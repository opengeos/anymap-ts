{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"anymap-ts","text":"<p>A Python package for creating interactive maps with anywidget and TypeScript</p> <ul> <li>GitHub repo: https://github.com/opengeos/anymap-ts</li> <li>Documentation: https://ts.anymap.dev</li> <li>PyPI: https://pypi.org/project/anymap-ts</li> <li>Free software: MIT License</li> </ul>"},{"location":"#features","title":"Features","text":"<ul> <li>Interactive maps in Jupyter notebooks</li> <li>Bidirectional Python-JavaScript communication via anywidget</li> <li>Drawing and geometry editing with maplibre-gl-geo-editor</li> <li>Layer control with maplibre-gl-layer-control</li> <li>Multiple basemap providers via xyzservices</li> <li>Export to standalone HTML</li> <li>TypeScript-based frontend for type safety and maintainability</li> </ul>"},{"location":"#supported-libraries","title":"Supported Libraries","text":"Library Description Use Case MapLibre GL JS Open-source vector maps Default, general-purpose mapping Mapbox GL JS Commercial vector maps Advanced styling, 3D terrain Leaflet Lightweight, mobile-friendly Simple maps, broad compatibility OpenLayers Feature-rich, enterprise WMS/WMTS, projections DeckGL GPU-accelerated Large-scale data visualization Cesium 3D globe 3D Tiles, terrain, global views KeplerGL Data exploration Interactive data analysis Potree Point clouds LiDAR visualization"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install anymap-ts\n</code></pre>"},{"location":"#quick-start","title":"Quick Start","text":"<pre><code>from anymap_ts import Map\n\n# Create a map centered on a location\nm = Map(center=[-122.4, 37.8], zoom=10)\nm.add_basemap(\"OpenStreetMap\")\nm.add_draw_control()\nm\n</code></pre>"},{"location":"anymap_ts/","title":"anymap_ts module","text":""},{"location":"anymap_ts/#anymap_ts.base","title":"<code>base</code>","text":"<p>Base MapWidget class for all map implementations.</p>"},{"location":"anymap_ts/#anymap_ts.base.MapWidget","title":"<code> MapWidget            (AnyWidget)         </code>","text":"<p>Base class for interactive map widgets.</p> <p>This class provides the core functionality for Python-JavaScript communication using anywidget's traitlet synchronization system.</p> Source code in <code>anymap_ts/base.py</code> <pre><code>class MapWidget(anywidget.AnyWidget):\n    \"\"\"Base class for interactive map widgets.\n\n    This class provides the core functionality for Python-JavaScript communication\n    using anywidget's traitlet synchronization system.\n    \"\"\"\n\n    # Synchronized traits for map state\n    center = traitlets.List([0.0, 0.0]).tag(sync=True)\n    zoom = traitlets.Float(2.0).tag(sync=True)\n    width = traitlets.Unicode(\"100%\").tag(sync=True)\n    height = traitlets.Unicode(\"400px\").tag(sync=True)\n    style = traitlets.Union([traitlets.Unicode(), traitlets.Dict()]).tag(sync=True)\n    max_pitch = traitlets.Float(85.0).tag(sync=True)\n\n    # JavaScript method call queue\n    _js_calls = traitlets.List([]).tag(sync=True)\n    _js_method_counter = traitlets.Int(0)\n\n    # Events from JavaScript\n    _js_events = traitlets.List([]).tag(sync=True)\n\n    # State persistence for layers, sources, and controls\n    _layers = traitlets.Dict({}).tag(sync=True)\n    _sources = traitlets.Dict({}).tag(sync=True)\n    _controls = traitlets.Dict({}).tag(sync=True)\n\n    # Interaction state\n    clicked = traitlets.Dict({}).tag(sync=True)\n    current_bounds = traitlets.List([]).tag(sync=True)\n    current_center = traitlets.List([]).tag(sync=True)\n    current_zoom = traitlets.Float(0.0).tag(sync=True)\n\n    # Drawing data\n    _draw_data = traitlets.Dict({}).tag(sync=True)\n\n    # Queried features (set by JS query methods)\n    _queried_features = traitlets.Dict({}).tag(sync=True)\n\n    def __init__(self, **kwargs):\n        \"\"\"Initialize the MapWidget.\n\n        Args:\n            **kwargs: Additional widget arguments\n        \"\"\"\n        super().__init__(**kwargs)\n        self._event_handlers: Dict[str, List[Callable]] = {}\n        self.observe(self._handle_js_events, names=[\"_js_events\"])\n\n    def _handle_js_events(self, change: Dict[str, Any]) -&gt; None:\n        \"\"\"Process events received from JavaScript.\n\n        Args:\n            change: Traitlet change dict\n        \"\"\"\n        events = change.get(\"new\", [])\n        for event in events:\n            event_type = event.get(\"type\")\n            if event_type in self._event_handlers:\n                for handler in self._event_handlers[event_type]:\n                    try:\n                        handler(event.get(\"data\"))\n                    except Exception as e:\n                        print(f\"Error in event handler for {event_type}: {e}\")\n        # Clear processed events\n        self._js_events = []\n\n    def call_js_method(self, method: str, *args, **kwargs) -&gt; None:\n        \"\"\"Queue a JavaScript method call.\n\n        Args:\n            method: Name of the JavaScript method to call\n            *args: Positional arguments for the method\n            **kwargs: Keyword arguments for the method\n        \"\"\"\n        self._js_method_counter += 1\n        call = {\n            \"id\": self._js_method_counter,\n            \"method\": method,\n            \"args\": list(args),\n            \"kwargs\": kwargs,\n        }\n        self._js_calls = self._js_calls + [call]\n\n    def on_map_event(self, event_type: str, handler: Callable) -&gt; None:\n        \"\"\"Register an event handler.\n\n        Args:\n            event_type: Type of event (e.g., 'click', 'moveend')\n            handler: Callback function to handle the event\n        \"\"\"\n        if event_type not in self._event_handlers:\n            self._event_handlers[event_type] = []\n        self._event_handlers[event_type].append(handler)\n\n    def off_map_event(\n        self, event_type: str, handler: Optional[Callable] = None\n    ) -&gt; None:\n        \"\"\"Unregister an event handler.\n\n        Args:\n            event_type: Type of event\n            handler: Specific handler to remove. If None, removes all handlers.\n        \"\"\"\n        if event_type in self._event_handlers:\n            if handler is None:\n                del self._event_handlers[event_type]\n            else:\n                self._event_handlers[event_type] = [\n                    h for h in self._event_handlers[event_type] if h != handler\n                ]\n\n    def set_center(self, lng: float, lat: float) -&gt; None:\n        \"\"\"Set the map center.\n\n        Args:\n            lng: Longitude\n            lat: Latitude\n        \"\"\"\n        self.center = [lng, lat]\n\n    def set_zoom(self, zoom: float) -&gt; None:\n        \"\"\"Set the map zoom level.\n\n        Args:\n            zoom: Zoom level\n        \"\"\"\n        self.zoom = zoom\n\n    def fly_to(\n        self,\n        lng: float,\n        lat: float,\n        zoom: Optional[float] = None,\n        duration: int = 2000,\n    ) -&gt; None:\n        \"\"\"Fly to a location with animation.\n\n        Args:\n            lng: Longitude\n            lat: Latitude\n            zoom: Optional zoom level\n            duration: Animation duration in milliseconds\n        \"\"\"\n        self.call_js_method(\"flyTo\", lng, lat, zoom=zoom, duration=duration)\n\n    def fit_bounds(\n        self,\n        bounds: List[float],\n        padding: int = 50,\n        duration: int = 1000,\n    ) -&gt; None:\n        \"\"\"Fit the map to the given bounds.\n\n        Args:\n            bounds: [west, south, east, north] bounds\n            padding: Padding in pixels\n            duration: Animation duration in milliseconds\n        \"\"\"\n        self.call_js_method(\"fitBounds\", bounds, padding=padding, duration=duration)\n\n    @property\n    def viewstate(self) -&gt; Dict[str, Any]:\n        \"\"\"Get current view state.\"\"\"\n        return {\n            \"center\": self.current_center or self.center,\n            \"zoom\": self.current_zoom or self.zoom,\n            \"bounds\": self.current_bounds,\n        }\n\n    def _generate_html_template(self) -&gt; str:\n        \"\"\"Generate HTML template for standalone export.\n\n        Override in subclasses for library-specific templates.\n        \"\"\"\n        raise NotImplementedError(\"Subclasses must implement _generate_html_template\")\n\n    def to_html(\n        self,\n        filepath: Optional[Union[str, Path]] = None,\n        title: str = \"Interactive Map\",\n    ) -&gt; Optional[str]:\n        \"\"\"Export map to standalone HTML file.\n\n        Args:\n            filepath: Path to save the HTML file. If None, returns HTML string.\n            title: Title for the HTML page.\n\n        Returns:\n            HTML string if filepath is None, otherwise None.\n        \"\"\"\n        html = self._generate_html_template()\n        html = html.replace(\"{{title}}\", title)\n\n        if filepath:\n            Path(filepath).write_text(html, encoding=\"utf-8\")\n            return None\n        return html\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.base.MapWidget.viewstate","title":"<code>viewstate: Dict[str, Any]</code>  <code>property</code> <code>readonly</code>","text":"<p>Get current view state.</p>"},{"location":"anymap_ts/#anymap_ts.base.MapWidget.__init__","title":"<code>__init__(self, **kwargs)</code>  <code>special</code>","text":"<p>Initialize the MapWidget.</p> <p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <p>Additional widget arguments</p> <code>{}</code> Source code in <code>anymap_ts/base.py</code> <pre><code>def __init__(self, **kwargs):\n    \"\"\"Initialize the MapWidget.\n\n    Args:\n        **kwargs: Additional widget arguments\n    \"\"\"\n    super().__init__(**kwargs)\n    self._event_handlers: Dict[str, List[Callable]] = {}\n    self.observe(self._handle_js_events, names=[\"_js_events\"])\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.base.MapWidget.call_js_method","title":"<code>call_js_method(self, method, *args, **kwargs)</code>","text":"<p>Queue a JavaScript method call.</p> <p>Parameters:</p> Name Type Description Default <code>method</code> <code>str</code> <p>Name of the JavaScript method to call</p> required <code>*args</code> <p>Positional arguments for the method</p> <code>()</code> <code>**kwargs</code> <p>Keyword arguments for the method</p> <code>{}</code> Source code in <code>anymap_ts/base.py</code> <pre><code>def call_js_method(self, method: str, *args, **kwargs) -&gt; None:\n    \"\"\"Queue a JavaScript method call.\n\n    Args:\n        method: Name of the JavaScript method to call\n        *args: Positional arguments for the method\n        **kwargs: Keyword arguments for the method\n    \"\"\"\n    self._js_method_counter += 1\n    call = {\n        \"id\": self._js_method_counter,\n        \"method\": method,\n        \"args\": list(args),\n        \"kwargs\": kwargs,\n    }\n    self._js_calls = self._js_calls + [call]\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.base.MapWidget.fit_bounds","title":"<code>fit_bounds(self, bounds, padding=50, duration=1000)</code>","text":"<p>Fit the map to the given bounds.</p> <p>Parameters:</p> Name Type Description Default <code>bounds</code> <code>List[float]</code> <p>[west, south, east, north] bounds</p> required <code>padding</code> <code>int</code> <p>Padding in pixels</p> <code>50</code> <code>duration</code> <code>int</code> <p>Animation duration in milliseconds</p> <code>1000</code> Source code in <code>anymap_ts/base.py</code> <pre><code>def fit_bounds(\n    self,\n    bounds: List[float],\n    padding: int = 50,\n    duration: int = 1000,\n) -&gt; None:\n    \"\"\"Fit the map to the given bounds.\n\n    Args:\n        bounds: [west, south, east, north] bounds\n        padding: Padding in pixels\n        duration: Animation duration in milliseconds\n    \"\"\"\n    self.call_js_method(\"fitBounds\", bounds, padding=padding, duration=duration)\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.base.MapWidget.fly_to","title":"<code>fly_to(self, lng, lat, zoom=None, duration=2000)</code>","text":"<p>Fly to a location with animation.</p> <p>Parameters:</p> Name Type Description Default <code>lng</code> <code>float</code> <p>Longitude</p> required <code>lat</code> <code>float</code> <p>Latitude</p> required <code>zoom</code> <code>Optional[float]</code> <p>Optional zoom level</p> <code>None</code> <code>duration</code> <code>int</code> <p>Animation duration in milliseconds</p> <code>2000</code> Source code in <code>anymap_ts/base.py</code> <pre><code>def fly_to(\n    self,\n    lng: float,\n    lat: float,\n    zoom: Optional[float] = None,\n    duration: int = 2000,\n) -&gt; None:\n    \"\"\"Fly to a location with animation.\n\n    Args:\n        lng: Longitude\n        lat: Latitude\n        zoom: Optional zoom level\n        duration: Animation duration in milliseconds\n    \"\"\"\n    self.call_js_method(\"flyTo\", lng, lat, zoom=zoom, duration=duration)\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.base.MapWidget.off_map_event","title":"<code>off_map_event(self, event_type, handler=None)</code>","text":"<p>Unregister an event handler.</p> <p>Parameters:</p> Name Type Description Default <code>event_type</code> <code>str</code> <p>Type of event</p> required <code>handler</code> <code>Optional[Callable]</code> <p>Specific handler to remove. If None, removes all handlers.</p> <code>None</code> Source code in <code>anymap_ts/base.py</code> <pre><code>def off_map_event(\n    self, event_type: str, handler: Optional[Callable] = None\n) -&gt; None:\n    \"\"\"Unregister an event handler.\n\n    Args:\n        event_type: Type of event\n        handler: Specific handler to remove. If None, removes all handlers.\n    \"\"\"\n    if event_type in self._event_handlers:\n        if handler is None:\n            del self._event_handlers[event_type]\n        else:\n            self._event_handlers[event_type] = [\n                h for h in self._event_handlers[event_type] if h != handler\n            ]\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.base.MapWidget.on_map_event","title":"<code>on_map_event(self, event_type, handler)</code>","text":"<p>Register an event handler.</p> <p>Parameters:</p> Name Type Description Default <code>event_type</code> <code>str</code> <p>Type of event (e.g., 'click', 'moveend')</p> required <code>handler</code> <code>Callable</code> <p>Callback function to handle the event</p> required Source code in <code>anymap_ts/base.py</code> <pre><code>def on_map_event(self, event_type: str, handler: Callable) -&gt; None:\n    \"\"\"Register an event handler.\n\n    Args:\n        event_type: Type of event (e.g., 'click', 'moveend')\n        handler: Callback function to handle the event\n    \"\"\"\n    if event_type not in self._event_handlers:\n        self._event_handlers[event_type] = []\n    self._event_handlers[event_type].append(handler)\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.base.MapWidget.set_center","title":"<code>set_center(self, lng, lat)</code>","text":"<p>Set the map center.</p> <p>Parameters:</p> Name Type Description Default <code>lng</code> <code>float</code> <p>Longitude</p> required <code>lat</code> <code>float</code> <p>Latitude</p> required Source code in <code>anymap_ts/base.py</code> <pre><code>def set_center(self, lng: float, lat: float) -&gt; None:\n    \"\"\"Set the map center.\n\n    Args:\n        lng: Longitude\n        lat: Latitude\n    \"\"\"\n    self.center = [lng, lat]\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.base.MapWidget.set_zoom","title":"<code>set_zoom(self, zoom)</code>","text":"<p>Set the map zoom level.</p> <p>Parameters:</p> Name Type Description Default <code>zoom</code> <code>float</code> <p>Zoom level</p> required Source code in <code>anymap_ts/base.py</code> <pre><code>def set_zoom(self, zoom: float) -&gt; None:\n    \"\"\"Set the map zoom level.\n\n    Args:\n        zoom: Zoom level\n    \"\"\"\n    self.zoom = zoom\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.base.MapWidget.to_html","title":"<code>to_html(self, filepath=None, title='Interactive Map')</code>","text":"<p>Export map to standalone HTML file.</p> <p>Parameters:</p> Name Type Description Default <code>filepath</code> <code>Optional[Union[str, Path]]</code> <p>Path to save the HTML file. If None, returns HTML string.</p> <code>None</code> <code>title</code> <code>str</code> <p>Title for the HTML page.</p> <code>'Interactive Map'</code> <p>Returns:</p> Type Description <code>Optional[str]</code> <p>HTML string if filepath is None, otherwise None.</p> Source code in <code>anymap_ts/base.py</code> <pre><code>def to_html(\n    self,\n    filepath: Optional[Union[str, Path]] = None,\n    title: str = \"Interactive Map\",\n) -&gt; Optional[str]:\n    \"\"\"Export map to standalone HTML file.\n\n    Args:\n        filepath: Path to save the HTML file. If None, returns HTML string.\n        title: Title for the HTML page.\n\n    Returns:\n        HTML string if filepath is None, otherwise None.\n    \"\"\"\n    html = self._generate_html_template()\n    html = html.replace(\"{{title}}\", title)\n\n    if filepath:\n        Path(filepath).write_text(html, encoding=\"utf-8\")\n        return None\n    return html\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.basemaps","title":"<code>basemaps</code>","text":"<p>Basemap provider utilities.</p>"},{"location":"anymap_ts/#anymap_ts.basemaps.get_basemap_names","title":"<code>get_basemap_names()</code>","text":"<p>Get list of available basemap names.</p> <p>Returns:</p> Type Description <code>list</code> <p>List of basemap provider names</p> Source code in <code>anymap_ts/basemaps.py</code> <pre><code>def get_basemap_names() -&gt; list:\n    \"\"\"Get list of available basemap names.\n\n    Returns:\n        List of basemap provider names\n    \"\"\"\n    return list(xyz.flatten().keys())\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.basemaps.get_basemap_url","title":"<code>get_basemap_url(name)</code>","text":"<p>Get tile URL and attribution for a named basemap.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Basemap provider name (e.g., \"OpenStreetMap\", \"CartoDB.Positron\")</p> required <p>Returns:</p> Type Description <code>Tuple[str, str]</code> <p>Tuple of (tile_url, attribution)</p> <p>Exceptions:</p> Type Description <code>ValueError</code> <p>If basemap name is not found</p> Source code in <code>anymap_ts/basemaps.py</code> <pre><code>def get_basemap_url(name: str) -&gt; Tuple[str, str]:\n    \"\"\"Get tile URL and attribution for a named basemap.\n\n    Args:\n        name: Basemap provider name (e.g., \"OpenStreetMap\", \"CartoDB.Positron\")\n\n    Returns:\n        Tuple of (tile_url, attribution)\n\n    Raises:\n        ValueError: If basemap name is not found\n    \"\"\"\n    # Handle shortcuts\n    if name in BASEMAP_SHORTCUTS:\n        name = BASEMAP_SHORTCUTS[name]\n\n    # Handle dot notation for nested providers\n    parts = name.split(\".\")\n    provider = xyz\n    for part in parts:\n        provider = getattr(provider, part, None)\n        if provider is None:\n            raise ValueError(f\"Unknown basemap: {name}\")\n\n    url = provider.build_url()\n    attribution = provider.get(\"attribution\", \"\")\n\n    return url, attribution\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.basemaps.get_maplibre_style","title":"<code>get_maplibre_style(name)</code>","text":"<p>Get MapLibre style URL by name.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Style name (e.g., \"positron\", \"dark-matter\")</p> required <p>Returns:</p> Type Description <code>str</code> <p>Style URL</p> <p>Exceptions:</p> Type Description <code>ValueError</code> <p>If style name is not found</p> Source code in <code>anymap_ts/basemaps.py</code> <pre><code>def get_maplibre_style(name: str) -&gt; str:\n    \"\"\"Get MapLibre style URL by name.\n\n    Args:\n        name: Style name (e.g., \"positron\", \"dark-matter\")\n\n    Returns:\n        Style URL\n\n    Raises:\n        ValueError: If style name is not found\n    \"\"\"\n    name_lower = name.lower().replace(\"_\", \"-\")\n    if name_lower in MAPLIBRE_STYLES:\n        return MAPLIBRE_STYLES[name_lower]\n    # Assume it's already a URL\n    if name.startswith(\"http\"):\n        return name\n    raise ValueError(f\"Unknown MapLibre style: {name}\")\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.cesium","title":"<code>cesium</code>","text":"<p>Cesium 3D globe widget implementation.</p>"},{"location":"anymap_ts/#anymap_ts.cesium.CesiumMap","title":"<code> CesiumMap            (MapWidget)         </code>","text":"<p>Interactive 3D globe widget using Cesium.</p> <p>This class provides a Python interface to Cesium for 3D globe visualization with terrain, 3D Tiles, and imagery layer support.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from anymap_ts import CesiumMap\n&gt;&gt;&gt; m = CesiumMap(center=[-122.4, 37.8], zoom=10)\n&gt;&gt;&gt; m.set_terrain()  # Enable Cesium World Terrain\n&gt;&gt;&gt; m.add_3d_tileset(url=\"path/to/tileset.json\")\n&gt;&gt;&gt; m\n</code></pre> Source code in <code>anymap_ts/cesium.py</code> <pre><code>class CesiumMap(MapWidget):\n    \"\"\"Interactive 3D globe widget using Cesium.\n\n    This class provides a Python interface to Cesium for 3D globe\n    visualization with terrain, 3D Tiles, and imagery layer support.\n\n    Example:\n        &gt;&gt;&gt; from anymap_ts import CesiumMap\n        &gt;&gt;&gt; m = CesiumMap(center=[-122.4, 37.8], zoom=10)\n        &gt;&gt;&gt; m.set_terrain()  # Enable Cesium World Terrain\n        &gt;&gt;&gt; m.add_3d_tileset(url=\"path/to/tileset.json\")\n        &gt;&gt;&gt; m\n    \"\"\"\n\n    # ESM module for frontend\n    _esm = STATIC_DIR / \"cesium.js\"\n    _css = STATIC_DIR / \"cesium.css\"\n\n    # Cesium-specific traits\n    access_token = traitlets.Unicode(\"\").tag(sync=True)\n\n    # Camera position traits\n    camera_height = traitlets.Float(10000000).tag(sync=True)\n    heading = traitlets.Float(0.0).tag(sync=True)\n    pitch = traitlets.Float(-90.0).tag(sync=True)\n    roll = traitlets.Float(0.0).tag(sync=True)\n\n    # Terrain\n    terrain_enabled = traitlets.Bool(False).tag(sync=True)\n\n    def __init__(\n        self,\n        center: Tuple[float, float] = (0.0, 0.0),\n        zoom: float = 2.0,\n        width: str = \"100%\",\n        height: str = \"600px\",\n        access_token: Optional[str] = None,\n        terrain: bool = False,\n        **kwargs,\n    ):\n        \"\"\"Initialize a Cesium 3D globe.\n\n        Args:\n            center: Globe center as (longitude, latitude).\n            zoom: Initial zoom level (converted to camera height).\n            width: Widget width as CSS string.\n            height: Widget height as CSS string.\n            access_token: Cesium Ion access token (uses CESIUM_TOKEN env var if not provided).\n            terrain: Whether to enable terrain on initialization.\n            **kwargs: Additional widget arguments.\n        \"\"\"\n        # Get access token from env if not provided\n        if access_token is None:\n            access_token = get_cesium_token()\n\n        super().__init__(\n            center=list(center),\n            zoom=zoom,\n            width=width,\n            height=height,\n            access_token=access_token,\n            terrain_enabled=terrain,\n            **kwargs,\n        )\n\n        # Enable terrain if requested\n        if terrain:\n            self.set_terrain()\n\n    # -------------------------------------------------------------------------\n    # Basemap/Imagery Methods\n    # -------------------------------------------------------------------------\n\n    def add_basemap(\n        self,\n        basemap: str = \"OpenStreetMap\",\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a basemap imagery layer.\n\n        Args:\n            basemap: Name of basemap (e.g., \"OpenStreetMap\", \"Bing\").\n            **kwargs: Additional options.\n        \"\"\"\n        # Common basemap URLs\n        basemap_urls = {\n            \"OpenStreetMap\": \"https://tile.openstreetmap.org/{z}/{x}/{y}.png\",\n            \"CartoDB.Positron\": \"https://a.basemaps.cartocdn.com/light_all/{z}/{x}/{y}.png\",\n            \"CartoDB.DarkMatter\": \"https://a.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}.png\",\n            \"Stamen.Terrain\": \"https://tiles.stadiamaps.com/tiles/stamen_terrain/{z}/{x}/{y}.png\",\n        }\n\n        url = basemap_urls.get(basemap, basemap_urls[\"OpenStreetMap\"])\n\n        self.call_js_method(\"addBasemap\", url, name=basemap, **kwargs)\n\n    def add_imagery_layer(\n        self,\n        url: str,\n        name: Optional[str] = None,\n        layer_type: str = \"xyz\",\n        alpha: float = 1.0,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add an imagery layer.\n\n        Args:\n            url: Imagery URL or service endpoint.\n            name: Layer name.\n            layer_type: Type of imagery ('xyz', 'wms', 'wmts', 'arcgis').\n            alpha: Layer opacity (0-1).\n            **kwargs: Additional options (layers, parameters for WMS, etc.).\n        \"\"\"\n        layer_id = name or f\"imagery-{len(self._layers)}\"\n\n        self.call_js_method(\n            \"addImageryLayer\",\n            url=url,\n            name=layer_id,\n            type=layer_type,\n            alpha=alpha,\n            **kwargs,\n        )\n\n        self._layers = {\n            **self._layers,\n            layer_id: {\"id\": layer_id, \"type\": \"imagery\"},\n        }\n\n    def remove_imagery_layer(self, name: str) -&gt; None:\n        \"\"\"Remove an imagery layer.\n\n        Args:\n            name: Layer name to remove.\n        \"\"\"\n        if name in self._layers:\n            layers = dict(self._layers)\n            del layers[name]\n            self._layers = layers\n        self.call_js_method(\"removeImageryLayer\", name)\n\n    # -------------------------------------------------------------------------\n    # Terrain Methods\n    # -------------------------------------------------------------------------\n\n    def set_terrain(\n        self,\n        url: Optional[str] = None,\n        request_vertex_normals: bool = True,\n        request_water_mask: bool = True,\n    ) -&gt; None:\n        \"\"\"Enable terrain.\n\n        Args:\n            url: Terrain provider URL. If None, uses Cesium World Terrain (requires Ion token).\n            request_vertex_normals: Request vertex normals for lighting.\n            request_water_mask: Request water mask for water effects.\n        \"\"\"\n        self.terrain_enabled = True\n        self.call_js_method(\n            \"setTerrain\",\n            url=url or \"cesium-world-terrain\",\n            requestVertexNormals=request_vertex_normals,\n            requestWaterMask=request_water_mask,\n        )\n\n    def remove_terrain(self) -&gt; None:\n        \"\"\"Disable terrain and use ellipsoid.\"\"\"\n        self.terrain_enabled = False\n        self.call_js_method(\"removeTerrain\")\n\n    # -------------------------------------------------------------------------\n    # 3D Tiles Methods\n    # -------------------------------------------------------------------------\n\n    def add_3d_tileset(\n        self,\n        url: Union[str, int],\n        name: Optional[str] = None,\n        maximum_screen_space_error: float = 16,\n        fly_to: bool = True,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a 3D Tileset.\n\n        Args:\n            url: URL to tileset.json or Cesium Ion asset ID.\n            name: Tileset name.\n            maximum_screen_space_error: Maximum screen space error for LOD.\n            fly_to: Whether to fly to the tileset after loading.\n            **kwargs: Additional options.\n        \"\"\"\n        layer_id = name or f\"tileset-{len(self._layers)}\"\n\n        self.call_js_method(\n            \"add3DTileset\",\n            url=str(url),\n            name=layer_id,\n            maximumScreenSpaceError=maximum_screen_space_error,\n            flyTo=fly_to,\n            **kwargs,\n        )\n\n        self._layers = {\n            **self._layers,\n            layer_id: {\"id\": layer_id, \"type\": \"3dtiles\"},\n        }\n\n    def remove_3d_tileset(self, name: str) -&gt; None:\n        \"\"\"Remove a 3D Tileset.\n\n        Args:\n            name: Tileset name to remove.\n        \"\"\"\n        if name in self._layers:\n            layers = dict(self._layers)\n            del layers[name]\n            self._layers = layers\n        self.call_js_method(\"remove3DTileset\", name)\n\n    # -------------------------------------------------------------------------\n    # GeoJSON Methods\n    # -------------------------------------------------------------------------\n\n    def add_geojson(\n        self,\n        data: Any,\n        name: Optional[str] = None,\n        stroke: str = \"#3388ff\",\n        stroke_width: float = 2,\n        fill: str = \"rgba(51, 136, 255, 0.5)\",\n        clamp_to_ground: bool = True,\n        fly_to: bool = True,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add GeoJSON data.\n\n        Args:\n            data: GeoJSON dict or file path.\n            name: Data source name.\n            stroke: Stroke color.\n            stroke_width: Stroke width.\n            fill: Fill color.\n            clamp_to_ground: Whether to clamp features to terrain.\n            fly_to: Whether to fly to the data after loading.\n            **kwargs: Additional options.\n        \"\"\"\n        geojson = to_geojson(data)\n        layer_id = name or f\"geojson-{len(self._layers)}\"\n\n        self.call_js_method(\n            \"addGeoJSON\",\n            data=geojson,\n            name=layer_id,\n            stroke=stroke,\n            strokeWidth=stroke_width,\n            fill=fill,\n            clampToGround=clamp_to_ground,\n            flyTo=fly_to,\n            **kwargs,\n        )\n\n        self._layers = {\n            **self._layers,\n            layer_id: {\"id\": layer_id, \"type\": \"geojson\"},\n        }\n\n    def remove_data_source(self, name: str) -&gt; None:\n        \"\"\"Remove a data source (GeoJSON, etc.).\n\n        Args:\n            name: Data source name to remove.\n        \"\"\"\n        if name in self._layers:\n            layers = dict(self._layers)\n            del layers[name]\n            self._layers = layers\n        self.call_js_method(\"removeDataSource\", name)\n\n    # -------------------------------------------------------------------------\n    # Camera Methods\n    # -------------------------------------------------------------------------\n\n    def fly_to(\n        self,\n        lng: float,\n        lat: float,\n        height: Optional[float] = None,\n        zoom: Optional[float] = None,\n        heading: float = 0,\n        pitch: float = -90,\n        roll: float = 0,\n        duration: float = 2,\n    ) -&gt; None:\n        \"\"\"Fly to a location.\n\n        Args:\n            lng: Target longitude.\n            lat: Target latitude.\n            height: Camera height in meters (overrides zoom).\n            zoom: Zoom level (converted to height if height not provided).\n            heading: Camera heading in degrees.\n            pitch: Camera pitch in degrees (default -90 = looking down).\n            roll: Camera roll in degrees.\n            duration: Flight duration in seconds.\n        \"\"\"\n        self.call_js_method(\n            \"flyTo\",\n            lng,\n            lat,\n            height=height,\n            zoom=zoom,\n            heading=heading,\n            pitch=pitch,\n            roll=roll,\n            duration=duration,\n        )\n\n    def zoom_to(self, target: str) -&gt; None:\n        \"\"\"Zoom to a layer or data source.\n\n        Args:\n            target: Name of the layer or data source to zoom to.\n        \"\"\"\n        self.call_js_method(\"zoomTo\", target=target)\n\n    def set_camera(\n        self,\n        longitude: float = 0,\n        latitude: float = 0,\n        height: float = 10000000,\n        heading: float = 0,\n        pitch: float = -90,\n        roll: float = 0,\n    ) -&gt; None:\n        \"\"\"Set the camera position immediately (no animation).\n\n        Args:\n            longitude: Camera longitude.\n            latitude: Camera latitude.\n            height: Camera height in meters.\n            heading: Camera heading in degrees.\n            pitch: Camera pitch in degrees.\n            roll: Camera roll in degrees.\n        \"\"\"\n        self.call_js_method(\n            \"setCamera\",\n            longitude=longitude,\n            latitude=latitude,\n            height=height,\n            heading=heading,\n            pitch=pitch,\n            roll=roll,\n        )\n\n    def reset_view(self, duration: float = 2) -&gt; None:\n        \"\"\"Reset camera to home position.\n\n        Args:\n            duration: Animation duration in seconds.\n        \"\"\"\n        self.call_js_method(\"resetView\", duration=duration)\n\n    # -------------------------------------------------------------------------\n    # Layer Management\n    # -------------------------------------------------------------------------\n\n    def set_visibility(self, name: str, visible: bool) -&gt; None:\n        \"\"\"Set layer visibility.\n\n        Args:\n            name: Layer name.\n            visible: Whether layer should be visible.\n        \"\"\"\n        self.call_js_method(\"setVisibility\", name, visible)\n\n    def set_opacity(self, name: str, opacity: float) -&gt; None:\n        \"\"\"Set layer opacity (imagery layers only).\n\n        Args:\n            name: Layer name.\n            opacity: Opacity value (0-1).\n        \"\"\"\n        self.call_js_method(\"setOpacity\", name, opacity)\n\n    # -------------------------------------------------------------------------\n    # HTML Export\n    # -------------------------------------------------------------------------\n\n    def _generate_html_template(self) -&gt; str:\n        \"\"\"Generate standalone HTML for the globe.\"\"\"\n        template_path = Path(__file__).parent / \"templates\" / \"cesium.html\"\n\n        if template_path.exists():\n            template = template_path.read_text(encoding=\"utf-8\")\n        else:\n            template = self._get_default_template()\n\n        state = {\n            \"center\": self.center,\n            \"zoom\": self.zoom,\n            \"access_token\": self.access_token,\n            \"terrain_enabled\": self.terrain_enabled,\n            \"width\": self.width,\n            \"height\": self.height,\n            \"layers\": self._layers,\n            \"js_calls\": self._js_calls,\n        }\n\n        template = template.replace(\"{{state}}\", json.dumps(state, indent=2))\n        template = template.replace(\"{{access_token}}\", self.access_token)\n        return template\n\n    def _get_default_template(self) -&gt; str:\n        \"\"\"Get default HTML template.\"\"\"\n        return \"\"\"&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n    &lt;meta charset=\"utf-8\"&gt;\n    &lt;title&gt;Cesium Globe&lt;/title&gt;\n    &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"&gt;\n    &lt;script src=\"https://cesium.com/downloads/cesiumjs/releases/1.120/Build/Cesium/Cesium.js\"&gt;&lt;/script&gt;\n    &lt;link href=\"https://cesium.com/downloads/cesiumjs/releases/1.120/Build/Cesium/Widgets/widgets.css\" rel=\"stylesheet\"&gt;\n    &lt;style&gt;\n        * { margin: 0; padding: 0; box-sizing: border-box; }\n        html, body { height: 100%; }\n        #cesiumContainer { position: absolute; top: 0; bottom: 0; width: 100%; }\n    &lt;/style&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;div id=\"cesiumContainer\"&gt;&lt;/div&gt;\n    &lt;script&gt;\n        const state = {{state}};\n\n        if (state.access_token) {\n            Cesium.Ion.defaultAccessToken = state.access_token;\n        }\n\n        const viewer = new Cesium.Viewer('cesiumContainer', {\n            baseLayerPicker: false,\n            geocoder: false,\n            homeButton: false,\n            sceneModePicker: false,\n            navigationHelpButton: false,\n            animation: false,\n            timeline: false\n        });\n\n        for (const call of state.js_calls || []) {\n            executeMethod(call.method, call.args, call.kwargs);\n        }\n\n        function executeMethod(method, args, kwargs) {\n            console.log('Executing:', method, args, kwargs);\n        }\n    &lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\"\"\"\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.cesium.CesiumMap.__init__","title":"<code>__init__(self, center=(0.0, 0.0), zoom=2.0, width='100%', height='600px', access_token=None, terrain=False, **kwargs)</code>  <code>special</code>","text":"<p>Initialize a Cesium 3D globe.</p> <p>Parameters:</p> Name Type Description Default <code>center</code> <code>Tuple[float, float]</code> <p>Globe center as (longitude, latitude).</p> <code>(0.0, 0.0)</code> <code>zoom</code> <code>float</code> <p>Initial zoom level (converted to camera height).</p> <code>2.0</code> <code>width</code> <code>str</code> <p>Widget width as CSS string.</p> <code>'100%'</code> <code>height</code> <code>str</code> <p>Widget height as CSS string.</p> <code>'600px'</code> <code>access_token</code> <code>Optional[str]</code> <p>Cesium Ion access token (uses CESIUM_TOKEN env var if not provided).</p> <code>None</code> <code>terrain</code> <code>bool</code> <p>Whether to enable terrain on initialization.</p> <code>False</code> <code>**kwargs</code> <p>Additional widget arguments.</p> <code>{}</code> Source code in <code>anymap_ts/cesium.py</code> <pre><code>def __init__(\n    self,\n    center: Tuple[float, float] = (0.0, 0.0),\n    zoom: float = 2.0,\n    width: str = \"100%\",\n    height: str = \"600px\",\n    access_token: Optional[str] = None,\n    terrain: bool = False,\n    **kwargs,\n):\n    \"\"\"Initialize a Cesium 3D globe.\n\n    Args:\n        center: Globe center as (longitude, latitude).\n        zoom: Initial zoom level (converted to camera height).\n        width: Widget width as CSS string.\n        height: Widget height as CSS string.\n        access_token: Cesium Ion access token (uses CESIUM_TOKEN env var if not provided).\n        terrain: Whether to enable terrain on initialization.\n        **kwargs: Additional widget arguments.\n    \"\"\"\n    # Get access token from env if not provided\n    if access_token is None:\n        access_token = get_cesium_token()\n\n    super().__init__(\n        center=list(center),\n        zoom=zoom,\n        width=width,\n        height=height,\n        access_token=access_token,\n        terrain_enabled=terrain,\n        **kwargs,\n    )\n\n    # Enable terrain if requested\n    if terrain:\n        self.set_terrain()\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.cesium.CesiumMap.add_3d_tileset","title":"<code>add_3d_tileset(self, url, name=None, maximum_screen_space_error=16, fly_to=True, **kwargs)</code>","text":"<p>Add a 3D Tileset.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>Union[str, int]</code> <p>URL to tileset.json or Cesium Ion asset ID.</p> required <code>name</code> <code>Optional[str]</code> <p>Tileset name.</p> <code>None</code> <code>maximum_screen_space_error</code> <code>float</code> <p>Maximum screen space error for LOD.</p> <code>16</code> <code>fly_to</code> <code>bool</code> <p>Whether to fly to the tileset after loading.</p> <code>True</code> <code>**kwargs</code> <p>Additional options.</p> <code>{}</code> Source code in <code>anymap_ts/cesium.py</code> <pre><code>def add_3d_tileset(\n    self,\n    url: Union[str, int],\n    name: Optional[str] = None,\n    maximum_screen_space_error: float = 16,\n    fly_to: bool = True,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a 3D Tileset.\n\n    Args:\n        url: URL to tileset.json or Cesium Ion asset ID.\n        name: Tileset name.\n        maximum_screen_space_error: Maximum screen space error for LOD.\n        fly_to: Whether to fly to the tileset after loading.\n        **kwargs: Additional options.\n    \"\"\"\n    layer_id = name or f\"tileset-{len(self._layers)}\"\n\n    self.call_js_method(\n        \"add3DTileset\",\n        url=str(url),\n        name=layer_id,\n        maximumScreenSpaceError=maximum_screen_space_error,\n        flyTo=fly_to,\n        **kwargs,\n    )\n\n    self._layers = {\n        **self._layers,\n        layer_id: {\"id\": layer_id, \"type\": \"3dtiles\"},\n    }\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.cesium.CesiumMap.add_basemap","title":"<code>add_basemap(self, basemap='OpenStreetMap', **kwargs)</code>","text":"<p>Add a basemap imagery layer.</p> <p>Parameters:</p> Name Type Description Default <code>basemap</code> <code>str</code> <p>Name of basemap (e.g., \"OpenStreetMap\", \"Bing\").</p> <code>'OpenStreetMap'</code> <code>**kwargs</code> <p>Additional options.</p> <code>{}</code> Source code in <code>anymap_ts/cesium.py</code> <pre><code>def add_basemap(\n    self,\n    basemap: str = \"OpenStreetMap\",\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a basemap imagery layer.\n\n    Args:\n        basemap: Name of basemap (e.g., \"OpenStreetMap\", \"Bing\").\n        **kwargs: Additional options.\n    \"\"\"\n    # Common basemap URLs\n    basemap_urls = {\n        \"OpenStreetMap\": \"https://tile.openstreetmap.org/{z}/{x}/{y}.png\",\n        \"CartoDB.Positron\": \"https://a.basemaps.cartocdn.com/light_all/{z}/{x}/{y}.png\",\n        \"CartoDB.DarkMatter\": \"https://a.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}.png\",\n        \"Stamen.Terrain\": \"https://tiles.stadiamaps.com/tiles/stamen_terrain/{z}/{x}/{y}.png\",\n    }\n\n    url = basemap_urls.get(basemap, basemap_urls[\"OpenStreetMap\"])\n\n    self.call_js_method(\"addBasemap\", url, name=basemap, **kwargs)\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.cesium.CesiumMap.add_geojson","title":"<code>add_geojson(self, data, name=None, stroke='#3388ff', stroke_width=2, fill='rgba(51, 136, 255, 0.5)', clamp_to_ground=True, fly_to=True, **kwargs)</code>","text":"<p>Add GeoJSON data.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>GeoJSON dict or file path.</p> required <code>name</code> <code>Optional[str]</code> <p>Data source name.</p> <code>None</code> <code>stroke</code> <code>str</code> <p>Stroke color.</p> <code>'#3388ff'</code> <code>stroke_width</code> <code>float</code> <p>Stroke width.</p> <code>2</code> <code>fill</code> <code>str</code> <p>Fill color.</p> <code>'rgba(51, 136, 255, 0.5)'</code> <code>clamp_to_ground</code> <code>bool</code> <p>Whether to clamp features to terrain.</p> <code>True</code> <code>fly_to</code> <code>bool</code> <p>Whether to fly to the data after loading.</p> <code>True</code> <code>**kwargs</code> <p>Additional options.</p> <code>{}</code> Source code in <code>anymap_ts/cesium.py</code> <pre><code>def add_geojson(\n    self,\n    data: Any,\n    name: Optional[str] = None,\n    stroke: str = \"#3388ff\",\n    stroke_width: float = 2,\n    fill: str = \"rgba(51, 136, 255, 0.5)\",\n    clamp_to_ground: bool = True,\n    fly_to: bool = True,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add GeoJSON data.\n\n    Args:\n        data: GeoJSON dict or file path.\n        name: Data source name.\n        stroke: Stroke color.\n        stroke_width: Stroke width.\n        fill: Fill color.\n        clamp_to_ground: Whether to clamp features to terrain.\n        fly_to: Whether to fly to the data after loading.\n        **kwargs: Additional options.\n    \"\"\"\n    geojson = to_geojson(data)\n    layer_id = name or f\"geojson-{len(self._layers)}\"\n\n    self.call_js_method(\n        \"addGeoJSON\",\n        data=geojson,\n        name=layer_id,\n        stroke=stroke,\n        strokeWidth=stroke_width,\n        fill=fill,\n        clampToGround=clamp_to_ground,\n        flyTo=fly_to,\n        **kwargs,\n    )\n\n    self._layers = {\n        **self._layers,\n        layer_id: {\"id\": layer_id, \"type\": \"geojson\"},\n    }\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.cesium.CesiumMap.add_imagery_layer","title":"<code>add_imagery_layer(self, url, name=None, layer_type='xyz', alpha=1.0, **kwargs)</code>","text":"<p>Add an imagery layer.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>Imagery URL or service endpoint.</p> required <code>name</code> <code>Optional[str]</code> <p>Layer name.</p> <code>None</code> <code>layer_type</code> <code>str</code> <p>Type of imagery ('xyz', 'wms', 'wmts', 'arcgis').</p> <code>'xyz'</code> <code>alpha</code> <code>float</code> <p>Layer opacity (0-1).</p> <code>1.0</code> <code>**kwargs</code> <p>Additional options (layers, parameters for WMS, etc.).</p> <code>{}</code> Source code in <code>anymap_ts/cesium.py</code> <pre><code>def add_imagery_layer(\n    self,\n    url: str,\n    name: Optional[str] = None,\n    layer_type: str = \"xyz\",\n    alpha: float = 1.0,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add an imagery layer.\n\n    Args:\n        url: Imagery URL or service endpoint.\n        name: Layer name.\n        layer_type: Type of imagery ('xyz', 'wms', 'wmts', 'arcgis').\n        alpha: Layer opacity (0-1).\n        **kwargs: Additional options (layers, parameters for WMS, etc.).\n    \"\"\"\n    layer_id = name or f\"imagery-{len(self._layers)}\"\n\n    self.call_js_method(\n        \"addImageryLayer\",\n        url=url,\n        name=layer_id,\n        type=layer_type,\n        alpha=alpha,\n        **kwargs,\n    )\n\n    self._layers = {\n        **self._layers,\n        layer_id: {\"id\": layer_id, \"type\": \"imagery\"},\n    }\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.cesium.CesiumMap.fly_to","title":"<code>fly_to(self, lng, lat, height=None, zoom=None, heading=0, pitch=-90, roll=0, duration=2)</code>","text":"<p>Fly to a location.</p> <p>Parameters:</p> Name Type Description Default <code>lng</code> <code>float</code> <p>Target longitude.</p> required <code>lat</code> <code>float</code> <p>Target latitude.</p> required <code>height</code> <code>Optional[float]</code> <p>Camera height in meters (overrides zoom).</p> <code>None</code> <code>zoom</code> <code>Optional[float]</code> <p>Zoom level (converted to height if height not provided).</p> <code>None</code> <code>heading</code> <code>float</code> <p>Camera heading in degrees.</p> <code>0</code> <code>pitch</code> <code>float</code> <p>Camera pitch in degrees (default -90 = looking down).</p> <code>-90</code> <code>roll</code> <code>float</code> <p>Camera roll in degrees.</p> <code>0</code> <code>duration</code> <code>float</code> <p>Flight duration in seconds.</p> <code>2</code> Source code in <code>anymap_ts/cesium.py</code> <pre><code>def fly_to(\n    self,\n    lng: float,\n    lat: float,\n    height: Optional[float] = None,\n    zoom: Optional[float] = None,\n    heading: float = 0,\n    pitch: float = -90,\n    roll: float = 0,\n    duration: float = 2,\n) -&gt; None:\n    \"\"\"Fly to a location.\n\n    Args:\n        lng: Target longitude.\n        lat: Target latitude.\n        height: Camera height in meters (overrides zoom).\n        zoom: Zoom level (converted to height if height not provided).\n        heading: Camera heading in degrees.\n        pitch: Camera pitch in degrees (default -90 = looking down).\n        roll: Camera roll in degrees.\n        duration: Flight duration in seconds.\n    \"\"\"\n    self.call_js_method(\n        \"flyTo\",\n        lng,\n        lat,\n        height=height,\n        zoom=zoom,\n        heading=heading,\n        pitch=pitch,\n        roll=roll,\n        duration=duration,\n    )\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.cesium.CesiumMap.remove_3d_tileset","title":"<code>remove_3d_tileset(self, name)</code>","text":"<p>Remove a 3D Tileset.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Tileset name to remove.</p> required Source code in <code>anymap_ts/cesium.py</code> <pre><code>def remove_3d_tileset(self, name: str) -&gt; None:\n    \"\"\"Remove a 3D Tileset.\n\n    Args:\n        name: Tileset name to remove.\n    \"\"\"\n    if name in self._layers:\n        layers = dict(self._layers)\n        del layers[name]\n        self._layers = layers\n    self.call_js_method(\"remove3DTileset\", name)\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.cesium.CesiumMap.remove_data_source","title":"<code>remove_data_source(self, name)</code>","text":"<p>Remove a data source (GeoJSON, etc.).</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Data source name to remove.</p> required Source code in <code>anymap_ts/cesium.py</code> <pre><code>def remove_data_source(self, name: str) -&gt; None:\n    \"\"\"Remove a data source (GeoJSON, etc.).\n\n    Args:\n        name: Data source name to remove.\n    \"\"\"\n    if name in self._layers:\n        layers = dict(self._layers)\n        del layers[name]\n        self._layers = layers\n    self.call_js_method(\"removeDataSource\", name)\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.cesium.CesiumMap.remove_imagery_layer","title":"<code>remove_imagery_layer(self, name)</code>","text":"<p>Remove an imagery layer.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Layer name to remove.</p> required Source code in <code>anymap_ts/cesium.py</code> <pre><code>def remove_imagery_layer(self, name: str) -&gt; None:\n    \"\"\"Remove an imagery layer.\n\n    Args:\n        name: Layer name to remove.\n    \"\"\"\n    if name in self._layers:\n        layers = dict(self._layers)\n        del layers[name]\n        self._layers = layers\n    self.call_js_method(\"removeImageryLayer\", name)\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.cesium.CesiumMap.remove_terrain","title":"<code>remove_terrain(self)</code>","text":"<p>Disable terrain and use ellipsoid.</p> Source code in <code>anymap_ts/cesium.py</code> <pre><code>def remove_terrain(self) -&gt; None:\n    \"\"\"Disable terrain and use ellipsoid.\"\"\"\n    self.terrain_enabled = False\n    self.call_js_method(\"removeTerrain\")\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.cesium.CesiumMap.reset_view","title":"<code>reset_view(self, duration=2)</code>","text":"<p>Reset camera to home position.</p> <p>Parameters:</p> Name Type Description Default <code>duration</code> <code>float</code> <p>Animation duration in seconds.</p> <code>2</code> Source code in <code>anymap_ts/cesium.py</code> <pre><code>def reset_view(self, duration: float = 2) -&gt; None:\n    \"\"\"Reset camera to home position.\n\n    Args:\n        duration: Animation duration in seconds.\n    \"\"\"\n    self.call_js_method(\"resetView\", duration=duration)\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.cesium.CesiumMap.set_camera","title":"<code>set_camera(self, longitude=0, latitude=0, height=10000000, heading=0, pitch=-90, roll=0)</code>","text":"<p>Set the camera position immediately (no animation).</p> <p>Parameters:</p> Name Type Description Default <code>longitude</code> <code>float</code> <p>Camera longitude.</p> <code>0</code> <code>latitude</code> <code>float</code> <p>Camera latitude.</p> <code>0</code> <code>height</code> <code>float</code> <p>Camera height in meters.</p> <code>10000000</code> <code>heading</code> <code>float</code> <p>Camera heading in degrees.</p> <code>0</code> <code>pitch</code> <code>float</code> <p>Camera pitch in degrees.</p> <code>-90</code> <code>roll</code> <code>float</code> <p>Camera roll in degrees.</p> <code>0</code> Source code in <code>anymap_ts/cesium.py</code> <pre><code>def set_camera(\n    self,\n    longitude: float = 0,\n    latitude: float = 0,\n    height: float = 10000000,\n    heading: float = 0,\n    pitch: float = -90,\n    roll: float = 0,\n) -&gt; None:\n    \"\"\"Set the camera position immediately (no animation).\n\n    Args:\n        longitude: Camera longitude.\n        latitude: Camera latitude.\n        height: Camera height in meters.\n        heading: Camera heading in degrees.\n        pitch: Camera pitch in degrees.\n        roll: Camera roll in degrees.\n    \"\"\"\n    self.call_js_method(\n        \"setCamera\",\n        longitude=longitude,\n        latitude=latitude,\n        height=height,\n        heading=heading,\n        pitch=pitch,\n        roll=roll,\n    )\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.cesium.CesiumMap.set_opacity","title":"<code>set_opacity(self, name, opacity)</code>","text":"<p>Set layer opacity (imagery layers only).</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Layer name.</p> required <code>opacity</code> <code>float</code> <p>Opacity value (0-1).</p> required Source code in <code>anymap_ts/cesium.py</code> <pre><code>def set_opacity(self, name: str, opacity: float) -&gt; None:\n    \"\"\"Set layer opacity (imagery layers only).\n\n    Args:\n        name: Layer name.\n        opacity: Opacity value (0-1).\n    \"\"\"\n    self.call_js_method(\"setOpacity\", name, opacity)\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.cesium.CesiumMap.set_terrain","title":"<code>set_terrain(self, url=None, request_vertex_normals=True, request_water_mask=True)</code>","text":"<p>Enable terrain.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>Optional[str]</code> <p>Terrain provider URL. If None, uses Cesium World Terrain (requires Ion token).</p> <code>None</code> <code>request_vertex_normals</code> <code>bool</code> <p>Request vertex normals for lighting.</p> <code>True</code> <code>request_water_mask</code> <code>bool</code> <p>Request water mask for water effects.</p> <code>True</code> Source code in <code>anymap_ts/cesium.py</code> <pre><code>def set_terrain(\n    self,\n    url: Optional[str] = None,\n    request_vertex_normals: bool = True,\n    request_water_mask: bool = True,\n) -&gt; None:\n    \"\"\"Enable terrain.\n\n    Args:\n        url: Terrain provider URL. If None, uses Cesium World Terrain (requires Ion token).\n        request_vertex_normals: Request vertex normals for lighting.\n        request_water_mask: Request water mask for water effects.\n    \"\"\"\n    self.terrain_enabled = True\n    self.call_js_method(\n        \"setTerrain\",\n        url=url or \"cesium-world-terrain\",\n        requestVertexNormals=request_vertex_normals,\n        requestWaterMask=request_water_mask,\n    )\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.cesium.CesiumMap.set_visibility","title":"<code>set_visibility(self, name, visible)</code>","text":"<p>Set layer visibility.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Layer name.</p> required <code>visible</code> <code>bool</code> <p>Whether layer should be visible.</p> required Source code in <code>anymap_ts/cesium.py</code> <pre><code>def set_visibility(self, name: str, visible: bool) -&gt; None:\n    \"\"\"Set layer visibility.\n\n    Args:\n        name: Layer name.\n        visible: Whether layer should be visible.\n    \"\"\"\n    self.call_js_method(\"setVisibility\", name, visible)\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.cesium.CesiumMap.zoom_to","title":"<code>zoom_to(self, target)</code>","text":"<p>Zoom to a layer or data source.</p> <p>Parameters:</p> Name Type Description Default <code>target</code> <code>str</code> <p>Name of the layer or data source to zoom to.</p> required Source code in <code>anymap_ts/cesium.py</code> <pre><code>def zoom_to(self, target: str) -&gt; None:\n    \"\"\"Zoom to a layer or data source.\n\n    Args:\n        target: Name of the layer or data source to zoom to.\n    \"\"\"\n    self.call_js_method(\"zoomTo\", target=target)\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.cesium.get_cesium_token","title":"<code>get_cesium_token()</code>","text":"<p>Get Cesium Ion access token from environment variable.</p> <p>Returns:</p> Type Description <code>str</code> <p>Cesium Ion access token or empty string if not set.</p> Source code in <code>anymap_ts/cesium.py</code> <pre><code>def get_cesium_token() -&gt; str:\n    \"\"\"Get Cesium Ion access token from environment variable.\n\n    Returns:\n        Cesium Ion access token or empty string if not set.\n    \"\"\"\n    return os.environ.get(\"CESIUM_TOKEN\", \"\")\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.deckgl","title":"<code>deckgl</code>","text":"<p>DeckGL map widget implementation extending MapLibre with deck.gl layers.</p>"},{"location":"anymap_ts/#anymap_ts.deckgl.DeckGLMap","title":"<code> DeckGLMap            (MapLibreMap)         </code>","text":"<p>Interactive map widget using MapLibre GL JS with deck.gl overlay.</p> <p>This class extends MapLibreMap with deck.gl visualization layer support for GPU-accelerated geospatial visualizations.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from anymap_ts import DeckGLMap\n&gt;&gt;&gt; m = DeckGLMap(center=[-122.4, 37.8], zoom=10)\n&gt;&gt;&gt; m.add_scatterplot_layer(\n...     data=points,\n...     get_position='coordinates',\n...     get_radius=100,\n...     get_fill_color=[255, 0, 0]\n... )\n&gt;&gt;&gt; m\n</code></pre> Source code in <code>anymap_ts/deckgl.py</code> <pre><code>class DeckGLMap(MapLibreMap):\n    \"\"\"Interactive map widget using MapLibre GL JS with deck.gl overlay.\n\n    This class extends MapLibreMap with deck.gl visualization layer support\n    for GPU-accelerated geospatial visualizations.\n\n    Example:\n        &gt;&gt;&gt; from anymap_ts import DeckGLMap\n        &gt;&gt;&gt; m = DeckGLMap(center=[-122.4, 37.8], zoom=10)\n        &gt;&gt;&gt; m.add_scatterplot_layer(\n        ...     data=points,\n        ...     get_position='coordinates',\n        ...     get_radius=100,\n        ...     get_fill_color=[255, 0, 0]\n        ... )\n        &gt;&gt;&gt; m\n    \"\"\"\n\n    # ESM module for frontend (uses DeckGL-enabled version)\n    _esm = STATIC_DIR / \"deckgl.js\"\n\n    # DeckGL layer tracking\n    _deck_layers = traitlets.Dict({}).tag(sync=True)\n\n    def __init__(\n        self,\n        center: Tuple[float, float] = (0.0, 0.0),\n        zoom: float = 2.0,\n        width: str = \"100%\",\n        height: str = \"600px\",\n        style: Union[str, Dict] = \"https://demotiles.maplibre.org/style.json\",\n        bearing: float = 0.0,\n        pitch: float = 0.0,\n        max_pitch: float = 85.0,\n        controls: Optional[Dict[str, Any]] = None,\n        **kwargs,\n    ):\n        \"\"\"Initialize a DeckGL map.\n\n        Args:\n            center: Map center as (longitude, latitude).\n            zoom: Initial zoom level.\n            width: Map width as CSS string.\n            height: Map height as CSS string.\n            style: MapLibre style URL or style object.\n            bearing: Map bearing in degrees.\n            pitch: Map pitch in degrees.\n            max_pitch: Maximum pitch angle in degrees (default: 85).\n            controls: Dict of controls to add (e.g., {\"navigation\": True}).\n            **kwargs: Additional widget arguments.\n        \"\"\"\n        super().__init__(\n            center=center,\n            zoom=zoom,\n            width=width,\n            height=height,\n            style=style,\n            bearing=bearing,\n            pitch=pitch,\n            max_pitch=max_pitch,\n            controls=controls,\n            **kwargs,\n        )\n        self._deck_layers = {}\n\n    # -------------------------------------------------------------------------\n    # DeckGL Scatterplot Layer\n    # -------------------------------------------------------------------------\n\n    def add_scatterplot_layer(\n        self,\n        data: Any,\n        name: Optional[str] = None,\n        get_position: Union[str, Callable] = \"coordinates\",\n        get_radius: Union[float, str, Callable] = 5,\n        get_fill_color: Union[List[int], str, Callable] = None,\n        get_line_color: Union[List[int], str, Callable] = None,\n        radius_scale: float = 1,\n        radius_min_pixels: float = 1,\n        radius_max_pixels: float = 100,\n        line_width_min_pixels: float = 1,\n        stroked: bool = True,\n        filled: bool = True,\n        pickable: bool = True,\n        opacity: float = 0.8,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a scatterplot layer for point visualization.\n\n        Args:\n            data: Array of data objects or GeoJSON.\n            name: Layer ID.\n            get_position: Accessor for point position [lng, lat].\n            get_radius: Accessor for point radius.\n            get_fill_color: Accessor for fill color [r, g, b, a].\n            get_line_color: Accessor for stroke color [r, g, b, a].\n            radius_scale: Global radius multiplier.\n            radius_min_pixels: Minimum radius in pixels.\n            radius_max_pixels: Maximum radius in pixels.\n            line_width_min_pixels: Minimum stroke width.\n            stroked: Whether to draw stroke.\n            filled: Whether to fill points.\n            pickable: Whether layer responds to hover/click.\n            opacity: Layer opacity.\n            **kwargs: Additional layer props.\n        \"\"\"\n        layer_id = name or f\"scatterplot-{len(self._deck_layers)}\"\n        processed_data = self._process_deck_data(data)\n\n        self.call_js_method(\n            \"addScatterplotLayer\",\n            id=layer_id,\n            data=processed_data,\n            getPosition=get_position,\n            getRadius=get_radius,\n            getFillColor=get_fill_color or [51, 136, 255, 200],\n            getLineColor=get_line_color or [255, 255, 255, 255],\n            radiusScale=radius_scale,\n            radiusMinPixels=radius_min_pixels,\n            radiusMaxPixels=radius_max_pixels,\n            lineWidthMinPixels=line_width_min_pixels,\n            stroked=stroked,\n            filled=filled,\n            pickable=pickable,\n            opacity=opacity,\n            **kwargs,\n        )\n\n        self._deck_layers = {\n            **self._deck_layers,\n            layer_id: {\"type\": \"ScatterplotLayer\", \"id\": layer_id},\n        }\n\n    # -------------------------------------------------------------------------\n    # DeckGL Arc Layer\n    # -------------------------------------------------------------------------\n\n    def add_arc_layer(\n        self,\n        data: Any,\n        name: Optional[str] = None,\n        get_source_position: Union[str, Callable] = \"source\",\n        get_target_position: Union[str, Callable] = \"target\",\n        get_source_color: Union[List[int], str, Callable] = None,\n        get_target_color: Union[List[int], str, Callable] = None,\n        get_width: Union[float, str, Callable] = 1,\n        pickable: bool = True,\n        opacity: float = 0.8,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add an arc layer for origin-destination visualization.\n\n        Args:\n            data: Array of data objects with source/target coordinates.\n            name: Layer ID.\n            get_source_position: Accessor for source position [lng, lat].\n            get_target_position: Accessor for target position [lng, lat].\n            get_source_color: Accessor for source color [r, g, b, a].\n            get_target_color: Accessor for target color [r, g, b, a].\n            get_width: Accessor for arc width.\n            pickable: Whether layer responds to hover/click.\n            opacity: Layer opacity.\n            **kwargs: Additional layer props.\n        \"\"\"\n        layer_id = name or f\"arc-{len(self._deck_layers)}\"\n        processed_data = self._process_deck_data(data)\n\n        self.call_js_method(\n            \"addArcLayer\",\n            id=layer_id,\n            data=processed_data,\n            getSourcePosition=get_source_position,\n            getTargetPosition=get_target_position,\n            getSourceColor=get_source_color or [51, 136, 255, 255],\n            getTargetColor=get_target_color or [255, 136, 51, 255],\n            getWidth=get_width,\n            pickable=pickable,\n            opacity=opacity,\n            **kwargs,\n        )\n\n        self._deck_layers = {\n            **self._deck_layers,\n            layer_id: {\"type\": \"ArcLayer\", \"id\": layer_id},\n        }\n\n    # -------------------------------------------------------------------------\n    # DeckGL Point Cloud Layer\n    # -------------------------------------------------------------------------\n\n    def add_point_cloud_layer(\n        self,\n        data: Any,\n        name: Optional[str] = None,\n        get_position: Union[str, Callable] = \"position\",\n        get_color: Union[List[int], str, Callable] = None,\n        get_normal: Union[str, Callable] = None,\n        point_size: float = 2,\n        size_units: str = \"pixels\",\n        coordinate_system: Optional[str] = None,\n        coordinate_origin: Optional[List[float]] = None,\n        pickable: bool = True,\n        opacity: float = 1.0,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a point cloud layer for 3D point visualization.\n\n        Renders large point cloud datasets typically from LiDAR or 3D scanning.\n        Supports both 2D and 3D coordinates with optional normal vectors for\n        lighting effects.\n\n        Args:\n            data: Array of point data with position [x, y, z] coordinates.\n            name: Layer ID. If None, auto-generated.\n            get_position: Accessor for point position [x, y, z].\n            get_color: Accessor for point color [r, g, b, a].\n            get_normal: Accessor for point normal [nx, ny, nz] for lighting.\n            point_size: Point size in size_units.\n            size_units: Units for point_size ('pixels' or 'meters').\n            coordinate_system: Coordinate system ('CARTESIAN', 'METER_OFFSETS',\n                'LNGLAT', 'LNGLAT_OFFSETS').\n            coordinate_origin: Origin for offset coordinate systems [lng, lat, z].\n            pickable: Whether layer responds to hover/click.\n            opacity: Layer opacity (0-1).\n            **kwargs: Additional PointCloudLayer props.\n\n        Example:\n            &gt;&gt;&gt; m = DeckGLMap()\n            &gt;&gt;&gt; points = [\n            ...     {\"position\": [-122.4, 37.8, 100], \"color\": [255, 0, 0]},\n            ...     {\"position\": [-122.5, 37.7, 200], \"color\": [0, 255, 0]},\n            ... ]\n            &gt;&gt;&gt; m.add_point_cloud_layer(\n            ...     data=points,\n            ...     point_size=5,\n            ...     get_color=\"color\"\n            ... )\n        \"\"\"\n        layer_id = name or f\"pointcloud-{len(self._deck_layers)}\"\n        processed_data = self._process_deck_data(data)\n\n        layer_kwargs = {\n            \"id\": layer_id,\n            \"data\": processed_data,\n            \"getPosition\": get_position,\n            \"getColor\": get_color or [255, 255, 255, 255],\n            \"pointSize\": point_size,\n            \"sizeUnits\": size_units,\n            \"pickable\": pickable,\n            \"opacity\": opacity,\n        }\n\n        if get_normal is not None:\n            layer_kwargs[\"getNormal\"] = get_normal\n\n        if coordinate_system is not None:\n            layer_kwargs[\"coordinateSystem\"] = coordinate_system\n\n        if coordinate_origin is not None:\n            layer_kwargs[\"coordinateOrigin\"] = coordinate_origin\n\n        layer_kwargs.update(kwargs)\n        self.call_js_method(\"addPointCloudLayer\", **layer_kwargs)\n\n        self._deck_layers = {\n            **self._deck_layers,\n            layer_id: {\"type\": \"PointCloudLayer\", \"id\": layer_id},\n        }\n\n    # -------------------------------------------------------------------------\n    # DeckGL Path Layer\n    # -------------------------------------------------------------------------\n\n    def add_path_layer(\n        self,\n        data: Any,\n        name: Optional[str] = None,\n        get_path: Union[str, Callable] = \"path\",\n        get_color: Union[List[int], str, Callable] = None,\n        get_width: Union[float, str, Callable] = 1,\n        width_scale: float = 1,\n        width_min_pixels: float = 1,\n        pickable: bool = True,\n        opacity: float = 0.8,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a path layer for polyline visualization.\n\n        Args:\n            data: Array of data objects with path coordinates.\n            name: Layer ID.\n            get_path: Accessor for path coordinates [[lng, lat], ...].\n            get_color: Accessor for path color [r, g, b, a].\n            get_width: Accessor for path width.\n            width_scale: Global width multiplier.\n            width_min_pixels: Minimum width in pixels.\n            pickable: Whether layer responds to hover/click.\n            opacity: Layer opacity.\n            **kwargs: Additional layer props.\n        \"\"\"\n        layer_id = name or f\"path-{len(self._deck_layers)}\"\n        processed_data = self._process_deck_data(data)\n\n        self.call_js_method(\n            \"addPathLayer\",\n            id=layer_id,\n            data=processed_data,\n            getPath=get_path,\n            getColor=get_color or [51, 136, 255, 200],\n            getWidth=get_width,\n            widthScale=width_scale,\n            widthMinPixels=width_min_pixels,\n            pickable=pickable,\n            opacity=opacity,\n            **kwargs,\n        )\n\n        self._deck_layers = {\n            **self._deck_layers,\n            layer_id: {\"type\": \"PathLayer\", \"id\": layer_id},\n        }\n\n    # -------------------------------------------------------------------------\n    # DeckGL Polygon Layer\n    # -------------------------------------------------------------------------\n\n    def add_polygon_layer(\n        self,\n        data: Any,\n        name: Optional[str] = None,\n        get_polygon: Union[str, Callable] = \"polygon\",\n        get_fill_color: Union[List[int], str, Callable] = None,\n        get_line_color: Union[List[int], str, Callable] = None,\n        get_line_width: Union[float, str, Callable] = 1,\n        get_elevation: Union[float, str, Callable] = 0,\n        extruded: bool = False,\n        wireframe: bool = False,\n        filled: bool = True,\n        stroked: bool = True,\n        line_width_min_pixels: float = 1,\n        pickable: bool = True,\n        opacity: float = 0.5,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a polygon layer for filled polygon visualization.\n\n        Args:\n            data: Array of data objects with polygon coordinates.\n            name: Layer ID.\n            get_polygon: Accessor for polygon coordinates.\n            get_fill_color: Accessor for fill color [r, g, b, a].\n            get_line_color: Accessor for stroke color [r, g, b, a].\n            get_line_width: Accessor for stroke width.\n            get_elevation: Accessor for 3D extrusion height.\n            extruded: Whether to render as 3D polygons.\n            wireframe: Whether to render wireframe (extruded only).\n            filled: Whether to fill polygons.\n            stroked: Whether to draw stroke.\n            line_width_min_pixels: Minimum stroke width.\n            pickable: Whether layer responds to hover/click.\n            opacity: Layer opacity.\n            **kwargs: Additional layer props.\n        \"\"\"\n        layer_id = name or f\"polygon-{len(self._deck_layers)}\"\n        processed_data = self._process_deck_data(data)\n\n        self.call_js_method(\n            \"addPolygonLayer\",\n            id=layer_id,\n            data=processed_data,\n            getPolygon=get_polygon,\n            getFillColor=get_fill_color or [51, 136, 255, 128],\n            getLineColor=get_line_color or [0, 0, 255, 255],\n            getLineWidth=get_line_width,\n            getElevation=get_elevation,\n            extruded=extruded,\n            wireframe=wireframe,\n            filled=filled,\n            stroked=stroked,\n            lineWidthMinPixels=line_width_min_pixels,\n            pickable=pickable,\n            opacity=opacity,\n            **kwargs,\n        )\n\n        self._deck_layers = {\n            **self._deck_layers,\n            layer_id: {\"type\": \"PolygonLayer\", \"id\": layer_id},\n        }\n\n    # -------------------------------------------------------------------------\n    # DeckGL Hexagon Layer\n    # -------------------------------------------------------------------------\n\n    def add_hexagon_layer(\n        self,\n        data: Any,\n        name: Optional[str] = None,\n        get_position: Union[str, Callable] = \"coordinates\",\n        radius: float = 1000,\n        elevation_scale: float = 4,\n        extruded: bool = True,\n        color_range: Optional[List[List[int]]] = None,\n        pickable: bool = True,\n        opacity: float = 0.8,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a hexagon layer for hexbin aggregation visualization.\n\n        Args:\n            data: Array of data objects with position coordinates.\n            name: Layer ID.\n            get_position: Accessor for point position [lng, lat].\n            radius: Hexagon radius in meters.\n            elevation_scale: Elevation multiplier for 3D.\n            extruded: Whether to render as 3D hexagons.\n            color_range: Color gradient for aggregation [[r, g, b], ...].\n            pickable: Whether layer responds to hover/click.\n            opacity: Layer opacity.\n            **kwargs: Additional layer props.\n        \"\"\"\n        layer_id = name or f\"hexagon-{len(self._deck_layers)}\"\n        processed_data = self._process_deck_data(data)\n\n        default_color_range = [\n            [1, 152, 189],\n            [73, 227, 206],\n            [216, 254, 181],\n            [254, 237, 177],\n            [254, 173, 84],\n            [209, 55, 78],\n        ]\n\n        self.call_js_method(\n            \"addHexagonLayer\",\n            id=layer_id,\n            data=processed_data,\n            getPosition=get_position,\n            radius=radius,\n            elevationScale=elevation_scale,\n            extruded=extruded,\n            colorRange=color_range or default_color_range,\n            pickable=pickable,\n            opacity=opacity,\n            **kwargs,\n        )\n\n        self._deck_layers = {\n            **self._deck_layers,\n            layer_id: {\"type\": \"HexagonLayer\", \"id\": layer_id},\n        }\n\n    # -------------------------------------------------------------------------\n    # DeckGL Heatmap Layer\n    # -------------------------------------------------------------------------\n\n    def add_heatmap_layer(\n        self,\n        data: Any,\n        name: Optional[str] = None,\n        get_position: Union[str, Callable] = \"coordinates\",\n        get_weight: Union[float, str, Callable] = 1,\n        radius_pixels: float = 30,\n        intensity: float = 1,\n        threshold: float = 0.05,\n        color_range: Optional[List[List[int]]] = None,\n        opacity: float = 1,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a heatmap layer for density visualization.\n\n        Args:\n            data: Array of data objects with position coordinates.\n            name: Layer ID.\n            get_position: Accessor for point position [lng, lat].\n            get_weight: Accessor for point weight.\n            radius_pixels: Influence radius in pixels.\n            intensity: Intensity multiplier.\n            threshold: Minimum density threshold.\n            color_range: Color gradient [[r, g, b, a], ...].\n            opacity: Layer opacity.\n            **kwargs: Additional layer props.\n        \"\"\"\n        layer_id = name or f\"heatmap-{len(self._deck_layers)}\"\n        processed_data = self._process_deck_data(data)\n\n        default_color_range = [\n            [255, 255, 178, 25],\n            [254, 217, 118, 85],\n            [254, 178, 76, 127],\n            [253, 141, 60, 170],\n            [240, 59, 32, 212],\n            [189, 0, 38, 255],\n        ]\n\n        self.call_js_method(\n            \"addHeatmapLayer\",\n            id=layer_id,\n            data=processed_data,\n            getPosition=get_position,\n            getWeight=get_weight,\n            radiusPixels=radius_pixels,\n            intensity=intensity,\n            threshold=threshold,\n            colorRange=color_range or default_color_range,\n            opacity=opacity,\n            **kwargs,\n        )\n\n        self._deck_layers = {\n            **self._deck_layers,\n            layer_id: {\"type\": \"HeatmapLayer\", \"id\": layer_id},\n        }\n\n    # -------------------------------------------------------------------------\n    # DeckGL Grid Layer\n    # -------------------------------------------------------------------------\n\n    def add_grid_layer(\n        self,\n        data: Any,\n        name: Optional[str] = None,\n        get_position: Union[str, Callable] = \"coordinates\",\n        cell_size: float = 200,\n        elevation_scale: float = 4,\n        extruded: bool = True,\n        color_range: Optional[List[List[int]]] = None,\n        pickable: bool = True,\n        opacity: float = 0.8,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a grid layer for square grid aggregation visualization.\n\n        Args:\n            data: Array of data objects with position coordinates.\n            name: Layer ID.\n            get_position: Accessor for point position [lng, lat].\n            cell_size: Grid cell size in meters.\n            elevation_scale: Elevation multiplier for 3D.\n            extruded: Whether to render as 3D cells.\n            color_range: Color gradient [[r, g, b], ...].\n            pickable: Whether layer responds to hover/click.\n            opacity: Layer opacity.\n            **kwargs: Additional layer props.\n        \"\"\"\n        layer_id = name or f\"grid-{len(self._deck_layers)}\"\n        processed_data = self._process_deck_data(data)\n\n        default_color_range = [\n            [1, 152, 189],\n            [73, 227, 206],\n            [216, 254, 181],\n            [254, 237, 177],\n            [254, 173, 84],\n            [209, 55, 78],\n        ]\n\n        self.call_js_method(\n            \"addGridLayer\",\n            id=layer_id,\n            data=processed_data,\n            getPosition=get_position,\n            cellSize=cell_size,\n            elevationScale=elevation_scale,\n            extruded=extruded,\n            colorRange=color_range or default_color_range,\n            pickable=pickable,\n            opacity=opacity,\n            **kwargs,\n        )\n\n        self._deck_layers = {\n            **self._deck_layers,\n            layer_id: {\"type\": \"GridLayer\", \"id\": layer_id},\n        }\n\n    # -------------------------------------------------------------------------\n    # DeckGL Icon Layer\n    # -------------------------------------------------------------------------\n\n    def add_icon_layer(\n        self,\n        data: Any,\n        name: Optional[str] = None,\n        get_position: Union[str, Callable] = \"coordinates\",\n        get_icon: Union[str, Callable] = \"icon\",\n        get_size: Union[float, str, Callable] = 20,\n        get_color: Union[List[int], str, Callable] = None,\n        icon_atlas: Optional[str] = None,\n        icon_mapping: Optional[Dict] = None,\n        pickable: bool = True,\n        opacity: float = 1,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add an icon layer for custom marker visualization.\n\n        Args:\n            data: Array of data objects with position coordinates.\n            name: Layer ID.\n            get_position: Accessor for icon position [lng, lat].\n            get_icon: Accessor for icon name in icon_mapping.\n            get_size: Accessor for icon size.\n            get_color: Accessor for icon tint color [r, g, b, a].\n            icon_atlas: URL to icon atlas image.\n            icon_mapping: Dict mapping icon names to atlas coordinates.\n            pickable: Whether layer responds to hover/click.\n            opacity: Layer opacity.\n            **kwargs: Additional layer props.\n        \"\"\"\n        layer_id = name or f\"icon-{len(self._deck_layers)}\"\n        processed_data = self._process_deck_data(data)\n\n        self.call_js_method(\n            \"addIconLayer\",\n            id=layer_id,\n            data=processed_data,\n            getPosition=get_position,\n            getIcon=get_icon,\n            getSize=get_size,\n            getColor=get_color or [255, 255, 255, 255],\n            iconAtlas=icon_atlas,\n            iconMapping=icon_mapping,\n            pickable=pickable,\n            opacity=opacity,\n            **kwargs,\n        )\n\n        self._deck_layers = {\n            **self._deck_layers,\n            layer_id: {\"type\": \"IconLayer\", \"id\": layer_id},\n        }\n\n    # -------------------------------------------------------------------------\n    # DeckGL Text Layer\n    # -------------------------------------------------------------------------\n\n    def add_text_layer(\n        self,\n        data: Any,\n        name: Optional[str] = None,\n        get_position: Union[str, Callable] = \"coordinates\",\n        get_text: Union[str, Callable] = \"text\",\n        get_size: Union[float, str, Callable] = 12,\n        get_color: Union[List[int], str, Callable] = None,\n        get_angle: Union[float, str, Callable] = 0,\n        text_anchor: str = \"middle\",\n        alignment_baseline: str = \"center\",\n        pickable: bool = True,\n        opacity: float = 1,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a text layer for label visualization.\n\n        Args:\n            data: Array of data objects with position and text.\n            name: Layer ID.\n            get_position: Accessor for text position [lng, lat].\n            get_text: Accessor for text content.\n            get_size: Accessor for text size.\n            get_color: Accessor for text color [r, g, b, a].\n            get_angle: Accessor for text rotation in degrees.\n            text_anchor: Horizontal alignment ('start', 'middle', 'end').\n            alignment_baseline: Vertical alignment ('top', 'center', 'bottom').\n            pickable: Whether layer responds to hover/click.\n            opacity: Layer opacity.\n            **kwargs: Additional layer props.\n        \"\"\"\n        layer_id = name or f\"text-{len(self._deck_layers)}\"\n        processed_data = self._process_deck_data(data)\n\n        self.call_js_method(\n            \"addTextLayer\",\n            id=layer_id,\n            data=processed_data,\n            getPosition=get_position,\n            getText=get_text,\n            getSize=get_size,\n            getColor=get_color or [0, 0, 0, 255],\n            getAngle=get_angle,\n            getTextAnchor=text_anchor,\n            getAlignmentBaseline=alignment_baseline,\n            pickable=pickable,\n            opacity=opacity,\n            **kwargs,\n        )\n\n        self._deck_layers = {\n            **self._deck_layers,\n            layer_id: {\"type\": \"TextLayer\", \"id\": layer_id},\n        }\n\n    # -------------------------------------------------------------------------\n    # DeckGL GeoJSON Layer\n    # -------------------------------------------------------------------------\n\n    def add_geojson_layer(\n        self,\n        data: Any,\n        name: Optional[str] = None,\n        get_fill_color: Union[List[int], str, Callable] = None,\n        get_line_color: Union[List[int], str, Callable] = None,\n        get_line_width: Union[float, str, Callable] = 1,\n        get_point_radius: Union[float, str, Callable] = 5,\n        get_elevation: Union[float, str, Callable] = 0,\n        extruded: bool = False,\n        wireframe: bool = False,\n        filled: bool = True,\n        stroked: bool = True,\n        line_width_min_pixels: float = 1,\n        point_radius_min_pixels: float = 2,\n        pickable: bool = True,\n        opacity: float = 0.8,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a GeoJSON layer for rendering GeoJSON features.\n\n        Args:\n            data: GeoJSON object or URL.\n            name: Layer ID.\n            get_fill_color: Accessor for fill color [r, g, b, a].\n            get_line_color: Accessor for stroke color [r, g, b, a].\n            get_line_width: Accessor for stroke width.\n            get_point_radius: Accessor for point radius.\n            get_elevation: Accessor for 3D extrusion height.\n            extruded: Whether to render as 3D features.\n            wireframe: Whether to render wireframe (extruded only).\n            filled: Whether to fill features.\n            stroked: Whether to draw stroke.\n            line_width_min_pixels: Minimum stroke width.\n            point_radius_min_pixels: Minimum point radius.\n            pickable: Whether layer responds to hover/click.\n            opacity: Layer opacity.\n            **kwargs: Additional layer props.\n        \"\"\"\n        layer_id = name or f\"geojson-{len(self._deck_layers)}\"\n        processed_data = self._process_deck_data(data)\n\n        self.call_js_method(\n            \"addGeoJsonLayer\",\n            id=layer_id,\n            data=processed_data,\n            getFillColor=get_fill_color or [51, 136, 255, 128],\n            getLineColor=get_line_color or [0, 0, 0, 255],\n            getLineWidth=get_line_width,\n            getPointRadius=get_point_radius,\n            getElevation=get_elevation,\n            extruded=extruded,\n            wireframe=wireframe,\n            filled=filled,\n            stroked=stroked,\n            lineWidthMinPixels=line_width_min_pixels,\n            pointRadiusMinPixels=point_radius_min_pixels,\n            pickable=pickable,\n            opacity=opacity,\n            **kwargs,\n        )\n\n        self._deck_layers = {\n            **self._deck_layers,\n            layer_id: {\"type\": \"GeoJsonLayer\", \"id\": layer_id},\n        }\n\n    # -------------------------------------------------------------------------\n    # DeckGL Contour Layer\n    # -------------------------------------------------------------------------\n\n    def add_contour_layer(\n        self,\n        data: Any,\n        name: Optional[str] = None,\n        get_position: Union[str, Callable] = \"coordinates\",\n        get_weight: Union[float, str, Callable] = 1,\n        cell_size: float = 200,\n        contours: Optional[List[Dict]] = None,\n        pickable: bool = True,\n        opacity: float = 1,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a contour layer for isoline visualization.\n\n        Args:\n            data: Array of data objects with position coordinates.\n            name: Layer ID.\n            get_position: Accessor for point position [lng, lat].\n            get_weight: Accessor for point weight.\n            cell_size: Grid cell size for aggregation.\n            contours: Contour definitions [{threshold, color, strokeWidth}, ...].\n            pickable: Whether layer responds to hover/click.\n            opacity: Layer opacity.\n            **kwargs: Additional layer props.\n        \"\"\"\n        layer_id = name or f\"contour-{len(self._deck_layers)}\"\n        processed_data = self._process_deck_data(data)\n\n        default_contours = [\n            {\"threshold\": 1, \"color\": [255, 255, 255], \"strokeWidth\": 1},\n            {\"threshold\": 5, \"color\": [51, 136, 255], \"strokeWidth\": 2},\n            {\"threshold\": 10, \"color\": [0, 0, 255], \"strokeWidth\": 3},\n        ]\n\n        self.call_js_method(\n            \"addContourLayer\",\n            id=layer_id,\n            data=processed_data,\n            getPosition=get_position,\n            getWeight=get_weight,\n            cellSize=cell_size,\n            contours=contours or default_contours,\n            pickable=pickable,\n            opacity=opacity,\n            **kwargs,\n        )\n\n        self._deck_layers = {\n            **self._deck_layers,\n            layer_id: {\"type\": \"ContourLayer\", \"id\": layer_id},\n        }\n\n    # -------------------------------------------------------------------------\n    # DeckGL Screen Grid Layer\n    # -------------------------------------------------------------------------\n\n    def add_screen_grid_layer(\n        self,\n        data: Any,\n        name: Optional[str] = None,\n        get_position: Union[str, Callable] = \"coordinates\",\n        get_weight: Union[float, str, Callable] = 1,\n        cell_size_pixels: float = 50,\n        color_range: Optional[List[List[int]]] = None,\n        pickable: bool = True,\n        opacity: float = 0.8,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a screen grid layer for screen-space grid aggregation.\n\n        Args:\n            data: Array of data objects with position coordinates.\n            name: Layer ID.\n            get_position: Accessor for point position [lng, lat].\n            get_weight: Accessor for point weight.\n            cell_size_pixels: Grid cell size in pixels.\n            color_range: Color gradient [[r, g, b, a], ...].\n            pickable: Whether layer responds to hover/click.\n            opacity: Layer opacity.\n            **kwargs: Additional layer props.\n        \"\"\"\n        layer_id = name or f\"screengrid-{len(self._deck_layers)}\"\n        processed_data = self._process_deck_data(data)\n\n        default_color_range = [\n            [255, 255, 178, 25],\n            [254, 217, 118, 85],\n            [254, 178, 76, 127],\n            [253, 141, 60, 170],\n            [240, 59, 32, 212],\n            [189, 0, 38, 255],\n        ]\n\n        self.call_js_method(\n            \"addScreenGridLayer\",\n            id=layer_id,\n            data=processed_data,\n            getPosition=get_position,\n            getWeight=get_weight,\n            cellSizePixels=cell_size_pixels,\n            colorRange=color_range or default_color_range,\n            pickable=pickable,\n            opacity=opacity,\n            **kwargs,\n        )\n\n        self._deck_layers = {\n            **self._deck_layers,\n            layer_id: {\"type\": \"ScreenGridLayer\", \"id\": layer_id},\n        }\n\n    # -------------------------------------------------------------------------\n    # Generic DeckGL Layer\n    # -------------------------------------------------------------------------\n\n    def add_deckgl_layer(\n        self,\n        layer_type: str,\n        data: Any,\n        name: Optional[str] = None,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a generic deck.gl layer to the map.\n\n        This method provides a flexible way to add any supported deck.gl layer\n        type using a single interface. For commonly used layers, prefer the\n        specific methods (e.g., add_scatterplot_layer) for better IDE support.\n\n        Args:\n            layer_type: The deck.gl layer type. Supported types include:\n                'ScatterplotLayer', 'ArcLayer', 'PathLayer', 'PolygonLayer',\n                'HexagonLayer', 'HeatmapLayer', 'GridLayer', 'IconLayer',\n                'TextLayer', 'GeoJsonLayer', 'ContourLayer', 'ScreenGridLayer',\n                'PointCloudLayer', 'TripsLayer', 'LineLayer'.\n            data: Array of data objects or GeoJSON.\n            name: Layer ID. If None, auto-generated from layer_type.\n            **kwargs: Layer-specific properties passed directly to deck.gl.\n                Common properties include:\n                - opacity: Layer opacity (0-1)\n                - pickable: Whether layer responds to hover/click\n                - getPosition: Accessor for position coordinates\n                - getColor/getFillColor/getLineColor: Color accessors\n\n        Example:\n            &gt;&gt;&gt; m = DeckGLMap()\n            &gt;&gt;&gt; # Add a TripsLayer with animation\n            &gt;&gt;&gt; m.add_deckgl_layer(\n            ...     'TripsLayer',\n            ...     data=trips_data,\n            ...     getPath='waypoints',\n            ...     getTimestamps='timestamps',\n            ...     getColor=[253, 128, 93],\n            ...     trailLength=180,\n            ... )\n            &gt;&gt;&gt; # Add a LineLayer\n            &gt;&gt;&gt; m.add_deckgl_layer(\n            ...     'LineLayer',\n            ...     data=lines_data,\n            ...     getSourcePosition='source',\n            ...     getTargetPosition='target',\n            ...     getColor=[0, 128, 255],\n            ... )\n        \"\"\"\n        # Normalize layer type and create prefix\n        layer_type_clean = layer_type.replace(\"Layer\", \"\")\n        prefix = layer_type_clean.lower()\n        layer_id = name or f\"{prefix}-{len(self._deck_layers)}\"\n        processed_data = self._process_deck_data(data)\n\n        self.call_js_method(\n            \"addDeckGLLayer\",\n            layerType=layer_type,\n            id=layer_id,\n            data=processed_data,\n            **kwargs,\n        )\n\n        self._deck_layers = {\n            **self._deck_layers,\n            layer_id: {\"type\": layer_type, \"id\": layer_id},\n        }\n\n    # -------------------------------------------------------------------------\n    # DeckGL Trips Layer\n    # -------------------------------------------------------------------------\n\n    def add_trips_layer(\n        self,\n        data: Any,\n        name: Optional[str] = None,\n        get_path: Union[str, Callable] = \"waypoints\",\n        get_timestamps: Union[str, Callable] = \"timestamps\",\n        get_color: Union[List[int], str, Callable] = None,\n        width_min_pixels: float = 2,\n        trail_length: float = 180,\n        current_time: float = 0,\n        pickable: bool = True,\n        opacity: float = 0.8,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a trips layer for animated path visualization.\n\n        The TripsLayer renders animated paths showing movement over time,\n        ideal for visualizing vehicle routes, migration patterns, or any\n        time-based trajectory data.\n\n        Args:\n            data: Array of trip objects with waypoints and timestamps.\n            name: Layer ID. If None, auto-generated.\n            get_path: Accessor for waypoint coordinates [[lng, lat], ...].\n            get_timestamps: Accessor for timestamps at each waypoint.\n            get_color: Accessor for trip color [r, g, b] or [r, g, b, a].\n            width_min_pixels: Minimum trail width in pixels.\n            trail_length: Trail length in timestamp units.\n            current_time: Current animation time.\n            pickable: Whether layer responds to hover/click.\n            opacity: Layer opacity (0-1).\n            **kwargs: Additional TripsLayer props.\n\n        Example:\n            &gt;&gt;&gt; m = DeckGLMap()\n            &gt;&gt;&gt; trips = [\n            ...     {\n            ...         \"waypoints\": [[-122.4, 37.8], [-122.5, 37.7], [-122.6, 37.8]],\n            ...         \"timestamps\": [0, 50, 100]\n            ...     }\n            ... ]\n            &gt;&gt;&gt; m.add_trips_layer(\n            ...     data=trips,\n            ...     trail_length=180,\n            ...     current_time=50,\n            ... )\n        \"\"\"\n        layer_id = name or f\"trips-{len(self._deck_layers)}\"\n        processed_data = self._process_deck_data(data)\n\n        self.call_js_method(\n            \"addTripsLayer\",\n            id=layer_id,\n            data=processed_data,\n            getPath=get_path,\n            getTimestamps=get_timestamps,\n            getColor=get_color or [253, 128, 93],\n            widthMinPixels=width_min_pixels,\n            trailLength=trail_length,\n            currentTime=current_time,\n            pickable=pickable,\n            opacity=opacity,\n            **kwargs,\n        )\n\n        self._deck_layers = {\n            **self._deck_layers,\n            layer_id: {\"type\": \"TripsLayer\", \"id\": layer_id},\n        }\n\n    # -------------------------------------------------------------------------\n    # DeckGL Line Layer\n    # -------------------------------------------------------------------------\n\n    def add_line_layer(\n        self,\n        data: Any,\n        name: Optional[str] = None,\n        get_source_position: Union[str, Callable] = \"sourcePosition\",\n        get_target_position: Union[str, Callable] = \"targetPosition\",\n        get_color: Union[List[int], str, Callable] = None,\n        get_width: Union[float, str, Callable] = 1,\n        width_min_pixels: float = 1,\n        pickable: bool = True,\n        opacity: float = 0.8,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a line layer for simple line segment visualization.\n\n        The LineLayer renders straight line segments between source and\n        target positions. Unlike ArcLayer, lines are drawn directly\n        without curvature.\n\n        Args:\n            data: Array of line objects with source/target positions.\n            name: Layer ID. If None, auto-generated.\n            get_source_position: Accessor for source position [lng, lat].\n            get_target_position: Accessor for target position [lng, lat].\n            get_color: Accessor for line color [r, g, b] or [r, g, b, a].\n            get_width: Accessor for line width.\n            width_min_pixels: Minimum line width in pixels.\n            pickable: Whether layer responds to hover/click.\n            opacity: Layer opacity (0-1).\n            **kwargs: Additional LineLayer props.\n\n        Example:\n            &gt;&gt;&gt; m = DeckGLMap()\n            &gt;&gt;&gt; lines = [\n            ...     {\"sourcePosition\": [-122.4, 37.8], \"targetPosition\": [-122.5, 37.7]},\n            ...     {\"sourcePosition\": [-122.5, 37.7], \"targetPosition\": [-122.6, 37.8]},\n            ... ]\n            &gt;&gt;&gt; m.add_line_layer(\n            ...     data=lines,\n            ...     get_color=[0, 128, 255],\n            ...     get_width=2,\n            ... )\n        \"\"\"\n        layer_id = name or f\"line-{len(self._deck_layers)}\"\n        processed_data = self._process_deck_data(data)\n\n        self.call_js_method(\n            \"addLineLayer\",\n            id=layer_id,\n            data=processed_data,\n            getSourcePosition=get_source_position,\n            getTargetPosition=get_target_position,\n            getColor=get_color or [51, 136, 255, 200],\n            getWidth=get_width,\n            widthMinPixels=width_min_pixels,\n            pickable=pickable,\n            opacity=opacity,\n            **kwargs,\n        )\n\n        self._deck_layers = {\n            **self._deck_layers,\n            layer_id: {\"type\": \"LineLayer\", \"id\": layer_id},\n        }\n\n    # -------------------------------------------------------------------------\n    # DeckGL COG Layer\n    # -------------------------------------------------------------------------\n\n    def add_cog_layer(\n        self,\n        url: str,\n        name: Optional[str] = None,\n        opacity: float = 1.0,\n        visible: bool = True,\n        debug: bool = False,\n        debug_opacity: float = 0.25,\n        max_error: float = 0.125,\n        fit_bounds: bool = True,\n        before_id: Optional[str] = None,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a Cloud Optimized GeoTIFF (COG) layer using @developmentseed/deck.gl-geotiff.\n\n        This method renders COG files directly in the browser using GPU-accelerated\n        deck.gl rendering with automatic reprojection support.\n\n        Args:\n            url: URL to the Cloud Optimized GeoTIFF file.\n            name: Layer ID. If None, auto-generated.\n            opacity: Layer opacity (0-1).\n            visible: Whether layer is visible.\n            debug: Show reprojection mesh for debugging.\n            debug_opacity: Opacity of debug mesh (0-1).\n            max_error: Maximum reprojection error in pixels. Lower values\n                create denser mesh for better accuracy.\n            fit_bounds: Whether to fit map to COG bounds after loading.\n            before_id: ID of layer to insert before.\n            **kwargs: Additional COGLayer props.\n\n        Example:\n            &gt;&gt;&gt; m = DeckGLMap()\n            &gt;&gt;&gt; m.add_cog_layer(\n            ...     \"https://example.com/landcover.tif\",\n            ...     name=\"landcover\",\n            ...     opacity=0.8\n            ... )\n        \"\"\"\n        # Use a monotonically increasing counter to avoid ID collisions when layers are removed.\n        counter = getattr(self, \"_cog_layer_counter\", 0)\n        layer_id = name or f\"cog-{counter}\"\n        self._cog_layer_counter = counter + 1\n\n        self.call_js_method(\n            \"addCOGLayer\",\n            id=layer_id,\n            geotiff=url,\n            opacity=opacity,\n            visible=visible,\n            debug=debug,\n            debugOpacity=debug_opacity,\n            maxError=max_error,\n            fitBounds=fit_bounds,\n            beforeId=before_id,\n            **kwargs,\n        )\n\n        self._deck_layers = {\n            **self._deck_layers,\n            layer_id: {\"type\": \"COGLayer\", \"id\": layer_id, \"url\": url},\n        }\n\n    # -------------------------------------------------------------------------\n    # New DeckGL Layer Types\n    # -------------------------------------------------------------------------\n\n    def add_bitmap_layer(\n        self,\n        image: str,\n        bounds: List[float],\n        name: Optional[str] = None,\n        opacity: float = 1.0,\n        visible: bool = True,\n        pickable: bool = False,\n        desaturate: float = 0,\n        transparent_color: Optional[List[int]] = None,\n        tint_color: Optional[List[int]] = None,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a bitmap layer for raster image overlay.\n\n        Args:\n            image: URL or data URI of the image.\n            bounds: Bounding box [west, south, east, north].\n            name: Layer ID.\n            opacity: Layer opacity (0-1).\n            visible: Whether layer is visible.\n            pickable: Whether layer responds to hover/click.\n            desaturate: Desaturation amount (0-1).\n            transparent_color: Color to make transparent [r, g, b, a].\n            tint_color: Color to tint the image [r, g, b].\n            **kwargs: Additional BitmapLayer props.\n        \"\"\"\n        layer_id = name or f\"bitmap-{len(self._deck_layers)}\"\n\n        self.call_js_method(\n            \"addBitmapLayer\",\n            id=layer_id,\n            image=image,\n            bounds=bounds,\n            opacity=opacity,\n            visible=visible,\n            pickable=pickable,\n            desaturate=desaturate,\n            transparentColor=transparent_color or [0, 0, 0, 0],\n            tintColor=tint_color or [255, 255, 255],\n            **kwargs,\n        )\n\n        self._deck_layers = {\n            **self._deck_layers,\n            layer_id: {\"type\": \"BitmapLayer\", \"id\": layer_id},\n        }\n\n    def add_column_layer(\n        self,\n        data: Any,\n        name: Optional[str] = None,\n        get_position: Union[str, Callable] = \"coordinates\",\n        get_fill_color: Union[List[int], str, Callable] = None,\n        get_line_color: Union[List[int], str, Callable] = None,\n        get_elevation: Union[float, str, Callable] = 1000,\n        radius: float = 1000,\n        disk_resolution: int = 20,\n        elevation_scale: float = 1,\n        coverage: float = 1,\n        extruded: bool = True,\n        filled: bool = True,\n        stroked: bool = False,\n        wireframe: bool = False,\n        pickable: bool = True,\n        opacity: float = 0.8,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a column layer for 3D column/bar visualization.\n\n        Args:\n            data: Array of data objects with position coordinates.\n            name: Layer ID.\n            get_position: Accessor for column position [lng, lat].\n            get_fill_color: Accessor for fill color [r, g, b, a].\n            get_line_color: Accessor for stroke color [r, g, b, a].\n            get_elevation: Accessor for column height.\n            radius: Column radius in meters.\n            disk_resolution: Number of sides for column polygon.\n            elevation_scale: Elevation multiplier.\n            coverage: Column coverage (0-1).\n            extruded: Whether to extrude columns.\n            filled: Whether to fill columns.\n            stroked: Whether to stroke columns.\n            wireframe: Whether to render as wireframe.\n            pickable: Whether layer responds to hover/click.\n            opacity: Layer opacity.\n            **kwargs: Additional ColumnLayer props.\n        \"\"\"\n        layer_id = name or f\"column-{len(self._deck_layers)}\"\n        processed_data = self._process_deck_data(data)\n\n        self.call_js_method(\n            \"addColumnLayer\",\n            id=layer_id,\n            data=processed_data,\n            getPosition=get_position,\n            getFillColor=get_fill_color or [255, 140, 0, 200],\n            getLineColor=get_line_color or [0, 0, 0, 255],\n            getElevation=get_elevation,\n            radius=radius,\n            diskResolution=disk_resolution,\n            elevationScale=elevation_scale,\n            coverage=coverage,\n            extruded=extruded,\n            filled=filled,\n            stroked=stroked,\n            wireframe=wireframe,\n            pickable=pickable,\n            opacity=opacity,\n            **kwargs,\n        )\n\n        self._deck_layers = {\n            **self._deck_layers,\n            layer_id: {\"type\": \"ColumnLayer\", \"id\": layer_id},\n        }\n\n    def add_grid_cell_layer(\n        self,\n        data: Any,\n        name: Optional[str] = None,\n        get_position: Union[str, Callable] = \"coordinates\",\n        get_color: Union[List[int], str, Callable] = None,\n        get_elevation: Union[float, str, Callable] = 1000,\n        cell_size: float = 200,\n        coverage: float = 1,\n        elevation_scale: float = 1,\n        extruded: bool = True,\n        pickable: bool = True,\n        opacity: float = 0.8,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a grid cell layer for pre-aggregated grid visualization.\n\n        Args:\n            data: Array of data objects with position coordinates.\n            name: Layer ID.\n            get_position: Accessor for cell position [lng, lat].\n            get_color: Accessor for cell color [r, g, b, a].\n            get_elevation: Accessor for cell height.\n            cell_size: Cell size in meters.\n            coverage: Cell coverage (0-1).\n            elevation_scale: Elevation multiplier.\n            extruded: Whether to extrude cells.\n            pickable: Whether layer responds to hover/click.\n            opacity: Layer opacity.\n            **kwargs: Additional GridCellLayer props.\n        \"\"\"\n        layer_id = name or f\"gridcell-{len(self._deck_layers)}\"\n        processed_data = self._process_deck_data(data)\n\n        self.call_js_method(\n            \"addGridCellLayer\",\n            id=layer_id,\n            data=processed_data,\n            getPosition=get_position,\n            getColor=get_color or [255, 140, 0, 200],\n            getElevation=get_elevation,\n            cellSize=cell_size,\n            coverage=coverage,\n            elevationScale=elevation_scale,\n            extruded=extruded,\n            pickable=pickable,\n            opacity=opacity,\n            **kwargs,\n        )\n\n        self._deck_layers = {\n            **self._deck_layers,\n            layer_id: {\"type\": \"GridCellLayer\", \"id\": layer_id},\n        }\n\n    def add_solid_polygon_layer(\n        self,\n        data: Any,\n        name: Optional[str] = None,\n        get_polygon: Union[str, Callable] = \"polygon\",\n        get_fill_color: Union[List[int], str, Callable] = None,\n        get_line_color: Union[List[int], str, Callable] = None,\n        get_elevation: Union[float, str, Callable] = 0,\n        filled: bool = True,\n        extruded: bool = False,\n        wireframe: bool = False,\n        elevation_scale: float = 1,\n        pickable: bool = True,\n        opacity: float = 0.8,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a solid polygon layer for filled polygon visualization.\n\n        Args:\n            data: Array of data objects with polygon coordinates.\n            name: Layer ID.\n            get_polygon: Accessor for polygon coordinates.\n            get_fill_color: Accessor for fill color [r, g, b, a].\n            get_line_color: Accessor for stroke color [r, g, b, a].\n            get_elevation: Accessor for 3D extrusion height.\n            filled: Whether to fill polygons.\n            extruded: Whether to render as 3D polygons.\n            wireframe: Whether to render wireframe.\n            elevation_scale: Elevation multiplier.\n            pickable: Whether layer responds to hover/click.\n            opacity: Layer opacity.\n            **kwargs: Additional SolidPolygonLayer props.\n        \"\"\"\n        layer_id = name or f\"solidpolygon-{len(self._deck_layers)}\"\n        processed_data = self._process_deck_data(data)\n\n        self.call_js_method(\n            \"addSolidPolygonLayer\",\n            id=layer_id,\n            data=processed_data,\n            getPolygon=get_polygon,\n            getFillColor=get_fill_color or [51, 136, 255, 128],\n            getLineColor=get_line_color or [0, 0, 0, 255],\n            getElevation=get_elevation,\n            filled=filled,\n            extruded=extruded,\n            wireframe=wireframe,\n            elevationScale=elevation_scale,\n            pickable=pickable,\n            opacity=opacity,\n            **kwargs,\n        )\n\n        self._deck_layers = {\n            **self._deck_layers,\n            layer_id: {\"type\": \"SolidPolygonLayer\", \"id\": layer_id},\n        }\n\n    def add_tile_layer(\n        self,\n        data: Union[str, List[str]],\n        name: Optional[str] = None,\n        min_zoom: int = 0,\n        max_zoom: int = 19,\n        tile_size: int = 256,\n        pickable: bool = False,\n        visible: bool = True,\n        opacity: float = 1.0,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a tile layer for raster tile visualization.\n\n        Args:\n            data: Tile URL template with {z}/{x}/{y} placeholders.\n            name: Layer ID.\n            min_zoom: Minimum zoom level.\n            max_zoom: Maximum zoom level.\n            tile_size: Tile size in pixels.\n            pickable: Whether layer responds to hover/click.\n            visible: Whether layer is visible.\n            opacity: Layer opacity (0-1).\n            **kwargs: Additional TileLayer props.\n        \"\"\"\n        layer_id = name or f\"tile-{len(self._deck_layers)}\"\n\n        self.call_js_method(\n            \"addTileLayer\",\n            id=layer_id,\n            data=data,\n            minZoom=min_zoom,\n            maxZoom=max_zoom,\n            tileSize=tile_size,\n            pickable=pickable,\n            visible=visible,\n            opacity=opacity,\n            **kwargs,\n        )\n\n        self._deck_layers = {\n            **self._deck_layers,\n            layer_id: {\"type\": \"TileLayer\", \"id\": layer_id},\n        }\n\n    def add_mvt_layer(\n        self,\n        data: Union[str, List[str]],\n        name: Optional[str] = None,\n        min_zoom: int = 0,\n        max_zoom: int = 14,\n        binary: bool = True,\n        get_fill_color: Union[List[int], str, Callable] = None,\n        get_line_color: Union[List[int], str, Callable] = None,\n        get_line_width: Union[float, str, Callable] = 1,\n        get_point_radius: Union[float, str, Callable] = 5,\n        line_width_min_pixels: float = 1,\n        point_radius_min_pixels: float = 2,\n        pickable: bool = True,\n        visible: bool = True,\n        opacity: float = 1.0,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a Mapbox Vector Tile (MVT) layer.\n\n        Args:\n            data: MVT tile URL template with {z}/{x}/{y} placeholders.\n            name: Layer ID.\n            min_zoom: Minimum zoom level.\n            max_zoom: Maximum zoom level.\n            binary: Whether to use binary format.\n            get_fill_color: Accessor for fill color [r, g, b, a].\n            get_line_color: Accessor for stroke color [r, g, b, a].\n            get_line_width: Accessor for line width.\n            get_point_radius: Accessor for point radius.\n            line_width_min_pixels: Minimum line width in pixels.\n            point_radius_min_pixels: Minimum point radius in pixels.\n            pickable: Whether layer responds to hover/click.\n            visible: Whether layer is visible.\n            opacity: Layer opacity (0-1).\n            **kwargs: Additional MVTLayer props.\n        \"\"\"\n        layer_id = name or f\"mvt-{len(self._deck_layers)}\"\n\n        self.call_js_method(\n            \"addMVTLayer\",\n            id=layer_id,\n            data=data,\n            minZoom=min_zoom,\n            maxZoom=max_zoom,\n            binary=binary,\n            getFillColor=get_fill_color or [51, 136, 255, 128],\n            getLineColor=get_line_color or [0, 0, 0, 255],\n            getLineWidth=get_line_width,\n            getPointRadius=get_point_radius,\n            lineWidthMinPixels=line_width_min_pixels,\n            pointRadiusMinPixels=point_radius_min_pixels,\n            pickable=pickable,\n            visible=visible,\n            opacity=opacity,\n            **kwargs,\n        )\n\n        self._deck_layers = {\n            **self._deck_layers,\n            layer_id: {\"type\": \"MVTLayer\", \"id\": layer_id},\n        }\n\n    def add_tile3d_layer(\n        self,\n        data: str,\n        name: Optional[str] = None,\n        point_size: float = 1,\n        pickable: bool = True,\n        visible: bool = True,\n        opacity: float = 1.0,\n        load_options: Optional[Dict] = None,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a 3D Tiles layer for 3D building/terrain visualization.\n\n        Args:\n            data: URL to tileset.json.\n            name: Layer ID.\n            point_size: Point size for point cloud tiles.\n            pickable: Whether layer responds to hover/click.\n            visible: Whether layer is visible.\n            opacity: Layer opacity (0-1).\n            load_options: Loader options for tile loading.\n            **kwargs: Additional Tile3DLayer props.\n        \"\"\"\n        layer_id = name or f\"tile3d-{len(self._deck_layers)}\"\n\n        self.call_js_method(\n            \"addTile3DLayer\",\n            id=layer_id,\n            data=data,\n            pointSize=point_size,\n            pickable=pickable,\n            visible=visible,\n            opacity=opacity,\n            loadOptions=load_options or {},\n            **kwargs,\n        )\n\n        self._deck_layers = {\n            **self._deck_layers,\n            layer_id: {\"type\": \"Tile3DLayer\", \"id\": layer_id},\n        }\n\n    def add_terrain_layer(\n        self,\n        elevation_data: Union[str, List[str]],\n        name: Optional[str] = None,\n        texture: Optional[str] = None,\n        mesh_max_error: float = 4.0,\n        bounds: Optional[List[float]] = None,\n        elevation_decoder: Optional[Dict] = None,\n        pickable: bool = False,\n        visible: bool = True,\n        opacity: float = 1.0,\n        wireframe: bool = False,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a terrain layer for 3D terrain visualization.\n\n        Args:\n            elevation_data: URL to elevation tiles (e.g., Mapbox terrain).\n            name: Layer ID.\n            texture: URL to texture tiles for terrain surface.\n            mesh_max_error: Maximum mesh error in meters.\n            bounds: Bounding box [west, south, east, north].\n            elevation_decoder: Decoder for elevation data format.\n            pickable: Whether layer responds to hover/click.\n            visible: Whether layer is visible.\n            opacity: Layer opacity (0-1).\n            wireframe: Whether to render as wireframe.\n            **kwargs: Additional TerrainLayer props.\n        \"\"\"\n        layer_id = name or f\"terrain-{len(self._deck_layers)}\"\n\n        default_decoder = {\n            \"rScaler\": 256,\n            \"gScaler\": 1,\n            \"bScaler\": 1 / 256,\n            \"offset\": -32768,\n        }\n\n        self.call_js_method(\n            \"addTerrainLayer\",\n            id=layer_id,\n            elevationData=elevation_data,\n            texture=texture,\n            meshMaxError=mesh_max_error,\n            bounds=bounds,\n            elevationDecoder=elevation_decoder or default_decoder,\n            pickable=pickable,\n            visible=visible,\n            opacity=opacity,\n            wireframe=wireframe,\n            **kwargs,\n        )\n\n        self._deck_layers = {\n            **self._deck_layers,\n            layer_id: {\"type\": \"TerrainLayer\", \"id\": layer_id},\n        }\n\n    def add_great_circle_layer(\n        self,\n        data: Any,\n        name: Optional[str] = None,\n        get_source_position: Union[str, Callable] = \"source\",\n        get_target_position: Union[str, Callable] = \"target\",\n        get_source_color: Union[List[int], str, Callable] = None,\n        get_target_color: Union[List[int], str, Callable] = None,\n        get_width: Union[float, str, Callable] = 1,\n        width_min_pixels: float = 1,\n        width_max_pixels: float = 100,\n        pickable: bool = True,\n        opacity: float = 0.8,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a great circle layer for geodesic arc visualization.\n\n        Args:\n            data: Array of data objects with source/target coordinates.\n            name: Layer ID.\n            get_source_position: Accessor for source position [lng, lat].\n            get_target_position: Accessor for target position [lng, lat].\n            get_source_color: Accessor for source color [r, g, b, a].\n            get_target_color: Accessor for target color [r, g, b, a].\n            get_width: Accessor for line width.\n            width_min_pixels: Minimum line width in pixels.\n            width_max_pixels: Maximum line width in pixels.\n            pickable: Whether layer responds to hover/click.\n            opacity: Layer opacity.\n            **kwargs: Additional GreatCircleLayer props.\n        \"\"\"\n        layer_id = name or f\"greatcircle-{len(self._deck_layers)}\"\n        processed_data = self._process_deck_data(data)\n\n        self.call_js_method(\n            \"addGreatCircleLayer\",\n            id=layer_id,\n            data=processed_data,\n            getSourcePosition=get_source_position,\n            getTargetPosition=get_target_position,\n            getSourceColor=get_source_color or [51, 136, 255, 255],\n            getTargetColor=get_target_color or [255, 136, 51, 255],\n            getWidth=get_width,\n            widthMinPixels=width_min_pixels,\n            widthMaxPixels=width_max_pixels,\n            pickable=pickable,\n            opacity=opacity,\n            **kwargs,\n        )\n\n        self._deck_layers = {\n            **self._deck_layers,\n            layer_id: {\"type\": \"GreatCircleLayer\", \"id\": layer_id},\n        }\n\n    def add_h3_hexagon_layer(\n        self,\n        data: Any,\n        name: Optional[str] = None,\n        get_hexagon: Union[str, Callable] = \"hexagon\",\n        get_fill_color: Union[List[int], str, Callable] = None,\n        get_line_color: Union[List[int], str, Callable] = None,\n        get_elevation: Union[float, str, Callable] = 0,\n        filled: bool = True,\n        stroked: bool = True,\n        extruded: bool = False,\n        wireframe: bool = False,\n        elevation_scale: float = 1,\n        coverage: float = 1,\n        high_precision: bool = False,\n        pickable: bool = True,\n        opacity: float = 0.8,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add an H3 hexagon layer for H3 spatial index visualization.\n\n        Args:\n            data: Array of data objects with H3 index.\n            name: Layer ID.\n            get_hexagon: Accessor for H3 index string.\n            get_fill_color: Accessor for fill color [r, g, b, a].\n            get_line_color: Accessor for stroke color [r, g, b, a].\n            get_elevation: Accessor for 3D extrusion height.\n            filled: Whether to fill hexagons.\n            stroked: Whether to stroke hexagons.\n            extruded: Whether to render as 3D hexagons.\n            wireframe: Whether to render wireframe.\n            elevation_scale: Elevation multiplier.\n            coverage: Hexagon coverage (0-1).\n            high_precision: Use high precision rendering.\n            pickable: Whether layer responds to hover/click.\n            opacity: Layer opacity.\n            **kwargs: Additional H3HexagonLayer props.\n        \"\"\"\n        layer_id = name or f\"h3hexagon-{len(self._deck_layers)}\"\n        processed_data = self._process_deck_data(data)\n\n        self.call_js_method(\n            \"addH3HexagonLayer\",\n            id=layer_id,\n            data=processed_data,\n            getHexagon=get_hexagon,\n            getFillColor=get_fill_color or [51, 136, 255, 128],\n            getLineColor=get_line_color or [0, 0, 0, 255],\n            getElevation=get_elevation,\n            filled=filled,\n            stroked=stroked,\n            extruded=extruded,\n            wireframe=wireframe,\n            elevationScale=elevation_scale,\n            coverage=coverage,\n            highPrecision=high_precision,\n            pickable=pickable,\n            opacity=opacity,\n            **kwargs,\n        )\n\n        self._deck_layers = {\n            **self._deck_layers,\n            layer_id: {\"type\": \"H3HexagonLayer\", \"id\": layer_id},\n        }\n\n    def add_h3_cluster_layer(\n        self,\n        data: Any,\n        name: Optional[str] = None,\n        get_hexagons: Union[str, Callable] = \"hexagons\",\n        get_fill_color: Union[List[int], str, Callable] = None,\n        get_line_color: Union[List[int], str, Callable] = None,\n        get_line_width: Union[float, str, Callable] = 1,\n        filled: bool = True,\n        stroked: bool = True,\n        extruded: bool = False,\n        elevation_scale: float = 1,\n        pickable: bool = True,\n        opacity: float = 0.8,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add an H3 cluster layer for grouped H3 cell visualization.\n\n        Args:\n            data: Array of data objects with H3 index arrays.\n            name: Layer ID.\n            get_hexagons: Accessor for array of H3 index strings.\n            get_fill_color: Accessor for fill color [r, g, b, a].\n            get_line_color: Accessor for stroke color [r, g, b, a].\n            get_line_width: Accessor for line width.\n            filled: Whether to fill clusters.\n            stroked: Whether to stroke clusters.\n            extruded: Whether to render as 3D.\n            elevation_scale: Elevation multiplier.\n            pickable: Whether layer responds to hover/click.\n            opacity: Layer opacity.\n            **kwargs: Additional H3ClusterLayer props.\n        \"\"\"\n        layer_id = name or f\"h3cluster-{len(self._deck_layers)}\"\n        processed_data = self._process_deck_data(data)\n\n        self.call_js_method(\n            \"addH3ClusterLayer\",\n            id=layer_id,\n            data=processed_data,\n            getHexagons=get_hexagons,\n            getFillColor=get_fill_color or [51, 136, 255, 128],\n            getLineColor=get_line_color or [0, 0, 0, 255],\n            getLineWidth=get_line_width,\n            filled=filled,\n            stroked=stroked,\n            extruded=extruded,\n            elevationScale=elevation_scale,\n            pickable=pickable,\n            opacity=opacity,\n            **kwargs,\n        )\n\n        self._deck_layers = {\n            **self._deck_layers,\n            layer_id: {\"type\": \"H3ClusterLayer\", \"id\": layer_id},\n        }\n\n    def add_s2_layer(\n        self,\n        data: Any,\n        name: Optional[str] = None,\n        get_s2_token: Union[str, Callable] = \"s2Token\",\n        get_fill_color: Union[List[int], str, Callable] = None,\n        get_line_color: Union[List[int], str, Callable] = None,\n        get_line_width: Union[float, str, Callable] = 1,\n        get_elevation: Union[float, str, Callable] = 0,\n        filled: bool = True,\n        stroked: bool = True,\n        extruded: bool = False,\n        wireframe: bool = False,\n        elevation_scale: float = 1,\n        pickable: bool = True,\n        opacity: float = 0.8,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add an S2 layer for S2 geometry cell visualization.\n\n        Args:\n            data: Array of data objects with S2 token.\n            name: Layer ID.\n            get_s2_token: Accessor for S2 token string.\n            get_fill_color: Accessor for fill color [r, g, b, a].\n            get_line_color: Accessor for stroke color [r, g, b, a].\n            get_line_width: Accessor for line width.\n            get_elevation: Accessor for 3D extrusion height.\n            filled: Whether to fill cells.\n            stroked: Whether to stroke cells.\n            extruded: Whether to render as 3D.\n            wireframe: Whether to render wireframe.\n            elevation_scale: Elevation multiplier.\n            pickable: Whether layer responds to hover/click.\n            opacity: Layer opacity.\n            **kwargs: Additional S2Layer props.\n        \"\"\"\n        layer_id = name or f\"s2-{len(self._deck_layers)}\"\n        processed_data = self._process_deck_data(data)\n\n        self.call_js_method(\n            \"addS2Layer\",\n            id=layer_id,\n            data=processed_data,\n            getS2Token=get_s2_token,\n            getFillColor=get_fill_color or [51, 136, 255, 128],\n            getLineColor=get_line_color or [0, 0, 0, 255],\n            getLineWidth=get_line_width,\n            getElevation=get_elevation,\n            filled=filled,\n            stroked=stroked,\n            extruded=extruded,\n            wireframe=wireframe,\n            elevationScale=elevation_scale,\n            pickable=pickable,\n            opacity=opacity,\n            **kwargs,\n        )\n\n        self._deck_layers = {\n            **self._deck_layers,\n            layer_id: {\"type\": \"S2Layer\", \"id\": layer_id},\n        }\n\n    def add_quadkey_layer(\n        self,\n        data: Any,\n        name: Optional[str] = None,\n        get_quadkey: Union[str, Callable] = \"quadkey\",\n        get_fill_color: Union[List[int], str, Callable] = None,\n        get_line_color: Union[List[int], str, Callable] = None,\n        get_line_width: Union[float, str, Callable] = 1,\n        get_elevation: Union[float, str, Callable] = 0,\n        filled: bool = True,\n        stroked: bool = True,\n        extruded: bool = False,\n        wireframe: bool = False,\n        elevation_scale: float = 1,\n        pickable: bool = True,\n        opacity: float = 0.8,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a Quadkey layer for Bing Maps tile index visualization.\n\n        Args:\n            data: Array of data objects with quadkey.\n            name: Layer ID.\n            get_quadkey: Accessor for quadkey string.\n            get_fill_color: Accessor for fill color [r, g, b, a].\n            get_line_color: Accessor for stroke color [r, g, b, a].\n            get_line_width: Accessor for line width.\n            get_elevation: Accessor for 3D extrusion height.\n            filled: Whether to fill cells.\n            stroked: Whether to stroke cells.\n            extruded: Whether to render as 3D.\n            wireframe: Whether to render wireframe.\n            elevation_scale: Elevation multiplier.\n            pickable: Whether layer responds to hover/click.\n            opacity: Layer opacity.\n            **kwargs: Additional QuadkeyLayer props.\n        \"\"\"\n        layer_id = name or f\"quadkey-{len(self._deck_layers)}\"\n        processed_data = self._process_deck_data(data)\n\n        self.call_js_method(\n            \"addQuadkeyLayer\",\n            id=layer_id,\n            data=processed_data,\n            getQuadkey=get_quadkey,\n            getFillColor=get_fill_color or [51, 136, 255, 128],\n            getLineColor=get_line_color or [0, 0, 0, 255],\n            getLineWidth=get_line_width,\n            getElevation=get_elevation,\n            filled=filled,\n            stroked=stroked,\n            extruded=extruded,\n            wireframe=wireframe,\n            elevationScale=elevation_scale,\n            pickable=pickable,\n            opacity=opacity,\n            **kwargs,\n        )\n\n        self._deck_layers = {\n            **self._deck_layers,\n            layer_id: {\"type\": \"QuadkeyLayer\", \"id\": layer_id},\n        }\n\n    def add_geohash_layer(\n        self,\n        data: Any,\n        name: Optional[str] = None,\n        get_geohash: Union[str, Callable] = \"geohash\",\n        get_fill_color: Union[List[int], str, Callable] = None,\n        get_line_color: Union[List[int], str, Callable] = None,\n        get_line_width: Union[float, str, Callable] = 1,\n        get_elevation: Union[float, str, Callable] = 0,\n        filled: bool = True,\n        stroked: bool = True,\n        extruded: bool = False,\n        wireframe: bool = False,\n        elevation_scale: float = 1,\n        pickable: bool = True,\n        opacity: float = 0.8,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a Geohash layer for geohash cell visualization.\n\n        Args:\n            data: Array of data objects with geohash.\n            name: Layer ID.\n            get_geohash: Accessor for geohash string.\n            get_fill_color: Accessor for fill color [r, g, b, a].\n            get_line_color: Accessor for stroke color [r, g, b, a].\n            get_line_width: Accessor for line width.\n            get_elevation: Accessor for 3D extrusion height.\n            filled: Whether to fill cells.\n            stroked: Whether to stroke cells.\n            extruded: Whether to render as 3D.\n            wireframe: Whether to render wireframe.\n            elevation_scale: Elevation multiplier.\n            pickable: Whether layer responds to hover/click.\n            opacity: Layer opacity.\n            **kwargs: Additional GeohashLayer props.\n        \"\"\"\n        layer_id = name or f\"geohash-{len(self._deck_layers)}\"\n        processed_data = self._process_deck_data(data)\n\n        self.call_js_method(\n            \"addGeohashLayer\",\n            id=layer_id,\n            data=processed_data,\n            getGeohash=get_geohash,\n            getFillColor=get_fill_color or [51, 136, 255, 128],\n            getLineColor=get_line_color or [0, 0, 0, 255],\n            getLineWidth=get_line_width,\n            getElevation=get_elevation,\n            filled=filled,\n            stroked=stroked,\n            extruded=extruded,\n            wireframe=wireframe,\n            elevationScale=elevation_scale,\n            pickable=pickable,\n            opacity=opacity,\n            **kwargs,\n        )\n\n        self._deck_layers = {\n            **self._deck_layers,\n            layer_id: {\"type\": \"GeohashLayer\", \"id\": layer_id},\n        }\n\n    def add_wms_layer(\n        self,\n        data: str,\n        name: Optional[str] = None,\n        service_type: str = \"wms\",\n        layers: Optional[List[str]] = None,\n        srs: Optional[str] = None,\n        pickable: bool = False,\n        visible: bool = True,\n        opacity: float = 1.0,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a WMS layer for OGC Web Map Service visualization.\n\n        Args:\n            data: WMS base URL.\n            name: Layer ID.\n            service_type: Service type ('wms' or 'template').\n            layers: WMS layer names to request.\n            srs: Spatial reference system (e.g., 'EPSG:4326').\n            pickable: Whether layer responds to hover/click.\n            visible: Whether layer is visible.\n            opacity: Layer opacity (0-1).\n            **kwargs: Additional WMSLayer props.\n        \"\"\"\n        layer_id = name or f\"wms-{len(self._deck_layers)}\"\n\n        self.call_js_method(\n            \"addWMSLayer\",\n            id=layer_id,\n            data=data,\n            serviceType=service_type,\n            layers=layers,\n            srs=srs,\n            pickable=pickable,\n            visible=visible,\n            opacity=opacity,\n            **kwargs,\n        )\n\n        self._deck_layers = {\n            **self._deck_layers,\n            layer_id: {\"type\": \"WMSLayer\", \"id\": layer_id},\n        }\n\n    def add_simple_mesh_layer(\n        self,\n        data: Any,\n        mesh: str,\n        name: Optional[str] = None,\n        texture: Optional[str] = None,\n        get_position: Union[str, Callable] = \"coordinates\",\n        get_color: Union[List[int], str, Callable] = None,\n        get_orientation: Union[str, Callable] = None,\n        get_scale: Union[str, Callable] = None,\n        get_translation: Union[str, Callable] = None,\n        size_scale: float = 1,\n        wireframe: bool = False,\n        pickable: bool = True,\n        opacity: float = 1.0,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a simple mesh layer for 3D mesh visualization.\n\n        Args:\n            data: Array of data objects with position coordinates.\n            mesh: URL to OBJ/glTF mesh file.\n            name: Layer ID.\n            texture: URL to texture image.\n            get_position: Accessor for mesh position [lng, lat, z].\n            get_color: Accessor for mesh color [r, g, b, a].\n            get_orientation: Accessor for mesh orientation [pitch, yaw, roll].\n            get_scale: Accessor for mesh scale [x, y, z].\n            get_translation: Accessor for mesh translation [x, y, z].\n            size_scale: Global size multiplier.\n            wireframe: Whether to render as wireframe.\n            pickable: Whether layer responds to hover/click.\n            opacity: Layer opacity (0-1).\n            **kwargs: Additional SimpleMeshLayer props.\n        \"\"\"\n        layer_id = name or f\"simplemesh-{len(self._deck_layers)}\"\n        processed_data = self._process_deck_data(data)\n\n        layer_kwargs = {\n            \"id\": layer_id,\n            \"data\": processed_data,\n            \"mesh\": mesh,\n            \"getPosition\": get_position,\n            \"getColor\": get_color or [255, 255, 255, 255],\n            \"sizeScale\": size_scale,\n            \"wireframe\": wireframe,\n            \"pickable\": pickable,\n            \"opacity\": opacity,\n        }\n\n        if texture:\n            layer_kwargs[\"texture\"] = texture\n        if get_orientation:\n            layer_kwargs[\"getOrientation\"] = get_orientation\n        if get_scale:\n            layer_kwargs[\"getScale\"] = get_scale\n        if get_translation:\n            layer_kwargs[\"getTranslation\"] = get_translation\n\n        layer_kwargs.update(kwargs)\n        self.call_js_method(\"addSimpleMeshLayer\", **layer_kwargs)\n\n        self._deck_layers = {\n            **self._deck_layers,\n            layer_id: {\"type\": \"SimpleMeshLayer\", \"id\": layer_id},\n        }\n\n    def add_scenegraph_layer(\n        self,\n        data: Any,\n        scenegraph: str,\n        name: Optional[str] = None,\n        get_position: Union[str, Callable] = \"coordinates\",\n        get_color: Union[List[int], str, Callable] = None,\n        get_orientation: Union[str, Callable] = None,\n        get_scale: Union[str, Callable] = None,\n        get_translation: Union[str, Callable] = None,\n        size_scale: float = 1,\n        size_min_pixels: float = 0,\n        size_max_pixels: float = 10000,\n        pickable: bool = True,\n        opacity: float = 1.0,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a scenegraph layer for glTF model visualization.\n\n        Args:\n            data: Array of data objects with position coordinates.\n            scenegraph: URL to glTF/GLB model file.\n            name: Layer ID.\n            get_position: Accessor for model position [lng, lat, z].\n            get_color: Accessor for model tint color [r, g, b, a].\n            get_orientation: Accessor for model orientation [pitch, yaw, roll].\n            get_scale: Accessor for model scale [x, y, z].\n            get_translation: Accessor for model translation [x, y, z].\n            size_scale: Global size multiplier.\n            size_min_pixels: Minimum model size in pixels.\n            size_max_pixels: Maximum model size in pixels.\n            pickable: Whether layer responds to hover/click.\n            opacity: Layer opacity (0-1).\n            **kwargs: Additional ScenegraphLayer props.\n        \"\"\"\n        layer_id = name or f\"scenegraph-{len(self._deck_layers)}\"\n        processed_data = self._process_deck_data(data)\n\n        layer_kwargs = {\n            \"id\": layer_id,\n            \"data\": processed_data,\n            \"scenegraph\": scenegraph,\n            \"getPosition\": get_position,\n            \"getColor\": get_color or [255, 255, 255, 255],\n            \"sizeScale\": size_scale,\n            \"sizeMinPixels\": size_min_pixels,\n            \"sizeMaxPixels\": size_max_pixels,\n            \"pickable\": pickable,\n            \"opacity\": opacity,\n        }\n\n        if get_orientation:\n            layer_kwargs[\"getOrientation\"] = get_orientation\n        if get_scale:\n            layer_kwargs[\"getScale\"] = get_scale\n        if get_translation:\n            layer_kwargs[\"getTranslation\"] = get_translation\n\n        layer_kwargs.update(kwargs)\n        self.call_js_method(\"addScenegraphLayer\", **layer_kwargs)\n\n        self._deck_layers = {\n            **self._deck_layers,\n            layer_id: {\"type\": \"ScenegraphLayer\", \"id\": layer_id},\n        }\n\n    def remove_cog_layer(self, layer_id: str) -&gt; None:\n        \"\"\"Remove a COG layer.\n\n        Args:\n            layer_id: Layer identifier to remove.\n        \"\"\"\n        self.remove_deck_layer(layer_id)\n\n    # -------------------------------------------------------------------------\n    # DeckGL Layer Management\n    # -------------------------------------------------------------------------\n\n    def remove_deck_layer(self, layer_id: str) -&gt; None:\n        \"\"\"Remove a deck.gl layer.\n\n        Args:\n            layer_id: Layer identifier to remove.\n        \"\"\"\n        if layer_id in self._deck_layers:\n            layers = dict(self._deck_layers)\n            del layers[layer_id]\n            self._deck_layers = layers\n        self.call_js_method(\"removeDeckLayer\", layer_id)\n\n    def set_deck_layer_visibility(self, layer_id: str, visible: bool) -&gt; None:\n        \"\"\"Set deck.gl layer visibility.\n\n        Args:\n            layer_id: Layer identifier.\n            visible: Whether layer should be visible.\n        \"\"\"\n        self.call_js_method(\"setDeckLayerVisibility\", layer_id, visible)\n\n    # -------------------------------------------------------------------------\n    # Data Processing Helpers\n    # -------------------------------------------------------------------------\n\n    def _process_deck_data(self, data: Any) -&gt; Any:\n        \"\"\"Process data for deck.gl layers.\n\n        Handles GeoDataFrame, GeoJSON, and list of dicts.\n\n        Args:\n            data: Input data in various formats.\n\n        Returns:\n            Processed data suitable for deck.gl.\n        \"\"\"\n        # Handle GeoDataFrame\n        if hasattr(data, \"__geo_interface__\"):\n            return json.loads(data.to_json())\n\n        # Handle file path\n        if isinstance(data, (str, Path)):\n            path = Path(data)\n            if path.exists() and path.suffix.lower() in [\".geojson\", \".json\"]:\n                with open(path) as f:\n                    return json.load(f)\n            # Could be URL, return as-is\n            return str(data)\n\n        # Handle dict (GeoJSON or config)\n        if isinstance(data, dict):\n            return data\n\n        # Handle list of dicts\n        if isinstance(data, list):\n            return data\n\n        return data\n\n    # -------------------------------------------------------------------------\n    # HTML Export\n    # -------------------------------------------------------------------------\n\n    def _generate_html_template(self) -&gt; str:\n        \"\"\"Generate standalone HTML for the DeckGL map.\"\"\"\n        template_path = Path(__file__).parent / \"templates\" / \"deckgl.html\"\n\n        if template_path.exists():\n            template = template_path.read_text(encoding=\"utf-8\")\n        else:\n            template = self._get_default_template()\n\n        # Serialize state\n        state = {\n            \"center\": self.center,\n            \"zoom\": self.zoom,\n            \"style\": self.style,\n            \"bearing\": self.bearing,\n            \"pitch\": self.pitch,\n            \"width\": self.width,\n            \"height\": self.height,\n            \"layers\": self._layers,\n            \"sources\": self._sources,\n            \"controls\": self._controls,\n            \"deckLayers\": self._deck_layers,\n            \"js_calls\": self._js_calls,\n        }\n\n        template = template.replace(\"{{state}}\", json.dumps(state, indent=2))\n        return template\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.deckgl.DeckGLMap.__init__","title":"<code>__init__(self, center=(0.0, 0.0), zoom=2.0, width='100%', height='600px', style='https://demotiles.maplibre.org/style.json', bearing=0.0, pitch=0.0, max_pitch=85.0, controls=None, **kwargs)</code>  <code>special</code>","text":"<p>Initialize a DeckGL map.</p> <p>Parameters:</p> Name Type Description Default <code>center</code> <code>Tuple[float, float]</code> <p>Map center as (longitude, latitude).</p> <code>(0.0, 0.0)</code> <code>zoom</code> <code>float</code> <p>Initial zoom level.</p> <code>2.0</code> <code>width</code> <code>str</code> <p>Map width as CSS string.</p> <code>'100%'</code> <code>height</code> <code>str</code> <p>Map height as CSS string.</p> <code>'600px'</code> <code>style</code> <code>Union[str, Dict]</code> <p>MapLibre style URL or style object.</p> <code>'https://demotiles.maplibre.org/style.json'</code> <code>bearing</code> <code>float</code> <p>Map bearing in degrees.</p> <code>0.0</code> <code>pitch</code> <code>float</code> <p>Map pitch in degrees.</p> <code>0.0</code> <code>max_pitch</code> <code>float</code> <p>Maximum pitch angle in degrees (default: 85).</p> <code>85.0</code> <code>controls</code> <code>Optional[Dict[str, Any]]</code> <p>Dict of controls to add (e.g., {\"navigation\": True}).</p> <code>None</code> <code>**kwargs</code> <p>Additional widget arguments.</p> <code>{}</code> Source code in <code>anymap_ts/deckgl.py</code> <pre><code>def __init__(\n    self,\n    center: Tuple[float, float] = (0.0, 0.0),\n    zoom: float = 2.0,\n    width: str = \"100%\",\n    height: str = \"600px\",\n    style: Union[str, Dict] = \"https://demotiles.maplibre.org/style.json\",\n    bearing: float = 0.0,\n    pitch: float = 0.0,\n    max_pitch: float = 85.0,\n    controls: Optional[Dict[str, Any]] = None,\n    **kwargs,\n):\n    \"\"\"Initialize a DeckGL map.\n\n    Args:\n        center: Map center as (longitude, latitude).\n        zoom: Initial zoom level.\n        width: Map width as CSS string.\n        height: Map height as CSS string.\n        style: MapLibre style URL or style object.\n        bearing: Map bearing in degrees.\n        pitch: Map pitch in degrees.\n        max_pitch: Maximum pitch angle in degrees (default: 85).\n        controls: Dict of controls to add (e.g., {\"navigation\": True}).\n        **kwargs: Additional widget arguments.\n    \"\"\"\n    super().__init__(\n        center=center,\n        zoom=zoom,\n        width=width,\n        height=height,\n        style=style,\n        bearing=bearing,\n        pitch=pitch,\n        max_pitch=max_pitch,\n        controls=controls,\n        **kwargs,\n    )\n    self._deck_layers = {}\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.deckgl.DeckGLMap.add_arc_layer","title":"<code>add_arc_layer(self, data, name=None, get_source_position='source', get_target_position='target', get_source_color=None, get_target_color=None, get_width=1, pickable=True, opacity=0.8, **kwargs)</code>","text":"<p>Add an arc layer for origin-destination visualization.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>Array of data objects with source/target coordinates.</p> required <code>name</code> <code>Optional[str]</code> <p>Layer ID.</p> <code>None</code> <code>get_source_position</code> <code>Union[str, Callable]</code> <p>Accessor for source position [lng, lat].</p> <code>'source'</code> <code>get_target_position</code> <code>Union[str, Callable]</code> <p>Accessor for target position [lng, lat].</p> <code>'target'</code> <code>get_source_color</code> <code>Union[List[int], str, Callable]</code> <p>Accessor for source color [r, g, b, a].</p> <code>None</code> <code>get_target_color</code> <code>Union[List[int], str, Callable]</code> <p>Accessor for target color [r, g, b, a].</p> <code>None</code> <code>get_width</code> <code>Union[float, str, Callable]</code> <p>Accessor for arc width.</p> <code>1</code> <code>pickable</code> <code>bool</code> <p>Whether layer responds to hover/click.</p> <code>True</code> <code>opacity</code> <code>float</code> <p>Layer opacity.</p> <code>0.8</code> <code>**kwargs</code> <p>Additional layer props.</p> <code>{}</code> Source code in <code>anymap_ts/deckgl.py</code> <pre><code>def add_arc_layer(\n    self,\n    data: Any,\n    name: Optional[str] = None,\n    get_source_position: Union[str, Callable] = \"source\",\n    get_target_position: Union[str, Callable] = \"target\",\n    get_source_color: Union[List[int], str, Callable] = None,\n    get_target_color: Union[List[int], str, Callable] = None,\n    get_width: Union[float, str, Callable] = 1,\n    pickable: bool = True,\n    opacity: float = 0.8,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add an arc layer for origin-destination visualization.\n\n    Args:\n        data: Array of data objects with source/target coordinates.\n        name: Layer ID.\n        get_source_position: Accessor for source position [lng, lat].\n        get_target_position: Accessor for target position [lng, lat].\n        get_source_color: Accessor for source color [r, g, b, a].\n        get_target_color: Accessor for target color [r, g, b, a].\n        get_width: Accessor for arc width.\n        pickable: Whether layer responds to hover/click.\n        opacity: Layer opacity.\n        **kwargs: Additional layer props.\n    \"\"\"\n    layer_id = name or f\"arc-{len(self._deck_layers)}\"\n    processed_data = self._process_deck_data(data)\n\n    self.call_js_method(\n        \"addArcLayer\",\n        id=layer_id,\n        data=processed_data,\n        getSourcePosition=get_source_position,\n        getTargetPosition=get_target_position,\n        getSourceColor=get_source_color or [51, 136, 255, 255],\n        getTargetColor=get_target_color or [255, 136, 51, 255],\n        getWidth=get_width,\n        pickable=pickable,\n        opacity=opacity,\n        **kwargs,\n    )\n\n    self._deck_layers = {\n        **self._deck_layers,\n        layer_id: {\"type\": \"ArcLayer\", \"id\": layer_id},\n    }\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.deckgl.DeckGLMap.add_bitmap_layer","title":"<code>add_bitmap_layer(self, image, bounds, name=None, opacity=1.0, visible=True, pickable=False, desaturate=0, transparent_color=None, tint_color=None, **kwargs)</code>","text":"<p>Add a bitmap layer for raster image overlay.</p> <p>Parameters:</p> Name Type Description Default <code>image</code> <code>str</code> <p>URL or data URI of the image.</p> required <code>bounds</code> <code>List[float]</code> <p>Bounding box [west, south, east, north].</p> required <code>name</code> <code>Optional[str]</code> <p>Layer ID.</p> <code>None</code> <code>opacity</code> <code>float</code> <p>Layer opacity (0-1).</p> <code>1.0</code> <code>visible</code> <code>bool</code> <p>Whether layer is visible.</p> <code>True</code> <code>pickable</code> <code>bool</code> <p>Whether layer responds to hover/click.</p> <code>False</code> <code>desaturate</code> <code>float</code> <p>Desaturation amount (0-1).</p> <code>0</code> <code>transparent_color</code> <code>Optional[List[int]]</code> <p>Color to make transparent [r, g, b, a].</p> <code>None</code> <code>tint_color</code> <code>Optional[List[int]]</code> <p>Color to tint the image [r, g, b].</p> <code>None</code> <code>**kwargs</code> <p>Additional BitmapLayer props.</p> <code>{}</code> Source code in <code>anymap_ts/deckgl.py</code> <pre><code>def add_bitmap_layer(\n    self,\n    image: str,\n    bounds: List[float],\n    name: Optional[str] = None,\n    opacity: float = 1.0,\n    visible: bool = True,\n    pickable: bool = False,\n    desaturate: float = 0,\n    transparent_color: Optional[List[int]] = None,\n    tint_color: Optional[List[int]] = None,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a bitmap layer for raster image overlay.\n\n    Args:\n        image: URL or data URI of the image.\n        bounds: Bounding box [west, south, east, north].\n        name: Layer ID.\n        opacity: Layer opacity (0-1).\n        visible: Whether layer is visible.\n        pickable: Whether layer responds to hover/click.\n        desaturate: Desaturation amount (0-1).\n        transparent_color: Color to make transparent [r, g, b, a].\n        tint_color: Color to tint the image [r, g, b].\n        **kwargs: Additional BitmapLayer props.\n    \"\"\"\n    layer_id = name or f\"bitmap-{len(self._deck_layers)}\"\n\n    self.call_js_method(\n        \"addBitmapLayer\",\n        id=layer_id,\n        image=image,\n        bounds=bounds,\n        opacity=opacity,\n        visible=visible,\n        pickable=pickable,\n        desaturate=desaturate,\n        transparentColor=transparent_color or [0, 0, 0, 0],\n        tintColor=tint_color or [255, 255, 255],\n        **kwargs,\n    )\n\n    self._deck_layers = {\n        **self._deck_layers,\n        layer_id: {\"type\": \"BitmapLayer\", \"id\": layer_id},\n    }\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.deckgl.DeckGLMap.add_cog_layer","title":"<code>add_cog_layer(self, url, name=None, opacity=1.0, visible=True, debug=False, debug_opacity=0.25, max_error=0.125, fit_bounds=True, before_id=None, **kwargs)</code>","text":"<p>Add a Cloud Optimized GeoTIFF (COG) layer using @developmentseed/deck.gl-geotiff.</p> <p>This method renders COG files directly in the browser using GPU-accelerated deck.gl rendering with automatic reprojection support.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>URL to the Cloud Optimized GeoTIFF file.</p> required <code>name</code> <code>Optional[str]</code> <p>Layer ID. If None, auto-generated.</p> <code>None</code> <code>opacity</code> <code>float</code> <p>Layer opacity (0-1).</p> <code>1.0</code> <code>visible</code> <code>bool</code> <p>Whether layer is visible.</p> <code>True</code> <code>debug</code> <code>bool</code> <p>Show reprojection mesh for debugging.</p> <code>False</code> <code>debug_opacity</code> <code>float</code> <p>Opacity of debug mesh (0-1).</p> <code>0.25</code> <code>max_error</code> <code>float</code> <p>Maximum reprojection error in pixels. Lower values create denser mesh for better accuracy.</p> <code>0.125</code> <code>fit_bounds</code> <code>bool</code> <p>Whether to fit map to COG bounds after loading.</p> <code>True</code> <code>before_id</code> <code>Optional[str]</code> <p>ID of layer to insert before.</p> <code>None</code> <code>**kwargs</code> <p>Additional COGLayer props.</p> <code>{}</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; m = DeckGLMap()\n&gt;&gt;&gt; m.add_cog_layer(\n...     \"https://example.com/landcover.tif\",\n...     name=\"landcover\",\n...     opacity=0.8\n... )\n</code></pre> Source code in <code>anymap_ts/deckgl.py</code> <pre><code>def add_cog_layer(\n    self,\n    url: str,\n    name: Optional[str] = None,\n    opacity: float = 1.0,\n    visible: bool = True,\n    debug: bool = False,\n    debug_opacity: float = 0.25,\n    max_error: float = 0.125,\n    fit_bounds: bool = True,\n    before_id: Optional[str] = None,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a Cloud Optimized GeoTIFF (COG) layer using @developmentseed/deck.gl-geotiff.\n\n    This method renders COG files directly in the browser using GPU-accelerated\n    deck.gl rendering with automatic reprojection support.\n\n    Args:\n        url: URL to the Cloud Optimized GeoTIFF file.\n        name: Layer ID. If None, auto-generated.\n        opacity: Layer opacity (0-1).\n        visible: Whether layer is visible.\n        debug: Show reprojection mesh for debugging.\n        debug_opacity: Opacity of debug mesh (0-1).\n        max_error: Maximum reprojection error in pixels. Lower values\n            create denser mesh for better accuracy.\n        fit_bounds: Whether to fit map to COG bounds after loading.\n        before_id: ID of layer to insert before.\n        **kwargs: Additional COGLayer props.\n\n    Example:\n        &gt;&gt;&gt; m = DeckGLMap()\n        &gt;&gt;&gt; m.add_cog_layer(\n        ...     \"https://example.com/landcover.tif\",\n        ...     name=\"landcover\",\n        ...     opacity=0.8\n        ... )\n    \"\"\"\n    # Use a monotonically increasing counter to avoid ID collisions when layers are removed.\n    counter = getattr(self, \"_cog_layer_counter\", 0)\n    layer_id = name or f\"cog-{counter}\"\n    self._cog_layer_counter = counter + 1\n\n    self.call_js_method(\n        \"addCOGLayer\",\n        id=layer_id,\n        geotiff=url,\n        opacity=opacity,\n        visible=visible,\n        debug=debug,\n        debugOpacity=debug_opacity,\n        maxError=max_error,\n        fitBounds=fit_bounds,\n        beforeId=before_id,\n        **kwargs,\n    )\n\n    self._deck_layers = {\n        **self._deck_layers,\n        layer_id: {\"type\": \"COGLayer\", \"id\": layer_id, \"url\": url},\n    }\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.deckgl.DeckGLMap.add_column_layer","title":"<code>add_column_layer(self, data, name=None, get_position='coordinates', get_fill_color=None, get_line_color=None, get_elevation=1000, radius=1000, disk_resolution=20, elevation_scale=1, coverage=1, extruded=True, filled=True, stroked=False, wireframe=False, pickable=True, opacity=0.8, **kwargs)</code>","text":"<p>Add a column layer for 3D column/bar visualization.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>Array of data objects with position coordinates.</p> required <code>name</code> <code>Optional[str]</code> <p>Layer ID.</p> <code>None</code> <code>get_position</code> <code>Union[str, Callable]</code> <p>Accessor for column position [lng, lat].</p> <code>'coordinates'</code> <code>get_fill_color</code> <code>Union[List[int], str, Callable]</code> <p>Accessor for fill color [r, g, b, a].</p> <code>None</code> <code>get_line_color</code> <code>Union[List[int], str, Callable]</code> <p>Accessor for stroke color [r, g, b, a].</p> <code>None</code> <code>get_elevation</code> <code>Union[float, str, Callable]</code> <p>Accessor for column height.</p> <code>1000</code> <code>radius</code> <code>float</code> <p>Column radius in meters.</p> <code>1000</code> <code>disk_resolution</code> <code>int</code> <p>Number of sides for column polygon.</p> <code>20</code> <code>elevation_scale</code> <code>float</code> <p>Elevation multiplier.</p> <code>1</code> <code>coverage</code> <code>float</code> <p>Column coverage (0-1).</p> <code>1</code> <code>extruded</code> <code>bool</code> <p>Whether to extrude columns.</p> <code>True</code> <code>filled</code> <code>bool</code> <p>Whether to fill columns.</p> <code>True</code> <code>stroked</code> <code>bool</code> <p>Whether to stroke columns.</p> <code>False</code> <code>wireframe</code> <code>bool</code> <p>Whether to render as wireframe.</p> <code>False</code> <code>pickable</code> <code>bool</code> <p>Whether layer responds to hover/click.</p> <code>True</code> <code>opacity</code> <code>float</code> <p>Layer opacity.</p> <code>0.8</code> <code>**kwargs</code> <p>Additional ColumnLayer props.</p> <code>{}</code> Source code in <code>anymap_ts/deckgl.py</code> <pre><code>def add_column_layer(\n    self,\n    data: Any,\n    name: Optional[str] = None,\n    get_position: Union[str, Callable] = \"coordinates\",\n    get_fill_color: Union[List[int], str, Callable] = None,\n    get_line_color: Union[List[int], str, Callable] = None,\n    get_elevation: Union[float, str, Callable] = 1000,\n    radius: float = 1000,\n    disk_resolution: int = 20,\n    elevation_scale: float = 1,\n    coverage: float = 1,\n    extruded: bool = True,\n    filled: bool = True,\n    stroked: bool = False,\n    wireframe: bool = False,\n    pickable: bool = True,\n    opacity: float = 0.8,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a column layer for 3D column/bar visualization.\n\n    Args:\n        data: Array of data objects with position coordinates.\n        name: Layer ID.\n        get_position: Accessor for column position [lng, lat].\n        get_fill_color: Accessor for fill color [r, g, b, a].\n        get_line_color: Accessor for stroke color [r, g, b, a].\n        get_elevation: Accessor for column height.\n        radius: Column radius in meters.\n        disk_resolution: Number of sides for column polygon.\n        elevation_scale: Elevation multiplier.\n        coverage: Column coverage (0-1).\n        extruded: Whether to extrude columns.\n        filled: Whether to fill columns.\n        stroked: Whether to stroke columns.\n        wireframe: Whether to render as wireframe.\n        pickable: Whether layer responds to hover/click.\n        opacity: Layer opacity.\n        **kwargs: Additional ColumnLayer props.\n    \"\"\"\n    layer_id = name or f\"column-{len(self._deck_layers)}\"\n    processed_data = self._process_deck_data(data)\n\n    self.call_js_method(\n        \"addColumnLayer\",\n        id=layer_id,\n        data=processed_data,\n        getPosition=get_position,\n        getFillColor=get_fill_color or [255, 140, 0, 200],\n        getLineColor=get_line_color or [0, 0, 0, 255],\n        getElevation=get_elevation,\n        radius=radius,\n        diskResolution=disk_resolution,\n        elevationScale=elevation_scale,\n        coverage=coverage,\n        extruded=extruded,\n        filled=filled,\n        stroked=stroked,\n        wireframe=wireframe,\n        pickable=pickable,\n        opacity=opacity,\n        **kwargs,\n    )\n\n    self._deck_layers = {\n        **self._deck_layers,\n        layer_id: {\"type\": \"ColumnLayer\", \"id\": layer_id},\n    }\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.deckgl.DeckGLMap.add_contour_layer","title":"<code>add_contour_layer(self, data, name=None, get_position='coordinates', get_weight=1, cell_size=200, contours=None, pickable=True, opacity=1, **kwargs)</code>","text":"<p>Add a contour layer for isoline visualization.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>Array of data objects with position coordinates.</p> required <code>name</code> <code>Optional[str]</code> <p>Layer ID.</p> <code>None</code> <code>get_position</code> <code>Union[str, Callable]</code> <p>Accessor for point position [lng, lat].</p> <code>'coordinates'</code> <code>get_weight</code> <code>Union[float, str, Callable]</code> <p>Accessor for point weight.</p> <code>1</code> <code>cell_size</code> <code>float</code> <p>Grid cell size for aggregation.</p> <code>200</code> <code>contours</code> <code>Optional[List[Dict]]</code> <p>Contour definitions [{threshold, color, strokeWidth}, ...].</p> <code>None</code> <code>pickable</code> <code>bool</code> <p>Whether layer responds to hover/click.</p> <code>True</code> <code>opacity</code> <code>float</code> <p>Layer opacity.</p> <code>1</code> <code>**kwargs</code> <p>Additional layer props.</p> <code>{}</code> Source code in <code>anymap_ts/deckgl.py</code> <pre><code>def add_contour_layer(\n    self,\n    data: Any,\n    name: Optional[str] = None,\n    get_position: Union[str, Callable] = \"coordinates\",\n    get_weight: Union[float, str, Callable] = 1,\n    cell_size: float = 200,\n    contours: Optional[List[Dict]] = None,\n    pickable: bool = True,\n    opacity: float = 1,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a contour layer for isoline visualization.\n\n    Args:\n        data: Array of data objects with position coordinates.\n        name: Layer ID.\n        get_position: Accessor for point position [lng, lat].\n        get_weight: Accessor for point weight.\n        cell_size: Grid cell size for aggregation.\n        contours: Contour definitions [{threshold, color, strokeWidth}, ...].\n        pickable: Whether layer responds to hover/click.\n        opacity: Layer opacity.\n        **kwargs: Additional layer props.\n    \"\"\"\n    layer_id = name or f\"contour-{len(self._deck_layers)}\"\n    processed_data = self._process_deck_data(data)\n\n    default_contours = [\n        {\"threshold\": 1, \"color\": [255, 255, 255], \"strokeWidth\": 1},\n        {\"threshold\": 5, \"color\": [51, 136, 255], \"strokeWidth\": 2},\n        {\"threshold\": 10, \"color\": [0, 0, 255], \"strokeWidth\": 3},\n    ]\n\n    self.call_js_method(\n        \"addContourLayer\",\n        id=layer_id,\n        data=processed_data,\n        getPosition=get_position,\n        getWeight=get_weight,\n        cellSize=cell_size,\n        contours=contours or default_contours,\n        pickable=pickable,\n        opacity=opacity,\n        **kwargs,\n    )\n\n    self._deck_layers = {\n        **self._deck_layers,\n        layer_id: {\"type\": \"ContourLayer\", \"id\": layer_id},\n    }\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.deckgl.DeckGLMap.add_deckgl_layer","title":"<code>add_deckgl_layer(self, layer_type, data, name=None, **kwargs)</code>","text":"<p>Add a generic deck.gl layer to the map.</p> <p>This method provides a flexible way to add any supported deck.gl layer type using a single interface. For commonly used layers, prefer the specific methods (e.g., add_scatterplot_layer) for better IDE support.</p> <p>Parameters:</p> Name Type Description Default <code>layer_type</code> <code>str</code> <p>The deck.gl layer type. Supported types include: 'ScatterplotLayer', 'ArcLayer', 'PathLayer', 'PolygonLayer', 'HexagonLayer', 'HeatmapLayer', 'GridLayer', 'IconLayer', 'TextLayer', 'GeoJsonLayer', 'ContourLayer', 'ScreenGridLayer', 'PointCloudLayer', 'TripsLayer', 'LineLayer'.</p> required <code>data</code> <code>Any</code> <p>Array of data objects or GeoJSON.</p> required <code>name</code> <code>Optional[str]</code> <p>Layer ID. If None, auto-generated from layer_type.</p> <code>None</code> <code>**kwargs</code> <p>Layer-specific properties passed directly to deck.gl. Common properties include: - opacity: Layer opacity (0-1) - pickable: Whether layer responds to hover/click - getPosition: Accessor for position coordinates - getColor/getFillColor/getLineColor: Color accessors</p> <code>{}</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; m = DeckGLMap()\n&gt;&gt;&gt; # Add a TripsLayer with animation\n&gt;&gt;&gt; m.add_deckgl_layer(\n...     'TripsLayer',\n...     data=trips_data,\n...     getPath='waypoints',\n...     getTimestamps='timestamps',\n...     getColor=[253, 128, 93],\n...     trailLength=180,\n... )\n&gt;&gt;&gt; # Add a LineLayer\n&gt;&gt;&gt; m.add_deckgl_layer(\n...     'LineLayer',\n...     data=lines_data,\n...     getSourcePosition='source',\n...     getTargetPosition='target',\n...     getColor=[0, 128, 255],\n... )\n</code></pre> Source code in <code>anymap_ts/deckgl.py</code> <pre><code>def add_deckgl_layer(\n    self,\n    layer_type: str,\n    data: Any,\n    name: Optional[str] = None,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a generic deck.gl layer to the map.\n\n    This method provides a flexible way to add any supported deck.gl layer\n    type using a single interface. For commonly used layers, prefer the\n    specific methods (e.g., add_scatterplot_layer) for better IDE support.\n\n    Args:\n        layer_type: The deck.gl layer type. Supported types include:\n            'ScatterplotLayer', 'ArcLayer', 'PathLayer', 'PolygonLayer',\n            'HexagonLayer', 'HeatmapLayer', 'GridLayer', 'IconLayer',\n            'TextLayer', 'GeoJsonLayer', 'ContourLayer', 'ScreenGridLayer',\n            'PointCloudLayer', 'TripsLayer', 'LineLayer'.\n        data: Array of data objects or GeoJSON.\n        name: Layer ID. If None, auto-generated from layer_type.\n        **kwargs: Layer-specific properties passed directly to deck.gl.\n            Common properties include:\n            - opacity: Layer opacity (0-1)\n            - pickable: Whether layer responds to hover/click\n            - getPosition: Accessor for position coordinates\n            - getColor/getFillColor/getLineColor: Color accessors\n\n    Example:\n        &gt;&gt;&gt; m = DeckGLMap()\n        &gt;&gt;&gt; # Add a TripsLayer with animation\n        &gt;&gt;&gt; m.add_deckgl_layer(\n        ...     'TripsLayer',\n        ...     data=trips_data,\n        ...     getPath='waypoints',\n        ...     getTimestamps='timestamps',\n        ...     getColor=[253, 128, 93],\n        ...     trailLength=180,\n        ... )\n        &gt;&gt;&gt; # Add a LineLayer\n        &gt;&gt;&gt; m.add_deckgl_layer(\n        ...     'LineLayer',\n        ...     data=lines_data,\n        ...     getSourcePosition='source',\n        ...     getTargetPosition='target',\n        ...     getColor=[0, 128, 255],\n        ... )\n    \"\"\"\n    # Normalize layer type and create prefix\n    layer_type_clean = layer_type.replace(\"Layer\", \"\")\n    prefix = layer_type_clean.lower()\n    layer_id = name or f\"{prefix}-{len(self._deck_layers)}\"\n    processed_data = self._process_deck_data(data)\n\n    self.call_js_method(\n        \"addDeckGLLayer\",\n        layerType=layer_type,\n        id=layer_id,\n        data=processed_data,\n        **kwargs,\n    )\n\n    self._deck_layers = {\n        **self._deck_layers,\n        layer_id: {\"type\": layer_type, \"id\": layer_id},\n    }\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.deckgl.DeckGLMap.add_geohash_layer","title":"<code>add_geohash_layer(self, data, name=None, get_geohash='geohash', get_fill_color=None, get_line_color=None, get_line_width=1, get_elevation=0, filled=True, stroked=True, extruded=False, wireframe=False, elevation_scale=1, pickable=True, opacity=0.8, **kwargs)</code>","text":"<p>Add a Geohash layer for geohash cell visualization.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>Array of data objects with geohash.</p> required <code>name</code> <code>Optional[str]</code> <p>Layer ID.</p> <code>None</code> <code>get_geohash</code> <code>Union[str, Callable]</code> <p>Accessor for geohash string.</p> <code>'geohash'</code> <code>get_fill_color</code> <code>Union[List[int], str, Callable]</code> <p>Accessor for fill color [r, g, b, a].</p> <code>None</code> <code>get_line_color</code> <code>Union[List[int], str, Callable]</code> <p>Accessor for stroke color [r, g, b, a].</p> <code>None</code> <code>get_line_width</code> <code>Union[float, str, Callable]</code> <p>Accessor for line width.</p> <code>1</code> <code>get_elevation</code> <code>Union[float, str, Callable]</code> <p>Accessor for 3D extrusion height.</p> <code>0</code> <code>filled</code> <code>bool</code> <p>Whether to fill cells.</p> <code>True</code> <code>stroked</code> <code>bool</code> <p>Whether to stroke cells.</p> <code>True</code> <code>extruded</code> <code>bool</code> <p>Whether to render as 3D.</p> <code>False</code> <code>wireframe</code> <code>bool</code> <p>Whether to render wireframe.</p> <code>False</code> <code>elevation_scale</code> <code>float</code> <p>Elevation multiplier.</p> <code>1</code> <code>pickable</code> <code>bool</code> <p>Whether layer responds to hover/click.</p> <code>True</code> <code>opacity</code> <code>float</code> <p>Layer opacity.</p> <code>0.8</code> <code>**kwargs</code> <p>Additional GeohashLayer props.</p> <code>{}</code> Source code in <code>anymap_ts/deckgl.py</code> <pre><code>def add_geohash_layer(\n    self,\n    data: Any,\n    name: Optional[str] = None,\n    get_geohash: Union[str, Callable] = \"geohash\",\n    get_fill_color: Union[List[int], str, Callable] = None,\n    get_line_color: Union[List[int], str, Callable] = None,\n    get_line_width: Union[float, str, Callable] = 1,\n    get_elevation: Union[float, str, Callable] = 0,\n    filled: bool = True,\n    stroked: bool = True,\n    extruded: bool = False,\n    wireframe: bool = False,\n    elevation_scale: float = 1,\n    pickable: bool = True,\n    opacity: float = 0.8,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a Geohash layer for geohash cell visualization.\n\n    Args:\n        data: Array of data objects with geohash.\n        name: Layer ID.\n        get_geohash: Accessor for geohash string.\n        get_fill_color: Accessor for fill color [r, g, b, a].\n        get_line_color: Accessor for stroke color [r, g, b, a].\n        get_line_width: Accessor for line width.\n        get_elevation: Accessor for 3D extrusion height.\n        filled: Whether to fill cells.\n        stroked: Whether to stroke cells.\n        extruded: Whether to render as 3D.\n        wireframe: Whether to render wireframe.\n        elevation_scale: Elevation multiplier.\n        pickable: Whether layer responds to hover/click.\n        opacity: Layer opacity.\n        **kwargs: Additional GeohashLayer props.\n    \"\"\"\n    layer_id = name or f\"geohash-{len(self._deck_layers)}\"\n    processed_data = self._process_deck_data(data)\n\n    self.call_js_method(\n        \"addGeohashLayer\",\n        id=layer_id,\n        data=processed_data,\n        getGeohash=get_geohash,\n        getFillColor=get_fill_color or [51, 136, 255, 128],\n        getLineColor=get_line_color or [0, 0, 0, 255],\n        getLineWidth=get_line_width,\n        getElevation=get_elevation,\n        filled=filled,\n        stroked=stroked,\n        extruded=extruded,\n        wireframe=wireframe,\n        elevationScale=elevation_scale,\n        pickable=pickable,\n        opacity=opacity,\n        **kwargs,\n    )\n\n    self._deck_layers = {\n        **self._deck_layers,\n        layer_id: {\"type\": \"GeohashLayer\", \"id\": layer_id},\n    }\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.deckgl.DeckGLMap.add_geojson_layer","title":"<code>add_geojson_layer(self, data, name=None, get_fill_color=None, get_line_color=None, get_line_width=1, get_point_radius=5, get_elevation=0, extruded=False, wireframe=False, filled=True, stroked=True, line_width_min_pixels=1, point_radius_min_pixels=2, pickable=True, opacity=0.8, **kwargs)</code>","text":"<p>Add a GeoJSON layer for rendering GeoJSON features.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>GeoJSON object or URL.</p> required <code>name</code> <code>Optional[str]</code> <p>Layer ID.</p> <code>None</code> <code>get_fill_color</code> <code>Union[List[int], str, Callable]</code> <p>Accessor for fill color [r, g, b, a].</p> <code>None</code> <code>get_line_color</code> <code>Union[List[int], str, Callable]</code> <p>Accessor for stroke color [r, g, b, a].</p> <code>None</code> <code>get_line_width</code> <code>Union[float, str, Callable]</code> <p>Accessor for stroke width.</p> <code>1</code> <code>get_point_radius</code> <code>Union[float, str, Callable]</code> <p>Accessor for point radius.</p> <code>5</code> <code>get_elevation</code> <code>Union[float, str, Callable]</code> <p>Accessor for 3D extrusion height.</p> <code>0</code> <code>extruded</code> <code>bool</code> <p>Whether to render as 3D features.</p> <code>False</code> <code>wireframe</code> <code>bool</code> <p>Whether to render wireframe (extruded only).</p> <code>False</code> <code>filled</code> <code>bool</code> <p>Whether to fill features.</p> <code>True</code> <code>stroked</code> <code>bool</code> <p>Whether to draw stroke.</p> <code>True</code> <code>line_width_min_pixels</code> <code>float</code> <p>Minimum stroke width.</p> <code>1</code> <code>point_radius_min_pixels</code> <code>float</code> <p>Minimum point radius.</p> <code>2</code> <code>pickable</code> <code>bool</code> <p>Whether layer responds to hover/click.</p> <code>True</code> <code>opacity</code> <code>float</code> <p>Layer opacity.</p> <code>0.8</code> <code>**kwargs</code> <p>Additional layer props.</p> <code>{}</code> Source code in <code>anymap_ts/deckgl.py</code> <pre><code>def add_geojson_layer(\n    self,\n    data: Any,\n    name: Optional[str] = None,\n    get_fill_color: Union[List[int], str, Callable] = None,\n    get_line_color: Union[List[int], str, Callable] = None,\n    get_line_width: Union[float, str, Callable] = 1,\n    get_point_radius: Union[float, str, Callable] = 5,\n    get_elevation: Union[float, str, Callable] = 0,\n    extruded: bool = False,\n    wireframe: bool = False,\n    filled: bool = True,\n    stroked: bool = True,\n    line_width_min_pixels: float = 1,\n    point_radius_min_pixels: float = 2,\n    pickable: bool = True,\n    opacity: float = 0.8,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a GeoJSON layer for rendering GeoJSON features.\n\n    Args:\n        data: GeoJSON object or URL.\n        name: Layer ID.\n        get_fill_color: Accessor for fill color [r, g, b, a].\n        get_line_color: Accessor for stroke color [r, g, b, a].\n        get_line_width: Accessor for stroke width.\n        get_point_radius: Accessor for point radius.\n        get_elevation: Accessor for 3D extrusion height.\n        extruded: Whether to render as 3D features.\n        wireframe: Whether to render wireframe (extruded only).\n        filled: Whether to fill features.\n        stroked: Whether to draw stroke.\n        line_width_min_pixels: Minimum stroke width.\n        point_radius_min_pixels: Minimum point radius.\n        pickable: Whether layer responds to hover/click.\n        opacity: Layer opacity.\n        **kwargs: Additional layer props.\n    \"\"\"\n    layer_id = name or f\"geojson-{len(self._deck_layers)}\"\n    processed_data = self._process_deck_data(data)\n\n    self.call_js_method(\n        \"addGeoJsonLayer\",\n        id=layer_id,\n        data=processed_data,\n        getFillColor=get_fill_color or [51, 136, 255, 128],\n        getLineColor=get_line_color or [0, 0, 0, 255],\n        getLineWidth=get_line_width,\n        getPointRadius=get_point_radius,\n        getElevation=get_elevation,\n        extruded=extruded,\n        wireframe=wireframe,\n        filled=filled,\n        stroked=stroked,\n        lineWidthMinPixels=line_width_min_pixels,\n        pointRadiusMinPixels=point_radius_min_pixels,\n        pickable=pickable,\n        opacity=opacity,\n        **kwargs,\n    )\n\n    self._deck_layers = {\n        **self._deck_layers,\n        layer_id: {\"type\": \"GeoJsonLayer\", \"id\": layer_id},\n    }\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.deckgl.DeckGLMap.add_great_circle_layer","title":"<code>add_great_circle_layer(self, data, name=None, get_source_position='source', get_target_position='target', get_source_color=None, get_target_color=None, get_width=1, width_min_pixels=1, width_max_pixels=100, pickable=True, opacity=0.8, **kwargs)</code>","text":"<p>Add a great circle layer for geodesic arc visualization.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>Array of data objects with source/target coordinates.</p> required <code>name</code> <code>Optional[str]</code> <p>Layer ID.</p> <code>None</code> <code>get_source_position</code> <code>Union[str, Callable]</code> <p>Accessor for source position [lng, lat].</p> <code>'source'</code> <code>get_target_position</code> <code>Union[str, Callable]</code> <p>Accessor for target position [lng, lat].</p> <code>'target'</code> <code>get_source_color</code> <code>Union[List[int], str, Callable]</code> <p>Accessor for source color [r, g, b, a].</p> <code>None</code> <code>get_target_color</code> <code>Union[List[int], str, Callable]</code> <p>Accessor for target color [r, g, b, a].</p> <code>None</code> <code>get_width</code> <code>Union[float, str, Callable]</code> <p>Accessor for line width.</p> <code>1</code> <code>width_min_pixels</code> <code>float</code> <p>Minimum line width in pixels.</p> <code>1</code> <code>width_max_pixels</code> <code>float</code> <p>Maximum line width in pixels.</p> <code>100</code> <code>pickable</code> <code>bool</code> <p>Whether layer responds to hover/click.</p> <code>True</code> <code>opacity</code> <code>float</code> <p>Layer opacity.</p> <code>0.8</code> <code>**kwargs</code> <p>Additional GreatCircleLayer props.</p> <code>{}</code> Source code in <code>anymap_ts/deckgl.py</code> <pre><code>def add_great_circle_layer(\n    self,\n    data: Any,\n    name: Optional[str] = None,\n    get_source_position: Union[str, Callable] = \"source\",\n    get_target_position: Union[str, Callable] = \"target\",\n    get_source_color: Union[List[int], str, Callable] = None,\n    get_target_color: Union[List[int], str, Callable] = None,\n    get_width: Union[float, str, Callable] = 1,\n    width_min_pixels: float = 1,\n    width_max_pixels: float = 100,\n    pickable: bool = True,\n    opacity: float = 0.8,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a great circle layer for geodesic arc visualization.\n\n    Args:\n        data: Array of data objects with source/target coordinates.\n        name: Layer ID.\n        get_source_position: Accessor for source position [lng, lat].\n        get_target_position: Accessor for target position [lng, lat].\n        get_source_color: Accessor for source color [r, g, b, a].\n        get_target_color: Accessor for target color [r, g, b, a].\n        get_width: Accessor for line width.\n        width_min_pixels: Minimum line width in pixels.\n        width_max_pixels: Maximum line width in pixels.\n        pickable: Whether layer responds to hover/click.\n        opacity: Layer opacity.\n        **kwargs: Additional GreatCircleLayer props.\n    \"\"\"\n    layer_id = name or f\"greatcircle-{len(self._deck_layers)}\"\n    processed_data = self._process_deck_data(data)\n\n    self.call_js_method(\n        \"addGreatCircleLayer\",\n        id=layer_id,\n        data=processed_data,\n        getSourcePosition=get_source_position,\n        getTargetPosition=get_target_position,\n        getSourceColor=get_source_color or [51, 136, 255, 255],\n        getTargetColor=get_target_color or [255, 136, 51, 255],\n        getWidth=get_width,\n        widthMinPixels=width_min_pixels,\n        widthMaxPixels=width_max_pixels,\n        pickable=pickable,\n        opacity=opacity,\n        **kwargs,\n    )\n\n    self._deck_layers = {\n        **self._deck_layers,\n        layer_id: {\"type\": \"GreatCircleLayer\", \"id\": layer_id},\n    }\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.deckgl.DeckGLMap.add_grid_cell_layer","title":"<code>add_grid_cell_layer(self, data, name=None, get_position='coordinates', get_color=None, get_elevation=1000, cell_size=200, coverage=1, elevation_scale=1, extruded=True, pickable=True, opacity=0.8, **kwargs)</code>","text":"<p>Add a grid cell layer for pre-aggregated grid visualization.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>Array of data objects with position coordinates.</p> required <code>name</code> <code>Optional[str]</code> <p>Layer ID.</p> <code>None</code> <code>get_position</code> <code>Union[str, Callable]</code> <p>Accessor for cell position [lng, lat].</p> <code>'coordinates'</code> <code>get_color</code> <code>Union[List[int], str, Callable]</code> <p>Accessor for cell color [r, g, b, a].</p> <code>None</code> <code>get_elevation</code> <code>Union[float, str, Callable]</code> <p>Accessor for cell height.</p> <code>1000</code> <code>cell_size</code> <code>float</code> <p>Cell size in meters.</p> <code>200</code> <code>coverage</code> <code>float</code> <p>Cell coverage (0-1).</p> <code>1</code> <code>elevation_scale</code> <code>float</code> <p>Elevation multiplier.</p> <code>1</code> <code>extruded</code> <code>bool</code> <p>Whether to extrude cells.</p> <code>True</code> <code>pickable</code> <code>bool</code> <p>Whether layer responds to hover/click.</p> <code>True</code> <code>opacity</code> <code>float</code> <p>Layer opacity.</p> <code>0.8</code> <code>**kwargs</code> <p>Additional GridCellLayer props.</p> <code>{}</code> Source code in <code>anymap_ts/deckgl.py</code> <pre><code>def add_grid_cell_layer(\n    self,\n    data: Any,\n    name: Optional[str] = None,\n    get_position: Union[str, Callable] = \"coordinates\",\n    get_color: Union[List[int], str, Callable] = None,\n    get_elevation: Union[float, str, Callable] = 1000,\n    cell_size: float = 200,\n    coverage: float = 1,\n    elevation_scale: float = 1,\n    extruded: bool = True,\n    pickable: bool = True,\n    opacity: float = 0.8,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a grid cell layer for pre-aggregated grid visualization.\n\n    Args:\n        data: Array of data objects with position coordinates.\n        name: Layer ID.\n        get_position: Accessor for cell position [lng, lat].\n        get_color: Accessor for cell color [r, g, b, a].\n        get_elevation: Accessor for cell height.\n        cell_size: Cell size in meters.\n        coverage: Cell coverage (0-1).\n        elevation_scale: Elevation multiplier.\n        extruded: Whether to extrude cells.\n        pickable: Whether layer responds to hover/click.\n        opacity: Layer opacity.\n        **kwargs: Additional GridCellLayer props.\n    \"\"\"\n    layer_id = name or f\"gridcell-{len(self._deck_layers)}\"\n    processed_data = self._process_deck_data(data)\n\n    self.call_js_method(\n        \"addGridCellLayer\",\n        id=layer_id,\n        data=processed_data,\n        getPosition=get_position,\n        getColor=get_color or [255, 140, 0, 200],\n        getElevation=get_elevation,\n        cellSize=cell_size,\n        coverage=coverage,\n        elevationScale=elevation_scale,\n        extruded=extruded,\n        pickable=pickable,\n        opacity=opacity,\n        **kwargs,\n    )\n\n    self._deck_layers = {\n        **self._deck_layers,\n        layer_id: {\"type\": \"GridCellLayer\", \"id\": layer_id},\n    }\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.deckgl.DeckGLMap.add_grid_layer","title":"<code>add_grid_layer(self, data, name=None, get_position='coordinates', cell_size=200, elevation_scale=4, extruded=True, color_range=None, pickable=True, opacity=0.8, **kwargs)</code>","text":"<p>Add a grid layer for square grid aggregation visualization.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>Array of data objects with position coordinates.</p> required <code>name</code> <code>Optional[str]</code> <p>Layer ID.</p> <code>None</code> <code>get_position</code> <code>Union[str, Callable]</code> <p>Accessor for point position [lng, lat].</p> <code>'coordinates'</code> <code>cell_size</code> <code>float</code> <p>Grid cell size in meters.</p> <code>200</code> <code>elevation_scale</code> <code>float</code> <p>Elevation multiplier for 3D.</p> <code>4</code> <code>extruded</code> <code>bool</code> <p>Whether to render as 3D cells.</p> <code>True</code> <code>color_range</code> <code>Optional[List[List[int]]]</code> <p>Color gradient [[r, g, b], ...].</p> <code>None</code> <code>pickable</code> <code>bool</code> <p>Whether layer responds to hover/click.</p> <code>True</code> <code>opacity</code> <code>float</code> <p>Layer opacity.</p> <code>0.8</code> <code>**kwargs</code> <p>Additional layer props.</p> <code>{}</code> Source code in <code>anymap_ts/deckgl.py</code> <pre><code>def add_grid_layer(\n    self,\n    data: Any,\n    name: Optional[str] = None,\n    get_position: Union[str, Callable] = \"coordinates\",\n    cell_size: float = 200,\n    elevation_scale: float = 4,\n    extruded: bool = True,\n    color_range: Optional[List[List[int]]] = None,\n    pickable: bool = True,\n    opacity: float = 0.8,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a grid layer for square grid aggregation visualization.\n\n    Args:\n        data: Array of data objects with position coordinates.\n        name: Layer ID.\n        get_position: Accessor for point position [lng, lat].\n        cell_size: Grid cell size in meters.\n        elevation_scale: Elevation multiplier for 3D.\n        extruded: Whether to render as 3D cells.\n        color_range: Color gradient [[r, g, b], ...].\n        pickable: Whether layer responds to hover/click.\n        opacity: Layer opacity.\n        **kwargs: Additional layer props.\n    \"\"\"\n    layer_id = name or f\"grid-{len(self._deck_layers)}\"\n    processed_data = self._process_deck_data(data)\n\n    default_color_range = [\n        [1, 152, 189],\n        [73, 227, 206],\n        [216, 254, 181],\n        [254, 237, 177],\n        [254, 173, 84],\n        [209, 55, 78],\n    ]\n\n    self.call_js_method(\n        \"addGridLayer\",\n        id=layer_id,\n        data=processed_data,\n        getPosition=get_position,\n        cellSize=cell_size,\n        elevationScale=elevation_scale,\n        extruded=extruded,\n        colorRange=color_range or default_color_range,\n        pickable=pickable,\n        opacity=opacity,\n        **kwargs,\n    )\n\n    self._deck_layers = {\n        **self._deck_layers,\n        layer_id: {\"type\": \"GridLayer\", \"id\": layer_id},\n    }\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.deckgl.DeckGLMap.add_h3_cluster_layer","title":"<code>add_h3_cluster_layer(self, data, name=None, get_hexagons='hexagons', get_fill_color=None, get_line_color=None, get_line_width=1, filled=True, stroked=True, extruded=False, elevation_scale=1, pickable=True, opacity=0.8, **kwargs)</code>","text":"<p>Add an H3 cluster layer for grouped H3 cell visualization.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>Array of data objects with H3 index arrays.</p> required <code>name</code> <code>Optional[str]</code> <p>Layer ID.</p> <code>None</code> <code>get_hexagons</code> <code>Union[str, Callable]</code> <p>Accessor for array of H3 index strings.</p> <code>'hexagons'</code> <code>get_fill_color</code> <code>Union[List[int], str, Callable]</code> <p>Accessor for fill color [r, g, b, a].</p> <code>None</code> <code>get_line_color</code> <code>Union[List[int], str, Callable]</code> <p>Accessor for stroke color [r, g, b, a].</p> <code>None</code> <code>get_line_width</code> <code>Union[float, str, Callable]</code> <p>Accessor for line width.</p> <code>1</code> <code>filled</code> <code>bool</code> <p>Whether to fill clusters.</p> <code>True</code> <code>stroked</code> <code>bool</code> <p>Whether to stroke clusters.</p> <code>True</code> <code>extruded</code> <code>bool</code> <p>Whether to render as 3D.</p> <code>False</code> <code>elevation_scale</code> <code>float</code> <p>Elevation multiplier.</p> <code>1</code> <code>pickable</code> <code>bool</code> <p>Whether layer responds to hover/click.</p> <code>True</code> <code>opacity</code> <code>float</code> <p>Layer opacity.</p> <code>0.8</code> <code>**kwargs</code> <p>Additional H3ClusterLayer props.</p> <code>{}</code> Source code in <code>anymap_ts/deckgl.py</code> <pre><code>def add_h3_cluster_layer(\n    self,\n    data: Any,\n    name: Optional[str] = None,\n    get_hexagons: Union[str, Callable] = \"hexagons\",\n    get_fill_color: Union[List[int], str, Callable] = None,\n    get_line_color: Union[List[int], str, Callable] = None,\n    get_line_width: Union[float, str, Callable] = 1,\n    filled: bool = True,\n    stroked: bool = True,\n    extruded: bool = False,\n    elevation_scale: float = 1,\n    pickable: bool = True,\n    opacity: float = 0.8,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add an H3 cluster layer for grouped H3 cell visualization.\n\n    Args:\n        data: Array of data objects with H3 index arrays.\n        name: Layer ID.\n        get_hexagons: Accessor for array of H3 index strings.\n        get_fill_color: Accessor for fill color [r, g, b, a].\n        get_line_color: Accessor for stroke color [r, g, b, a].\n        get_line_width: Accessor for line width.\n        filled: Whether to fill clusters.\n        stroked: Whether to stroke clusters.\n        extruded: Whether to render as 3D.\n        elevation_scale: Elevation multiplier.\n        pickable: Whether layer responds to hover/click.\n        opacity: Layer opacity.\n        **kwargs: Additional H3ClusterLayer props.\n    \"\"\"\n    layer_id = name or f\"h3cluster-{len(self._deck_layers)}\"\n    processed_data = self._process_deck_data(data)\n\n    self.call_js_method(\n        \"addH3ClusterLayer\",\n        id=layer_id,\n        data=processed_data,\n        getHexagons=get_hexagons,\n        getFillColor=get_fill_color or [51, 136, 255, 128],\n        getLineColor=get_line_color or [0, 0, 0, 255],\n        getLineWidth=get_line_width,\n        filled=filled,\n        stroked=stroked,\n        extruded=extruded,\n        elevationScale=elevation_scale,\n        pickable=pickable,\n        opacity=opacity,\n        **kwargs,\n    )\n\n    self._deck_layers = {\n        **self._deck_layers,\n        layer_id: {\"type\": \"H3ClusterLayer\", \"id\": layer_id},\n    }\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.deckgl.DeckGLMap.add_h3_hexagon_layer","title":"<code>add_h3_hexagon_layer(self, data, name=None, get_hexagon='hexagon', get_fill_color=None, get_line_color=None, get_elevation=0, filled=True, stroked=True, extruded=False, wireframe=False, elevation_scale=1, coverage=1, high_precision=False, pickable=True, opacity=0.8, **kwargs)</code>","text":"<p>Add an H3 hexagon layer for H3 spatial index visualization.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>Array of data objects with H3 index.</p> required <code>name</code> <code>Optional[str]</code> <p>Layer ID.</p> <code>None</code> <code>get_hexagon</code> <code>Union[str, Callable]</code> <p>Accessor for H3 index string.</p> <code>'hexagon'</code> <code>get_fill_color</code> <code>Union[List[int], str, Callable]</code> <p>Accessor for fill color [r, g, b, a].</p> <code>None</code> <code>get_line_color</code> <code>Union[List[int], str, Callable]</code> <p>Accessor for stroke color [r, g, b, a].</p> <code>None</code> <code>get_elevation</code> <code>Union[float, str, Callable]</code> <p>Accessor for 3D extrusion height.</p> <code>0</code> <code>filled</code> <code>bool</code> <p>Whether to fill hexagons.</p> <code>True</code> <code>stroked</code> <code>bool</code> <p>Whether to stroke hexagons.</p> <code>True</code> <code>extruded</code> <code>bool</code> <p>Whether to render as 3D hexagons.</p> <code>False</code> <code>wireframe</code> <code>bool</code> <p>Whether to render wireframe.</p> <code>False</code> <code>elevation_scale</code> <code>float</code> <p>Elevation multiplier.</p> <code>1</code> <code>coverage</code> <code>float</code> <p>Hexagon coverage (0-1).</p> <code>1</code> <code>high_precision</code> <code>bool</code> <p>Use high precision rendering.</p> <code>False</code> <code>pickable</code> <code>bool</code> <p>Whether layer responds to hover/click.</p> <code>True</code> <code>opacity</code> <code>float</code> <p>Layer opacity.</p> <code>0.8</code> <code>**kwargs</code> <p>Additional H3HexagonLayer props.</p> <code>{}</code> Source code in <code>anymap_ts/deckgl.py</code> <pre><code>def add_h3_hexagon_layer(\n    self,\n    data: Any,\n    name: Optional[str] = None,\n    get_hexagon: Union[str, Callable] = \"hexagon\",\n    get_fill_color: Union[List[int], str, Callable] = None,\n    get_line_color: Union[List[int], str, Callable] = None,\n    get_elevation: Union[float, str, Callable] = 0,\n    filled: bool = True,\n    stroked: bool = True,\n    extruded: bool = False,\n    wireframe: bool = False,\n    elevation_scale: float = 1,\n    coverage: float = 1,\n    high_precision: bool = False,\n    pickable: bool = True,\n    opacity: float = 0.8,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add an H3 hexagon layer for H3 spatial index visualization.\n\n    Args:\n        data: Array of data objects with H3 index.\n        name: Layer ID.\n        get_hexagon: Accessor for H3 index string.\n        get_fill_color: Accessor for fill color [r, g, b, a].\n        get_line_color: Accessor for stroke color [r, g, b, a].\n        get_elevation: Accessor for 3D extrusion height.\n        filled: Whether to fill hexagons.\n        stroked: Whether to stroke hexagons.\n        extruded: Whether to render as 3D hexagons.\n        wireframe: Whether to render wireframe.\n        elevation_scale: Elevation multiplier.\n        coverage: Hexagon coverage (0-1).\n        high_precision: Use high precision rendering.\n        pickable: Whether layer responds to hover/click.\n        opacity: Layer opacity.\n        **kwargs: Additional H3HexagonLayer props.\n    \"\"\"\n    layer_id = name or f\"h3hexagon-{len(self._deck_layers)}\"\n    processed_data = self._process_deck_data(data)\n\n    self.call_js_method(\n        \"addH3HexagonLayer\",\n        id=layer_id,\n        data=processed_data,\n        getHexagon=get_hexagon,\n        getFillColor=get_fill_color or [51, 136, 255, 128],\n        getLineColor=get_line_color or [0, 0, 0, 255],\n        getElevation=get_elevation,\n        filled=filled,\n        stroked=stroked,\n        extruded=extruded,\n        wireframe=wireframe,\n        elevationScale=elevation_scale,\n        coverage=coverage,\n        highPrecision=high_precision,\n        pickable=pickable,\n        opacity=opacity,\n        **kwargs,\n    )\n\n    self._deck_layers = {\n        **self._deck_layers,\n        layer_id: {\"type\": \"H3HexagonLayer\", \"id\": layer_id},\n    }\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.deckgl.DeckGLMap.add_heatmap_layer","title":"<code>add_heatmap_layer(self, data, name=None, get_position='coordinates', get_weight=1, radius_pixels=30, intensity=1, threshold=0.05, color_range=None, opacity=1, **kwargs)</code>","text":"<p>Add a heatmap layer for density visualization.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>Array of data objects with position coordinates.</p> required <code>name</code> <code>Optional[str]</code> <p>Layer ID.</p> <code>None</code> <code>get_position</code> <code>Union[str, Callable]</code> <p>Accessor for point position [lng, lat].</p> <code>'coordinates'</code> <code>get_weight</code> <code>Union[float, str, Callable]</code> <p>Accessor for point weight.</p> <code>1</code> <code>radius_pixels</code> <code>float</code> <p>Influence radius in pixels.</p> <code>30</code> <code>intensity</code> <code>float</code> <p>Intensity multiplier.</p> <code>1</code> <code>threshold</code> <code>float</code> <p>Minimum density threshold.</p> <code>0.05</code> <code>color_range</code> <code>Optional[List[List[int]]]</code> <p>Color gradient [[r, g, b, a], ...].</p> <code>None</code> <code>opacity</code> <code>float</code> <p>Layer opacity.</p> <code>1</code> <code>**kwargs</code> <p>Additional layer props.</p> <code>{}</code> Source code in <code>anymap_ts/deckgl.py</code> <pre><code>def add_heatmap_layer(\n    self,\n    data: Any,\n    name: Optional[str] = None,\n    get_position: Union[str, Callable] = \"coordinates\",\n    get_weight: Union[float, str, Callable] = 1,\n    radius_pixels: float = 30,\n    intensity: float = 1,\n    threshold: float = 0.05,\n    color_range: Optional[List[List[int]]] = None,\n    opacity: float = 1,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a heatmap layer for density visualization.\n\n    Args:\n        data: Array of data objects with position coordinates.\n        name: Layer ID.\n        get_position: Accessor for point position [lng, lat].\n        get_weight: Accessor for point weight.\n        radius_pixels: Influence radius in pixels.\n        intensity: Intensity multiplier.\n        threshold: Minimum density threshold.\n        color_range: Color gradient [[r, g, b, a], ...].\n        opacity: Layer opacity.\n        **kwargs: Additional layer props.\n    \"\"\"\n    layer_id = name or f\"heatmap-{len(self._deck_layers)}\"\n    processed_data = self._process_deck_data(data)\n\n    default_color_range = [\n        [255, 255, 178, 25],\n        [254, 217, 118, 85],\n        [254, 178, 76, 127],\n        [253, 141, 60, 170],\n        [240, 59, 32, 212],\n        [189, 0, 38, 255],\n    ]\n\n    self.call_js_method(\n        \"addHeatmapLayer\",\n        id=layer_id,\n        data=processed_data,\n        getPosition=get_position,\n        getWeight=get_weight,\n        radiusPixels=radius_pixels,\n        intensity=intensity,\n        threshold=threshold,\n        colorRange=color_range or default_color_range,\n        opacity=opacity,\n        **kwargs,\n    )\n\n    self._deck_layers = {\n        **self._deck_layers,\n        layer_id: {\"type\": \"HeatmapLayer\", \"id\": layer_id},\n    }\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.deckgl.DeckGLMap.add_hexagon_layer","title":"<code>add_hexagon_layer(self, data, name=None, get_position='coordinates', radius=1000, elevation_scale=4, extruded=True, color_range=None, pickable=True, opacity=0.8, **kwargs)</code>","text":"<p>Add a hexagon layer for hexbin aggregation visualization.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>Array of data objects with position coordinates.</p> required <code>name</code> <code>Optional[str]</code> <p>Layer ID.</p> <code>None</code> <code>get_position</code> <code>Union[str, Callable]</code> <p>Accessor for point position [lng, lat].</p> <code>'coordinates'</code> <code>radius</code> <code>float</code> <p>Hexagon radius in meters.</p> <code>1000</code> <code>elevation_scale</code> <code>float</code> <p>Elevation multiplier for 3D.</p> <code>4</code> <code>extruded</code> <code>bool</code> <p>Whether to render as 3D hexagons.</p> <code>True</code> <code>color_range</code> <code>Optional[List[List[int]]]</code> <p>Color gradient for aggregation [[r, g, b], ...].</p> <code>None</code> <code>pickable</code> <code>bool</code> <p>Whether layer responds to hover/click.</p> <code>True</code> <code>opacity</code> <code>float</code> <p>Layer opacity.</p> <code>0.8</code> <code>**kwargs</code> <p>Additional layer props.</p> <code>{}</code> Source code in <code>anymap_ts/deckgl.py</code> <pre><code>def add_hexagon_layer(\n    self,\n    data: Any,\n    name: Optional[str] = None,\n    get_position: Union[str, Callable] = \"coordinates\",\n    radius: float = 1000,\n    elevation_scale: float = 4,\n    extruded: bool = True,\n    color_range: Optional[List[List[int]]] = None,\n    pickable: bool = True,\n    opacity: float = 0.8,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a hexagon layer for hexbin aggregation visualization.\n\n    Args:\n        data: Array of data objects with position coordinates.\n        name: Layer ID.\n        get_position: Accessor for point position [lng, lat].\n        radius: Hexagon radius in meters.\n        elevation_scale: Elevation multiplier for 3D.\n        extruded: Whether to render as 3D hexagons.\n        color_range: Color gradient for aggregation [[r, g, b], ...].\n        pickable: Whether layer responds to hover/click.\n        opacity: Layer opacity.\n        **kwargs: Additional layer props.\n    \"\"\"\n    layer_id = name or f\"hexagon-{len(self._deck_layers)}\"\n    processed_data = self._process_deck_data(data)\n\n    default_color_range = [\n        [1, 152, 189],\n        [73, 227, 206],\n        [216, 254, 181],\n        [254, 237, 177],\n        [254, 173, 84],\n        [209, 55, 78],\n    ]\n\n    self.call_js_method(\n        \"addHexagonLayer\",\n        id=layer_id,\n        data=processed_data,\n        getPosition=get_position,\n        radius=radius,\n        elevationScale=elevation_scale,\n        extruded=extruded,\n        colorRange=color_range or default_color_range,\n        pickable=pickable,\n        opacity=opacity,\n        **kwargs,\n    )\n\n    self._deck_layers = {\n        **self._deck_layers,\n        layer_id: {\"type\": \"HexagonLayer\", \"id\": layer_id},\n    }\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.deckgl.DeckGLMap.add_icon_layer","title":"<code>add_icon_layer(self, data, name=None, get_position='coordinates', get_icon='icon', get_size=20, get_color=None, icon_atlas=None, icon_mapping=None, pickable=True, opacity=1, **kwargs)</code>","text":"<p>Add an icon layer for custom marker visualization.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>Array of data objects with position coordinates.</p> required <code>name</code> <code>Optional[str]</code> <p>Layer ID.</p> <code>None</code> <code>get_position</code> <code>Union[str, Callable]</code> <p>Accessor for icon position [lng, lat].</p> <code>'coordinates'</code> <code>get_icon</code> <code>Union[str, Callable]</code> <p>Accessor for icon name in icon_mapping.</p> <code>'icon'</code> <code>get_size</code> <code>Union[float, str, Callable]</code> <p>Accessor for icon size.</p> <code>20</code> <code>get_color</code> <code>Union[List[int], str, Callable]</code> <p>Accessor for icon tint color [r, g, b, a].</p> <code>None</code> <code>icon_atlas</code> <code>Optional[str]</code> <p>URL to icon atlas image.</p> <code>None</code> <code>icon_mapping</code> <code>Optional[Dict]</code> <p>Dict mapping icon names to atlas coordinates.</p> <code>None</code> <code>pickable</code> <code>bool</code> <p>Whether layer responds to hover/click.</p> <code>True</code> <code>opacity</code> <code>float</code> <p>Layer opacity.</p> <code>1</code> <code>**kwargs</code> <p>Additional layer props.</p> <code>{}</code> Source code in <code>anymap_ts/deckgl.py</code> <pre><code>def add_icon_layer(\n    self,\n    data: Any,\n    name: Optional[str] = None,\n    get_position: Union[str, Callable] = \"coordinates\",\n    get_icon: Union[str, Callable] = \"icon\",\n    get_size: Union[float, str, Callable] = 20,\n    get_color: Union[List[int], str, Callable] = None,\n    icon_atlas: Optional[str] = None,\n    icon_mapping: Optional[Dict] = None,\n    pickable: bool = True,\n    opacity: float = 1,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add an icon layer for custom marker visualization.\n\n    Args:\n        data: Array of data objects with position coordinates.\n        name: Layer ID.\n        get_position: Accessor for icon position [lng, lat].\n        get_icon: Accessor for icon name in icon_mapping.\n        get_size: Accessor for icon size.\n        get_color: Accessor for icon tint color [r, g, b, a].\n        icon_atlas: URL to icon atlas image.\n        icon_mapping: Dict mapping icon names to atlas coordinates.\n        pickable: Whether layer responds to hover/click.\n        opacity: Layer opacity.\n        **kwargs: Additional layer props.\n    \"\"\"\n    layer_id = name or f\"icon-{len(self._deck_layers)}\"\n    processed_data = self._process_deck_data(data)\n\n    self.call_js_method(\n        \"addIconLayer\",\n        id=layer_id,\n        data=processed_data,\n        getPosition=get_position,\n        getIcon=get_icon,\n        getSize=get_size,\n        getColor=get_color or [255, 255, 255, 255],\n        iconAtlas=icon_atlas,\n        iconMapping=icon_mapping,\n        pickable=pickable,\n        opacity=opacity,\n        **kwargs,\n    )\n\n    self._deck_layers = {\n        **self._deck_layers,\n        layer_id: {\"type\": \"IconLayer\", \"id\": layer_id},\n    }\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.deckgl.DeckGLMap.add_line_layer","title":"<code>add_line_layer(self, data, name=None, get_source_position='sourcePosition', get_target_position='targetPosition', get_color=None, get_width=1, width_min_pixels=1, pickable=True, opacity=0.8, **kwargs)</code>","text":"<p>Add a line layer for simple line segment visualization.</p> <p>The LineLayer renders straight line segments between source and target positions. Unlike ArcLayer, lines are drawn directly without curvature.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>Array of line objects with source/target positions.</p> required <code>name</code> <code>Optional[str]</code> <p>Layer ID. If None, auto-generated.</p> <code>None</code> <code>get_source_position</code> <code>Union[str, Callable]</code> <p>Accessor for source position [lng, lat].</p> <code>'sourcePosition'</code> <code>get_target_position</code> <code>Union[str, Callable]</code> <p>Accessor for target position [lng, lat].</p> <code>'targetPosition'</code> <code>get_color</code> <code>Union[List[int], str, Callable]</code> <p>Accessor for line color [r, g, b] or [r, g, b, a].</p> <code>None</code> <code>get_width</code> <code>Union[float, str, Callable]</code> <p>Accessor for line width.</p> <code>1</code> <code>width_min_pixels</code> <code>float</code> <p>Minimum line width in pixels.</p> <code>1</code> <code>pickable</code> <code>bool</code> <p>Whether layer responds to hover/click.</p> <code>True</code> <code>opacity</code> <code>float</code> <p>Layer opacity (0-1).</p> <code>0.8</code> <code>**kwargs</code> <p>Additional LineLayer props.</p> <code>{}</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; m = DeckGLMap()\n&gt;&gt;&gt; lines = [\n...     {\"sourcePosition\": [-122.4, 37.8], \"targetPosition\": [-122.5, 37.7]},\n...     {\"sourcePosition\": [-122.5, 37.7], \"targetPosition\": [-122.6, 37.8]},\n... ]\n&gt;&gt;&gt; m.add_line_layer(\n...     data=lines,\n...     get_color=[0, 128, 255],\n...     get_width=2,\n... )\n</code></pre> Source code in <code>anymap_ts/deckgl.py</code> <pre><code>def add_line_layer(\n    self,\n    data: Any,\n    name: Optional[str] = None,\n    get_source_position: Union[str, Callable] = \"sourcePosition\",\n    get_target_position: Union[str, Callable] = \"targetPosition\",\n    get_color: Union[List[int], str, Callable] = None,\n    get_width: Union[float, str, Callable] = 1,\n    width_min_pixels: float = 1,\n    pickable: bool = True,\n    opacity: float = 0.8,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a line layer for simple line segment visualization.\n\n    The LineLayer renders straight line segments between source and\n    target positions. Unlike ArcLayer, lines are drawn directly\n    without curvature.\n\n    Args:\n        data: Array of line objects with source/target positions.\n        name: Layer ID. If None, auto-generated.\n        get_source_position: Accessor for source position [lng, lat].\n        get_target_position: Accessor for target position [lng, lat].\n        get_color: Accessor for line color [r, g, b] or [r, g, b, a].\n        get_width: Accessor for line width.\n        width_min_pixels: Minimum line width in pixels.\n        pickable: Whether layer responds to hover/click.\n        opacity: Layer opacity (0-1).\n        **kwargs: Additional LineLayer props.\n\n    Example:\n        &gt;&gt;&gt; m = DeckGLMap()\n        &gt;&gt;&gt; lines = [\n        ...     {\"sourcePosition\": [-122.4, 37.8], \"targetPosition\": [-122.5, 37.7]},\n        ...     {\"sourcePosition\": [-122.5, 37.7], \"targetPosition\": [-122.6, 37.8]},\n        ... ]\n        &gt;&gt;&gt; m.add_line_layer(\n        ...     data=lines,\n        ...     get_color=[0, 128, 255],\n        ...     get_width=2,\n        ... )\n    \"\"\"\n    layer_id = name or f\"line-{len(self._deck_layers)}\"\n    processed_data = self._process_deck_data(data)\n\n    self.call_js_method(\n        \"addLineLayer\",\n        id=layer_id,\n        data=processed_data,\n        getSourcePosition=get_source_position,\n        getTargetPosition=get_target_position,\n        getColor=get_color or [51, 136, 255, 200],\n        getWidth=get_width,\n        widthMinPixels=width_min_pixels,\n        pickable=pickable,\n        opacity=opacity,\n        **kwargs,\n    )\n\n    self._deck_layers = {\n        **self._deck_layers,\n        layer_id: {\"type\": \"LineLayer\", \"id\": layer_id},\n    }\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.deckgl.DeckGLMap.add_mvt_layer","title":"<code>add_mvt_layer(self, data, name=None, min_zoom=0, max_zoom=14, binary=True, get_fill_color=None, get_line_color=None, get_line_width=1, get_point_radius=5, line_width_min_pixels=1, point_radius_min_pixels=2, pickable=True, visible=True, opacity=1.0, **kwargs)</code>","text":"<p>Add a Mapbox Vector Tile (MVT) layer.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Union[str, List[str]]</code> <p>MVT tile URL template with {z}/{x}/{y} placeholders.</p> required <code>name</code> <code>Optional[str]</code> <p>Layer ID.</p> <code>None</code> <code>min_zoom</code> <code>int</code> <p>Minimum zoom level.</p> <code>0</code> <code>max_zoom</code> <code>int</code> <p>Maximum zoom level.</p> <code>14</code> <code>binary</code> <code>bool</code> <p>Whether to use binary format.</p> <code>True</code> <code>get_fill_color</code> <code>Union[List[int], str, Callable]</code> <p>Accessor for fill color [r, g, b, a].</p> <code>None</code> <code>get_line_color</code> <code>Union[List[int], str, Callable]</code> <p>Accessor for stroke color [r, g, b, a].</p> <code>None</code> <code>get_line_width</code> <code>Union[float, str, Callable]</code> <p>Accessor for line width.</p> <code>1</code> <code>get_point_radius</code> <code>Union[float, str, Callable]</code> <p>Accessor for point radius.</p> <code>5</code> <code>line_width_min_pixels</code> <code>float</code> <p>Minimum line width in pixels.</p> <code>1</code> <code>point_radius_min_pixels</code> <code>float</code> <p>Minimum point radius in pixels.</p> <code>2</code> <code>pickable</code> <code>bool</code> <p>Whether layer responds to hover/click.</p> <code>True</code> <code>visible</code> <code>bool</code> <p>Whether layer is visible.</p> <code>True</code> <code>opacity</code> <code>float</code> <p>Layer opacity (0-1).</p> <code>1.0</code> <code>**kwargs</code> <p>Additional MVTLayer props.</p> <code>{}</code> Source code in <code>anymap_ts/deckgl.py</code> <pre><code>def add_mvt_layer(\n    self,\n    data: Union[str, List[str]],\n    name: Optional[str] = None,\n    min_zoom: int = 0,\n    max_zoom: int = 14,\n    binary: bool = True,\n    get_fill_color: Union[List[int], str, Callable] = None,\n    get_line_color: Union[List[int], str, Callable] = None,\n    get_line_width: Union[float, str, Callable] = 1,\n    get_point_radius: Union[float, str, Callable] = 5,\n    line_width_min_pixels: float = 1,\n    point_radius_min_pixels: float = 2,\n    pickable: bool = True,\n    visible: bool = True,\n    opacity: float = 1.0,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a Mapbox Vector Tile (MVT) layer.\n\n    Args:\n        data: MVT tile URL template with {z}/{x}/{y} placeholders.\n        name: Layer ID.\n        min_zoom: Minimum zoom level.\n        max_zoom: Maximum zoom level.\n        binary: Whether to use binary format.\n        get_fill_color: Accessor for fill color [r, g, b, a].\n        get_line_color: Accessor for stroke color [r, g, b, a].\n        get_line_width: Accessor for line width.\n        get_point_radius: Accessor for point radius.\n        line_width_min_pixels: Minimum line width in pixels.\n        point_radius_min_pixels: Minimum point radius in pixels.\n        pickable: Whether layer responds to hover/click.\n        visible: Whether layer is visible.\n        opacity: Layer opacity (0-1).\n        **kwargs: Additional MVTLayer props.\n    \"\"\"\n    layer_id = name or f\"mvt-{len(self._deck_layers)}\"\n\n    self.call_js_method(\n        \"addMVTLayer\",\n        id=layer_id,\n        data=data,\n        minZoom=min_zoom,\n        maxZoom=max_zoom,\n        binary=binary,\n        getFillColor=get_fill_color or [51, 136, 255, 128],\n        getLineColor=get_line_color or [0, 0, 0, 255],\n        getLineWidth=get_line_width,\n        getPointRadius=get_point_radius,\n        lineWidthMinPixels=line_width_min_pixels,\n        pointRadiusMinPixels=point_radius_min_pixels,\n        pickable=pickable,\n        visible=visible,\n        opacity=opacity,\n        **kwargs,\n    )\n\n    self._deck_layers = {\n        **self._deck_layers,\n        layer_id: {\"type\": \"MVTLayer\", \"id\": layer_id},\n    }\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.deckgl.DeckGLMap.add_path_layer","title":"<code>add_path_layer(self, data, name=None, get_path='path', get_color=None, get_width=1, width_scale=1, width_min_pixels=1, pickable=True, opacity=0.8, **kwargs)</code>","text":"<p>Add a path layer for polyline visualization.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>Array of data objects with path coordinates.</p> required <code>name</code> <code>Optional[str]</code> <p>Layer ID.</p> <code>None</code> <code>get_path</code> <code>Union[str, Callable]</code> <p>Accessor for path coordinates [[lng, lat], ...].</p> <code>'path'</code> <code>get_color</code> <code>Union[List[int], str, Callable]</code> <p>Accessor for path color [r, g, b, a].</p> <code>None</code> <code>get_width</code> <code>Union[float, str, Callable]</code> <p>Accessor for path width.</p> <code>1</code> <code>width_scale</code> <code>float</code> <p>Global width multiplier.</p> <code>1</code> <code>width_min_pixels</code> <code>float</code> <p>Minimum width in pixels.</p> <code>1</code> <code>pickable</code> <code>bool</code> <p>Whether layer responds to hover/click.</p> <code>True</code> <code>opacity</code> <code>float</code> <p>Layer opacity.</p> <code>0.8</code> <code>**kwargs</code> <p>Additional layer props.</p> <code>{}</code> Source code in <code>anymap_ts/deckgl.py</code> <pre><code>def add_path_layer(\n    self,\n    data: Any,\n    name: Optional[str] = None,\n    get_path: Union[str, Callable] = \"path\",\n    get_color: Union[List[int], str, Callable] = None,\n    get_width: Union[float, str, Callable] = 1,\n    width_scale: float = 1,\n    width_min_pixels: float = 1,\n    pickable: bool = True,\n    opacity: float = 0.8,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a path layer for polyline visualization.\n\n    Args:\n        data: Array of data objects with path coordinates.\n        name: Layer ID.\n        get_path: Accessor for path coordinates [[lng, lat], ...].\n        get_color: Accessor for path color [r, g, b, a].\n        get_width: Accessor for path width.\n        width_scale: Global width multiplier.\n        width_min_pixels: Minimum width in pixels.\n        pickable: Whether layer responds to hover/click.\n        opacity: Layer opacity.\n        **kwargs: Additional layer props.\n    \"\"\"\n    layer_id = name or f\"path-{len(self._deck_layers)}\"\n    processed_data = self._process_deck_data(data)\n\n    self.call_js_method(\n        \"addPathLayer\",\n        id=layer_id,\n        data=processed_data,\n        getPath=get_path,\n        getColor=get_color or [51, 136, 255, 200],\n        getWidth=get_width,\n        widthScale=width_scale,\n        widthMinPixels=width_min_pixels,\n        pickable=pickable,\n        opacity=opacity,\n        **kwargs,\n    )\n\n    self._deck_layers = {\n        **self._deck_layers,\n        layer_id: {\"type\": \"PathLayer\", \"id\": layer_id},\n    }\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.deckgl.DeckGLMap.add_point_cloud_layer","title":"<code>add_point_cloud_layer(self, data, name=None, get_position='position', get_color=None, get_normal=None, point_size=2, size_units='pixels', coordinate_system=None, coordinate_origin=None, pickable=True, opacity=1.0, **kwargs)</code>","text":"<p>Add a point cloud layer for 3D point visualization.</p> <p>Renders large point cloud datasets typically from LiDAR or 3D scanning. Supports both 2D and 3D coordinates with optional normal vectors for lighting effects.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>Array of point data with position [x, y, z] coordinates.</p> required <code>name</code> <code>Optional[str]</code> <p>Layer ID. If None, auto-generated.</p> <code>None</code> <code>get_position</code> <code>Union[str, Callable]</code> <p>Accessor for point position [x, y, z].</p> <code>'position'</code> <code>get_color</code> <code>Union[List[int], str, Callable]</code> <p>Accessor for point color [r, g, b, a].</p> <code>None</code> <code>get_normal</code> <code>Union[str, Callable]</code> <p>Accessor for point normal [nx, ny, nz] for lighting.</p> <code>None</code> <code>point_size</code> <code>float</code> <p>Point size in size_units.</p> <code>2</code> <code>size_units</code> <code>str</code> <p>Units for point_size ('pixels' or 'meters').</p> <code>'pixels'</code> <code>coordinate_system</code> <code>Optional[str]</code> <p>Coordinate system ('CARTESIAN', 'METER_OFFSETS', 'LNGLAT', 'LNGLAT_OFFSETS').</p> <code>None</code> <code>coordinate_origin</code> <code>Optional[List[float]]</code> <p>Origin for offset coordinate systems [lng, lat, z].</p> <code>None</code> <code>pickable</code> <code>bool</code> <p>Whether layer responds to hover/click.</p> <code>True</code> <code>opacity</code> <code>float</code> <p>Layer opacity (0-1).</p> <code>1.0</code> <code>**kwargs</code> <p>Additional PointCloudLayer props.</p> <code>{}</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; m = DeckGLMap()\n&gt;&gt;&gt; points = [\n...     {\"position\": [-122.4, 37.8, 100], \"color\": [255, 0, 0]},\n...     {\"position\": [-122.5, 37.7, 200], \"color\": [0, 255, 0]},\n... ]\n&gt;&gt;&gt; m.add_point_cloud_layer(\n...     data=points,\n...     point_size=5,\n...     get_color=\"color\"\n... )\n</code></pre> Source code in <code>anymap_ts/deckgl.py</code> <pre><code>def add_point_cloud_layer(\n    self,\n    data: Any,\n    name: Optional[str] = None,\n    get_position: Union[str, Callable] = \"position\",\n    get_color: Union[List[int], str, Callable] = None,\n    get_normal: Union[str, Callable] = None,\n    point_size: float = 2,\n    size_units: str = \"pixels\",\n    coordinate_system: Optional[str] = None,\n    coordinate_origin: Optional[List[float]] = None,\n    pickable: bool = True,\n    opacity: float = 1.0,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a point cloud layer for 3D point visualization.\n\n    Renders large point cloud datasets typically from LiDAR or 3D scanning.\n    Supports both 2D and 3D coordinates with optional normal vectors for\n    lighting effects.\n\n    Args:\n        data: Array of point data with position [x, y, z] coordinates.\n        name: Layer ID. If None, auto-generated.\n        get_position: Accessor for point position [x, y, z].\n        get_color: Accessor for point color [r, g, b, a].\n        get_normal: Accessor for point normal [nx, ny, nz] for lighting.\n        point_size: Point size in size_units.\n        size_units: Units for point_size ('pixels' or 'meters').\n        coordinate_system: Coordinate system ('CARTESIAN', 'METER_OFFSETS',\n            'LNGLAT', 'LNGLAT_OFFSETS').\n        coordinate_origin: Origin for offset coordinate systems [lng, lat, z].\n        pickable: Whether layer responds to hover/click.\n        opacity: Layer opacity (0-1).\n        **kwargs: Additional PointCloudLayer props.\n\n    Example:\n        &gt;&gt;&gt; m = DeckGLMap()\n        &gt;&gt;&gt; points = [\n        ...     {\"position\": [-122.4, 37.8, 100], \"color\": [255, 0, 0]},\n        ...     {\"position\": [-122.5, 37.7, 200], \"color\": [0, 255, 0]},\n        ... ]\n        &gt;&gt;&gt; m.add_point_cloud_layer(\n        ...     data=points,\n        ...     point_size=5,\n        ...     get_color=\"color\"\n        ... )\n    \"\"\"\n    layer_id = name or f\"pointcloud-{len(self._deck_layers)}\"\n    processed_data = self._process_deck_data(data)\n\n    layer_kwargs = {\n        \"id\": layer_id,\n        \"data\": processed_data,\n        \"getPosition\": get_position,\n        \"getColor\": get_color or [255, 255, 255, 255],\n        \"pointSize\": point_size,\n        \"sizeUnits\": size_units,\n        \"pickable\": pickable,\n        \"opacity\": opacity,\n    }\n\n    if get_normal is not None:\n        layer_kwargs[\"getNormal\"] = get_normal\n\n    if coordinate_system is not None:\n        layer_kwargs[\"coordinateSystem\"] = coordinate_system\n\n    if coordinate_origin is not None:\n        layer_kwargs[\"coordinateOrigin\"] = coordinate_origin\n\n    layer_kwargs.update(kwargs)\n    self.call_js_method(\"addPointCloudLayer\", **layer_kwargs)\n\n    self._deck_layers = {\n        **self._deck_layers,\n        layer_id: {\"type\": \"PointCloudLayer\", \"id\": layer_id},\n    }\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.deckgl.DeckGLMap.add_polygon_layer","title":"<code>add_polygon_layer(self, data, name=None, get_polygon='polygon', get_fill_color=None, get_line_color=None, get_line_width=1, get_elevation=0, extruded=False, wireframe=False, filled=True, stroked=True, line_width_min_pixels=1, pickable=True, opacity=0.5, **kwargs)</code>","text":"<p>Add a polygon layer for filled polygon visualization.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>Array of data objects with polygon coordinates.</p> required <code>name</code> <code>Optional[str]</code> <p>Layer ID.</p> <code>None</code> <code>get_polygon</code> <code>Union[str, Callable]</code> <p>Accessor for polygon coordinates.</p> <code>'polygon'</code> <code>get_fill_color</code> <code>Union[List[int], str, Callable]</code> <p>Accessor for fill color [r, g, b, a].</p> <code>None</code> <code>get_line_color</code> <code>Union[List[int], str, Callable]</code> <p>Accessor for stroke color [r, g, b, a].</p> <code>None</code> <code>get_line_width</code> <code>Union[float, str, Callable]</code> <p>Accessor for stroke width.</p> <code>1</code> <code>get_elevation</code> <code>Union[float, str, Callable]</code> <p>Accessor for 3D extrusion height.</p> <code>0</code> <code>extruded</code> <code>bool</code> <p>Whether to render as 3D polygons.</p> <code>False</code> <code>wireframe</code> <code>bool</code> <p>Whether to render wireframe (extruded only).</p> <code>False</code> <code>filled</code> <code>bool</code> <p>Whether to fill polygons.</p> <code>True</code> <code>stroked</code> <code>bool</code> <p>Whether to draw stroke.</p> <code>True</code> <code>line_width_min_pixels</code> <code>float</code> <p>Minimum stroke width.</p> <code>1</code> <code>pickable</code> <code>bool</code> <p>Whether layer responds to hover/click.</p> <code>True</code> <code>opacity</code> <code>float</code> <p>Layer opacity.</p> <code>0.5</code> <code>**kwargs</code> <p>Additional layer props.</p> <code>{}</code> Source code in <code>anymap_ts/deckgl.py</code> <pre><code>def add_polygon_layer(\n    self,\n    data: Any,\n    name: Optional[str] = None,\n    get_polygon: Union[str, Callable] = \"polygon\",\n    get_fill_color: Union[List[int], str, Callable] = None,\n    get_line_color: Union[List[int], str, Callable] = None,\n    get_line_width: Union[float, str, Callable] = 1,\n    get_elevation: Union[float, str, Callable] = 0,\n    extruded: bool = False,\n    wireframe: bool = False,\n    filled: bool = True,\n    stroked: bool = True,\n    line_width_min_pixels: float = 1,\n    pickable: bool = True,\n    opacity: float = 0.5,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a polygon layer for filled polygon visualization.\n\n    Args:\n        data: Array of data objects with polygon coordinates.\n        name: Layer ID.\n        get_polygon: Accessor for polygon coordinates.\n        get_fill_color: Accessor for fill color [r, g, b, a].\n        get_line_color: Accessor for stroke color [r, g, b, a].\n        get_line_width: Accessor for stroke width.\n        get_elevation: Accessor for 3D extrusion height.\n        extruded: Whether to render as 3D polygons.\n        wireframe: Whether to render wireframe (extruded only).\n        filled: Whether to fill polygons.\n        stroked: Whether to draw stroke.\n        line_width_min_pixels: Minimum stroke width.\n        pickable: Whether layer responds to hover/click.\n        opacity: Layer opacity.\n        **kwargs: Additional layer props.\n    \"\"\"\n    layer_id = name or f\"polygon-{len(self._deck_layers)}\"\n    processed_data = self._process_deck_data(data)\n\n    self.call_js_method(\n        \"addPolygonLayer\",\n        id=layer_id,\n        data=processed_data,\n        getPolygon=get_polygon,\n        getFillColor=get_fill_color or [51, 136, 255, 128],\n        getLineColor=get_line_color or [0, 0, 255, 255],\n        getLineWidth=get_line_width,\n        getElevation=get_elevation,\n        extruded=extruded,\n        wireframe=wireframe,\n        filled=filled,\n        stroked=stroked,\n        lineWidthMinPixels=line_width_min_pixels,\n        pickable=pickable,\n        opacity=opacity,\n        **kwargs,\n    )\n\n    self._deck_layers = {\n        **self._deck_layers,\n        layer_id: {\"type\": \"PolygonLayer\", \"id\": layer_id},\n    }\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.deckgl.DeckGLMap.add_quadkey_layer","title":"<code>add_quadkey_layer(self, data, name=None, get_quadkey='quadkey', get_fill_color=None, get_line_color=None, get_line_width=1, get_elevation=0, filled=True, stroked=True, extruded=False, wireframe=False, elevation_scale=1, pickable=True, opacity=0.8, **kwargs)</code>","text":"<p>Add a Quadkey layer for Bing Maps tile index visualization.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>Array of data objects with quadkey.</p> required <code>name</code> <code>Optional[str]</code> <p>Layer ID.</p> <code>None</code> <code>get_quadkey</code> <code>Union[str, Callable]</code> <p>Accessor for quadkey string.</p> <code>'quadkey'</code> <code>get_fill_color</code> <code>Union[List[int], str, Callable]</code> <p>Accessor for fill color [r, g, b, a].</p> <code>None</code> <code>get_line_color</code> <code>Union[List[int], str, Callable]</code> <p>Accessor for stroke color [r, g, b, a].</p> <code>None</code> <code>get_line_width</code> <code>Union[float, str, Callable]</code> <p>Accessor for line width.</p> <code>1</code> <code>get_elevation</code> <code>Union[float, str, Callable]</code> <p>Accessor for 3D extrusion height.</p> <code>0</code> <code>filled</code> <code>bool</code> <p>Whether to fill cells.</p> <code>True</code> <code>stroked</code> <code>bool</code> <p>Whether to stroke cells.</p> <code>True</code> <code>extruded</code> <code>bool</code> <p>Whether to render as 3D.</p> <code>False</code> <code>wireframe</code> <code>bool</code> <p>Whether to render wireframe.</p> <code>False</code> <code>elevation_scale</code> <code>float</code> <p>Elevation multiplier.</p> <code>1</code> <code>pickable</code> <code>bool</code> <p>Whether layer responds to hover/click.</p> <code>True</code> <code>opacity</code> <code>float</code> <p>Layer opacity.</p> <code>0.8</code> <code>**kwargs</code> <p>Additional QuadkeyLayer props.</p> <code>{}</code> Source code in <code>anymap_ts/deckgl.py</code> <pre><code>def add_quadkey_layer(\n    self,\n    data: Any,\n    name: Optional[str] = None,\n    get_quadkey: Union[str, Callable] = \"quadkey\",\n    get_fill_color: Union[List[int], str, Callable] = None,\n    get_line_color: Union[List[int], str, Callable] = None,\n    get_line_width: Union[float, str, Callable] = 1,\n    get_elevation: Union[float, str, Callable] = 0,\n    filled: bool = True,\n    stroked: bool = True,\n    extruded: bool = False,\n    wireframe: bool = False,\n    elevation_scale: float = 1,\n    pickable: bool = True,\n    opacity: float = 0.8,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a Quadkey layer for Bing Maps tile index visualization.\n\n    Args:\n        data: Array of data objects with quadkey.\n        name: Layer ID.\n        get_quadkey: Accessor for quadkey string.\n        get_fill_color: Accessor for fill color [r, g, b, a].\n        get_line_color: Accessor for stroke color [r, g, b, a].\n        get_line_width: Accessor for line width.\n        get_elevation: Accessor for 3D extrusion height.\n        filled: Whether to fill cells.\n        stroked: Whether to stroke cells.\n        extruded: Whether to render as 3D.\n        wireframe: Whether to render wireframe.\n        elevation_scale: Elevation multiplier.\n        pickable: Whether layer responds to hover/click.\n        opacity: Layer opacity.\n        **kwargs: Additional QuadkeyLayer props.\n    \"\"\"\n    layer_id = name or f\"quadkey-{len(self._deck_layers)}\"\n    processed_data = self._process_deck_data(data)\n\n    self.call_js_method(\n        \"addQuadkeyLayer\",\n        id=layer_id,\n        data=processed_data,\n        getQuadkey=get_quadkey,\n        getFillColor=get_fill_color or [51, 136, 255, 128],\n        getLineColor=get_line_color or [0, 0, 0, 255],\n        getLineWidth=get_line_width,\n        getElevation=get_elevation,\n        filled=filled,\n        stroked=stroked,\n        extruded=extruded,\n        wireframe=wireframe,\n        elevationScale=elevation_scale,\n        pickable=pickable,\n        opacity=opacity,\n        **kwargs,\n    )\n\n    self._deck_layers = {\n        **self._deck_layers,\n        layer_id: {\"type\": \"QuadkeyLayer\", \"id\": layer_id},\n    }\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.deckgl.DeckGLMap.add_s2_layer","title":"<code>add_s2_layer(self, data, name=None, get_s2_token='s2Token', get_fill_color=None, get_line_color=None, get_line_width=1, get_elevation=0, filled=True, stroked=True, extruded=False, wireframe=False, elevation_scale=1, pickable=True, opacity=0.8, **kwargs)</code>","text":"<p>Add an S2 layer for S2 geometry cell visualization.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>Array of data objects with S2 token.</p> required <code>name</code> <code>Optional[str]</code> <p>Layer ID.</p> <code>None</code> <code>get_s2_token</code> <code>Union[str, Callable]</code> <p>Accessor for S2 token string.</p> <code>'s2Token'</code> <code>get_fill_color</code> <code>Union[List[int], str, Callable]</code> <p>Accessor for fill color [r, g, b, a].</p> <code>None</code> <code>get_line_color</code> <code>Union[List[int], str, Callable]</code> <p>Accessor for stroke color [r, g, b, a].</p> <code>None</code> <code>get_line_width</code> <code>Union[float, str, Callable]</code> <p>Accessor for line width.</p> <code>1</code> <code>get_elevation</code> <code>Union[float, str, Callable]</code> <p>Accessor for 3D extrusion height.</p> <code>0</code> <code>filled</code> <code>bool</code> <p>Whether to fill cells.</p> <code>True</code> <code>stroked</code> <code>bool</code> <p>Whether to stroke cells.</p> <code>True</code> <code>extruded</code> <code>bool</code> <p>Whether to render as 3D.</p> <code>False</code> <code>wireframe</code> <code>bool</code> <p>Whether to render wireframe.</p> <code>False</code> <code>elevation_scale</code> <code>float</code> <p>Elevation multiplier.</p> <code>1</code> <code>pickable</code> <code>bool</code> <p>Whether layer responds to hover/click.</p> <code>True</code> <code>opacity</code> <code>float</code> <p>Layer opacity.</p> <code>0.8</code> <code>**kwargs</code> <p>Additional S2Layer props.</p> <code>{}</code> Source code in <code>anymap_ts/deckgl.py</code> <pre><code>def add_s2_layer(\n    self,\n    data: Any,\n    name: Optional[str] = None,\n    get_s2_token: Union[str, Callable] = \"s2Token\",\n    get_fill_color: Union[List[int], str, Callable] = None,\n    get_line_color: Union[List[int], str, Callable] = None,\n    get_line_width: Union[float, str, Callable] = 1,\n    get_elevation: Union[float, str, Callable] = 0,\n    filled: bool = True,\n    stroked: bool = True,\n    extruded: bool = False,\n    wireframe: bool = False,\n    elevation_scale: float = 1,\n    pickable: bool = True,\n    opacity: float = 0.8,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add an S2 layer for S2 geometry cell visualization.\n\n    Args:\n        data: Array of data objects with S2 token.\n        name: Layer ID.\n        get_s2_token: Accessor for S2 token string.\n        get_fill_color: Accessor for fill color [r, g, b, a].\n        get_line_color: Accessor for stroke color [r, g, b, a].\n        get_line_width: Accessor for line width.\n        get_elevation: Accessor for 3D extrusion height.\n        filled: Whether to fill cells.\n        stroked: Whether to stroke cells.\n        extruded: Whether to render as 3D.\n        wireframe: Whether to render wireframe.\n        elevation_scale: Elevation multiplier.\n        pickable: Whether layer responds to hover/click.\n        opacity: Layer opacity.\n        **kwargs: Additional S2Layer props.\n    \"\"\"\n    layer_id = name or f\"s2-{len(self._deck_layers)}\"\n    processed_data = self._process_deck_data(data)\n\n    self.call_js_method(\n        \"addS2Layer\",\n        id=layer_id,\n        data=processed_data,\n        getS2Token=get_s2_token,\n        getFillColor=get_fill_color or [51, 136, 255, 128],\n        getLineColor=get_line_color or [0, 0, 0, 255],\n        getLineWidth=get_line_width,\n        getElevation=get_elevation,\n        filled=filled,\n        stroked=stroked,\n        extruded=extruded,\n        wireframe=wireframe,\n        elevationScale=elevation_scale,\n        pickable=pickable,\n        opacity=opacity,\n        **kwargs,\n    )\n\n    self._deck_layers = {\n        **self._deck_layers,\n        layer_id: {\"type\": \"S2Layer\", \"id\": layer_id},\n    }\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.deckgl.DeckGLMap.add_scatterplot_layer","title":"<code>add_scatterplot_layer(self, data, name=None, get_position='coordinates', get_radius=5, get_fill_color=None, get_line_color=None, radius_scale=1, radius_min_pixels=1, radius_max_pixels=100, line_width_min_pixels=1, stroked=True, filled=True, pickable=True, opacity=0.8, **kwargs)</code>","text":"<p>Add a scatterplot layer for point visualization.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>Array of data objects or GeoJSON.</p> required <code>name</code> <code>Optional[str]</code> <p>Layer ID.</p> <code>None</code> <code>get_position</code> <code>Union[str, Callable]</code> <p>Accessor for point position [lng, lat].</p> <code>'coordinates'</code> <code>get_radius</code> <code>Union[float, str, Callable]</code> <p>Accessor for point radius.</p> <code>5</code> <code>get_fill_color</code> <code>Union[List[int], str, Callable]</code> <p>Accessor for fill color [r, g, b, a].</p> <code>None</code> <code>get_line_color</code> <code>Union[List[int], str, Callable]</code> <p>Accessor for stroke color [r, g, b, a].</p> <code>None</code> <code>radius_scale</code> <code>float</code> <p>Global radius multiplier.</p> <code>1</code> <code>radius_min_pixels</code> <code>float</code> <p>Minimum radius in pixels.</p> <code>1</code> <code>radius_max_pixels</code> <code>float</code> <p>Maximum radius in pixels.</p> <code>100</code> <code>line_width_min_pixels</code> <code>float</code> <p>Minimum stroke width.</p> <code>1</code> <code>stroked</code> <code>bool</code> <p>Whether to draw stroke.</p> <code>True</code> <code>filled</code> <code>bool</code> <p>Whether to fill points.</p> <code>True</code> <code>pickable</code> <code>bool</code> <p>Whether layer responds to hover/click.</p> <code>True</code> <code>opacity</code> <code>float</code> <p>Layer opacity.</p> <code>0.8</code> <code>**kwargs</code> <p>Additional layer props.</p> <code>{}</code> Source code in <code>anymap_ts/deckgl.py</code> <pre><code>def add_scatterplot_layer(\n    self,\n    data: Any,\n    name: Optional[str] = None,\n    get_position: Union[str, Callable] = \"coordinates\",\n    get_radius: Union[float, str, Callable] = 5,\n    get_fill_color: Union[List[int], str, Callable] = None,\n    get_line_color: Union[List[int], str, Callable] = None,\n    radius_scale: float = 1,\n    radius_min_pixels: float = 1,\n    radius_max_pixels: float = 100,\n    line_width_min_pixels: float = 1,\n    stroked: bool = True,\n    filled: bool = True,\n    pickable: bool = True,\n    opacity: float = 0.8,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a scatterplot layer for point visualization.\n\n    Args:\n        data: Array of data objects or GeoJSON.\n        name: Layer ID.\n        get_position: Accessor for point position [lng, lat].\n        get_radius: Accessor for point radius.\n        get_fill_color: Accessor for fill color [r, g, b, a].\n        get_line_color: Accessor for stroke color [r, g, b, a].\n        radius_scale: Global radius multiplier.\n        radius_min_pixels: Minimum radius in pixels.\n        radius_max_pixels: Maximum radius in pixels.\n        line_width_min_pixels: Minimum stroke width.\n        stroked: Whether to draw stroke.\n        filled: Whether to fill points.\n        pickable: Whether layer responds to hover/click.\n        opacity: Layer opacity.\n        **kwargs: Additional layer props.\n    \"\"\"\n    layer_id = name or f\"scatterplot-{len(self._deck_layers)}\"\n    processed_data = self._process_deck_data(data)\n\n    self.call_js_method(\n        \"addScatterplotLayer\",\n        id=layer_id,\n        data=processed_data,\n        getPosition=get_position,\n        getRadius=get_radius,\n        getFillColor=get_fill_color or [51, 136, 255, 200],\n        getLineColor=get_line_color or [255, 255, 255, 255],\n        radiusScale=radius_scale,\n        radiusMinPixels=radius_min_pixels,\n        radiusMaxPixels=radius_max_pixels,\n        lineWidthMinPixels=line_width_min_pixels,\n        stroked=stroked,\n        filled=filled,\n        pickable=pickable,\n        opacity=opacity,\n        **kwargs,\n    )\n\n    self._deck_layers = {\n        **self._deck_layers,\n        layer_id: {\"type\": \"ScatterplotLayer\", \"id\": layer_id},\n    }\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.deckgl.DeckGLMap.add_scenegraph_layer","title":"<code>add_scenegraph_layer(self, data, scenegraph, name=None, get_position='coordinates', get_color=None, get_orientation=None, get_scale=None, get_translation=None, size_scale=1, size_min_pixels=0, size_max_pixels=10000, pickable=True, opacity=1.0, **kwargs)</code>","text":"<p>Add a scenegraph layer for glTF model visualization.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>Array of data objects with position coordinates.</p> required <code>scenegraph</code> <code>str</code> <p>URL to glTF/GLB model file.</p> required <code>name</code> <code>Optional[str]</code> <p>Layer ID.</p> <code>None</code> <code>get_position</code> <code>Union[str, Callable]</code> <p>Accessor for model position [lng, lat, z].</p> <code>'coordinates'</code> <code>get_color</code> <code>Union[List[int], str, Callable]</code> <p>Accessor for model tint color [r, g, b, a].</p> <code>None</code> <code>get_orientation</code> <code>Union[str, Callable]</code> <p>Accessor for model orientation [pitch, yaw, roll].</p> <code>None</code> <code>get_scale</code> <code>Union[str, Callable]</code> <p>Accessor for model scale [x, y, z].</p> <code>None</code> <code>get_translation</code> <code>Union[str, Callable]</code> <p>Accessor for model translation [x, y, z].</p> <code>None</code> <code>size_scale</code> <code>float</code> <p>Global size multiplier.</p> <code>1</code> <code>size_min_pixels</code> <code>float</code> <p>Minimum model size in pixels.</p> <code>0</code> <code>size_max_pixels</code> <code>float</code> <p>Maximum model size in pixels.</p> <code>10000</code> <code>pickable</code> <code>bool</code> <p>Whether layer responds to hover/click.</p> <code>True</code> <code>opacity</code> <code>float</code> <p>Layer opacity (0-1).</p> <code>1.0</code> <code>**kwargs</code> <p>Additional ScenegraphLayer props.</p> <code>{}</code> Source code in <code>anymap_ts/deckgl.py</code> <pre><code>def add_scenegraph_layer(\n    self,\n    data: Any,\n    scenegraph: str,\n    name: Optional[str] = None,\n    get_position: Union[str, Callable] = \"coordinates\",\n    get_color: Union[List[int], str, Callable] = None,\n    get_orientation: Union[str, Callable] = None,\n    get_scale: Union[str, Callable] = None,\n    get_translation: Union[str, Callable] = None,\n    size_scale: float = 1,\n    size_min_pixels: float = 0,\n    size_max_pixels: float = 10000,\n    pickable: bool = True,\n    opacity: float = 1.0,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a scenegraph layer for glTF model visualization.\n\n    Args:\n        data: Array of data objects with position coordinates.\n        scenegraph: URL to glTF/GLB model file.\n        name: Layer ID.\n        get_position: Accessor for model position [lng, lat, z].\n        get_color: Accessor for model tint color [r, g, b, a].\n        get_orientation: Accessor for model orientation [pitch, yaw, roll].\n        get_scale: Accessor for model scale [x, y, z].\n        get_translation: Accessor for model translation [x, y, z].\n        size_scale: Global size multiplier.\n        size_min_pixels: Minimum model size in pixels.\n        size_max_pixels: Maximum model size in pixels.\n        pickable: Whether layer responds to hover/click.\n        opacity: Layer opacity (0-1).\n        **kwargs: Additional ScenegraphLayer props.\n    \"\"\"\n    layer_id = name or f\"scenegraph-{len(self._deck_layers)}\"\n    processed_data = self._process_deck_data(data)\n\n    layer_kwargs = {\n        \"id\": layer_id,\n        \"data\": processed_data,\n        \"scenegraph\": scenegraph,\n        \"getPosition\": get_position,\n        \"getColor\": get_color or [255, 255, 255, 255],\n        \"sizeScale\": size_scale,\n        \"sizeMinPixels\": size_min_pixels,\n        \"sizeMaxPixels\": size_max_pixels,\n        \"pickable\": pickable,\n        \"opacity\": opacity,\n    }\n\n    if get_orientation:\n        layer_kwargs[\"getOrientation\"] = get_orientation\n    if get_scale:\n        layer_kwargs[\"getScale\"] = get_scale\n    if get_translation:\n        layer_kwargs[\"getTranslation\"] = get_translation\n\n    layer_kwargs.update(kwargs)\n    self.call_js_method(\"addScenegraphLayer\", **layer_kwargs)\n\n    self._deck_layers = {\n        **self._deck_layers,\n        layer_id: {\"type\": \"ScenegraphLayer\", \"id\": layer_id},\n    }\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.deckgl.DeckGLMap.add_screen_grid_layer","title":"<code>add_screen_grid_layer(self, data, name=None, get_position='coordinates', get_weight=1, cell_size_pixels=50, color_range=None, pickable=True, opacity=0.8, **kwargs)</code>","text":"<p>Add a screen grid layer for screen-space grid aggregation.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>Array of data objects with position coordinates.</p> required <code>name</code> <code>Optional[str]</code> <p>Layer ID.</p> <code>None</code> <code>get_position</code> <code>Union[str, Callable]</code> <p>Accessor for point position [lng, lat].</p> <code>'coordinates'</code> <code>get_weight</code> <code>Union[float, str, Callable]</code> <p>Accessor for point weight.</p> <code>1</code> <code>cell_size_pixels</code> <code>float</code> <p>Grid cell size in pixels.</p> <code>50</code> <code>color_range</code> <code>Optional[List[List[int]]]</code> <p>Color gradient [[r, g, b, a], ...].</p> <code>None</code> <code>pickable</code> <code>bool</code> <p>Whether layer responds to hover/click.</p> <code>True</code> <code>opacity</code> <code>float</code> <p>Layer opacity.</p> <code>0.8</code> <code>**kwargs</code> <p>Additional layer props.</p> <code>{}</code> Source code in <code>anymap_ts/deckgl.py</code> <pre><code>def add_screen_grid_layer(\n    self,\n    data: Any,\n    name: Optional[str] = None,\n    get_position: Union[str, Callable] = \"coordinates\",\n    get_weight: Union[float, str, Callable] = 1,\n    cell_size_pixels: float = 50,\n    color_range: Optional[List[List[int]]] = None,\n    pickable: bool = True,\n    opacity: float = 0.8,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a screen grid layer for screen-space grid aggregation.\n\n    Args:\n        data: Array of data objects with position coordinates.\n        name: Layer ID.\n        get_position: Accessor for point position [lng, lat].\n        get_weight: Accessor for point weight.\n        cell_size_pixels: Grid cell size in pixels.\n        color_range: Color gradient [[r, g, b, a], ...].\n        pickable: Whether layer responds to hover/click.\n        opacity: Layer opacity.\n        **kwargs: Additional layer props.\n    \"\"\"\n    layer_id = name or f\"screengrid-{len(self._deck_layers)}\"\n    processed_data = self._process_deck_data(data)\n\n    default_color_range = [\n        [255, 255, 178, 25],\n        [254, 217, 118, 85],\n        [254, 178, 76, 127],\n        [253, 141, 60, 170],\n        [240, 59, 32, 212],\n        [189, 0, 38, 255],\n    ]\n\n    self.call_js_method(\n        \"addScreenGridLayer\",\n        id=layer_id,\n        data=processed_data,\n        getPosition=get_position,\n        getWeight=get_weight,\n        cellSizePixels=cell_size_pixels,\n        colorRange=color_range or default_color_range,\n        pickable=pickable,\n        opacity=opacity,\n        **kwargs,\n    )\n\n    self._deck_layers = {\n        **self._deck_layers,\n        layer_id: {\"type\": \"ScreenGridLayer\", \"id\": layer_id},\n    }\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.deckgl.DeckGLMap.add_simple_mesh_layer","title":"<code>add_simple_mesh_layer(self, data, mesh, name=None, texture=None, get_position='coordinates', get_color=None, get_orientation=None, get_scale=None, get_translation=None, size_scale=1, wireframe=False, pickable=True, opacity=1.0, **kwargs)</code>","text":"<p>Add a simple mesh layer for 3D mesh visualization.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>Array of data objects with position coordinates.</p> required <code>mesh</code> <code>str</code> <p>URL to OBJ/glTF mesh file.</p> required <code>name</code> <code>Optional[str]</code> <p>Layer ID.</p> <code>None</code> <code>texture</code> <code>Optional[str]</code> <p>URL to texture image.</p> <code>None</code> <code>get_position</code> <code>Union[str, Callable]</code> <p>Accessor for mesh position [lng, lat, z].</p> <code>'coordinates'</code> <code>get_color</code> <code>Union[List[int], str, Callable]</code> <p>Accessor for mesh color [r, g, b, a].</p> <code>None</code> <code>get_orientation</code> <code>Union[str, Callable]</code> <p>Accessor for mesh orientation [pitch, yaw, roll].</p> <code>None</code> <code>get_scale</code> <code>Union[str, Callable]</code> <p>Accessor for mesh scale [x, y, z].</p> <code>None</code> <code>get_translation</code> <code>Union[str, Callable]</code> <p>Accessor for mesh translation [x, y, z].</p> <code>None</code> <code>size_scale</code> <code>float</code> <p>Global size multiplier.</p> <code>1</code> <code>wireframe</code> <code>bool</code> <p>Whether to render as wireframe.</p> <code>False</code> <code>pickable</code> <code>bool</code> <p>Whether layer responds to hover/click.</p> <code>True</code> <code>opacity</code> <code>float</code> <p>Layer opacity (0-1).</p> <code>1.0</code> <code>**kwargs</code> <p>Additional SimpleMeshLayer props.</p> <code>{}</code> Source code in <code>anymap_ts/deckgl.py</code> <pre><code>def add_simple_mesh_layer(\n    self,\n    data: Any,\n    mesh: str,\n    name: Optional[str] = None,\n    texture: Optional[str] = None,\n    get_position: Union[str, Callable] = \"coordinates\",\n    get_color: Union[List[int], str, Callable] = None,\n    get_orientation: Union[str, Callable] = None,\n    get_scale: Union[str, Callable] = None,\n    get_translation: Union[str, Callable] = None,\n    size_scale: float = 1,\n    wireframe: bool = False,\n    pickable: bool = True,\n    opacity: float = 1.0,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a simple mesh layer for 3D mesh visualization.\n\n    Args:\n        data: Array of data objects with position coordinates.\n        mesh: URL to OBJ/glTF mesh file.\n        name: Layer ID.\n        texture: URL to texture image.\n        get_position: Accessor for mesh position [lng, lat, z].\n        get_color: Accessor for mesh color [r, g, b, a].\n        get_orientation: Accessor for mesh orientation [pitch, yaw, roll].\n        get_scale: Accessor for mesh scale [x, y, z].\n        get_translation: Accessor for mesh translation [x, y, z].\n        size_scale: Global size multiplier.\n        wireframe: Whether to render as wireframe.\n        pickable: Whether layer responds to hover/click.\n        opacity: Layer opacity (0-1).\n        **kwargs: Additional SimpleMeshLayer props.\n    \"\"\"\n    layer_id = name or f\"simplemesh-{len(self._deck_layers)}\"\n    processed_data = self._process_deck_data(data)\n\n    layer_kwargs = {\n        \"id\": layer_id,\n        \"data\": processed_data,\n        \"mesh\": mesh,\n        \"getPosition\": get_position,\n        \"getColor\": get_color or [255, 255, 255, 255],\n        \"sizeScale\": size_scale,\n        \"wireframe\": wireframe,\n        \"pickable\": pickable,\n        \"opacity\": opacity,\n    }\n\n    if texture:\n        layer_kwargs[\"texture\"] = texture\n    if get_orientation:\n        layer_kwargs[\"getOrientation\"] = get_orientation\n    if get_scale:\n        layer_kwargs[\"getScale\"] = get_scale\n    if get_translation:\n        layer_kwargs[\"getTranslation\"] = get_translation\n\n    layer_kwargs.update(kwargs)\n    self.call_js_method(\"addSimpleMeshLayer\", **layer_kwargs)\n\n    self._deck_layers = {\n        **self._deck_layers,\n        layer_id: {\"type\": \"SimpleMeshLayer\", \"id\": layer_id},\n    }\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.deckgl.DeckGLMap.add_solid_polygon_layer","title":"<code>add_solid_polygon_layer(self, data, name=None, get_polygon='polygon', get_fill_color=None, get_line_color=None, get_elevation=0, filled=True, extruded=False, wireframe=False, elevation_scale=1, pickable=True, opacity=0.8, **kwargs)</code>","text":"<p>Add a solid polygon layer for filled polygon visualization.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>Array of data objects with polygon coordinates.</p> required <code>name</code> <code>Optional[str]</code> <p>Layer ID.</p> <code>None</code> <code>get_polygon</code> <code>Union[str, Callable]</code> <p>Accessor for polygon coordinates.</p> <code>'polygon'</code> <code>get_fill_color</code> <code>Union[List[int], str, Callable]</code> <p>Accessor for fill color [r, g, b, a].</p> <code>None</code> <code>get_line_color</code> <code>Union[List[int], str, Callable]</code> <p>Accessor for stroke color [r, g, b, a].</p> <code>None</code> <code>get_elevation</code> <code>Union[float, str, Callable]</code> <p>Accessor for 3D extrusion height.</p> <code>0</code> <code>filled</code> <code>bool</code> <p>Whether to fill polygons.</p> <code>True</code> <code>extruded</code> <code>bool</code> <p>Whether to render as 3D polygons.</p> <code>False</code> <code>wireframe</code> <code>bool</code> <p>Whether to render wireframe.</p> <code>False</code> <code>elevation_scale</code> <code>float</code> <p>Elevation multiplier.</p> <code>1</code> <code>pickable</code> <code>bool</code> <p>Whether layer responds to hover/click.</p> <code>True</code> <code>opacity</code> <code>float</code> <p>Layer opacity.</p> <code>0.8</code> <code>**kwargs</code> <p>Additional SolidPolygonLayer props.</p> <code>{}</code> Source code in <code>anymap_ts/deckgl.py</code> <pre><code>def add_solid_polygon_layer(\n    self,\n    data: Any,\n    name: Optional[str] = None,\n    get_polygon: Union[str, Callable] = \"polygon\",\n    get_fill_color: Union[List[int], str, Callable] = None,\n    get_line_color: Union[List[int], str, Callable] = None,\n    get_elevation: Union[float, str, Callable] = 0,\n    filled: bool = True,\n    extruded: bool = False,\n    wireframe: bool = False,\n    elevation_scale: float = 1,\n    pickable: bool = True,\n    opacity: float = 0.8,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a solid polygon layer for filled polygon visualization.\n\n    Args:\n        data: Array of data objects with polygon coordinates.\n        name: Layer ID.\n        get_polygon: Accessor for polygon coordinates.\n        get_fill_color: Accessor for fill color [r, g, b, a].\n        get_line_color: Accessor for stroke color [r, g, b, a].\n        get_elevation: Accessor for 3D extrusion height.\n        filled: Whether to fill polygons.\n        extruded: Whether to render as 3D polygons.\n        wireframe: Whether to render wireframe.\n        elevation_scale: Elevation multiplier.\n        pickable: Whether layer responds to hover/click.\n        opacity: Layer opacity.\n        **kwargs: Additional SolidPolygonLayer props.\n    \"\"\"\n    layer_id = name or f\"solidpolygon-{len(self._deck_layers)}\"\n    processed_data = self._process_deck_data(data)\n\n    self.call_js_method(\n        \"addSolidPolygonLayer\",\n        id=layer_id,\n        data=processed_data,\n        getPolygon=get_polygon,\n        getFillColor=get_fill_color or [51, 136, 255, 128],\n        getLineColor=get_line_color or [0, 0, 0, 255],\n        getElevation=get_elevation,\n        filled=filled,\n        extruded=extruded,\n        wireframe=wireframe,\n        elevationScale=elevation_scale,\n        pickable=pickable,\n        opacity=opacity,\n        **kwargs,\n    )\n\n    self._deck_layers = {\n        **self._deck_layers,\n        layer_id: {\"type\": \"SolidPolygonLayer\", \"id\": layer_id},\n    }\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.deckgl.DeckGLMap.add_terrain_layer","title":"<code>add_terrain_layer(self, elevation_data, name=None, texture=None, mesh_max_error=4.0, bounds=None, elevation_decoder=None, pickable=False, visible=True, opacity=1.0, wireframe=False, **kwargs)</code>","text":"<p>Add a terrain layer for 3D terrain visualization.</p> <p>Parameters:</p> Name Type Description Default <code>elevation_data</code> <code>Union[str, List[str]]</code> <p>URL to elevation tiles (e.g., Mapbox terrain).</p> required <code>name</code> <code>Optional[str]</code> <p>Layer ID.</p> <code>None</code> <code>texture</code> <code>Optional[str]</code> <p>URL to texture tiles for terrain surface.</p> <code>None</code> <code>mesh_max_error</code> <code>float</code> <p>Maximum mesh error in meters.</p> <code>4.0</code> <code>bounds</code> <code>Optional[List[float]]</code> <p>Bounding box [west, south, east, north].</p> <code>None</code> <code>elevation_decoder</code> <code>Optional[Dict]</code> <p>Decoder for elevation data format.</p> <code>None</code> <code>pickable</code> <code>bool</code> <p>Whether layer responds to hover/click.</p> <code>False</code> <code>visible</code> <code>bool</code> <p>Whether layer is visible.</p> <code>True</code> <code>opacity</code> <code>float</code> <p>Layer opacity (0-1).</p> <code>1.0</code> <code>wireframe</code> <code>bool</code> <p>Whether to render as wireframe.</p> <code>False</code> <code>**kwargs</code> <p>Additional TerrainLayer props.</p> <code>{}</code> Source code in <code>anymap_ts/deckgl.py</code> <pre><code>def add_terrain_layer(\n    self,\n    elevation_data: Union[str, List[str]],\n    name: Optional[str] = None,\n    texture: Optional[str] = None,\n    mesh_max_error: float = 4.0,\n    bounds: Optional[List[float]] = None,\n    elevation_decoder: Optional[Dict] = None,\n    pickable: bool = False,\n    visible: bool = True,\n    opacity: float = 1.0,\n    wireframe: bool = False,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a terrain layer for 3D terrain visualization.\n\n    Args:\n        elevation_data: URL to elevation tiles (e.g., Mapbox terrain).\n        name: Layer ID.\n        texture: URL to texture tiles for terrain surface.\n        mesh_max_error: Maximum mesh error in meters.\n        bounds: Bounding box [west, south, east, north].\n        elevation_decoder: Decoder for elevation data format.\n        pickable: Whether layer responds to hover/click.\n        visible: Whether layer is visible.\n        opacity: Layer opacity (0-1).\n        wireframe: Whether to render as wireframe.\n        **kwargs: Additional TerrainLayer props.\n    \"\"\"\n    layer_id = name or f\"terrain-{len(self._deck_layers)}\"\n\n    default_decoder = {\n        \"rScaler\": 256,\n        \"gScaler\": 1,\n        \"bScaler\": 1 / 256,\n        \"offset\": -32768,\n    }\n\n    self.call_js_method(\n        \"addTerrainLayer\",\n        id=layer_id,\n        elevationData=elevation_data,\n        texture=texture,\n        meshMaxError=mesh_max_error,\n        bounds=bounds,\n        elevationDecoder=elevation_decoder or default_decoder,\n        pickable=pickable,\n        visible=visible,\n        opacity=opacity,\n        wireframe=wireframe,\n        **kwargs,\n    )\n\n    self._deck_layers = {\n        **self._deck_layers,\n        layer_id: {\"type\": \"TerrainLayer\", \"id\": layer_id},\n    }\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.deckgl.DeckGLMap.add_text_layer","title":"<code>add_text_layer(self, data, name=None, get_position='coordinates', get_text='text', get_size=12, get_color=None, get_angle=0, text_anchor='middle', alignment_baseline='center', pickable=True, opacity=1, **kwargs)</code>","text":"<p>Add a text layer for label visualization.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>Array of data objects with position and text.</p> required <code>name</code> <code>Optional[str]</code> <p>Layer ID.</p> <code>None</code> <code>get_position</code> <code>Union[str, Callable]</code> <p>Accessor for text position [lng, lat].</p> <code>'coordinates'</code> <code>get_text</code> <code>Union[str, Callable]</code> <p>Accessor for text content.</p> <code>'text'</code> <code>get_size</code> <code>Union[float, str, Callable]</code> <p>Accessor for text size.</p> <code>12</code> <code>get_color</code> <code>Union[List[int], str, Callable]</code> <p>Accessor for text color [r, g, b, a].</p> <code>None</code> <code>get_angle</code> <code>Union[float, str, Callable]</code> <p>Accessor for text rotation in degrees.</p> <code>0</code> <code>text_anchor</code> <code>str</code> <p>Horizontal alignment ('start', 'middle', 'end').</p> <code>'middle'</code> <code>alignment_baseline</code> <code>str</code> <p>Vertical alignment ('top', 'center', 'bottom').</p> <code>'center'</code> <code>pickable</code> <code>bool</code> <p>Whether layer responds to hover/click.</p> <code>True</code> <code>opacity</code> <code>float</code> <p>Layer opacity.</p> <code>1</code> <code>**kwargs</code> <p>Additional layer props.</p> <code>{}</code> Source code in <code>anymap_ts/deckgl.py</code> <pre><code>def add_text_layer(\n    self,\n    data: Any,\n    name: Optional[str] = None,\n    get_position: Union[str, Callable] = \"coordinates\",\n    get_text: Union[str, Callable] = \"text\",\n    get_size: Union[float, str, Callable] = 12,\n    get_color: Union[List[int], str, Callable] = None,\n    get_angle: Union[float, str, Callable] = 0,\n    text_anchor: str = \"middle\",\n    alignment_baseline: str = \"center\",\n    pickable: bool = True,\n    opacity: float = 1,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a text layer for label visualization.\n\n    Args:\n        data: Array of data objects with position and text.\n        name: Layer ID.\n        get_position: Accessor for text position [lng, lat].\n        get_text: Accessor for text content.\n        get_size: Accessor for text size.\n        get_color: Accessor for text color [r, g, b, a].\n        get_angle: Accessor for text rotation in degrees.\n        text_anchor: Horizontal alignment ('start', 'middle', 'end').\n        alignment_baseline: Vertical alignment ('top', 'center', 'bottom').\n        pickable: Whether layer responds to hover/click.\n        opacity: Layer opacity.\n        **kwargs: Additional layer props.\n    \"\"\"\n    layer_id = name or f\"text-{len(self._deck_layers)}\"\n    processed_data = self._process_deck_data(data)\n\n    self.call_js_method(\n        \"addTextLayer\",\n        id=layer_id,\n        data=processed_data,\n        getPosition=get_position,\n        getText=get_text,\n        getSize=get_size,\n        getColor=get_color or [0, 0, 0, 255],\n        getAngle=get_angle,\n        getTextAnchor=text_anchor,\n        getAlignmentBaseline=alignment_baseline,\n        pickable=pickable,\n        opacity=opacity,\n        **kwargs,\n    )\n\n    self._deck_layers = {\n        **self._deck_layers,\n        layer_id: {\"type\": \"TextLayer\", \"id\": layer_id},\n    }\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.deckgl.DeckGLMap.add_tile3d_layer","title":"<code>add_tile3d_layer(self, data, name=None, point_size=1, pickable=True, visible=True, opacity=1.0, load_options=None, **kwargs)</code>","text":"<p>Add a 3D Tiles layer for 3D building/terrain visualization.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>str</code> <p>URL to tileset.json.</p> required <code>name</code> <code>Optional[str]</code> <p>Layer ID.</p> <code>None</code> <code>point_size</code> <code>float</code> <p>Point size for point cloud tiles.</p> <code>1</code> <code>pickable</code> <code>bool</code> <p>Whether layer responds to hover/click.</p> <code>True</code> <code>visible</code> <code>bool</code> <p>Whether layer is visible.</p> <code>True</code> <code>opacity</code> <code>float</code> <p>Layer opacity (0-1).</p> <code>1.0</code> <code>load_options</code> <code>Optional[Dict]</code> <p>Loader options for tile loading.</p> <code>None</code> <code>**kwargs</code> <p>Additional Tile3DLayer props.</p> <code>{}</code> Source code in <code>anymap_ts/deckgl.py</code> <pre><code>def add_tile3d_layer(\n    self,\n    data: str,\n    name: Optional[str] = None,\n    point_size: float = 1,\n    pickable: bool = True,\n    visible: bool = True,\n    opacity: float = 1.0,\n    load_options: Optional[Dict] = None,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a 3D Tiles layer for 3D building/terrain visualization.\n\n    Args:\n        data: URL to tileset.json.\n        name: Layer ID.\n        point_size: Point size for point cloud tiles.\n        pickable: Whether layer responds to hover/click.\n        visible: Whether layer is visible.\n        opacity: Layer opacity (0-1).\n        load_options: Loader options for tile loading.\n        **kwargs: Additional Tile3DLayer props.\n    \"\"\"\n    layer_id = name or f\"tile3d-{len(self._deck_layers)}\"\n\n    self.call_js_method(\n        \"addTile3DLayer\",\n        id=layer_id,\n        data=data,\n        pointSize=point_size,\n        pickable=pickable,\n        visible=visible,\n        opacity=opacity,\n        loadOptions=load_options or {},\n        **kwargs,\n    )\n\n    self._deck_layers = {\n        **self._deck_layers,\n        layer_id: {\"type\": \"Tile3DLayer\", \"id\": layer_id},\n    }\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.deckgl.DeckGLMap.add_tile_layer","title":"<code>add_tile_layer(self, data, name=None, min_zoom=0, max_zoom=19, tile_size=256, pickable=False, visible=True, opacity=1.0, **kwargs)</code>","text":"<p>Add a tile layer for raster tile visualization.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Union[str, List[str]]</code> <p>Tile URL template with {z}/{x}/{y} placeholders.</p> required <code>name</code> <code>Optional[str]</code> <p>Layer ID.</p> <code>None</code> <code>min_zoom</code> <code>int</code> <p>Minimum zoom level.</p> <code>0</code> <code>max_zoom</code> <code>int</code> <p>Maximum zoom level.</p> <code>19</code> <code>tile_size</code> <code>int</code> <p>Tile size in pixels.</p> <code>256</code> <code>pickable</code> <code>bool</code> <p>Whether layer responds to hover/click.</p> <code>False</code> <code>visible</code> <code>bool</code> <p>Whether layer is visible.</p> <code>True</code> <code>opacity</code> <code>float</code> <p>Layer opacity (0-1).</p> <code>1.0</code> <code>**kwargs</code> <p>Additional TileLayer props.</p> <code>{}</code> Source code in <code>anymap_ts/deckgl.py</code> <pre><code>def add_tile_layer(\n    self,\n    data: Union[str, List[str]],\n    name: Optional[str] = None,\n    min_zoom: int = 0,\n    max_zoom: int = 19,\n    tile_size: int = 256,\n    pickable: bool = False,\n    visible: bool = True,\n    opacity: float = 1.0,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a tile layer for raster tile visualization.\n\n    Args:\n        data: Tile URL template with {z}/{x}/{y} placeholders.\n        name: Layer ID.\n        min_zoom: Minimum zoom level.\n        max_zoom: Maximum zoom level.\n        tile_size: Tile size in pixels.\n        pickable: Whether layer responds to hover/click.\n        visible: Whether layer is visible.\n        opacity: Layer opacity (0-1).\n        **kwargs: Additional TileLayer props.\n    \"\"\"\n    layer_id = name or f\"tile-{len(self._deck_layers)}\"\n\n    self.call_js_method(\n        \"addTileLayer\",\n        id=layer_id,\n        data=data,\n        minZoom=min_zoom,\n        maxZoom=max_zoom,\n        tileSize=tile_size,\n        pickable=pickable,\n        visible=visible,\n        opacity=opacity,\n        **kwargs,\n    )\n\n    self._deck_layers = {\n        **self._deck_layers,\n        layer_id: {\"type\": \"TileLayer\", \"id\": layer_id},\n    }\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.deckgl.DeckGLMap.add_trips_layer","title":"<code>add_trips_layer(self, data, name=None, get_path='waypoints', get_timestamps='timestamps', get_color=None, width_min_pixels=2, trail_length=180, current_time=0, pickable=True, opacity=0.8, **kwargs)</code>","text":"<p>Add a trips layer for animated path visualization.</p> <p>The TripsLayer renders animated paths showing movement over time, ideal for visualizing vehicle routes, migration patterns, or any time-based trajectory data.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>Array of trip objects with waypoints and timestamps.</p> required <code>name</code> <code>Optional[str]</code> <p>Layer ID. If None, auto-generated.</p> <code>None</code> <code>get_path</code> <code>Union[str, Callable]</code> <p>Accessor for waypoint coordinates [[lng, lat], ...].</p> <code>'waypoints'</code> <code>get_timestamps</code> <code>Union[str, Callable]</code> <p>Accessor for timestamps at each waypoint.</p> <code>'timestamps'</code> <code>get_color</code> <code>Union[List[int], str, Callable]</code> <p>Accessor for trip color [r, g, b] or [r, g, b, a].</p> <code>None</code> <code>width_min_pixels</code> <code>float</code> <p>Minimum trail width in pixels.</p> <code>2</code> <code>trail_length</code> <code>float</code> <p>Trail length in timestamp units.</p> <code>180</code> <code>current_time</code> <code>float</code> <p>Current animation time.</p> <code>0</code> <code>pickable</code> <code>bool</code> <p>Whether layer responds to hover/click.</p> <code>True</code> <code>opacity</code> <code>float</code> <p>Layer opacity (0-1).</p> <code>0.8</code> <code>**kwargs</code> <p>Additional TripsLayer props.</p> <code>{}</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; m = DeckGLMap()\n&gt;&gt;&gt; trips = [\n...     {\n...         \"waypoints\": [[-122.4, 37.8], [-122.5, 37.7], [-122.6, 37.8]],\n...         \"timestamps\": [0, 50, 100]\n...     }\n... ]\n&gt;&gt;&gt; m.add_trips_layer(\n...     data=trips,\n...     trail_length=180,\n...     current_time=50,\n... )\n</code></pre> Source code in <code>anymap_ts/deckgl.py</code> <pre><code>def add_trips_layer(\n    self,\n    data: Any,\n    name: Optional[str] = None,\n    get_path: Union[str, Callable] = \"waypoints\",\n    get_timestamps: Union[str, Callable] = \"timestamps\",\n    get_color: Union[List[int], str, Callable] = None,\n    width_min_pixels: float = 2,\n    trail_length: float = 180,\n    current_time: float = 0,\n    pickable: bool = True,\n    opacity: float = 0.8,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a trips layer for animated path visualization.\n\n    The TripsLayer renders animated paths showing movement over time,\n    ideal for visualizing vehicle routes, migration patterns, or any\n    time-based trajectory data.\n\n    Args:\n        data: Array of trip objects with waypoints and timestamps.\n        name: Layer ID. If None, auto-generated.\n        get_path: Accessor for waypoint coordinates [[lng, lat], ...].\n        get_timestamps: Accessor for timestamps at each waypoint.\n        get_color: Accessor for trip color [r, g, b] or [r, g, b, a].\n        width_min_pixels: Minimum trail width in pixels.\n        trail_length: Trail length in timestamp units.\n        current_time: Current animation time.\n        pickable: Whether layer responds to hover/click.\n        opacity: Layer opacity (0-1).\n        **kwargs: Additional TripsLayer props.\n\n    Example:\n        &gt;&gt;&gt; m = DeckGLMap()\n        &gt;&gt;&gt; trips = [\n        ...     {\n        ...         \"waypoints\": [[-122.4, 37.8], [-122.5, 37.7], [-122.6, 37.8]],\n        ...         \"timestamps\": [0, 50, 100]\n        ...     }\n        ... ]\n        &gt;&gt;&gt; m.add_trips_layer(\n        ...     data=trips,\n        ...     trail_length=180,\n        ...     current_time=50,\n        ... )\n    \"\"\"\n    layer_id = name or f\"trips-{len(self._deck_layers)}\"\n    processed_data = self._process_deck_data(data)\n\n    self.call_js_method(\n        \"addTripsLayer\",\n        id=layer_id,\n        data=processed_data,\n        getPath=get_path,\n        getTimestamps=get_timestamps,\n        getColor=get_color or [253, 128, 93],\n        widthMinPixels=width_min_pixels,\n        trailLength=trail_length,\n        currentTime=current_time,\n        pickable=pickable,\n        opacity=opacity,\n        **kwargs,\n    )\n\n    self._deck_layers = {\n        **self._deck_layers,\n        layer_id: {\"type\": \"TripsLayer\", \"id\": layer_id},\n    }\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.deckgl.DeckGLMap.add_wms_layer","title":"<code>add_wms_layer(self, data, name=None, service_type='wms', layers=None, srs=None, pickable=False, visible=True, opacity=1.0, **kwargs)</code>","text":"<p>Add a WMS layer for OGC Web Map Service visualization.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>str</code> <p>WMS base URL.</p> required <code>name</code> <code>Optional[str]</code> <p>Layer ID.</p> <code>None</code> <code>service_type</code> <code>str</code> <p>Service type ('wms' or 'template').</p> <code>'wms'</code> <code>layers</code> <code>Optional[List[str]]</code> <p>WMS layer names to request.</p> <code>None</code> <code>srs</code> <code>Optional[str]</code> <p>Spatial reference system (e.g., 'EPSG:4326').</p> <code>None</code> <code>pickable</code> <code>bool</code> <p>Whether layer responds to hover/click.</p> <code>False</code> <code>visible</code> <code>bool</code> <p>Whether layer is visible.</p> <code>True</code> <code>opacity</code> <code>float</code> <p>Layer opacity (0-1).</p> <code>1.0</code> <code>**kwargs</code> <p>Additional WMSLayer props.</p> <code>{}</code> Source code in <code>anymap_ts/deckgl.py</code> <pre><code>def add_wms_layer(\n    self,\n    data: str,\n    name: Optional[str] = None,\n    service_type: str = \"wms\",\n    layers: Optional[List[str]] = None,\n    srs: Optional[str] = None,\n    pickable: bool = False,\n    visible: bool = True,\n    opacity: float = 1.0,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a WMS layer for OGC Web Map Service visualization.\n\n    Args:\n        data: WMS base URL.\n        name: Layer ID.\n        service_type: Service type ('wms' or 'template').\n        layers: WMS layer names to request.\n        srs: Spatial reference system (e.g., 'EPSG:4326').\n        pickable: Whether layer responds to hover/click.\n        visible: Whether layer is visible.\n        opacity: Layer opacity (0-1).\n        **kwargs: Additional WMSLayer props.\n    \"\"\"\n    layer_id = name or f\"wms-{len(self._deck_layers)}\"\n\n    self.call_js_method(\n        \"addWMSLayer\",\n        id=layer_id,\n        data=data,\n        serviceType=service_type,\n        layers=layers,\n        srs=srs,\n        pickable=pickable,\n        visible=visible,\n        opacity=opacity,\n        **kwargs,\n    )\n\n    self._deck_layers = {\n        **self._deck_layers,\n        layer_id: {\"type\": \"WMSLayer\", \"id\": layer_id},\n    }\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.deckgl.DeckGLMap.remove_cog_layer","title":"<code>remove_cog_layer(self, layer_id)</code>","text":"<p>Remove a COG layer.</p> <p>Parameters:</p> Name Type Description Default <code>layer_id</code> <code>str</code> <p>Layer identifier to remove.</p> required Source code in <code>anymap_ts/deckgl.py</code> <pre><code>def remove_cog_layer(self, layer_id: str) -&gt; None:\n    \"\"\"Remove a COG layer.\n\n    Args:\n        layer_id: Layer identifier to remove.\n    \"\"\"\n    self.remove_deck_layer(layer_id)\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.deckgl.DeckGLMap.remove_deck_layer","title":"<code>remove_deck_layer(self, layer_id)</code>","text":"<p>Remove a deck.gl layer.</p> <p>Parameters:</p> Name Type Description Default <code>layer_id</code> <code>str</code> <p>Layer identifier to remove.</p> required Source code in <code>anymap_ts/deckgl.py</code> <pre><code>def remove_deck_layer(self, layer_id: str) -&gt; None:\n    \"\"\"Remove a deck.gl layer.\n\n    Args:\n        layer_id: Layer identifier to remove.\n    \"\"\"\n    if layer_id in self._deck_layers:\n        layers = dict(self._deck_layers)\n        del layers[layer_id]\n        self._deck_layers = layers\n    self.call_js_method(\"removeDeckLayer\", layer_id)\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.deckgl.DeckGLMap.set_deck_layer_visibility","title":"<code>set_deck_layer_visibility(self, layer_id, visible)</code>","text":"<p>Set deck.gl layer visibility.</p> <p>Parameters:</p> Name Type Description Default <code>layer_id</code> <code>str</code> <p>Layer identifier.</p> required <code>visible</code> <code>bool</code> <p>Whether layer should be visible.</p> required Source code in <code>anymap_ts/deckgl.py</code> <pre><code>def set_deck_layer_visibility(self, layer_id: str, visible: bool) -&gt; None:\n    \"\"\"Set deck.gl layer visibility.\n\n    Args:\n        layer_id: Layer identifier.\n        visible: Whether layer should be visible.\n    \"\"\"\n    self.call_js_method(\"setDeckLayerVisibility\", layer_id, visible)\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.keplergl","title":"<code>keplergl</code>","text":"<p>KeplerGL map widget implementation.</p> <p>KeplerGL is loaded via CDN since it's React-based and requires complex setup. This implementation provides a Python wrapper with data management capabilities.</p>"},{"location":"anymap_ts/#anymap_ts.keplergl.KeplerGLMap","title":"<code> KeplerGLMap            (MapWidget)         </code>","text":"<p>Interactive map widget using KeplerGL.</p> <p>KeplerGL is a powerful data visualization tool built on top of deck.gl. This class provides a Python interface for adding data and configuring the KeplerGL visualization.</p> <p>Note: KeplerGL is loaded from CDN due to its React-based architecture.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from anymap_ts import KeplerGLMap\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; m = KeplerGLMap()\n&gt;&gt;&gt; df = pd.DataFrame({\n...     'lat': [37.7749, 37.8044],\n...     'lng': [-122.4194, -122.2712],\n...     'value': [100, 200]\n... })\n&gt;&gt;&gt; m.add_data(df, name='points')\n&gt;&gt;&gt; m\n</code></pre> Source code in <code>anymap_ts/keplergl.py</code> <pre><code>class KeplerGLMap(MapWidget):\n    \"\"\"Interactive map widget using KeplerGL.\n\n    KeplerGL is a powerful data visualization tool built on top of deck.gl.\n    This class provides a Python interface for adding data and configuring\n    the KeplerGL visualization.\n\n    Note: KeplerGL is loaded from CDN due to its React-based architecture.\n\n    Example:\n        &gt;&gt;&gt; from anymap_ts import KeplerGLMap\n        &gt;&gt;&gt; import pandas as pd\n        &gt;&gt;&gt; m = KeplerGLMap()\n        &gt;&gt;&gt; df = pd.DataFrame({\n        ...     'lat': [37.7749, 37.8044],\n        ...     'lng': [-122.4194, -122.2712],\n        ...     'value': [100, 200]\n        ... })\n        &gt;&gt;&gt; m.add_data(df, name='points')\n        &gt;&gt;&gt; m\n    \"\"\"\n\n    # ESM module for frontend\n    _esm = STATIC_DIR / \"keplergl.js\"\n\n    # KeplerGL-specific traits\n    config = traitlets.Dict({}).tag(sync=True)\n    datasets = traitlets.Dict({}).tag(sync=True)\n    read_only = traitlets.Bool(False).tag(sync=True)\n    show_data_table = traitlets.Bool(True).tag(sync=True)\n\n    # Mapbox token for basemaps\n    mapbox_token = traitlets.Unicode(\"\").tag(sync=True)\n\n    def __init__(\n        self,\n        center: Tuple[float, float] = (-122.4, 37.8),\n        zoom: float = 10.0,\n        width: str = \"100%\",\n        height: str = \"600px\",\n        config: Optional[Dict] = None,\n        read_only: bool = False,\n        show_data_table: bool = True,\n        mapbox_token: Optional[str] = None,\n        **kwargs,\n    ):\n        \"\"\"Initialize a KeplerGL map.\n\n        Args:\n            center: Map center as (longitude, latitude).\n            zoom: Initial zoom level.\n            width: Widget width as CSS string.\n            height: Widget height as CSS string.\n            config: KeplerGL configuration dict.\n            read_only: Whether the UI is read-only.\n            show_data_table: Whether to show the data table panel.\n            mapbox_token: Mapbox access token for basemaps.\n            **kwargs: Additional widget arguments.\n        \"\"\"\n        import os\n\n        if mapbox_token is None:\n            mapbox_token = os.environ.get(\"MAPBOX_TOKEN\", \"\")\n\n        super().__init__(\n            center=list(center),\n            zoom=zoom,\n            width=width,\n            height=height,\n            config=config or {},\n            read_only=read_only,\n            show_data_table=show_data_table,\n            mapbox_token=mapbox_token,\n            **kwargs,\n        )\n        self.datasets = {}\n\n    # -------------------------------------------------------------------------\n    # Data Methods\n    # -------------------------------------------------------------------------\n\n    def add_data(\n        self,\n        data: Any,\n        name: Optional[str] = None,\n    ) -&gt; None:\n        \"\"\"Add data to the map.\n\n        Args:\n            data: Data to add (DataFrame, GeoDataFrame, dict, or file path).\n            name: Dataset name/label.\n        \"\"\"\n        dataset_id = name or f\"data_{uuid.uuid4().hex[:8]}\"\n        processed_data = self._process_data(data)\n\n        self.datasets = {\n            **self.datasets,\n            dataset_id: {\n                \"info\": {\n                    \"id\": dataset_id,\n                    \"label\": dataset_id,\n                },\n                \"data\": processed_data,\n            },\n        }\n\n        self.call_js_method(\n            \"addData\",\n            dataId=dataset_id,\n            data=processed_data,\n        )\n\n    def _process_data(self, data: Any) -&gt; Dict:\n        \"\"\"Process data into KeplerGL format.\n\n        Args:\n            data: Input data.\n\n        Returns:\n            Processed data dict with fields and rows.\n        \"\"\"\n        # Handle DataFrame\n        if hasattr(data, \"to_dict\"):\n            # Check if it's a GeoDataFrame\n            if hasattr(data, \"geometry\"):\n                # Convert to GeoJSON for geometry columns\n                geojson = json.loads(data.to_json())\n                return {\n                    \"type\": \"geojson\",\n                    \"data\": geojson,\n                }\n            else:\n                # Regular DataFrame\n                fields = []\n                for col in data.columns:\n                    dtype = str(data[col].dtype)\n                    if \"int\" in dtype:\n                        field_type = \"integer\"\n                    elif \"float\" in dtype:\n                        field_type = \"real\"\n                    elif \"datetime\" in dtype:\n                        field_type = \"timestamp\"\n                    elif \"bool\" in dtype:\n                        field_type = \"boolean\"\n                    else:\n                        field_type = \"string\"\n\n                    fields.append({\"name\": col, \"type\": field_type})\n\n                # Convert to list of lists\n                rows = data.values.tolist()\n\n                return {\n                    \"fields\": fields,\n                    \"rows\": rows,\n                }\n\n        # Handle dict (assume it's already GeoJSON or processed)\n        if isinstance(data, dict):\n            if \"type\" in data and data[\"type\"] in [\n                \"FeatureCollection\",\n                \"Feature\",\n                \"Point\",\n                \"LineString\",\n                \"Polygon\",\n                \"MultiPoint\",\n                \"MultiLineString\",\n                \"MultiPolygon\",\n            ]:\n                return {\"type\": \"geojson\", \"data\": data}\n            return data\n\n        # Handle file path\n        if isinstance(data, (str, Path)):\n            path = Path(data)\n            if path.exists():\n                if path.suffix.lower() in [\".geojson\", \".json\"]:\n                    with open(path) as f:\n                        geojson = json.load(f)\n                    return {\"type\": \"geojson\", \"data\": geojson}\n                elif path.suffix.lower() == \".csv\":\n                    try:\n                        import pandas as pd\n\n                        df = pd.read_csv(path)\n                        return self._process_data(df)\n                    except ImportError:\n                        raise ImportError(\n                            \"pandas is required to load CSV files. \"\n                            \"Install with: pip install pandas\"\n                        )\n\n        return data\n\n    def remove_data(self, name: str) -&gt; None:\n        \"\"\"Remove a dataset.\n\n        Args:\n            name: Dataset name to remove.\n        \"\"\"\n        if name in self.datasets:\n            datasets = dict(self.datasets)\n            del datasets[name]\n            self.datasets = datasets\n        self.call_js_method(\"removeData\", dataId=name)\n\n    # -------------------------------------------------------------------------\n    # Configuration Methods\n    # -------------------------------------------------------------------------\n\n    def set_config(self, config: Dict) -&gt; None:\n        \"\"\"Set the KeplerGL configuration.\n\n        Args:\n            config: Configuration dict.\n        \"\"\"\n        self.config = config\n        self.call_js_method(\"setConfig\", config=config)\n\n    def get_config(self) -&gt; Dict:\n        \"\"\"Get the current KeplerGL configuration.\n\n        Returns:\n            Configuration dict.\n        \"\"\"\n        return self.config\n\n    def save_config(self, filepath: Union[str, Path]) -&gt; None:\n        \"\"\"Save configuration to a JSON file.\n\n        Args:\n            filepath: Path to save the configuration.\n        \"\"\"\n        with open(filepath, \"w\") as f:\n            json.dump(self.config, f, indent=2)\n\n    def load_config(self, filepath: Union[str, Path]) -&gt; None:\n        \"\"\"Load configuration from a JSON file.\n\n        Args:\n            filepath: Path to the configuration file.\n        \"\"\"\n        with open(filepath) as f:\n            config = json.load(f)\n        self.set_config(config)\n\n    # -------------------------------------------------------------------------\n    # Filter Methods\n    # -------------------------------------------------------------------------\n\n    def add_filter(\n        self,\n        data_id: str,\n        field: str,\n        filter_type: str = \"range\",\n        value: Optional[Any] = None,\n    ) -&gt; None:\n        \"\"\"Add a filter to the visualization.\n\n        Args:\n            data_id: Dataset ID to filter.\n            field: Field name to filter on.\n            filter_type: Type of filter ('range', 'select', 'time').\n            value: Filter value(s).\n        \"\"\"\n        filter_config = {\n            \"dataId\": [data_id],\n            \"name\": [field],\n            \"type\": filter_type,\n        }\n        if value is not None:\n            filter_config[\"value\"] = value\n\n        self.call_js_method(\"addFilter\", filter=filter_config)\n\n    # -------------------------------------------------------------------------\n    # Layer Methods\n    # -------------------------------------------------------------------------\n\n    def add_layer(\n        self,\n        layer_type: str,\n        data_id: str,\n        columns: Dict[str, str],\n        label: Optional[str] = None,\n        color: Optional[List[int]] = None,\n        vis_config: Optional[Dict] = None,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a layer to the visualization.\n\n        Args:\n            layer_type: Layer type ('point', 'arc', 'line', 'hexagon', 'heatmap', etc.).\n            data_id: Dataset ID for the layer.\n            columns: Column mapping (e.g., {'lat': 'latitude', 'lng': 'longitude'}).\n            label: Layer label.\n            color: Layer color as [r, g, b].\n            vis_config: Visual configuration.\n            **kwargs: Additional layer options.\n        \"\"\"\n        layer_config = {\n            \"type\": layer_type,\n            \"config\": {\n                \"dataId\": data_id,\n                \"label\": label or f\"{layer_type}_layer\",\n                \"columns\": columns,\n                \"isVisible\": True,\n            },\n        }\n        if color:\n            layer_config[\"config\"][\"color\"] = color\n        if vis_config:\n            layer_config[\"config\"][\"visConfig\"] = vis_config\n\n        layer_config[\"config\"].update(kwargs)\n\n        self.call_js_method(\"addLayer\", layer=layer_config)\n\n    # -------------------------------------------------------------------------\n    # View Methods\n    # -------------------------------------------------------------------------\n\n    def fly_to(\n        self,\n        lng: float,\n        lat: float,\n        zoom: Optional[float] = None,\n    ) -&gt; None:\n        \"\"\"Fly to a location.\n\n        Args:\n            lng: Target longitude.\n            lat: Target latitude.\n            zoom: Target zoom level.\n        \"\"\"\n        self.center = [lng, lat]\n        if zoom is not None:\n            self.zoom = zoom\n        self.call_js_method(\"flyTo\", lng=lng, lat=lat, zoom=zoom or self.zoom)\n\n    # -------------------------------------------------------------------------\n    # HTML Export\n    # -------------------------------------------------------------------------\n\n    def _generate_html_template(self) -&gt; str:\n        \"\"\"Generate standalone HTML for KeplerGL.\"\"\"\n        template_path = Path(__file__).parent / \"templates\" / \"keplergl.html\"\n\n        if template_path.exists():\n            template = template_path.read_text(encoding=\"utf-8\")\n        else:\n            template = self._get_default_template()\n\n        state = {\n            \"center\": self.center,\n            \"zoom\": self.zoom,\n            \"config\": self.config,\n            \"datasets\": self.datasets,\n            \"read_only\": self.read_only,\n            \"mapbox_token\": self.mapbox_token,\n            \"width\": self.width,\n            \"height\": self.height,\n            \"js_calls\": self._js_calls,\n        }\n\n        template = template.replace(\"{{state}}\", json.dumps(state, indent=2))\n        return template\n\n    def _get_default_template(self) -&gt; str:\n        \"\"\"Get default HTML template.\"\"\"\n        return \"\"\"&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n    &lt;meta charset=\"utf-8\"&gt;\n    &lt;title&gt;KeplerGL Map&lt;/title&gt;\n    &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"&gt;\n    &lt;style&gt;\n        * { margin: 0; padding: 0; box-sizing: border-box; }\n        html, body { height: 100%; }\n        #app { position: absolute; top: 0; bottom: 0; width: 100%; }\n    &lt;/style&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;div id=\"app\"&gt;&lt;/div&gt;\n    &lt;script&gt;\n        const state = {{state}};\n        // KeplerGL requires React/Redux setup - simplified placeholder\n        document.getElementById('app').innerHTML = '&lt;p&gt;KeplerGL visualization requires full React setup. Use Jupyter widget for interactive visualization.&lt;/p&gt;';\n    &lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\"\"\"\n\n    def _repr_html_(self) -&gt; str:\n        \"\"\"Return HTML representation for Jupyter (uses iframe with CDN KeplerGL).\"\"\"\n        state = {\n            \"center\": self.center,\n            \"zoom\": self.zoom,\n            \"config\": self.config,\n            \"datasets\": self.datasets,\n            \"mapbox_token\": self.mapbox_token,\n        }\n\n        html = f\"\"\"\n        &lt;iframe\n            srcdoc='\n            &lt;!DOCTYPE html&gt;\n            &lt;html&gt;\n            &lt;head&gt;\n                &lt;meta charset=\"utf-8\"&gt;\n                &lt;script src=\"https://unpkg.com/react@16.8.4/umd/react.production.min.js\"&gt;&lt;/script&gt;\n                &lt;script src=\"https://unpkg.com/react-dom@16.8.4/umd/react-dom.production.min.js\"&gt;&lt;/script&gt;\n                &lt;script src=\"https://unpkg.com/kepler.gl@3.0.0/umd/keplergl.min.js\"&gt;&lt;/script&gt;\n                &lt;link href=\"https://unpkg.com/kepler.gl@3.0.0/umd/keplergl.min.css\" rel=\"stylesheet\" /&gt;\n                &lt;style&gt;\n                    body {{ margin: 0; padding: 0; overflow: hidden; }}\n                    #app {{ width: 100vw; height: 100vh; }}\n                &lt;/style&gt;\n            &lt;/head&gt;\n            &lt;body&gt;\n                &lt;div id=\"app\"&gt;&lt;/div&gt;\n                &lt;script&gt;\n                    const state = {json.dumps(state)};\n                    // KeplerGL requires complex React setup\n                    document.getElementById(\"app\").innerHTML = \"KeplerGL widget - use anywidget interface for full interactivity\";\n                &lt;/script&gt;\n            &lt;/body&gt;\n            &lt;/html&gt;\n            '\n            width=\"{self.width}\"\n            height=\"{self.height}\"\n            frameborder=\"0\"\n        &gt;&lt;/iframe&gt;\n        \"\"\"\n        return html\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.keplergl.KeplerGLMap.__init__","title":"<code>__init__(self, center=(-122.4, 37.8), zoom=10.0, width='100%', height='600px', config=None, read_only=False, show_data_table=True, mapbox_token=None, **kwargs)</code>  <code>special</code>","text":"<p>Initialize a KeplerGL map.</p> <p>Parameters:</p> Name Type Description Default <code>center</code> <code>Tuple[float, float]</code> <p>Map center as (longitude, latitude).</p> <code>(-122.4, 37.8)</code> <code>zoom</code> <code>float</code> <p>Initial zoom level.</p> <code>10.0</code> <code>width</code> <code>str</code> <p>Widget width as CSS string.</p> <code>'100%'</code> <code>height</code> <code>str</code> <p>Widget height as CSS string.</p> <code>'600px'</code> <code>config</code> <code>Optional[Dict]</code> <p>KeplerGL configuration dict.</p> <code>None</code> <code>read_only</code> <code>bool</code> <p>Whether the UI is read-only.</p> <code>False</code> <code>show_data_table</code> <code>bool</code> <p>Whether to show the data table panel.</p> <code>True</code> <code>mapbox_token</code> <code>Optional[str]</code> <p>Mapbox access token for basemaps.</p> <code>None</code> <code>**kwargs</code> <p>Additional widget arguments.</p> <code>{}</code> Source code in <code>anymap_ts/keplergl.py</code> <pre><code>def __init__(\n    self,\n    center: Tuple[float, float] = (-122.4, 37.8),\n    zoom: float = 10.0,\n    width: str = \"100%\",\n    height: str = \"600px\",\n    config: Optional[Dict] = None,\n    read_only: bool = False,\n    show_data_table: bool = True,\n    mapbox_token: Optional[str] = None,\n    **kwargs,\n):\n    \"\"\"Initialize a KeplerGL map.\n\n    Args:\n        center: Map center as (longitude, latitude).\n        zoom: Initial zoom level.\n        width: Widget width as CSS string.\n        height: Widget height as CSS string.\n        config: KeplerGL configuration dict.\n        read_only: Whether the UI is read-only.\n        show_data_table: Whether to show the data table panel.\n        mapbox_token: Mapbox access token for basemaps.\n        **kwargs: Additional widget arguments.\n    \"\"\"\n    import os\n\n    if mapbox_token is None:\n        mapbox_token = os.environ.get(\"MAPBOX_TOKEN\", \"\")\n\n    super().__init__(\n        center=list(center),\n        zoom=zoom,\n        width=width,\n        height=height,\n        config=config or {},\n        read_only=read_only,\n        show_data_table=show_data_table,\n        mapbox_token=mapbox_token,\n        **kwargs,\n    )\n    self.datasets = {}\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.keplergl.KeplerGLMap.add_data","title":"<code>add_data(self, data, name=None)</code>","text":"<p>Add data to the map.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>Data to add (DataFrame, GeoDataFrame, dict, or file path).</p> required <code>name</code> <code>Optional[str]</code> <p>Dataset name/label.</p> <code>None</code> Source code in <code>anymap_ts/keplergl.py</code> <pre><code>def add_data(\n    self,\n    data: Any,\n    name: Optional[str] = None,\n) -&gt; None:\n    \"\"\"Add data to the map.\n\n    Args:\n        data: Data to add (DataFrame, GeoDataFrame, dict, or file path).\n        name: Dataset name/label.\n    \"\"\"\n    dataset_id = name or f\"data_{uuid.uuid4().hex[:8]}\"\n    processed_data = self._process_data(data)\n\n    self.datasets = {\n        **self.datasets,\n        dataset_id: {\n            \"info\": {\n                \"id\": dataset_id,\n                \"label\": dataset_id,\n            },\n            \"data\": processed_data,\n        },\n    }\n\n    self.call_js_method(\n        \"addData\",\n        dataId=dataset_id,\n        data=processed_data,\n    )\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.keplergl.KeplerGLMap.add_filter","title":"<code>add_filter(self, data_id, field, filter_type='range', value=None)</code>","text":"<p>Add a filter to the visualization.</p> <p>Parameters:</p> Name Type Description Default <code>data_id</code> <code>str</code> <p>Dataset ID to filter.</p> required <code>field</code> <code>str</code> <p>Field name to filter on.</p> required <code>filter_type</code> <code>str</code> <p>Type of filter ('range', 'select', 'time').</p> <code>'range'</code> <code>value</code> <code>Optional[Any]</code> <p>Filter value(s).</p> <code>None</code> Source code in <code>anymap_ts/keplergl.py</code> <pre><code>def add_filter(\n    self,\n    data_id: str,\n    field: str,\n    filter_type: str = \"range\",\n    value: Optional[Any] = None,\n) -&gt; None:\n    \"\"\"Add a filter to the visualization.\n\n    Args:\n        data_id: Dataset ID to filter.\n        field: Field name to filter on.\n        filter_type: Type of filter ('range', 'select', 'time').\n        value: Filter value(s).\n    \"\"\"\n    filter_config = {\n        \"dataId\": [data_id],\n        \"name\": [field],\n        \"type\": filter_type,\n    }\n    if value is not None:\n        filter_config[\"value\"] = value\n\n    self.call_js_method(\"addFilter\", filter=filter_config)\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.keplergl.KeplerGLMap.add_layer","title":"<code>add_layer(self, layer_type, data_id, columns, label=None, color=None, vis_config=None, **kwargs)</code>","text":"<p>Add a layer to the visualization.</p> <p>Parameters:</p> Name Type Description Default <code>layer_type</code> <code>str</code> <p>Layer type ('point', 'arc', 'line', 'hexagon', 'heatmap', etc.).</p> required <code>data_id</code> <code>str</code> <p>Dataset ID for the layer.</p> required <code>columns</code> <code>Dict[str, str]</code> <p>Column mapping (e.g., {'lat': 'latitude', 'lng': 'longitude'}).</p> required <code>label</code> <code>Optional[str]</code> <p>Layer label.</p> <code>None</code> <code>color</code> <code>Optional[List[int]]</code> <p>Layer color as [r, g, b].</p> <code>None</code> <code>vis_config</code> <code>Optional[Dict]</code> <p>Visual configuration.</p> <code>None</code> <code>**kwargs</code> <p>Additional layer options.</p> <code>{}</code> Source code in <code>anymap_ts/keplergl.py</code> <pre><code>def add_layer(\n    self,\n    layer_type: str,\n    data_id: str,\n    columns: Dict[str, str],\n    label: Optional[str] = None,\n    color: Optional[List[int]] = None,\n    vis_config: Optional[Dict] = None,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a layer to the visualization.\n\n    Args:\n        layer_type: Layer type ('point', 'arc', 'line', 'hexagon', 'heatmap', etc.).\n        data_id: Dataset ID for the layer.\n        columns: Column mapping (e.g., {'lat': 'latitude', 'lng': 'longitude'}).\n        label: Layer label.\n        color: Layer color as [r, g, b].\n        vis_config: Visual configuration.\n        **kwargs: Additional layer options.\n    \"\"\"\n    layer_config = {\n        \"type\": layer_type,\n        \"config\": {\n            \"dataId\": data_id,\n            \"label\": label or f\"{layer_type}_layer\",\n            \"columns\": columns,\n            \"isVisible\": True,\n        },\n    }\n    if color:\n        layer_config[\"config\"][\"color\"] = color\n    if vis_config:\n        layer_config[\"config\"][\"visConfig\"] = vis_config\n\n    layer_config[\"config\"].update(kwargs)\n\n    self.call_js_method(\"addLayer\", layer=layer_config)\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.keplergl.KeplerGLMap.fly_to","title":"<code>fly_to(self, lng, lat, zoom=None)</code>","text":"<p>Fly to a location.</p> <p>Parameters:</p> Name Type Description Default <code>lng</code> <code>float</code> <p>Target longitude.</p> required <code>lat</code> <code>float</code> <p>Target latitude.</p> required <code>zoom</code> <code>Optional[float]</code> <p>Target zoom level.</p> <code>None</code> Source code in <code>anymap_ts/keplergl.py</code> <pre><code>def fly_to(\n    self,\n    lng: float,\n    lat: float,\n    zoom: Optional[float] = None,\n) -&gt; None:\n    \"\"\"Fly to a location.\n\n    Args:\n        lng: Target longitude.\n        lat: Target latitude.\n        zoom: Target zoom level.\n    \"\"\"\n    self.center = [lng, lat]\n    if zoom is not None:\n        self.zoom = zoom\n    self.call_js_method(\"flyTo\", lng=lng, lat=lat, zoom=zoom or self.zoom)\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.keplergl.KeplerGLMap.get_config","title":"<code>get_config(self)</code>","text":"<p>Get the current KeplerGL configuration.</p> <p>Returns:</p> Type Description <code>Dict</code> <p>Configuration dict.</p> Source code in <code>anymap_ts/keplergl.py</code> <pre><code>def get_config(self) -&gt; Dict:\n    \"\"\"Get the current KeplerGL configuration.\n\n    Returns:\n        Configuration dict.\n    \"\"\"\n    return self.config\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.keplergl.KeplerGLMap.load_config","title":"<code>load_config(self, filepath)</code>","text":"<p>Load configuration from a JSON file.</p> <p>Parameters:</p> Name Type Description Default <code>filepath</code> <code>Union[str, Path]</code> <p>Path to the configuration file.</p> required Source code in <code>anymap_ts/keplergl.py</code> <pre><code>def load_config(self, filepath: Union[str, Path]) -&gt; None:\n    \"\"\"Load configuration from a JSON file.\n\n    Args:\n        filepath: Path to the configuration file.\n    \"\"\"\n    with open(filepath) as f:\n        config = json.load(f)\n    self.set_config(config)\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.keplergl.KeplerGLMap.remove_data","title":"<code>remove_data(self, name)</code>","text":"<p>Remove a dataset.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Dataset name to remove.</p> required Source code in <code>anymap_ts/keplergl.py</code> <pre><code>def remove_data(self, name: str) -&gt; None:\n    \"\"\"Remove a dataset.\n\n    Args:\n        name: Dataset name to remove.\n    \"\"\"\n    if name in self.datasets:\n        datasets = dict(self.datasets)\n        del datasets[name]\n        self.datasets = datasets\n    self.call_js_method(\"removeData\", dataId=name)\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.keplergl.KeplerGLMap.save_config","title":"<code>save_config(self, filepath)</code>","text":"<p>Save configuration to a JSON file.</p> <p>Parameters:</p> Name Type Description Default <code>filepath</code> <code>Union[str, Path]</code> <p>Path to save the configuration.</p> required Source code in <code>anymap_ts/keplergl.py</code> <pre><code>def save_config(self, filepath: Union[str, Path]) -&gt; None:\n    \"\"\"Save configuration to a JSON file.\n\n    Args:\n        filepath: Path to save the configuration.\n    \"\"\"\n    with open(filepath, \"w\") as f:\n        json.dump(self.config, f, indent=2)\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.keplergl.KeplerGLMap.set_config","title":"<code>set_config(self, config)</code>","text":"<p>Set the KeplerGL configuration.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>Dict</code> <p>Configuration dict.</p> required Source code in <code>anymap_ts/keplergl.py</code> <pre><code>def set_config(self, config: Dict) -&gt; None:\n    \"\"\"Set the KeplerGL configuration.\n\n    Args:\n        config: Configuration dict.\n    \"\"\"\n    self.config = config\n    self.call_js_method(\"setConfig\", config=config)\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.leaflet","title":"<code>leaflet</code>","text":"<p>Leaflet map widget implementation.</p>"},{"location":"anymap_ts/#anymap_ts.leaflet.LeafletMap","title":"<code> LeafletMap            (MapWidget)         </code>","text":"<p>Interactive map widget using Leaflet.</p> <p>This class provides a Python interface to Leaflet maps with full bidirectional communication through anywidget.</p> <p>Note</p> <p>Leaflet uses [lat, lng] order internally, but this class accepts [lng, lat] for consistency with other map libraries.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from anymap_ts import LeafletMap\n&gt;&gt;&gt; m = LeafletMap(center=[-122.4, 37.8], zoom=10)\n&gt;&gt;&gt; m.add_basemap(\"OpenStreetMap\")\n&gt;&gt;&gt; m\n</code></pre> Source code in <code>anymap_ts/leaflet.py</code> <pre><code>class LeafletMap(MapWidget):\n    \"\"\"Interactive map widget using Leaflet.\n\n    This class provides a Python interface to Leaflet maps with\n    full bidirectional communication through anywidget.\n\n    Note:\n        Leaflet uses [lat, lng] order internally, but this class\n        accepts [lng, lat] for consistency with other map libraries.\n\n    Example:\n        &gt;&gt;&gt; from anymap_ts import LeafletMap\n        &gt;&gt;&gt; m = LeafletMap(center=[-122.4, 37.8], zoom=10)\n        &gt;&gt;&gt; m.add_basemap(\"OpenStreetMap\")\n        &gt;&gt;&gt; m\n    \"\"\"\n\n    # ESM module for frontend\n    _esm = STATIC_DIR / \"leaflet.js\"\n    _css = STATIC_DIR / \"leaflet.css\"\n\n    # Layer tracking\n    _layer_dict = traitlets.Dict({}).tag(sync=True)\n\n    def __init__(\n        self,\n        center: Tuple[float, float] = (0.0, 0.0),\n        zoom: float = 2.0,\n        width: str = \"100%\",\n        height: str = \"600px\",\n        controls: Optional[Dict[str, Any]] = None,\n        **kwargs,\n    ):\n        \"\"\"Initialize a Leaflet map.\n\n        Args:\n            center: Map center as (longitude, latitude).\n            zoom: Initial zoom level.\n            width: Map width as CSS string.\n            height: Map height as CSS string.\n            controls: Dict of controls to add (e.g., {\"zoom\": True}).\n            **kwargs: Additional widget arguments.\n        \"\"\"\n        super().__init__(\n            center=list(center),\n            zoom=zoom,\n            width=width,\n            height=height,\n            style=\"\",  # Leaflet doesn't use style URLs\n            **kwargs,\n        )\n\n        # Initialize layer dictionary\n        self._layer_dict = {\"Background\": []}\n\n        # Add default controls\n        if controls is None:\n            controls = {\n                \"scale\": {\"position\": \"bottom-left\"},\n                \"attribution\": {\"position\": \"bottom-right\"},\n                \"layers\": {\"position\": \"top-right\"},\n            }\n\n        for control_name, config in controls.items():\n            if config:\n                self.add_control(\n                    control_name, **(config if isinstance(config, dict) else {})\n                )\n\n    # -------------------------------------------------------------------------\n    # Basemap Methods\n    # -------------------------------------------------------------------------\n\n    def add_basemap(\n        self,\n        basemap: str = \"OpenStreetMap\",\n        attribution: Optional[str] = None,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a basemap layer.\n\n        Args:\n            basemap: Name of basemap provider (e.g., \"OpenStreetMap\", \"CartoDB.Positron\").\n            attribution: Custom attribution text.\n            **kwargs: Additional options.\n        \"\"\"\n        try:\n            url, default_attribution = get_basemap_url(basemap)\n        except (ValueError, KeyError):\n            url = basemap\n            default_attribution = \"\"\n\n        self.call_js_method(\n            \"addBasemap\",\n            url,\n            attribution=attribution or default_attribution,\n            name=basemap,\n            **kwargs,\n        )\n\n        # Track in layer dict\n        basemaps = self._layer_dict.get(\"Basemaps\", [])\n        if basemap not in basemaps:\n            self._layer_dict = {\n                **self._layer_dict,\n                \"Basemaps\": basemaps + [basemap],\n            }\n\n    # -------------------------------------------------------------------------\n    # Vector Data Methods\n    # -------------------------------------------------------------------------\n\n    def add_vector(\n        self,\n        data: Any,\n        style: Optional[Dict] = None,\n        name: Optional[str] = None,\n        fit_bounds: bool = True,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add vector data to the map.\n\n        Supports GeoJSON, GeoDataFrame, or file paths to vector formats.\n\n        Args:\n            data: GeoJSON dict, GeoDataFrame, or path to vector file.\n            style: Leaflet style properties.\n            name: Layer name.\n            fit_bounds: Whether to fit map to data bounds.\n            **kwargs: Additional layer options.\n        \"\"\"\n        geojson = to_geojson(data)\n\n        # Handle URL data\n        if geojson.get(\"type\") == \"url\":\n            self.add_geojson(\n                geojson[\"url\"],\n                style=style,\n                name=name,\n                fit_bounds=fit_bounds,\n                **kwargs,\n            )\n            return\n\n        layer_id = name or f\"vector-{len(self._layers)}\"\n\n        # Get default style if not provided\n        if style is None:\n            layer_type = _infer_leaflet_type(geojson)\n            style = _get_default_style(layer_type)\n\n        # Get bounds\n        bounds = get_bounds(data) if fit_bounds else None\n\n        # Call JavaScript\n        self.call_js_method(\n            \"addGeoJSON\",\n            data=geojson,\n            name=layer_id,\n            style=style,\n            fitBounds=fit_bounds,\n            bounds=bounds,\n            **kwargs,\n        )\n\n        # Track layer\n        self._layers = {\n            **self._layers,\n            layer_id: {\n                \"id\": layer_id,\n                \"type\": \"geojson\",\n                \"style\": style,\n            },\n        }\n\n    def add_geojson(\n        self,\n        data: Union[str, Dict],\n        style: Optional[Dict] = None,\n        name: Optional[str] = None,\n        fit_bounds: bool = True,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add GeoJSON data to the map.\n\n        Args:\n            data: GeoJSON dict or URL to GeoJSON file.\n            style: Leaflet style properties.\n            name: Layer name.\n            fit_bounds: Whether to fit map to data bounds.\n            **kwargs: Additional layer options.\n        \"\"\"\n        self.add_vector(\n            data,\n            style=style,\n            name=name,\n            fit_bounds=fit_bounds,\n            **kwargs,\n        )\n\n    # -------------------------------------------------------------------------\n    # Raster Data Methods\n    # -------------------------------------------------------------------------\n\n    def add_tile_layer(\n        self,\n        url: str,\n        name: Optional[str] = None,\n        attribution: str = \"\",\n        min_zoom: int = 0,\n        max_zoom: int = 22,\n        opacity: float = 1.0,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add an XYZ tile layer.\n\n        Args:\n            url: Tile URL template with {x}, {y}, {z} placeholders.\n            name: Layer name.\n            attribution: Attribution text.\n            min_zoom: Minimum zoom level.\n            max_zoom: Maximum zoom level.\n            opacity: Layer opacity.\n            **kwargs: Additional options.\n        \"\"\"\n        layer_id = name or f\"tiles-{len(self._layers)}\"\n\n        self.call_js_method(\n            \"addTileLayer\",\n            url,\n            name=layer_id,\n            attribution=attribution,\n            minZoom=min_zoom,\n            maxZoom=max_zoom,\n            opacity=opacity,\n            **kwargs,\n        )\n\n        # Track layer\n        self._layers = {\n            **self._layers,\n            layer_id: {\n                \"id\": layer_id,\n                \"type\": \"tile\",\n            },\n        }\n\n    # -------------------------------------------------------------------------\n    # Layer Management\n    # -------------------------------------------------------------------------\n\n    def remove_layer(self, layer_id: str) -&gt; None:\n        \"\"\"Remove a layer from the map.\n\n        Args:\n            layer_id: Layer identifier to remove.\n        \"\"\"\n        if layer_id in self._layers:\n            layers = dict(self._layers)\n            del layers[layer_id]\n            self._layers = layers\n        self.call_js_method(\"removeLayer\", layer_id)\n\n    def set_visibility(self, layer_id: str, visible: bool) -&gt; None:\n        \"\"\"Set layer visibility.\n\n        Args:\n            layer_id: Layer identifier.\n            visible: Whether layer should be visible.\n        \"\"\"\n        self.call_js_method(\"setVisibility\", layer_id, visible)\n\n    def set_opacity(self, layer_id: str, opacity: float) -&gt; None:\n        \"\"\"Set layer opacity.\n\n        Args:\n            layer_id: Layer identifier.\n            opacity: Opacity value between 0 and 1.\n        \"\"\"\n        self.call_js_method(\"setOpacity\", layer_id, opacity)\n\n    # -------------------------------------------------------------------------\n    # Controls\n    # -------------------------------------------------------------------------\n\n    def add_control(\n        self,\n        control_type: str,\n        position: str = \"topright\",\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a map control.\n\n        Args:\n            control_type: Type of control ('zoom', 'scale', 'attribution', 'layers').\n            position: Control position ('topleft', 'topright', 'bottomleft', 'bottomright').\n            **kwargs: Control-specific options.\n        \"\"\"\n        # Convert position format\n        position_map = {\n            \"top-left\": \"topleft\",\n            \"top-right\": \"topright\",\n            \"bottom-left\": \"bottomleft\",\n            \"bottom-right\": \"bottomright\",\n        }\n        pos = position_map.get(position, position)\n\n        self.call_js_method(\"addControl\", control_type, position=pos, **kwargs)\n        self._controls = {\n            **self._controls,\n            control_type: {\"type\": control_type, \"position\": pos, **kwargs},\n        }\n\n    def remove_control(self, control_type: str) -&gt; None:\n        \"\"\"Remove a map control.\n\n        Args:\n            control_type: Type of control to remove.\n        \"\"\"\n        self.call_js_method(\"removeControl\", control_type)\n        if control_type in self._controls:\n            controls = dict(self._controls)\n            del controls[control_type]\n            self._controls = controls\n\n    def add_layer_control(\n        self,\n        position: str = \"topright\",\n        collapsed: bool = True,\n    ) -&gt; None:\n        \"\"\"Add a layer control for toggling layer visibility.\n\n        Args:\n            position: Control position.\n            collapsed: Whether control starts collapsed.\n        \"\"\"\n        self.add_control(\"layers\", position=position, collapsed=collapsed)\n\n    # -------------------------------------------------------------------------\n    # Markers\n    # -------------------------------------------------------------------------\n\n    def add_marker(\n        self,\n        lng: float,\n        lat: float,\n        popup: Optional[str] = None,\n        marker_id: Optional[str] = None,\n    ) -&gt; None:\n        \"\"\"Add a marker to the map.\n\n        Args:\n            lng: Longitude.\n            lat: Latitude.\n            popup: HTML content for popup.\n            marker_id: Unique marker ID.\n        \"\"\"\n        self.call_js_method(\"addMarker\", lng, lat, popup=popup, id=marker_id)\n\n    def remove_marker(self, marker_id: str) -&gt; None:\n        \"\"\"Remove a marker from the map.\n\n        Args:\n            marker_id: Marker ID to remove.\n        \"\"\"\n        self.call_js_method(\"removeMarker\", marker_id)\n\n    # -------------------------------------------------------------------------\n    # HTML Export\n    # -------------------------------------------------------------------------\n\n    def _generate_html_template(self) -&gt; str:\n        \"\"\"Generate standalone HTML for the map.\"\"\"\n        template_path = Path(__file__).parent / \"templates\" / \"leaflet.html\"\n\n        if template_path.exists():\n            template = template_path.read_text(encoding=\"utf-8\")\n        else:\n            template = self._get_default_template()\n\n        # Serialize state\n        state = {\n            \"center\": self.center,\n            \"zoom\": self.zoom,\n            \"width\": self.width,\n            \"height\": self.height,\n            \"layers\": self._layers,\n            \"controls\": self._controls,\n            \"js_calls\": self._js_calls,\n        }\n\n        template = template.replace(\"{{state}}\", json.dumps(state, indent=2))\n        return template\n\n    def _get_default_template(self) -&gt; str:\n        \"\"\"Get default HTML template.\"\"\"\n        return \"\"\"&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n    &lt;meta charset=\"utf-8\"&gt;\n    &lt;title&gt;{{title}}&lt;/title&gt;\n    &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"&gt;\n    &lt;link rel=\"stylesheet\" href=\"https://unpkg.com/leaflet@1.9.4/dist/leaflet.css\" /&gt;\n    &lt;script src=\"https://unpkg.com/leaflet@1.9.4/dist/leaflet.js\"&gt;&lt;/script&gt;\n    &lt;style&gt;\n        body { margin: 0; padding: 0; }\n        #map { position: absolute; top: 0; bottom: 0; width: 100%; }\n    &lt;/style&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;div id=\"map\"&gt;&lt;/div&gt;\n    &lt;script&gt;\n        const state = {{state}};\n\n        // Note: Leaflet uses [lat, lng], but we store [lng, lat]\n        const map = L.map('map').setView([state.center[1], state.center[0]], state.zoom);\n\n        // Replay JS calls\n        for (const call of state.js_calls || []) {\n            try {\n                executeMethod(call.method, call.args, call.kwargs);\n            } catch (e) {\n                console.error('Error executing', call.method, e);\n            }\n        }\n\n        function executeMethod(method, args, kwargs) {\n            switch (method) {\n                case 'addBasemap':\n                case 'addTileLayer':\n                    const url = args[0];\n                    L.tileLayer(url, {\n                        attribution: kwargs.attribution || '',\n                        maxZoom: kwargs.maxZoom || 22,\n                        minZoom: kwargs.minZoom || 0,\n                        opacity: kwargs.opacity || 1\n                    }).addTo(map);\n                    break;\n\n                case 'addGeoJSON':\n                    const geojson = kwargs.data;\n                    const style = kwargs.style || {\n                        color: '#3388ff',\n                        weight: 2,\n                        opacity: 0.8,\n                        fillOpacity: 0.5\n                    };\n                    const layer = L.geoJSON(geojson, {\n                        style: style,\n                        pointToLayer: (feature, latlng) =&gt; L.circleMarker(latlng, style)\n                    }).addTo(map);\n\n                    if (kwargs.fitBounds) {\n                        map.fitBounds(layer.getBounds(), { padding: [50, 50] });\n                    }\n                    break;\n\n                case 'addControl':\n                    const controlType = args[0];\n                    const position = kwargs.position || 'topright';\n                    if (controlType === 'zoom' || controlType === 'navigation') {\n                        L.control.zoom({ position }).addTo(map);\n                    } else if (controlType === 'scale') {\n                        L.control.scale({ position, imperial: false }).addTo(map);\n                    }\n                    break;\n\n                case 'addMarker':\n                    const [lng, lat] = args;\n                    const marker = L.marker([lat, lng]).addTo(map);\n                    if (kwargs.popup) {\n                        marker.bindPopup(kwargs.popup);\n                    }\n                    break;\n\n                case 'flyTo':\n                    map.flyTo([args[1], args[0]], kwargs.zoom || map.getZoom(), {\n                        duration: (kwargs.duration || 2000) / 1000\n                    });\n                    break;\n\n                case 'fitBounds':\n                    const bounds = args[0];\n                    map.fitBounds([\n                        [bounds[1], bounds[0]],\n                        [bounds[3], bounds[2]]\n                    ], { padding: [kwargs.padding || 50, kwargs.padding || 50] });\n                    break;\n\n                default:\n                    console.log('Unknown method:', method);\n            }\n        }\n    &lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\"\"\"\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.leaflet.LeafletMap.__init__","title":"<code>__init__(self, center=(0.0, 0.0), zoom=2.0, width='100%', height='600px', controls=None, **kwargs)</code>  <code>special</code>","text":"<p>Initialize a Leaflet map.</p> <p>Parameters:</p> Name Type Description Default <code>center</code> <code>Tuple[float, float]</code> <p>Map center as (longitude, latitude).</p> <code>(0.0, 0.0)</code> <code>zoom</code> <code>float</code> <p>Initial zoom level.</p> <code>2.0</code> <code>width</code> <code>str</code> <p>Map width as CSS string.</p> <code>'100%'</code> <code>height</code> <code>str</code> <p>Map height as CSS string.</p> <code>'600px'</code> <code>controls</code> <code>Optional[Dict[str, Any]]</code> <p>Dict of controls to add (e.g., {\"zoom\": True}).</p> <code>None</code> <code>**kwargs</code> <p>Additional widget arguments.</p> <code>{}</code> Source code in <code>anymap_ts/leaflet.py</code> <pre><code>def __init__(\n    self,\n    center: Tuple[float, float] = (0.0, 0.0),\n    zoom: float = 2.0,\n    width: str = \"100%\",\n    height: str = \"600px\",\n    controls: Optional[Dict[str, Any]] = None,\n    **kwargs,\n):\n    \"\"\"Initialize a Leaflet map.\n\n    Args:\n        center: Map center as (longitude, latitude).\n        zoom: Initial zoom level.\n        width: Map width as CSS string.\n        height: Map height as CSS string.\n        controls: Dict of controls to add (e.g., {\"zoom\": True}).\n        **kwargs: Additional widget arguments.\n    \"\"\"\n    super().__init__(\n        center=list(center),\n        zoom=zoom,\n        width=width,\n        height=height,\n        style=\"\",  # Leaflet doesn't use style URLs\n        **kwargs,\n    )\n\n    # Initialize layer dictionary\n    self._layer_dict = {\"Background\": []}\n\n    # Add default controls\n    if controls is None:\n        controls = {\n            \"scale\": {\"position\": \"bottom-left\"},\n            \"attribution\": {\"position\": \"bottom-right\"},\n            \"layers\": {\"position\": \"top-right\"},\n        }\n\n    for control_name, config in controls.items():\n        if config:\n            self.add_control(\n                control_name, **(config if isinstance(config, dict) else {})\n            )\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.leaflet.LeafletMap.add_basemap","title":"<code>add_basemap(self, basemap='OpenStreetMap', attribution=None, **kwargs)</code>","text":"<p>Add a basemap layer.</p> <p>Parameters:</p> Name Type Description Default <code>basemap</code> <code>str</code> <p>Name of basemap provider (e.g., \"OpenStreetMap\", \"CartoDB.Positron\").</p> <code>'OpenStreetMap'</code> <code>attribution</code> <code>Optional[str]</code> <p>Custom attribution text.</p> <code>None</code> <code>**kwargs</code> <p>Additional options.</p> <code>{}</code> Source code in <code>anymap_ts/leaflet.py</code> <pre><code>def add_basemap(\n    self,\n    basemap: str = \"OpenStreetMap\",\n    attribution: Optional[str] = None,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a basemap layer.\n\n    Args:\n        basemap: Name of basemap provider (e.g., \"OpenStreetMap\", \"CartoDB.Positron\").\n        attribution: Custom attribution text.\n        **kwargs: Additional options.\n    \"\"\"\n    try:\n        url, default_attribution = get_basemap_url(basemap)\n    except (ValueError, KeyError):\n        url = basemap\n        default_attribution = \"\"\n\n    self.call_js_method(\n        \"addBasemap\",\n        url,\n        attribution=attribution or default_attribution,\n        name=basemap,\n        **kwargs,\n    )\n\n    # Track in layer dict\n    basemaps = self._layer_dict.get(\"Basemaps\", [])\n    if basemap not in basemaps:\n        self._layer_dict = {\n            **self._layer_dict,\n            \"Basemaps\": basemaps + [basemap],\n        }\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.leaflet.LeafletMap.add_control","title":"<code>add_control(self, control_type, position='topright', **kwargs)</code>","text":"<p>Add a map control.</p> <p>Parameters:</p> Name Type Description Default <code>control_type</code> <code>str</code> <p>Type of control ('zoom', 'scale', 'attribution', 'layers').</p> required <code>position</code> <code>str</code> <p>Control position ('topleft', 'topright', 'bottomleft', 'bottomright').</p> <code>'topright'</code> <code>**kwargs</code> <p>Control-specific options.</p> <code>{}</code> Source code in <code>anymap_ts/leaflet.py</code> <pre><code>def add_control(\n    self,\n    control_type: str,\n    position: str = \"topright\",\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a map control.\n\n    Args:\n        control_type: Type of control ('zoom', 'scale', 'attribution', 'layers').\n        position: Control position ('topleft', 'topright', 'bottomleft', 'bottomright').\n        **kwargs: Control-specific options.\n    \"\"\"\n    # Convert position format\n    position_map = {\n        \"top-left\": \"topleft\",\n        \"top-right\": \"topright\",\n        \"bottom-left\": \"bottomleft\",\n        \"bottom-right\": \"bottomright\",\n    }\n    pos = position_map.get(position, position)\n\n    self.call_js_method(\"addControl\", control_type, position=pos, **kwargs)\n    self._controls = {\n        **self._controls,\n        control_type: {\"type\": control_type, \"position\": pos, **kwargs},\n    }\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.leaflet.LeafletMap.add_geojson","title":"<code>add_geojson(self, data, style=None, name=None, fit_bounds=True, **kwargs)</code>","text":"<p>Add GeoJSON data to the map.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Union[str, Dict]</code> <p>GeoJSON dict or URL to GeoJSON file.</p> required <code>style</code> <code>Optional[Dict]</code> <p>Leaflet style properties.</p> <code>None</code> <code>name</code> <code>Optional[str]</code> <p>Layer name.</p> <code>None</code> <code>fit_bounds</code> <code>bool</code> <p>Whether to fit map to data bounds.</p> <code>True</code> <code>**kwargs</code> <p>Additional layer options.</p> <code>{}</code> Source code in <code>anymap_ts/leaflet.py</code> <pre><code>def add_geojson(\n    self,\n    data: Union[str, Dict],\n    style: Optional[Dict] = None,\n    name: Optional[str] = None,\n    fit_bounds: bool = True,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add GeoJSON data to the map.\n\n    Args:\n        data: GeoJSON dict or URL to GeoJSON file.\n        style: Leaflet style properties.\n        name: Layer name.\n        fit_bounds: Whether to fit map to data bounds.\n        **kwargs: Additional layer options.\n    \"\"\"\n    self.add_vector(\n        data,\n        style=style,\n        name=name,\n        fit_bounds=fit_bounds,\n        **kwargs,\n    )\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.leaflet.LeafletMap.add_layer_control","title":"<code>add_layer_control(self, position='topright', collapsed=True)</code>","text":"<p>Add a layer control for toggling layer visibility.</p> <p>Parameters:</p> Name Type Description Default <code>position</code> <code>str</code> <p>Control position.</p> <code>'topright'</code> <code>collapsed</code> <code>bool</code> <p>Whether control starts collapsed.</p> <code>True</code> Source code in <code>anymap_ts/leaflet.py</code> <pre><code>def add_layer_control(\n    self,\n    position: str = \"topright\",\n    collapsed: bool = True,\n) -&gt; None:\n    \"\"\"Add a layer control for toggling layer visibility.\n\n    Args:\n        position: Control position.\n        collapsed: Whether control starts collapsed.\n    \"\"\"\n    self.add_control(\"layers\", position=position, collapsed=collapsed)\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.leaflet.LeafletMap.add_marker","title":"<code>add_marker(self, lng, lat, popup=None, marker_id=None)</code>","text":"<p>Add a marker to the map.</p> <p>Parameters:</p> Name Type Description Default <code>lng</code> <code>float</code> <p>Longitude.</p> required <code>lat</code> <code>float</code> <p>Latitude.</p> required <code>popup</code> <code>Optional[str]</code> <p>HTML content for popup.</p> <code>None</code> <code>marker_id</code> <code>Optional[str]</code> <p>Unique marker ID.</p> <code>None</code> Source code in <code>anymap_ts/leaflet.py</code> <pre><code>def add_marker(\n    self,\n    lng: float,\n    lat: float,\n    popup: Optional[str] = None,\n    marker_id: Optional[str] = None,\n) -&gt; None:\n    \"\"\"Add a marker to the map.\n\n    Args:\n        lng: Longitude.\n        lat: Latitude.\n        popup: HTML content for popup.\n        marker_id: Unique marker ID.\n    \"\"\"\n    self.call_js_method(\"addMarker\", lng, lat, popup=popup, id=marker_id)\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.leaflet.LeafletMap.add_tile_layer","title":"<code>add_tile_layer(self, url, name=None, attribution='', min_zoom=0, max_zoom=22, opacity=1.0, **kwargs)</code>","text":"<p>Add an XYZ tile layer.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>Tile URL template with {x}, {y}, {z} placeholders.</p> required <code>name</code> <code>Optional[str]</code> <p>Layer name.</p> <code>None</code> <code>attribution</code> <code>str</code> <p>Attribution text.</p> <code>''</code> <code>min_zoom</code> <code>int</code> <p>Minimum zoom level.</p> <code>0</code> <code>max_zoom</code> <code>int</code> <p>Maximum zoom level.</p> <code>22</code> <code>opacity</code> <code>float</code> <p>Layer opacity.</p> <code>1.0</code> <code>**kwargs</code> <p>Additional options.</p> <code>{}</code> Source code in <code>anymap_ts/leaflet.py</code> <pre><code>def add_tile_layer(\n    self,\n    url: str,\n    name: Optional[str] = None,\n    attribution: str = \"\",\n    min_zoom: int = 0,\n    max_zoom: int = 22,\n    opacity: float = 1.0,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add an XYZ tile layer.\n\n    Args:\n        url: Tile URL template with {x}, {y}, {z} placeholders.\n        name: Layer name.\n        attribution: Attribution text.\n        min_zoom: Minimum zoom level.\n        max_zoom: Maximum zoom level.\n        opacity: Layer opacity.\n        **kwargs: Additional options.\n    \"\"\"\n    layer_id = name or f\"tiles-{len(self._layers)}\"\n\n    self.call_js_method(\n        \"addTileLayer\",\n        url,\n        name=layer_id,\n        attribution=attribution,\n        minZoom=min_zoom,\n        maxZoom=max_zoom,\n        opacity=opacity,\n        **kwargs,\n    )\n\n    # Track layer\n    self._layers = {\n        **self._layers,\n        layer_id: {\n            \"id\": layer_id,\n            \"type\": \"tile\",\n        },\n    }\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.leaflet.LeafletMap.add_vector","title":"<code>add_vector(self, data, style=None, name=None, fit_bounds=True, **kwargs)</code>","text":"<p>Add vector data to the map.</p> <p>Supports GeoJSON, GeoDataFrame, or file paths to vector formats.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>GeoJSON dict, GeoDataFrame, or path to vector file.</p> required <code>style</code> <code>Optional[Dict]</code> <p>Leaflet style properties.</p> <code>None</code> <code>name</code> <code>Optional[str]</code> <p>Layer name.</p> <code>None</code> <code>fit_bounds</code> <code>bool</code> <p>Whether to fit map to data bounds.</p> <code>True</code> <code>**kwargs</code> <p>Additional layer options.</p> <code>{}</code> Source code in <code>anymap_ts/leaflet.py</code> <pre><code>def add_vector(\n    self,\n    data: Any,\n    style: Optional[Dict] = None,\n    name: Optional[str] = None,\n    fit_bounds: bool = True,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add vector data to the map.\n\n    Supports GeoJSON, GeoDataFrame, or file paths to vector formats.\n\n    Args:\n        data: GeoJSON dict, GeoDataFrame, or path to vector file.\n        style: Leaflet style properties.\n        name: Layer name.\n        fit_bounds: Whether to fit map to data bounds.\n        **kwargs: Additional layer options.\n    \"\"\"\n    geojson = to_geojson(data)\n\n    # Handle URL data\n    if geojson.get(\"type\") == \"url\":\n        self.add_geojson(\n            geojson[\"url\"],\n            style=style,\n            name=name,\n            fit_bounds=fit_bounds,\n            **kwargs,\n        )\n        return\n\n    layer_id = name or f\"vector-{len(self._layers)}\"\n\n    # Get default style if not provided\n    if style is None:\n        layer_type = _infer_leaflet_type(geojson)\n        style = _get_default_style(layer_type)\n\n    # Get bounds\n    bounds = get_bounds(data) if fit_bounds else None\n\n    # Call JavaScript\n    self.call_js_method(\n        \"addGeoJSON\",\n        data=geojson,\n        name=layer_id,\n        style=style,\n        fitBounds=fit_bounds,\n        bounds=bounds,\n        **kwargs,\n    )\n\n    # Track layer\n    self._layers = {\n        **self._layers,\n        layer_id: {\n            \"id\": layer_id,\n            \"type\": \"geojson\",\n            \"style\": style,\n        },\n    }\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.leaflet.LeafletMap.remove_control","title":"<code>remove_control(self, control_type)</code>","text":"<p>Remove a map control.</p> <p>Parameters:</p> Name Type Description Default <code>control_type</code> <code>str</code> <p>Type of control to remove.</p> required Source code in <code>anymap_ts/leaflet.py</code> <pre><code>def remove_control(self, control_type: str) -&gt; None:\n    \"\"\"Remove a map control.\n\n    Args:\n        control_type: Type of control to remove.\n    \"\"\"\n    self.call_js_method(\"removeControl\", control_type)\n    if control_type in self._controls:\n        controls = dict(self._controls)\n        del controls[control_type]\n        self._controls = controls\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.leaflet.LeafletMap.remove_layer","title":"<code>remove_layer(self, layer_id)</code>","text":"<p>Remove a layer from the map.</p> <p>Parameters:</p> Name Type Description Default <code>layer_id</code> <code>str</code> <p>Layer identifier to remove.</p> required Source code in <code>anymap_ts/leaflet.py</code> <pre><code>def remove_layer(self, layer_id: str) -&gt; None:\n    \"\"\"Remove a layer from the map.\n\n    Args:\n        layer_id: Layer identifier to remove.\n    \"\"\"\n    if layer_id in self._layers:\n        layers = dict(self._layers)\n        del layers[layer_id]\n        self._layers = layers\n    self.call_js_method(\"removeLayer\", layer_id)\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.leaflet.LeafletMap.remove_marker","title":"<code>remove_marker(self, marker_id)</code>","text":"<p>Remove a marker from the map.</p> <p>Parameters:</p> Name Type Description Default <code>marker_id</code> <code>str</code> <p>Marker ID to remove.</p> required Source code in <code>anymap_ts/leaflet.py</code> <pre><code>def remove_marker(self, marker_id: str) -&gt; None:\n    \"\"\"Remove a marker from the map.\n\n    Args:\n        marker_id: Marker ID to remove.\n    \"\"\"\n    self.call_js_method(\"removeMarker\", marker_id)\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.leaflet.LeafletMap.set_opacity","title":"<code>set_opacity(self, layer_id, opacity)</code>","text":"<p>Set layer opacity.</p> <p>Parameters:</p> Name Type Description Default <code>layer_id</code> <code>str</code> <p>Layer identifier.</p> required <code>opacity</code> <code>float</code> <p>Opacity value between 0 and 1.</p> required Source code in <code>anymap_ts/leaflet.py</code> <pre><code>def set_opacity(self, layer_id: str, opacity: float) -&gt; None:\n    \"\"\"Set layer opacity.\n\n    Args:\n        layer_id: Layer identifier.\n        opacity: Opacity value between 0 and 1.\n    \"\"\"\n    self.call_js_method(\"setOpacity\", layer_id, opacity)\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.leaflet.LeafletMap.set_visibility","title":"<code>set_visibility(self, layer_id, visible)</code>","text":"<p>Set layer visibility.</p> <p>Parameters:</p> Name Type Description Default <code>layer_id</code> <code>str</code> <p>Layer identifier.</p> required <code>visible</code> <code>bool</code> <p>Whether layer should be visible.</p> required Source code in <code>anymap_ts/leaflet.py</code> <pre><code>def set_visibility(self, layer_id: str, visible: bool) -&gt; None:\n    \"\"\"Set layer visibility.\n\n    Args:\n        layer_id: Layer identifier.\n        visible: Whether layer should be visible.\n    \"\"\"\n    self.call_js_method(\"setVisibility\", layer_id, visible)\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.mapbox","title":"<code>mapbox</code>","text":"<p>Mapbox GL JS map widget implementation.</p>"},{"location":"anymap_ts/#anymap_ts.mapbox.MapboxMap","title":"<code> MapboxMap            (MapWidget)         </code>","text":"<p>Interactive map widget using Mapbox GL JS.</p> <p>This class provides a Python interface to Mapbox GL JS maps with full bidirectional communication through anywidget.</p> <p>Note</p> <p>Requires a Mapbox access token. Set via MAPBOX_TOKEN environment variable or pass directly to the constructor.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from anymap_ts import MapboxMap\n&gt;&gt;&gt; m = MapboxMap(center=[-122.4, 37.8], zoom=10)\n&gt;&gt;&gt; m.add_basemap(\"mapbox://styles/mapbox/streets-v12\")\n&gt;&gt;&gt; m\n</code></pre> Source code in <code>anymap_ts/mapbox.py</code> <pre><code>class MapboxMap(MapWidget):\n    \"\"\"Interactive map widget using Mapbox GL JS.\n\n    This class provides a Python interface to Mapbox GL JS maps with\n    full bidirectional communication through anywidget.\n\n    Note:\n        Requires a Mapbox access token. Set via MAPBOX_TOKEN environment\n        variable or pass directly to the constructor.\n\n    Example:\n        &gt;&gt;&gt; from anymap_ts import MapboxMap\n        &gt;&gt;&gt; m = MapboxMap(center=[-122.4, 37.8], zoom=10)\n        &gt;&gt;&gt; m.add_basemap(\"mapbox://styles/mapbox/streets-v12\")\n        &gt;&gt;&gt; m\n    \"\"\"\n\n    # ESM module for frontend\n    _esm = STATIC_DIR / \"mapbox.js\"\n    _css = STATIC_DIR / \"mapbox.css\"\n\n    # Mapbox-specific traits\n    access_token = traitlets.Unicode(\"\").tag(sync=True)\n    bearing = traitlets.Float(0.0).tag(sync=True)\n    pitch = traitlets.Float(0.0).tag(sync=True)\n    antialias = traitlets.Bool(True).tag(sync=True)\n    double_click_zoom = traitlets.Bool(True).tag(sync=True)\n\n    # Layer tracking\n    _layer_dict = traitlets.Dict({}).tag(sync=True)\n\n    def __init__(\n        self,\n        center: Tuple[float, float] = (0.0, 0.0),\n        zoom: float = 2.0,\n        width: str = \"100%\",\n        height: str = \"600px\",\n        style: str = \"mapbox://styles/mapbox/streets-v12\",\n        bearing: float = 0.0,\n        pitch: float = 0.0,\n        max_pitch: float = 85.0,\n        access_token: Optional[str] = None,\n        controls: Optional[Dict[str, Any]] = None,\n        **kwargs,\n    ):\n        \"\"\"Initialize a Mapbox map.\n\n        Args:\n            center: Map center as (longitude, latitude).\n            zoom: Initial zoom level.\n            width: Map width as CSS string.\n            height: Map height as CSS string.\n            style: Mapbox style URL (e.g., \"mapbox://styles/mapbox/streets-v12\").\n            bearing: Map bearing in degrees.\n            pitch: Map pitch in degrees.\n            max_pitch: Maximum pitch angle in degrees (default: 85).\n            access_token: Mapbox access token. If None, reads from MAPBOX_TOKEN env var.\n            controls: Dict of controls to add (e.g., {\"navigation\": True}).\n            **kwargs: Additional widget arguments.\n        \"\"\"\n        # Get access token\n        token = access_token or get_mapbox_token()\n        if not token:\n            print(\n                \"Warning: No Mapbox access token provided. \"\n                \"Set MAPBOX_TOKEN environment variable or pass access_token parameter.\"\n            )\n\n        super().__init__(\n            center=list(center),\n            zoom=zoom,\n            width=width,\n            height=height,\n            style=style,\n            bearing=bearing,\n            pitch=pitch,\n            max_pitch=max_pitch,\n            access_token=token,\n            **kwargs,\n        )\n\n        # Initialize layer dictionary\n        self._layer_dict = {\"Background\": []}\n\n        # Add default controls\n        if controls is None:\n            controls = {\"navigation\": True, \"fullscreen\": True}\n\n        for control_name, config in controls.items():\n            if config:\n                self.add_control(\n                    control_name, **(config if isinstance(config, dict) else {})\n                )\n\n    def set_access_token(self, token: str) -&gt; None:\n        \"\"\"Set the Mapbox access token.\n\n        Args:\n            token: Mapbox access token.\n        \"\"\"\n        self.access_token = token\n\n    # -------------------------------------------------------------------------\n    # Layer Dict Helpers\n    # -------------------------------------------------------------------------\n\n    def _add_to_layer_dict(self, layer_id: str, category: str = \"Overlays\") -&gt; None:\n        \"\"\"Add a layer to the layer dictionary for UI tracking.\"\"\"\n        layers = self._layer_dict.get(category, [])\n        if layer_id not in layers:\n            self._layer_dict = {\n                **self._layer_dict,\n                category: layers + [layer_id],\n            }\n\n    def _remove_from_layer_dict(self, layer_id: str) -&gt; None:\n        \"\"\"Remove a layer from the layer dictionary.\"\"\"\n        new_dict = {}\n        for category, layers in self._layer_dict.items():\n            if layer_id in layers:\n                new_layers = [lid for lid in layers if lid != layer_id]\n                if new_layers:\n                    new_dict[category] = new_layers\n            else:\n                new_dict[category] = layers\n        self._layer_dict = new_dict\n\n    def _validate_opacity(self, opacity: float, param_name: str = \"opacity\") -&gt; float:\n        \"\"\"Validate opacity value is between 0 and 1.\"\"\"\n        if not 0 &lt;= opacity &lt;= 1:\n            raise ValueError(f\"{param_name} must be between 0 and 1, got {opacity}\")\n        return opacity\n\n    def _validate_position(self, position: str) -&gt; str:\n        \"\"\"Validate control position is valid.\"\"\"\n        valid_positions = [\"top-left\", \"top-right\", \"bottom-left\", \"bottom-right\"]\n        if position not in valid_positions:\n            raise ValueError(\n                f\"Position must be one of: {', '.join(valid_positions)}, got '{position}'\"\n            )\n        return position\n\n    def _remove_layer_internal(self, layer_id: str, js_method: str) -&gt; None:\n        \"\"\"Internal helper to remove a layer.\"\"\"\n        if layer_id in self._layers:\n            layers = dict(self._layers)\n            del layers[layer_id]\n            self._layers = layers\n        self._remove_from_layer_dict(layer_id)\n        self.call_js_method(js_method, layer_id)\n\n    # -------------------------------------------------------------------------\n    # Basemap Methods\n    # -------------------------------------------------------------------------\n\n    def add_basemap(\n        self,\n        basemap: str = \"mapbox://styles/mapbox/streets-v12\",\n        attribution: Optional[str] = None,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a basemap layer.\n\n        For Mapbox styles, use the style URL format:\n        - \"mapbox://styles/mapbox/streets-v12\"\n        - \"mapbox://styles/mapbox/satellite-v9\"\n        - \"mapbox://styles/mapbox/satellite-streets-v12\"\n        - \"mapbox://styles/mapbox/light-v11\"\n        - \"mapbox://styles/mapbox/dark-v11\"\n        - \"mapbox://styles/mapbox/outdoors-v12\"\n\n        Or use XYZ tile URLs for custom basemaps.\n\n        Args:\n            basemap: Mapbox style URL or XYZ tile URL.\n            attribution: Custom attribution text.\n            **kwargs: Additional options.\n        \"\"\"\n        # If it's a Mapbox style URL, set it as the map style\n        if basemap.startswith(\"mapbox://\"):\n            self.style = basemap\n            return\n\n        # Otherwise, treat as XYZ tile URL\n        try:\n            url, default_attribution = get_basemap_url(basemap)\n        except (ValueError, KeyError):\n            url = basemap\n            default_attribution = \"\"\n\n        self.call_js_method(\n            \"addBasemap\",\n            url,\n            attribution=attribution or default_attribution,\n            name=basemap,\n            **kwargs,\n        )\n\n        # Track in layer dict\n        basemaps = self._layer_dict.get(\"Basemaps\", [])\n        if basemap not in basemaps:\n            self._layer_dict = {\n                **self._layer_dict,\n                \"Basemaps\": basemaps + [basemap],\n            }\n\n    # -------------------------------------------------------------------------\n    # Vector Data Methods\n    # -------------------------------------------------------------------------\n\n    def add_vector(\n        self,\n        data: Any,\n        layer_type: Optional[str] = None,\n        paint: Optional[Dict] = None,\n        name: Optional[str] = None,\n        fit_bounds: bool = True,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add vector data to the map.\n\n        Supports GeoJSON, GeoDataFrame, or file paths to vector formats.\n\n        Args:\n            data: GeoJSON dict, GeoDataFrame, or path to vector file.\n            layer_type: Mapbox layer type ('circle', 'line', 'fill', 'symbol').\n            paint: Mapbox paint properties.\n            name: Layer name.\n            fit_bounds: Whether to fit map to data bounds.\n            **kwargs: Additional layer options.\n        \"\"\"\n        geojson = to_geojson(data)\n\n        layer_id = name or f\"vector-{len(self._layers)}\"\n\n        # Handle URL data - fetch GeoJSON to get bounds and infer layer type\n        if geojson.get(\"type\") == \"url\":\n            url = geojson[\"url\"]\n            geojson = fetch_geojson(url)\n\n        # Infer layer type if not specified\n        if layer_type is None:\n            layer_type = infer_layer_type(geojson)\n\n        # Get default paint if not provided\n        if paint is None:\n            paint = get_default_paint(layer_type)\n\n        # Get bounds (use geojson dict, not original data which may be a URL)\n        bounds = get_bounds(geojson) if fit_bounds else None\n\n        # Call JavaScript\n        self.call_js_method(\n            \"addGeoJSON\",\n            data=geojson,\n            name=layer_id,\n            layerType=layer_type,\n            paint=paint,\n            fitBounds=fit_bounds,\n            bounds=bounds,\n            **kwargs,\n        )\n\n        # Track layer\n        self._layers = {\n            **self._layers,\n            layer_id: {\n                \"id\": layer_id,\n                \"type\": layer_type,\n                \"source\": f\"{layer_id}-source\",\n                \"paint\": paint,\n            },\n        }\n        self._add_to_layer_dict(layer_id, \"Vector\")\n\n    def add_geojson(\n        self,\n        data: Union[str, Dict],\n        layer_type: Optional[str] = None,\n        paint: Optional[Dict] = None,\n        name: Optional[str] = None,\n        fit_bounds: bool = True,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add GeoJSON data to the map.\n\n        Args:\n            data: GeoJSON dict or URL to GeoJSON file.\n            layer_type: Mapbox layer type.\n            paint: Mapbox paint properties.\n            name: Layer name.\n            fit_bounds: Whether to fit map to data bounds.\n            **kwargs: Additional layer options.\n        \"\"\"\n        self.add_vector(\n            data,\n            layer_type=layer_type,\n            paint=paint,\n            name=name,\n            fit_bounds=fit_bounds,\n            **kwargs,\n        )\n\n    # -------------------------------------------------------------------------\n    # Raster Data Methods\n    # -------------------------------------------------------------------------\n\n    def add_tile_layer(\n        self,\n        url: str,\n        name: Optional[str] = None,\n        attribution: str = \"\",\n        min_zoom: int = 0,\n        max_zoom: int = 22,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add an XYZ tile layer.\n\n        Args:\n            url: Tile URL template with {x}, {y}, {z} placeholders.\n            name: Layer name.\n            attribution: Attribution text.\n            min_zoom: Minimum zoom level.\n            max_zoom: Maximum zoom level.\n            **kwargs: Additional options.\n        \"\"\"\n        layer_id = name or f\"tiles-{len(self._layers)}\"\n\n        self.call_js_method(\n            \"addTileLayer\",\n            url,\n            name=layer_id,\n            attribution=attribution,\n            minZoom=min_zoom,\n            maxZoom=max_zoom,\n            **kwargs,\n        )\n\n        # Track layer\n        self._layers = {\n            **self._layers,\n            layer_id: {\n                \"id\": layer_id,\n                \"type\": \"raster\",\n                \"source\": f\"{layer_id}-source\",\n            },\n        }\n        self._add_to_layer_dict(layer_id, \"Raster\")\n\n    def add_raster(\n        self,\n        source: str,\n        name: Optional[str] = None,\n        attribution: str = \"\",\n        indexes: Optional[List[int]] = None,\n        colormap: Optional[str] = None,\n        vmin: Optional[float] = None,\n        vmax: Optional[float] = None,\n        nodata: Optional[float] = None,\n        fit_bounds: bool = True,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a raster layer from a local file using localtileserver.\"\"\"\n        try:\n            from localtileserver import TileClient\n        except ImportError:\n            raise ImportError(\n                \"localtileserver is required for local raster support. \"\n                \"Install with: pip install anymap-ts[raster]\"\n            )\n\n        client = TileClient(source)\n\n        tile_params = {}\n        if indexes:\n            tile_params[\"indexes\"] = indexes\n        if colormap:\n            tile_params[\"colormap\"] = colormap\n        if vmin is not None or vmax is not None:\n            tile_params[\"vmin\"] = vmin if vmin is not None else client.min\n            tile_params[\"vmax\"] = vmax if vmax is not None else client.max\n        if nodata is not None:\n            tile_params[\"nodata\"] = nodata\n\n        tile_url = client.get_tile_url(**tile_params)\n\n        layer_name = name or Path(source).stem\n\n        self.add_tile_layer(\n            tile_url,\n            name=layer_name,\n            attribution=attribution,\n            **kwargs,\n        )\n\n        if fit_bounds:\n            bounds = client.bounds()\n            if bounds:\n                self.fit_bounds([bounds[0], bounds[1], bounds[2], bounds[3]])\n\n    def add_stac_layer(\n        self,\n        url: Optional[str] = None,\n        item: Optional[Any] = None,\n        assets: Optional[List[str]] = None,\n        colormap: Optional[str] = None,\n        rescale: Optional[List[float]] = None,\n        opacity: float = 1.0,\n        layer_id: Optional[str] = None,\n        titiler_endpoint: str = \"https://titiler.xyz\",\n        attribution: str = \"STAC\",\n        fit_bounds: bool = True,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a STAC (SpatioTemporal Asset Catalog) layer to the map.\"\"\"\n        if url is None and item is None:\n            raise ValueError(\"Either 'url' or 'item' must be provided\")\n\n        if url is not None and item is not None:\n            raise ValueError(\"Provide either 'url' or 'item', not both\")\n\n        if item is not None:\n            try:\n                if hasattr(item, \"to_dict\") and hasattr(item, \"self_href\"):\n                    stac_url = item.self_href\n                    if not stac_url and hasattr(item, \"links\"):\n                        for link in item.links:\n                            if link.rel == \"self\":\n                                stac_url = link.href\n                                break\n                    if not stac_url:\n                        raise ValueError(\"STAC item must have a self_href or self link\")\n                else:\n                    raise ValueError(\n                        \"Item must be a pystac Item object with to_dict() and self_href\"\n                    )\n            except Exception as e:\n                raise ValueError(f\"Invalid STAC item: {e}\")\n        else:\n            stac_url = url\n\n        tile_params = {\"url\": stac_url}\n        if assets:\n            tile_params[\"assets\"] = \",\".join(assets)\n        if colormap:\n            tile_params[\"colormap_name\"] = colormap\n        if rescale:\n            if len(rescale) == 2:\n                tile_params[\"rescale\"] = f\"{rescale[0]},{rescale[1]}\"\n            else:\n                raise ValueError(\"rescale must be a list of two values [min, max]\")\n\n        query_string = urlencode(tile_params)\n        tile_url = f\"{titiler_endpoint.rstrip('/')}/stac/tiles/{{z}}/{{x}}/{{y}}?{query_string}\"\n\n        layer_name = layer_id or f\"stac-{len(self._layers)}\"\n\n        self.add_tile_layer(\n            url=tile_url,\n            name=layer_name,\n            attribution=attribution,\n            **kwargs,\n        )\n\n        if fit_bounds and item is not None:\n            try:\n                bbox = item.bbox\n                if bbox and len(bbox) == 4:\n                    self.fit_bounds([[bbox[0], bbox[1]], [bbox[2], bbox[3]]])\n            except Exception:\n                pass\n\n    # -------------------------------------------------------------------------\n    # COG Layer (deck.gl)\n    # -------------------------------------------------------------------------\n\n    def add_heatmap(\n        self,\n        data: Any,\n        weight_property: Optional[str] = None,\n        radius: int = 20,\n        intensity: float = 1.0,\n        colormap: Optional[List] = None,\n        opacity: float = 0.8,\n        name: Optional[str] = None,\n        fit_bounds: bool = True,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a heatmap layer to the map.\"\"\"\n        self._validate_opacity(opacity)\n        layer_id = name or f\"heatmap-{len(self._layers)}\"\n\n        geojson = to_geojson(data)\n\n        if geojson.get(\"type\") == \"url\":\n            url = geojson[\"url\"]\n            geojson = fetch_geojson(url)\n\n        if colormap is None:\n            colormap = [\n                [0, \"rgba(33,102,172,0)\"],\n                [0.2, \"rgb(103,169,207)\"],\n                [0.4, \"rgb(209,229,240)\"],\n                [0.6, \"rgb(253,219,199)\"],\n                [0.8, \"rgb(239,138,98)\"],\n                [1, \"rgb(178,24,43)\"],\n            ]\n\n        paint = {\n            \"heatmap-radius\": radius,\n            \"heatmap-intensity\": intensity,\n            \"heatmap-opacity\": opacity,\n            \"heatmap-color\": [\n                \"interpolate\",\n                [\"linear\"],\n                [\"heatmap-density\"],\n            ],\n        }\n\n        for stop, color in colormap:\n            paint[\"heatmap-color\"].extend([stop, color])\n\n        if weight_property:\n            paint[\"heatmap-weight\"] = [\"get\", weight_property]\n\n        bounds = get_bounds(geojson) if fit_bounds else None\n\n        self.call_js_method(\n            \"addGeoJSON\",\n            data=geojson,\n            name=layer_id,\n            layerType=\"heatmap\",\n            paint=paint,\n            fitBounds=fit_bounds,\n            bounds=bounds,\n            **kwargs,\n        )\n\n        self._layers = {\n            **self._layers,\n            layer_id: {\n                \"id\": layer_id,\n                \"type\": \"heatmap\",\n                \"source\": f\"{layer_id}-source\",\n                \"paint\": paint,\n            },\n        }\n        self._add_to_layer_dict(layer_id, \"Heatmap\")\n\n    def add_cog_layer(\n        self,\n        url: str,\n        name: Optional[str] = None,\n        opacity: float = 1.0,\n        visible: bool = True,\n        debug: bool = False,\n        debug_opacity: float = 0.25,\n        max_error: float = 0.125,\n        fit_bounds: bool = True,\n        before_id: Optional[str] = None,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a Cloud Optimized GeoTIFF (COG) layer using deck.gl-raster.\n\n        This method renders COG files directly in the browser using GPU-accelerated\n        deck.gl rendering with automatic reprojection support.\n\n        Args:\n            url: URL to the Cloud Optimized GeoTIFF file.\n            name: Layer ID. If None, auto-generated.\n            opacity: Layer opacity (0-1).\n            visible: Whether layer is visible.\n            debug: Show reprojection mesh for debugging.\n            debug_opacity: Opacity of debug mesh (0-1).\n            max_error: Maximum reprojection error in pixels. Lower values\n                create denser mesh for better accuracy.\n            fit_bounds: Whether to fit map to COG bounds after loading.\n            before_id: ID of layer to insert before.\n            **kwargs: Additional COGLayer props.\n\n        Example:\n            &gt;&gt;&gt; from anymap_ts import MapboxMap\n            &gt;&gt;&gt; m = MapboxMap()\n            &gt;&gt;&gt; m.add_cog_layer(\n            ...     \"https://example.com/landcover.tif\",\n            ...     name=\"landcover\",\n            ...     opacity=0.8\n            ... )\n        \"\"\"\n        layer_id = name or f\"cog-{len(self._layers)}\"\n\n        self.call_js_method(\n            \"addCOGLayer\",\n            id=layer_id,\n            geotiff=url,\n            opacity=opacity,\n            visible=visible,\n            debug=debug,\n            debugOpacity=debug_opacity,\n            maxError=max_error,\n            fitBounds=fit_bounds,\n            beforeId=before_id,\n            **kwargs,\n        )\n\n        self._layers = {\n            **self._layers,\n            layer_id: {\n                \"id\": layer_id,\n                \"type\": \"cog\",\n                \"url\": url,\n            },\n        }\n        self._add_to_layer_dict(layer_id, \"Raster\")\n\n    def remove_cog_layer(self, layer_id: str) -&gt; None:\n        \"\"\"Remove a COG layer.\"\"\"\n        self._remove_layer_internal(layer_id, \"removeCOGLayer\")\n\n    def add_zarr_layer(\n        self,\n        url: str,\n        variable: str,\n        name: Optional[str] = None,\n        colormap: Optional[List[str]] = None,\n        clim: Optional[Tuple[float, float]] = None,\n        opacity: float = 1.0,\n        selector: Optional[Dict[str, Any]] = None,\n        minzoom: int = 0,\n        maxzoom: int = 22,\n        fill_value: Optional[float] = None,\n        spatial_dimensions: Optional[Dict[str, str]] = None,\n        zarr_version: Optional[int] = None,\n        bounds: Optional[List[float]] = None,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a Zarr dataset layer for visualizing multidimensional array data.\"\"\"\n        layer_id = name or f\"zarr-{len(self._layers)}\"\n\n        self.call_js_method(\n            \"addZarrLayer\",\n            id=layer_id,\n            source=url,\n            variable=variable,\n            colormap=colormap or [\"#000000\", \"#ffffff\"],\n            clim=list(clim) if clim else [0, 100],\n            opacity=opacity,\n            selector=selector or {},\n            minzoom=minzoom,\n            maxzoom=maxzoom,\n            fillValue=fill_value,\n            spatialDimensions=spatial_dimensions,\n            zarrVersion=zarr_version,\n            bounds=bounds,\n            **kwargs,\n        )\n\n        self._layers = {\n            **self._layers,\n            layer_id: {\n                \"id\": layer_id,\n                \"type\": \"zarr\",\n                \"url\": url,\n                \"variable\": variable,\n            },\n        }\n        self._add_to_layer_dict(layer_id, \"Raster\")\n\n    def remove_zarr_layer(self, layer_id: str) -&gt; None:\n        \"\"\"Remove a Zarr layer.\"\"\"\n        self._remove_layer_internal(layer_id, \"removeZarrLayer\")\n\n    def update_zarr_layer(\n        self,\n        layer_id: str,\n        selector: Optional[Dict[str, Any]] = None,\n        clim: Optional[Tuple[float, float]] = None,\n        colormap: Optional[List[str]] = None,\n        opacity: Optional[float] = None,\n    ) -&gt; None:\n        \"\"\"Update a Zarr layer's properties dynamically.\"\"\"\n        update_kwargs: Dict[str, Any] = {\"id\": layer_id}\n        if selector is not None:\n            update_kwargs[\"selector\"] = selector\n        if clim is not None:\n            update_kwargs[\"clim\"] = list(clim)\n        if colormap is not None:\n            update_kwargs[\"colormap\"] = colormap\n        if opacity is not None:\n            update_kwargs[\"opacity\"] = opacity\n        self.call_js_method(\"updateZarrLayer\", **update_kwargs)\n\n    def add_pmtiles_layer(\n        self,\n        url: str,\n        layer_id: Optional[str] = None,\n        style: Optional[Dict[str, Any]] = None,\n        opacity: float = 1.0,\n        visible: bool = True,\n        fit_bounds: bool = False,\n        source_type: str = \"vector\",\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a PMTiles layer for efficient vector or raster tile serving.\"\"\"\n        layer_id = layer_id or f\"pmtiles-{len(self._layers)}\"\n\n        self.call_js_method(\n            \"addPMTilesLayer\",\n            url=url,\n            id=layer_id,\n            style=style or {},\n            opacity=opacity,\n            visible=visible,\n            fitBounds=fit_bounds,\n            sourceType=source_type,\n            name=layer_id,\n            **kwargs,\n        )\n\n        self._layers = {\n            **self._layers,\n            layer_id: {\n                \"id\": layer_id,\n                \"type\": \"pmtiles\",\n                \"url\": url,\n                \"source_type\": source_type,\n            },\n        }\n        category = \"Vector\" if source_type == \"vector\" else \"Raster\"\n        self._add_to_layer_dict(layer_id, category)\n\n    def remove_pmtiles_layer(self, layer_id: str) -&gt; None:\n        \"\"\"Remove a PMTiles layer.\"\"\"\n        self._remove_layer_internal(layer_id, \"removePMTilesLayer\")\n\n    # -------------------------------------------------------------------------\n    # Arc Layer (deck.gl)\n    # -------------------------------------------------------------------------\n\n    def add_arc_layer(\n        self,\n        data: Any,\n        name: Optional[str] = None,\n        get_source_position: Union[str, Any] = \"source\",\n        get_target_position: Union[str, Any] = \"target\",\n        get_source_color: Optional[List[int]] = None,\n        get_target_color: Optional[List[int]] = None,\n        get_width: Union[float, str] = 1,\n        get_height: float = 1,\n        great_circle: bool = False,\n        pickable: bool = True,\n        opacity: float = 0.8,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add an arc layer for origin-destination visualization using deck.gl.\n\n        Arc layers are ideal for visualizing connections between locations,\n        such as flight routes, migration patterns, or network flows.\n\n        Args:\n            data: Array of data objects with source/target coordinates.\n                Each object should have source and target positions.\n            name: Layer ID. If None, auto-generated.\n            get_source_position: Accessor for source position [lng, lat].\n                Can be a string (property name) or a value.\n            get_target_position: Accessor for target position [lng, lat].\n                Can be a string (property name) or a value.\n            get_source_color: Source end color as [r, g, b, a].\n                Default: [51, 136, 255, 255] (blue).\n            get_target_color: Target end color as [r, g, b, a].\n                Default: [255, 136, 51, 255] (orange).\n            get_width: Arc width in pixels. Can be a number or accessor.\n            get_height: Arc height multiplier. Higher values create more curved arcs.\n            great_circle: Whether to draw arcs along great circles.\n            pickable: Whether layer responds to hover/click events.\n            opacity: Layer opacity (0-1).\n            **kwargs: Additional ArcLayer props.\n\n        Example:\n            &gt;&gt;&gt; from anymap_ts import MapboxMap\n            &gt;&gt;&gt; m = MapboxMap()\n            &gt;&gt;&gt; arcs = [\n            ...     {\"source\": [-122.4, 37.8], \"target\": [-73.9, 40.7]},\n            ...     {\"source\": [-122.4, 37.8], \"target\": [-0.1, 51.5]},\n            ... ]\n            &gt;&gt;&gt; m.add_arc_layer(arcs, name=\"flights\")\n        \"\"\"\n        layer_id = name or f\"arc-{len(self._layers)}\"\n        processed_data = self._process_deck_data(data)\n\n        self.call_js_method(\n            \"addArcLayer\",\n            id=layer_id,\n            data=processed_data,\n            getSourcePosition=get_source_position,\n            getTargetPosition=get_target_position,\n            getSourceColor=get_source_color or [51, 136, 255, 255],\n            getTargetColor=get_target_color or [255, 136, 51, 255],\n            getWidth=get_width,\n            getHeight=get_height,\n            greatCircle=great_circle,\n            pickable=pickable,\n            opacity=opacity,\n            **kwargs,\n        )\n\n        self._layers = {\n            **self._layers,\n            layer_id: {\n                \"id\": layer_id,\n                \"type\": \"arc\",\n            },\n        }\n        self._add_to_layer_dict(layer_id, \"Deck.gl\")\n\n    def remove_arc_layer(self, layer_id: str) -&gt; None:\n        \"\"\"Remove an arc layer.\"\"\"\n        self._remove_layer_internal(layer_id, \"removeArcLayer\")\n\n    # -------------------------------------------------------------------------\n    # PointCloud Layer (deck.gl)\n    # -------------------------------------------------------------------------\n\n    def add_point_cloud_layer(\n        self,\n        data: Any,\n        name: Optional[str] = None,\n        get_position: Union[str, Any] = \"position\",\n        get_color: Optional[Union[List[int], str]] = None,\n        get_normal: Optional[Union[str, Any]] = None,\n        point_size: float = 2,\n        size_units: str = \"pixels\",\n        pickable: bool = True,\n        opacity: float = 1.0,\n        material: bool = True,\n        coordinate_system: Optional[int] = None,\n        coordinate_origin: Optional[List[float]] = None,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a point cloud layer for 3D point visualization using deck.gl.\n\n        Point cloud layers render large collections of 3D points, ideal for\n        LiDAR data, photogrammetry outputs, or any 3D point dataset.\n\n        Args:\n            data: Array of point data with positions. Each point should have\n                x, y, z coordinates (or position array).\n            name: Layer ID. If None, auto-generated.\n            get_position: Accessor for point position [x, y, z].\n                Can be a string (property name) or a value.\n            get_color: Accessor or value for point color [r, g, b, a].\n                Default: [255, 255, 255, 255] (white).\n            get_normal: Accessor for point normal [nx, ny, nz] for lighting.\n                Default: [0, 0, 1] (pointing up).\n            point_size: Point size in pixels or meters (depends on size_units).\n            size_units: Size units: 'pixels', 'meters', or 'common'.\n            pickable: Whether layer responds to hover/click events.\n            opacity: Layer opacity (0-1).\n            material: Whether to enable lighting effects.\n            coordinate_system: Coordinate system for positions.\n            coordinate_origin: Origin for coordinate system [x, y, z].\n            **kwargs: Additional PointCloudLayer props.\n\n        Example:\n            &gt;&gt;&gt; from anymap_ts import MapboxMap\n            &gt;&gt;&gt; m = MapboxMap(pitch=45)\n            &gt;&gt;&gt; points = [\n            ...     {\"position\": [-122.4, 37.8, 100], \"color\": [255, 0, 0, 255]},\n            ...     {\"position\": [-122.3, 37.7, 200], \"color\": [0, 255, 0, 255]},\n            ... ]\n            &gt;&gt;&gt; m.add_point_cloud_layer(points, point_size=5)\n        \"\"\"\n        layer_id = name or f\"pointcloud-{len(self._layers)}\"\n        processed_data = self._process_deck_data(data)\n\n        self.call_js_method(\n            \"addPointCloudLayer\",\n            id=layer_id,\n            data=processed_data,\n            getPosition=get_position,\n            getColor=get_color or [255, 255, 255, 255],\n            getNormal=get_normal,\n            pointSize=point_size,\n            sizeUnits=size_units,\n            pickable=pickable,\n            opacity=opacity,\n            material=material,\n            coordinateSystem=coordinate_system,\n            coordinateOrigin=coordinate_origin,\n            **kwargs,\n        )\n\n        self._layers = {\n            **self._layers,\n            layer_id: {\n                \"id\": layer_id,\n                \"type\": \"pointcloud\",\n            },\n        }\n        self._add_to_layer_dict(layer_id, \"Deck.gl\")\n\n    def remove_point_cloud_layer(self, layer_id: str) -&gt; None:\n        \"\"\"Remove a point cloud layer.\"\"\"\n        self._remove_layer_internal(layer_id, \"removePointCloudLayer\")\n\n    def add_scatterplot_layer(\n        self,\n        data: Any,\n        name: Optional[str] = None,\n        get_position: Union[str, Any] = \"coordinates\",\n        get_radius: Union[float, str] = 5,\n        get_fill_color: Optional[Union[List[int], str]] = None,\n        get_line_color: Optional[Union[List[int], str]] = None,\n        radius_scale: float = 1,\n        radius_min_pixels: float = 1,\n        radius_max_pixels: float = 100,\n        line_width_min_pixels: float = 1,\n        stroked: bool = True,\n        filled: bool = True,\n        pickable: bool = True,\n        opacity: float = 0.8,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a scatterplot layer using deck.gl.\"\"\"\n        layer_id = name or f\"scatterplot-{len(self._layers)}\"\n        processed_data = self._process_deck_data(data)\n\n        self.call_js_method(\n            \"addScatterplotLayer\",\n            id=layer_id,\n            data=processed_data,\n            getPosition=get_position,\n            getRadius=get_radius,\n            getFillColor=get_fill_color or [51, 136, 255, 200],\n            getLineColor=get_line_color or [255, 255, 255, 255],\n            radiusScale=radius_scale,\n            radiusMinPixels=radius_min_pixels,\n            radiusMaxPixels=radius_max_pixels,\n            lineWidthMinPixels=line_width_min_pixels,\n            stroked=stroked,\n            filled=filled,\n            pickable=pickable,\n            opacity=opacity,\n            **kwargs,\n        )\n\n        self._layers = {\n            **self._layers,\n            layer_id: {\"id\": layer_id, \"type\": \"scatterplot\"},\n        }\n        self._add_to_layer_dict(layer_id, \"Deck.gl\")\n\n    def add_path_layer(\n        self,\n        data: Any,\n        name: Optional[str] = None,\n        get_path: Union[str, Any] = \"path\",\n        get_color: Optional[Union[List[int], str]] = None,\n        get_width: Union[float, str] = 1,\n        width_scale: float = 1,\n        width_min_pixels: float = 1,\n        pickable: bool = True,\n        opacity: float = 0.8,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a path layer using deck.gl.\"\"\"\n        layer_id = name or f\"path-{len(self._layers)}\"\n        processed_data = self._process_deck_data(data)\n\n        self.call_js_method(\n            \"addPathLayer\",\n            id=layer_id,\n            data=processed_data,\n            getPath=get_path,\n            getColor=get_color or [51, 136, 255, 200],\n            getWidth=get_width,\n            widthScale=width_scale,\n            widthMinPixels=width_min_pixels,\n            pickable=pickable,\n            opacity=opacity,\n            **kwargs,\n        )\n\n        self._layers = {**self._layers, layer_id: {\"id\": layer_id, \"type\": \"path\"}}\n        self._add_to_layer_dict(layer_id, \"Deck.gl\")\n\n    def add_polygon_layer(\n        self,\n        data: Any,\n        name: Optional[str] = None,\n        get_polygon: Union[str, Any] = \"polygon\",\n        get_fill_color: Optional[Union[List[int], str]] = None,\n        get_line_color: Optional[Union[List[int], str]] = None,\n        get_line_width: Union[float, str] = 1,\n        get_elevation: Union[float, str] = 0,\n        extruded: bool = False,\n        wireframe: bool = False,\n        filled: bool = True,\n        stroked: bool = True,\n        line_width_min_pixels: float = 1,\n        pickable: bool = True,\n        opacity: float = 0.5,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a polygon layer using deck.gl.\"\"\"\n        layer_id = name or f\"polygon-{len(self._layers)}\"\n        processed_data = self._process_deck_data(data)\n\n        self.call_js_method(\n            \"addPolygonLayer\",\n            id=layer_id,\n            data=processed_data,\n            getPolygon=get_polygon,\n            getFillColor=get_fill_color or [51, 136, 255, 128],\n            getLineColor=get_line_color or [0, 0, 255, 255],\n            getLineWidth=get_line_width,\n            getElevation=get_elevation,\n            extruded=extruded,\n            wireframe=wireframe,\n            filled=filled,\n            stroked=stroked,\n            lineWidthMinPixels=line_width_min_pixels,\n            pickable=pickable,\n            opacity=opacity,\n            **kwargs,\n        )\n\n        self._layers = {**self._layers, layer_id: {\"id\": layer_id, \"type\": \"polygon\"}}\n        self._add_to_layer_dict(layer_id, \"Deck.gl\")\n\n    def add_hexagon_layer(\n        self,\n        data: Any,\n        name: Optional[str] = None,\n        get_position: Union[str, Any] = \"coordinates\",\n        radius: float = 1000,\n        elevation_scale: float = 4,\n        extruded: bool = True,\n        color_range: Optional[List[List[int]]] = None,\n        pickable: bool = True,\n        opacity: float = 0.8,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a hexagon layer using deck.gl.\"\"\"\n        layer_id = name or f\"hexagon-{len(self._layers)}\"\n        processed_data = self._process_deck_data(data)\n\n        default_color_range = [\n            [1, 152, 189],\n            [73, 227, 206],\n            [216, 254, 181],\n            [254, 237, 177],\n            [254, 173, 84],\n            [209, 55, 78],\n        ]\n\n        self.call_js_method(\n            \"addHexagonLayer\",\n            id=layer_id,\n            data=processed_data,\n            getPosition=get_position,\n            radius=radius,\n            elevationScale=elevation_scale,\n            extruded=extruded,\n            colorRange=color_range or default_color_range,\n            pickable=pickable,\n            opacity=opacity,\n            **kwargs,\n        )\n\n        self._layers = {**self._layers, layer_id: {\"id\": layer_id, \"type\": \"hexagon\"}}\n        self._add_to_layer_dict(layer_id, \"Deck.gl\")\n\n    def add_deck_heatmap_layer(\n        self,\n        data: Any,\n        name: Optional[str] = None,\n        get_position: Union[str, Any] = \"coordinates\",\n        get_weight: Union[float, str] = 1,\n        radius_pixels: float = 30,\n        intensity: float = 1,\n        threshold: float = 0.05,\n        color_range: Optional[List[List[int]]] = None,\n        opacity: float = 1,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a GPU-accelerated heatmap layer using deck.gl.\"\"\"\n        layer_id = name or f\"deck-heatmap-{len(self._layers)}\"\n        processed_data = self._process_deck_data(data)\n\n        default_color_range = [\n            [255, 255, 178, 25],\n            [254, 217, 118, 85],\n            [254, 178, 76, 127],\n            [253, 141, 60, 170],\n            [240, 59, 32, 212],\n            [189, 0, 38, 255],\n        ]\n\n        self.call_js_method(\n            \"addHeatmapLayer\",\n            id=layer_id,\n            data=processed_data,\n            getPosition=get_position,\n            getWeight=get_weight,\n            radiusPixels=radius_pixels,\n            intensity=intensity,\n            threshold=threshold,\n            colorRange=color_range or default_color_range,\n            opacity=opacity,\n            **kwargs,\n        )\n\n        self._layers = {\n            **self._layers,\n            layer_id: {\"id\": layer_id, \"type\": \"deck-heatmap\"},\n        }\n        self._add_to_layer_dict(layer_id, \"Deck.gl\")\n\n    def add_grid_layer(\n        self,\n        data: Any,\n        name: Optional[str] = None,\n        get_position: Union[str, Any] = \"coordinates\",\n        cell_size: float = 200,\n        elevation_scale: float = 4,\n        extruded: bool = True,\n        color_range: Optional[List[List[int]]] = None,\n        pickable: bool = True,\n        opacity: float = 0.8,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a grid layer using deck.gl.\"\"\"\n        layer_id = name or f\"grid-{len(self._layers)}\"\n        processed_data = self._process_deck_data(data)\n\n        default_color_range = [\n            [1, 152, 189],\n            [73, 227, 206],\n            [216, 254, 181],\n            [254, 237, 177],\n            [254, 173, 84],\n            [209, 55, 78],\n        ]\n\n        self.call_js_method(\n            \"addGridLayer\",\n            id=layer_id,\n            data=processed_data,\n            getPosition=get_position,\n            cellSize=cell_size,\n            elevationScale=elevation_scale,\n            extruded=extruded,\n            colorRange=color_range or default_color_range,\n            pickable=pickable,\n            opacity=opacity,\n            **kwargs,\n        )\n\n        self._layers = {**self._layers, layer_id: {\"id\": layer_id, \"type\": \"grid\"}}\n        self._add_to_layer_dict(layer_id, \"Deck.gl\")\n\n    def add_icon_layer(\n        self,\n        data: Any,\n        name: Optional[str] = None,\n        get_position: Union[str, Any] = \"coordinates\",\n        get_icon: Union[str, Any] = \"icon\",\n        get_size: Union[float, str] = 20,\n        get_color: Optional[Union[List[int], str]] = None,\n        icon_atlas: Optional[str] = None,\n        icon_mapping: Optional[Dict] = None,\n        pickable: bool = True,\n        opacity: float = 1,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add an icon layer using deck.gl.\"\"\"\n        layer_id = name or f\"icon-{len(self._layers)}\"\n        processed_data = self._process_deck_data(data)\n\n        self.call_js_method(\n            \"addIconLayer\",\n            id=layer_id,\n            data=processed_data,\n            getPosition=get_position,\n            getIcon=get_icon,\n            getSize=get_size,\n            getColor=get_color or [255, 255, 255, 255],\n            iconAtlas=icon_atlas,\n            iconMapping=icon_mapping,\n            pickable=pickable,\n            opacity=opacity,\n            **kwargs,\n        )\n\n        self._layers = {**self._layers, layer_id: {\"id\": layer_id, \"type\": \"icon\"}}\n        self._add_to_layer_dict(layer_id, \"Deck.gl\")\n\n    def add_text_layer(\n        self,\n        data: Any,\n        name: Optional[str] = None,\n        get_position: Union[str, Any] = \"coordinates\",\n        get_text: Union[str, Any] = \"text\",\n        get_size: Union[float, str] = 12,\n        get_color: Optional[Union[List[int], str]] = None,\n        get_angle: Union[float, str] = 0,\n        text_anchor: str = \"middle\",\n        alignment_baseline: str = \"center\",\n        pickable: bool = True,\n        opacity: float = 1,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a text layer using deck.gl.\"\"\"\n        layer_id = name or f\"text-{len(self._layers)}\"\n        processed_data = self._process_deck_data(data)\n\n        self.call_js_method(\n            \"addTextLayer\",\n            id=layer_id,\n            data=processed_data,\n            getPosition=get_position,\n            getText=get_text,\n            getSize=get_size,\n            getColor=get_color or [0, 0, 0, 255],\n            getAngle=get_angle,\n            getTextAnchor=text_anchor,\n            getAlignmentBaseline=alignment_baseline,\n            pickable=pickable,\n            opacity=opacity,\n            **kwargs,\n        )\n\n        self._layers = {**self._layers, layer_id: {\"id\": layer_id, \"type\": \"text\"}}\n        self._add_to_layer_dict(layer_id, \"Deck.gl\")\n\n    def add_geojson_layer(\n        self,\n        data: Any,\n        name: Optional[str] = None,\n        get_fill_color: Optional[Union[List[int], str]] = None,\n        get_line_color: Optional[Union[List[int], str]] = None,\n        get_line_width: Union[float, str] = 1,\n        get_point_radius: Union[float, str] = 5,\n        get_elevation: Union[float, str] = 0,\n        extruded: bool = False,\n        wireframe: bool = False,\n        filled: bool = True,\n        stroked: bool = True,\n        line_width_min_pixels: float = 1,\n        point_radius_min_pixels: float = 2,\n        pickable: bool = True,\n        opacity: float = 0.8,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a GeoJSON layer with auto-styling using deck.gl.\"\"\"\n        layer_id = name or f\"geojson-deck-{len(self._layers)}\"\n        processed_data = self._process_deck_data(data)\n\n        self.call_js_method(\n            \"addGeoJsonLayer\",\n            id=layer_id,\n            data=processed_data,\n            getFillColor=get_fill_color or [51, 136, 255, 128],\n            getLineColor=get_line_color or [0, 0, 0, 255],\n            getLineWidth=get_line_width,\n            getPointRadius=get_point_radius,\n            getElevation=get_elevation,\n            extruded=extruded,\n            wireframe=wireframe,\n            filled=filled,\n            stroked=stroked,\n            lineWidthMinPixels=line_width_min_pixels,\n            pointRadiusMinPixels=point_radius_min_pixels,\n            pickable=pickable,\n            opacity=opacity,\n            **kwargs,\n        )\n\n        self._layers = {\n            **self._layers,\n            layer_id: {\"id\": layer_id, \"type\": \"geojson-deck\"},\n        }\n        self._add_to_layer_dict(layer_id, \"Deck.gl\")\n\n    def add_contour_layer(\n        self,\n        data: Any,\n        name: Optional[str] = None,\n        get_position: Union[str, Any] = \"coordinates\",\n        get_weight: Union[float, str] = 1,\n        cell_size: float = 200,\n        contours: Optional[List[Dict]] = None,\n        pickable: bool = True,\n        opacity: float = 1,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a contour layer using deck.gl.\"\"\"\n        layer_id = name or f\"contour-{len(self._layers)}\"\n        processed_data = self._process_deck_data(data)\n\n        default_contours = [\n            {\"threshold\": 1, \"color\": [255, 255, 255], \"strokeWidth\": 1},\n            {\"threshold\": 5, \"color\": [51, 136, 255], \"strokeWidth\": 2},\n            {\"threshold\": 10, \"color\": [0, 0, 255], \"strokeWidth\": 3},\n        ]\n\n        self.call_js_method(\n            \"addContourLayer\",\n            id=layer_id,\n            data=processed_data,\n            getPosition=get_position,\n            getWeight=get_weight,\n            cellSize=cell_size,\n            contours=contours or default_contours,\n            pickable=pickable,\n            opacity=opacity,\n            **kwargs,\n        )\n\n        self._layers = {**self._layers, layer_id: {\"id\": layer_id, \"type\": \"contour\"}}\n        self._add_to_layer_dict(layer_id, \"Deck.gl\")\n\n    def add_screen_grid_layer(\n        self,\n        data: Any,\n        name: Optional[str] = None,\n        get_position: Union[str, Any] = \"coordinates\",\n        get_weight: Union[float, str] = 1,\n        cell_size_pixels: float = 50,\n        color_range: Optional[List[List[int]]] = None,\n        pickable: bool = True,\n        opacity: float = 0.8,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a screen grid layer using deck.gl.\"\"\"\n        layer_id = name or f\"screengrid-{len(self._layers)}\"\n        processed_data = self._process_deck_data(data)\n\n        default_color_range = [\n            [255, 255, 178, 25],\n            [254, 217, 118, 85],\n            [254, 178, 76, 127],\n            [253, 141, 60, 170],\n            [240, 59, 32, 212],\n            [189, 0, 38, 255],\n        ]\n\n        self.call_js_method(\n            \"addScreenGridLayer\",\n            id=layer_id,\n            data=processed_data,\n            getPosition=get_position,\n            getWeight=get_weight,\n            cellSizePixels=cell_size_pixels,\n            colorRange=color_range or default_color_range,\n            pickable=pickable,\n            opacity=opacity,\n            **kwargs,\n        )\n\n        self._layers = {\n            **self._layers,\n            layer_id: {\"id\": layer_id, \"type\": \"screengrid\"},\n        }\n        self._add_to_layer_dict(layer_id, \"Deck.gl\")\n\n    def add_trips_layer(\n        self,\n        data: Any,\n        name: Optional[str] = None,\n        get_path: Union[str, Any] = \"waypoints\",\n        get_timestamps: Union[str, Any] = \"timestamps\",\n        get_color: Optional[Union[List[int], str]] = None,\n        width_min_pixels: float = 2,\n        trail_length: float = 180,\n        current_time: float = 0,\n        pickable: bool = True,\n        opacity: float = 0.8,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a trips layer using deck.gl.\"\"\"\n        layer_id = name or f\"trips-{len(self._layers)}\"\n        processed_data = self._process_deck_data(data)\n\n        self.call_js_method(\n            \"addTripsLayer\",\n            id=layer_id,\n            data=processed_data,\n            getPath=get_path,\n            getTimestamps=get_timestamps,\n            getColor=get_color or [253, 128, 93],\n            widthMinPixels=width_min_pixels,\n            trailLength=trail_length,\n            currentTime=current_time,\n            pickable=pickable,\n            opacity=opacity,\n            **kwargs,\n        )\n\n        self._layers = {**self._layers, layer_id: {\"id\": layer_id, \"type\": \"trips\"}}\n        self._add_to_layer_dict(layer_id, \"Deck.gl\")\n\n    def add_line_layer(\n        self,\n        data: Any,\n        name: Optional[str] = None,\n        get_source_position: Union[str, Any] = \"sourcePosition\",\n        get_target_position: Union[str, Any] = \"targetPosition\",\n        get_color: Optional[Union[List[int], str]] = None,\n        get_width: Union[float, str] = 1,\n        width_min_pixels: float = 1,\n        pickable: bool = True,\n        opacity: float = 0.8,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a line layer using deck.gl.\"\"\"\n        layer_id = name or f\"line-{len(self._layers)}\"\n        processed_data = self._process_deck_data(data)\n\n        self.call_js_method(\n            \"addLineLayer\",\n            id=layer_id,\n            data=processed_data,\n            getSourcePosition=get_source_position,\n            getTargetPosition=get_target_position,\n            getColor=get_color or [51, 136, 255, 200],\n            getWidth=get_width,\n            widthMinPixels=width_min_pixels,\n            pickable=pickable,\n            opacity=opacity,\n            **kwargs,\n        )\n\n        self._layers = {**self._layers, layer_id: {\"id\": layer_id, \"type\": \"line\"}}\n        self._add_to_layer_dict(layer_id, \"Deck.gl\")\n\n    def add_deckgl_layer(\n        self,\n        layer_type: str,\n        data: Any,\n        name: Optional[str] = None,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a generic deck.gl layer to the map.\"\"\"\n        layer_type_clean = layer_type.replace(\"Layer\", \"\")\n        prefix = layer_type_clean.lower()\n        layer_id = name or f\"{prefix}-{len(self._layers)}\"\n        processed_data = self._process_deck_data(data)\n\n        self.call_js_method(\n            \"addDeckGLLayer\",\n            layerType=layer_type,\n            id=layer_id,\n            data=processed_data,\n            **kwargs,\n        )\n\n        self._layers = {**self._layers, layer_id: {\"id\": layer_id, \"type\": layer_type}}\n        self._add_to_layer_dict(layer_id, \"Deck.gl\")\n\n    def remove_deck_layer(self, layer_id: str) -&gt; None:\n        \"\"\"Remove a deck.gl layer from the map.\"\"\"\n        self._remove_layer_internal(layer_id, \"removeDeckLayer\")\n\n    def add_column_layer(\n        self,\n        data: Any,\n        name: Optional[str] = None,\n        get_position: Union[str, Any] = \"coordinates\",\n        get_fill_color: Optional[Union[List[int], str]] = None,\n        get_line_color: Optional[Union[List[int], str]] = None,\n        get_elevation: Union[float, str] = 1000,\n        radius: float = 1000,\n        disk_resolution: int = 20,\n        elevation_scale: float = 1,\n        coverage: float = 1,\n        extruded: bool = True,\n        filled: bool = True,\n        stroked: bool = False,\n        wireframe: bool = False,\n        pickable: bool = True,\n        opacity: float = 0.8,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a column layer using deck.gl.\"\"\"\n        layer_id = name or f\"column-{len(self._layers)}\"\n        processed_data = self._process_deck_data(data)\n\n        self.call_js_method(\n            \"addColumnLayer\",\n            id=layer_id,\n            data=processed_data,\n            getPosition=get_position,\n            getFillColor=get_fill_color or [255, 140, 0, 200],\n            getLineColor=get_line_color or [0, 0, 0, 255],\n            getElevation=get_elevation,\n            radius=radius,\n            diskResolution=disk_resolution,\n            elevationScale=elevation_scale,\n            coverage=coverage,\n            extruded=extruded,\n            filled=filled,\n            stroked=stroked,\n            wireframe=wireframe,\n            pickable=pickable,\n            opacity=opacity,\n            **kwargs,\n        )\n\n        self._layers = {**self._layers, layer_id: {\"id\": layer_id, \"type\": \"column\"}}\n        self._add_to_layer_dict(layer_id, \"Deck.gl\")\n\n    def add_bitmap_layer(\n        self,\n        image: str,\n        bounds: List[float],\n        name: Optional[str] = None,\n        opacity: float = 1.0,\n        visible: bool = True,\n        pickable: bool = False,\n        desaturate: float = 0,\n        transparent_color: Optional[List[int]] = None,\n        tint_color: Optional[List[int]] = None,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a bitmap layer using deck.gl.\"\"\"\n        layer_id = name or f\"bitmap-{len(self._layers)}\"\n\n        self.call_js_method(\n            \"addBitmapLayer\",\n            id=layer_id,\n            image=image,\n            bounds=bounds,\n            opacity=opacity,\n            visible=visible,\n            pickable=pickable,\n            desaturate=desaturate,\n            transparentColor=transparent_color or [0, 0, 0, 0],\n            tintColor=tint_color or [255, 255, 255],\n            **kwargs,\n        )\n\n        self._layers = {**self._layers, layer_id: {\"id\": layer_id, \"type\": \"bitmap\"}}\n        self._add_to_layer_dict(layer_id, \"Deck.gl\")\n\n    def add_solid_polygon_layer(\n        self,\n        data: Any,\n        name: Optional[str] = None,\n        get_polygon: Union[str, Any] = \"polygon\",\n        get_fill_color: Optional[Union[List[int], str]] = None,\n        get_line_color: Optional[Union[List[int], str]] = None,\n        get_elevation: Union[float, str] = 0,\n        filled: bool = True,\n        extruded: bool = False,\n        wireframe: bool = False,\n        elevation_scale: float = 1,\n        pickable: bool = True,\n        opacity: float = 0.8,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a solid polygon layer using deck.gl.\"\"\"\n        layer_id = name or f\"solidpolygon-{len(self._layers)}\"\n        processed_data = self._process_deck_data(data)\n\n        self.call_js_method(\n            \"addSolidPolygonLayer\",\n            id=layer_id,\n            data=processed_data,\n            getPolygon=get_polygon,\n            getFillColor=get_fill_color or [51, 136, 255, 128],\n            getLineColor=get_line_color or [0, 0, 0, 255],\n            getElevation=get_elevation,\n            filled=filled,\n            extruded=extruded,\n            wireframe=wireframe,\n            elevationScale=elevation_scale,\n            pickable=pickable,\n            opacity=opacity,\n            **kwargs,\n        )\n\n        self._layers = {\n            **self._layers,\n            layer_id: {\"id\": layer_id, \"type\": \"solidpolygon\"},\n        }\n        self._add_to_layer_dict(layer_id, \"Deck.gl\")\n\n    def add_grid_cell_layer(\n        self,\n        data: Any,\n        name: Optional[str] = None,\n        get_position: Union[str, Any] = \"coordinates\",\n        get_color: Optional[Union[List[int], str]] = None,\n        get_elevation: Union[float, str] = 1000,\n        cell_size: float = 200,\n        coverage: float = 1,\n        elevation_scale: float = 1,\n        extruded: bool = True,\n        pickable: bool = True,\n        opacity: float = 0.8,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a grid cell layer using deck.gl.\"\"\"\n        layer_id = name or f\"gridcell-{len(self._layers)}\"\n        processed_data = self._process_deck_data(data)\n\n        self.call_js_method(\n            \"addGridCellLayer\",\n            id=layer_id,\n            data=processed_data,\n            getPosition=get_position,\n            getColor=get_color or [255, 140, 0, 200],\n            getElevation=get_elevation,\n            cellSize=cell_size,\n            coverage=coverage,\n            elevationScale=elevation_scale,\n            extruded=extruded,\n            pickable=pickable,\n            opacity=opacity,\n            **kwargs,\n        )\n\n        self._layers = {\n            **self._layers,\n            layer_id: {\"id\": layer_id, \"type\": \"gridcell\"},\n        }\n        self._add_to_layer_dict(layer_id, \"Deck.gl\")\n\n    # -------------------------------------------------------------------------\n    # LiDAR Layers (maplibre-gl-lidar)\n    # -------------------------------------------------------------------------\n\n    def add_lidar_control(\n        self,\n        position: str = \"top-right\",\n        collapsed: bool = True,\n        title: str = \"LiDAR Viewer\",\n        point_size: float = 2,\n        opacity: float = 1.0,\n        color_scheme: str = \"elevation\",\n        use_percentile: bool = True,\n        point_budget: int = 1000000,\n        pickable: bool = False,\n        auto_zoom: bool = True,\n        copc_loading_mode: Optional[str] = None,\n        streaming_point_budget: int = 5000000,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add an interactive LiDAR control panel.\n\n        The LiDAR control provides a UI panel for loading, visualizing, and\n        styling LiDAR point cloud files (LAS, LAZ, COPC formats).\n\n        Args:\n            position: Control position ('top-left', 'top-right', 'bottom-left', 'bottom-right').\n            collapsed: Whether the panel starts collapsed.\n            title: Title displayed on the panel.\n            point_size: Point size in pixels.\n            opacity: Layer opacity (0-1).\n            color_scheme: Color scheme ('elevation', 'intensity', 'classification', 'rgb').\n            use_percentile: Use 2-98% percentile for color scaling.\n            point_budget: Maximum number of points to display.\n            pickable: Enable hover/click interactions.\n            auto_zoom: Auto-zoom to point cloud after loading.\n            copc_loading_mode: COPC loading mode ('full' or 'dynamic').\n            streaming_point_budget: Point budget for streaming mode.\n            **kwargs: Additional control options.\n\n        Example:\n            &gt;&gt;&gt; from anymap_ts import MapboxMap\n            &gt;&gt;&gt; m = MapboxMap(pitch=60)\n            &gt;&gt;&gt; m.add_lidar_control(color_scheme=\"classification\", pickable=True)\n        \"\"\"\n        self.call_js_method(\n            \"addLidarControl\",\n            position=position,\n            collapsed=collapsed,\n            title=title,\n            pointSize=point_size,\n            opacity=opacity,\n            colorScheme=color_scheme,\n            usePercentile=use_percentile,\n            pointBudget=point_budget,\n            pickable=pickable,\n            autoZoom=auto_zoom,\n            copcLoadingMode=copc_loading_mode,\n            streamingPointBudget=streaming_point_budget,\n            **kwargs,\n        )\n        self._controls = {\n            **self._controls,\n            \"lidar-control\": {\"position\": position, \"collapsed\": collapsed},\n        }\n\n    def add_lidar_layer(\n        self,\n        source: Union[str, Path],\n        name: Optional[str] = None,\n        color_scheme: str = \"elevation\",\n        point_size: float = 2,\n        opacity: float = 1.0,\n        pickable: bool = True,\n        auto_zoom: bool = True,\n        streaming_mode: bool = True,\n        point_budget: int = 1000000,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Load and display a LiDAR file from URL or local path.\n\n        Supports LAS, LAZ, and COPC (Cloud-Optimized Point Cloud) formats.\n        For local files, the file is read and sent as base64 to JavaScript.\n        For URLs, the data is loaded directly via streaming when possible.\n\n        Args:\n            source: URL or local file path to the LiDAR file.\n            name: Layer identifier. If None, auto-generated.\n            color_scheme: Color scheme ('elevation', 'intensity', 'classification', 'rgb').\n            point_size: Point size in pixels.\n            opacity: Layer opacity (0-1).\n            pickable: Enable hover/click interactions.\n            auto_zoom: Auto-zoom to point cloud after loading.\n            streaming_mode: Use streaming mode for large COPC files.\n            point_budget: Maximum number of points to display.\n            **kwargs: Additional layer options.\n\n        Example:\n            &gt;&gt;&gt; from anymap_ts import MapboxMap\n            &gt;&gt;&gt; m = MapboxMap(center=[-123.07, 44.05], zoom=14, pitch=60)\n            &gt;&gt;&gt; m.add_lidar_layer(\n            ...     source=\"https://s3.amazonaws.com/hobu-lidar/autzen-classified.copc.laz\",\n            ...     name=\"autzen\",\n            ...     color_scheme=\"classification\",\n            ... )\n        \"\"\"\n        import base64\n\n        layer_id = name or f\"lidar-{len(self._layers)}\"\n\n        # Check if source is a local file\n        source_path = Path(source) if isinstance(source, (str, Path)) else None\n        is_local = source_path is not None and source_path.exists()\n\n        if is_local:\n            # Read local file and encode as base64\n            with open(source_path, \"rb\") as f:\n                file_data = f.read()\n            source_b64 = base64.b64encode(file_data).decode(\"utf-8\")\n\n            self.call_js_method(\n                \"addLidarLayer\",\n                source=source_b64,\n                name=layer_id,\n                isBase64=True,\n                filename=source_path.name,\n                colorScheme=color_scheme,\n                pointSize=point_size,\n                opacity=opacity,\n                pickable=pickable,\n                autoZoom=auto_zoom,\n                streamingMode=streaming_mode,\n                pointBudget=point_budget,\n                **kwargs,\n            )\n        else:\n            # Load from URL\n            self.call_js_method(\n                \"addLidarLayer\",\n                source=str(source),\n                name=layer_id,\n                isBase64=False,\n                colorScheme=color_scheme,\n                pointSize=point_size,\n                opacity=opacity,\n                pickable=pickable,\n                autoZoom=auto_zoom,\n                streamingMode=streaming_mode,\n                pointBudget=point_budget,\n                **kwargs,\n            )\n\n        self._layers = {\n            **self._layers,\n            layer_id: {\n                \"id\": layer_id,\n                \"type\": \"lidar\",\n                \"source\": str(source),\n            },\n        }\n\n    def remove_lidar_layer(self, layer_id: Optional[str] = None) -&gt; None:\n        \"\"\"Remove a LiDAR layer.\n\n        Args:\n            layer_id: Layer identifier to remove. If None, removes all LiDAR layers.\n        \"\"\"\n        if layer_id:\n            if layer_id in self._layers:\n                layers = dict(self._layers)\n                del layers[layer_id]\n                self._layers = layers\n            self.call_js_method(\"removeLidarLayer\", id=layer_id)\n        else:\n            # Remove all lidar layers\n            layers = dict(self._layers)\n            self._layers = {k: v for k, v in layers.items() if v.get(\"type\") != \"lidar\"}\n            self.call_js_method(\"removeLidarLayer\")\n\n    def set_lidar_color_scheme(self, color_scheme: str) -&gt; None:\n        \"\"\"Set the LiDAR color scheme.\n\n        Args:\n            color_scheme: Color scheme ('elevation', 'intensity', 'classification', 'rgb').\n        \"\"\"\n        self.call_js_method(\"setLidarColorScheme\", colorScheme=color_scheme)\n\n    def set_lidar_point_size(self, point_size: float) -&gt; None:\n        \"\"\"Set the LiDAR point size.\n\n        Args:\n            point_size: Point size in pixels.\n        \"\"\"\n        self.call_js_method(\"setLidarPointSize\", pointSize=point_size)\n\n    def set_lidar_opacity(self, opacity: float) -&gt; None:\n        \"\"\"Set the LiDAR layer opacity.\n\n        Args:\n            opacity: Opacity value between 0 and 1.\n        \"\"\"\n        self.call_js_method(\"setLidarOpacity\", opacity=opacity)\n\n    def _process_deck_data(self, data: Any) -&gt; Any:\n        \"\"\"Process data for deck.gl layers.\n\n        Handles GeoDataFrame, file paths, GeoJSON, and list of dicts.\n\n        Args:\n            data: Input data in various formats.\n\n        Returns:\n            Processed data suitable for deck.gl layers.\n        \"\"\"\n        # Handle GeoDataFrame\n        if hasattr(data, \"__geo_interface__\"):\n            return data.__geo_interface__\n\n        # Handle file paths\n        if isinstance(data, (str, Path)):\n            path = Path(data)\n            if path.exists():\n                try:\n                    import geopandas as gpd\n\n                    gdf = gpd.read_file(path)\n                    return gdf.__geo_interface__\n                except ImportError:\n                    pass\n\n        # Return as-is for lists, dicts, etc.\n        return data\n\n    # -------------------------------------------------------------------------\n    # Terrain Methods (Mapbox-specific)\n    # -------------------------------------------------------------------------\n\n    def add_terrain(\n        self, exaggeration: float = 1.0, source: str = \"mapbox-dem\"\n    ) -&gt; None:\n        \"\"\"Add 3D terrain to the map.\n\n        Args:\n            exaggeration: Terrain exaggeration factor.\n            source: Terrain source ID.\n        \"\"\"\n        self.call_js_method(\"addTerrain\", source=source, exaggeration=exaggeration)\n\n    def remove_terrain(self) -&gt; None:\n        \"\"\"Remove 3D terrain from the map.\"\"\"\n        self.call_js_method(\"removeTerrain\")\n\n    def add_3d_terrain(\n        self, exaggeration: float = 1.0, source: str = \"mapbox-dem\", **kwargs\n    ) -&gt; None:\n        \"\"\"Alias for add_terrain for MapLibre compatibility.\"\"\"\n        self.add_terrain(exaggeration=exaggeration, source=source)\n\n    # -------------------------------------------------------------------------\n    # Layer Management\n    # -------------------------------------------------------------------------\n\n    def add_layer(\n        self,\n        layer_id: str,\n        layer_type: str,\n        source: Union[str, Dict],\n        paint: Optional[Dict] = None,\n        layout: Optional[Dict] = None,\n        before_id: Optional[str] = None,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a generic layer to the map.\n\n        Args:\n            layer_id: Unique layer identifier.\n            layer_type: Mapbox layer type.\n            source: Source ID or source configuration dict.\n            paint: Paint properties.\n            layout: Layout properties.\n            before_id: ID of layer to insert before.\n            **kwargs: Additional layer options.\n        \"\"\"\n        layer_config = {\n            \"id\": layer_id,\n            \"type\": layer_type,\n            \"paint\": paint or {},\n            \"layout\": layout or {},\n            **kwargs,\n        }\n\n        if isinstance(source, str):\n            layer_config[\"source\"] = source\n        else:\n            source_id = f\"{layer_id}-source\"\n            self._sources = {**self._sources, source_id: source}\n            self.call_js_method(\"addSource\", source_id, **source)\n            layer_config[\"source\"] = source_id\n\n        self._layers = {**self._layers, layer_id: layer_config}\n        self.call_js_method(\"addLayer\", beforeId=before_id, **layer_config)\n        lt = layer_config.get(\"type\", \"\")\n        self._add_to_layer_dict(layer_id, \"Raster\" if lt == \"raster\" else \"Vector\")\n\n    def remove_layer(self, layer_id: str) -&gt; None:\n        \"\"\"Remove a layer from the map.\"\"\"\n        if layer_id in self._layers:\n            layers = dict(self._layers)\n            del layers[layer_id]\n            self._layers = layers\n        self._remove_from_layer_dict(layer_id)\n        self.call_js_method(\"removeLayer\", layer_id)\n\n    def set_visibility(self, layer_id: str, visible: bool) -&gt; None:\n        \"\"\"Set layer visibility.\n\n        Args:\n            layer_id: Layer identifier.\n            visible: Whether layer should be visible.\n        \"\"\"\n        self.call_js_method(\"setVisibility\", layer_id, visible)\n\n    def set_opacity(self, layer_id: str, opacity: float) -&gt; None:\n        \"\"\"Set layer opacity.\"\"\"\n        self._validate_opacity(opacity)\n        self.call_js_method(\"setOpacity\", layer_id, opacity)\n\n    def set_paint_property(self, layer_id: str, property_name: str, value: Any) -&gt; None:\n        \"\"\"Set a paint property for a layer.\"\"\"\n        self.call_js_method(\"setPaintProperty\", layer_id, property_name, value)\n\n    def set_layout_property(\n        self, layer_id: str, property_name: str, value: Any\n    ) -&gt; None:\n        \"\"\"Set a layout property for a layer.\"\"\"\n        self.call_js_method(\"setLayoutProperty\", layer_id, property_name, value)\n\n    def move_layer(self, layer_id: str, before_id: Optional[str] = None) -&gt; None:\n        \"\"\"Move a layer in the layer stack.\"\"\"\n        self.call_js_method(\"moveLayer\", layer_id, before_id)\n\n    def get_layer(self, layer_id: str) -&gt; Optional[Dict]:\n        \"\"\"Get layer configuration by ID.\"\"\"\n        return self._layers.get(layer_id)\n\n    def get_layer_ids(self) -&gt; List[str]:\n        \"\"\"Get list of all layer IDs.\"\"\"\n        return list(self._layers.keys())\n\n    def add_popup(\n        self,\n        layer_id: str,\n        properties: Optional[List[str]] = None,\n        template: Optional[str] = None,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add popup on click for a layer.\"\"\"\n        self.call_js_method(\n            \"addPopup\",\n            layerId=layer_id,\n            properties=properties,\n            template=template,\n            **kwargs,\n        )\n\n    # -------------------------------------------------------------------------\n    # Controls\n    # -------------------------------------------------------------------------\n\n    def add_control(\n        self,\n        control_type: str,\n        position: str = \"top-right\",\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a map control.\n\n        Args:\n            control_type: Type of control ('navigation', 'scale', 'fullscreen', etc.).\n            position: Control position.\n            **kwargs: Control-specific options.\n        \"\"\"\n        self.call_js_method(\"addControl\", control_type, position=position, **kwargs)\n        self._controls = {\n            **self._controls,\n            control_type: {\"type\": control_type, \"position\": position, **kwargs},\n        }\n\n    def remove_control(self, control_type: str) -&gt; None:\n        \"\"\"Remove a map control.\"\"\"\n        self.call_js_method(\"removeControl\", control_type)\n        if control_type in self._controls:\n            controls = dict(self._controls)\n            del controls[control_type]\n            self._controls = controls\n\n    def add_layer_control(\n        self,\n        layers: Optional[List[str]] = None,\n        position: str = \"top-right\",\n        collapsed: bool = True,\n    ) -&gt; None:\n        \"\"\"Add a layer visibility control.\"\"\"\n        if layers is None:\n            layers = list(self._layers.keys())\n\n        self.call_js_method(\n            \"addLayerControl\",\n            layers=layers,\n            position=position,\n            collapsed=collapsed,\n        )\n        self._controls = {\n            **self._controls,\n            \"layer-control\": {\n                \"layers\": layers,\n                \"position\": position,\n                \"collapsed\": collapsed,\n            },\n        }\n\n    def add_colorbar(\n        self,\n        colormap: str = \"viridis\",\n        vmin: float = 0,\n        vmax: float = 1,\n        label: str = \"\",\n        units: str = \"\",\n        orientation: str = \"horizontal\",\n        position: str = \"bottom-right\",\n        bar_thickness: Optional[int] = None,\n        bar_length: Optional[int] = None,\n        ticks: Optional[Dict] = None,\n        opacity: Optional[float] = None,\n        colorbar_id: Optional[str] = None,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a continuous gradient colorbar to the map.\"\"\"\n        self._validate_position(position)\n\n        cbar_id = (\n            colorbar_id\n            or f\"colorbar-{len([k for k in self._controls.keys() if k.startswith('colorbar')])}\"\n        )\n\n        js_kwargs: Dict[str, Any] = {\n            \"colormap\": colormap,\n            \"vmin\": vmin,\n            \"vmax\": vmax,\n            \"label\": label,\n            \"units\": units,\n            \"orientation\": orientation,\n            \"position\": position,\n            \"colorbarId\": cbar_id,\n            **kwargs,\n        }\n        if bar_thickness is not None:\n            js_kwargs[\"barThickness\"] = bar_thickness\n        if bar_length is not None:\n            js_kwargs[\"barLength\"] = bar_length\n        if ticks is not None:\n            js_kwargs[\"ticks\"] = ticks\n        if opacity is not None:\n            js_kwargs[\"opacity\"] = opacity\n\n        self.call_js_method(\"addColorbar\", **js_kwargs)\n\n        self._controls = {\n            **self._controls,\n            cbar_id: {\n                \"type\": \"colorbar\",\n                \"colormap\": colormap,\n                \"vmin\": vmin,\n                \"vmax\": vmax,\n                \"label\": label,\n                \"units\": units,\n                \"orientation\": orientation,\n                \"position\": position,\n            },\n        }\n\n    def remove_colorbar(self, colorbar_id: Optional[str] = None) -&gt; None:\n        \"\"\"Remove a colorbar from the map.\"\"\"\n        if colorbar_id is None:\n            cbar_keys = [k for k in self._controls.keys() if k.startswith(\"colorbar\")]\n            for key in cbar_keys:\n                self.call_js_method(\"removeColorbar\", colorbarId=key)\n            self._controls = {\n                k: v for k, v in self._controls.items() if not k.startswith(\"colorbar\")\n            }\n        else:\n            self.call_js_method(\"removeColorbar\", colorbarId=colorbar_id)\n            if colorbar_id in self._controls:\n                controls = dict(self._controls)\n                del controls[colorbar_id]\n                self._controls = controls\n\n    def update_colorbar(self, colorbar_id: Optional[str] = None, **kwargs) -&gt; None:\n        \"\"\"Update an existing colorbar's properties.\"\"\"\n        if colorbar_id is None:\n            cbar_keys = [k for k in self._controls.keys() if k.startswith(\"colorbar\")]\n            if not cbar_keys:\n                raise ValueError(\"No colorbar found to update\")\n            colorbar_id = cbar_keys[0]\n\n        if colorbar_id not in self._controls:\n            raise ValueError(f\"Colorbar '{colorbar_id}' not found\")\n\n        js_kwargs: Dict[str, Any] = {\"colorbarId\": colorbar_id}\n        key_map = {\"bar_thickness\": \"barThickness\", \"bar_length\": \"barLength\"}\n        for key, value in kwargs.items():\n            js_key = key_map.get(key, key)\n            js_kwargs[js_key] = value\n\n        self.call_js_method(\"updateColorbar\", **js_kwargs)\n\n    def add_search_control(\n        self,\n        position: str = \"top-left\",\n        placeholder: str = \"Search places...\",\n        collapsed: bool = True,\n        fly_to_zoom: int = 14,\n        show_marker: bool = True,\n        marker_color: str = \"#4264fb\",\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a search/geocoder control.\"\"\"\n        self._validate_position(position)\n        self.call_js_method(\n            \"addSearchControl\",\n            position=position,\n            placeholder=placeholder,\n            collapsed=collapsed,\n            flyToZoom=fly_to_zoom,\n            showMarker=show_marker,\n            markerColor=marker_color,\n            **kwargs,\n        )\n        self._controls = {\n            **self._controls,\n            \"search-control\": {\n                \"type\": \"search-control\",\n                \"position\": position,\n                \"collapsed\": collapsed,\n            },\n        }\n\n    def remove_search_control(self) -&gt; None:\n        \"\"\"Remove the search/geocoder control.\"\"\"\n        self.call_js_method(\"removeSearchControl\")\n        if \"search-control\" in self._controls:\n            controls = dict(self._controls)\n            del controls[\"search-control\"]\n            self._controls = controls\n\n    def add_measure_control(\n        self,\n        position: str = \"top-right\",\n        collapsed: bool = True,\n        default_mode: str = \"distance\",\n        distance_unit: str = \"kilometers\",\n        area_unit: str = \"square-kilometers\",\n        line_color: str = \"#3b82f6\",\n        fill_color: str = \"rgba(59, 130, 246, 0.2)\",\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a measurement control.\"\"\"\n        self._validate_position(position)\n        self.call_js_method(\n            \"addMeasureControl\",\n            position=position,\n            collapsed=collapsed,\n            defaultMode=default_mode,\n            distanceUnit=distance_unit,\n            areaUnit=area_unit,\n            lineColor=line_color,\n            fillColor=fill_color,\n            **kwargs,\n        )\n        self._controls = {\n            **self._controls,\n            \"measure-control\": {\n                \"type\": \"measure-control\",\n                \"position\": position,\n                \"collapsed\": collapsed,\n            },\n        }\n\n    def remove_measure_control(self) -&gt; None:\n        \"\"\"Remove the measurement control.\"\"\"\n        self.call_js_method(\"removeMeasureControl\")\n        if \"measure-control\" in self._controls:\n            controls = dict(self._controls)\n            del controls[\"measure-control\"]\n            self._controls = controls\n\n    def add_print_control(\n        self,\n        position: str = \"top-right\",\n        collapsed: bool = True,\n        format: str = \"png\",\n        filename: str = \"map-export\",\n        include_north_arrow: bool = False,\n        include_scale_bar: bool = False,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a print/export control.\"\"\"\n        self._validate_position(position)\n        self.call_js_method(\n            \"addPrintControl\",\n            position=position,\n            collapsed=collapsed,\n            format=format,\n            filename=filename,\n            includeNorthArrow=include_north_arrow,\n            includeScaleBar=include_scale_bar,\n            **kwargs,\n        )\n        self._controls = {\n            **self._controls,\n            \"print-control\": {\n                \"type\": \"print-control\",\n                \"position\": position,\n                \"collapsed\": collapsed,\n            },\n        }\n\n    def remove_print_control(self) -&gt; None:\n        \"\"\"Remove the print/export control.\"\"\"\n        self.call_js_method(\"removePrintControl\")\n        if \"print-control\" in self._controls:\n            controls = dict(self._controls)\n            del controls[\"print-control\"]\n            self._controls = controls\n\n    def add_coordinates_control(\n        self,\n        position: str = \"bottom-left\",\n        precision: int = 4,\n    ) -&gt; None:\n        \"\"\"Add a coordinates display control.\"\"\"\n        self.call_js_method(\n            \"addCoordinatesControl\",\n            position=position,\n            precision=precision,\n        )\n\n    def remove_coordinates_control(self) -&gt; None:\n        \"\"\"Remove the coordinates display control.\"\"\"\n        self.call_js_method(\"removeCoordinatesControl\")\n\n    def add_time_slider(\n        self,\n        layer_id: str,\n        property: str,\n        min_value: float = 0,\n        max_value: float = 100,\n        step: float = 1,\n        position: str = \"bottom-left\",\n        label: str = \"Time\",\n        auto_play: bool = False,\n        interval: int = 500,\n    ) -&gt; None:\n        \"\"\"Add a time slider to filter data by a temporal property.\"\"\"\n        self.call_js_method(\n            \"addTimeSlider\",\n            layerId=layer_id,\n            property=property,\n            min=min_value,\n            max=max_value,\n            step=step,\n            position=position,\n            label=label,\n            autoPlay=auto_play,\n            interval=interval,\n        )\n\n    def remove_time_slider(self) -&gt; None:\n        \"\"\"Remove the time slider control.\"\"\"\n        self.call_js_method(\"removeTimeSlider\")\n\n    def add_opacity_slider(\n        self,\n        layer_id: str,\n        position: str = \"top-right\",\n        label: Optional[str] = None,\n    ) -&gt; None:\n        \"\"\"Add a UI slider to control layer opacity.\"\"\"\n        self.call_js_method(\n            \"addOpacitySlider\",\n            layerId=layer_id,\n            position=position,\n            label=label or layer_id,\n        )\n\n    def remove_opacity_slider(self, layer_id: str) -&gt; None:\n        \"\"\"Remove the opacity slider for a layer.\"\"\"\n        self.call_js_method(\"removeOpacitySlider\", layerId=layer_id)\n\n    def add_style_switcher(\n        self,\n        styles: Dict[str, str],\n        position: str = \"top-right\",\n    ) -&gt; None:\n        \"\"\"Add a dropdown to switch between map styles.\"\"\"\n        self.call_js_method(\n            \"addStyleSwitcher\",\n            styles=styles,\n            position=position,\n        )\n\n    def remove_style_switcher(self) -&gt; None:\n        \"\"\"Remove the style switcher control.\"\"\"\n        self.call_js_method(\"removeStyleSwitcher\")\n\n    def add_pmtiles_control(\n        self,\n        position: str = \"top-right\",\n        collapsed: bool = True,\n        default_url: Optional[str] = None,\n        load_default_url: bool = False,\n        default_opacity: float = 1.0,\n        default_fill_color: str = \"steelblue\",\n        default_line_color: str = \"#333\",\n        default_pickable: bool = True,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a PMTiles layer control.\"\"\"\n        self.call_js_method(\n            \"addPMTilesControl\",\n            position=position,\n            collapsed=collapsed,\n            defaultUrl=default_url or \"\",\n            loadDefaultUrl=load_default_url,\n            defaultOpacity=default_opacity,\n            defaultFillColor=default_fill_color,\n            defaultLineColor=default_line_color,\n            defaultPickable=default_pickable,\n            **kwargs,\n        )\n        self._controls = {\n            **self._controls,\n            \"pmtiles-control\": {\"position\": position, \"collapsed\": collapsed},\n        }\n\n    def add_cog_control(\n        self,\n        position: str = \"top-right\",\n        collapsed: bool = True,\n        default_url: Optional[str] = None,\n        load_default_url: bool = False,\n        default_opacity: float = 1.0,\n        default_colormap: str = \"viridis\",\n        default_bands: str = \"1\",\n        default_rescale_min: float = 0,\n        default_rescale_max: float = 255,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a COG layer control.\"\"\"\n        self.call_js_method(\n            \"addCogControl\",\n            position=position,\n            collapsed=collapsed,\n            defaultUrl=default_url or \"\",\n            loadDefaultUrl=load_default_url,\n            defaultOpacity=default_opacity,\n            defaultColormap=default_colormap,\n            defaultBands=default_bands,\n            defaultRescaleMin=default_rescale_min,\n            defaultRescaleMax=default_rescale_max,\n            **kwargs,\n        )\n        self._controls = {\n            **self._controls,\n            \"cog-control\": {\"position\": position, \"collapsed\": collapsed},\n        }\n\n    def add_zarr_control(\n        self,\n        position: str = \"top-right\",\n        collapsed: bool = True,\n        default_url: Optional[str] = None,\n        load_default_url: bool = False,\n        default_opacity: float = 1.0,\n        default_variable: str = \"\",\n        default_clim: Optional[Tuple[float, float]] = None,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a Zarr layer control.\"\"\"\n        self.call_js_method(\n            \"addZarrControl\",\n            position=position,\n            collapsed=collapsed,\n            defaultUrl=default_url or \"\",\n            loadDefaultUrl=load_default_url,\n            defaultOpacity=default_opacity,\n            defaultVariable=default_variable,\n            defaultClim=list(default_clim) if default_clim else [0, 1],\n            **kwargs,\n        )\n        self._controls = {\n            **self._controls,\n            \"zarr-control\": {\"position\": position, \"collapsed\": collapsed},\n        }\n\n    def add_vector_control(\n        self,\n        position: str = \"top-right\",\n        collapsed: bool = True,\n        default_url: Optional[str] = None,\n        load_default_url: bool = False,\n        default_opacity: float = 1.0,\n        default_fill_color: str = \"#3388ff\",\n        default_stroke_color: str = \"#3388ff\",\n        fit_bounds: bool = True,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a vector layer control.\"\"\"\n        self.call_js_method(\n            \"addVectorControl\",\n            position=position,\n            collapsed=collapsed,\n            defaultUrl=default_url or \"\",\n            loadDefaultUrl=load_default_url,\n            defaultOpacity=default_opacity,\n            defaultFillColor=default_fill_color,\n            defaultStrokeColor=default_stroke_color,\n            fitBounds=fit_bounds,\n            **kwargs,\n        )\n        self._controls = {\n            **self._controls,\n            \"vector-control\": {\"position\": position, \"collapsed\": collapsed},\n        }\n\n    def add_control_grid(\n        self,\n        position: str = \"top-right\",\n        default_controls: Optional[List[str]] = None,\n        exclude: Optional[List[str]] = None,\n        rows: Optional[int] = None,\n        columns: Optional[int] = None,\n        collapsed: bool = True,\n        collapsible: bool = True,\n        title: str = \"\",\n        show_row_column_controls: bool = True,\n        gap: int = 2,\n        basemap_style_url: Optional[str] = None,\n        exclude_layers: Optional[List[str]] = None,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a ControlGrid with all default tools or a custom subset.\"\"\"\n        js_kwargs: Dict[str, Any] = {\n            \"position\": position,\n            \"collapsed\": collapsed,\n            \"collapsible\": collapsible,\n            \"showRowColumnControls\": show_row_column_controls,\n            \"gap\": gap,\n            **kwargs,\n        }\n        if default_controls is not None:\n            js_kwargs[\"defaultControls\"] = default_controls\n        if exclude is not None:\n            js_kwargs[\"exclude\"] = exclude\n        if rows is not None:\n            js_kwargs[\"rows\"] = rows\n        if columns is not None:\n            js_kwargs[\"columns\"] = columns\n        if title:\n            js_kwargs[\"title\"] = title\n        if basemap_style_url is not None:\n            js_kwargs[\"basemapStyleUrl\"] = basemap_style_url\n        if exclude_layers is not None:\n            js_kwargs[\"excludeLayers\"] = exclude_layers\n\n        self.call_js_method(\"addControlGrid\", **js_kwargs)\n        self._controls = {\n            **self._controls,\n            \"control-grid\": {\n                \"position\": position,\n                \"collapsed\": collapsed,\n                \"collapsible\": collapsible,\n            },\n        }\n\n    def add_legend(\n        self,\n        title: str,\n        labels: List[str],\n        colors: List[str],\n        position: str = \"bottom-right\",\n        opacity: float = 1.0,\n        legend_id: Optional[str] = None,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a floating legend control to the map.\"\"\"\n        if len(labels) != len(colors):\n            raise ValueError(\"Number of labels must match number of colors\")\n\n        self._validate_position(position)\n\n        for i, color in enumerate(colors):\n            if not isinstance(color, str) or not color.startswith(\"#\"):\n                raise ValueError(\n                    f\"Color at index {i} must be a hex color string (e.g., '#ff0000')\"\n                )\n\n        legend_id = (\n            legend_id\n            or f\"legend-{len([k for k in self._controls.keys() if k.startswith('legend')])}\"\n        )\n\n        legend_items = [\n            {\"label\": label, \"color\": color} for label, color in zip(labels, colors)\n        ]\n\n        self.call_js_method(\n            \"addLegend\",\n            id=legend_id,\n            title=title,\n            items=legend_items,\n            position=position,\n            opacity=opacity,\n            **kwargs,\n        )\n\n        self._controls = {\n            **self._controls,\n            legend_id: {\n                \"type\": \"legend\",\n                \"title\": title,\n                \"labels\": labels,\n                \"colors\": colors,\n                \"position\": position,\n                \"opacity\": opacity,\n            },\n        }\n\n    def remove_legend(self, legend_id: Optional[str] = None) -&gt; None:\n        \"\"\"Remove a legend control from the map.\"\"\"\n        if legend_id is None:\n            legend_keys = [k for k in self._controls.keys() if k.startswith(\"legend\")]\n            for key in legend_keys:\n                self.call_js_method(\"removeLegend\", key)\n            self._controls = {\n                k: v for k, v in self._controls.items() if not k.startswith(\"legend\")\n            }\n        else:\n            self.call_js_method(\"removeLegend\", legend_id)\n            if legend_id in self._controls:\n                controls = dict(self._controls)\n                del controls[legend_id]\n                self._controls = controls\n\n    def update_legend(\n        self,\n        legend_id: str,\n        title: Optional[str] = None,\n        labels: Optional[List[str]] = None,\n        colors: Optional[List[str]] = None,\n        opacity: Optional[float] = None,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Update an existing legend's properties.\"\"\"\n        if legend_id not in self._controls:\n            raise ValueError(f\"Legend '{legend_id}' not found\")\n\n        update_params = {\"id\": legend_id}\n\n        if title is not None:\n            update_params[\"title\"] = title\n            self._controls[legend_id][\"title\"] = title\n\n        if labels is not None and colors is not None:\n            if len(labels) != len(colors):\n                raise ValueError(\"Number of labels must match number of colors\")\n\n            legend_items = [\n                {\"label\": label, \"color\": color} for label, color in zip(labels, colors)\n            ]\n            update_params[\"items\"] = legend_items\n            self._controls[legend_id][\"labels\"] = labels\n            self._controls[legend_id][\"colors\"] = colors\n\n        elif labels is not None or colors is not None:\n            raise ValueError(\"Both labels and colors must be provided together\")\n\n        if opacity is not None:\n            update_params[\"opacity\"] = opacity\n            self._controls[legend_id][\"opacity\"] = opacity\n\n        update_params.update(kwargs)\n        self.call_js_method(\"updateLegend\", **update_params)\n\n    def add_tooltip(\n        self,\n        layer_id: str,\n        template: Optional[str] = None,\n        properties: Optional[List[str]] = None,\n    ) -&gt; None:\n        \"\"\"Add a tooltip that shows on feature hover.\"\"\"\n        self.call_js_method(\n            \"addTooltip\",\n            layerId=layer_id,\n            template=template or \"\",\n            properties=properties,\n        )\n\n    def remove_tooltip(self, layer_id: str) -&gt; None:\n        \"\"\"Remove tooltip from a layer.\"\"\"\n        self.call_js_method(\"removeTooltip\", layerId=layer_id)\n\n    def add_flatgeobuf(\n        self,\n        url: str,\n        name: Optional[str] = None,\n        layer_type: Optional[str] = None,\n        paint: Optional[Dict] = None,\n        fit_bounds: bool = True,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a FlatGeobuf layer from a URL.\"\"\"\n        layer_id = name or f\"flatgeobuf-{len(self._layers)}\"\n\n        self.call_js_method(\n            \"addFlatGeobuf\",\n            url=url,\n            name=layer_id,\n            layerType=layer_type,\n            paint=paint,\n            fitBounds=fit_bounds,\n            **kwargs,\n        )\n\n        self._layers = {\n            **self._layers,\n            layer_id: {\n                \"id\": layer_id,\n                \"type\": \"flatgeobuf\",\n                \"url\": url,\n            },\n        }\n        self._add_to_layer_dict(layer_id, \"Vector\")\n\n    def remove_flatgeobuf(self, name: str) -&gt; None:\n        \"\"\"Remove a FlatGeobuf layer from the map.\"\"\"\n        if name in self._layers:\n            layers = dict(self._layers)\n            del layers[name]\n            self._layers = layers\n        self._remove_from_layer_dict(name)\n        self.call_js_method(\"removeFlatGeobuf\", name=name)\n\n    def add_draw_control(\n        self,\n        position: str = \"top-right\",\n        draw_modes: Optional[List[str]] = None,\n        edit_modes: Optional[List[str]] = None,\n        collapsed: bool = False,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a drawing control.\"\"\"\n        if draw_modes is None:\n            draw_modes = [\"polygon\", \"line\", \"rectangle\", \"circle\", \"marker\"]\n        if edit_modes is None:\n            edit_modes = [\"select\", \"drag\", \"change\", \"rotate\", \"delete\"]\n\n        self.call_js_method(\n            \"addDrawControl\",\n            position=position,\n            drawModes=draw_modes,\n            editModes=edit_modes,\n            collapsed=collapsed,\n            **kwargs,\n        )\n        self._controls = {\n            **self._controls,\n            \"draw-control\": {\n                \"position\": position,\n                \"drawModes\": draw_modes,\n                \"editModes\": edit_modes,\n            },\n        }\n\n    def get_draw_data(self) -&gt; Dict:\n        \"\"\"Get the current drawn features as GeoJSON.\"\"\"\n        self.call_js_method(\"getDrawData\")\n        import time\n\n        time.sleep(0.1)\n        return self._draw_data or {\"type\": \"FeatureCollection\", \"features\": []}\n\n    @property\n    def draw_data(self) -&gt; Dict:\n        \"\"\"Property to access current draw data.\"\"\"\n        return self._draw_data or {\"type\": \"FeatureCollection\", \"features\": []}\n\n    def load_draw_data(self, geojson: Dict) -&gt; None:\n        \"\"\"Load GeoJSON features into the drawing layer.\"\"\"\n        self._draw_data = geojson\n        self.call_js_method(\"loadDrawData\", geojson)\n\n    def clear_draw_data(self) -&gt; None:\n        \"\"\"Clear all drawn features.\"\"\"\n        self._draw_data = {\"type\": \"FeatureCollection\", \"features\": []}\n        self.call_js_method(\"clearDrawData\")\n\n    def save_draw_data(\n        self,\n        filepath: Union[str, Path],\n        driver: Optional[str] = None,\n    ) -&gt; None:\n        \"\"\"Save drawn features to a file.\"\"\"\n        try:\n            import geopandas as gpd\n        except ImportError:\n            raise ImportError(\n                \"geopandas is required to save draw data. \"\n                \"Install with: pip install anymap-ts[vector]\"\n            )\n\n        data = self.get_draw_data()\n        if not data.get(\"features\"):\n            print(\"No features to save\")\n            return\n\n        gdf = gpd.GeoDataFrame.from_features(data[\"features\"])\n        filepath = Path(filepath)\n\n        if driver is None:\n            ext = filepath.suffix.lower()\n            driver_map = {\n                \".geojson\": \"GeoJSON\",\n                \".json\": \"GeoJSON\",\n                \".shp\": \"ESRI Shapefile\",\n                \".gpkg\": \"GPKG\",\n            }\n            driver = driver_map.get(ext, \"GeoJSON\")\n\n        gdf.to_file(filepath, driver=driver)\n\n    def add_cluster_layer(\n        self,\n        data: Any,\n        cluster_radius: int = 50,\n        cluster_max_zoom: int = 14,\n        cluster_colors: Optional[List[str]] = None,\n        cluster_steps: Optional[List[int]] = None,\n        cluster_min_radius: int = 15,\n        cluster_max_radius: int = 30,\n        unclustered_color: str = \"#11b4da\",\n        unclustered_radius: int = 8,\n        show_cluster_count: bool = True,\n        name: Optional[str] = None,\n        zoom_on_click: bool = True,\n        fit_bounds: bool = True,\n        **kwargs,\n    ) -&gt; str:\n        \"\"\"Add a clustered point layer.\"\"\"\n        layer_id = name or f\"cluster-{len(self._layers)}\"\n\n        if cluster_colors is None:\n            cluster_colors = [\"#51bbd6\", \"#f1f075\", \"#f28cb1\"]\n        if cluster_steps is None:\n            cluster_steps = [100, 750]\n\n        if len(cluster_steps) != len(cluster_colors) - 1:\n            raise ValueError(\n                f\"cluster_steps must have {len(cluster_colors) - 1} values \"\n                f\"(one less than cluster_colors), got {len(cluster_steps)}\"\n            )\n\n        geojson = to_geojson(data)\n\n        if geojson.get(\"type\") == \"url\":\n            url = geojson[\"url\"]\n            geojson = fetch_geojson(url)\n\n        bounds = get_bounds(geojson) if fit_bounds else None\n\n        self.call_js_method(\n            \"addClusterLayer\",\n            data=geojson,\n            name=layer_id,\n            clusterRadius=cluster_radius,\n            clusterMaxZoom=cluster_max_zoom,\n            clusterColors=cluster_colors,\n            clusterSteps=cluster_steps,\n            clusterMinRadius=cluster_min_radius,\n            clusterMaxRadius=cluster_max_radius,\n            unclusteredColor=unclustered_color,\n            unclusteredRadius=unclustered_radius,\n            showClusterCount=show_cluster_count,\n            zoomOnClick=zoom_on_click,\n            fitBounds=fit_bounds,\n            bounds=bounds,\n            **kwargs,\n        )\n\n        self._layers = {\n            **self._layers,\n            layer_id: {\n                \"id\": layer_id,\n                \"type\": \"cluster\",\n                \"source\": f\"{layer_id}-source\",\n            },\n        }\n        self._add_to_layer_dict(layer_id, \"Vector\")\n        return layer_id\n\n    def remove_cluster_layer(self, layer_id: str) -&gt; None:\n        \"\"\"Remove a cluster layer.\"\"\"\n        self._remove_layer_internal(layer_id, \"removeClusterLayer\")\n\n    def add_choropleth(\n        self,\n        data: Any,\n        column: str,\n        cmap: str = \"viridis\",\n        classification: str = \"quantile\",\n        k: int = 5,\n        breaks: Optional[List[float]] = None,\n        fill_opacity: float = 0.7,\n        line_color: str = \"#000000\",\n        line_width: float = 1,\n        legend: bool = True,\n        legend_title: Optional[str] = None,\n        hover: bool = True,\n        layer_id: Optional[str] = None,\n        fit_bounds: bool = True,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a choropleth (thematic) map layer.\"\"\"\n        from .utils import (\n            get_choropleth_colors,\n            compute_breaks,\n            build_step_expression,\n        )\n\n        layer_name = layer_id or f\"choropleth-{len(self._layers)}\"\n\n        geojson = to_geojson(data)\n\n        if geojson.get(\"type\") == \"url\":\n            url = geojson[\"url\"]\n            geojson = fetch_geojson(url)\n\n        features = geojson.get(\"features\", [])\n        values = []\n        for feature in features:\n            props = feature.get(\"properties\", {})\n            val = props.get(column)\n            if val is not None:\n                try:\n                    values.append(float(val))\n                except (TypeError, ValueError):\n                    pass\n\n        if not values:\n            raise ValueError(f\"No valid numeric values found for column '{column}'\")\n\n        computed_breaks = compute_breaks(values, classification, k, breaks)\n\n        colors = get_choropleth_colors(cmap, k)\n\n        step_expr = build_step_expression(column, computed_breaks, colors)\n\n        bounds = get_bounds(geojson) if fit_bounds else None\n\n        self.call_js_method(\n            \"addChoropleth\",\n            data=geojson,\n            name=layer_name,\n            column=column,\n            stepExpression=step_expr,\n            fillOpacity=fill_opacity,\n            lineColor=line_color,\n            lineWidth=line_width,\n            hover=hover,\n            fitBounds=fit_bounds,\n            bounds=bounds,\n            **kwargs,\n        )\n\n        self._layers = {\n            **self._layers,\n            layer_name: {\n                \"id\": layer_name,\n                \"type\": \"choropleth\",\n                \"source\": f\"{layer_name}-source\",\n                \"column\": column,\n            },\n        }\n        self._add_to_layer_dict(layer_name, \"Vector\")\n\n        if legend:\n            title = legend_title or column\n            labels = []\n            for i in range(len(computed_breaks) - 1):\n                low = computed_breaks[i]\n                high = computed_breaks[i + 1]\n                labels.append(f\"{low:.1f} - {high:.1f}\")\n\n            self.add_legend(\n                title=title,\n                labels=labels,\n                colors=colors,\n                position=\"bottom-right\",\n            )\n\n    def add_3d_buildings(\n        self,\n        source: str = \"openmaptiles\",\n        min_zoom: float = 14,\n        fill_extrusion_color: str = \"#aaa\",\n        fill_extrusion_opacity: float = 0.6,\n        height_property: str = \"render_height\",\n        base_property: str = \"render_min_height\",\n        layer_id: Optional[str] = None,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add 3D building extrusions from vector tiles.\"\"\"\n        layer_name = layer_id or \"3d-buildings\"\n\n        self.call_js_method(\n            \"add3DBuildings\",\n            source=source,\n            minZoom=min_zoom,\n            fillExtrusionColor=fill_extrusion_color,\n            fillExtrusionOpacity=fill_extrusion_opacity,\n            heightProperty=height_property,\n            baseProperty=base_property,\n            layerId=layer_name,\n            **kwargs,\n        )\n\n        self._layers = {\n            **self._layers,\n            layer_name: {\n                \"id\": layer_name,\n                \"type\": \"fill-extrusion\",\n            },\n        }\n        self._add_to_layer_dict(layer_name, \"Vector\")\n\n    def animate_along_route(\n        self,\n        route: Any,\n        duration: int = 10000,\n        loop: bool = True,\n        marker_color: str = \"#3388ff\",\n        marker_size: float = 1.0,\n        show_trail: bool = False,\n        trail_color: str = \"#3388ff\",\n        trail_width: float = 3,\n        animation_id: Optional[str] = None,\n        **kwargs,\n    ) -&gt; str:\n        \"\"\"Animate a marker along a route.\"\"\"\n        anim_id = animation_id or f\"animation-{len(self._layers)}\"\n\n        if isinstance(route, list) and len(route) &gt; 0:\n            if isinstance(route[0], (list, tuple)):\n                coordinates = route\n            else:\n                raise ValueError(\"Route list must contain coordinate pairs\")\n        elif isinstance(route, dict):\n            if route.get(\"type\") == \"LineString\":\n                coordinates = route.get(\"coordinates\", [])\n            elif route.get(\"type\") == \"Feature\":\n                geometry = route.get(\"geometry\", {})\n                if geometry.get(\"type\") == \"LineString\":\n                    coordinates = geometry.get(\"coordinates\", [])\n                else:\n                    raise ValueError(\"Feature geometry must be LineString\")\n            elif route.get(\"type\") == \"FeatureCollection\":\n                features = route.get(\"features\", [])\n                if (\n                    features\n                    and features[0].get(\"geometry\", {}).get(\"type\") == \"LineString\"\n                ):\n                    coordinates = features[0][\"geometry\"][\"coordinates\"]\n                else:\n                    raise ValueError(\n                        \"FeatureCollection must contain LineString features\"\n                    )\n            else:\n                raise ValueError(\n                    \"GeoJSON must be LineString, Feature, or FeatureCollection\"\n                )\n        else:\n            geojson = to_geojson(route)\n            if geojson.get(\"type\") == \"url\":\n                geojson = fetch_geojson(geojson[\"url\"])\n            if geojson.get(\"type\") == \"FeatureCollection\":\n                features = geojson.get(\"features\", [])\n                if features:\n                    coordinates = features[0].get(\"geometry\", {}).get(\"coordinates\", [])\n                else:\n                    raise ValueError(\"No features found in data\")\n            elif geojson.get(\"type\") == \"Feature\":\n                coordinates = geojson.get(\"geometry\", {}).get(\"coordinates\", [])\n            else:\n                coordinates = geojson.get(\"coordinates\", [])\n\n        if len(coordinates) &lt; 2:\n            raise ValueError(\"Route must have at least 2 points\")\n\n        self.call_js_method(\n            \"animateAlongRoute\",\n            id=anim_id,\n            coordinates=coordinates,\n            duration=duration,\n            loop=loop,\n            markerColor=marker_color,\n            markerSize=marker_size,\n            showTrail=show_trail,\n            trailColor=trail_color,\n            trailWidth=trail_width,\n            **kwargs,\n        )\n\n        self._layers = {\n            **self._layers,\n            anim_id: {\n                \"id\": anim_id,\n                \"type\": \"animation\",\n            },\n        }\n        return anim_id\n\n    def stop_animation(self, animation_id: str) -&gt; None:\n        \"\"\"Stop a running animation.\"\"\"\n        self.call_js_method(\"stopAnimation\", animation_id)\n        if animation_id in self._layers:\n            layers = dict(self._layers)\n            del layers[animation_id]\n            self._layers = layers\n\n    def pause_animation(self, animation_id: str) -&gt; None:\n        \"\"\"Pause a running animation.\"\"\"\n        self.call_js_method(\"pauseAnimation\", animation_id)\n\n    def resume_animation(self, animation_id: str) -&gt; None:\n        \"\"\"Resume a paused animation.\"\"\"\n        self.call_js_method(\"resumeAnimation\", animation_id)\n\n    def set_animation_speed(self, animation_id: str, speed: float) -&gt; None:\n        \"\"\"Set animation speed multiplier.\"\"\"\n        self.call_js_method(\"setAnimationSpeed\", animation_id, speed)\n\n    def add_hover_effect(\n        self,\n        layer_id: str,\n        highlight_color: Optional[str] = None,\n        highlight_opacity: Optional[float] = None,\n        highlight_outline_width: float = 2,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add hover highlight effect to an existing layer.\"\"\"\n        self.call_js_method(\n            \"addHoverEffect\",\n            layerId=layer_id,\n            highlightColor=highlight_color,\n            highlightOpacity=highlight_opacity,\n            highlightOutlineWidth=highlight_outline_width,\n            **kwargs,\n        )\n\n    def set_fog(\n        self,\n        color: Optional[str] = None,\n        high_color: Optional[str] = None,\n        low_color: Optional[str] = None,\n        horizon_blend: Optional[float] = None,\n        range: Optional[List[float]] = None,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Set fog atmospheric effect (Mapbox uses map.setFog() API).\"\"\"\n        self.call_js_method(\n            \"setFog\",\n            color=color,\n            highColor=high_color,\n            lowColor=low_color,\n            horizonBlend=horizon_blend,\n            range=range,\n            **kwargs,\n        )\n\n    def remove_fog(self) -&gt; None:\n        \"\"\"Remove fog atmospheric effects from the map.\"\"\"\n        self.call_js_method(\"removeFog\")\n\n    def add_image_layer(\n        self,\n        url: str,\n        coordinates: List[List[float]],\n        name: Optional[str] = None,\n        opacity: float = 1.0,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a georeferenced image overlay.\"\"\"\n        self._validate_opacity(opacity)\n        layer_id = name or f\"image-{len(self._layers)}\"\n\n        if len(coordinates) != 4:\n            raise ValueError(\n                \"coordinates must have exactly 4 corner points \"\n                \"[top-left, top-right, bottom-right, bottom-left]\"\n            )\n\n        self.call_js_method(\n            \"addImageLayer\",\n            id=layer_id,\n            url=url,\n            coordinates=coordinates,\n            opacity=opacity,\n            **kwargs,\n        )\n\n        self._layers = {\n            **self._layers,\n            layer_id: {\n                \"id\": layer_id,\n                \"type\": \"image\",\n                \"url\": url,\n                \"coordinates\": coordinates,\n            },\n        }\n        self._add_to_layer_dict(layer_id, \"Raster\")\n\n    def add_video_layer(\n        self,\n        urls: List[str],\n        coordinates: List[List[float]],\n        name: Optional[str] = None,\n        opacity: float = 1.0,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a georeferenced video overlay on the map.\"\"\"\n        self._validate_opacity(opacity)\n        layer_id = name or f\"video-{len(self._layers)}\"\n\n        if len(coordinates) != 4:\n            raise ValueError(\n                \"coordinates must have exactly 4 corner points \"\n                \"[top-left, top-right, bottom-right, bottom-left]\"\n            )\n\n        self.call_js_method(\n            \"addVideoLayer\",\n            id=layer_id,\n            urls=urls,\n            coordinates=coordinates,\n            opacity=opacity,\n            **kwargs,\n        )\n\n        self._layers = {\n            **self._layers,\n            layer_id: {\n                \"id\": layer_id,\n                \"type\": \"video\",\n                \"source\": f\"{layer_id}-source\",\n            },\n        }\n        self._add_to_layer_dict(layer_id, \"Raster\")\n\n    def remove_video_layer(self, name: str) -&gt; None:\n        \"\"\"Remove a video layer from the map.\"\"\"\n        if name in self._layers:\n            layers = dict(self._layers)\n            del layers[name]\n            self._layers = layers\n        self._remove_from_layer_dict(name)\n        self.call_js_method(\"removeVideoLayer\", id=name)\n\n    def play_video(self, name: str) -&gt; None:\n        \"\"\"Start playing a video layer.\"\"\"\n        self.call_js_method(\"playVideo\", id=name)\n\n    def pause_video(self, name: str) -&gt; None:\n        \"\"\"Pause a video layer.\"\"\"\n        self.call_js_method(\"pauseVideo\", id=name)\n\n    def seek_video(self, name: str, time: float) -&gt; None:\n        \"\"\"Seek to a specific time in a video layer.\"\"\"\n        self.call_js_method(\"seekVideo\", id=name, time=time)\n\n    def add_split_map(\n        self,\n        left_layer: str,\n        right_layer: str,\n        position: int = 50,\n    ) -&gt; None:\n        \"\"\"Add a split map comparison view with a draggable divider.\"\"\"\n        if not 0 &lt;= position &lt;= 100:\n            raise ValueError(f\"position must be between 0 and 100, got {position}\")\n\n        self.call_js_method(\n            \"addSplitMap\",\n            leftLayer=left_layer,\n            rightLayer=right_layer,\n            position=position,\n        )\n\n    def remove_split_map(self) -&gt; None:\n        \"\"\"Remove the split map comparison view.\"\"\"\n        self.call_js_method(\"removeSplitMap\")\n\n    def set_projection(self, projection: str = \"mercator\") -&gt; None:\n        \"\"\"Set the map projection (Mapbox supports 'globe' and 'mercator').\"\"\"\n        self.call_js_method(\"setProjection\", projection=projection)\n\n    def update_geojson_source(self, source_id: str, data: Any) -&gt; None:\n        \"\"\"Update the data of an existing GeoJSON source in place.\"\"\"\n        processed_data = self._process_deck_data(data)\n        self.call_js_method(\n            \"updateGeoJSONSource\",\n            sourceId=source_id,\n            data=processed_data,\n        )\n\n    def add_image(self, name: str, url: str) -&gt; None:\n        \"\"\"Load a custom icon image for use in symbol layers.\"\"\"\n        self.call_js_method(\"addMapImage\", name=name, url=url)\n\n    def add_swipe_map(self, left_layer: str, right_layer: str) -&gt; None:\n        \"\"\"Add a drag-to-compare swipe control for two layers.\"\"\"\n        self.call_js_method(\n            \"addSwipeMap\",\n            leftLayer=left_layer,\n            rightLayer=right_layer,\n        )\n\n    def remove_swipe_map(self) -&gt; None:\n        \"\"\"Remove the swipe map comparison control.\"\"\"\n        self.call_js_method(\"removeSwipeMap\")\n\n    def set_filter(\n        self,\n        layer_id: str,\n        filter_expression: Optional[List] = None,\n    ) -&gt; None:\n        \"\"\"Set or clear a filter on a map layer.\"\"\"\n        self.call_js_method(\n            \"setFilter\",\n            layerId=layer_id,\n            filter=filter_expression,\n        )\n\n    def query_rendered_features(\n        self,\n        geometry: Optional[Any] = None,\n        layers: Optional[List[str]] = None,\n        filter_expression: Optional[List] = None,\n    ) -&gt; Dict:\n        \"\"\"Query features currently rendered on the map.\"\"\"\n        kwargs: Dict[str, Any] = {}\n        if geometry is not None:\n            kwargs[\"geometry\"] = geometry\n        if layers is not None:\n            kwargs[\"layers\"] = layers\n        if filter_expression is not None:\n            kwargs[\"filter\"] = filter_expression\n\n        self.call_js_method(\"queryRenderedFeatures\", **kwargs)\n        return self._queried_features\n\n    def query_source_features(\n        self,\n        source_id: str,\n        source_layer: Optional[str] = None,\n        filter_expression: Optional[List] = None,\n    ) -&gt; Dict:\n        \"\"\"Query features from a source.\"\"\"\n        kwargs: Dict[str, Any] = {\"sourceId\": source_id}\n        if source_layer is not None:\n            kwargs[\"sourceLayer\"] = source_layer\n        if filter_expression is not None:\n            kwargs[\"filter\"] = filter_expression\n\n        self.call_js_method(\"querySourceFeatures\", **kwargs)\n        return self._queried_features\n\n    @property\n    def queried_features(self) -&gt; Dict:\n        \"\"\"Get the most recent query results.\"\"\"\n        return self._queried_features\n\n    def get_visible_features(\n        self,\n        layers: Optional[List[str]] = None,\n    ) -&gt; Optional[Dict]:\n        \"\"\"Get all features currently visible in the viewport.\"\"\"\n        if layers is not None:\n            self.call_js_method(\"getVisibleFeatures\", layers=layers)\n        features = self._queried_features\n        if features and \"data\" in features:\n            return features[\"data\"]\n        return None\n\n    def to_geojson(self, layer_id: Optional[str] = None) -&gt; Optional[Dict]:\n        \"\"\"Get layer data as GeoJSON.\"\"\"\n        if layer_id:\n            self.call_js_method(\"getLayerData\", sourceId=layer_id)\n        features = self._queried_features\n        if features and \"data\" in features:\n            return features[\"data\"]\n        return None\n\n    def to_geopandas(self, layer_id: Optional[str] = None) -&gt; Any:\n        \"\"\"Get layer data as a GeoDataFrame.\"\"\"\n        geojson = self.to_geojson(layer_id)\n        if geojson is None:\n            return None\n        try:\n            import geopandas as gpd\n\n            return gpd.GeoDataFrame.from_features(geojson.get(\"features\", []))\n        except ImportError:\n            raise ImportError(\"geopandas is required for to_geopandas()\")\n\n    # -------------------------------------------------------------------------\n    # Markers\n    # -------------------------------------------------------------------------\n\n    def add_marker(\n        self,\n        lng: float,\n        lat: float,\n        popup: Optional[str] = None,\n        tooltip: Optional[str] = None,\n        color: str = \"#3388ff\",\n        draggable: bool = False,\n        scale: float = 1.0,\n        popup_max_width: str = \"240px\",\n        tooltip_max_width: str = \"240px\",\n        name: Optional[str] = None,\n        **kwargs,\n    ) -&gt; str:\n        \"\"\"Add a single marker to the map.\"\"\"\n        marker_id = name or f\"marker-{len(self._layers)}\"\n\n        self.call_js_method(\n            \"addMarker\",\n            lng,\n            lat,\n            id=marker_id,\n            popup=popup,\n            tooltip=tooltip,\n            color=color,\n            draggable=draggable,\n            scale=scale,\n            popupMaxWidth=popup_max_width,\n            tooltipMaxWidth=tooltip_max_width,\n            **kwargs,\n        )\n\n        self._layers = {\n            **self._layers,\n            marker_id: {\n                \"id\": marker_id,\n                \"type\": \"marker\",\n                \"lngLat\": [lng, lat],\n            },\n        }\n        self._add_to_layer_dict(marker_id, \"Markers\")\n        return marker_id\n\n    def add_markers(\n        self,\n        data: Any,\n        lng_column: Optional[str] = None,\n        lat_column: Optional[str] = None,\n        popup_column: Optional[str] = None,\n        tooltip_column: Optional[str] = None,\n        color: str = \"#3388ff\",\n        scale: float = 1.0,\n        popup_max_width: str = \"240px\",\n        tooltip_max_width: str = \"240px\",\n        draggable: bool = False,\n        name: Optional[str] = None,\n        **kwargs,\n    ) -&gt; str:\n        \"\"\"Add multiple markers from data.\"\"\"\n        layer_id = name or f\"markers-{len(self._layers)}\"\n        markers = []\n\n        if hasattr(data, \"geometry\"):\n            for _, row in data.iterrows():\n                geom = row.geometry\n                if geom.geom_type == \"Point\":\n                    marker = {\"lngLat\": [geom.x, geom.y]}\n                    if popup_column and popup_column in row:\n                        marker[\"popup\"] = str(row[popup_column])\n                    if tooltip_column and tooltip_column in row:\n                        marker[\"tooltip\"] = str(row[tooltip_column])\n                    markers.append(marker)\n        elif isinstance(data, dict) and data.get(\"type\") == \"FeatureCollection\":\n            for feature in data.get(\"features\", []):\n                geom = feature.get(\"geometry\", {})\n                if geom.get(\"type\") == \"Point\":\n                    coords = geom.get(\"coordinates\", [])\n                    marker = {\"lngLat\": coords[:2]}\n                    props = feature.get(\"properties\", {})\n                    if popup_column and popup_column in props:\n                        marker[\"popup\"] = str(props[popup_column])\n                    if tooltip_column and tooltip_column in props:\n                        marker[\"tooltip\"] = str(props[tooltip_column])\n                    markers.append(marker)\n        elif isinstance(data, list):\n            lng_keys = [\"lng\", \"lon\", \"longitude\", \"x\"]\n            lat_keys = [\"lat\", \"latitude\", \"y\"]\n\n            for item in data:\n                if not isinstance(item, dict):\n                    continue\n\n                lng_val = None\n                lat_val = None\n\n                if lng_column and lng_column in item:\n                    lng_val = item[lng_column]\n                else:\n                    for key in lng_keys:\n                        if key in item:\n                            lng_val = item[key]\n                            break\n\n                if lat_column and lat_column in item:\n                    lat_val = item[lat_column]\n                else:\n                    for key in lat_keys:\n                        if key in item:\n                            lat_val = item[key]\n                            break\n\n                if lng_val is not None and lat_val is not None:\n                    marker = {\"lngLat\": [float(lng_val), float(lat_val)]}\n                    if popup_column and popup_column in item:\n                        marker[\"popup\"] = str(item[popup_column])\n                    if tooltip_column and tooltip_column in item:\n                        marker[\"tooltip\"] = str(item[tooltip_column])\n                    markers.append(marker)\n\n        if not markers:\n            raise ValueError(\"No valid point data found in input\")\n\n        self.call_js_method(\n            \"addMarkers\",\n            id=layer_id,\n            markers=markers,\n            color=color,\n            scale=scale,\n            popupMaxWidth=popup_max_width,\n            tooltipMaxWidth=tooltip_max_width,\n            draggable=draggable,\n            **kwargs,\n        )\n\n        self._layers = {\n            **self._layers,\n            layer_id: {\n                \"id\": layer_id,\n                \"type\": \"markers\",\n                \"count\": len(markers),\n            },\n        }\n        self._add_to_layer_dict(layer_id, \"Markers\")\n        return layer_id\n\n    def remove_marker(self, marker_id: str) -&gt; None:\n        \"\"\"Remove a marker from the map.\"\"\"\n        self._remove_layer_internal(marker_id, \"removeMarker\")\n\n    # -------------------------------------------------------------------------\n    # HTML Export\n    # -------------------------------------------------------------------------\n\n    def _generate_html_template(self) -&gt; str:\n        \"\"\"Generate standalone HTML for the map.\"\"\"\n        template_path = Path(__file__).parent / \"templates\" / \"mapbox.html\"\n\n        if template_path.exists():\n            template = template_path.read_text(encoding=\"utf-8\")\n        else:\n            template = self._get_default_template()\n\n        # Serialize state\n        state = {\n            \"center\": self.center,\n            \"zoom\": self.zoom,\n            \"style\": self.style,\n            \"bearing\": self.bearing,\n            \"pitch\": self.pitch,\n            \"width\": self.width,\n            \"height\": self.height,\n            \"layers\": self._layers,\n            \"sources\": self._sources,\n            \"controls\": self._controls,\n            \"js_calls\": self._js_calls,\n            \"access_token\": self.access_token,\n        }\n\n        template = template.replace(\"{{state}}\", json.dumps(state, indent=2))\n        return template\n\n    def _get_default_template(self) -&gt; str:\n        \"\"\"Get default HTML template.\"\"\"\n        return \"\"\"&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n    &lt;meta charset=\"utf-8\"&gt;\n    &lt;title&gt;{{title}}&lt;/title&gt;\n    &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"&gt;\n    &lt;script src=\"https://api.mapbox.com/mapbox-gl-js/v3.0.0/mapbox-gl.js\"&gt;&lt;/script&gt;\n    &lt;link href=\"https://api.mapbox.com/mapbox-gl-js/v3.0.0/mapbox-gl.css\" rel=\"stylesheet\" /&gt;\n    &lt;style&gt;\n        body { margin: 0; padding: 0; }\n        #map { position: absolute; top: 0; bottom: 0; width: 100%; }\n    &lt;/style&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;div id=\"map\"&gt;&lt;/div&gt;\n    &lt;script&gt;\n        const state = {{state}};\n\n        mapboxgl.accessToken = state.access_token;\n\n        const map = new mapboxgl.Map({\n            container: 'map',\n            style: state.style,\n            center: state.center,\n            zoom: state.zoom,\n            bearing: state.bearing || 0,\n            pitch: state.pitch || 0\n        });\n\n        map.on('load', function() {\n            // Replay JS calls\n            for (const call of state.js_calls || []) {\n                try {\n                    executeMethod(call.method, call.args, call.kwargs);\n                } catch (e) {\n                    console.error('Error executing', call.method, e);\n                }\n            }\n        });\n\n        function executeMethod(method, args, kwargs) {\n            switch (method) {\n                case 'addBasemap':\n                    const url = args[0];\n                    const name = kwargs.name || 'basemap';\n                    const sourceId = 'basemap-' + name;\n                    if (!map.getSource(sourceId)) {\n                        map.addSource(sourceId, {\n                            type: 'raster',\n                            tiles: [url],\n                            tileSize: 256,\n                            attribution: kwargs.attribution || ''\n                        });\n                    }\n                    if (!map.getLayer(sourceId)) {\n                        map.addLayer({\n                            id: sourceId,\n                            type: 'raster',\n                            source: sourceId\n                        });\n                    }\n                    break;\n\n                case 'addGeoJSON':\n                    const layerName = kwargs.name;\n                    const sourceIdGeo = layerName + '-source';\n                    if (!map.getSource(sourceIdGeo)) {\n                        map.addSource(sourceIdGeo, {\n                            type: 'geojson',\n                            data: kwargs.data\n                        });\n                    }\n                    if (!map.getLayer(layerName)) {\n                        map.addLayer({\n                            id: layerName,\n                            type: kwargs.layerType || 'circle',\n                            source: sourceIdGeo,\n                            paint: kwargs.paint || {}\n                        });\n                    }\n                    if (kwargs.fitBounds &amp;&amp; kwargs.bounds) {\n                        map.fitBounds([\n                            [kwargs.bounds[0], kwargs.bounds[1]],\n                            [kwargs.bounds[2], kwargs.bounds[3]]\n                        ], { padding: 50 });\n                    }\n                    break;\n\n                case 'addTileLayer':\n                    const tileUrl = args[0];\n                    const tileName = kwargs.name;\n                    const tileSourceId = tileName + '-source';\n                    if (!map.getSource(tileSourceId)) {\n                        map.addSource(tileSourceId, {\n                            type: 'raster',\n                            tiles: [tileUrl],\n                            tileSize: 256,\n                            attribution: kwargs.attribution || ''\n                        });\n                    }\n                    if (!map.getLayer(tileName)) {\n                        map.addLayer({\n                            id: tileName,\n                            type: 'raster',\n                            source: tileSourceId\n                        });\n                    }\n                    break;\n\n                case 'addControl':\n                    const controlType = args[0];\n                    const position = kwargs.position || 'top-right';\n                    let control;\n                    switch (controlType) {\n                        case 'navigation':\n                            control = new mapboxgl.NavigationControl();\n                            break;\n                        case 'scale':\n                            control = new mapboxgl.ScaleControl();\n                            break;\n                        case 'fullscreen':\n                            control = new mapboxgl.FullscreenControl();\n                            break;\n                    }\n                    if (control) {\n                        map.addControl(control, position);\n                    }\n                    break;\n\n                case 'addTerrain':\n                    const terrainSource = kwargs.source || 'mapbox-dem';\n                    if (!map.getSource(terrainSource)) {\n                        map.addSource(terrainSource, {\n                            type: 'raster-dem',\n                            url: 'mapbox://mapbox.mapbox-terrain-dem-v1',\n                            tileSize: 512,\n                            maxzoom: 14\n                        });\n                    }\n                    map.setTerrain({ source: terrainSource, exaggeration: kwargs.exaggeration || 1 });\n                    break;\n\n                case 'removeTerrain':\n                    map.setTerrain(null);\n                    break;\n\n                case 'flyTo':\n                    map.flyTo({\n                        center: [args[0], args[1]],\n                        zoom: kwargs.zoom,\n                        duration: kwargs.duration || 2000\n                    });\n                    break;\n\n                case 'fitBounds':\n                    const bounds = args[0];\n                    map.fitBounds([\n                        [bounds[0], bounds[1]],\n                        [bounds[2], bounds[3]]\n                    ], {\n                        padding: kwargs.padding || 50,\n                        duration: kwargs.duration || 1000\n                    });\n                    break;\n\n                case 'addMarker':\n                    new mapboxgl.Marker({ color: kwargs.color || '#3388ff' })\n                        .setLngLat([args[0], args[1]])\n                        .addTo(map);\n                    break;\n\n                default:\n                    console.log('Unknown method:', method);\n            }\n        }\n    &lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\"\"\"\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.mapbox.MapboxMap.draw_data","title":"<code>draw_data: Dict</code>  <code>property</code> <code>readonly</code>","text":"<p>Property to access current draw data.</p>"},{"location":"anymap_ts/#anymap_ts.mapbox.MapboxMap.queried_features","title":"<code>queried_features: Dict</code>  <code>property</code> <code>readonly</code>","text":"<p>Get the most recent query results.</p>"},{"location":"anymap_ts/#anymap_ts.mapbox.MapboxMap.__init__","title":"<code>__init__(self, center=(0.0, 0.0), zoom=2.0, width='100%', height='600px', style='mapbox://styles/mapbox/streets-v12', bearing=0.0, pitch=0.0, max_pitch=85.0, access_token=None, controls=None, **kwargs)</code>  <code>special</code>","text":"<p>Initialize a Mapbox map.</p> <p>Parameters:</p> Name Type Description Default <code>center</code> <code>Tuple[float, float]</code> <p>Map center as (longitude, latitude).</p> <code>(0.0, 0.0)</code> <code>zoom</code> <code>float</code> <p>Initial zoom level.</p> <code>2.0</code> <code>width</code> <code>str</code> <p>Map width as CSS string.</p> <code>'100%'</code> <code>height</code> <code>str</code> <p>Map height as CSS string.</p> <code>'600px'</code> <code>style</code> <code>str</code> <p>Mapbox style URL (e.g., \"mapbox://styles/mapbox/streets-v12\").</p> <code>'mapbox://styles/mapbox/streets-v12'</code> <code>bearing</code> <code>float</code> <p>Map bearing in degrees.</p> <code>0.0</code> <code>pitch</code> <code>float</code> <p>Map pitch in degrees.</p> <code>0.0</code> <code>max_pitch</code> <code>float</code> <p>Maximum pitch angle in degrees (default: 85).</p> <code>85.0</code> <code>access_token</code> <code>Optional[str]</code> <p>Mapbox access token. If None, reads from MAPBOX_TOKEN env var.</p> <code>None</code> <code>controls</code> <code>Optional[Dict[str, Any]]</code> <p>Dict of controls to add (e.g., {\"navigation\": True}).</p> <code>None</code> <code>**kwargs</code> <p>Additional widget arguments.</p> <code>{}</code> Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def __init__(\n    self,\n    center: Tuple[float, float] = (0.0, 0.0),\n    zoom: float = 2.0,\n    width: str = \"100%\",\n    height: str = \"600px\",\n    style: str = \"mapbox://styles/mapbox/streets-v12\",\n    bearing: float = 0.0,\n    pitch: float = 0.0,\n    max_pitch: float = 85.0,\n    access_token: Optional[str] = None,\n    controls: Optional[Dict[str, Any]] = None,\n    **kwargs,\n):\n    \"\"\"Initialize a Mapbox map.\n\n    Args:\n        center: Map center as (longitude, latitude).\n        zoom: Initial zoom level.\n        width: Map width as CSS string.\n        height: Map height as CSS string.\n        style: Mapbox style URL (e.g., \"mapbox://styles/mapbox/streets-v12\").\n        bearing: Map bearing in degrees.\n        pitch: Map pitch in degrees.\n        max_pitch: Maximum pitch angle in degrees (default: 85).\n        access_token: Mapbox access token. If None, reads from MAPBOX_TOKEN env var.\n        controls: Dict of controls to add (e.g., {\"navigation\": True}).\n        **kwargs: Additional widget arguments.\n    \"\"\"\n    # Get access token\n    token = access_token or get_mapbox_token()\n    if not token:\n        print(\n            \"Warning: No Mapbox access token provided. \"\n            \"Set MAPBOX_TOKEN environment variable or pass access_token parameter.\"\n        )\n\n    super().__init__(\n        center=list(center),\n        zoom=zoom,\n        width=width,\n        height=height,\n        style=style,\n        bearing=bearing,\n        pitch=pitch,\n        max_pitch=max_pitch,\n        access_token=token,\n        **kwargs,\n    )\n\n    # Initialize layer dictionary\n    self._layer_dict = {\"Background\": []}\n\n    # Add default controls\n    if controls is None:\n        controls = {\"navigation\": True, \"fullscreen\": True}\n\n    for control_name, config in controls.items():\n        if config:\n            self.add_control(\n                control_name, **(config if isinstance(config, dict) else {})\n            )\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.mapbox.MapboxMap.add_3d_buildings","title":"<code>add_3d_buildings(self, source='openmaptiles', min_zoom=14, fill_extrusion_color='#aaa', fill_extrusion_opacity=0.6, height_property='render_height', base_property='render_min_height', layer_id=None, **kwargs)</code>","text":"<p>Add 3D building extrusions from vector tiles.</p> Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def add_3d_buildings(\n    self,\n    source: str = \"openmaptiles\",\n    min_zoom: float = 14,\n    fill_extrusion_color: str = \"#aaa\",\n    fill_extrusion_opacity: float = 0.6,\n    height_property: str = \"render_height\",\n    base_property: str = \"render_min_height\",\n    layer_id: Optional[str] = None,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add 3D building extrusions from vector tiles.\"\"\"\n    layer_name = layer_id or \"3d-buildings\"\n\n    self.call_js_method(\n        \"add3DBuildings\",\n        source=source,\n        minZoom=min_zoom,\n        fillExtrusionColor=fill_extrusion_color,\n        fillExtrusionOpacity=fill_extrusion_opacity,\n        heightProperty=height_property,\n        baseProperty=base_property,\n        layerId=layer_name,\n        **kwargs,\n    )\n\n    self._layers = {\n        **self._layers,\n        layer_name: {\n            \"id\": layer_name,\n            \"type\": \"fill-extrusion\",\n        },\n    }\n    self._add_to_layer_dict(layer_name, \"Vector\")\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.mapbox.MapboxMap.add_3d_terrain","title":"<code>add_3d_terrain(self, exaggeration=1.0, source='mapbox-dem', **kwargs)</code>","text":"<p>Alias for add_terrain for MapLibre compatibility.</p> Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def add_3d_terrain(\n    self, exaggeration: float = 1.0, source: str = \"mapbox-dem\", **kwargs\n) -&gt; None:\n    \"\"\"Alias for add_terrain for MapLibre compatibility.\"\"\"\n    self.add_terrain(exaggeration=exaggeration, source=source)\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.mapbox.MapboxMap.add_arc_layer","title":"<code>add_arc_layer(self, data, name=None, get_source_position='source', get_target_position='target', get_source_color=None, get_target_color=None, get_width=1, get_height=1, great_circle=False, pickable=True, opacity=0.8, **kwargs)</code>","text":"<p>Add an arc layer for origin-destination visualization using deck.gl.</p> <p>Arc layers are ideal for visualizing connections between locations, such as flight routes, migration patterns, or network flows.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>Array of data objects with source/target coordinates. Each object should have source and target positions.</p> required <code>name</code> <code>Optional[str]</code> <p>Layer ID. If None, auto-generated.</p> <code>None</code> <code>get_source_position</code> <code>Union[str, Any]</code> <p>Accessor for source position [lng, lat]. Can be a string (property name) or a value.</p> <code>'source'</code> <code>get_target_position</code> <code>Union[str, Any]</code> <p>Accessor for target position [lng, lat]. Can be a string (property name) or a value.</p> <code>'target'</code> <code>get_source_color</code> <code>Optional[List[int]]</code> <p>Source end color as [r, g, b, a]. Default: [51, 136, 255, 255] (blue).</p> <code>None</code> <code>get_target_color</code> <code>Optional[List[int]]</code> <p>Target end color as [r, g, b, a]. Default: [255, 136, 51, 255] (orange).</p> <code>None</code> <code>get_width</code> <code>Union[float, str]</code> <p>Arc width in pixels. Can be a number or accessor.</p> <code>1</code> <code>get_height</code> <code>float</code> <p>Arc height multiplier. Higher values create more curved arcs.</p> <code>1</code> <code>great_circle</code> <code>bool</code> <p>Whether to draw arcs along great circles.</p> <code>False</code> <code>pickable</code> <code>bool</code> <p>Whether layer responds to hover/click events.</p> <code>True</code> <code>opacity</code> <code>float</code> <p>Layer opacity (0-1).</p> <code>0.8</code> <code>**kwargs</code> <p>Additional ArcLayer props.</p> <code>{}</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from anymap_ts import MapboxMap\n&gt;&gt;&gt; m = MapboxMap()\n&gt;&gt;&gt; arcs = [\n...     {\"source\": [-122.4, 37.8], \"target\": [-73.9, 40.7]},\n...     {\"source\": [-122.4, 37.8], \"target\": [-0.1, 51.5]},\n... ]\n&gt;&gt;&gt; m.add_arc_layer(arcs, name=\"flights\")\n</code></pre> Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def add_arc_layer(\n    self,\n    data: Any,\n    name: Optional[str] = None,\n    get_source_position: Union[str, Any] = \"source\",\n    get_target_position: Union[str, Any] = \"target\",\n    get_source_color: Optional[List[int]] = None,\n    get_target_color: Optional[List[int]] = None,\n    get_width: Union[float, str] = 1,\n    get_height: float = 1,\n    great_circle: bool = False,\n    pickable: bool = True,\n    opacity: float = 0.8,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add an arc layer for origin-destination visualization using deck.gl.\n\n    Arc layers are ideal for visualizing connections between locations,\n    such as flight routes, migration patterns, or network flows.\n\n    Args:\n        data: Array of data objects with source/target coordinates.\n            Each object should have source and target positions.\n        name: Layer ID. If None, auto-generated.\n        get_source_position: Accessor for source position [lng, lat].\n            Can be a string (property name) or a value.\n        get_target_position: Accessor for target position [lng, lat].\n            Can be a string (property name) or a value.\n        get_source_color: Source end color as [r, g, b, a].\n            Default: [51, 136, 255, 255] (blue).\n        get_target_color: Target end color as [r, g, b, a].\n            Default: [255, 136, 51, 255] (orange).\n        get_width: Arc width in pixels. Can be a number or accessor.\n        get_height: Arc height multiplier. Higher values create more curved arcs.\n        great_circle: Whether to draw arcs along great circles.\n        pickable: Whether layer responds to hover/click events.\n        opacity: Layer opacity (0-1).\n        **kwargs: Additional ArcLayer props.\n\n    Example:\n        &gt;&gt;&gt; from anymap_ts import MapboxMap\n        &gt;&gt;&gt; m = MapboxMap()\n        &gt;&gt;&gt; arcs = [\n        ...     {\"source\": [-122.4, 37.8], \"target\": [-73.9, 40.7]},\n        ...     {\"source\": [-122.4, 37.8], \"target\": [-0.1, 51.5]},\n        ... ]\n        &gt;&gt;&gt; m.add_arc_layer(arcs, name=\"flights\")\n    \"\"\"\n    layer_id = name or f\"arc-{len(self._layers)}\"\n    processed_data = self._process_deck_data(data)\n\n    self.call_js_method(\n        \"addArcLayer\",\n        id=layer_id,\n        data=processed_data,\n        getSourcePosition=get_source_position,\n        getTargetPosition=get_target_position,\n        getSourceColor=get_source_color or [51, 136, 255, 255],\n        getTargetColor=get_target_color or [255, 136, 51, 255],\n        getWidth=get_width,\n        getHeight=get_height,\n        greatCircle=great_circle,\n        pickable=pickable,\n        opacity=opacity,\n        **kwargs,\n    )\n\n    self._layers = {\n        **self._layers,\n        layer_id: {\n            \"id\": layer_id,\n            \"type\": \"arc\",\n        },\n    }\n    self._add_to_layer_dict(layer_id, \"Deck.gl\")\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.mapbox.MapboxMap.add_basemap","title":"<code>add_basemap(self, basemap='mapbox://styles/mapbox/streets-v12', attribution=None, **kwargs)</code>","text":"<p>Add a basemap layer.</p> <p>For Mapbox styles, use the style URL format: - \"mapbox://styles/mapbox/streets-v12\" - \"mapbox://styles/mapbox/satellite-v9\" - \"mapbox://styles/mapbox/satellite-streets-v12\" - \"mapbox://styles/mapbox/light-v11\" - \"mapbox://styles/mapbox/dark-v11\" - \"mapbox://styles/mapbox/outdoors-v12\"</p> <p>Or use XYZ tile URLs for custom basemaps.</p> <p>Parameters:</p> Name Type Description Default <code>basemap</code> <code>str</code> <p>Mapbox style URL or XYZ tile URL.</p> <code>'mapbox://styles/mapbox/streets-v12'</code> <code>attribution</code> <code>Optional[str]</code> <p>Custom attribution text.</p> <code>None</code> <code>**kwargs</code> <p>Additional options.</p> <code>{}</code> Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def add_basemap(\n    self,\n    basemap: str = \"mapbox://styles/mapbox/streets-v12\",\n    attribution: Optional[str] = None,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a basemap layer.\n\n    For Mapbox styles, use the style URL format:\n    - \"mapbox://styles/mapbox/streets-v12\"\n    - \"mapbox://styles/mapbox/satellite-v9\"\n    - \"mapbox://styles/mapbox/satellite-streets-v12\"\n    - \"mapbox://styles/mapbox/light-v11\"\n    - \"mapbox://styles/mapbox/dark-v11\"\n    - \"mapbox://styles/mapbox/outdoors-v12\"\n\n    Or use XYZ tile URLs for custom basemaps.\n\n    Args:\n        basemap: Mapbox style URL or XYZ tile URL.\n        attribution: Custom attribution text.\n        **kwargs: Additional options.\n    \"\"\"\n    # If it's a Mapbox style URL, set it as the map style\n    if basemap.startswith(\"mapbox://\"):\n        self.style = basemap\n        return\n\n    # Otherwise, treat as XYZ tile URL\n    try:\n        url, default_attribution = get_basemap_url(basemap)\n    except (ValueError, KeyError):\n        url = basemap\n        default_attribution = \"\"\n\n    self.call_js_method(\n        \"addBasemap\",\n        url,\n        attribution=attribution or default_attribution,\n        name=basemap,\n        **kwargs,\n    )\n\n    # Track in layer dict\n    basemaps = self._layer_dict.get(\"Basemaps\", [])\n    if basemap not in basemaps:\n        self._layer_dict = {\n            **self._layer_dict,\n            \"Basemaps\": basemaps + [basemap],\n        }\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.mapbox.MapboxMap.add_bitmap_layer","title":"<code>add_bitmap_layer(self, image, bounds, name=None, opacity=1.0, visible=True, pickable=False, desaturate=0, transparent_color=None, tint_color=None, **kwargs)</code>","text":"<p>Add a bitmap layer using deck.gl.</p> Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def add_bitmap_layer(\n    self,\n    image: str,\n    bounds: List[float],\n    name: Optional[str] = None,\n    opacity: float = 1.0,\n    visible: bool = True,\n    pickable: bool = False,\n    desaturate: float = 0,\n    transparent_color: Optional[List[int]] = None,\n    tint_color: Optional[List[int]] = None,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a bitmap layer using deck.gl.\"\"\"\n    layer_id = name or f\"bitmap-{len(self._layers)}\"\n\n    self.call_js_method(\n        \"addBitmapLayer\",\n        id=layer_id,\n        image=image,\n        bounds=bounds,\n        opacity=opacity,\n        visible=visible,\n        pickable=pickable,\n        desaturate=desaturate,\n        transparentColor=transparent_color or [0, 0, 0, 0],\n        tintColor=tint_color or [255, 255, 255],\n        **kwargs,\n    )\n\n    self._layers = {**self._layers, layer_id: {\"id\": layer_id, \"type\": \"bitmap\"}}\n    self._add_to_layer_dict(layer_id, \"Deck.gl\")\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.mapbox.MapboxMap.add_choropleth","title":"<code>add_choropleth(self, data, column, cmap='viridis', classification='quantile', k=5, breaks=None, fill_opacity=0.7, line_color='#000000', line_width=1, legend=True, legend_title=None, hover=True, layer_id=None, fit_bounds=True, **kwargs)</code>","text":"<p>Add a choropleth (thematic) map layer.</p> Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def add_choropleth(\n    self,\n    data: Any,\n    column: str,\n    cmap: str = \"viridis\",\n    classification: str = \"quantile\",\n    k: int = 5,\n    breaks: Optional[List[float]] = None,\n    fill_opacity: float = 0.7,\n    line_color: str = \"#000000\",\n    line_width: float = 1,\n    legend: bool = True,\n    legend_title: Optional[str] = None,\n    hover: bool = True,\n    layer_id: Optional[str] = None,\n    fit_bounds: bool = True,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a choropleth (thematic) map layer.\"\"\"\n    from .utils import (\n        get_choropleth_colors,\n        compute_breaks,\n        build_step_expression,\n    )\n\n    layer_name = layer_id or f\"choropleth-{len(self._layers)}\"\n\n    geojson = to_geojson(data)\n\n    if geojson.get(\"type\") == \"url\":\n        url = geojson[\"url\"]\n        geojson = fetch_geojson(url)\n\n    features = geojson.get(\"features\", [])\n    values = []\n    for feature in features:\n        props = feature.get(\"properties\", {})\n        val = props.get(column)\n        if val is not None:\n            try:\n                values.append(float(val))\n            except (TypeError, ValueError):\n                pass\n\n    if not values:\n        raise ValueError(f\"No valid numeric values found for column '{column}'\")\n\n    computed_breaks = compute_breaks(values, classification, k, breaks)\n\n    colors = get_choropleth_colors(cmap, k)\n\n    step_expr = build_step_expression(column, computed_breaks, colors)\n\n    bounds = get_bounds(geojson) if fit_bounds else None\n\n    self.call_js_method(\n        \"addChoropleth\",\n        data=geojson,\n        name=layer_name,\n        column=column,\n        stepExpression=step_expr,\n        fillOpacity=fill_opacity,\n        lineColor=line_color,\n        lineWidth=line_width,\n        hover=hover,\n        fitBounds=fit_bounds,\n        bounds=bounds,\n        **kwargs,\n    )\n\n    self._layers = {\n        **self._layers,\n        layer_name: {\n            \"id\": layer_name,\n            \"type\": \"choropleth\",\n            \"source\": f\"{layer_name}-source\",\n            \"column\": column,\n        },\n    }\n    self._add_to_layer_dict(layer_name, \"Vector\")\n\n    if legend:\n        title = legend_title or column\n        labels = []\n        for i in range(len(computed_breaks) - 1):\n            low = computed_breaks[i]\n            high = computed_breaks[i + 1]\n            labels.append(f\"{low:.1f} - {high:.1f}\")\n\n        self.add_legend(\n            title=title,\n            labels=labels,\n            colors=colors,\n            position=\"bottom-right\",\n        )\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.mapbox.MapboxMap.add_cluster_layer","title":"<code>add_cluster_layer(self, data, cluster_radius=50, cluster_max_zoom=14, cluster_colors=None, cluster_steps=None, cluster_min_radius=15, cluster_max_radius=30, unclustered_color='#11b4da', unclustered_radius=8, show_cluster_count=True, name=None, zoom_on_click=True, fit_bounds=True, **kwargs)</code>","text":"<p>Add a clustered point layer.</p> Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def add_cluster_layer(\n    self,\n    data: Any,\n    cluster_radius: int = 50,\n    cluster_max_zoom: int = 14,\n    cluster_colors: Optional[List[str]] = None,\n    cluster_steps: Optional[List[int]] = None,\n    cluster_min_radius: int = 15,\n    cluster_max_radius: int = 30,\n    unclustered_color: str = \"#11b4da\",\n    unclustered_radius: int = 8,\n    show_cluster_count: bool = True,\n    name: Optional[str] = None,\n    zoom_on_click: bool = True,\n    fit_bounds: bool = True,\n    **kwargs,\n) -&gt; str:\n    \"\"\"Add a clustered point layer.\"\"\"\n    layer_id = name or f\"cluster-{len(self._layers)}\"\n\n    if cluster_colors is None:\n        cluster_colors = [\"#51bbd6\", \"#f1f075\", \"#f28cb1\"]\n    if cluster_steps is None:\n        cluster_steps = [100, 750]\n\n    if len(cluster_steps) != len(cluster_colors) - 1:\n        raise ValueError(\n            f\"cluster_steps must have {len(cluster_colors) - 1} values \"\n            f\"(one less than cluster_colors), got {len(cluster_steps)}\"\n        )\n\n    geojson = to_geojson(data)\n\n    if geojson.get(\"type\") == \"url\":\n        url = geojson[\"url\"]\n        geojson = fetch_geojson(url)\n\n    bounds = get_bounds(geojson) if fit_bounds else None\n\n    self.call_js_method(\n        \"addClusterLayer\",\n        data=geojson,\n        name=layer_id,\n        clusterRadius=cluster_radius,\n        clusterMaxZoom=cluster_max_zoom,\n        clusterColors=cluster_colors,\n        clusterSteps=cluster_steps,\n        clusterMinRadius=cluster_min_radius,\n        clusterMaxRadius=cluster_max_radius,\n        unclusteredColor=unclustered_color,\n        unclusteredRadius=unclustered_radius,\n        showClusterCount=show_cluster_count,\n        zoomOnClick=zoom_on_click,\n        fitBounds=fit_bounds,\n        bounds=bounds,\n        **kwargs,\n    )\n\n    self._layers = {\n        **self._layers,\n        layer_id: {\n            \"id\": layer_id,\n            \"type\": \"cluster\",\n            \"source\": f\"{layer_id}-source\",\n        },\n    }\n    self._add_to_layer_dict(layer_id, \"Vector\")\n    return layer_id\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.mapbox.MapboxMap.add_cog_control","title":"<code>add_cog_control(self, position='top-right', collapsed=True, default_url=None, load_default_url=False, default_opacity=1.0, default_colormap='viridis', default_bands='1', default_rescale_min=0, default_rescale_max=255, **kwargs)</code>","text":"<p>Add a COG layer control.</p> Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def add_cog_control(\n    self,\n    position: str = \"top-right\",\n    collapsed: bool = True,\n    default_url: Optional[str] = None,\n    load_default_url: bool = False,\n    default_opacity: float = 1.0,\n    default_colormap: str = \"viridis\",\n    default_bands: str = \"1\",\n    default_rescale_min: float = 0,\n    default_rescale_max: float = 255,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a COG layer control.\"\"\"\n    self.call_js_method(\n        \"addCogControl\",\n        position=position,\n        collapsed=collapsed,\n        defaultUrl=default_url or \"\",\n        loadDefaultUrl=load_default_url,\n        defaultOpacity=default_opacity,\n        defaultColormap=default_colormap,\n        defaultBands=default_bands,\n        defaultRescaleMin=default_rescale_min,\n        defaultRescaleMax=default_rescale_max,\n        **kwargs,\n    )\n    self._controls = {\n        **self._controls,\n        \"cog-control\": {\"position\": position, \"collapsed\": collapsed},\n    }\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.mapbox.MapboxMap.add_cog_layer","title":"<code>add_cog_layer(self, url, name=None, opacity=1.0, visible=True, debug=False, debug_opacity=0.25, max_error=0.125, fit_bounds=True, before_id=None, **kwargs)</code>","text":"<p>Add a Cloud Optimized GeoTIFF (COG) layer using deck.gl-raster.</p> <p>This method renders COG files directly in the browser using GPU-accelerated deck.gl rendering with automatic reprojection support.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>URL to the Cloud Optimized GeoTIFF file.</p> required <code>name</code> <code>Optional[str]</code> <p>Layer ID. If None, auto-generated.</p> <code>None</code> <code>opacity</code> <code>float</code> <p>Layer opacity (0-1).</p> <code>1.0</code> <code>visible</code> <code>bool</code> <p>Whether layer is visible.</p> <code>True</code> <code>debug</code> <code>bool</code> <p>Show reprojection mesh for debugging.</p> <code>False</code> <code>debug_opacity</code> <code>float</code> <p>Opacity of debug mesh (0-1).</p> <code>0.25</code> <code>max_error</code> <code>float</code> <p>Maximum reprojection error in pixels. Lower values create denser mesh for better accuracy.</p> <code>0.125</code> <code>fit_bounds</code> <code>bool</code> <p>Whether to fit map to COG bounds after loading.</p> <code>True</code> <code>before_id</code> <code>Optional[str]</code> <p>ID of layer to insert before.</p> <code>None</code> <code>**kwargs</code> <p>Additional COGLayer props.</p> <code>{}</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from anymap_ts import MapboxMap\n&gt;&gt;&gt; m = MapboxMap()\n&gt;&gt;&gt; m.add_cog_layer(\n...     \"https://example.com/landcover.tif\",\n...     name=\"landcover\",\n...     opacity=0.8\n... )\n</code></pre> Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def add_cog_layer(\n    self,\n    url: str,\n    name: Optional[str] = None,\n    opacity: float = 1.0,\n    visible: bool = True,\n    debug: bool = False,\n    debug_opacity: float = 0.25,\n    max_error: float = 0.125,\n    fit_bounds: bool = True,\n    before_id: Optional[str] = None,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a Cloud Optimized GeoTIFF (COG) layer using deck.gl-raster.\n\n    This method renders COG files directly in the browser using GPU-accelerated\n    deck.gl rendering with automatic reprojection support.\n\n    Args:\n        url: URL to the Cloud Optimized GeoTIFF file.\n        name: Layer ID. If None, auto-generated.\n        opacity: Layer opacity (0-1).\n        visible: Whether layer is visible.\n        debug: Show reprojection mesh for debugging.\n        debug_opacity: Opacity of debug mesh (0-1).\n        max_error: Maximum reprojection error in pixels. Lower values\n            create denser mesh for better accuracy.\n        fit_bounds: Whether to fit map to COG bounds after loading.\n        before_id: ID of layer to insert before.\n        **kwargs: Additional COGLayer props.\n\n    Example:\n        &gt;&gt;&gt; from anymap_ts import MapboxMap\n        &gt;&gt;&gt; m = MapboxMap()\n        &gt;&gt;&gt; m.add_cog_layer(\n        ...     \"https://example.com/landcover.tif\",\n        ...     name=\"landcover\",\n        ...     opacity=0.8\n        ... )\n    \"\"\"\n    layer_id = name or f\"cog-{len(self._layers)}\"\n\n    self.call_js_method(\n        \"addCOGLayer\",\n        id=layer_id,\n        geotiff=url,\n        opacity=opacity,\n        visible=visible,\n        debug=debug,\n        debugOpacity=debug_opacity,\n        maxError=max_error,\n        fitBounds=fit_bounds,\n        beforeId=before_id,\n        **kwargs,\n    )\n\n    self._layers = {\n        **self._layers,\n        layer_id: {\n            \"id\": layer_id,\n            \"type\": \"cog\",\n            \"url\": url,\n        },\n    }\n    self._add_to_layer_dict(layer_id, \"Raster\")\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.mapbox.MapboxMap.add_colorbar","title":"<code>add_colorbar(self, colormap='viridis', vmin=0, vmax=1, label='', units='', orientation='horizontal', position='bottom-right', bar_thickness=None, bar_length=None, ticks=None, opacity=None, colorbar_id=None, **kwargs)</code>","text":"<p>Add a continuous gradient colorbar to the map.</p> Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def add_colorbar(\n    self,\n    colormap: str = \"viridis\",\n    vmin: float = 0,\n    vmax: float = 1,\n    label: str = \"\",\n    units: str = \"\",\n    orientation: str = \"horizontal\",\n    position: str = \"bottom-right\",\n    bar_thickness: Optional[int] = None,\n    bar_length: Optional[int] = None,\n    ticks: Optional[Dict] = None,\n    opacity: Optional[float] = None,\n    colorbar_id: Optional[str] = None,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a continuous gradient colorbar to the map.\"\"\"\n    self._validate_position(position)\n\n    cbar_id = (\n        colorbar_id\n        or f\"colorbar-{len([k for k in self._controls.keys() if k.startswith('colorbar')])}\"\n    )\n\n    js_kwargs: Dict[str, Any] = {\n        \"colormap\": colormap,\n        \"vmin\": vmin,\n        \"vmax\": vmax,\n        \"label\": label,\n        \"units\": units,\n        \"orientation\": orientation,\n        \"position\": position,\n        \"colorbarId\": cbar_id,\n        **kwargs,\n    }\n    if bar_thickness is not None:\n        js_kwargs[\"barThickness\"] = bar_thickness\n    if bar_length is not None:\n        js_kwargs[\"barLength\"] = bar_length\n    if ticks is not None:\n        js_kwargs[\"ticks\"] = ticks\n    if opacity is not None:\n        js_kwargs[\"opacity\"] = opacity\n\n    self.call_js_method(\"addColorbar\", **js_kwargs)\n\n    self._controls = {\n        **self._controls,\n        cbar_id: {\n            \"type\": \"colorbar\",\n            \"colormap\": colormap,\n            \"vmin\": vmin,\n            \"vmax\": vmax,\n            \"label\": label,\n            \"units\": units,\n            \"orientation\": orientation,\n            \"position\": position,\n        },\n    }\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.mapbox.MapboxMap.add_column_layer","title":"<code>add_column_layer(self, data, name=None, get_position='coordinates', get_fill_color=None, get_line_color=None, get_elevation=1000, radius=1000, disk_resolution=20, elevation_scale=1, coverage=1, extruded=True, filled=True, stroked=False, wireframe=False, pickable=True, opacity=0.8, **kwargs)</code>","text":"<p>Add a column layer using deck.gl.</p> Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def add_column_layer(\n    self,\n    data: Any,\n    name: Optional[str] = None,\n    get_position: Union[str, Any] = \"coordinates\",\n    get_fill_color: Optional[Union[List[int], str]] = None,\n    get_line_color: Optional[Union[List[int], str]] = None,\n    get_elevation: Union[float, str] = 1000,\n    radius: float = 1000,\n    disk_resolution: int = 20,\n    elevation_scale: float = 1,\n    coverage: float = 1,\n    extruded: bool = True,\n    filled: bool = True,\n    stroked: bool = False,\n    wireframe: bool = False,\n    pickable: bool = True,\n    opacity: float = 0.8,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a column layer using deck.gl.\"\"\"\n    layer_id = name or f\"column-{len(self._layers)}\"\n    processed_data = self._process_deck_data(data)\n\n    self.call_js_method(\n        \"addColumnLayer\",\n        id=layer_id,\n        data=processed_data,\n        getPosition=get_position,\n        getFillColor=get_fill_color or [255, 140, 0, 200],\n        getLineColor=get_line_color or [0, 0, 0, 255],\n        getElevation=get_elevation,\n        radius=radius,\n        diskResolution=disk_resolution,\n        elevationScale=elevation_scale,\n        coverage=coverage,\n        extruded=extruded,\n        filled=filled,\n        stroked=stroked,\n        wireframe=wireframe,\n        pickable=pickable,\n        opacity=opacity,\n        **kwargs,\n    )\n\n    self._layers = {**self._layers, layer_id: {\"id\": layer_id, \"type\": \"column\"}}\n    self._add_to_layer_dict(layer_id, \"Deck.gl\")\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.mapbox.MapboxMap.add_contour_layer","title":"<code>add_contour_layer(self, data, name=None, get_position='coordinates', get_weight=1, cell_size=200, contours=None, pickable=True, opacity=1, **kwargs)</code>","text":"<p>Add a contour layer using deck.gl.</p> Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def add_contour_layer(\n    self,\n    data: Any,\n    name: Optional[str] = None,\n    get_position: Union[str, Any] = \"coordinates\",\n    get_weight: Union[float, str] = 1,\n    cell_size: float = 200,\n    contours: Optional[List[Dict]] = None,\n    pickable: bool = True,\n    opacity: float = 1,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a contour layer using deck.gl.\"\"\"\n    layer_id = name or f\"contour-{len(self._layers)}\"\n    processed_data = self._process_deck_data(data)\n\n    default_contours = [\n        {\"threshold\": 1, \"color\": [255, 255, 255], \"strokeWidth\": 1},\n        {\"threshold\": 5, \"color\": [51, 136, 255], \"strokeWidth\": 2},\n        {\"threshold\": 10, \"color\": [0, 0, 255], \"strokeWidth\": 3},\n    ]\n\n    self.call_js_method(\n        \"addContourLayer\",\n        id=layer_id,\n        data=processed_data,\n        getPosition=get_position,\n        getWeight=get_weight,\n        cellSize=cell_size,\n        contours=contours or default_contours,\n        pickable=pickable,\n        opacity=opacity,\n        **kwargs,\n    )\n\n    self._layers = {**self._layers, layer_id: {\"id\": layer_id, \"type\": \"contour\"}}\n    self._add_to_layer_dict(layer_id, \"Deck.gl\")\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.mapbox.MapboxMap.add_control","title":"<code>add_control(self, control_type, position='top-right', **kwargs)</code>","text":"<p>Add a map control.</p> <p>Parameters:</p> Name Type Description Default <code>control_type</code> <code>str</code> <p>Type of control ('navigation', 'scale', 'fullscreen', etc.).</p> required <code>position</code> <code>str</code> <p>Control position.</p> <code>'top-right'</code> <code>**kwargs</code> <p>Control-specific options.</p> <code>{}</code> Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def add_control(\n    self,\n    control_type: str,\n    position: str = \"top-right\",\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a map control.\n\n    Args:\n        control_type: Type of control ('navigation', 'scale', 'fullscreen', etc.).\n        position: Control position.\n        **kwargs: Control-specific options.\n    \"\"\"\n    self.call_js_method(\"addControl\", control_type, position=position, **kwargs)\n    self._controls = {\n        **self._controls,\n        control_type: {\"type\": control_type, \"position\": position, **kwargs},\n    }\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.mapbox.MapboxMap.add_control_grid","title":"<code>add_control_grid(self, position='top-right', default_controls=None, exclude=None, rows=None, columns=None, collapsed=True, collapsible=True, title='', show_row_column_controls=True, gap=2, basemap_style_url=None, exclude_layers=None, **kwargs)</code>","text":"<p>Add a ControlGrid with all default tools or a custom subset.</p> Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def add_control_grid(\n    self,\n    position: str = \"top-right\",\n    default_controls: Optional[List[str]] = None,\n    exclude: Optional[List[str]] = None,\n    rows: Optional[int] = None,\n    columns: Optional[int] = None,\n    collapsed: bool = True,\n    collapsible: bool = True,\n    title: str = \"\",\n    show_row_column_controls: bool = True,\n    gap: int = 2,\n    basemap_style_url: Optional[str] = None,\n    exclude_layers: Optional[List[str]] = None,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a ControlGrid with all default tools or a custom subset.\"\"\"\n    js_kwargs: Dict[str, Any] = {\n        \"position\": position,\n        \"collapsed\": collapsed,\n        \"collapsible\": collapsible,\n        \"showRowColumnControls\": show_row_column_controls,\n        \"gap\": gap,\n        **kwargs,\n    }\n    if default_controls is not None:\n        js_kwargs[\"defaultControls\"] = default_controls\n    if exclude is not None:\n        js_kwargs[\"exclude\"] = exclude\n    if rows is not None:\n        js_kwargs[\"rows\"] = rows\n    if columns is not None:\n        js_kwargs[\"columns\"] = columns\n    if title:\n        js_kwargs[\"title\"] = title\n    if basemap_style_url is not None:\n        js_kwargs[\"basemapStyleUrl\"] = basemap_style_url\n    if exclude_layers is not None:\n        js_kwargs[\"excludeLayers\"] = exclude_layers\n\n    self.call_js_method(\"addControlGrid\", **js_kwargs)\n    self._controls = {\n        **self._controls,\n        \"control-grid\": {\n            \"position\": position,\n            \"collapsed\": collapsed,\n            \"collapsible\": collapsible,\n        },\n    }\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.mapbox.MapboxMap.add_coordinates_control","title":"<code>add_coordinates_control(self, position='bottom-left', precision=4)</code>","text":"<p>Add a coordinates display control.</p> Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def add_coordinates_control(\n    self,\n    position: str = \"bottom-left\",\n    precision: int = 4,\n) -&gt; None:\n    \"\"\"Add a coordinates display control.\"\"\"\n    self.call_js_method(\n        \"addCoordinatesControl\",\n        position=position,\n        precision=precision,\n    )\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.mapbox.MapboxMap.add_deck_heatmap_layer","title":"<code>add_deck_heatmap_layer(self, data, name=None, get_position='coordinates', get_weight=1, radius_pixels=30, intensity=1, threshold=0.05, color_range=None, opacity=1, **kwargs)</code>","text":"<p>Add a GPU-accelerated heatmap layer using deck.gl.</p> Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def add_deck_heatmap_layer(\n    self,\n    data: Any,\n    name: Optional[str] = None,\n    get_position: Union[str, Any] = \"coordinates\",\n    get_weight: Union[float, str] = 1,\n    radius_pixels: float = 30,\n    intensity: float = 1,\n    threshold: float = 0.05,\n    color_range: Optional[List[List[int]]] = None,\n    opacity: float = 1,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a GPU-accelerated heatmap layer using deck.gl.\"\"\"\n    layer_id = name or f\"deck-heatmap-{len(self._layers)}\"\n    processed_data = self._process_deck_data(data)\n\n    default_color_range = [\n        [255, 255, 178, 25],\n        [254, 217, 118, 85],\n        [254, 178, 76, 127],\n        [253, 141, 60, 170],\n        [240, 59, 32, 212],\n        [189, 0, 38, 255],\n    ]\n\n    self.call_js_method(\n        \"addHeatmapLayer\",\n        id=layer_id,\n        data=processed_data,\n        getPosition=get_position,\n        getWeight=get_weight,\n        radiusPixels=radius_pixels,\n        intensity=intensity,\n        threshold=threshold,\n        colorRange=color_range or default_color_range,\n        opacity=opacity,\n        **kwargs,\n    )\n\n    self._layers = {\n        **self._layers,\n        layer_id: {\"id\": layer_id, \"type\": \"deck-heatmap\"},\n    }\n    self._add_to_layer_dict(layer_id, \"Deck.gl\")\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.mapbox.MapboxMap.add_deckgl_layer","title":"<code>add_deckgl_layer(self, layer_type, data, name=None, **kwargs)</code>","text":"<p>Add a generic deck.gl layer to the map.</p> Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def add_deckgl_layer(\n    self,\n    layer_type: str,\n    data: Any,\n    name: Optional[str] = None,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a generic deck.gl layer to the map.\"\"\"\n    layer_type_clean = layer_type.replace(\"Layer\", \"\")\n    prefix = layer_type_clean.lower()\n    layer_id = name or f\"{prefix}-{len(self._layers)}\"\n    processed_data = self._process_deck_data(data)\n\n    self.call_js_method(\n        \"addDeckGLLayer\",\n        layerType=layer_type,\n        id=layer_id,\n        data=processed_data,\n        **kwargs,\n    )\n\n    self._layers = {**self._layers, layer_id: {\"id\": layer_id, \"type\": layer_type}}\n    self._add_to_layer_dict(layer_id, \"Deck.gl\")\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.mapbox.MapboxMap.add_draw_control","title":"<code>add_draw_control(self, position='top-right', draw_modes=None, edit_modes=None, collapsed=False, **kwargs)</code>","text":"<p>Add a drawing control.</p> Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def add_draw_control(\n    self,\n    position: str = \"top-right\",\n    draw_modes: Optional[List[str]] = None,\n    edit_modes: Optional[List[str]] = None,\n    collapsed: bool = False,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a drawing control.\"\"\"\n    if draw_modes is None:\n        draw_modes = [\"polygon\", \"line\", \"rectangle\", \"circle\", \"marker\"]\n    if edit_modes is None:\n        edit_modes = [\"select\", \"drag\", \"change\", \"rotate\", \"delete\"]\n\n    self.call_js_method(\n        \"addDrawControl\",\n        position=position,\n        drawModes=draw_modes,\n        editModes=edit_modes,\n        collapsed=collapsed,\n        **kwargs,\n    )\n    self._controls = {\n        **self._controls,\n        \"draw-control\": {\n            \"position\": position,\n            \"drawModes\": draw_modes,\n            \"editModes\": edit_modes,\n        },\n    }\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.mapbox.MapboxMap.add_flatgeobuf","title":"<code>add_flatgeobuf(self, url, name=None, layer_type=None, paint=None, fit_bounds=True, **kwargs)</code>","text":"<p>Add a FlatGeobuf layer from a URL.</p> Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def add_flatgeobuf(\n    self,\n    url: str,\n    name: Optional[str] = None,\n    layer_type: Optional[str] = None,\n    paint: Optional[Dict] = None,\n    fit_bounds: bool = True,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a FlatGeobuf layer from a URL.\"\"\"\n    layer_id = name or f\"flatgeobuf-{len(self._layers)}\"\n\n    self.call_js_method(\n        \"addFlatGeobuf\",\n        url=url,\n        name=layer_id,\n        layerType=layer_type,\n        paint=paint,\n        fitBounds=fit_bounds,\n        **kwargs,\n    )\n\n    self._layers = {\n        **self._layers,\n        layer_id: {\n            \"id\": layer_id,\n            \"type\": \"flatgeobuf\",\n            \"url\": url,\n        },\n    }\n    self._add_to_layer_dict(layer_id, \"Vector\")\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.mapbox.MapboxMap.add_geojson","title":"<code>add_geojson(self, data, layer_type=None, paint=None, name=None, fit_bounds=True, **kwargs)</code>","text":"<p>Add GeoJSON data to the map.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Union[str, Dict]</code> <p>GeoJSON dict or URL to GeoJSON file.</p> required <code>layer_type</code> <code>Optional[str]</code> <p>Mapbox layer type.</p> <code>None</code> <code>paint</code> <code>Optional[Dict]</code> <p>Mapbox paint properties.</p> <code>None</code> <code>name</code> <code>Optional[str]</code> <p>Layer name.</p> <code>None</code> <code>fit_bounds</code> <code>bool</code> <p>Whether to fit map to data bounds.</p> <code>True</code> <code>**kwargs</code> <p>Additional layer options.</p> <code>{}</code> Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def add_geojson(\n    self,\n    data: Union[str, Dict],\n    layer_type: Optional[str] = None,\n    paint: Optional[Dict] = None,\n    name: Optional[str] = None,\n    fit_bounds: bool = True,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add GeoJSON data to the map.\n\n    Args:\n        data: GeoJSON dict or URL to GeoJSON file.\n        layer_type: Mapbox layer type.\n        paint: Mapbox paint properties.\n        name: Layer name.\n        fit_bounds: Whether to fit map to data bounds.\n        **kwargs: Additional layer options.\n    \"\"\"\n    self.add_vector(\n        data,\n        layer_type=layer_type,\n        paint=paint,\n        name=name,\n        fit_bounds=fit_bounds,\n        **kwargs,\n    )\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.mapbox.MapboxMap.add_geojson_layer","title":"<code>add_geojson_layer(self, data, name=None, get_fill_color=None, get_line_color=None, get_line_width=1, get_point_radius=5, get_elevation=0, extruded=False, wireframe=False, filled=True, stroked=True, line_width_min_pixels=1, point_radius_min_pixels=2, pickable=True, opacity=0.8, **kwargs)</code>","text":"<p>Add a GeoJSON layer with auto-styling using deck.gl.</p> Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def add_geojson_layer(\n    self,\n    data: Any,\n    name: Optional[str] = None,\n    get_fill_color: Optional[Union[List[int], str]] = None,\n    get_line_color: Optional[Union[List[int], str]] = None,\n    get_line_width: Union[float, str] = 1,\n    get_point_radius: Union[float, str] = 5,\n    get_elevation: Union[float, str] = 0,\n    extruded: bool = False,\n    wireframe: bool = False,\n    filled: bool = True,\n    stroked: bool = True,\n    line_width_min_pixels: float = 1,\n    point_radius_min_pixels: float = 2,\n    pickable: bool = True,\n    opacity: float = 0.8,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a GeoJSON layer with auto-styling using deck.gl.\"\"\"\n    layer_id = name or f\"geojson-deck-{len(self._layers)}\"\n    processed_data = self._process_deck_data(data)\n\n    self.call_js_method(\n        \"addGeoJsonLayer\",\n        id=layer_id,\n        data=processed_data,\n        getFillColor=get_fill_color or [51, 136, 255, 128],\n        getLineColor=get_line_color or [0, 0, 0, 255],\n        getLineWidth=get_line_width,\n        getPointRadius=get_point_radius,\n        getElevation=get_elevation,\n        extruded=extruded,\n        wireframe=wireframe,\n        filled=filled,\n        stroked=stroked,\n        lineWidthMinPixels=line_width_min_pixels,\n        pointRadiusMinPixels=point_radius_min_pixels,\n        pickable=pickable,\n        opacity=opacity,\n        **kwargs,\n    )\n\n    self._layers = {\n        **self._layers,\n        layer_id: {\"id\": layer_id, \"type\": \"geojson-deck\"},\n    }\n    self._add_to_layer_dict(layer_id, \"Deck.gl\")\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.mapbox.MapboxMap.add_grid_cell_layer","title":"<code>add_grid_cell_layer(self, data, name=None, get_position='coordinates', get_color=None, get_elevation=1000, cell_size=200, coverage=1, elevation_scale=1, extruded=True, pickable=True, opacity=0.8, **kwargs)</code>","text":"<p>Add a grid cell layer using deck.gl.</p> Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def add_grid_cell_layer(\n    self,\n    data: Any,\n    name: Optional[str] = None,\n    get_position: Union[str, Any] = \"coordinates\",\n    get_color: Optional[Union[List[int], str]] = None,\n    get_elevation: Union[float, str] = 1000,\n    cell_size: float = 200,\n    coverage: float = 1,\n    elevation_scale: float = 1,\n    extruded: bool = True,\n    pickable: bool = True,\n    opacity: float = 0.8,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a grid cell layer using deck.gl.\"\"\"\n    layer_id = name or f\"gridcell-{len(self._layers)}\"\n    processed_data = self._process_deck_data(data)\n\n    self.call_js_method(\n        \"addGridCellLayer\",\n        id=layer_id,\n        data=processed_data,\n        getPosition=get_position,\n        getColor=get_color or [255, 140, 0, 200],\n        getElevation=get_elevation,\n        cellSize=cell_size,\n        coverage=coverage,\n        elevationScale=elevation_scale,\n        extruded=extruded,\n        pickable=pickable,\n        opacity=opacity,\n        **kwargs,\n    )\n\n    self._layers = {\n        **self._layers,\n        layer_id: {\"id\": layer_id, \"type\": \"gridcell\"},\n    }\n    self._add_to_layer_dict(layer_id, \"Deck.gl\")\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.mapbox.MapboxMap.add_grid_layer","title":"<code>add_grid_layer(self, data, name=None, get_position='coordinates', cell_size=200, elevation_scale=4, extruded=True, color_range=None, pickable=True, opacity=0.8, **kwargs)</code>","text":"<p>Add a grid layer using deck.gl.</p> Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def add_grid_layer(\n    self,\n    data: Any,\n    name: Optional[str] = None,\n    get_position: Union[str, Any] = \"coordinates\",\n    cell_size: float = 200,\n    elevation_scale: float = 4,\n    extruded: bool = True,\n    color_range: Optional[List[List[int]]] = None,\n    pickable: bool = True,\n    opacity: float = 0.8,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a grid layer using deck.gl.\"\"\"\n    layer_id = name or f\"grid-{len(self._layers)}\"\n    processed_data = self._process_deck_data(data)\n\n    default_color_range = [\n        [1, 152, 189],\n        [73, 227, 206],\n        [216, 254, 181],\n        [254, 237, 177],\n        [254, 173, 84],\n        [209, 55, 78],\n    ]\n\n    self.call_js_method(\n        \"addGridLayer\",\n        id=layer_id,\n        data=processed_data,\n        getPosition=get_position,\n        cellSize=cell_size,\n        elevationScale=elevation_scale,\n        extruded=extruded,\n        colorRange=color_range or default_color_range,\n        pickable=pickable,\n        opacity=opacity,\n        **kwargs,\n    )\n\n    self._layers = {**self._layers, layer_id: {\"id\": layer_id, \"type\": \"grid\"}}\n    self._add_to_layer_dict(layer_id, \"Deck.gl\")\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.mapbox.MapboxMap.add_heatmap","title":"<code>add_heatmap(self, data, weight_property=None, radius=20, intensity=1.0, colormap=None, opacity=0.8, name=None, fit_bounds=True, **kwargs)</code>","text":"<p>Add a heatmap layer to the map.</p> Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def add_heatmap(\n    self,\n    data: Any,\n    weight_property: Optional[str] = None,\n    radius: int = 20,\n    intensity: float = 1.0,\n    colormap: Optional[List] = None,\n    opacity: float = 0.8,\n    name: Optional[str] = None,\n    fit_bounds: bool = True,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a heatmap layer to the map.\"\"\"\n    self._validate_opacity(opacity)\n    layer_id = name or f\"heatmap-{len(self._layers)}\"\n\n    geojson = to_geojson(data)\n\n    if geojson.get(\"type\") == \"url\":\n        url = geojson[\"url\"]\n        geojson = fetch_geojson(url)\n\n    if colormap is None:\n        colormap = [\n            [0, \"rgba(33,102,172,0)\"],\n            [0.2, \"rgb(103,169,207)\"],\n            [0.4, \"rgb(209,229,240)\"],\n            [0.6, \"rgb(253,219,199)\"],\n            [0.8, \"rgb(239,138,98)\"],\n            [1, \"rgb(178,24,43)\"],\n        ]\n\n    paint = {\n        \"heatmap-radius\": radius,\n        \"heatmap-intensity\": intensity,\n        \"heatmap-opacity\": opacity,\n        \"heatmap-color\": [\n            \"interpolate\",\n            [\"linear\"],\n            [\"heatmap-density\"],\n        ],\n    }\n\n    for stop, color in colormap:\n        paint[\"heatmap-color\"].extend([stop, color])\n\n    if weight_property:\n        paint[\"heatmap-weight\"] = [\"get\", weight_property]\n\n    bounds = get_bounds(geojson) if fit_bounds else None\n\n    self.call_js_method(\n        \"addGeoJSON\",\n        data=geojson,\n        name=layer_id,\n        layerType=\"heatmap\",\n        paint=paint,\n        fitBounds=fit_bounds,\n        bounds=bounds,\n        **kwargs,\n    )\n\n    self._layers = {\n        **self._layers,\n        layer_id: {\n            \"id\": layer_id,\n            \"type\": \"heatmap\",\n            \"source\": f\"{layer_id}-source\",\n            \"paint\": paint,\n        },\n    }\n    self._add_to_layer_dict(layer_id, \"Heatmap\")\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.mapbox.MapboxMap.add_hexagon_layer","title":"<code>add_hexagon_layer(self, data, name=None, get_position='coordinates', radius=1000, elevation_scale=4, extruded=True, color_range=None, pickable=True, opacity=0.8, **kwargs)</code>","text":"<p>Add a hexagon layer using deck.gl.</p> Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def add_hexagon_layer(\n    self,\n    data: Any,\n    name: Optional[str] = None,\n    get_position: Union[str, Any] = \"coordinates\",\n    radius: float = 1000,\n    elevation_scale: float = 4,\n    extruded: bool = True,\n    color_range: Optional[List[List[int]]] = None,\n    pickable: bool = True,\n    opacity: float = 0.8,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a hexagon layer using deck.gl.\"\"\"\n    layer_id = name or f\"hexagon-{len(self._layers)}\"\n    processed_data = self._process_deck_data(data)\n\n    default_color_range = [\n        [1, 152, 189],\n        [73, 227, 206],\n        [216, 254, 181],\n        [254, 237, 177],\n        [254, 173, 84],\n        [209, 55, 78],\n    ]\n\n    self.call_js_method(\n        \"addHexagonLayer\",\n        id=layer_id,\n        data=processed_data,\n        getPosition=get_position,\n        radius=radius,\n        elevationScale=elevation_scale,\n        extruded=extruded,\n        colorRange=color_range or default_color_range,\n        pickable=pickable,\n        opacity=opacity,\n        **kwargs,\n    )\n\n    self._layers = {**self._layers, layer_id: {\"id\": layer_id, \"type\": \"hexagon\"}}\n    self._add_to_layer_dict(layer_id, \"Deck.gl\")\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.mapbox.MapboxMap.add_hover_effect","title":"<code>add_hover_effect(self, layer_id, highlight_color=None, highlight_opacity=None, highlight_outline_width=2, **kwargs)</code>","text":"<p>Add hover highlight effect to an existing layer.</p> Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def add_hover_effect(\n    self,\n    layer_id: str,\n    highlight_color: Optional[str] = None,\n    highlight_opacity: Optional[float] = None,\n    highlight_outline_width: float = 2,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add hover highlight effect to an existing layer.\"\"\"\n    self.call_js_method(\n        \"addHoverEffect\",\n        layerId=layer_id,\n        highlightColor=highlight_color,\n        highlightOpacity=highlight_opacity,\n        highlightOutlineWidth=highlight_outline_width,\n        **kwargs,\n    )\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.mapbox.MapboxMap.add_icon_layer","title":"<code>add_icon_layer(self, data, name=None, get_position='coordinates', get_icon='icon', get_size=20, get_color=None, icon_atlas=None, icon_mapping=None, pickable=True, opacity=1, **kwargs)</code>","text":"<p>Add an icon layer using deck.gl.</p> Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def add_icon_layer(\n    self,\n    data: Any,\n    name: Optional[str] = None,\n    get_position: Union[str, Any] = \"coordinates\",\n    get_icon: Union[str, Any] = \"icon\",\n    get_size: Union[float, str] = 20,\n    get_color: Optional[Union[List[int], str]] = None,\n    icon_atlas: Optional[str] = None,\n    icon_mapping: Optional[Dict] = None,\n    pickable: bool = True,\n    opacity: float = 1,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add an icon layer using deck.gl.\"\"\"\n    layer_id = name or f\"icon-{len(self._layers)}\"\n    processed_data = self._process_deck_data(data)\n\n    self.call_js_method(\n        \"addIconLayer\",\n        id=layer_id,\n        data=processed_data,\n        getPosition=get_position,\n        getIcon=get_icon,\n        getSize=get_size,\n        getColor=get_color or [255, 255, 255, 255],\n        iconAtlas=icon_atlas,\n        iconMapping=icon_mapping,\n        pickable=pickable,\n        opacity=opacity,\n        **kwargs,\n    )\n\n    self._layers = {**self._layers, layer_id: {\"id\": layer_id, \"type\": \"icon\"}}\n    self._add_to_layer_dict(layer_id, \"Deck.gl\")\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.mapbox.MapboxMap.add_image","title":"<code>add_image(self, name, url)</code>","text":"<p>Load a custom icon image for use in symbol layers.</p> Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def add_image(self, name: str, url: str) -&gt; None:\n    \"\"\"Load a custom icon image for use in symbol layers.\"\"\"\n    self.call_js_method(\"addMapImage\", name=name, url=url)\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.mapbox.MapboxMap.add_image_layer","title":"<code>add_image_layer(self, url, coordinates, name=None, opacity=1.0, **kwargs)</code>","text":"<p>Add a georeferenced image overlay.</p> Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def add_image_layer(\n    self,\n    url: str,\n    coordinates: List[List[float]],\n    name: Optional[str] = None,\n    opacity: float = 1.0,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a georeferenced image overlay.\"\"\"\n    self._validate_opacity(opacity)\n    layer_id = name or f\"image-{len(self._layers)}\"\n\n    if len(coordinates) != 4:\n        raise ValueError(\n            \"coordinates must have exactly 4 corner points \"\n            \"[top-left, top-right, bottom-right, bottom-left]\"\n        )\n\n    self.call_js_method(\n        \"addImageLayer\",\n        id=layer_id,\n        url=url,\n        coordinates=coordinates,\n        opacity=opacity,\n        **kwargs,\n    )\n\n    self._layers = {\n        **self._layers,\n        layer_id: {\n            \"id\": layer_id,\n            \"type\": \"image\",\n            \"url\": url,\n            \"coordinates\": coordinates,\n        },\n    }\n    self._add_to_layer_dict(layer_id, \"Raster\")\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.mapbox.MapboxMap.add_layer","title":"<code>add_layer(self, layer_id, layer_type, source, paint=None, layout=None, before_id=None, **kwargs)</code>","text":"<p>Add a generic layer to the map.</p> <p>Parameters:</p> Name Type Description Default <code>layer_id</code> <code>str</code> <p>Unique layer identifier.</p> required <code>layer_type</code> <code>str</code> <p>Mapbox layer type.</p> required <code>source</code> <code>Union[str, Dict]</code> <p>Source ID or source configuration dict.</p> required <code>paint</code> <code>Optional[Dict]</code> <p>Paint properties.</p> <code>None</code> <code>layout</code> <code>Optional[Dict]</code> <p>Layout properties.</p> <code>None</code> <code>before_id</code> <code>Optional[str]</code> <p>ID of layer to insert before.</p> <code>None</code> <code>**kwargs</code> <p>Additional layer options.</p> <code>{}</code> Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def add_layer(\n    self,\n    layer_id: str,\n    layer_type: str,\n    source: Union[str, Dict],\n    paint: Optional[Dict] = None,\n    layout: Optional[Dict] = None,\n    before_id: Optional[str] = None,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a generic layer to the map.\n\n    Args:\n        layer_id: Unique layer identifier.\n        layer_type: Mapbox layer type.\n        source: Source ID or source configuration dict.\n        paint: Paint properties.\n        layout: Layout properties.\n        before_id: ID of layer to insert before.\n        **kwargs: Additional layer options.\n    \"\"\"\n    layer_config = {\n        \"id\": layer_id,\n        \"type\": layer_type,\n        \"paint\": paint or {},\n        \"layout\": layout or {},\n        **kwargs,\n    }\n\n    if isinstance(source, str):\n        layer_config[\"source\"] = source\n    else:\n        source_id = f\"{layer_id}-source\"\n        self._sources = {**self._sources, source_id: source}\n        self.call_js_method(\"addSource\", source_id, **source)\n        layer_config[\"source\"] = source_id\n\n    self._layers = {**self._layers, layer_id: layer_config}\n    self.call_js_method(\"addLayer\", beforeId=before_id, **layer_config)\n    lt = layer_config.get(\"type\", \"\")\n    self._add_to_layer_dict(layer_id, \"Raster\" if lt == \"raster\" else \"Vector\")\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.mapbox.MapboxMap.add_layer_control","title":"<code>add_layer_control(self, layers=None, position='top-right', collapsed=True)</code>","text":"<p>Add a layer visibility control.</p> Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def add_layer_control(\n    self,\n    layers: Optional[List[str]] = None,\n    position: str = \"top-right\",\n    collapsed: bool = True,\n) -&gt; None:\n    \"\"\"Add a layer visibility control.\"\"\"\n    if layers is None:\n        layers = list(self._layers.keys())\n\n    self.call_js_method(\n        \"addLayerControl\",\n        layers=layers,\n        position=position,\n        collapsed=collapsed,\n    )\n    self._controls = {\n        **self._controls,\n        \"layer-control\": {\n            \"layers\": layers,\n            \"position\": position,\n            \"collapsed\": collapsed,\n        },\n    }\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.mapbox.MapboxMap.add_legend","title":"<code>add_legend(self, title, labels, colors, position='bottom-right', opacity=1.0, legend_id=None, **kwargs)</code>","text":"<p>Add a floating legend control to the map.</p> Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def add_legend(\n    self,\n    title: str,\n    labels: List[str],\n    colors: List[str],\n    position: str = \"bottom-right\",\n    opacity: float = 1.0,\n    legend_id: Optional[str] = None,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a floating legend control to the map.\"\"\"\n    if len(labels) != len(colors):\n        raise ValueError(\"Number of labels must match number of colors\")\n\n    self._validate_position(position)\n\n    for i, color in enumerate(colors):\n        if not isinstance(color, str) or not color.startswith(\"#\"):\n            raise ValueError(\n                f\"Color at index {i} must be a hex color string (e.g., '#ff0000')\"\n            )\n\n    legend_id = (\n        legend_id\n        or f\"legend-{len([k for k in self._controls.keys() if k.startswith('legend')])}\"\n    )\n\n    legend_items = [\n        {\"label\": label, \"color\": color} for label, color in zip(labels, colors)\n    ]\n\n    self.call_js_method(\n        \"addLegend\",\n        id=legend_id,\n        title=title,\n        items=legend_items,\n        position=position,\n        opacity=opacity,\n        **kwargs,\n    )\n\n    self._controls = {\n        **self._controls,\n        legend_id: {\n            \"type\": \"legend\",\n            \"title\": title,\n            \"labels\": labels,\n            \"colors\": colors,\n            \"position\": position,\n            \"opacity\": opacity,\n        },\n    }\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.mapbox.MapboxMap.add_lidar_control","title":"<code>add_lidar_control(self, position='top-right', collapsed=True, title='LiDAR Viewer', point_size=2, opacity=1.0, color_scheme='elevation', use_percentile=True, point_budget=1000000, pickable=False, auto_zoom=True, copc_loading_mode=None, streaming_point_budget=5000000, **kwargs)</code>","text":"<p>Add an interactive LiDAR control panel.</p> <p>The LiDAR control provides a UI panel for loading, visualizing, and styling LiDAR point cloud files (LAS, LAZ, COPC formats).</p> <p>Parameters:</p> Name Type Description Default <code>position</code> <code>str</code> <p>Control position ('top-left', 'top-right', 'bottom-left', 'bottom-right').</p> <code>'top-right'</code> <code>collapsed</code> <code>bool</code> <p>Whether the panel starts collapsed.</p> <code>True</code> <code>title</code> <code>str</code> <p>Title displayed on the panel.</p> <code>'LiDAR Viewer'</code> <code>point_size</code> <code>float</code> <p>Point size in pixels.</p> <code>2</code> <code>opacity</code> <code>float</code> <p>Layer opacity (0-1).</p> <code>1.0</code> <code>color_scheme</code> <code>str</code> <p>Color scheme ('elevation', 'intensity', 'classification', 'rgb').</p> <code>'elevation'</code> <code>use_percentile</code> <code>bool</code> <p>Use 2-98% percentile for color scaling.</p> <code>True</code> <code>point_budget</code> <code>int</code> <p>Maximum number of points to display.</p> <code>1000000</code> <code>pickable</code> <code>bool</code> <p>Enable hover/click interactions.</p> <code>False</code> <code>auto_zoom</code> <code>bool</code> <p>Auto-zoom to point cloud after loading.</p> <code>True</code> <code>copc_loading_mode</code> <code>Optional[str]</code> <p>COPC loading mode ('full' or 'dynamic').</p> <code>None</code> <code>streaming_point_budget</code> <code>int</code> <p>Point budget for streaming mode.</p> <code>5000000</code> <code>**kwargs</code> <p>Additional control options.</p> <code>{}</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from anymap_ts import MapboxMap\n&gt;&gt;&gt; m = MapboxMap(pitch=60)\n&gt;&gt;&gt; m.add_lidar_control(color_scheme=\"classification\", pickable=True)\n</code></pre> Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def add_lidar_control(\n    self,\n    position: str = \"top-right\",\n    collapsed: bool = True,\n    title: str = \"LiDAR Viewer\",\n    point_size: float = 2,\n    opacity: float = 1.0,\n    color_scheme: str = \"elevation\",\n    use_percentile: bool = True,\n    point_budget: int = 1000000,\n    pickable: bool = False,\n    auto_zoom: bool = True,\n    copc_loading_mode: Optional[str] = None,\n    streaming_point_budget: int = 5000000,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add an interactive LiDAR control panel.\n\n    The LiDAR control provides a UI panel for loading, visualizing, and\n    styling LiDAR point cloud files (LAS, LAZ, COPC formats).\n\n    Args:\n        position: Control position ('top-left', 'top-right', 'bottom-left', 'bottom-right').\n        collapsed: Whether the panel starts collapsed.\n        title: Title displayed on the panel.\n        point_size: Point size in pixels.\n        opacity: Layer opacity (0-1).\n        color_scheme: Color scheme ('elevation', 'intensity', 'classification', 'rgb').\n        use_percentile: Use 2-98% percentile for color scaling.\n        point_budget: Maximum number of points to display.\n        pickable: Enable hover/click interactions.\n        auto_zoom: Auto-zoom to point cloud after loading.\n        copc_loading_mode: COPC loading mode ('full' or 'dynamic').\n        streaming_point_budget: Point budget for streaming mode.\n        **kwargs: Additional control options.\n\n    Example:\n        &gt;&gt;&gt; from anymap_ts import MapboxMap\n        &gt;&gt;&gt; m = MapboxMap(pitch=60)\n        &gt;&gt;&gt; m.add_lidar_control(color_scheme=\"classification\", pickable=True)\n    \"\"\"\n    self.call_js_method(\n        \"addLidarControl\",\n        position=position,\n        collapsed=collapsed,\n        title=title,\n        pointSize=point_size,\n        opacity=opacity,\n        colorScheme=color_scheme,\n        usePercentile=use_percentile,\n        pointBudget=point_budget,\n        pickable=pickable,\n        autoZoom=auto_zoom,\n        copcLoadingMode=copc_loading_mode,\n        streamingPointBudget=streaming_point_budget,\n        **kwargs,\n    )\n    self._controls = {\n        **self._controls,\n        \"lidar-control\": {\"position\": position, \"collapsed\": collapsed},\n    }\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.mapbox.MapboxMap.add_lidar_layer","title":"<code>add_lidar_layer(self, source, name=None, color_scheme='elevation', point_size=2, opacity=1.0, pickable=True, auto_zoom=True, streaming_mode=True, point_budget=1000000, **kwargs)</code>","text":"<p>Load and display a LiDAR file from URL or local path.</p> <p>Supports LAS, LAZ, and COPC (Cloud-Optimized Point Cloud) formats. For local files, the file is read and sent as base64 to JavaScript. For URLs, the data is loaded directly via streaming when possible.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>Union[str, Path]</code> <p>URL or local file path to the LiDAR file.</p> required <code>name</code> <code>Optional[str]</code> <p>Layer identifier. If None, auto-generated.</p> <code>None</code> <code>color_scheme</code> <code>str</code> <p>Color scheme ('elevation', 'intensity', 'classification', 'rgb').</p> <code>'elevation'</code> <code>point_size</code> <code>float</code> <p>Point size in pixels.</p> <code>2</code> <code>opacity</code> <code>float</code> <p>Layer opacity (0-1).</p> <code>1.0</code> <code>pickable</code> <code>bool</code> <p>Enable hover/click interactions.</p> <code>True</code> <code>auto_zoom</code> <code>bool</code> <p>Auto-zoom to point cloud after loading.</p> <code>True</code> <code>streaming_mode</code> <code>bool</code> <p>Use streaming mode for large COPC files.</p> <code>True</code> <code>point_budget</code> <code>int</code> <p>Maximum number of points to display.</p> <code>1000000</code> <code>**kwargs</code> <p>Additional layer options.</p> <code>{}</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from anymap_ts import MapboxMap\n&gt;&gt;&gt; m = MapboxMap(center=[-123.07, 44.05], zoom=14, pitch=60)\n&gt;&gt;&gt; m.add_lidar_layer(\n...     source=\"https://s3.amazonaws.com/hobu-lidar/autzen-classified.copc.laz\",\n...     name=\"autzen\",\n...     color_scheme=\"classification\",\n... )\n</code></pre> Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def add_lidar_layer(\n    self,\n    source: Union[str, Path],\n    name: Optional[str] = None,\n    color_scheme: str = \"elevation\",\n    point_size: float = 2,\n    opacity: float = 1.0,\n    pickable: bool = True,\n    auto_zoom: bool = True,\n    streaming_mode: bool = True,\n    point_budget: int = 1000000,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Load and display a LiDAR file from URL or local path.\n\n    Supports LAS, LAZ, and COPC (Cloud-Optimized Point Cloud) formats.\n    For local files, the file is read and sent as base64 to JavaScript.\n    For URLs, the data is loaded directly via streaming when possible.\n\n    Args:\n        source: URL or local file path to the LiDAR file.\n        name: Layer identifier. If None, auto-generated.\n        color_scheme: Color scheme ('elevation', 'intensity', 'classification', 'rgb').\n        point_size: Point size in pixels.\n        opacity: Layer opacity (0-1).\n        pickable: Enable hover/click interactions.\n        auto_zoom: Auto-zoom to point cloud after loading.\n        streaming_mode: Use streaming mode for large COPC files.\n        point_budget: Maximum number of points to display.\n        **kwargs: Additional layer options.\n\n    Example:\n        &gt;&gt;&gt; from anymap_ts import MapboxMap\n        &gt;&gt;&gt; m = MapboxMap(center=[-123.07, 44.05], zoom=14, pitch=60)\n        &gt;&gt;&gt; m.add_lidar_layer(\n        ...     source=\"https://s3.amazonaws.com/hobu-lidar/autzen-classified.copc.laz\",\n        ...     name=\"autzen\",\n        ...     color_scheme=\"classification\",\n        ... )\n    \"\"\"\n    import base64\n\n    layer_id = name or f\"lidar-{len(self._layers)}\"\n\n    # Check if source is a local file\n    source_path = Path(source) if isinstance(source, (str, Path)) else None\n    is_local = source_path is not None and source_path.exists()\n\n    if is_local:\n        # Read local file and encode as base64\n        with open(source_path, \"rb\") as f:\n            file_data = f.read()\n        source_b64 = base64.b64encode(file_data).decode(\"utf-8\")\n\n        self.call_js_method(\n            \"addLidarLayer\",\n            source=source_b64,\n            name=layer_id,\n            isBase64=True,\n            filename=source_path.name,\n            colorScheme=color_scheme,\n            pointSize=point_size,\n            opacity=opacity,\n            pickable=pickable,\n            autoZoom=auto_zoom,\n            streamingMode=streaming_mode,\n            pointBudget=point_budget,\n            **kwargs,\n        )\n    else:\n        # Load from URL\n        self.call_js_method(\n            \"addLidarLayer\",\n            source=str(source),\n            name=layer_id,\n            isBase64=False,\n            colorScheme=color_scheme,\n            pointSize=point_size,\n            opacity=opacity,\n            pickable=pickable,\n            autoZoom=auto_zoom,\n            streamingMode=streaming_mode,\n            pointBudget=point_budget,\n            **kwargs,\n        )\n\n    self._layers = {\n        **self._layers,\n        layer_id: {\n            \"id\": layer_id,\n            \"type\": \"lidar\",\n            \"source\": str(source),\n        },\n    }\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.mapbox.MapboxMap.add_line_layer","title":"<code>add_line_layer(self, data, name=None, get_source_position='sourcePosition', get_target_position='targetPosition', get_color=None, get_width=1, width_min_pixels=1, pickable=True, opacity=0.8, **kwargs)</code>","text":"<p>Add a line layer using deck.gl.</p> Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def add_line_layer(\n    self,\n    data: Any,\n    name: Optional[str] = None,\n    get_source_position: Union[str, Any] = \"sourcePosition\",\n    get_target_position: Union[str, Any] = \"targetPosition\",\n    get_color: Optional[Union[List[int], str]] = None,\n    get_width: Union[float, str] = 1,\n    width_min_pixels: float = 1,\n    pickable: bool = True,\n    opacity: float = 0.8,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a line layer using deck.gl.\"\"\"\n    layer_id = name or f\"line-{len(self._layers)}\"\n    processed_data = self._process_deck_data(data)\n\n    self.call_js_method(\n        \"addLineLayer\",\n        id=layer_id,\n        data=processed_data,\n        getSourcePosition=get_source_position,\n        getTargetPosition=get_target_position,\n        getColor=get_color or [51, 136, 255, 200],\n        getWidth=get_width,\n        widthMinPixels=width_min_pixels,\n        pickable=pickable,\n        opacity=opacity,\n        **kwargs,\n    )\n\n    self._layers = {**self._layers, layer_id: {\"id\": layer_id, \"type\": \"line\"}}\n    self._add_to_layer_dict(layer_id, \"Deck.gl\")\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.mapbox.MapboxMap.add_marker","title":"<code>add_marker(self, lng, lat, popup=None, tooltip=None, color='#3388ff', draggable=False, scale=1.0, popup_max_width='240px', tooltip_max_width='240px', name=None, **kwargs)</code>","text":"<p>Add a single marker to the map.</p> Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def add_marker(\n    self,\n    lng: float,\n    lat: float,\n    popup: Optional[str] = None,\n    tooltip: Optional[str] = None,\n    color: str = \"#3388ff\",\n    draggable: bool = False,\n    scale: float = 1.0,\n    popup_max_width: str = \"240px\",\n    tooltip_max_width: str = \"240px\",\n    name: Optional[str] = None,\n    **kwargs,\n) -&gt; str:\n    \"\"\"Add a single marker to the map.\"\"\"\n    marker_id = name or f\"marker-{len(self._layers)}\"\n\n    self.call_js_method(\n        \"addMarker\",\n        lng,\n        lat,\n        id=marker_id,\n        popup=popup,\n        tooltip=tooltip,\n        color=color,\n        draggable=draggable,\n        scale=scale,\n        popupMaxWidth=popup_max_width,\n        tooltipMaxWidth=tooltip_max_width,\n        **kwargs,\n    )\n\n    self._layers = {\n        **self._layers,\n        marker_id: {\n            \"id\": marker_id,\n            \"type\": \"marker\",\n            \"lngLat\": [lng, lat],\n        },\n    }\n    self._add_to_layer_dict(marker_id, \"Markers\")\n    return marker_id\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.mapbox.MapboxMap.add_markers","title":"<code>add_markers(self, data, lng_column=None, lat_column=None, popup_column=None, tooltip_column=None, color='#3388ff', scale=1.0, popup_max_width='240px', tooltip_max_width='240px', draggable=False, name=None, **kwargs)</code>","text":"<p>Add multiple markers from data.</p> Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def add_markers(\n    self,\n    data: Any,\n    lng_column: Optional[str] = None,\n    lat_column: Optional[str] = None,\n    popup_column: Optional[str] = None,\n    tooltip_column: Optional[str] = None,\n    color: str = \"#3388ff\",\n    scale: float = 1.0,\n    popup_max_width: str = \"240px\",\n    tooltip_max_width: str = \"240px\",\n    draggable: bool = False,\n    name: Optional[str] = None,\n    **kwargs,\n) -&gt; str:\n    \"\"\"Add multiple markers from data.\"\"\"\n    layer_id = name or f\"markers-{len(self._layers)}\"\n    markers = []\n\n    if hasattr(data, \"geometry\"):\n        for _, row in data.iterrows():\n            geom = row.geometry\n            if geom.geom_type == \"Point\":\n                marker = {\"lngLat\": [geom.x, geom.y]}\n                if popup_column and popup_column in row:\n                    marker[\"popup\"] = str(row[popup_column])\n                if tooltip_column and tooltip_column in row:\n                    marker[\"tooltip\"] = str(row[tooltip_column])\n                markers.append(marker)\n    elif isinstance(data, dict) and data.get(\"type\") == \"FeatureCollection\":\n        for feature in data.get(\"features\", []):\n            geom = feature.get(\"geometry\", {})\n            if geom.get(\"type\") == \"Point\":\n                coords = geom.get(\"coordinates\", [])\n                marker = {\"lngLat\": coords[:2]}\n                props = feature.get(\"properties\", {})\n                if popup_column and popup_column in props:\n                    marker[\"popup\"] = str(props[popup_column])\n                if tooltip_column and tooltip_column in props:\n                    marker[\"tooltip\"] = str(props[tooltip_column])\n                markers.append(marker)\n    elif isinstance(data, list):\n        lng_keys = [\"lng\", \"lon\", \"longitude\", \"x\"]\n        lat_keys = [\"lat\", \"latitude\", \"y\"]\n\n        for item in data:\n            if not isinstance(item, dict):\n                continue\n\n            lng_val = None\n            lat_val = None\n\n            if lng_column and lng_column in item:\n                lng_val = item[lng_column]\n            else:\n                for key in lng_keys:\n                    if key in item:\n                        lng_val = item[key]\n                        break\n\n            if lat_column and lat_column in item:\n                lat_val = item[lat_column]\n            else:\n                for key in lat_keys:\n                    if key in item:\n                        lat_val = item[key]\n                        break\n\n            if lng_val is not None and lat_val is not None:\n                marker = {\"lngLat\": [float(lng_val), float(lat_val)]}\n                if popup_column and popup_column in item:\n                    marker[\"popup\"] = str(item[popup_column])\n                if tooltip_column and tooltip_column in item:\n                    marker[\"tooltip\"] = str(item[tooltip_column])\n                markers.append(marker)\n\n    if not markers:\n        raise ValueError(\"No valid point data found in input\")\n\n    self.call_js_method(\n        \"addMarkers\",\n        id=layer_id,\n        markers=markers,\n        color=color,\n        scale=scale,\n        popupMaxWidth=popup_max_width,\n        tooltipMaxWidth=tooltip_max_width,\n        draggable=draggable,\n        **kwargs,\n    )\n\n    self._layers = {\n        **self._layers,\n        layer_id: {\n            \"id\": layer_id,\n            \"type\": \"markers\",\n            \"count\": len(markers),\n        },\n    }\n    self._add_to_layer_dict(layer_id, \"Markers\")\n    return layer_id\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.mapbox.MapboxMap.add_measure_control","title":"<code>add_measure_control(self, position='top-right', collapsed=True, default_mode='distance', distance_unit='kilometers', area_unit='square-kilometers', line_color='#3b82f6', fill_color='rgba(59, 130, 246, 0.2)', **kwargs)</code>","text":"<p>Add a measurement control.</p> Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def add_measure_control(\n    self,\n    position: str = \"top-right\",\n    collapsed: bool = True,\n    default_mode: str = \"distance\",\n    distance_unit: str = \"kilometers\",\n    area_unit: str = \"square-kilometers\",\n    line_color: str = \"#3b82f6\",\n    fill_color: str = \"rgba(59, 130, 246, 0.2)\",\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a measurement control.\"\"\"\n    self._validate_position(position)\n    self.call_js_method(\n        \"addMeasureControl\",\n        position=position,\n        collapsed=collapsed,\n        defaultMode=default_mode,\n        distanceUnit=distance_unit,\n        areaUnit=area_unit,\n        lineColor=line_color,\n        fillColor=fill_color,\n        **kwargs,\n    )\n    self._controls = {\n        **self._controls,\n        \"measure-control\": {\n            \"type\": \"measure-control\",\n            \"position\": position,\n            \"collapsed\": collapsed,\n        },\n    }\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.mapbox.MapboxMap.add_opacity_slider","title":"<code>add_opacity_slider(self, layer_id, position='top-right', label=None)</code>","text":"<p>Add a UI slider to control layer opacity.</p> Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def add_opacity_slider(\n    self,\n    layer_id: str,\n    position: str = \"top-right\",\n    label: Optional[str] = None,\n) -&gt; None:\n    \"\"\"Add a UI slider to control layer opacity.\"\"\"\n    self.call_js_method(\n        \"addOpacitySlider\",\n        layerId=layer_id,\n        position=position,\n        label=label or layer_id,\n    )\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.mapbox.MapboxMap.add_path_layer","title":"<code>add_path_layer(self, data, name=None, get_path='path', get_color=None, get_width=1, width_scale=1, width_min_pixels=1, pickable=True, opacity=0.8, **kwargs)</code>","text":"<p>Add a path layer using deck.gl.</p> Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def add_path_layer(\n    self,\n    data: Any,\n    name: Optional[str] = None,\n    get_path: Union[str, Any] = \"path\",\n    get_color: Optional[Union[List[int], str]] = None,\n    get_width: Union[float, str] = 1,\n    width_scale: float = 1,\n    width_min_pixels: float = 1,\n    pickable: bool = True,\n    opacity: float = 0.8,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a path layer using deck.gl.\"\"\"\n    layer_id = name or f\"path-{len(self._layers)}\"\n    processed_data = self._process_deck_data(data)\n\n    self.call_js_method(\n        \"addPathLayer\",\n        id=layer_id,\n        data=processed_data,\n        getPath=get_path,\n        getColor=get_color or [51, 136, 255, 200],\n        getWidth=get_width,\n        widthScale=width_scale,\n        widthMinPixels=width_min_pixels,\n        pickable=pickable,\n        opacity=opacity,\n        **kwargs,\n    )\n\n    self._layers = {**self._layers, layer_id: {\"id\": layer_id, \"type\": \"path\"}}\n    self._add_to_layer_dict(layer_id, \"Deck.gl\")\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.mapbox.MapboxMap.add_pmtiles_control","title":"<code>add_pmtiles_control(self, position='top-right', collapsed=True, default_url=None, load_default_url=False, default_opacity=1.0, default_fill_color='steelblue', default_line_color='#333', default_pickable=True, **kwargs)</code>","text":"<p>Add a PMTiles layer control.</p> Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def add_pmtiles_control(\n    self,\n    position: str = \"top-right\",\n    collapsed: bool = True,\n    default_url: Optional[str] = None,\n    load_default_url: bool = False,\n    default_opacity: float = 1.0,\n    default_fill_color: str = \"steelblue\",\n    default_line_color: str = \"#333\",\n    default_pickable: bool = True,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a PMTiles layer control.\"\"\"\n    self.call_js_method(\n        \"addPMTilesControl\",\n        position=position,\n        collapsed=collapsed,\n        defaultUrl=default_url or \"\",\n        loadDefaultUrl=load_default_url,\n        defaultOpacity=default_opacity,\n        defaultFillColor=default_fill_color,\n        defaultLineColor=default_line_color,\n        defaultPickable=default_pickable,\n        **kwargs,\n    )\n    self._controls = {\n        **self._controls,\n        \"pmtiles-control\": {\"position\": position, \"collapsed\": collapsed},\n    }\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.mapbox.MapboxMap.add_pmtiles_layer","title":"<code>add_pmtiles_layer(self, url, layer_id=None, style=None, opacity=1.0, visible=True, fit_bounds=False, source_type='vector', **kwargs)</code>","text":"<p>Add a PMTiles layer for efficient vector or raster tile serving.</p> Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def add_pmtiles_layer(\n    self,\n    url: str,\n    layer_id: Optional[str] = None,\n    style: Optional[Dict[str, Any]] = None,\n    opacity: float = 1.0,\n    visible: bool = True,\n    fit_bounds: bool = False,\n    source_type: str = \"vector\",\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a PMTiles layer for efficient vector or raster tile serving.\"\"\"\n    layer_id = layer_id or f\"pmtiles-{len(self._layers)}\"\n\n    self.call_js_method(\n        \"addPMTilesLayer\",\n        url=url,\n        id=layer_id,\n        style=style or {},\n        opacity=opacity,\n        visible=visible,\n        fitBounds=fit_bounds,\n        sourceType=source_type,\n        name=layer_id,\n        **kwargs,\n    )\n\n    self._layers = {\n        **self._layers,\n        layer_id: {\n            \"id\": layer_id,\n            \"type\": \"pmtiles\",\n            \"url\": url,\n            \"source_type\": source_type,\n        },\n    }\n    category = \"Vector\" if source_type == \"vector\" else \"Raster\"\n    self._add_to_layer_dict(layer_id, category)\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.mapbox.MapboxMap.add_point_cloud_layer","title":"<code>add_point_cloud_layer(self, data, name=None, get_position='position', get_color=None, get_normal=None, point_size=2, size_units='pixels', pickable=True, opacity=1.0, material=True, coordinate_system=None, coordinate_origin=None, **kwargs)</code>","text":"<p>Add a point cloud layer for 3D point visualization using deck.gl.</p> <p>Point cloud layers render large collections of 3D points, ideal for LiDAR data, photogrammetry outputs, or any 3D point dataset.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>Array of point data with positions. Each point should have x, y, z coordinates (or position array).</p> required <code>name</code> <code>Optional[str]</code> <p>Layer ID. If None, auto-generated.</p> <code>None</code> <code>get_position</code> <code>Union[str, Any]</code> <p>Accessor for point position [x, y, z]. Can be a string (property name) or a value.</p> <code>'position'</code> <code>get_color</code> <code>Optional[Union[List[int], str]]</code> <p>Accessor or value for point color [r, g, b, a]. Default: [255, 255, 255, 255] (white).</p> <code>None</code> <code>get_normal</code> <code>Optional[Union[str, Any]]</code> <p>Accessor for point normal [nx, ny, nz] for lighting. Default: [0, 0, 1] (pointing up).</p> <code>None</code> <code>point_size</code> <code>float</code> <p>Point size in pixels or meters (depends on size_units).</p> <code>2</code> <code>size_units</code> <code>str</code> <p>Size units: 'pixels', 'meters', or 'common'.</p> <code>'pixels'</code> <code>pickable</code> <code>bool</code> <p>Whether layer responds to hover/click events.</p> <code>True</code> <code>opacity</code> <code>float</code> <p>Layer opacity (0-1).</p> <code>1.0</code> <code>material</code> <code>bool</code> <p>Whether to enable lighting effects.</p> <code>True</code> <code>coordinate_system</code> <code>Optional[int]</code> <p>Coordinate system for positions.</p> <code>None</code> <code>coordinate_origin</code> <code>Optional[List[float]]</code> <p>Origin for coordinate system [x, y, z].</p> <code>None</code> <code>**kwargs</code> <p>Additional PointCloudLayer props.</p> <code>{}</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from anymap_ts import MapboxMap\n&gt;&gt;&gt; m = MapboxMap(pitch=45)\n&gt;&gt;&gt; points = [\n...     {\"position\": [-122.4, 37.8, 100], \"color\": [255, 0, 0, 255]},\n...     {\"position\": [-122.3, 37.7, 200], \"color\": [0, 255, 0, 255]},\n... ]\n&gt;&gt;&gt; m.add_point_cloud_layer(points, point_size=5)\n</code></pre> Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def add_point_cloud_layer(\n    self,\n    data: Any,\n    name: Optional[str] = None,\n    get_position: Union[str, Any] = \"position\",\n    get_color: Optional[Union[List[int], str]] = None,\n    get_normal: Optional[Union[str, Any]] = None,\n    point_size: float = 2,\n    size_units: str = \"pixels\",\n    pickable: bool = True,\n    opacity: float = 1.0,\n    material: bool = True,\n    coordinate_system: Optional[int] = None,\n    coordinate_origin: Optional[List[float]] = None,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a point cloud layer for 3D point visualization using deck.gl.\n\n    Point cloud layers render large collections of 3D points, ideal for\n    LiDAR data, photogrammetry outputs, or any 3D point dataset.\n\n    Args:\n        data: Array of point data with positions. Each point should have\n            x, y, z coordinates (or position array).\n        name: Layer ID. If None, auto-generated.\n        get_position: Accessor for point position [x, y, z].\n            Can be a string (property name) or a value.\n        get_color: Accessor or value for point color [r, g, b, a].\n            Default: [255, 255, 255, 255] (white).\n        get_normal: Accessor for point normal [nx, ny, nz] for lighting.\n            Default: [0, 0, 1] (pointing up).\n        point_size: Point size in pixels or meters (depends on size_units).\n        size_units: Size units: 'pixels', 'meters', or 'common'.\n        pickable: Whether layer responds to hover/click events.\n        opacity: Layer opacity (0-1).\n        material: Whether to enable lighting effects.\n        coordinate_system: Coordinate system for positions.\n        coordinate_origin: Origin for coordinate system [x, y, z].\n        **kwargs: Additional PointCloudLayer props.\n\n    Example:\n        &gt;&gt;&gt; from anymap_ts import MapboxMap\n        &gt;&gt;&gt; m = MapboxMap(pitch=45)\n        &gt;&gt;&gt; points = [\n        ...     {\"position\": [-122.4, 37.8, 100], \"color\": [255, 0, 0, 255]},\n        ...     {\"position\": [-122.3, 37.7, 200], \"color\": [0, 255, 0, 255]},\n        ... ]\n        &gt;&gt;&gt; m.add_point_cloud_layer(points, point_size=5)\n    \"\"\"\n    layer_id = name or f\"pointcloud-{len(self._layers)}\"\n    processed_data = self._process_deck_data(data)\n\n    self.call_js_method(\n        \"addPointCloudLayer\",\n        id=layer_id,\n        data=processed_data,\n        getPosition=get_position,\n        getColor=get_color or [255, 255, 255, 255],\n        getNormal=get_normal,\n        pointSize=point_size,\n        sizeUnits=size_units,\n        pickable=pickable,\n        opacity=opacity,\n        material=material,\n        coordinateSystem=coordinate_system,\n        coordinateOrigin=coordinate_origin,\n        **kwargs,\n    )\n\n    self._layers = {\n        **self._layers,\n        layer_id: {\n            \"id\": layer_id,\n            \"type\": \"pointcloud\",\n        },\n    }\n    self._add_to_layer_dict(layer_id, \"Deck.gl\")\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.mapbox.MapboxMap.add_polygon_layer","title":"<code>add_polygon_layer(self, data, name=None, get_polygon='polygon', get_fill_color=None, get_line_color=None, get_line_width=1, get_elevation=0, extruded=False, wireframe=False, filled=True, stroked=True, line_width_min_pixels=1, pickable=True, opacity=0.5, **kwargs)</code>","text":"<p>Add a polygon layer using deck.gl.</p> Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def add_polygon_layer(\n    self,\n    data: Any,\n    name: Optional[str] = None,\n    get_polygon: Union[str, Any] = \"polygon\",\n    get_fill_color: Optional[Union[List[int], str]] = None,\n    get_line_color: Optional[Union[List[int], str]] = None,\n    get_line_width: Union[float, str] = 1,\n    get_elevation: Union[float, str] = 0,\n    extruded: bool = False,\n    wireframe: bool = False,\n    filled: bool = True,\n    stroked: bool = True,\n    line_width_min_pixels: float = 1,\n    pickable: bool = True,\n    opacity: float = 0.5,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a polygon layer using deck.gl.\"\"\"\n    layer_id = name or f\"polygon-{len(self._layers)}\"\n    processed_data = self._process_deck_data(data)\n\n    self.call_js_method(\n        \"addPolygonLayer\",\n        id=layer_id,\n        data=processed_data,\n        getPolygon=get_polygon,\n        getFillColor=get_fill_color or [51, 136, 255, 128],\n        getLineColor=get_line_color or [0, 0, 255, 255],\n        getLineWidth=get_line_width,\n        getElevation=get_elevation,\n        extruded=extruded,\n        wireframe=wireframe,\n        filled=filled,\n        stroked=stroked,\n        lineWidthMinPixels=line_width_min_pixels,\n        pickable=pickable,\n        opacity=opacity,\n        **kwargs,\n    )\n\n    self._layers = {**self._layers, layer_id: {\"id\": layer_id, \"type\": \"polygon\"}}\n    self._add_to_layer_dict(layer_id, \"Deck.gl\")\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.mapbox.MapboxMap.add_popup","title":"<code>add_popup(self, layer_id, properties=None, template=None, **kwargs)</code>","text":"<p>Add popup on click for a layer.</p> Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def add_popup(\n    self,\n    layer_id: str,\n    properties: Optional[List[str]] = None,\n    template: Optional[str] = None,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add popup on click for a layer.\"\"\"\n    self.call_js_method(\n        \"addPopup\",\n        layerId=layer_id,\n        properties=properties,\n        template=template,\n        **kwargs,\n    )\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.mapbox.MapboxMap.add_print_control","title":"<code>add_print_control(self, position='top-right', collapsed=True, format='png', filename='map-export', include_north_arrow=False, include_scale_bar=False, **kwargs)</code>","text":"<p>Add a print/export control.</p> Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def add_print_control(\n    self,\n    position: str = \"top-right\",\n    collapsed: bool = True,\n    format: str = \"png\",\n    filename: str = \"map-export\",\n    include_north_arrow: bool = False,\n    include_scale_bar: bool = False,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a print/export control.\"\"\"\n    self._validate_position(position)\n    self.call_js_method(\n        \"addPrintControl\",\n        position=position,\n        collapsed=collapsed,\n        format=format,\n        filename=filename,\n        includeNorthArrow=include_north_arrow,\n        includeScaleBar=include_scale_bar,\n        **kwargs,\n    )\n    self._controls = {\n        **self._controls,\n        \"print-control\": {\n            \"type\": \"print-control\",\n            \"position\": position,\n            \"collapsed\": collapsed,\n        },\n    }\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.mapbox.MapboxMap.add_raster","title":"<code>add_raster(self, source, name=None, attribution='', indexes=None, colormap=None, vmin=None, vmax=None, nodata=None, fit_bounds=True, **kwargs)</code>","text":"<p>Add a raster layer from a local file using localtileserver.</p> Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def add_raster(\n    self,\n    source: str,\n    name: Optional[str] = None,\n    attribution: str = \"\",\n    indexes: Optional[List[int]] = None,\n    colormap: Optional[str] = None,\n    vmin: Optional[float] = None,\n    vmax: Optional[float] = None,\n    nodata: Optional[float] = None,\n    fit_bounds: bool = True,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a raster layer from a local file using localtileserver.\"\"\"\n    try:\n        from localtileserver import TileClient\n    except ImportError:\n        raise ImportError(\n            \"localtileserver is required for local raster support. \"\n            \"Install with: pip install anymap-ts[raster]\"\n        )\n\n    client = TileClient(source)\n\n    tile_params = {}\n    if indexes:\n        tile_params[\"indexes\"] = indexes\n    if colormap:\n        tile_params[\"colormap\"] = colormap\n    if vmin is not None or vmax is not None:\n        tile_params[\"vmin\"] = vmin if vmin is not None else client.min\n        tile_params[\"vmax\"] = vmax if vmax is not None else client.max\n    if nodata is not None:\n        tile_params[\"nodata\"] = nodata\n\n    tile_url = client.get_tile_url(**tile_params)\n\n    layer_name = name or Path(source).stem\n\n    self.add_tile_layer(\n        tile_url,\n        name=layer_name,\n        attribution=attribution,\n        **kwargs,\n    )\n\n    if fit_bounds:\n        bounds = client.bounds()\n        if bounds:\n            self.fit_bounds([bounds[0], bounds[1], bounds[2], bounds[3]])\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.mapbox.MapboxMap.add_scatterplot_layer","title":"<code>add_scatterplot_layer(self, data, name=None, get_position='coordinates', get_radius=5, get_fill_color=None, get_line_color=None, radius_scale=1, radius_min_pixels=1, radius_max_pixels=100, line_width_min_pixels=1, stroked=True, filled=True, pickable=True, opacity=0.8, **kwargs)</code>","text":"<p>Add a scatterplot layer using deck.gl.</p> Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def add_scatterplot_layer(\n    self,\n    data: Any,\n    name: Optional[str] = None,\n    get_position: Union[str, Any] = \"coordinates\",\n    get_radius: Union[float, str] = 5,\n    get_fill_color: Optional[Union[List[int], str]] = None,\n    get_line_color: Optional[Union[List[int], str]] = None,\n    radius_scale: float = 1,\n    radius_min_pixels: float = 1,\n    radius_max_pixels: float = 100,\n    line_width_min_pixels: float = 1,\n    stroked: bool = True,\n    filled: bool = True,\n    pickable: bool = True,\n    opacity: float = 0.8,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a scatterplot layer using deck.gl.\"\"\"\n    layer_id = name or f\"scatterplot-{len(self._layers)}\"\n    processed_data = self._process_deck_data(data)\n\n    self.call_js_method(\n        \"addScatterplotLayer\",\n        id=layer_id,\n        data=processed_data,\n        getPosition=get_position,\n        getRadius=get_radius,\n        getFillColor=get_fill_color or [51, 136, 255, 200],\n        getLineColor=get_line_color or [255, 255, 255, 255],\n        radiusScale=radius_scale,\n        radiusMinPixels=radius_min_pixels,\n        radiusMaxPixels=radius_max_pixels,\n        lineWidthMinPixels=line_width_min_pixels,\n        stroked=stroked,\n        filled=filled,\n        pickable=pickable,\n        opacity=opacity,\n        **kwargs,\n    )\n\n    self._layers = {\n        **self._layers,\n        layer_id: {\"id\": layer_id, \"type\": \"scatterplot\"},\n    }\n    self._add_to_layer_dict(layer_id, \"Deck.gl\")\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.mapbox.MapboxMap.add_screen_grid_layer","title":"<code>add_screen_grid_layer(self, data, name=None, get_position='coordinates', get_weight=1, cell_size_pixels=50, color_range=None, pickable=True, opacity=0.8, **kwargs)</code>","text":"<p>Add a screen grid layer using deck.gl.</p> Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def add_screen_grid_layer(\n    self,\n    data: Any,\n    name: Optional[str] = None,\n    get_position: Union[str, Any] = \"coordinates\",\n    get_weight: Union[float, str] = 1,\n    cell_size_pixels: float = 50,\n    color_range: Optional[List[List[int]]] = None,\n    pickable: bool = True,\n    opacity: float = 0.8,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a screen grid layer using deck.gl.\"\"\"\n    layer_id = name or f\"screengrid-{len(self._layers)}\"\n    processed_data = self._process_deck_data(data)\n\n    default_color_range = [\n        [255, 255, 178, 25],\n        [254, 217, 118, 85],\n        [254, 178, 76, 127],\n        [253, 141, 60, 170],\n        [240, 59, 32, 212],\n        [189, 0, 38, 255],\n    ]\n\n    self.call_js_method(\n        \"addScreenGridLayer\",\n        id=layer_id,\n        data=processed_data,\n        getPosition=get_position,\n        getWeight=get_weight,\n        cellSizePixels=cell_size_pixels,\n        colorRange=color_range or default_color_range,\n        pickable=pickable,\n        opacity=opacity,\n        **kwargs,\n    )\n\n    self._layers = {\n        **self._layers,\n        layer_id: {\"id\": layer_id, \"type\": \"screengrid\"},\n    }\n    self._add_to_layer_dict(layer_id, \"Deck.gl\")\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.mapbox.MapboxMap.add_search_control","title":"<code>add_search_control(self, position='top-left', placeholder='Search places...', collapsed=True, fly_to_zoom=14, show_marker=True, marker_color='#4264fb', **kwargs)</code>","text":"<p>Add a search/geocoder control.</p> Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def add_search_control(\n    self,\n    position: str = \"top-left\",\n    placeholder: str = \"Search places...\",\n    collapsed: bool = True,\n    fly_to_zoom: int = 14,\n    show_marker: bool = True,\n    marker_color: str = \"#4264fb\",\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a search/geocoder control.\"\"\"\n    self._validate_position(position)\n    self.call_js_method(\n        \"addSearchControl\",\n        position=position,\n        placeholder=placeholder,\n        collapsed=collapsed,\n        flyToZoom=fly_to_zoom,\n        showMarker=show_marker,\n        markerColor=marker_color,\n        **kwargs,\n    )\n    self._controls = {\n        **self._controls,\n        \"search-control\": {\n            \"type\": \"search-control\",\n            \"position\": position,\n            \"collapsed\": collapsed,\n        },\n    }\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.mapbox.MapboxMap.add_solid_polygon_layer","title":"<code>add_solid_polygon_layer(self, data, name=None, get_polygon='polygon', get_fill_color=None, get_line_color=None, get_elevation=0, filled=True, extruded=False, wireframe=False, elevation_scale=1, pickable=True, opacity=0.8, **kwargs)</code>","text":"<p>Add a solid polygon layer using deck.gl.</p> Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def add_solid_polygon_layer(\n    self,\n    data: Any,\n    name: Optional[str] = None,\n    get_polygon: Union[str, Any] = \"polygon\",\n    get_fill_color: Optional[Union[List[int], str]] = None,\n    get_line_color: Optional[Union[List[int], str]] = None,\n    get_elevation: Union[float, str] = 0,\n    filled: bool = True,\n    extruded: bool = False,\n    wireframe: bool = False,\n    elevation_scale: float = 1,\n    pickable: bool = True,\n    opacity: float = 0.8,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a solid polygon layer using deck.gl.\"\"\"\n    layer_id = name or f\"solidpolygon-{len(self._layers)}\"\n    processed_data = self._process_deck_data(data)\n\n    self.call_js_method(\n        \"addSolidPolygonLayer\",\n        id=layer_id,\n        data=processed_data,\n        getPolygon=get_polygon,\n        getFillColor=get_fill_color or [51, 136, 255, 128],\n        getLineColor=get_line_color or [0, 0, 0, 255],\n        getElevation=get_elevation,\n        filled=filled,\n        extruded=extruded,\n        wireframe=wireframe,\n        elevationScale=elevation_scale,\n        pickable=pickable,\n        opacity=opacity,\n        **kwargs,\n    )\n\n    self._layers = {\n        **self._layers,\n        layer_id: {\"id\": layer_id, \"type\": \"solidpolygon\"},\n    }\n    self._add_to_layer_dict(layer_id, \"Deck.gl\")\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.mapbox.MapboxMap.add_split_map","title":"<code>add_split_map(self, left_layer, right_layer, position=50)</code>","text":"<p>Add a split map comparison view with a draggable divider.</p> Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def add_split_map(\n    self,\n    left_layer: str,\n    right_layer: str,\n    position: int = 50,\n) -&gt; None:\n    \"\"\"Add a split map comparison view with a draggable divider.\"\"\"\n    if not 0 &lt;= position &lt;= 100:\n        raise ValueError(f\"position must be between 0 and 100, got {position}\")\n\n    self.call_js_method(\n        \"addSplitMap\",\n        leftLayer=left_layer,\n        rightLayer=right_layer,\n        position=position,\n    )\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.mapbox.MapboxMap.add_stac_layer","title":"<code>add_stac_layer(self, url=None, item=None, assets=None, colormap=None, rescale=None, opacity=1.0, layer_id=None, titiler_endpoint='https://titiler.xyz', attribution='STAC', fit_bounds=True, **kwargs)</code>","text":"<p>Add a STAC (SpatioTemporal Asset Catalog) layer to the map.</p> Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def add_stac_layer(\n    self,\n    url: Optional[str] = None,\n    item: Optional[Any] = None,\n    assets: Optional[List[str]] = None,\n    colormap: Optional[str] = None,\n    rescale: Optional[List[float]] = None,\n    opacity: float = 1.0,\n    layer_id: Optional[str] = None,\n    titiler_endpoint: str = \"https://titiler.xyz\",\n    attribution: str = \"STAC\",\n    fit_bounds: bool = True,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a STAC (SpatioTemporal Asset Catalog) layer to the map.\"\"\"\n    if url is None and item is None:\n        raise ValueError(\"Either 'url' or 'item' must be provided\")\n\n    if url is not None and item is not None:\n        raise ValueError(\"Provide either 'url' or 'item', not both\")\n\n    if item is not None:\n        try:\n            if hasattr(item, \"to_dict\") and hasattr(item, \"self_href\"):\n                stac_url = item.self_href\n                if not stac_url and hasattr(item, \"links\"):\n                    for link in item.links:\n                        if link.rel == \"self\":\n                            stac_url = link.href\n                            break\n                if not stac_url:\n                    raise ValueError(\"STAC item must have a self_href or self link\")\n            else:\n                raise ValueError(\n                    \"Item must be a pystac Item object with to_dict() and self_href\"\n                )\n        except Exception as e:\n            raise ValueError(f\"Invalid STAC item: {e}\")\n    else:\n        stac_url = url\n\n    tile_params = {\"url\": stac_url}\n    if assets:\n        tile_params[\"assets\"] = \",\".join(assets)\n    if colormap:\n        tile_params[\"colormap_name\"] = colormap\n    if rescale:\n        if len(rescale) == 2:\n            tile_params[\"rescale\"] = f\"{rescale[0]},{rescale[1]}\"\n        else:\n            raise ValueError(\"rescale must be a list of two values [min, max]\")\n\n    query_string = urlencode(tile_params)\n    tile_url = f\"{titiler_endpoint.rstrip('/')}/stac/tiles/{{z}}/{{x}}/{{y}}?{query_string}\"\n\n    layer_name = layer_id or f\"stac-{len(self._layers)}\"\n\n    self.add_tile_layer(\n        url=tile_url,\n        name=layer_name,\n        attribution=attribution,\n        **kwargs,\n    )\n\n    if fit_bounds and item is not None:\n        try:\n            bbox = item.bbox\n            if bbox and len(bbox) == 4:\n                self.fit_bounds([[bbox[0], bbox[1]], [bbox[2], bbox[3]]])\n        except Exception:\n            pass\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.mapbox.MapboxMap.add_style_switcher","title":"<code>add_style_switcher(self, styles, position='top-right')</code>","text":"<p>Add a dropdown to switch between map styles.</p> Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def add_style_switcher(\n    self,\n    styles: Dict[str, str],\n    position: str = \"top-right\",\n) -&gt; None:\n    \"\"\"Add a dropdown to switch between map styles.\"\"\"\n    self.call_js_method(\n        \"addStyleSwitcher\",\n        styles=styles,\n        position=position,\n    )\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.mapbox.MapboxMap.add_swipe_map","title":"<code>add_swipe_map(self, left_layer, right_layer)</code>","text":"<p>Add a drag-to-compare swipe control for two layers.</p> Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def add_swipe_map(self, left_layer: str, right_layer: str) -&gt; None:\n    \"\"\"Add a drag-to-compare swipe control for two layers.\"\"\"\n    self.call_js_method(\n        \"addSwipeMap\",\n        leftLayer=left_layer,\n        rightLayer=right_layer,\n    )\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.mapbox.MapboxMap.add_terrain","title":"<code>add_terrain(self, exaggeration=1.0, source='mapbox-dem')</code>","text":"<p>Add 3D terrain to the map.</p> <p>Parameters:</p> Name Type Description Default <code>exaggeration</code> <code>float</code> <p>Terrain exaggeration factor.</p> <code>1.0</code> <code>source</code> <code>str</code> <p>Terrain source ID.</p> <code>'mapbox-dem'</code> Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def add_terrain(\n    self, exaggeration: float = 1.0, source: str = \"mapbox-dem\"\n) -&gt; None:\n    \"\"\"Add 3D terrain to the map.\n\n    Args:\n        exaggeration: Terrain exaggeration factor.\n        source: Terrain source ID.\n    \"\"\"\n    self.call_js_method(\"addTerrain\", source=source, exaggeration=exaggeration)\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.mapbox.MapboxMap.add_text_layer","title":"<code>add_text_layer(self, data, name=None, get_position='coordinates', get_text='text', get_size=12, get_color=None, get_angle=0, text_anchor='middle', alignment_baseline='center', pickable=True, opacity=1, **kwargs)</code>","text":"<p>Add a text layer using deck.gl.</p> Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def add_text_layer(\n    self,\n    data: Any,\n    name: Optional[str] = None,\n    get_position: Union[str, Any] = \"coordinates\",\n    get_text: Union[str, Any] = \"text\",\n    get_size: Union[float, str] = 12,\n    get_color: Optional[Union[List[int], str]] = None,\n    get_angle: Union[float, str] = 0,\n    text_anchor: str = \"middle\",\n    alignment_baseline: str = \"center\",\n    pickable: bool = True,\n    opacity: float = 1,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a text layer using deck.gl.\"\"\"\n    layer_id = name or f\"text-{len(self._layers)}\"\n    processed_data = self._process_deck_data(data)\n\n    self.call_js_method(\n        \"addTextLayer\",\n        id=layer_id,\n        data=processed_data,\n        getPosition=get_position,\n        getText=get_text,\n        getSize=get_size,\n        getColor=get_color or [0, 0, 0, 255],\n        getAngle=get_angle,\n        getTextAnchor=text_anchor,\n        getAlignmentBaseline=alignment_baseline,\n        pickable=pickable,\n        opacity=opacity,\n        **kwargs,\n    )\n\n    self._layers = {**self._layers, layer_id: {\"id\": layer_id, \"type\": \"text\"}}\n    self._add_to_layer_dict(layer_id, \"Deck.gl\")\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.mapbox.MapboxMap.add_tile_layer","title":"<code>add_tile_layer(self, url, name=None, attribution='', min_zoom=0, max_zoom=22, **kwargs)</code>","text":"<p>Add an XYZ tile layer.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>Tile URL template with {x}, {y}, {z} placeholders.</p> required <code>name</code> <code>Optional[str]</code> <p>Layer name.</p> <code>None</code> <code>attribution</code> <code>str</code> <p>Attribution text.</p> <code>''</code> <code>min_zoom</code> <code>int</code> <p>Minimum zoom level.</p> <code>0</code> <code>max_zoom</code> <code>int</code> <p>Maximum zoom level.</p> <code>22</code> <code>**kwargs</code> <p>Additional options.</p> <code>{}</code> Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def add_tile_layer(\n    self,\n    url: str,\n    name: Optional[str] = None,\n    attribution: str = \"\",\n    min_zoom: int = 0,\n    max_zoom: int = 22,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add an XYZ tile layer.\n\n    Args:\n        url: Tile URL template with {x}, {y}, {z} placeholders.\n        name: Layer name.\n        attribution: Attribution text.\n        min_zoom: Minimum zoom level.\n        max_zoom: Maximum zoom level.\n        **kwargs: Additional options.\n    \"\"\"\n    layer_id = name or f\"tiles-{len(self._layers)}\"\n\n    self.call_js_method(\n        \"addTileLayer\",\n        url,\n        name=layer_id,\n        attribution=attribution,\n        minZoom=min_zoom,\n        maxZoom=max_zoom,\n        **kwargs,\n    )\n\n    # Track layer\n    self._layers = {\n        **self._layers,\n        layer_id: {\n            \"id\": layer_id,\n            \"type\": \"raster\",\n            \"source\": f\"{layer_id}-source\",\n        },\n    }\n    self._add_to_layer_dict(layer_id, \"Raster\")\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.mapbox.MapboxMap.add_time_slider","title":"<code>add_time_slider(self, layer_id, property, min_value=0, max_value=100, step=1, position='bottom-left', label='Time', auto_play=False, interval=500)</code>","text":"<p>Add a time slider to filter data by a temporal property.</p> Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def add_time_slider(\n    self,\n    layer_id: str,\n    property: str,\n    min_value: float = 0,\n    max_value: float = 100,\n    step: float = 1,\n    position: str = \"bottom-left\",\n    label: str = \"Time\",\n    auto_play: bool = False,\n    interval: int = 500,\n) -&gt; None:\n    \"\"\"Add a time slider to filter data by a temporal property.\"\"\"\n    self.call_js_method(\n        \"addTimeSlider\",\n        layerId=layer_id,\n        property=property,\n        min=min_value,\n        max=max_value,\n        step=step,\n        position=position,\n        label=label,\n        autoPlay=auto_play,\n        interval=interval,\n    )\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.mapbox.MapboxMap.add_tooltip","title":"<code>add_tooltip(self, layer_id, template=None, properties=None)</code>","text":"<p>Add a tooltip that shows on feature hover.</p> Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def add_tooltip(\n    self,\n    layer_id: str,\n    template: Optional[str] = None,\n    properties: Optional[List[str]] = None,\n) -&gt; None:\n    \"\"\"Add a tooltip that shows on feature hover.\"\"\"\n    self.call_js_method(\n        \"addTooltip\",\n        layerId=layer_id,\n        template=template or \"\",\n        properties=properties,\n    )\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.mapbox.MapboxMap.add_trips_layer","title":"<code>add_trips_layer(self, data, name=None, get_path='waypoints', get_timestamps='timestamps', get_color=None, width_min_pixels=2, trail_length=180, current_time=0, pickable=True, opacity=0.8, **kwargs)</code>","text":"<p>Add a trips layer using deck.gl.</p> Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def add_trips_layer(\n    self,\n    data: Any,\n    name: Optional[str] = None,\n    get_path: Union[str, Any] = \"waypoints\",\n    get_timestamps: Union[str, Any] = \"timestamps\",\n    get_color: Optional[Union[List[int], str]] = None,\n    width_min_pixels: float = 2,\n    trail_length: float = 180,\n    current_time: float = 0,\n    pickable: bool = True,\n    opacity: float = 0.8,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a trips layer using deck.gl.\"\"\"\n    layer_id = name or f\"trips-{len(self._layers)}\"\n    processed_data = self._process_deck_data(data)\n\n    self.call_js_method(\n        \"addTripsLayer\",\n        id=layer_id,\n        data=processed_data,\n        getPath=get_path,\n        getTimestamps=get_timestamps,\n        getColor=get_color or [253, 128, 93],\n        widthMinPixels=width_min_pixels,\n        trailLength=trail_length,\n        currentTime=current_time,\n        pickable=pickable,\n        opacity=opacity,\n        **kwargs,\n    )\n\n    self._layers = {**self._layers, layer_id: {\"id\": layer_id, \"type\": \"trips\"}}\n    self._add_to_layer_dict(layer_id, \"Deck.gl\")\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.mapbox.MapboxMap.add_vector","title":"<code>add_vector(self, data, layer_type=None, paint=None, name=None, fit_bounds=True, **kwargs)</code>","text":"<p>Add vector data to the map.</p> <p>Supports GeoJSON, GeoDataFrame, or file paths to vector formats.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>GeoJSON dict, GeoDataFrame, or path to vector file.</p> required <code>layer_type</code> <code>Optional[str]</code> <p>Mapbox layer type ('circle', 'line', 'fill', 'symbol').</p> <code>None</code> <code>paint</code> <code>Optional[Dict]</code> <p>Mapbox paint properties.</p> <code>None</code> <code>name</code> <code>Optional[str]</code> <p>Layer name.</p> <code>None</code> <code>fit_bounds</code> <code>bool</code> <p>Whether to fit map to data bounds.</p> <code>True</code> <code>**kwargs</code> <p>Additional layer options.</p> <code>{}</code> Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def add_vector(\n    self,\n    data: Any,\n    layer_type: Optional[str] = None,\n    paint: Optional[Dict] = None,\n    name: Optional[str] = None,\n    fit_bounds: bool = True,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add vector data to the map.\n\n    Supports GeoJSON, GeoDataFrame, or file paths to vector formats.\n\n    Args:\n        data: GeoJSON dict, GeoDataFrame, or path to vector file.\n        layer_type: Mapbox layer type ('circle', 'line', 'fill', 'symbol').\n        paint: Mapbox paint properties.\n        name: Layer name.\n        fit_bounds: Whether to fit map to data bounds.\n        **kwargs: Additional layer options.\n    \"\"\"\n    geojson = to_geojson(data)\n\n    layer_id = name or f\"vector-{len(self._layers)}\"\n\n    # Handle URL data - fetch GeoJSON to get bounds and infer layer type\n    if geojson.get(\"type\") == \"url\":\n        url = geojson[\"url\"]\n        geojson = fetch_geojson(url)\n\n    # Infer layer type if not specified\n    if layer_type is None:\n        layer_type = infer_layer_type(geojson)\n\n    # Get default paint if not provided\n    if paint is None:\n        paint = get_default_paint(layer_type)\n\n    # Get bounds (use geojson dict, not original data which may be a URL)\n    bounds = get_bounds(geojson) if fit_bounds else None\n\n    # Call JavaScript\n    self.call_js_method(\n        \"addGeoJSON\",\n        data=geojson,\n        name=layer_id,\n        layerType=layer_type,\n        paint=paint,\n        fitBounds=fit_bounds,\n        bounds=bounds,\n        **kwargs,\n    )\n\n    # Track layer\n    self._layers = {\n        **self._layers,\n        layer_id: {\n            \"id\": layer_id,\n            \"type\": layer_type,\n            \"source\": f\"{layer_id}-source\",\n            \"paint\": paint,\n        },\n    }\n    self._add_to_layer_dict(layer_id, \"Vector\")\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.mapbox.MapboxMap.add_vector_control","title":"<code>add_vector_control(self, position='top-right', collapsed=True, default_url=None, load_default_url=False, default_opacity=1.0, default_fill_color='#3388ff', default_stroke_color='#3388ff', fit_bounds=True, **kwargs)</code>","text":"<p>Add a vector layer control.</p> Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def add_vector_control(\n    self,\n    position: str = \"top-right\",\n    collapsed: bool = True,\n    default_url: Optional[str] = None,\n    load_default_url: bool = False,\n    default_opacity: float = 1.0,\n    default_fill_color: str = \"#3388ff\",\n    default_stroke_color: str = \"#3388ff\",\n    fit_bounds: bool = True,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a vector layer control.\"\"\"\n    self.call_js_method(\n        \"addVectorControl\",\n        position=position,\n        collapsed=collapsed,\n        defaultUrl=default_url or \"\",\n        loadDefaultUrl=load_default_url,\n        defaultOpacity=default_opacity,\n        defaultFillColor=default_fill_color,\n        defaultStrokeColor=default_stroke_color,\n        fitBounds=fit_bounds,\n        **kwargs,\n    )\n    self._controls = {\n        **self._controls,\n        \"vector-control\": {\"position\": position, \"collapsed\": collapsed},\n    }\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.mapbox.MapboxMap.add_video_layer","title":"<code>add_video_layer(self, urls, coordinates, name=None, opacity=1.0, **kwargs)</code>","text":"<p>Add a georeferenced video overlay on the map.</p> Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def add_video_layer(\n    self,\n    urls: List[str],\n    coordinates: List[List[float]],\n    name: Optional[str] = None,\n    opacity: float = 1.0,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a georeferenced video overlay on the map.\"\"\"\n    self._validate_opacity(opacity)\n    layer_id = name or f\"video-{len(self._layers)}\"\n\n    if len(coordinates) != 4:\n        raise ValueError(\n            \"coordinates must have exactly 4 corner points \"\n            \"[top-left, top-right, bottom-right, bottom-left]\"\n        )\n\n    self.call_js_method(\n        \"addVideoLayer\",\n        id=layer_id,\n        urls=urls,\n        coordinates=coordinates,\n        opacity=opacity,\n        **kwargs,\n    )\n\n    self._layers = {\n        **self._layers,\n        layer_id: {\n            \"id\": layer_id,\n            \"type\": \"video\",\n            \"source\": f\"{layer_id}-source\",\n        },\n    }\n    self._add_to_layer_dict(layer_id, \"Raster\")\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.mapbox.MapboxMap.add_zarr_control","title":"<code>add_zarr_control(self, position='top-right', collapsed=True, default_url=None, load_default_url=False, default_opacity=1.0, default_variable='', default_clim=None, **kwargs)</code>","text":"<p>Add a Zarr layer control.</p> Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def add_zarr_control(\n    self,\n    position: str = \"top-right\",\n    collapsed: bool = True,\n    default_url: Optional[str] = None,\n    load_default_url: bool = False,\n    default_opacity: float = 1.0,\n    default_variable: str = \"\",\n    default_clim: Optional[Tuple[float, float]] = None,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a Zarr layer control.\"\"\"\n    self.call_js_method(\n        \"addZarrControl\",\n        position=position,\n        collapsed=collapsed,\n        defaultUrl=default_url or \"\",\n        loadDefaultUrl=load_default_url,\n        defaultOpacity=default_opacity,\n        defaultVariable=default_variable,\n        defaultClim=list(default_clim) if default_clim else [0, 1],\n        **kwargs,\n    )\n    self._controls = {\n        **self._controls,\n        \"zarr-control\": {\"position\": position, \"collapsed\": collapsed},\n    }\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.mapbox.MapboxMap.add_zarr_layer","title":"<code>add_zarr_layer(self, url, variable, name=None, colormap=None, clim=None, opacity=1.0, selector=None, minzoom=0, maxzoom=22, fill_value=None, spatial_dimensions=None, zarr_version=None, bounds=None, **kwargs)</code>","text":"<p>Add a Zarr dataset layer for visualizing multidimensional array data.</p> Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def add_zarr_layer(\n    self,\n    url: str,\n    variable: str,\n    name: Optional[str] = None,\n    colormap: Optional[List[str]] = None,\n    clim: Optional[Tuple[float, float]] = None,\n    opacity: float = 1.0,\n    selector: Optional[Dict[str, Any]] = None,\n    minzoom: int = 0,\n    maxzoom: int = 22,\n    fill_value: Optional[float] = None,\n    spatial_dimensions: Optional[Dict[str, str]] = None,\n    zarr_version: Optional[int] = None,\n    bounds: Optional[List[float]] = None,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a Zarr dataset layer for visualizing multidimensional array data.\"\"\"\n    layer_id = name or f\"zarr-{len(self._layers)}\"\n\n    self.call_js_method(\n        \"addZarrLayer\",\n        id=layer_id,\n        source=url,\n        variable=variable,\n        colormap=colormap or [\"#000000\", \"#ffffff\"],\n        clim=list(clim) if clim else [0, 100],\n        opacity=opacity,\n        selector=selector or {},\n        minzoom=minzoom,\n        maxzoom=maxzoom,\n        fillValue=fill_value,\n        spatialDimensions=spatial_dimensions,\n        zarrVersion=zarr_version,\n        bounds=bounds,\n        **kwargs,\n    )\n\n    self._layers = {\n        **self._layers,\n        layer_id: {\n            \"id\": layer_id,\n            \"type\": \"zarr\",\n            \"url\": url,\n            \"variable\": variable,\n        },\n    }\n    self._add_to_layer_dict(layer_id, \"Raster\")\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.mapbox.MapboxMap.animate_along_route","title":"<code>animate_along_route(self, route, duration=10000, loop=True, marker_color='#3388ff', marker_size=1.0, show_trail=False, trail_color='#3388ff', trail_width=3, animation_id=None, **kwargs)</code>","text":"<p>Animate a marker along a route.</p> Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def animate_along_route(\n    self,\n    route: Any,\n    duration: int = 10000,\n    loop: bool = True,\n    marker_color: str = \"#3388ff\",\n    marker_size: float = 1.0,\n    show_trail: bool = False,\n    trail_color: str = \"#3388ff\",\n    trail_width: float = 3,\n    animation_id: Optional[str] = None,\n    **kwargs,\n) -&gt; str:\n    \"\"\"Animate a marker along a route.\"\"\"\n    anim_id = animation_id or f\"animation-{len(self._layers)}\"\n\n    if isinstance(route, list) and len(route) &gt; 0:\n        if isinstance(route[0], (list, tuple)):\n            coordinates = route\n        else:\n            raise ValueError(\"Route list must contain coordinate pairs\")\n    elif isinstance(route, dict):\n        if route.get(\"type\") == \"LineString\":\n            coordinates = route.get(\"coordinates\", [])\n        elif route.get(\"type\") == \"Feature\":\n            geometry = route.get(\"geometry\", {})\n            if geometry.get(\"type\") == \"LineString\":\n                coordinates = geometry.get(\"coordinates\", [])\n            else:\n                raise ValueError(\"Feature geometry must be LineString\")\n        elif route.get(\"type\") == \"FeatureCollection\":\n            features = route.get(\"features\", [])\n            if (\n                features\n                and features[0].get(\"geometry\", {}).get(\"type\") == \"LineString\"\n            ):\n                coordinates = features[0][\"geometry\"][\"coordinates\"]\n            else:\n                raise ValueError(\n                    \"FeatureCollection must contain LineString features\"\n                )\n        else:\n            raise ValueError(\n                \"GeoJSON must be LineString, Feature, or FeatureCollection\"\n            )\n    else:\n        geojson = to_geojson(route)\n        if geojson.get(\"type\") == \"url\":\n            geojson = fetch_geojson(geojson[\"url\"])\n        if geojson.get(\"type\") == \"FeatureCollection\":\n            features = geojson.get(\"features\", [])\n            if features:\n                coordinates = features[0].get(\"geometry\", {}).get(\"coordinates\", [])\n            else:\n                raise ValueError(\"No features found in data\")\n        elif geojson.get(\"type\") == \"Feature\":\n            coordinates = geojson.get(\"geometry\", {}).get(\"coordinates\", [])\n        else:\n            coordinates = geojson.get(\"coordinates\", [])\n\n    if len(coordinates) &lt; 2:\n        raise ValueError(\"Route must have at least 2 points\")\n\n    self.call_js_method(\n        \"animateAlongRoute\",\n        id=anim_id,\n        coordinates=coordinates,\n        duration=duration,\n        loop=loop,\n        markerColor=marker_color,\n        markerSize=marker_size,\n        showTrail=show_trail,\n        trailColor=trail_color,\n        trailWidth=trail_width,\n        **kwargs,\n    )\n\n    self._layers = {\n        **self._layers,\n        anim_id: {\n            \"id\": anim_id,\n            \"type\": \"animation\",\n        },\n    }\n    return anim_id\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.mapbox.MapboxMap.clear_draw_data","title":"<code>clear_draw_data(self)</code>","text":"<p>Clear all drawn features.</p> Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def clear_draw_data(self) -&gt; None:\n    \"\"\"Clear all drawn features.\"\"\"\n    self._draw_data = {\"type\": \"FeatureCollection\", \"features\": []}\n    self.call_js_method(\"clearDrawData\")\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.mapbox.MapboxMap.get_draw_data","title":"<code>get_draw_data(self)</code>","text":"<p>Get the current drawn features as GeoJSON.</p> Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def get_draw_data(self) -&gt; Dict:\n    \"\"\"Get the current drawn features as GeoJSON.\"\"\"\n    self.call_js_method(\"getDrawData\")\n    import time\n\n    time.sleep(0.1)\n    return self._draw_data or {\"type\": \"FeatureCollection\", \"features\": []}\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.mapbox.MapboxMap.get_layer","title":"<code>get_layer(self, layer_id)</code>","text":"<p>Get layer configuration by ID.</p> Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def get_layer(self, layer_id: str) -&gt; Optional[Dict]:\n    \"\"\"Get layer configuration by ID.\"\"\"\n    return self._layers.get(layer_id)\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.mapbox.MapboxMap.get_layer_ids","title":"<code>get_layer_ids(self)</code>","text":"<p>Get list of all layer IDs.</p> Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def get_layer_ids(self) -&gt; List[str]:\n    \"\"\"Get list of all layer IDs.\"\"\"\n    return list(self._layers.keys())\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.mapbox.MapboxMap.get_visible_features","title":"<code>get_visible_features(self, layers=None)</code>","text":"<p>Get all features currently visible in the viewport.</p> Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def get_visible_features(\n    self,\n    layers: Optional[List[str]] = None,\n) -&gt; Optional[Dict]:\n    \"\"\"Get all features currently visible in the viewport.\"\"\"\n    if layers is not None:\n        self.call_js_method(\"getVisibleFeatures\", layers=layers)\n    features = self._queried_features\n    if features and \"data\" in features:\n        return features[\"data\"]\n    return None\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.mapbox.MapboxMap.load_draw_data","title":"<code>load_draw_data(self, geojson)</code>","text":"<p>Load GeoJSON features into the drawing layer.</p> Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def load_draw_data(self, geojson: Dict) -&gt; None:\n    \"\"\"Load GeoJSON features into the drawing layer.\"\"\"\n    self._draw_data = geojson\n    self.call_js_method(\"loadDrawData\", geojson)\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.mapbox.MapboxMap.move_layer","title":"<code>move_layer(self, layer_id, before_id=None)</code>","text":"<p>Move a layer in the layer stack.</p> Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def move_layer(self, layer_id: str, before_id: Optional[str] = None) -&gt; None:\n    \"\"\"Move a layer in the layer stack.\"\"\"\n    self.call_js_method(\"moveLayer\", layer_id, before_id)\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.mapbox.MapboxMap.pause_animation","title":"<code>pause_animation(self, animation_id)</code>","text":"<p>Pause a running animation.</p> Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def pause_animation(self, animation_id: str) -&gt; None:\n    \"\"\"Pause a running animation.\"\"\"\n    self.call_js_method(\"pauseAnimation\", animation_id)\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.mapbox.MapboxMap.pause_video","title":"<code>pause_video(self, name)</code>","text":"<p>Pause a video layer.</p> Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def pause_video(self, name: str) -&gt; None:\n    \"\"\"Pause a video layer.\"\"\"\n    self.call_js_method(\"pauseVideo\", id=name)\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.mapbox.MapboxMap.play_video","title":"<code>play_video(self, name)</code>","text":"<p>Start playing a video layer.</p> Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def play_video(self, name: str) -&gt; None:\n    \"\"\"Start playing a video layer.\"\"\"\n    self.call_js_method(\"playVideo\", id=name)\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.mapbox.MapboxMap.query_rendered_features","title":"<code>query_rendered_features(self, geometry=None, layers=None, filter_expression=None)</code>","text":"<p>Query features currently rendered on the map.</p> Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def query_rendered_features(\n    self,\n    geometry: Optional[Any] = None,\n    layers: Optional[List[str]] = None,\n    filter_expression: Optional[List] = None,\n) -&gt; Dict:\n    \"\"\"Query features currently rendered on the map.\"\"\"\n    kwargs: Dict[str, Any] = {}\n    if geometry is not None:\n        kwargs[\"geometry\"] = geometry\n    if layers is not None:\n        kwargs[\"layers\"] = layers\n    if filter_expression is not None:\n        kwargs[\"filter\"] = filter_expression\n\n    self.call_js_method(\"queryRenderedFeatures\", **kwargs)\n    return self._queried_features\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.mapbox.MapboxMap.query_source_features","title":"<code>query_source_features(self, source_id, source_layer=None, filter_expression=None)</code>","text":"<p>Query features from a source.</p> Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def query_source_features(\n    self,\n    source_id: str,\n    source_layer: Optional[str] = None,\n    filter_expression: Optional[List] = None,\n) -&gt; Dict:\n    \"\"\"Query features from a source.\"\"\"\n    kwargs: Dict[str, Any] = {\"sourceId\": source_id}\n    if source_layer is not None:\n        kwargs[\"sourceLayer\"] = source_layer\n    if filter_expression is not None:\n        kwargs[\"filter\"] = filter_expression\n\n    self.call_js_method(\"querySourceFeatures\", **kwargs)\n    return self._queried_features\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.mapbox.MapboxMap.remove_arc_layer","title":"<code>remove_arc_layer(self, layer_id)</code>","text":"<p>Remove an arc layer.</p> Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def remove_arc_layer(self, layer_id: str) -&gt; None:\n    \"\"\"Remove an arc layer.\"\"\"\n    self._remove_layer_internal(layer_id, \"removeArcLayer\")\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.mapbox.MapboxMap.remove_cluster_layer","title":"<code>remove_cluster_layer(self, layer_id)</code>","text":"<p>Remove a cluster layer.</p> Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def remove_cluster_layer(self, layer_id: str) -&gt; None:\n    \"\"\"Remove a cluster layer.\"\"\"\n    self._remove_layer_internal(layer_id, \"removeClusterLayer\")\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.mapbox.MapboxMap.remove_cog_layer","title":"<code>remove_cog_layer(self, layer_id)</code>","text":"<p>Remove a COG layer.</p> Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def remove_cog_layer(self, layer_id: str) -&gt; None:\n    \"\"\"Remove a COG layer.\"\"\"\n    self._remove_layer_internal(layer_id, \"removeCOGLayer\")\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.mapbox.MapboxMap.remove_colorbar","title":"<code>remove_colorbar(self, colorbar_id=None)</code>","text":"<p>Remove a colorbar from the map.</p> Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def remove_colorbar(self, colorbar_id: Optional[str] = None) -&gt; None:\n    \"\"\"Remove a colorbar from the map.\"\"\"\n    if colorbar_id is None:\n        cbar_keys = [k for k in self._controls.keys() if k.startswith(\"colorbar\")]\n        for key in cbar_keys:\n            self.call_js_method(\"removeColorbar\", colorbarId=key)\n        self._controls = {\n            k: v for k, v in self._controls.items() if not k.startswith(\"colorbar\")\n        }\n    else:\n        self.call_js_method(\"removeColorbar\", colorbarId=colorbar_id)\n        if colorbar_id in self._controls:\n            controls = dict(self._controls)\n            del controls[colorbar_id]\n            self._controls = controls\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.mapbox.MapboxMap.remove_control","title":"<code>remove_control(self, control_type)</code>","text":"<p>Remove a map control.</p> Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def remove_control(self, control_type: str) -&gt; None:\n    \"\"\"Remove a map control.\"\"\"\n    self.call_js_method(\"removeControl\", control_type)\n    if control_type in self._controls:\n        controls = dict(self._controls)\n        del controls[control_type]\n        self._controls = controls\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.mapbox.MapboxMap.remove_coordinates_control","title":"<code>remove_coordinates_control(self)</code>","text":"<p>Remove the coordinates display control.</p> Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def remove_coordinates_control(self) -&gt; None:\n    \"\"\"Remove the coordinates display control.\"\"\"\n    self.call_js_method(\"removeCoordinatesControl\")\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.mapbox.MapboxMap.remove_deck_layer","title":"<code>remove_deck_layer(self, layer_id)</code>","text":"<p>Remove a deck.gl layer from the map.</p> Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def remove_deck_layer(self, layer_id: str) -&gt; None:\n    \"\"\"Remove a deck.gl layer from the map.\"\"\"\n    self._remove_layer_internal(layer_id, \"removeDeckLayer\")\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.mapbox.MapboxMap.remove_flatgeobuf","title":"<code>remove_flatgeobuf(self, name)</code>","text":"<p>Remove a FlatGeobuf layer from the map.</p> Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def remove_flatgeobuf(self, name: str) -&gt; None:\n    \"\"\"Remove a FlatGeobuf layer from the map.\"\"\"\n    if name in self._layers:\n        layers = dict(self._layers)\n        del layers[name]\n        self._layers = layers\n    self._remove_from_layer_dict(name)\n    self.call_js_method(\"removeFlatGeobuf\", name=name)\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.mapbox.MapboxMap.remove_fog","title":"<code>remove_fog(self)</code>","text":"<p>Remove fog atmospheric effects from the map.</p> Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def remove_fog(self) -&gt; None:\n    \"\"\"Remove fog atmospheric effects from the map.\"\"\"\n    self.call_js_method(\"removeFog\")\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.mapbox.MapboxMap.remove_layer","title":"<code>remove_layer(self, layer_id)</code>","text":"<p>Remove a layer from the map.</p> Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def remove_layer(self, layer_id: str) -&gt; None:\n    \"\"\"Remove a layer from the map.\"\"\"\n    if layer_id in self._layers:\n        layers = dict(self._layers)\n        del layers[layer_id]\n        self._layers = layers\n    self._remove_from_layer_dict(layer_id)\n    self.call_js_method(\"removeLayer\", layer_id)\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.mapbox.MapboxMap.remove_legend","title":"<code>remove_legend(self, legend_id=None)</code>","text":"<p>Remove a legend control from the map.</p> Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def remove_legend(self, legend_id: Optional[str] = None) -&gt; None:\n    \"\"\"Remove a legend control from the map.\"\"\"\n    if legend_id is None:\n        legend_keys = [k for k in self._controls.keys() if k.startswith(\"legend\")]\n        for key in legend_keys:\n            self.call_js_method(\"removeLegend\", key)\n        self._controls = {\n            k: v for k, v in self._controls.items() if not k.startswith(\"legend\")\n        }\n    else:\n        self.call_js_method(\"removeLegend\", legend_id)\n        if legend_id in self._controls:\n            controls = dict(self._controls)\n            del controls[legend_id]\n            self._controls = controls\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.mapbox.MapboxMap.remove_lidar_layer","title":"<code>remove_lidar_layer(self, layer_id=None)</code>","text":"<p>Remove a LiDAR layer.</p> <p>Parameters:</p> Name Type Description Default <code>layer_id</code> <code>Optional[str]</code> <p>Layer identifier to remove. If None, removes all LiDAR layers.</p> <code>None</code> Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def remove_lidar_layer(self, layer_id: Optional[str] = None) -&gt; None:\n    \"\"\"Remove a LiDAR layer.\n\n    Args:\n        layer_id: Layer identifier to remove. If None, removes all LiDAR layers.\n    \"\"\"\n    if layer_id:\n        if layer_id in self._layers:\n            layers = dict(self._layers)\n            del layers[layer_id]\n            self._layers = layers\n        self.call_js_method(\"removeLidarLayer\", id=layer_id)\n    else:\n        # Remove all lidar layers\n        layers = dict(self._layers)\n        self._layers = {k: v for k, v in layers.items() if v.get(\"type\") != \"lidar\"}\n        self.call_js_method(\"removeLidarLayer\")\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.mapbox.MapboxMap.remove_marker","title":"<code>remove_marker(self, marker_id)</code>","text":"<p>Remove a marker from the map.</p> Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def remove_marker(self, marker_id: str) -&gt; None:\n    \"\"\"Remove a marker from the map.\"\"\"\n    self._remove_layer_internal(marker_id, \"removeMarker\")\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.mapbox.MapboxMap.remove_measure_control","title":"<code>remove_measure_control(self)</code>","text":"<p>Remove the measurement control.</p> Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def remove_measure_control(self) -&gt; None:\n    \"\"\"Remove the measurement control.\"\"\"\n    self.call_js_method(\"removeMeasureControl\")\n    if \"measure-control\" in self._controls:\n        controls = dict(self._controls)\n        del controls[\"measure-control\"]\n        self._controls = controls\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.mapbox.MapboxMap.remove_opacity_slider","title":"<code>remove_opacity_slider(self, layer_id)</code>","text":"<p>Remove the opacity slider for a layer.</p> Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def remove_opacity_slider(self, layer_id: str) -&gt; None:\n    \"\"\"Remove the opacity slider for a layer.\"\"\"\n    self.call_js_method(\"removeOpacitySlider\", layerId=layer_id)\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.mapbox.MapboxMap.remove_pmtiles_layer","title":"<code>remove_pmtiles_layer(self, layer_id)</code>","text":"<p>Remove a PMTiles layer.</p> Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def remove_pmtiles_layer(self, layer_id: str) -&gt; None:\n    \"\"\"Remove a PMTiles layer.\"\"\"\n    self._remove_layer_internal(layer_id, \"removePMTilesLayer\")\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.mapbox.MapboxMap.remove_point_cloud_layer","title":"<code>remove_point_cloud_layer(self, layer_id)</code>","text":"<p>Remove a point cloud layer.</p> Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def remove_point_cloud_layer(self, layer_id: str) -&gt; None:\n    \"\"\"Remove a point cloud layer.\"\"\"\n    self._remove_layer_internal(layer_id, \"removePointCloudLayer\")\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.mapbox.MapboxMap.remove_print_control","title":"<code>remove_print_control(self)</code>","text":"<p>Remove the print/export control.</p> Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def remove_print_control(self) -&gt; None:\n    \"\"\"Remove the print/export control.\"\"\"\n    self.call_js_method(\"removePrintControl\")\n    if \"print-control\" in self._controls:\n        controls = dict(self._controls)\n        del controls[\"print-control\"]\n        self._controls = controls\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.mapbox.MapboxMap.remove_search_control","title":"<code>remove_search_control(self)</code>","text":"<p>Remove the search/geocoder control.</p> Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def remove_search_control(self) -&gt; None:\n    \"\"\"Remove the search/geocoder control.\"\"\"\n    self.call_js_method(\"removeSearchControl\")\n    if \"search-control\" in self._controls:\n        controls = dict(self._controls)\n        del controls[\"search-control\"]\n        self._controls = controls\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.mapbox.MapboxMap.remove_split_map","title":"<code>remove_split_map(self)</code>","text":"<p>Remove the split map comparison view.</p> Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def remove_split_map(self) -&gt; None:\n    \"\"\"Remove the split map comparison view.\"\"\"\n    self.call_js_method(\"removeSplitMap\")\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.mapbox.MapboxMap.remove_style_switcher","title":"<code>remove_style_switcher(self)</code>","text":"<p>Remove the style switcher control.</p> Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def remove_style_switcher(self) -&gt; None:\n    \"\"\"Remove the style switcher control.\"\"\"\n    self.call_js_method(\"removeStyleSwitcher\")\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.mapbox.MapboxMap.remove_swipe_map","title":"<code>remove_swipe_map(self)</code>","text":"<p>Remove the swipe map comparison control.</p> Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def remove_swipe_map(self) -&gt; None:\n    \"\"\"Remove the swipe map comparison control.\"\"\"\n    self.call_js_method(\"removeSwipeMap\")\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.mapbox.MapboxMap.remove_terrain","title":"<code>remove_terrain(self)</code>","text":"<p>Remove 3D terrain from the map.</p> Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def remove_terrain(self) -&gt; None:\n    \"\"\"Remove 3D terrain from the map.\"\"\"\n    self.call_js_method(\"removeTerrain\")\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.mapbox.MapboxMap.remove_time_slider","title":"<code>remove_time_slider(self)</code>","text":"<p>Remove the time slider control.</p> Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def remove_time_slider(self) -&gt; None:\n    \"\"\"Remove the time slider control.\"\"\"\n    self.call_js_method(\"removeTimeSlider\")\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.mapbox.MapboxMap.remove_tooltip","title":"<code>remove_tooltip(self, layer_id)</code>","text":"<p>Remove tooltip from a layer.</p> Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def remove_tooltip(self, layer_id: str) -&gt; None:\n    \"\"\"Remove tooltip from a layer.\"\"\"\n    self.call_js_method(\"removeTooltip\", layerId=layer_id)\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.mapbox.MapboxMap.remove_video_layer","title":"<code>remove_video_layer(self, name)</code>","text":"<p>Remove a video layer from the map.</p> Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def remove_video_layer(self, name: str) -&gt; None:\n    \"\"\"Remove a video layer from the map.\"\"\"\n    if name in self._layers:\n        layers = dict(self._layers)\n        del layers[name]\n        self._layers = layers\n    self._remove_from_layer_dict(name)\n    self.call_js_method(\"removeVideoLayer\", id=name)\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.mapbox.MapboxMap.remove_zarr_layer","title":"<code>remove_zarr_layer(self, layer_id)</code>","text":"<p>Remove a Zarr layer.</p> Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def remove_zarr_layer(self, layer_id: str) -&gt; None:\n    \"\"\"Remove a Zarr layer.\"\"\"\n    self._remove_layer_internal(layer_id, \"removeZarrLayer\")\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.mapbox.MapboxMap.resume_animation","title":"<code>resume_animation(self, animation_id)</code>","text":"<p>Resume a paused animation.</p> Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def resume_animation(self, animation_id: str) -&gt; None:\n    \"\"\"Resume a paused animation.\"\"\"\n    self.call_js_method(\"resumeAnimation\", animation_id)\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.mapbox.MapboxMap.save_draw_data","title":"<code>save_draw_data(self, filepath, driver=None)</code>","text":"<p>Save drawn features to a file.</p> Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def save_draw_data(\n    self,\n    filepath: Union[str, Path],\n    driver: Optional[str] = None,\n) -&gt; None:\n    \"\"\"Save drawn features to a file.\"\"\"\n    try:\n        import geopandas as gpd\n    except ImportError:\n        raise ImportError(\n            \"geopandas is required to save draw data. \"\n            \"Install with: pip install anymap-ts[vector]\"\n        )\n\n    data = self.get_draw_data()\n    if not data.get(\"features\"):\n        print(\"No features to save\")\n        return\n\n    gdf = gpd.GeoDataFrame.from_features(data[\"features\"])\n    filepath = Path(filepath)\n\n    if driver is None:\n        ext = filepath.suffix.lower()\n        driver_map = {\n            \".geojson\": \"GeoJSON\",\n            \".json\": \"GeoJSON\",\n            \".shp\": \"ESRI Shapefile\",\n            \".gpkg\": \"GPKG\",\n        }\n        driver = driver_map.get(ext, \"GeoJSON\")\n\n    gdf.to_file(filepath, driver=driver)\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.mapbox.MapboxMap.seek_video","title":"<code>seek_video(self, name, time)</code>","text":"<p>Seek to a specific time in a video layer.</p> Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def seek_video(self, name: str, time: float) -&gt; None:\n    \"\"\"Seek to a specific time in a video layer.\"\"\"\n    self.call_js_method(\"seekVideo\", id=name, time=time)\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.mapbox.MapboxMap.set_access_token","title":"<code>set_access_token(self, token)</code>","text":"<p>Set the Mapbox access token.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>str</code> <p>Mapbox access token.</p> required Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def set_access_token(self, token: str) -&gt; None:\n    \"\"\"Set the Mapbox access token.\n\n    Args:\n        token: Mapbox access token.\n    \"\"\"\n    self.access_token = token\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.mapbox.MapboxMap.set_animation_speed","title":"<code>set_animation_speed(self, animation_id, speed)</code>","text":"<p>Set animation speed multiplier.</p> Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def set_animation_speed(self, animation_id: str, speed: float) -&gt; None:\n    \"\"\"Set animation speed multiplier.\"\"\"\n    self.call_js_method(\"setAnimationSpeed\", animation_id, speed)\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.mapbox.MapboxMap.set_filter","title":"<code>set_filter(self, layer_id, filter_expression=None)</code>","text":"<p>Set or clear a filter on a map layer.</p> Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def set_filter(\n    self,\n    layer_id: str,\n    filter_expression: Optional[List] = None,\n) -&gt; None:\n    \"\"\"Set or clear a filter on a map layer.\"\"\"\n    self.call_js_method(\n        \"setFilter\",\n        layerId=layer_id,\n        filter=filter_expression,\n    )\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.mapbox.MapboxMap.set_fog","title":"<code>set_fog(self, color=None, high_color=None, low_color=None, horizon_blend=None, range=None, **kwargs)</code>","text":"<p>Set fog atmospheric effect (Mapbox uses map.setFog() API).</p> Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def set_fog(\n    self,\n    color: Optional[str] = None,\n    high_color: Optional[str] = None,\n    low_color: Optional[str] = None,\n    horizon_blend: Optional[float] = None,\n    range: Optional[List[float]] = None,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Set fog atmospheric effect (Mapbox uses map.setFog() API).\"\"\"\n    self.call_js_method(\n        \"setFog\",\n        color=color,\n        highColor=high_color,\n        lowColor=low_color,\n        horizonBlend=horizon_blend,\n        range=range,\n        **kwargs,\n    )\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.mapbox.MapboxMap.set_layout_property","title":"<code>set_layout_property(self, layer_id, property_name, value)</code>","text":"<p>Set a layout property for a layer.</p> Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def set_layout_property(\n    self, layer_id: str, property_name: str, value: Any\n) -&gt; None:\n    \"\"\"Set a layout property for a layer.\"\"\"\n    self.call_js_method(\"setLayoutProperty\", layer_id, property_name, value)\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.mapbox.MapboxMap.set_lidar_color_scheme","title":"<code>set_lidar_color_scheme(self, color_scheme)</code>","text":"<p>Set the LiDAR color scheme.</p> <p>Parameters:</p> Name Type Description Default <code>color_scheme</code> <code>str</code> <p>Color scheme ('elevation', 'intensity', 'classification', 'rgb').</p> required Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def set_lidar_color_scheme(self, color_scheme: str) -&gt; None:\n    \"\"\"Set the LiDAR color scheme.\n\n    Args:\n        color_scheme: Color scheme ('elevation', 'intensity', 'classification', 'rgb').\n    \"\"\"\n    self.call_js_method(\"setLidarColorScheme\", colorScheme=color_scheme)\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.mapbox.MapboxMap.set_lidar_opacity","title":"<code>set_lidar_opacity(self, opacity)</code>","text":"<p>Set the LiDAR layer opacity.</p> <p>Parameters:</p> Name Type Description Default <code>opacity</code> <code>float</code> <p>Opacity value between 0 and 1.</p> required Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def set_lidar_opacity(self, opacity: float) -&gt; None:\n    \"\"\"Set the LiDAR layer opacity.\n\n    Args:\n        opacity: Opacity value between 0 and 1.\n    \"\"\"\n    self.call_js_method(\"setLidarOpacity\", opacity=opacity)\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.mapbox.MapboxMap.set_lidar_point_size","title":"<code>set_lidar_point_size(self, point_size)</code>","text":"<p>Set the LiDAR point size.</p> <p>Parameters:</p> Name Type Description Default <code>point_size</code> <code>float</code> <p>Point size in pixels.</p> required Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def set_lidar_point_size(self, point_size: float) -&gt; None:\n    \"\"\"Set the LiDAR point size.\n\n    Args:\n        point_size: Point size in pixels.\n    \"\"\"\n    self.call_js_method(\"setLidarPointSize\", pointSize=point_size)\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.mapbox.MapboxMap.set_opacity","title":"<code>set_opacity(self, layer_id, opacity)</code>","text":"<p>Set layer opacity.</p> Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def set_opacity(self, layer_id: str, opacity: float) -&gt; None:\n    \"\"\"Set layer opacity.\"\"\"\n    self._validate_opacity(opacity)\n    self.call_js_method(\"setOpacity\", layer_id, opacity)\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.mapbox.MapboxMap.set_paint_property","title":"<code>set_paint_property(self, layer_id, property_name, value)</code>","text":"<p>Set a paint property for a layer.</p> Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def set_paint_property(self, layer_id: str, property_name: str, value: Any) -&gt; None:\n    \"\"\"Set a paint property for a layer.\"\"\"\n    self.call_js_method(\"setPaintProperty\", layer_id, property_name, value)\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.mapbox.MapboxMap.set_projection","title":"<code>set_projection(self, projection='mercator')</code>","text":"<p>Set the map projection (Mapbox supports 'globe' and 'mercator').</p> Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def set_projection(self, projection: str = \"mercator\") -&gt; None:\n    \"\"\"Set the map projection (Mapbox supports 'globe' and 'mercator').\"\"\"\n    self.call_js_method(\"setProjection\", projection=projection)\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.mapbox.MapboxMap.set_visibility","title":"<code>set_visibility(self, layer_id, visible)</code>","text":"<p>Set layer visibility.</p> <p>Parameters:</p> Name Type Description Default <code>layer_id</code> <code>str</code> <p>Layer identifier.</p> required <code>visible</code> <code>bool</code> <p>Whether layer should be visible.</p> required Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def set_visibility(self, layer_id: str, visible: bool) -&gt; None:\n    \"\"\"Set layer visibility.\n\n    Args:\n        layer_id: Layer identifier.\n        visible: Whether layer should be visible.\n    \"\"\"\n    self.call_js_method(\"setVisibility\", layer_id, visible)\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.mapbox.MapboxMap.stop_animation","title":"<code>stop_animation(self, animation_id)</code>","text":"<p>Stop a running animation.</p> Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def stop_animation(self, animation_id: str) -&gt; None:\n    \"\"\"Stop a running animation.\"\"\"\n    self.call_js_method(\"stopAnimation\", animation_id)\n    if animation_id in self._layers:\n        layers = dict(self._layers)\n        del layers[animation_id]\n        self._layers = layers\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.mapbox.MapboxMap.to_geojson","title":"<code>to_geojson(self, layer_id=None)</code>","text":"<p>Get layer data as GeoJSON.</p> Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def to_geojson(self, layer_id: Optional[str] = None) -&gt; Optional[Dict]:\n    \"\"\"Get layer data as GeoJSON.\"\"\"\n    if layer_id:\n        self.call_js_method(\"getLayerData\", sourceId=layer_id)\n    features = self._queried_features\n    if features and \"data\" in features:\n        return features[\"data\"]\n    return None\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.mapbox.MapboxMap.to_geopandas","title":"<code>to_geopandas(self, layer_id=None)</code>","text":"<p>Get layer data as a GeoDataFrame.</p> Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def to_geopandas(self, layer_id: Optional[str] = None) -&gt; Any:\n    \"\"\"Get layer data as a GeoDataFrame.\"\"\"\n    geojson = self.to_geojson(layer_id)\n    if geojson is None:\n        return None\n    try:\n        import geopandas as gpd\n\n        return gpd.GeoDataFrame.from_features(geojson.get(\"features\", []))\n    except ImportError:\n        raise ImportError(\"geopandas is required for to_geopandas()\")\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.mapbox.MapboxMap.update_colorbar","title":"<code>update_colorbar(self, colorbar_id=None, **kwargs)</code>","text":"<p>Update an existing colorbar's properties.</p> Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def update_colorbar(self, colorbar_id: Optional[str] = None, **kwargs) -&gt; None:\n    \"\"\"Update an existing colorbar's properties.\"\"\"\n    if colorbar_id is None:\n        cbar_keys = [k for k in self._controls.keys() if k.startswith(\"colorbar\")]\n        if not cbar_keys:\n            raise ValueError(\"No colorbar found to update\")\n        colorbar_id = cbar_keys[0]\n\n    if colorbar_id not in self._controls:\n        raise ValueError(f\"Colorbar '{colorbar_id}' not found\")\n\n    js_kwargs: Dict[str, Any] = {\"colorbarId\": colorbar_id}\n    key_map = {\"bar_thickness\": \"barThickness\", \"bar_length\": \"barLength\"}\n    for key, value in kwargs.items():\n        js_key = key_map.get(key, key)\n        js_kwargs[js_key] = value\n\n    self.call_js_method(\"updateColorbar\", **js_kwargs)\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.mapbox.MapboxMap.update_geojson_source","title":"<code>update_geojson_source(self, source_id, data)</code>","text":"<p>Update the data of an existing GeoJSON source in place.</p> Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def update_geojson_source(self, source_id: str, data: Any) -&gt; None:\n    \"\"\"Update the data of an existing GeoJSON source in place.\"\"\"\n    processed_data = self._process_deck_data(data)\n    self.call_js_method(\n        \"updateGeoJSONSource\",\n        sourceId=source_id,\n        data=processed_data,\n    )\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.mapbox.MapboxMap.update_legend","title":"<code>update_legend(self, legend_id, title=None, labels=None, colors=None, opacity=None, **kwargs)</code>","text":"<p>Update an existing legend's properties.</p> Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def update_legend(\n    self,\n    legend_id: str,\n    title: Optional[str] = None,\n    labels: Optional[List[str]] = None,\n    colors: Optional[List[str]] = None,\n    opacity: Optional[float] = None,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Update an existing legend's properties.\"\"\"\n    if legend_id not in self._controls:\n        raise ValueError(f\"Legend '{legend_id}' not found\")\n\n    update_params = {\"id\": legend_id}\n\n    if title is not None:\n        update_params[\"title\"] = title\n        self._controls[legend_id][\"title\"] = title\n\n    if labels is not None and colors is not None:\n        if len(labels) != len(colors):\n            raise ValueError(\"Number of labels must match number of colors\")\n\n        legend_items = [\n            {\"label\": label, \"color\": color} for label, color in zip(labels, colors)\n        ]\n        update_params[\"items\"] = legend_items\n        self._controls[legend_id][\"labels\"] = labels\n        self._controls[legend_id][\"colors\"] = colors\n\n    elif labels is not None or colors is not None:\n        raise ValueError(\"Both labels and colors must be provided together\")\n\n    if opacity is not None:\n        update_params[\"opacity\"] = opacity\n        self._controls[legend_id][\"opacity\"] = opacity\n\n    update_params.update(kwargs)\n    self.call_js_method(\"updateLegend\", **update_params)\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.mapbox.MapboxMap.update_zarr_layer","title":"<code>update_zarr_layer(self, layer_id, selector=None, clim=None, colormap=None, opacity=None)</code>","text":"<p>Update a Zarr layer's properties dynamically.</p> Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def update_zarr_layer(\n    self,\n    layer_id: str,\n    selector: Optional[Dict[str, Any]] = None,\n    clim: Optional[Tuple[float, float]] = None,\n    colormap: Optional[List[str]] = None,\n    opacity: Optional[float] = None,\n) -&gt; None:\n    \"\"\"Update a Zarr layer's properties dynamically.\"\"\"\n    update_kwargs: Dict[str, Any] = {\"id\": layer_id}\n    if selector is not None:\n        update_kwargs[\"selector\"] = selector\n    if clim is not None:\n        update_kwargs[\"clim\"] = list(clim)\n    if colormap is not None:\n        update_kwargs[\"colormap\"] = colormap\n    if opacity is not None:\n        update_kwargs[\"opacity\"] = opacity\n    self.call_js_method(\"updateZarrLayer\", **update_kwargs)\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.mapbox.get_mapbox_token","title":"<code>get_mapbox_token()</code>","text":"<p>Get Mapbox access token from environment variable.</p> <p>Returns:</p> Type Description <code>str</code> <p>Mapbox access token string, or empty string if not set.</p> Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def get_mapbox_token() -&gt; str:\n    \"\"\"Get Mapbox access token from environment variable.\n\n    Returns:\n        Mapbox access token string, or empty string if not set.\n    \"\"\"\n    return os.environ.get(\"MAPBOX_TOKEN\", \"\")\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.maplibre","title":"<code>maplibre</code>","text":"<p>MapLibre GL JS map widget implementation.</p>"},{"location":"anymap_ts/#anymap_ts.maplibre.MapLibreMap","title":"<code> MapLibreMap            (MapWidget)         </code>","text":"<p>Interactive map widget using MapLibre GL JS.</p> <p>This class provides a Python interface to MapLibre GL JS maps with full bidirectional communication through anywidget.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from anymap_ts import Map\n&gt;&gt;&gt; m = Map(center=[-122.4, 37.8], zoom=10)\n&gt;&gt;&gt; m.add_basemap(\"OpenStreetMap\")\n&gt;&gt;&gt; m\n</code></pre> Source code in <code>anymap_ts/maplibre.py</code> <pre><code>class MapLibreMap(MapWidget):\n    \"\"\"Interactive map widget using MapLibre GL JS.\n\n    This class provides a Python interface to MapLibre GL JS maps with\n    full bidirectional communication through anywidget.\n\n    Example:\n        &gt;&gt;&gt; from anymap_ts import Map\n        &gt;&gt;&gt; m = Map(center=[-122.4, 37.8], zoom=10)\n        &gt;&gt;&gt; m.add_basemap(\"OpenStreetMap\")\n        &gt;&gt;&gt; m\n    \"\"\"\n\n    # ESM module for frontend\n    _esm = STATIC_DIR / \"maplibre.js\"\n    _css = STATIC_DIR / \"maplibre.css\"\n\n    # MapLibre-specific traits\n    bearing = traitlets.Float(0.0).tag(sync=True)\n    pitch = traitlets.Float(0.0).tag(sync=True)\n    projection = traitlets.Unicode(\"mercator\").tag(sync=True)\n    antialias = traitlets.Bool(True).tag(sync=True)\n    double_click_zoom = traitlets.Bool(True).tag(sync=True)\n\n    # Layer tracking\n    _layer_dict = traitlets.Dict({}).tag(sync=True)\n\n    def __init__(\n        self,\n        center: Tuple[float, float] = (0.0, 0.0),\n        zoom: float = 2.0,\n        width: str = \"100%\",\n        height: str = \"700px\",\n        style: Union[\n            str, Dict\n        ] = \"https://basemaps.cartocdn.com/gl/positron-gl-style/style.json\",\n        bearing: float = 0.0,\n        pitch: float = 0.0,\n        max_pitch: float = 85.0,\n        projection: str = \"mercator\",\n        controls: Optional[Dict[str, Any]] = None,\n        **kwargs,\n    ):\n        \"\"\"Initialize a MapLibre map.\n\n        Args:\n            center: Map center as (longitude, latitude).\n            zoom: Initial zoom level.\n            width: Map width as CSS string.\n            height: Map height as CSS string. Default is \"700px\".\n            style: MapLibre style URL or style object. Default is \"https://basemaps.cartocdn.com/gl/positron-gl-style/style.json\".\n            bearing: Map bearing in degrees.\n            pitch: Map pitch in degrees.\n            max_pitch: Maximum pitch angle in degrees (default: 85).\n            projection: Map projection. Supported values: 'mercator', 'globe'.\n                Default is 'mercator'.\n            controls: Dict of controls to add. If None, defaults to\n                {\"layer-control\": True, \"control-grid\": True}.\n                Use {\"layer-control\": {\"collapsed\": True}} for custom options.\n            **kwargs: Additional widget arguments.\n        \"\"\"\n        # Handle style shortcuts\n        if isinstance(style, str) and not style.startswith(\"http\"):\n            try:\n                style = get_maplibre_style(style)\n            except ValueError:\n                pass  # Use as-is\n\n        super().__init__(\n            center=list(center),\n            zoom=zoom,\n            width=width,\n            height=height,\n            style=style,\n            bearing=bearing,\n            pitch=pitch,\n            max_pitch=max_pitch,\n            projection=projection,\n            **kwargs,\n        )\n\n        # Initialize layer dictionary\n        self._layer_dict = {\"Background\": []}\n\n        # Add default controls\n        if controls is None:\n            controls = {\n                \"layer-control\": True,\n                \"control-grid\": True,\n            }\n\n        for control_name, config in controls.items():\n            if config:\n                if control_name == \"layer-control\":\n                    self.add_layer_control(\n                        **(config if isinstance(config, dict) else {})\n                    )\n                elif control_name == \"control-grid\":\n                    self.add_control_grid(\n                        **(config if isinstance(config, dict) else {})\n                    )\n                else:\n                    self.add_control(\n                        control_name, **(config if isinstance(config, dict) else {})\n                    )\n\n    # -------------------------------------------------------------------------\n    # Layer Dict Helper\n    # -------------------------------------------------------------------------\n\n    def _add_to_layer_dict(self, layer_id: str, category: str = \"Overlays\") -&gt; None:\n        \"\"\"Add a layer to the layer dictionary for UI tracking.\n\n        Args:\n            layer_id: The layer identifier.\n            category: The category to add the layer to (e.g., \"Overlays\", \"Raster\").\n        \"\"\"\n        layers = self._layer_dict.get(category, [])\n        if layer_id not in layers:\n            self._layer_dict = {\n                **self._layer_dict,\n                category: layers + [layer_id],\n            }\n\n    def _remove_from_layer_dict(self, layer_id: str) -&gt; None:\n        \"\"\"Remove a layer from the layer dictionary.\n\n        Args:\n            layer_id: The layer identifier to remove.\n        \"\"\"\n        new_dict = {}\n        for category, layers in self._layer_dict.items():\n            if layer_id in layers:\n                new_layers = [lid for lid in layers if lid != layer_id]\n                if new_layers:  # Only keep category if it still has layers\n                    new_dict[category] = new_layers\n            else:\n                new_dict[category] = layers\n        self._layer_dict = new_dict\n\n    # -------------------------------------------------------------------------\n    # Validation Helpers\n    # -------------------------------------------------------------------------\n\n    def _validate_opacity(self, opacity: float, param_name: str = \"opacity\") -&gt; float:\n        \"\"\"Validate opacity value is between 0 and 1.\n\n        Args:\n            opacity: The opacity value to validate.\n            param_name: Name of the parameter for error messages.\n\n        Returns:\n            The validated opacity value.\n\n        Raises:\n            ValueError: If opacity is not between 0 and 1.\n        \"\"\"\n        if not 0 &lt;= opacity &lt;= 1:\n            raise ValueError(f\"{param_name} must be between 0 and 1, got {opacity}\")\n        return opacity\n\n    def _validate_position(self, position: str) -&gt; str:\n        \"\"\"Validate control position is valid.\n\n        Args:\n            position: The position string to validate.\n\n        Returns:\n            The validated position string.\n\n        Raises:\n            ValueError: If position is not valid.\n        \"\"\"\n        valid_positions = [\"top-left\", \"top-right\", \"bottom-left\", \"bottom-right\"]\n        if position not in valid_positions:\n            raise ValueError(\n                f\"Position must be one of: {', '.join(valid_positions)}, got '{position}'\"\n            )\n        return position\n\n    def _remove_layer_internal(self, layer_id: str, js_method: str) -&gt; None:\n        \"\"\"Internal helper to remove a layer.\n\n        Args:\n            layer_id: The layer identifier to remove.\n            js_method: The JavaScript method to call for removal.\n        \"\"\"\n        if layer_id in self._layers:\n            layers = dict(self._layers)\n            del layers[layer_id]\n            self._layers = layers\n        self._remove_from_layer_dict(layer_id)\n        self.call_js_method(js_method, layer_id)\n\n    # -------------------------------------------------------------------------\n    # Basemap Methods\n    # -------------------------------------------------------------------------\n\n    def add_basemap(\n        self,\n        basemap: str = \"OpenStreetMap\",\n        attribution: Optional[str] = None,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a basemap layer.\n\n        Args:\n            basemap: Name of basemap provider (e.g., \"OpenStreetMap\", \"CartoDB.Positron\")\n            attribution: Custom attribution text\n            **kwargs: Additional options\n        \"\"\"\n        url, default_attribution = get_basemap_url(basemap)\n        self.call_js_method(\n            \"addBasemap\",\n            url,\n            attribution=attribution or default_attribution,\n            name=basemap,\n            **kwargs,\n        )\n\n        # Track in layer dict\n        basemaps = self._layer_dict.get(\"Basemaps\", [])\n        if basemap not in basemaps:\n            self._layer_dict = {\n                **self._layer_dict,\n                \"Basemaps\": basemaps + [basemap],\n            }\n\n    # -------------------------------------------------------------------------\n    # Vector Data Methods\n    # -------------------------------------------------------------------------\n\n    def add_vector(\n        self,\n        data: Any,\n        layer_type: Optional[str] = None,\n        paint: Optional[Dict] = None,\n        name: Optional[str] = None,\n        fit_bounds: bool = True,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add vector data to the map.\n\n        Supports GeoJSON, GeoDataFrame, or file paths to vector formats.\n\n        Args:\n            data: GeoJSON dict, GeoDataFrame, or path to vector file\n            layer_type: MapLibre layer type ('circle', 'line', 'fill', 'symbol')\n            paint: MapLibre paint properties\n            name: Layer name\n            fit_bounds: Whether to fit map to data bounds\n            **kwargs: Additional layer options\n        \"\"\"\n        geojson = to_geojson(data)\n\n        layer_id = name or f\"vector-{len(self._layers)}\"\n\n        # Handle URL data - fetch GeoJSON to get bounds and infer layer type\n        if geojson.get(\"type\") == \"url\":\n            url = geojson[\"url\"]\n            # Fetch the actual GeoJSON data from URL\n            geojson = fetch_geojson(url)\n\n        # Infer layer type if not specified\n        if layer_type is None:\n            layer_type = infer_layer_type(geojson)\n\n        # Get default paint if not provided\n        if paint is None:\n            paint = get_default_paint(layer_type)\n\n        # Get bounds (use geojson dict, not original data which may be a URL)\n        bounds = get_bounds(geojson) if fit_bounds else None\n\n        # Call JavaScript\n        self.call_js_method(\n            \"addGeoJSON\",\n            data=geojson,\n            name=layer_id,\n            layerType=layer_type,\n            paint=paint,\n            fitBounds=fit_bounds,\n            bounds=bounds,\n            **kwargs,\n        )\n\n        # Track layer\n        self._layers = {\n            **self._layers,\n            layer_id: {\n                \"id\": layer_id,\n                \"type\": layer_type,\n                \"source\": f\"{layer_id}-source\",\n                \"paint\": paint,\n            },\n        }\n        self._add_to_layer_dict(layer_id, \"Vector\")\n\n    def add_geojson(\n        self,\n        data: Union[str, Dict],\n        layer_type: Optional[str] = None,\n        paint: Optional[Dict] = None,\n        name: Optional[str] = None,\n        fit_bounds: bool = True,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add GeoJSON data to the map.\n\n        Args:\n            data: GeoJSON dict or URL to GeoJSON file\n            layer_type: MapLibre layer type\n            paint: MapLibre paint properties\n            name: Layer name\n            fit_bounds: Whether to fit map to data bounds\n            **kwargs: Additional layer options\n        \"\"\"\n        self.add_vector(\n            data,\n            layer_type=layer_type,\n            paint=paint,\n            name=name,\n            fit_bounds=fit_bounds,\n            **kwargs,\n        )\n\n    # -------------------------------------------------------------------------\n    # Marker Methods\n    # -------------------------------------------------------------------------\n\n    def add_marker(\n        self,\n        lng: float,\n        lat: float,\n        popup: Optional[str] = None,\n        tooltip: Optional[str] = None,\n        color: str = \"#3388ff\",\n        draggable: bool = False,\n        scale: float = 1.0,\n        popup_max_width: str = \"240px\",\n        tooltip_max_width: str = \"240px\",\n        name: Optional[str] = None,\n        **kwargs,\n    ) -&gt; str:\n        \"\"\"Add a single marker to the map.\n\n        Args:\n            lng: Longitude of the marker.\n            lat: Latitude of the marker.\n            popup: Optional popup HTML content (shown on click).\n            tooltip: Optional tooltip HTML content (shown on hover).\n            color: Marker color as hex string.\n            draggable: Whether the marker can be dragged.\n            scale: Marker size multiplier (default 1.0, range 0.1 to 3.0).\n            popup_max_width: Maximum width of popup (CSS value, default \"240px\").\n            tooltip_max_width: Maximum width of tooltip (CSS value, default \"240px\").\n            name: Marker identifier. If None, auto-generated.\n            **kwargs: Additional marker options.\n\n        Returns:\n            The marker identifier.\n\n        Example:\n            &gt;&gt;&gt; from anymap_ts import Map\n            &gt;&gt;&gt; m = Map(center=[-122.4, 37.8], zoom=10)\n            &gt;&gt;&gt; m.add_marker(-122.4, 37.8, popup=\"San Francisco\", tooltip=\"Hover me!\")\n            &gt;&gt;&gt; m.add_marker(-122.5, 37.7, scale=1.5, color=\"#ff0000\")\n        \"\"\"\n        marker_id = name or f\"marker-{len(self._layers)}\"\n\n        self.call_js_method(\n            \"addMarker\",\n            lng,\n            lat,\n            id=marker_id,\n            popup=popup,\n            tooltip=tooltip,\n            color=color,\n            draggable=draggable,\n            scale=scale,\n            popupMaxWidth=popup_max_width,\n            tooltipMaxWidth=tooltip_max_width,\n            **kwargs,\n        )\n\n        self._layers = {\n            **self._layers,\n            marker_id: {\n                \"id\": marker_id,\n                \"type\": \"marker\",\n                \"lngLat\": [lng, lat],\n            },\n        }\n        self._add_to_layer_dict(marker_id, \"Markers\")\n        return marker_id\n\n    def add_markers(\n        self,\n        data: Any,\n        lng_column: Optional[str] = None,\n        lat_column: Optional[str] = None,\n        popup_column: Optional[str] = None,\n        tooltip_column: Optional[str] = None,\n        color: str = \"#3388ff\",\n        scale: float = 1.0,\n        popup_max_width: str = \"240px\",\n        tooltip_max_width: str = \"240px\",\n        draggable: bool = False,\n        name: Optional[str] = None,\n        **kwargs,\n    ) -&gt; str:\n        \"\"\"Add multiple markers from data.\n\n        Args:\n            data: Data source - can be:\n                - List of dicts with 'lng'/'lon'/'longitude' and 'lat'/'latitude' keys\n                - GeoDataFrame with Point geometries\n                - GeoJSON FeatureCollection with Point features\n            lng_column: Column name for longitude (auto-detected if None).\n            lat_column: Column name for latitude (auto-detected if None).\n            popup_column: Column name for popup content (shown on click).\n            tooltip_column: Column name for tooltip content (shown on hover).\n            color: Marker color as hex string.\n            scale: Marker size multiplier (default 1.0, range 0.1 to 3.0).\n            popup_max_width: Maximum width of popup (CSS value, default \"240px\").\n            tooltip_max_width: Maximum width of tooltip (CSS value, default \"240px\").\n            draggable: Whether markers can be dragged.\n            name: Layer identifier. If None, auto-generated.\n            **kwargs: Additional marker options.\n\n        Returns:\n            The layer identifier.\n\n        Example:\n            &gt;&gt;&gt; from anymap_ts import Map\n            &gt;&gt;&gt; m = Map()\n            &gt;&gt;&gt; cities = [\n            ...     {\"name\": \"SF\", \"info\": \"San Francisco\", \"lng\": -122.4, \"lat\": 37.8},\n            ...     {\"name\": \"NYC\", \"info\": \"New York City\", \"lng\": -74.0, \"lat\": 40.7},\n            ... ]\n            &gt;&gt;&gt; m.add_markers(cities, popup_column=\"name\", tooltip_column=\"info\", scale=1.5)\n        \"\"\"\n        layer_id = name or f\"markers-{len(self._layers)}\"\n        markers = []\n\n        # Handle GeoDataFrame\n        if hasattr(data, \"geometry\"):\n            for _, row in data.iterrows():\n                geom = row.geometry\n                if geom.geom_type == \"Point\":\n                    marker = {\"lngLat\": [geom.x, geom.y]}\n                    if popup_column and popup_column in row:\n                        marker[\"popup\"] = str(row[popup_column])\n                    if tooltip_column and tooltip_column in row:\n                        marker[\"tooltip\"] = str(row[tooltip_column])\n                    markers.append(marker)\n        # Handle GeoJSON\n        elif isinstance(data, dict) and data.get(\"type\") == \"FeatureCollection\":\n            for feature in data.get(\"features\", []):\n                geom = feature.get(\"geometry\", {})\n                if geom.get(\"type\") == \"Point\":\n                    coords = geom.get(\"coordinates\", [])\n                    marker = {\"lngLat\": coords[:2]}\n                    props = feature.get(\"properties\", {})\n                    if popup_column and popup_column in props:\n                        marker[\"popup\"] = str(props[popup_column])\n                    if tooltip_column and tooltip_column in props:\n                        marker[\"tooltip\"] = str(props[tooltip_column])\n                    markers.append(marker)\n        # Handle list of dicts\n        elif isinstance(data, list):\n            lng_keys = [\"lng\", \"lon\", \"longitude\", \"x\"]\n            lat_keys = [\"lat\", \"latitude\", \"y\"]\n\n            for item in data:\n                if not isinstance(item, dict):\n                    continue\n\n                # Find lng/lat values\n                lng_val = None\n                lat_val = None\n\n                if lng_column and lng_column in item:\n                    lng_val = item[lng_column]\n                else:\n                    for key in lng_keys:\n                        if key in item:\n                            lng_val = item[key]\n                            break\n\n                if lat_column and lat_column in item:\n                    lat_val = item[lat_column]\n                else:\n                    for key in lat_keys:\n                        if key in item:\n                            lat_val = item[key]\n                            break\n\n                if lng_val is not None and lat_val is not None:\n                    marker = {\"lngLat\": [float(lng_val), float(lat_val)]}\n                    if popup_column and popup_column in item:\n                        marker[\"popup\"] = str(item[popup_column])\n                    if tooltip_column and tooltip_column in item:\n                        marker[\"tooltip\"] = str(item[tooltip_column])\n                    markers.append(marker)\n\n        if not markers:\n            raise ValueError(\"No valid point data found in input\")\n\n        self.call_js_method(\n            \"addMarkers\",\n            id=layer_id,\n            markers=markers,\n            color=color,\n            scale=scale,\n            popupMaxWidth=popup_max_width,\n            tooltipMaxWidth=tooltip_max_width,\n            draggable=draggable,\n            **kwargs,\n        )\n\n        self._layers = {\n            **self._layers,\n            layer_id: {\n                \"id\": layer_id,\n                \"type\": \"markers\",\n                \"count\": len(markers),\n            },\n        }\n        self._add_to_layer_dict(layer_id, \"Markers\")\n        return layer_id\n\n    def remove_marker(self, marker_id: str) -&gt; None:\n        \"\"\"Remove a marker from the map.\n\n        Args:\n            marker_id: Marker identifier to remove.\n        \"\"\"\n        self._remove_layer_internal(marker_id, \"removeMarker\")\n\n    # -------------------------------------------------------------------------\n    # Heatmap Methods\n    # -------------------------------------------------------------------------\n\n    def add_heatmap(\n        self,\n        data: Any,\n        weight_property: Optional[str] = None,\n        radius: int = 20,\n        intensity: float = 1.0,\n        colormap: Optional[List] = None,\n        opacity: float = 0.8,\n        name: Optional[str] = None,\n        fit_bounds: bool = True,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a heatmap layer to the map.\n\n        Creates a heatmap visualization from point data using MapLibre's\n        native heatmap layer type.\n\n        Args:\n            data: Point data - can be GeoJSON, GeoDataFrame, or file path.\n            weight_property: Property name to use for point weights.\n                If None, all points have equal weight.\n            radius: Radius of influence for each point in pixels.\n            intensity: Intensity multiplier for the heatmap.\n            colormap: Color gradient as list of [stop, color] pairs.\n                Example: [[0, \"blue\"], [0.5, \"yellow\"], [1, \"red\"]]\n                Default: blue-yellow-red gradient.\n            opacity: Layer opacity (0-1).\n            name: Layer identifier. If None, auto-generated.\n            fit_bounds: Whether to fit map to data bounds.\n            **kwargs: Additional heatmap layer options.\n\n        Example:\n            &gt;&gt;&gt; from anymap_ts import Map\n            &gt;&gt;&gt; m = Map()\n            &gt;&gt;&gt; m.add_heatmap(\n            ...     \"earthquakes.geojson\",\n            ...     weight_property=\"magnitude\",\n            ...     radius=30,\n            ...     colormap=[[0, \"blue\"], [0.5, \"lime\"], [1, \"red\"]]\n            ... )\n        \"\"\"\n        self._validate_opacity(opacity)\n        layer_id = name or f\"heatmap-{len(self._layers)}\"\n\n        # Convert data to GeoJSON\n        geojson = to_geojson(data)\n\n        # Handle URL data - fetch GeoJSON\n        if geojson.get(\"type\") == \"url\":\n            url = geojson[\"url\"]\n            geojson = fetch_geojson(url)\n\n        # Default colormap\n        if colormap is None:\n            colormap = [\n                [0, \"rgba(33,102,172,0)\"],\n                [0.2, \"rgb(103,169,207)\"],\n                [0.4, \"rgb(209,229,240)\"],\n                [0.6, \"rgb(253,219,199)\"],\n                [0.8, \"rgb(239,138,98)\"],\n                [1, \"rgb(178,24,43)\"],\n            ]\n\n        # Build heatmap paint properties\n        paint = {\n            \"heatmap-radius\": radius,\n            \"heatmap-intensity\": intensity,\n            \"heatmap-opacity\": opacity,\n            \"heatmap-color\": [\n                \"interpolate\",\n                [\"linear\"],\n                [\"heatmap-density\"],\n            ],\n        }\n\n        # Add colormap stops\n        for stop, color in colormap:\n            paint[\"heatmap-color\"].extend([stop, color])\n\n        # Add weight if specified\n        if weight_property:\n            paint[\"heatmap-weight\"] = [\"get\", weight_property]\n\n        # Get bounds\n        bounds = get_bounds(geojson) if fit_bounds else None\n\n        self.call_js_method(\n            \"addGeoJSON\",\n            data=geojson,\n            name=layer_id,\n            layerType=\"heatmap\",\n            paint=paint,\n            fitBounds=fit_bounds,\n            bounds=bounds,\n            **kwargs,\n        )\n\n        self._layers = {\n            **self._layers,\n            layer_id: {\n                \"id\": layer_id,\n                \"type\": \"heatmap\",\n                \"source\": f\"{layer_id}-source\",\n                \"paint\": paint,\n            },\n        }\n        self._add_to_layer_dict(layer_id, \"Heatmap\")\n\n    # -------------------------------------------------------------------------\n    # Raster Data Methods\n    # -------------------------------------------------------------------------\n\n    def add_raster(\n        self,\n        source: str,\n        name: Optional[str] = None,\n        attribution: str = \"\",\n        indexes: Optional[List[int]] = None,\n        colormap: Optional[str] = None,\n        vmin: Optional[float] = None,\n        vmax: Optional[float] = None,\n        nodata: Optional[float] = None,\n        fit_bounds: bool = True,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a raster layer from a local file using localtileserver.\n\n        Args:\n            source: Path to local raster file\n            name: Layer name\n            attribution: Attribution text\n            indexes: Band indexes to use\n            colormap: Colormap name\n            vmin: Minimum value for colormap\n            vmax: Maximum value for colormap\n            nodata: NoData value\n            fit_bounds: Whether to fit map to raster bounds\n            **kwargs: Additional options\n        \"\"\"\n        try:\n            from localtileserver import TileClient\n        except ImportError:\n            raise ImportError(\n                \"localtileserver is required for local raster support. \"\n                \"Install with: pip install anymap-ts[raster]\"\n            )\n\n        client = TileClient(source)\n\n        # Build parameters dict and pass all at once\n        tile_params = {}\n        if indexes:\n            tile_params[\"indexes\"] = indexes\n        if colormap:\n            tile_params[\"colormap\"] = colormap\n        if vmin is not None or vmax is not None:\n            tile_params[\"vmin\"] = vmin if vmin is not None else client.min\n            tile_params[\"vmax\"] = vmax if vmax is not None else client.max\n        if nodata is not None:\n            tile_params[\"nodata\"] = nodata\n\n        tile_url = client.get_tile_url(**tile_params)\n\n        layer_name = name or Path(source).stem\n\n        self.add_tile_layer(\n            tile_url,\n            name=layer_name,\n            attribution=attribution,\n            **kwargs,\n        )\n\n        # Fit bounds if requested\n        if fit_bounds:\n            bounds = client.bounds()\n            if bounds:\n                self.fit_bounds([bounds[0], bounds[1], bounds[2], bounds[3]])\n\n    def add_tile_layer(\n        self,\n        url: str,\n        name: Optional[str] = None,\n        attribution: str = \"\",\n        min_zoom: int = 0,\n        max_zoom: int = 22,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add an XYZ tile layer.\n\n        Args:\n            url: Tile URL template with {x}, {y}, {z} placeholders\n            name: Layer name\n            attribution: Attribution text\n            min_zoom: Minimum zoom level\n            max_zoom: Maximum zoom level\n            **kwargs: Additional options\n        \"\"\"\n        layer_id = name or f\"tiles-{len(self._layers)}\"\n\n        self.call_js_method(\n            \"addTileLayer\",\n            url,\n            name=layer_id,\n            attribution=attribution,\n            minZoom=min_zoom,\n            maxZoom=max_zoom,\n            **kwargs,\n        )\n\n        # Track layer\n        self._layers = {\n            **self._layers,\n            layer_id: {\n                \"id\": layer_id,\n                \"type\": \"raster\",\n                \"source\": f\"{layer_id}-source\",\n            },\n        }\n        self._add_to_layer_dict(layer_id, \"Raster\")\n\n    def add_stac_layer(\n        self,\n        url: Optional[str] = None,\n        item: Optional[Any] = None,\n        assets: Optional[List[str]] = None,\n        colormap: Optional[str] = None,\n        rescale: Optional[List[float]] = None,\n        opacity: float = 1.0,\n        layer_id: Optional[str] = None,\n        titiler_endpoint: str = \"https://titiler.xyz\",\n        attribution: str = \"STAC\",\n        fit_bounds: bool = True,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a STAC (SpatioTemporal Asset Catalog) layer to the map.\n\n        Uses TiTiler to render STAC items as XYZ tiles on the map.\n        Supports both STAC item URLs and pystac Item objects.\n\n        Args:\n            url: URL to a STAC item JSON\n            item: A pystac Item object\n            assets: List of asset names/bands to visualize\n            colormap: Colormap name (e.g., 'viridis', 'plasma', 'inferno')\n            rescale: Min/max values for rescaling as [min, max]\n            opacity: Layer opacity (0-1)\n            layer_id: Custom layer identifier\n            titiler_endpoint: TiTiler server endpoint URL\n            attribution: Attribution text for the layer\n            fit_bounds: Whether to fit map to STAC item bounds\n            **kwargs: Additional tile layer options\n\n        Example:\n            &gt;&gt;&gt; from anymap_ts import Map\n            &gt;&gt;&gt; m = Map()\n            &gt;&gt;&gt; # From URL\n            &gt;&gt;&gt; m.add_stac_layer(\n            ...     url=\"https://planetarycomputer.microsoft.com/api/stac/v1/collections/sentinel-2-l2a/items/S2A_MSIL2A_20220101T181901_N0301_R027_T10TEM_20220101T201906\",\n            ...     assets=[\"red\", \"green\", \"blue\"],\n            ...     rescale=[0, 3000]\n            ... )\n            &gt;&gt;&gt; # From pystac Item\n            &gt;&gt;&gt; import pystac\n            &gt;&gt;&gt; item = pystac.Item.from_file(\"path/to/item.json\")\n            &gt;&gt;&gt; m.add_stac_layer(item=item, assets=[\"nir\", \"red\"], colormap=\"ndvi\")\n        \"\"\"\n        if url is None and item is None:\n            raise ValueError(\"Either 'url' or 'item' must be provided\")\n\n        if url is not None and item is not None:\n            raise ValueError(\"Provide either 'url' or 'item', not both\")\n\n        # Handle pystac Item object\n        if item is not None:\n            try:\n                # Check if it's a pystac Item\n                if hasattr(item, \"to_dict\") and hasattr(item, \"self_href\"):\n                    stac_url = item.self_href\n                    if not stac_url:\n                        # Try to get URL from item properties if no self_href\n                        if hasattr(item, \"links\"):\n                            for link in item.links:\n                                if link.rel == \"self\":\n                                    stac_url = link.href\n                                    break\n                        if not stac_url:\n                            raise ValueError(\n                                \"STAC item must have a self_href or self link for tile generation\"\n                            )\n                else:\n                    raise ValueError(\n                        \"Item must be a pystac Item object with to_dict() and self_href attributes\"\n                    )\n            except Exception as e:\n                raise ValueError(f\"Invalid STAC item: {e}\")\n        else:\n            stac_url = url\n\n        # Build TiTiler tile URL\n        tile_params = {\"url\": stac_url}\n\n        if assets:\n            tile_params[\"assets\"] = \",\".join(assets)\n        if colormap:\n            tile_params[\"colormap_name\"] = colormap\n        if rescale:\n            if len(rescale) == 2:\n                tile_params[\"rescale\"] = f\"{rescale[0]},{rescale[1]}\"\n            else:\n                raise ValueError(\"rescale must be a list of two values [min, max]\")\n\n        # Construct tile URL template\n        query_string = urlencode(tile_params)\n        tile_url = f\"{titiler_endpoint.rstrip('/')}/stac/tiles/{{z}}/{{x}}/{{y}}?{query_string}\"\n\n        layer_name = layer_id or f\"stac-{len(self._layers)}\"\n\n        # Add as tile layer\n        self.add_tile_layer(\n            url=tile_url,\n            name=layer_name,\n            attribution=attribution,\n            **kwargs,\n        )\n\n        # Update layer info to mark as STAC\n        if layer_name in self._layers:\n            self._layers[layer_name].update(\n                {\n                    \"stac_url\": stac_url,\n                    \"stac_assets\": assets,\n                    \"colormap\": colormap,\n                    \"rescale\": rescale,\n                }\n            )\n\n        # Try to fit bounds if requested and we have an item object\n        if fit_bounds and item is not None:\n            try:\n                bbox = item.bbox\n                if bbox and len(bbox) == 4:\n                    self.fit_bounds([[bbox[0], bbox[1]], [bbox[2], bbox[3]]])\n            except Exception:\n                pass  # Skip bounds fitting if bbox is not available\n\n    # -------------------------------------------------------------------------\n    # COG Layer (deck.gl)\n    # -------------------------------------------------------------------------\n\n    def add_cog_layer(\n        self,\n        url: str,\n        name: Optional[str] = None,\n        opacity: float = 1.0,\n        visible: bool = True,\n        debug: bool = False,\n        debug_opacity: float = 0.25,\n        max_error: float = 0.125,\n        fit_bounds: bool = True,\n        before_id: Optional[str] = None,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a Cloud Optimized GeoTIFF (COG) layer using @developmentseed/deck.gl-geotiff.\n\n        This method renders COG files directly in the browser using GPU-accelerated\n        deck.gl-geotiff rendering with automatic reprojection support.\n\n        Args:\n            url: URL to the Cloud Optimized GeoTIFF file.\n            name: Layer ID. If None, auto-generated.\n            opacity: Layer opacity (0-1).\n            visible: Whether layer is visible.\n            debug: Show reprojection mesh for debugging.\n            debug_opacity: Opacity of debug mesh (0-1).\n            max_error: Maximum reprojection error in pixels. Lower values\n                create denser mesh for better accuracy.\n            fit_bounds: Whether to fit map to COG bounds after loading.\n            before_id: ID of layer to insert before.\n            **kwargs: Additional COGLayer props.\n\n        Example:\n            &gt;&gt;&gt; from anymap_ts import Map\n            &gt;&gt;&gt; m = Map()\n            &gt;&gt;&gt; m.add_cog_layer(\n            ...     \"https://example.com/landcover.tif\",\n            ...     name=\"landcover\",\n            ...     opacity=0.8\n            ... )\n        \"\"\"\n        layer_id = name or f\"cog-{len(self._layers)}\"\n\n        self.call_js_method(\n            \"addCOGLayer\",\n            id=layer_id,\n            geotiff=url,\n            opacity=opacity,\n            visible=visible,\n            debug=debug,\n            debugOpacity=debug_opacity,\n            maxError=max_error,\n            fitBounds=fit_bounds,\n            beforeId=before_id,\n            **kwargs,\n        )\n\n        self._layers = {\n            **self._layers,\n            layer_id: {\n                \"id\": layer_id,\n                \"type\": \"cog\",\n                \"url\": url,\n            },\n        }\n        self._add_to_layer_dict(layer_id, \"Raster\")\n\n    def remove_cog_layer(self, layer_id: str) -&gt; None:\n        \"\"\"Remove a COG layer.\n\n        Args:\n            layer_id: Layer identifier to remove.\n        \"\"\"\n        self._remove_layer_internal(layer_id, \"removeCOGLayer\")\n\n    # -------------------------------------------------------------------------\n    # Zarr Layer (@carbonplan/zarr-layer)\n    # -------------------------------------------------------------------------\n\n    def add_zarr_layer(\n        self,\n        url: str,\n        variable: str,\n        name: Optional[str] = None,\n        colormap: Optional[List[str]] = None,\n        clim: Optional[Tuple[float, float]] = None,\n        opacity: float = 1.0,\n        selector: Optional[Dict[str, Any]] = None,\n        minzoom: int = 0,\n        maxzoom: int = 22,\n        fill_value: Optional[float] = None,\n        spatial_dimensions: Optional[Dict[str, str]] = None,\n        zarr_version: Optional[int] = None,\n        bounds: Optional[List[float]] = None,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a Zarr dataset layer for visualizing multidimensional array data.\n\n        This method renders Zarr pyramid datasets directly in the browser using\n        GPU-accelerated WebGL rendering via @carbonplan/zarr-layer.\n\n        Args:\n            url: URL to the Zarr store (pyramid format recommended).\n            variable: Variable name in the Zarr dataset to visualize.\n            name: Layer ID. If None, auto-generated.\n            colormap: List of hex color strings for visualization.\n                Example: ['#0000ff', '#ffff00', '#ff0000'] (blue-yellow-red).\n                Default: ['#000000', '#ffffff'] (black to white).\n            clim: Color range as (min, max) tuple.\n                Default: (0, 100).\n            opacity: Layer opacity (0-1).\n            selector: Dimension selector for multi-dimensional data.\n                Example: {\"month\": 4} to select 4th month.\n            minzoom: Minimum zoom level for rendering.\n            maxzoom: Maximum zoom level for rendering.\n            fill_value: No-data value (auto-detected from metadata if not set).\n            spatial_dimensions: Custom spatial dimension names.\n                Example: {\"lat\": \"y\", \"lon\": \"x\"} for non-standard names.\n            zarr_version: Zarr format version (2 or 3). Auto-detected if not set.\n            bounds: Explicit spatial bounds [xMin, yMin, xMax, yMax].\n                Units depend on CRS: degrees for EPSG:4326, meters for EPSG:3857.\n            **kwargs: Additional ZarrLayer props.\n\n        Example:\n            &gt;&gt;&gt; from anymap_ts import Map\n            &gt;&gt;&gt; m = Map()\n            &gt;&gt;&gt; m.add_zarr_layer(\n            ...     \"https://example.com/climate.zarr\",\n            ...     variable=\"temperature\",\n            ...     clim=(270, 310),\n            ...     colormap=['#0000ff', '#ffff00', '#ff0000'],\n            ...     selector={\"month\": 7}\n            ... )\n        \"\"\"\n        layer_id = name or f\"zarr-{len(self._layers)}\"\n\n        self.call_js_method(\n            \"addZarrLayer\",\n            id=layer_id,\n            source=url,\n            variable=variable,\n            colormap=colormap or [\"#000000\", \"#ffffff\"],\n            clim=list(clim) if clim else [0, 100],\n            opacity=opacity,\n            selector=selector or {},\n            minzoom=minzoom,\n            maxzoom=maxzoom,\n            fillValue=fill_value,\n            spatialDimensions=spatial_dimensions,\n            zarrVersion=zarr_version,\n            bounds=bounds,\n            **kwargs,\n        )\n\n        self._layers = {\n            **self._layers,\n            layer_id: {\n                \"id\": layer_id,\n                \"type\": \"zarr\",\n                \"url\": url,\n                \"variable\": variable,\n            },\n        }\n        self._add_to_layer_dict(layer_id, \"Raster\")\n\n    def remove_zarr_layer(self, layer_id: str) -&gt; None:\n        \"\"\"Remove a Zarr layer.\n\n        Args:\n            layer_id: Layer identifier to remove.\n        \"\"\"\n        self._remove_layer_internal(layer_id, \"removeZarrLayer\")\n\n    def update_zarr_layer(\n        self,\n        layer_id: str,\n        selector: Optional[Dict[str, Any]] = None,\n        clim: Optional[Tuple[float, float]] = None,\n        colormap: Optional[List[str]] = None,\n        opacity: Optional[float] = None,\n    ) -&gt; None:\n        \"\"\"Update a Zarr layer's properties dynamically.\n\n        Args:\n            layer_id: Layer identifier.\n            selector: New dimension selector.\n            clim: New color range.\n            colormap: New colormap.\n            opacity: New opacity value (0-1).\n        \"\"\"\n        update_kwargs: Dict[str, Any] = {\"id\": layer_id}\n        if selector is not None:\n            update_kwargs[\"selector\"] = selector\n        if clim is not None:\n            update_kwargs[\"clim\"] = list(clim)\n        if colormap is not None:\n            update_kwargs[\"colormap\"] = colormap\n        if opacity is not None:\n            update_kwargs[\"opacity\"] = opacity\n        self.call_js_method(\"updateZarrLayer\", **update_kwargs)\n\n    # -------------------------------------------------------------------------\n    # PMTiles Layer\n    # -------------------------------------------------------------------------\n\n    def add_pmtiles_layer(\n        self,\n        url: str,\n        layer_id: Optional[str] = None,\n        style: Optional[Dict[str, Any]] = None,\n        opacity: float = 1.0,\n        visible: bool = True,\n        fit_bounds: bool = False,\n        source_type: str = \"vector\",\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a PMTiles layer for efficient vector or raster tile serving.\n\n        PMTiles is a single-file archive format for pyramids of map tiles.\n        It enables efficient web-native map serving without requiring a\n        separate tile server infrastructure.\n\n        Args:\n            url: URL to the PMTiles file (e.g., \"https://example.com/data.pmtiles\").\n            layer_id: Layer identifier. If None, auto-generated.\n            style: Layer style configuration for vector tiles.\n                For vector PMTiles, can include:\n                - type: Layer type ('fill', 'line', 'circle', 'symbol')\n                - source-layer: Source layer name from vector tiles\n                - paint properties (e.g., 'fill-color', 'line-width')\n                - layout properties (e.g., 'visibility')\n                Example: {\"type\": \"line\", \"source-layer\": \"roads\", \"line-color\": \"#ff0000\"}\n            opacity: Layer opacity (0-1).\n            visible: Whether layer is initially visible.\n            fit_bounds: Whether to fit map to layer bounds after loading.\n            source_type: Source type - \"vector\" for vector PMTiles, \"raster\" for raster PMTiles.\n            **kwargs: Additional layer options.\n\n        Example:\n            &gt;&gt;&gt; from anymap_ts import Map\n            &gt;&gt;&gt; m = Map()\n            &gt;&gt;&gt; # Add vector PMTiles\n            &gt;&gt;&gt; m.add_pmtiles_layer(\n            ...     url=\"https://example.com/countries.pmtiles\",\n            ...     layer_id=\"countries\",\n            ...     style={\n            ...         \"type\": \"fill\",\n            ...         \"source-layer\": \"countries\",\n            ...         \"fill-color\": \"#3388ff\",\n            ...         \"fill-opacity\": 0.6\n            ...     }\n            ... )\n            &gt;&gt;&gt; # Add raster PMTiles\n            &gt;&gt;&gt; m.add_pmtiles_layer(\n            ...     url=\"https://example.com/satellite.pmtiles\",\n            ...     layer_id=\"satellite\",\n            ...     source_type=\"raster\",\n            ...     opacity=0.8\n            ... )\n        \"\"\"\n        layer_id = layer_id or f\"pmtiles-{len(self._layers)}\"\n\n        self.call_js_method(\n            \"addPMTilesLayer\",\n            url=url,\n            id=layer_id,\n            style=style or {},\n            opacity=opacity,\n            visible=visible,\n            fitBounds=fit_bounds,\n            sourceType=source_type,\n            name=layer_id,\n            **kwargs,\n        )\n\n        self._layers = {\n            **self._layers,\n            layer_id: {\n                \"id\": layer_id,\n                \"type\": \"pmtiles\",\n                \"url\": url,\n                \"source_type\": source_type,\n            },\n        }\n        category = \"Vector\" if source_type == \"vector\" else \"Raster\"\n        self._add_to_layer_dict(layer_id, category)\n\n    def remove_pmtiles_layer(self, layer_id: str) -&gt; None:\n        \"\"\"Remove a PMTiles layer.\n\n        Args:\n            layer_id: Layer identifier to remove.\n        \"\"\"\n        self._remove_layer_internal(layer_id, \"removePMTilesLayer\")\n\n    # -------------------------------------------------------------------------\n    # Arc Layer (deck.gl)\n    # -------------------------------------------------------------------------\n\n    def add_arc_layer(\n        self,\n        data: Any,\n        name: Optional[str] = None,\n        get_source_position: Union[str, Any] = \"source\",\n        get_target_position: Union[str, Any] = \"target\",\n        get_source_color: Optional[List[int]] = None,\n        get_target_color: Optional[List[int]] = None,\n        get_width: Union[float, str] = 1,\n        get_height: float = 1,\n        great_circle: bool = False,\n        pickable: bool = True,\n        opacity: float = 0.8,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add an arc layer for origin-destination visualization using deck.gl.\n\n        Arc layers are ideal for visualizing connections between locations,\n        such as flight routes, migration patterns, or network flows.\n\n        Args:\n            data: Array of data objects with source/target coordinates.\n                Each object should have source and target positions.\n            name: Layer ID. If None, auto-generated.\n            get_source_position: Accessor for source position [lng, lat].\n                Can be a string (property name) or a value.\n            get_target_position: Accessor for target position [lng, lat].\n                Can be a string (property name) or a value.\n            get_source_color: Source end color as [r, g, b, a].\n                Default: [51, 136, 255, 255] (blue).\n            get_target_color: Target end color as [r, g, b, a].\n                Default: [255, 136, 51, 255] (orange).\n            get_width: Arc width in pixels. Can be a number or accessor.\n            get_height: Arc height multiplier. Higher values create more curved arcs.\n            great_circle: Whether to draw arcs along great circles.\n            pickable: Whether layer responds to hover/click events.\n            opacity: Layer opacity (0-1).\n            **kwargs: Additional ArcLayer props.\n\n        Example:\n            &gt;&gt;&gt; from anymap_ts import MapLibreMap\n            &gt;&gt;&gt; m = MapLibreMap()\n            &gt;&gt;&gt; arcs = [\n            ...     {\"source\": [-122.4, 37.8], \"target\": [-73.9, 40.7]},\n            ...     {\"source\": [-122.4, 37.8], \"target\": [-0.1, 51.5]},\n            ... ]\n            &gt;&gt;&gt; m.add_arc_layer(arcs, name=\"flights\")\n        \"\"\"\n        layer_id = name or f\"arc-{len(self._layers)}\"\n        processed_data = self._process_deck_data(data)\n\n        self.call_js_method(\n            \"addArcLayer\",\n            id=layer_id,\n            data=processed_data,\n            getSourcePosition=get_source_position,\n            getTargetPosition=get_target_position,\n            getSourceColor=get_source_color or [51, 136, 255, 255],\n            getTargetColor=get_target_color or [255, 136, 51, 255],\n            getWidth=get_width,\n            getHeight=get_height,\n            greatCircle=great_circle,\n            pickable=pickable,\n            opacity=opacity,\n            **kwargs,\n        )\n\n        self._layers = {\n            **self._layers,\n            layer_id: {\n                \"id\": layer_id,\n                \"type\": \"arc\",\n            },\n        }\n        self._add_to_layer_dict(layer_id, \"Deck.gl\")\n\n    def remove_arc_layer(self, layer_id: str) -&gt; None:\n        \"\"\"Remove an arc layer.\n\n        Args:\n            layer_id: Layer identifier to remove.\n        \"\"\"\n        self._remove_layer_internal(layer_id, \"removeArcLayer\")\n\n    # -------------------------------------------------------------------------\n    # PointCloud Layer (deck.gl)\n    # -------------------------------------------------------------------------\n\n    def add_point_cloud_layer(\n        self,\n        data: Any,\n        name: Optional[str] = None,\n        get_position: Union[str, Any] = \"position\",\n        get_color: Optional[Union[List[int], str]] = None,\n        get_normal: Optional[Union[str, Any]] = None,\n        point_size: float = 2,\n        size_units: str = \"pixels\",\n        pickable: bool = True,\n        opacity: float = 1.0,\n        material: bool = True,\n        coordinate_system: Optional[int] = None,\n        coordinate_origin: Optional[List[float]] = None,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a point cloud layer for 3D point visualization using deck.gl.\n\n        Point cloud layers render large collections of 3D points, ideal for\n        LiDAR data, photogrammetry outputs, or any 3D point dataset.\n\n        Args:\n            data: Array of point data with positions. Each point should have\n                x, y, z coordinates (or position array).\n            name: Layer ID. If None, auto-generated.\n            get_position: Accessor for point position [x, y, z].\n                Can be a string (property name) or a value.\n            get_color: Accessor or value for point color [r, g, b, a].\n                Default: [255, 255, 255, 255] (white).\n            get_normal: Accessor for point normal [nx, ny, nz] for lighting.\n                Default: [0, 0, 1] (pointing up).\n            point_size: Point size in pixels or meters (depends on size_units).\n            size_units: Size units: 'pixels', 'meters', or 'common'.\n            pickable: Whether layer responds to hover/click events.\n            opacity: Layer opacity (0-1).\n            material: Whether to enable lighting effects.\n            coordinate_system: Coordinate system for positions.\n            coordinate_origin: Origin for coordinate system [x, y, z].\n            **kwargs: Additional PointCloudLayer props.\n\n        Example:\n            &gt;&gt;&gt; from anymap_ts import MapLibreMap\n            &gt;&gt;&gt; import numpy as np\n            &gt;&gt;&gt; m = MapLibreMap(pitch=45)\n            &gt;&gt;&gt; points = [\n            ...     {\"position\": [-122.4, 37.8, 100], \"color\": [255, 0, 0, 255]},\n            ...     {\"position\": [-122.3, 37.7, 200], \"color\": [0, 255, 0, 255]},\n            ... ]\n            &gt;&gt;&gt; m.add_point_cloud_layer(points, point_size=5)\n        \"\"\"\n        layer_id = name or f\"pointcloud-{len(self._layers)}\"\n        processed_data = self._process_deck_data(data)\n\n        self.call_js_method(\n            \"addPointCloudLayer\",\n            id=layer_id,\n            data=processed_data,\n            getPosition=get_position,\n            getColor=get_color or [255, 255, 255, 255],\n            getNormal=get_normal,\n            pointSize=point_size,\n            sizeUnits=size_units,\n            pickable=pickable,\n            opacity=opacity,\n            material=material,\n            coordinateSystem=coordinate_system,\n            coordinateOrigin=coordinate_origin,\n            **kwargs,\n        )\n\n        self._layers = {\n            **self._layers,\n            layer_id: {\n                \"id\": layer_id,\n                \"type\": \"pointcloud\",\n            },\n        }\n        self._add_to_layer_dict(layer_id, \"Deck.gl\")\n\n    def remove_point_cloud_layer(self, layer_id: str) -&gt; None:\n        \"\"\"Remove a point cloud layer.\n\n        Args:\n            layer_id: Layer identifier to remove.\n        \"\"\"\n        self._remove_layer_internal(layer_id, \"removePointCloudLayer\")\n\n    # -------------------------------------------------------------------------\n    # Scatterplot Layer (deck.gl)\n    # -------------------------------------------------------------------------\n\n    def add_scatterplot_layer(\n        self,\n        data: Any,\n        name: Optional[str] = None,\n        get_position: Union[str, Any] = \"coordinates\",\n        get_radius: Union[float, str] = 5,\n        get_fill_color: Optional[Union[List[int], str]] = None,\n        get_line_color: Optional[Union[List[int], str]] = None,\n        radius_scale: float = 1,\n        radius_min_pixels: float = 1,\n        radius_max_pixels: float = 100,\n        line_width_min_pixels: float = 1,\n        stroked: bool = True,\n        filled: bool = True,\n        pickable: bool = True,\n        opacity: float = 0.8,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a scatterplot layer for sized/colored point visualization using deck.gl.\n\n        Scatterplot layers render circles at given coordinates with configurable\n        radius and color, ideal for point datasets where size and color encode data.\n\n        Args:\n            data: Array of data objects or GeoJSON with point coordinates.\n            name: Layer ID. If None, auto-generated.\n            get_position: Accessor for point position [lng, lat].\n                Can be a string (property name) or a value.\n            get_radius: Accessor for point radius in meters.\n            get_fill_color: Accessor for fill color [r, g, b, a].\n                Default: [51, 136, 255, 200] (blue).\n            get_line_color: Accessor for stroke color [r, g, b, a].\n                Default: [255, 255, 255, 255] (white).\n            radius_scale: Global radius multiplier.\n            radius_min_pixels: Minimum radius in pixels.\n            radius_max_pixels: Maximum radius in pixels.\n            line_width_min_pixels: Minimum stroke width in pixels.\n            stroked: Whether to draw stroke around points.\n            filled: Whether to fill points.\n            pickable: Whether layer responds to hover/click events.\n            opacity: Layer opacity (0-1).\n            **kwargs: Additional ScatterplotLayer props.\n\n        Example:\n            &gt;&gt;&gt; from anymap_ts import MapLibreMap\n            &gt;&gt;&gt; m = MapLibreMap()\n            &gt;&gt;&gt; points = [\n            ...     {\"coordinates\": [-122.4, 37.8], \"size\": 100},\n            ...     {\"coordinates\": [-122.5, 37.7], \"size\": 200},\n            ... ]\n            &gt;&gt;&gt; m.add_scatterplot_layer(points, get_radius=\"size\")\n        \"\"\"\n        layer_id = name or f\"scatterplot-{len(self._layers)}\"\n        processed_data = self._process_deck_data(data)\n\n        self.call_js_method(\n            \"addScatterplotLayer\",\n            id=layer_id,\n            data=processed_data,\n            getPosition=get_position,\n            getRadius=get_radius,\n            getFillColor=get_fill_color or [51, 136, 255, 200],\n            getLineColor=get_line_color or [255, 255, 255, 255],\n            radiusScale=radius_scale,\n            radiusMinPixels=radius_min_pixels,\n            radiusMaxPixels=radius_max_pixels,\n            lineWidthMinPixels=line_width_min_pixels,\n            stroked=stroked,\n            filled=filled,\n            pickable=pickable,\n            opacity=opacity,\n            **kwargs,\n        )\n\n        self._layers = {\n            **self._layers,\n            layer_id: {\n                \"id\": layer_id,\n                \"type\": \"scatterplot\",\n            },\n        }\n        self._add_to_layer_dict(layer_id, \"Deck.gl\")\n\n    # -------------------------------------------------------------------------\n    # Path Layer (deck.gl)\n    # -------------------------------------------------------------------------\n\n    def add_path_layer(\n        self,\n        data: Any,\n        name: Optional[str] = None,\n        get_path: Union[str, Any] = \"path\",\n        get_color: Optional[Union[List[int], str]] = None,\n        get_width: Union[float, str] = 1,\n        width_scale: float = 1,\n        width_min_pixels: float = 1,\n        pickable: bool = True,\n        opacity: float = 0.8,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a path layer for route/trajectory rendering using deck.gl.\n\n        Path layers render polylines defined by arrays of coordinates,\n        ideal for visualizing routes, trajectories, or any line-based data.\n\n        Args:\n            data: Array of data objects with path coordinates.\n            name: Layer ID. If None, auto-generated.\n            get_path: Accessor for path coordinates [[lng, lat], ...].\n                Can be a string (property name) or a value.\n            get_color: Accessor for path color [r, g, b, a].\n                Default: [51, 136, 255, 200] (blue).\n            get_width: Accessor for path width in meters.\n            width_scale: Global width multiplier.\n            width_min_pixels: Minimum width in pixels.\n            pickable: Whether layer responds to hover/click events.\n            opacity: Layer opacity (0-1).\n            **kwargs: Additional PathLayer props.\n\n        Example:\n            &gt;&gt;&gt; from anymap_ts import MapLibreMap\n            &gt;&gt;&gt; m = MapLibreMap()\n            &gt;&gt;&gt; routes = [\n            ...     {\"path\": [[-122.4, 37.8], [-122.5, 37.7], [-122.6, 37.8]]},\n            ... ]\n            &gt;&gt;&gt; m.add_path_layer(routes, get_color=[255, 0, 0], get_width=3)\n        \"\"\"\n        layer_id = name or f\"path-{len(self._layers)}\"\n        processed_data = self._process_deck_data(data)\n\n        self.call_js_method(\n            \"addPathLayer\",\n            id=layer_id,\n            data=processed_data,\n            getPath=get_path,\n            getColor=get_color or [51, 136, 255, 200],\n            getWidth=get_width,\n            widthScale=width_scale,\n            widthMinPixels=width_min_pixels,\n            pickable=pickable,\n            opacity=opacity,\n            **kwargs,\n        )\n\n        self._layers = {\n            **self._layers,\n            layer_id: {\n                \"id\": layer_id,\n                \"type\": \"path\",\n            },\n        }\n        self._add_to_layer_dict(layer_id, \"Deck.gl\")\n\n    # -------------------------------------------------------------------------\n    # Polygon Layer (deck.gl)\n    # -------------------------------------------------------------------------\n\n    def add_polygon_layer(\n        self,\n        data: Any,\n        name: Optional[str] = None,\n        get_polygon: Union[str, Any] = \"polygon\",\n        get_fill_color: Optional[Union[List[int], str]] = None,\n        get_line_color: Optional[Union[List[int], str]] = None,\n        get_line_width: Union[float, str] = 1,\n        get_elevation: Union[float, str] = 0,\n        extruded: bool = False,\n        wireframe: bool = False,\n        filled: bool = True,\n        stroked: bool = True,\n        line_width_min_pixels: float = 1,\n        pickable: bool = True,\n        opacity: float = 0.5,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a polygon layer for filled polygon visualization using deck.gl.\n\n        Polygon layers render filled and/or stroked polygons with optional\n        3D extrusion, ideal for choropleth maps and area visualizations.\n\n        Args:\n            data: Array of data objects with polygon coordinates.\n            name: Layer ID. If None, auto-generated.\n            get_polygon: Accessor for polygon coordinates.\n                Can be a string (property name) or a value.\n            get_fill_color: Accessor for fill color [r, g, b, a].\n                Default: [51, 136, 255, 128].\n            get_line_color: Accessor for stroke color [r, g, b, a].\n                Default: [0, 0, 255, 255].\n            get_line_width: Accessor for stroke width.\n            get_elevation: Accessor for 3D extrusion height.\n            extruded: Whether to render as 3D polygons.\n            wireframe: Whether to render wireframe (extruded only).\n            filled: Whether to fill polygons.\n            stroked: Whether to draw stroke.\n            line_width_min_pixels: Minimum stroke width in pixels.\n            pickable: Whether layer responds to hover/click events.\n            opacity: Layer opacity (0-1).\n            **kwargs: Additional PolygonLayer props.\n\n        Example:\n            &gt;&gt;&gt; from anymap_ts import MapLibreMap\n            &gt;&gt;&gt; m = MapLibreMap(pitch=45)\n            &gt;&gt;&gt; polygons = [\n            ...     {\"polygon\": [[-122.4, 37.8], [-122.5, 37.7], [-122.3, 37.7]], \"height\": 1000},\n            ... ]\n            &gt;&gt;&gt; m.add_polygon_layer(polygons, extruded=True, get_elevation=\"height\")\n        \"\"\"\n        layer_id = name or f\"polygon-{len(self._layers)}\"\n        processed_data = self._process_deck_data(data)\n\n        self.call_js_method(\n            \"addPolygonLayer\",\n            id=layer_id,\n            data=processed_data,\n            getPolygon=get_polygon,\n            getFillColor=get_fill_color or [51, 136, 255, 128],\n            getLineColor=get_line_color or [0, 0, 255, 255],\n            getLineWidth=get_line_width,\n            getElevation=get_elevation,\n            extruded=extruded,\n            wireframe=wireframe,\n            filled=filled,\n            stroked=stroked,\n            lineWidthMinPixels=line_width_min_pixels,\n            pickable=pickable,\n            opacity=opacity,\n            **kwargs,\n        )\n\n        self._layers = {\n            **self._layers,\n            layer_id: {\n                \"id\": layer_id,\n                \"type\": \"polygon\",\n            },\n        }\n        self._add_to_layer_dict(layer_id, \"Deck.gl\")\n\n    # -------------------------------------------------------------------------\n    # Hexagon Layer (deck.gl)\n    # -------------------------------------------------------------------------\n\n    def add_hexagon_layer(\n        self,\n        data: Any,\n        name: Optional[str] = None,\n        get_position: Union[str, Any] = \"coordinates\",\n        radius: float = 1000,\n        elevation_scale: float = 4,\n        extruded: bool = True,\n        color_range: Optional[List[List[int]]] = None,\n        pickable: bool = True,\n        opacity: float = 0.8,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a hexagon layer for hexagonal binning/aggregation using deck.gl.\n\n        Hexagon layers aggregate points into hexagonal bins and render them\n        with height and color based on point density.\n\n        Args:\n            data: Array of data objects with position coordinates.\n            name: Layer ID. If None, auto-generated.\n            get_position: Accessor for point position [lng, lat].\n            radius: Hexagon radius in meters.\n            elevation_scale: Elevation multiplier for 3D hexagons.\n            extruded: Whether to render as 3D hexagons.\n            color_range: Color gradient for aggregation [[r, g, b], ...].\n            pickable: Whether layer responds to hover/click events.\n            opacity: Layer opacity (0-1).\n            **kwargs: Additional HexagonLayer props.\n\n        Example:\n            &gt;&gt;&gt; from anymap_ts import MapLibreMap\n            &gt;&gt;&gt; m = MapLibreMap(pitch=45)\n            &gt;&gt;&gt; points = [\n            ...     {\"coordinates\": [-122.4, 37.8]},\n            ...     {\"coordinates\": [-122.41, 37.81]},\n            ... ]\n            &gt;&gt;&gt; m.add_hexagon_layer(points, radius=500, elevation_scale=10)\n        \"\"\"\n        layer_id = name or f\"hexagon-{len(self._layers)}\"\n        processed_data = self._process_deck_data(data)\n\n        default_color_range = [\n            [1, 152, 189],\n            [73, 227, 206],\n            [216, 254, 181],\n            [254, 237, 177],\n            [254, 173, 84],\n            [209, 55, 78],\n        ]\n\n        self.call_js_method(\n            \"addHexagonLayer\",\n            id=layer_id,\n            data=processed_data,\n            getPosition=get_position,\n            radius=radius,\n            elevationScale=elevation_scale,\n            extruded=extruded,\n            colorRange=color_range or default_color_range,\n            pickable=pickable,\n            opacity=opacity,\n            **kwargs,\n        )\n\n        self._layers = {\n            **self._layers,\n            layer_id: {\n                \"id\": layer_id,\n                \"type\": \"hexagon\",\n            },\n        }\n        self._add_to_layer_dict(layer_id, \"Deck.gl\")\n\n    # -------------------------------------------------------------------------\n    # Deck.gl Heatmap Layer\n    # -------------------------------------------------------------------------\n\n    def add_deck_heatmap_layer(\n        self,\n        data: Any,\n        name: Optional[str] = None,\n        get_position: Union[str, Any] = \"coordinates\",\n        get_weight: Union[float, str] = 1,\n        radius_pixels: float = 30,\n        intensity: float = 1,\n        threshold: float = 0.05,\n        color_range: Optional[List[List[int]]] = None,\n        opacity: float = 1,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a GPU-accelerated heatmap layer using deck.gl.\n\n        This is an alternative to the native MapLibre heatmap layer, using\n        deck.gl's GPU-based rendering for better performance with large datasets.\n\n        Args:\n            data: Array of data objects with position coordinates.\n            name: Layer ID. If None, auto-generated.\n            get_position: Accessor for point position [lng, lat].\n            get_weight: Accessor for point weight value.\n            radius_pixels: Influence radius in pixels.\n            intensity: Intensity multiplier.\n            threshold: Minimum density threshold (0-1).\n            color_range: Color gradient [[r, g, b, a], ...].\n            opacity: Layer opacity (0-1).\n            **kwargs: Additional HeatmapLayer props.\n\n        Example:\n            &gt;&gt;&gt; from anymap_ts import MapLibreMap\n            &gt;&gt;&gt; m = MapLibreMap()\n            &gt;&gt;&gt; points = [\n            ...     {\"coordinates\": [-122.4, 37.8], \"weight\": 5},\n            ...     {\"coordinates\": [-122.5, 37.7], \"weight\": 10},\n            ... ]\n            &gt;&gt;&gt; m.add_deck_heatmap_layer(points, get_weight=\"weight\")\n        \"\"\"\n        layer_id = name or f\"deck-heatmap-{len(self._layers)}\"\n        processed_data = self._process_deck_data(data)\n\n        default_color_range = [\n            [255, 255, 178, 25],\n            [254, 217, 118, 85],\n            [254, 178, 76, 127],\n            [253, 141, 60, 170],\n            [240, 59, 32, 212],\n            [189, 0, 38, 255],\n        ]\n\n        self.call_js_method(\n            \"addHeatmapLayer\",\n            id=layer_id,\n            data=processed_data,\n            getPosition=get_position,\n            getWeight=get_weight,\n            radiusPixels=radius_pixels,\n            intensity=intensity,\n            threshold=threshold,\n            colorRange=color_range or default_color_range,\n            opacity=opacity,\n            **kwargs,\n        )\n\n        self._layers = {\n            **self._layers,\n            layer_id: {\n                \"id\": layer_id,\n                \"type\": \"deck-heatmap\",\n            },\n        }\n        self._add_to_layer_dict(layer_id, \"Deck.gl\")\n\n    # -------------------------------------------------------------------------\n    # Grid Layer (deck.gl)\n    # -------------------------------------------------------------------------\n\n    def add_grid_layer(\n        self,\n        data: Any,\n        name: Optional[str] = None,\n        get_position: Union[str, Any] = \"coordinates\",\n        cell_size: float = 200,\n        elevation_scale: float = 4,\n        extruded: bool = True,\n        color_range: Optional[List[List[int]]] = None,\n        pickable: bool = True,\n        opacity: float = 0.8,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a grid layer for square grid aggregation using deck.gl.\n\n        Grid layers aggregate points into square grid cells and render them\n        with height and color based on point density.\n\n        Args:\n            data: Array of data objects with position coordinates.\n            name: Layer ID. If None, auto-generated.\n            get_position: Accessor for point position [lng, lat].\n            cell_size: Grid cell size in meters.\n            elevation_scale: Elevation multiplier for 3D cells.\n            extruded: Whether to render as 3D cells.\n            color_range: Color gradient [[r, g, b], ...].\n            pickable: Whether layer responds to hover/click events.\n            opacity: Layer opacity (0-1).\n            **kwargs: Additional GridLayer props.\n\n        Example:\n            &gt;&gt;&gt; from anymap_ts import MapLibreMap\n            &gt;&gt;&gt; m = MapLibreMap(pitch=45)\n            &gt;&gt;&gt; points = [\n            ...     {\"coordinates\": [-122.4, 37.8]},\n            ...     {\"coordinates\": [-122.41, 37.81]},\n            ... ]\n            &gt;&gt;&gt; m.add_grid_layer(points, cell_size=500)\n        \"\"\"\n        layer_id = name or f\"grid-{len(self._layers)}\"\n        processed_data = self._process_deck_data(data)\n\n        default_color_range = [\n            [1, 152, 189],\n            [73, 227, 206],\n            [216, 254, 181],\n            [254, 237, 177],\n            [254, 173, 84],\n            [209, 55, 78],\n        ]\n\n        self.call_js_method(\n            \"addGridLayer\",\n            id=layer_id,\n            data=processed_data,\n            getPosition=get_position,\n            cellSize=cell_size,\n            elevationScale=elevation_scale,\n            extruded=extruded,\n            colorRange=color_range or default_color_range,\n            pickable=pickable,\n            opacity=opacity,\n            **kwargs,\n        )\n\n        self._layers = {\n            **self._layers,\n            layer_id: {\n                \"id\": layer_id,\n                \"type\": \"grid\",\n            },\n        }\n        self._add_to_layer_dict(layer_id, \"Deck.gl\")\n\n    # -------------------------------------------------------------------------\n    # Icon Layer (deck.gl)\n    # -------------------------------------------------------------------------\n\n    def add_icon_layer(\n        self,\n        data: Any,\n        name: Optional[str] = None,\n        get_position: Union[str, Any] = \"coordinates\",\n        get_icon: Union[str, Any] = \"icon\",\n        get_size: Union[float, str] = 20,\n        get_color: Optional[Union[List[int], str]] = None,\n        icon_atlas: Optional[str] = None,\n        icon_mapping: Optional[Dict] = None,\n        pickable: bool = True,\n        opacity: float = 1,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add an icon layer for custom icon markers at scale using deck.gl.\n\n        Icon layers render icons/images at specified positions, ideal for\n        rendering large numbers of custom markers efficiently.\n\n        Args:\n            data: Array of data objects with position coordinates.\n            name: Layer ID. If None, auto-generated.\n            get_position: Accessor for icon position [lng, lat].\n            get_icon: Accessor for icon name in icon_mapping.\n            get_size: Accessor for icon size in pixels.\n            get_color: Accessor for icon tint color [r, g, b, a].\n                Default: [255, 255, 255, 255] (white, no tint).\n            icon_atlas: URL to icon atlas image.\n            icon_mapping: Dict mapping icon names to atlas coordinates.\n            pickable: Whether layer responds to hover/click events.\n            opacity: Layer opacity (0-1).\n            **kwargs: Additional IconLayer props.\n\n        Example:\n            &gt;&gt;&gt; from anymap_ts import MapLibreMap\n            &gt;&gt;&gt; m = MapLibreMap()\n            &gt;&gt;&gt; markers = [\n            ...     {\"coordinates\": [-122.4, 37.8], \"icon\": \"marker\", \"size\": 30},\n            ... ]\n            &gt;&gt;&gt; m.add_icon_layer(markers, get_size=\"size\")\n        \"\"\"\n        layer_id = name or f\"icon-{len(self._layers)}\"\n        processed_data = self._process_deck_data(data)\n\n        self.call_js_method(\n            \"addIconLayer\",\n            id=layer_id,\n            data=processed_data,\n            getPosition=get_position,\n            getIcon=get_icon,\n            getSize=get_size,\n            getColor=get_color or [255, 255, 255, 255],\n            iconAtlas=icon_atlas,\n            iconMapping=icon_mapping,\n            pickable=pickable,\n            opacity=opacity,\n            **kwargs,\n        )\n\n        self._layers = {\n            **self._layers,\n            layer_id: {\n                \"id\": layer_id,\n                \"type\": \"icon\",\n            },\n        }\n        self._add_to_layer_dict(layer_id, \"Deck.gl\")\n\n    # -------------------------------------------------------------------------\n    # Text Layer (deck.gl)\n    # -------------------------------------------------------------------------\n\n    def add_text_layer(\n        self,\n        data: Any,\n        name: Optional[str] = None,\n        get_position: Union[str, Any] = \"coordinates\",\n        get_text: Union[str, Any] = \"text\",\n        get_size: Union[float, str] = 12,\n        get_color: Optional[Union[List[int], str]] = None,\n        get_angle: Union[float, str] = 0,\n        text_anchor: str = \"middle\",\n        alignment_baseline: str = \"center\",\n        pickable: bool = True,\n        opacity: float = 1,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a text layer for label placement using deck.gl.\n\n        Text layers render text labels at specified positions, ideal for\n        annotating map features or creating label layers.\n\n        Args:\n            data: Array of data objects with position and text.\n            name: Layer ID. If None, auto-generated.\n            get_position: Accessor for text position [lng, lat].\n            get_text: Accessor for text content string.\n            get_size: Accessor for text size in pixels.\n            get_color: Accessor for text color [r, g, b, a].\n                Default: [0, 0, 0, 255] (black).\n            get_angle: Accessor for text rotation in degrees.\n            text_anchor: Horizontal alignment ('start', 'middle', 'end').\n            alignment_baseline: Vertical alignment ('top', 'center', 'bottom').\n            pickable: Whether layer responds to hover/click events.\n            opacity: Layer opacity (0-1).\n            **kwargs: Additional TextLayer props.\n\n        Example:\n            &gt;&gt;&gt; from anymap_ts import MapLibreMap\n            &gt;&gt;&gt; m = MapLibreMap()\n            &gt;&gt;&gt; labels = [\n            ...     {\"coordinates\": [-122.4, 37.8], \"text\": \"San Francisco\"},\n            ...     {\"coordinates\": [-118.2, 34.1], \"text\": \"Los Angeles\"},\n            ... ]\n            &gt;&gt;&gt; m.add_text_layer(labels, get_size=16)\n        \"\"\"\n        layer_id = name or f\"text-{len(self._layers)}\"\n        processed_data = self._process_deck_data(data)\n\n        self.call_js_method(\n            \"addTextLayer\",\n            id=layer_id,\n            data=processed_data,\n            getPosition=get_position,\n            getText=get_text,\n            getSize=get_size,\n            getColor=get_color or [0, 0, 0, 255],\n            getAngle=get_angle,\n            getTextAnchor=text_anchor,\n            getAlignmentBaseline=alignment_baseline,\n            pickable=pickable,\n            opacity=opacity,\n            **kwargs,\n        )\n\n        self._layers = {\n            **self._layers,\n            layer_id: {\n                \"id\": layer_id,\n                \"type\": \"text\",\n            },\n        }\n        self._add_to_layer_dict(layer_id, \"Deck.gl\")\n\n    # -------------------------------------------------------------------------\n    # GeoJSON Layer (deck.gl)\n    # -------------------------------------------------------------------------\n\n    def add_geojson_layer(\n        self,\n        data: Any,\n        name: Optional[str] = None,\n        get_fill_color: Optional[Union[List[int], str]] = None,\n        get_line_color: Optional[Union[List[int], str]] = None,\n        get_line_width: Union[float, str] = 1,\n        get_point_radius: Union[float, str] = 5,\n        get_elevation: Union[float, str] = 0,\n        extruded: bool = False,\n        wireframe: bool = False,\n        filled: bool = True,\n        stroked: bool = True,\n        line_width_min_pixels: float = 1,\n        point_radius_min_pixels: float = 2,\n        pickable: bool = True,\n        opacity: float = 0.8,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a GeoJSON layer with auto-styling using deck.gl.\n\n        GeoJSON layers render GeoJSON features with automatic geometry type\n        detection and styling, supporting points, lines, and polygons.\n\n        Args:\n            data: GeoJSON object, URL, or file path.\n            name: Layer ID. If None, auto-generated.\n            get_fill_color: Accessor for fill color [r, g, b, a].\n                Default: [51, 136, 255, 128].\n            get_line_color: Accessor for stroke color [r, g, b, a].\n                Default: [0, 0, 0, 255].\n            get_line_width: Accessor for stroke width.\n            get_point_radius: Accessor for point radius.\n            get_elevation: Accessor for 3D extrusion height.\n            extruded: Whether to render as 3D features.\n            wireframe: Whether to render wireframe (extruded only).\n            filled: Whether to fill features.\n            stroked: Whether to draw stroke.\n            line_width_min_pixels: Minimum stroke width in pixels.\n            point_radius_min_pixels: Minimum point radius in pixels.\n            pickable: Whether layer responds to hover/click events.\n            opacity: Layer opacity (0-1).\n            **kwargs: Additional GeoJsonLayer props.\n\n        Example:\n            &gt;&gt;&gt; from anymap_ts import MapLibreMap\n            &gt;&gt;&gt; m = MapLibreMap()\n            &gt;&gt;&gt; m.add_geojson_layer(\n            ...     \"https://example.com/data.geojson\",\n            ...     get_fill_color=[255, 0, 0, 128],\n            ... )\n        \"\"\"\n        layer_id = name or f\"geojson-deck-{len(self._layers)}\"\n        processed_data = self._process_deck_data(data)\n\n        self.call_js_method(\n            \"addGeoJsonLayer\",\n            id=layer_id,\n            data=processed_data,\n            getFillColor=get_fill_color or [51, 136, 255, 128],\n            getLineColor=get_line_color or [0, 0, 0, 255],\n            getLineWidth=get_line_width,\n            getPointRadius=get_point_radius,\n            getElevation=get_elevation,\n            extruded=extruded,\n            wireframe=wireframe,\n            filled=filled,\n            stroked=stroked,\n            lineWidthMinPixels=line_width_min_pixels,\n            pointRadiusMinPixels=point_radius_min_pixels,\n            pickable=pickable,\n            opacity=opacity,\n            **kwargs,\n        )\n\n        self._layers = {\n            **self._layers,\n            layer_id: {\n                \"id\": layer_id,\n                \"type\": \"geojson-deck\",\n            },\n        }\n        self._add_to_layer_dict(layer_id, \"Deck.gl\")\n\n    # -------------------------------------------------------------------------\n    # Contour Layer (deck.gl)\n    # -------------------------------------------------------------------------\n\n    def add_contour_layer(\n        self,\n        data: Any,\n        name: Optional[str] = None,\n        get_position: Union[str, Any] = \"coordinates\",\n        get_weight: Union[float, str] = 1,\n        cell_size: float = 200,\n        contours: Optional[List[Dict]] = None,\n        pickable: bool = True,\n        opacity: float = 1,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a contour layer for isoline/isoband generation using deck.gl.\n\n        Contour layers aggregate point data and generate isolines or isobands,\n        ideal for density visualization and topographic-style maps.\n\n        Args:\n            data: Array of data objects with position coordinates.\n            name: Layer ID. If None, auto-generated.\n            get_position: Accessor for point position [lng, lat].\n            get_weight: Accessor for point weight value.\n            cell_size: Grid cell size for aggregation in meters.\n            contours: Contour definitions [{threshold, color, strokeWidth}, ...].\n            pickable: Whether layer responds to hover/click events.\n            opacity: Layer opacity (0-1).\n            **kwargs: Additional ContourLayer props.\n\n        Example:\n            &gt;&gt;&gt; from anymap_ts import MapLibreMap\n            &gt;&gt;&gt; m = MapLibreMap()\n            &gt;&gt;&gt; points = [\n            ...     {\"coordinates\": [-122.4, 37.8], \"weight\": 5},\n            ...     {\"coordinates\": [-122.41, 37.81], \"weight\": 10},\n            ... ]\n            &gt;&gt;&gt; m.add_contour_layer(points, contours=[\n            ...     {\"threshold\": 1, \"color\": [255, 255, 178], \"strokeWidth\": 1},\n            ...     {\"threshold\": 5, \"color\": [253, 141, 60], \"strokeWidth\": 2},\n            ... ])\n        \"\"\"\n        layer_id = name or f\"contour-{len(self._layers)}\"\n        processed_data = self._process_deck_data(data)\n\n        default_contours = [\n            {\"threshold\": 1, \"color\": [255, 255, 255], \"strokeWidth\": 1},\n            {\"threshold\": 5, \"color\": [51, 136, 255], \"strokeWidth\": 2},\n            {\"threshold\": 10, \"color\": [0, 0, 255], \"strokeWidth\": 3},\n        ]\n\n        self.call_js_method(\n            \"addContourLayer\",\n            id=layer_id,\n            data=processed_data,\n            getPosition=get_position,\n            getWeight=get_weight,\n            cellSize=cell_size,\n            contours=contours or default_contours,\n            pickable=pickable,\n            opacity=opacity,\n            **kwargs,\n        )\n\n        self._layers = {\n            **self._layers,\n            layer_id: {\n                \"id\": layer_id,\n                \"type\": \"contour\",\n            },\n        }\n        self._add_to_layer_dict(layer_id, \"Deck.gl\")\n\n    # -------------------------------------------------------------------------\n    # Screen Grid Layer (deck.gl)\n    # -------------------------------------------------------------------------\n\n    def add_screen_grid_layer(\n        self,\n        data: Any,\n        name: Optional[str] = None,\n        get_position: Union[str, Any] = \"coordinates\",\n        get_weight: Union[float, str] = 1,\n        cell_size_pixels: float = 50,\n        color_range: Optional[List[List[int]]] = None,\n        pickable: bool = True,\n        opacity: float = 0.8,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a screen grid layer for screen-space grid aggregation using deck.gl.\n\n        Screen grid layers aggregate points into a grid in screen space,\n        providing a fast overview of point density that updates on zoom/pan.\n\n        Args:\n            data: Array of data objects with position coordinates.\n            name: Layer ID. If None, auto-generated.\n            get_position: Accessor for point position [lng, lat].\n            get_weight: Accessor for point weight value.\n            cell_size_pixels: Grid cell size in screen pixels.\n            color_range: Color gradient [[r, g, b, a], ...].\n            pickable: Whether layer responds to hover/click events.\n            opacity: Layer opacity (0-1).\n            **kwargs: Additional ScreenGridLayer props.\n\n        Example:\n            &gt;&gt;&gt; from anymap_ts import MapLibreMap\n            &gt;&gt;&gt; m = MapLibreMap()\n            &gt;&gt;&gt; points = [\n            ...     {\"coordinates\": [-122.4, 37.8]},\n            ...     {\"coordinates\": [-122.41, 37.81]},\n            ... ]\n            &gt;&gt;&gt; m.add_screen_grid_layer(points, cell_size_pixels=30)\n        \"\"\"\n        layer_id = name or f\"screengrid-{len(self._layers)}\"\n        processed_data = self._process_deck_data(data)\n\n        default_color_range = [\n            [255, 255, 178, 25],\n            [254, 217, 118, 85],\n            [254, 178, 76, 127],\n            [253, 141, 60, 170],\n            [240, 59, 32, 212],\n            [189, 0, 38, 255],\n        ]\n\n        self.call_js_method(\n            \"addScreenGridLayer\",\n            id=layer_id,\n            data=processed_data,\n            getPosition=get_position,\n            getWeight=get_weight,\n            cellSizePixels=cell_size_pixels,\n            colorRange=color_range or default_color_range,\n            pickable=pickable,\n            opacity=opacity,\n            **kwargs,\n        )\n\n        self._layers = {\n            **self._layers,\n            layer_id: {\n                \"id\": layer_id,\n                \"type\": \"screengrid\",\n            },\n        }\n        self._add_to_layer_dict(layer_id, \"Deck.gl\")\n\n    # -------------------------------------------------------------------------\n    # Trips Layer (deck.gl)\n    # -------------------------------------------------------------------------\n\n    def add_trips_layer(\n        self,\n        data: Any,\n        name: Optional[str] = None,\n        get_path: Union[str, Any] = \"waypoints\",\n        get_timestamps: Union[str, Any] = \"timestamps\",\n        get_color: Optional[Union[List[int], str]] = None,\n        width_min_pixels: float = 2,\n        trail_length: float = 180,\n        current_time: float = 0,\n        pickable: bool = True,\n        opacity: float = 0.8,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a trips layer for animated trip/trajectory playback using deck.gl.\n\n        Trips layers render animated paths showing movement over time, ideal\n        for visualizing vehicle routes, migration patterns, or time-based data.\n\n        Args:\n            data: Array of trip objects with waypoints and timestamps.\n            name: Layer ID. If None, auto-generated.\n            get_path: Accessor for waypoint coordinates [[lng, lat], ...].\n            get_timestamps: Accessor for timestamps at each waypoint.\n            get_color: Accessor for trip color [r, g, b] or [r, g, b, a].\n                Default: [253, 128, 93].\n            width_min_pixels: Minimum trail width in pixels.\n            trail_length: Trail length in timestamp units.\n            current_time: Current animation time.\n            pickable: Whether layer responds to hover/click events.\n            opacity: Layer opacity (0-1).\n            **kwargs: Additional TripsLayer props.\n\n        Example:\n            &gt;&gt;&gt; from anymap_ts import MapLibreMap\n            &gt;&gt;&gt; m = MapLibreMap()\n            &gt;&gt;&gt; trips = [\n            ...     {\n            ...         \"waypoints\": [[-122.4, 37.8], [-122.5, 37.7]],\n            ...         \"timestamps\": [0, 100]\n            ...     }\n            ... ]\n            &gt;&gt;&gt; m.add_trips_layer(trips, trail_length=200, current_time=50)\n        \"\"\"\n        layer_id = name or f\"trips-{len(self._layers)}\"\n        processed_data = self._process_deck_data(data)\n\n        self.call_js_method(\n            \"addTripsLayer\",\n            id=layer_id,\n            data=processed_data,\n            getPath=get_path,\n            getTimestamps=get_timestamps,\n            getColor=get_color or [253, 128, 93],\n            widthMinPixels=width_min_pixels,\n            trailLength=trail_length,\n            currentTime=current_time,\n            pickable=pickable,\n            opacity=opacity,\n            **kwargs,\n        )\n\n        self._layers = {\n            **self._layers,\n            layer_id: {\n                \"id\": layer_id,\n                \"type\": \"trips\",\n            },\n        }\n        self._add_to_layer_dict(layer_id, \"Deck.gl\")\n\n    # -------------------------------------------------------------------------\n    # Line Layer (deck.gl)\n    # -------------------------------------------------------------------------\n\n    def add_line_layer(\n        self,\n        data: Any,\n        name: Optional[str] = None,\n        get_source_position: Union[str, Any] = \"sourcePosition\",\n        get_target_position: Union[str, Any] = \"targetPosition\",\n        get_color: Optional[Union[List[int], str]] = None,\n        get_width: Union[float, str] = 1,\n        width_min_pixels: float = 1,\n        pickable: bool = True,\n        opacity: float = 0.8,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a line layer for origin-destination line visualization using deck.gl.\n\n        Line layers render straight line segments between source and target\n        positions. Unlike arc layers, lines are drawn without curvature.\n\n        Args:\n            data: Array of line objects with source/target positions.\n            name: Layer ID. If None, auto-generated.\n            get_source_position: Accessor for source position [lng, lat].\n            get_target_position: Accessor for target position [lng, lat].\n            get_color: Accessor for line color [r, g, b] or [r, g, b, a].\n                Default: [51, 136, 255, 200] (blue).\n            get_width: Accessor for line width.\n            width_min_pixels: Minimum line width in pixels.\n            pickable: Whether layer responds to hover/click events.\n            opacity: Layer opacity (0-1).\n            **kwargs: Additional LineLayer props.\n\n        Example:\n            &gt;&gt;&gt; from anymap_ts import MapLibreMap\n            &gt;&gt;&gt; m = MapLibreMap()\n            &gt;&gt;&gt; lines = [\n            ...     {\"sourcePosition\": [-122.4, 37.8], \"targetPosition\": [-73.9, 40.7]},\n            ... ]\n            &gt;&gt;&gt; m.add_line_layer(lines, get_color=[0, 128, 255], get_width=2)\n        \"\"\"\n        layer_id = name or f\"line-{len(self._layers)}\"\n        processed_data = self._process_deck_data(data)\n\n        self.call_js_method(\n            \"addLineLayer\",\n            id=layer_id,\n            data=processed_data,\n            getSourcePosition=get_source_position,\n            getTargetPosition=get_target_position,\n            getColor=get_color or [51, 136, 255, 200],\n            getWidth=get_width,\n            widthMinPixels=width_min_pixels,\n            pickable=pickable,\n            opacity=opacity,\n            **kwargs,\n        )\n\n        self._layers = {\n            **self._layers,\n            layer_id: {\n                \"id\": layer_id,\n                \"type\": \"line\",\n            },\n        }\n        self._add_to_layer_dict(layer_id, \"Deck.gl\")\n\n    # -------------------------------------------------------------------------\n    # Generic Deck.gl Layer\n    # -------------------------------------------------------------------------\n\n    def add_deckgl_layer(\n        self,\n        layer_type: str,\n        data: Any,\n        name: Optional[str] = None,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a generic deck.gl layer to the map.\n\n        This method provides a flexible way to add any supported deck.gl layer\n        type using a single interface. For commonly used layers, prefer the\n        specific methods (e.g., add_scatterplot_layer) for better IDE support.\n\n        Args:\n            layer_type: The deck.gl layer type (e.g., 'ScatterplotLayer',\n                'ArcLayer', 'HexagonLayer').\n            data: Array of data objects or GeoJSON.\n            name: Layer ID. If None, auto-generated from layer_type.\n            **kwargs: Layer-specific properties passed directly to deck.gl.\n\n        Example:\n            &gt;&gt;&gt; from anymap_ts import MapLibreMap\n            &gt;&gt;&gt; m = MapLibreMap()\n            &gt;&gt;&gt; m.add_deckgl_layer(\n            ...     \"TripsLayer\",\n            ...     data=trips_data,\n            ...     getPath=\"waypoints\",\n            ...     getTimestamps=\"timestamps\",\n            ...     trailLength=180,\n            ... )\n        \"\"\"\n        layer_type_clean = layer_type.replace(\"Layer\", \"\")\n        prefix = layer_type_clean.lower()\n        layer_id = name or f\"{prefix}-{len(self._layers)}\"\n        processed_data = self._process_deck_data(data)\n\n        self.call_js_method(\n            \"addDeckGLLayer\",\n            layerType=layer_type,\n            id=layer_id,\n            data=processed_data,\n            **kwargs,\n        )\n\n        self._layers = {\n            **self._layers,\n            layer_id: {\n                \"id\": layer_id,\n                \"type\": layer_type,\n            },\n        }\n        self._add_to_layer_dict(layer_id, \"Deck.gl\")\n\n    def remove_deck_layer(self, layer_id: str) -&gt; None:\n        \"\"\"Remove a deck.gl layer from the map.\n\n        Args:\n            layer_id: Layer identifier to remove.\n        \"\"\"\n        self._remove_layer_internal(layer_id, \"removeDeckLayer\")\n\n    # -------------------------------------------------------------------------\n    # Column Layer (deck.gl)\n    # -------------------------------------------------------------------------\n\n    def add_column_layer(\n        self,\n        data: Any,\n        name: Optional[str] = None,\n        get_position: Union[str, Any] = \"coordinates\",\n        get_fill_color: Optional[Union[List[int], str]] = None,\n        get_line_color: Optional[Union[List[int], str]] = None,\n        get_elevation: Union[float, str] = 1000,\n        radius: float = 1000,\n        disk_resolution: int = 20,\n        elevation_scale: float = 1,\n        coverage: float = 1,\n        extruded: bool = True,\n        filled: bool = True,\n        stroked: bool = False,\n        wireframe: bool = False,\n        pickable: bool = True,\n        opacity: float = 0.8,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a column layer for 3D bar chart visualization using deck.gl.\n\n        Column layers render cylindrical columns at specified positions,\n        ideal for 3D bar charts on a map.\n\n        Args:\n            data: Array of data objects with position coordinates.\n            name: Layer ID. If None, auto-generated.\n            get_position: Accessor for column position [lng, lat].\n            get_fill_color: Accessor for fill color [r, g, b, a].\n            get_line_color: Accessor for stroke color [r, g, b, a].\n            get_elevation: Accessor for column height.\n            radius: Column radius in meters.\n            disk_resolution: Number of sides for column polygon.\n            elevation_scale: Elevation multiplier.\n            coverage: Column coverage (0-1).\n            extruded: Whether to extrude columns.\n            filled: Whether to fill columns.\n            stroked: Whether to stroke columns.\n            wireframe: Whether to render as wireframe.\n            pickable: Whether layer responds to hover/click events.\n            opacity: Layer opacity (0-1).\n            **kwargs: Additional ColumnLayer props.\n\n        Example:\n            &gt;&gt;&gt; from anymap_ts import MapLibreMap\n            &gt;&gt;&gt; m = MapLibreMap(pitch=45)\n            &gt;&gt;&gt; data = [\n            ...     {\"coordinates\": [-122.4, 37.8], \"value\": 500},\n            ...     {\"coordinates\": [-122.5, 37.7], \"value\": 1000},\n            ... ]\n            &gt;&gt;&gt; m.add_column_layer(data, get_elevation=\"value\", radius=500)\n        \"\"\"\n        layer_id = name or f\"column-{len(self._layers)}\"\n        processed_data = self._process_deck_data(data)\n\n        self.call_js_method(\n            \"addColumnLayer\",\n            id=layer_id,\n            data=processed_data,\n            getPosition=get_position,\n            getFillColor=get_fill_color or [255, 140, 0, 200],\n            getLineColor=get_line_color or [0, 0, 0, 255],\n            getElevation=get_elevation,\n            radius=radius,\n            diskResolution=disk_resolution,\n            elevationScale=elevation_scale,\n            coverage=coverage,\n            extruded=extruded,\n            filled=filled,\n            stroked=stroked,\n            wireframe=wireframe,\n            pickable=pickable,\n            opacity=opacity,\n            **kwargs,\n        )\n\n        self._layers = {\n            **self._layers,\n            layer_id: {\"id\": layer_id, \"type\": \"column\"},\n        }\n        self._add_to_layer_dict(layer_id, \"Deck.gl\")\n\n    # -------------------------------------------------------------------------\n    # Bitmap Layer (deck.gl)\n    # -------------------------------------------------------------------------\n\n    def add_bitmap_layer(\n        self,\n        image: str,\n        bounds: List[float],\n        name: Optional[str] = None,\n        opacity: float = 1.0,\n        visible: bool = True,\n        pickable: bool = False,\n        desaturate: float = 0,\n        transparent_color: Optional[List[int]] = None,\n        tint_color: Optional[List[int]] = None,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a bitmap layer for image overlay with GPU rendering using deck.gl.\n\n        Args:\n            image: URL or data URI of the image.\n            bounds: Bounding box [west, south, east, north].\n            name: Layer ID. If None, auto-generated.\n            opacity: Layer opacity (0-1).\n            visible: Whether layer is visible.\n            pickable: Whether layer responds to hover/click events.\n            desaturate: Desaturation amount (0-1).\n            transparent_color: Color to make transparent [r, g, b, a].\n            tint_color: Color to tint the image [r, g, b].\n            **kwargs: Additional BitmapLayer props.\n\n        Example:\n            &gt;&gt;&gt; from anymap_ts import MapLibreMap\n            &gt;&gt;&gt; m = MapLibreMap()\n            &gt;&gt;&gt; m.add_bitmap_layer(\n            ...     \"https://example.com/overlay.png\",\n            ...     bounds=[-122.5, 37.7, -122.3, 37.9],\n            ... )\n        \"\"\"\n        layer_id = name or f\"bitmap-{len(self._layers)}\"\n\n        self.call_js_method(\n            \"addBitmapLayer\",\n            id=layer_id,\n            image=image,\n            bounds=bounds,\n            opacity=opacity,\n            visible=visible,\n            pickable=pickable,\n            desaturate=desaturate,\n            transparentColor=transparent_color or [0, 0, 0, 0],\n            tintColor=tint_color or [255, 255, 255],\n            **kwargs,\n        )\n\n        self._layers = {\n            **self._layers,\n            layer_id: {\"id\": layer_id, \"type\": \"bitmap\"},\n        }\n        self._add_to_layer_dict(layer_id, \"Deck.gl\")\n\n    # -------------------------------------------------------------------------\n    # Solid Polygon Layer (deck.gl)\n    # -------------------------------------------------------------------------\n\n    def add_solid_polygon_layer(\n        self,\n        data: Any,\n        name: Optional[str] = None,\n        get_polygon: Union[str, Any] = \"polygon\",\n        get_fill_color: Optional[Union[List[int], str]] = None,\n        get_line_color: Optional[Union[List[int], str]] = None,\n        get_elevation: Union[float, str] = 0,\n        filled: bool = True,\n        extruded: bool = False,\n        wireframe: bool = False,\n        elevation_scale: float = 1,\n        pickable: bool = True,\n        opacity: float = 0.8,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a solid polygon layer for extruded 3D polygon visualization using deck.gl.\n\n        Args:\n            data: Array of data objects with polygon coordinates.\n            name: Layer ID. If None, auto-generated.\n            get_polygon: Accessor for polygon coordinates.\n            get_fill_color: Accessor for fill color [r, g, b, a].\n            get_line_color: Accessor for stroke color [r, g, b, a].\n            get_elevation: Accessor for 3D extrusion height.\n            filled: Whether to fill polygons.\n            extruded: Whether to render as 3D polygons.\n            wireframe: Whether to render wireframe.\n            elevation_scale: Elevation multiplier.\n            pickable: Whether layer responds to hover/click events.\n            opacity: Layer opacity (0-1).\n            **kwargs: Additional SolidPolygonLayer props.\n\n        Example:\n            &gt;&gt;&gt; from anymap_ts import MapLibreMap\n            &gt;&gt;&gt; m = MapLibreMap(pitch=45)\n            &gt;&gt;&gt; data = [\n            ...     {\"polygon\": [[-122.4, 37.8], [-122.5, 37.7], [-122.3, 37.7]], \"height\": 500},\n            ... ]\n            &gt;&gt;&gt; m.add_solid_polygon_layer(data, extruded=True, get_elevation=\"height\")\n        \"\"\"\n        layer_id = name or f\"solidpolygon-{len(self._layers)}\"\n        processed_data = self._process_deck_data(data)\n\n        self.call_js_method(\n            \"addSolidPolygonLayer\",\n            id=layer_id,\n            data=processed_data,\n            getPolygon=get_polygon,\n            getFillColor=get_fill_color or [51, 136, 255, 128],\n            getLineColor=get_line_color or [0, 0, 0, 255],\n            getElevation=get_elevation,\n            filled=filled,\n            extruded=extruded,\n            wireframe=wireframe,\n            elevationScale=elevation_scale,\n            pickable=pickable,\n            opacity=opacity,\n            **kwargs,\n        )\n\n        self._layers = {\n            **self._layers,\n            layer_id: {\"id\": layer_id, \"type\": \"solidpolygon\"},\n        }\n        self._add_to_layer_dict(layer_id, \"Deck.gl\")\n\n    # -------------------------------------------------------------------------\n    # Grid Cell Layer (deck.gl)\n    # -------------------------------------------------------------------------\n\n    def add_grid_cell_layer(\n        self,\n        data: Any,\n        name: Optional[str] = None,\n        get_position: Union[str, Any] = \"coordinates\",\n        get_color: Optional[Union[List[int], str]] = None,\n        get_elevation: Union[float, str] = 1000,\n        cell_size: float = 200,\n        coverage: float = 1,\n        elevation_scale: float = 1,\n        extruded: bool = True,\n        pickable: bool = True,\n        opacity: float = 0.8,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a grid cell layer for pre-aggregated grid visualization using deck.gl.\n\n        Args:\n            data: Array of data objects with position coordinates.\n            name: Layer ID. If None, auto-generated.\n            get_position: Accessor for cell position [lng, lat].\n            get_color: Accessor for cell color [r, g, b, a].\n            get_elevation: Accessor for cell height.\n            cell_size: Cell size in meters.\n            coverage: Cell coverage (0-1).\n            elevation_scale: Elevation multiplier.\n            extruded: Whether to extrude cells.\n            pickable: Whether layer responds to hover/click events.\n            opacity: Layer opacity (0-1).\n            **kwargs: Additional GridCellLayer props.\n\n        Example:\n            &gt;&gt;&gt; from anymap_ts import MapLibreMap\n            &gt;&gt;&gt; m = MapLibreMap(pitch=45)\n            &gt;&gt;&gt; data = [\n            ...     {\"coordinates\": [-122.4, 37.8], \"value\": 500},\n            ... ]\n            &gt;&gt;&gt; m.add_grid_cell_layer(data, get_elevation=\"value\")\n        \"\"\"\n        layer_id = name or f\"gridcell-{len(self._layers)}\"\n        processed_data = self._process_deck_data(data)\n\n        self.call_js_method(\n            \"addGridCellLayer\",\n            id=layer_id,\n            data=processed_data,\n            getPosition=get_position,\n            getColor=get_color or [255, 140, 0, 200],\n            getElevation=get_elevation,\n            cellSize=cell_size,\n            coverage=coverage,\n            elevationScale=elevation_scale,\n            extruded=extruded,\n            pickable=pickable,\n            opacity=opacity,\n            **kwargs,\n        )\n\n        self._layers = {\n            **self._layers,\n            layer_id: {\"id\": layer_id, \"type\": \"gridcell\"},\n        }\n        self._add_to_layer_dict(layer_id, \"Deck.gl\")\n\n    # -------------------------------------------------------------------------\n    # LiDAR Layers (maplibre-gl-lidar)\n    # -------------------------------------------------------------------------\n\n    def add_lidar_control(\n        self,\n        position: str = \"top-right\",\n        collapsed: bool = True,\n        title: str = \"LiDAR Viewer\",\n        point_size: float = 2,\n        opacity: float = 1.0,\n        color_scheme: str = \"elevation\",\n        use_percentile: bool = True,\n        point_budget: int = 1000000,\n        pickable: bool = False,\n        auto_zoom: bool = True,\n        copc_loading_mode: Optional[str] = None,\n        streaming_point_budget: int = 5000000,\n        panel_max_height: int = 600,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add an interactive LiDAR control panel.\n\n        The LiDAR control provides a UI panel for loading, visualizing, and\n        styling LiDAR point cloud files (LAS, LAZ, COPC formats).\n\n        Args:\n            position: Control position ('top-left', 'top-right', 'bottom-left', 'bottom-right').\n            collapsed: Whether the panel starts collapsed.\n            title: Title displayed on the panel.\n            point_size: Point size in pixels.\n            opacity: Layer opacity (0-1).\n            color_scheme: Color scheme ('elevation', 'intensity', 'classification', 'rgb').\n            use_percentile: Use 2-98% percentile for color scaling.\n            point_budget: Maximum number of points to display.\n            pickable: Enable hover/click interactions.\n            auto_zoom: Auto-zoom to point cloud after loading.\n            copc_loading_mode: COPC loading mode ('full' or 'dynamic').\n            streaming_point_budget: Point budget for streaming mode.\n            panel_max_height: Maximum height of the panel in pixels.\n            **kwargs: Additional control options.\n\n        Example:\n            &gt;&gt;&gt; from anymap_ts import MapLibreMap\n            &gt;&gt;&gt; m = MapLibreMap(pitch=60)\n            &gt;&gt;&gt; m.add_lidar_control(color_scheme=\"classification\", pickable=True)\n        \"\"\"\n        self.call_js_method(\n            \"addLidarControl\",\n            position=position,\n            collapsed=collapsed,\n            title=title,\n            pointSize=point_size,\n            opacity=opacity,\n            colorScheme=color_scheme,\n            usePercentile=use_percentile,\n            pointBudget=point_budget,\n            pickable=pickable,\n            autoZoom=auto_zoom,\n            copcLoadingMode=copc_loading_mode,\n            streamingPointBudget=streaming_point_budget,\n            panelMaxHeight=panel_max_height,\n            **kwargs,\n        )\n        self._controls = {\n            **self._controls,\n            \"lidar-control\": {\"position\": position, \"collapsed\": collapsed},\n        }\n\n    def add_lidar_layer(\n        self,\n        source: Union[str, Path],\n        name: Optional[str] = None,\n        color_scheme: str = \"elevation\",\n        point_size: float = 2,\n        opacity: float = 1.0,\n        pickable: bool = True,\n        auto_zoom: bool = True,\n        streaming_mode: bool = True,\n        point_budget: int = 1000000,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Load and display a LiDAR file from URL or local path.\n\n        Supports LAS, LAZ, and COPC (Cloud-Optimized Point Cloud) formats.\n        For local files, the file is read and sent as base64 to JavaScript.\n        For URLs, the data is loaded directly via streaming when possible.\n\n        Args:\n            source: URL or local file path to the LiDAR file.\n            name: Layer identifier. If None, auto-generated.\n            color_scheme: Color scheme ('elevation', 'intensity', 'classification', 'rgb').\n            point_size: Point size in pixels.\n            opacity: Layer opacity (0-1).\n            pickable: Enable hover/click interactions.\n            auto_zoom: Auto-zoom to point cloud after loading.\n            streaming_mode: Use streaming mode for large COPC files.\n            point_budget: Maximum number of points to display.\n            **kwargs: Additional layer options.\n\n        Example:\n            &gt;&gt;&gt; from anymap_ts import MapLibreMap\n            &gt;&gt;&gt; m = MapLibreMap(center=[-123.07, 44.05], zoom=14, pitch=60)\n            &gt;&gt;&gt; m.add_lidar_layer(\n            ...     source=\"https://s3.amazonaws.com/hobu-lidar/autzen-classified.copc.laz\",\n            ...     name=\"autzen\",\n            ...     color_scheme=\"classification\",\n            ... )\n        \"\"\"\n        layer_id = name or f\"lidar-{len(self._layers)}\"\n\n        # Check if source is a local file\n        source_path = Path(source) if isinstance(source, (str, Path)) else None\n        is_local = source_path is not None and source_path.exists()\n\n        if is_local:\n            # Read local file and encode as base64\n            import base64\n\n            with open(source_path, \"rb\") as f:\n                file_data = f.read()\n            source_b64 = base64.b64encode(file_data).decode(\"utf-8\")\n\n            self.call_js_method(\n                \"addLidarLayer\",\n                source=source_b64,\n                name=layer_id,\n                isBase64=True,\n                filename=source_path.name,\n                colorScheme=color_scheme,\n                pointSize=point_size,\n                opacity=opacity,\n                pickable=pickable,\n                autoZoom=auto_zoom,\n                streamingMode=streaming_mode,\n                pointBudget=point_budget,\n                **kwargs,\n            )\n        else:\n            # Load from URL\n            self.call_js_method(\n                \"addLidarLayer\",\n                source=str(source),\n                name=layer_id,\n                isBase64=False,\n                colorScheme=color_scheme,\n                pointSize=point_size,\n                opacity=opacity,\n                pickable=pickable,\n                autoZoom=auto_zoom,\n                streamingMode=streaming_mode,\n                pointBudget=point_budget,\n                **kwargs,\n            )\n\n        self._layers = {\n            **self._layers,\n            layer_id: {\n                \"id\": layer_id,\n                \"type\": \"lidar\",\n                \"source\": str(source),\n            },\n        }\n        self._add_to_layer_dict(layer_id, \"LiDAR\")\n\n    def remove_lidar_layer(self, layer_id: Optional[str] = None) -&gt; None:\n        \"\"\"Remove a LiDAR layer.\n\n        Args:\n            layer_id: Layer identifier to remove. If None, removes all LiDAR layers.\n        \"\"\"\n        if layer_id:\n            if layer_id in self._layers:\n                layers = dict(self._layers)\n                del layers[layer_id]\n                self._layers = layers\n            self.call_js_method(\"removeLidarLayer\", id=layer_id)\n        else:\n            # Remove all lidar layers\n            layers = dict(self._layers)\n            self._layers = {k: v for k, v in layers.items() if v.get(\"type\") != \"lidar\"}\n            self.call_js_method(\"removeLidarLayer\")\n\n    def set_lidar_color_scheme(self, color_scheme: str) -&gt; None:\n        \"\"\"Set the LiDAR color scheme.\n\n        Args:\n            color_scheme: Color scheme ('elevation', 'intensity', 'classification', 'rgb').\n        \"\"\"\n        self.call_js_method(\"setLidarColorScheme\", colorScheme=color_scheme)\n\n    def set_lidar_point_size(self, point_size: float) -&gt; None:\n        \"\"\"Set the LiDAR point size.\n\n        Args:\n            point_size: Point size in pixels.\n        \"\"\"\n        self.call_js_method(\"setLidarPointSize\", pointSize=point_size)\n\n    def set_lidar_opacity(self, opacity: float) -&gt; None:\n        \"\"\"Set the LiDAR layer opacity.\n\n        Args:\n            opacity: Opacity value between 0 and 1.\n        \"\"\"\n        self.call_js_method(\"setLidarOpacity\", opacity=opacity)\n\n    # -------------------------------------------------------------------------\n    # maplibre-gl-components UI Controls\n    # -------------------------------------------------------------------------\n\n    def add_pmtiles_control(\n        self,\n        position: str = \"top-right\",\n        collapsed: bool = True,\n        default_url: Optional[str] = None,\n        load_default_url: bool = False,\n        default_opacity: float = 1.0,\n        default_fill_color: str = \"steelblue\",\n        default_line_color: str = \"#333\",\n        default_pickable: bool = True,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a PMTiles layer control for loading PMTiles files via UI.\n\n        This provides an interactive panel for users to enter PMTiles URLs\n        and visualize vector or raster tile data.\n\n        Args:\n            position: Control position ('top-left', 'top-right', 'bottom-left', 'bottom-right').\n            collapsed: Whether the panel starts collapsed.\n            default_url: Default PMTiles URL to pre-fill.\n            load_default_url: Whether to auto-load the default URL.\n            default_opacity: Default layer opacity (0-1).\n            default_fill_color: Default fill color for vector polygons.\n            default_line_color: Default line color for vector lines.\n            default_pickable: Whether features are clickable by default.\n            **kwargs: Additional control options.\n\n        Example:\n            &gt;&gt;&gt; from anymap_ts import MapLibreMap\n            &gt;&gt;&gt; m = MapLibreMap()\n            &gt;&gt;&gt; m.add_pmtiles_control(\n            ...     default_url=\"https://pmtiles.io/protomaps(vector)ODbL_firenze.pmtiles\",\n            ...     load_default_url=True\n            ... )\n        \"\"\"\n        self.call_js_method(\n            \"addPMTilesControl\",\n            position=position,\n            collapsed=collapsed,\n            defaultUrl=default_url or \"\",\n            loadDefaultUrl=load_default_url,\n            defaultOpacity=default_opacity,\n            defaultFillColor=default_fill_color,\n            defaultLineColor=default_line_color,\n            defaultPickable=default_pickable,\n            **kwargs,\n        )\n        self._controls = {\n            **self._controls,\n            \"pmtiles-control\": {\"position\": position, \"collapsed\": collapsed},\n        }\n\n    def add_cog_control(\n        self,\n        position: str = \"top-right\",\n        collapsed: bool = True,\n        default_url: Optional[str] = None,\n        load_default_url: bool = False,\n        default_opacity: float = 1.0,\n        default_colormap: str = \"viridis\",\n        default_bands: str = \"1\",\n        default_rescale_min: float = 0,\n        default_rescale_max: float = 255,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a COG layer control for loading Cloud Optimized GeoTIFFs via UI.\n\n        This provides an interactive panel for users to enter COG URLs\n        and configure visualization parameters like colormap and rescaling.\n\n        Args:\n            position: Control position ('top-left', 'top-right', 'bottom-left', 'bottom-right').\n            collapsed: Whether the panel starts collapsed.\n            default_url: Default COG URL to pre-fill.\n            load_default_url: Whether to auto-load the default URL.\n            default_opacity: Default layer opacity (0-1).\n            default_colormap: Default colormap name.\n            default_bands: Default bands (e.g., '1' or '1,2,3').\n            default_rescale_min: Default minimum value for rescaling.\n            default_rescale_max: Default maximum value for rescaling.\n            **kwargs: Additional control options.\n\n        Example:\n            &gt;&gt;&gt; from anymap_ts import MapLibreMap\n            &gt;&gt;&gt; m = MapLibreMap()\n            &gt;&gt;&gt; m.add_cog_control(\n            ...     default_url=\"https://example.com/cog.tif\",\n            ...     default_colormap=\"terrain\"\n            ... )\n        \"\"\"\n        self.call_js_method(\n            \"addCogControl\",\n            position=position,\n            collapsed=collapsed,\n            defaultUrl=default_url or \"\",\n            loadDefaultUrl=load_default_url,\n            defaultOpacity=default_opacity,\n            defaultColormap=default_colormap,\n            defaultBands=default_bands,\n            defaultRescaleMin=default_rescale_min,\n            defaultRescaleMax=default_rescale_max,\n            **kwargs,\n        )\n        self._controls = {\n            **self._controls,\n            \"cog-control\": {\"position\": position, \"collapsed\": collapsed},\n        }\n\n    def add_zarr_control(\n        self,\n        position: str = \"top-right\",\n        collapsed: bool = True,\n        default_url: Optional[str] = None,\n        load_default_url: bool = False,\n        default_opacity: float = 1.0,\n        default_variable: str = \"\",\n        default_clim: Optional[Tuple[float, float]] = None,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a Zarr layer control for loading Zarr datasets via UI.\n\n        This provides an interactive panel for users to enter Zarr URLs\n        and configure visualization parameters.\n\n        Args:\n            position: Control position ('top-left', 'top-right', 'bottom-left', 'bottom-right').\n            collapsed: Whether the panel starts collapsed.\n            default_url: Default Zarr URL to pre-fill.\n            load_default_url: Whether to auto-load the default URL.\n            default_opacity: Default layer opacity (0-1).\n            default_variable: Default variable name.\n            default_clim: Default color limits (min, max).\n            **kwargs: Additional control options.\n\n        Example:\n            &gt;&gt;&gt; from anymap_ts import MapLibreMap\n            &gt;&gt;&gt; m = MapLibreMap()\n            &gt;&gt;&gt; m.add_zarr_control(\n            ...     default_url=\"https://example.com/data.zarr\",\n            ...     default_variable=\"temperature\"\n            ... )\n        \"\"\"\n        self.call_js_method(\n            \"addZarrControl\",\n            position=position,\n            collapsed=collapsed,\n            defaultUrl=default_url or \"\",\n            loadDefaultUrl=load_default_url,\n            defaultOpacity=default_opacity,\n            defaultVariable=default_variable,\n            defaultClim=list(default_clim) if default_clim else [0, 1],\n            **kwargs,\n        )\n        self._controls = {\n            **self._controls,\n            \"zarr-control\": {\"position\": position, \"collapsed\": collapsed},\n        }\n\n    def add_vector_control(\n        self,\n        position: str = \"top-right\",\n        collapsed: bool = True,\n        default_url: Optional[str] = None,\n        load_default_url: bool = False,\n        default_opacity: float = 1.0,\n        default_fill_color: str = \"#3388ff\",\n        default_stroke_color: str = \"#3388ff\",\n        fit_bounds: bool = True,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a vector layer control for loading vector datasets from URLs.\n\n        This provides an interactive panel for users to enter URLs to\n        GeoJSON, GeoParquet, or FlatGeobuf datasets.\n\n        Args:\n            position: Control position ('top-left', 'top-right', 'bottom-left', 'bottom-right').\n            collapsed: Whether the panel starts collapsed.\n            default_url: Default vector URL to pre-fill.\n            load_default_url: Whether to auto-load the default URL.\n            default_opacity: Default layer opacity (0-1).\n            default_fill_color: Default fill color for polygons.\n            default_stroke_color: Default stroke color for lines/outlines.\n            fit_bounds: Whether to fit map to loaded data bounds.\n            **kwargs: Additional control options.\n\n        Example:\n            &gt;&gt;&gt; from anymap_ts import MapLibreMap\n            &gt;&gt;&gt; m = MapLibreMap()\n            &gt;&gt;&gt; m.add_vector_control(\n            ...     default_url=\"https://example.com/data.geojson\",\n            ...     default_fill_color=\"#ff0000\"\n            ... )\n        \"\"\"\n        self.call_js_method(\n            \"addVectorControl\",\n            position=position,\n            collapsed=collapsed,\n            defaultUrl=default_url or \"\",\n            loadDefaultUrl=load_default_url,\n            defaultOpacity=default_opacity,\n            defaultFillColor=default_fill_color,\n            defaultStrokeColor=default_stroke_color,\n            fitBounds=fit_bounds,\n            **kwargs,\n        )\n        self._controls = {\n            **self._controls,\n            \"vector-control\": {\"position\": position, \"collapsed\": collapsed},\n        }\n\n    def add_control_grid(\n        self,\n        position: str = \"top-right\",\n        default_controls: Optional[List[str]] = None,\n        exclude: Optional[List[str]] = None,\n        rows: Optional[int] = None,\n        columns: Optional[int] = None,\n        collapsed: bool = True,\n        collapsible: bool = True,\n        title: str = \"\",\n        show_row_column_controls: bool = True,\n        gap: int = 2,\n        basemap_style_url: Optional[str] = None,\n        exclude_layers: Optional[List[str]] = None,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a ControlGrid with all default tools or a custom subset.\n\n        The ControlGrid provides a collapsible toolbar with up to 26 built-in\n        controls (search, basemap, terrain, measure, draw, etc.) in a\n        configurable grid layout.\n\n        Args:\n            position: Control position ('top-left', 'top-right', 'bottom-left',\n                'bottom-right').\n            default_controls: Explicit list of control names to include. If None,\n                all 26 default controls are used (minus any in ``exclude``).\n                Valid names: 'globe', 'fullscreen', 'north', 'terrain', 'search',\n                'viewState', 'inspect', 'vectorDataset', 'basemap', 'measure',\n                'geoEditor', 'bookmark', 'print', 'minimap', 'swipe',\n                'streetView', 'addVector', 'cogLayer', 'zarrLayer',\n                'pmtilesLayer', 'stacLayer', 'stacSearch', 'planetaryComputer',\n                'gaussianSplat', 'lidar', 'usgsLidar'.\n            exclude: Controls to remove from the default set. Ignored when\n                ``default_controls`` is provided.\n            rows: Number of grid rows (auto-calculated if None).\n            columns: Number of grid columns (auto-calculated if None).\n            collapsed: Whether the grid starts collapsed. Default True.\n            collapsible: Whether the grid can be collapsed. Default True.\n            title: Optional header title for the grid.\n            show_row_column_controls: Show row/column input fields. Default True.\n            gap: Gap between grid cells in pixels. Default 2.\n            basemap_style_url: Basemap style URL for SwipeControl layer grouping.\n                If None, the current map style is used automatically.\n            exclude_layers: Layer ID patterns to exclude from SwipeControl\n                (e.g., 'measure-*', 'gl-draw-*'). If None, sensible defaults\n                are applied.\n            **kwargs: Additional ControlGrid options.\n\n        Example:\n            &gt;&gt;&gt; from anymap_ts import MapLibreMap\n            &gt;&gt;&gt; m = MapLibreMap()\n            &gt;&gt;&gt; m.add_control_grid()  # All 26 controls\n            &gt;&gt;&gt; # Or with customization:\n            &gt;&gt;&gt; m.add_control_grid(\n            ...     exclude=[\"minimap\", \"streetView\"],\n            ...     collapsed=True,\n            ... )\n        \"\"\"\n        js_kwargs: Dict[str, Any] = {\n            \"position\": position,\n            \"collapsed\": collapsed,\n            \"collapsible\": collapsible,\n            \"showRowColumnControls\": show_row_column_controls,\n            \"gap\": gap,\n            **kwargs,\n        }\n        if default_controls is not None:\n            js_kwargs[\"defaultControls\"] = default_controls\n        if exclude is not None:\n            js_kwargs[\"exclude\"] = exclude\n        if rows is not None:\n            js_kwargs[\"rows\"] = rows\n        if columns is not None:\n            js_kwargs[\"columns\"] = columns\n        if title:\n            js_kwargs[\"title\"] = title\n        if basemap_style_url is not None:\n            js_kwargs[\"basemapStyleUrl\"] = basemap_style_url\n        if exclude_layers is not None:\n            js_kwargs[\"excludeLayers\"] = exclude_layers\n\n        self.call_js_method(\"addControlGrid\", **js_kwargs)\n        # Save full config for HTML export\n        control_config = {\n            \"position\": position,\n            \"collapsed\": collapsed,\n            \"collapsible\": collapsible,\n        }\n        if default_controls is not None:\n            control_config[\"defaultControls\"] = default_controls\n        if exclude is not None:\n            control_config[\"exclude\"] = exclude\n        if rows is not None:\n            control_config[\"rows\"] = rows\n        if columns is not None:\n            control_config[\"columns\"] = columns\n        self._controls = {\n            **self._controls,\n            \"control-grid\": control_config,\n        }\n\n    # -------------------------------------------------------------------------\n    # Colorbar\n    # -------------------------------------------------------------------------\n\n    def add_colorbar(\n        self,\n        colormap: str = \"viridis\",\n        vmin: float = 0,\n        vmax: float = 1,\n        label: str = \"\",\n        units: str = \"\",\n        orientation: str = \"horizontal\",\n        position: str = \"bottom-right\",\n        bar_thickness: Optional[int] = None,\n        bar_length: Optional[int] = None,\n        ticks: Optional[Dict] = None,\n        opacity: Optional[float] = None,\n        colorbar_id: Optional[str] = None,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a continuous gradient colorbar to the map.\n\n        Displays a color gradient legend with customizable colormaps,\n        tick marks, labels, and positioning using maplibre-gl-components.\n\n        Args:\n            colormap: Colormap name (e.g., 'viridis', 'plasma', 'inferno',\n                'magma', 'cividis', 'coolwarm', 'jet', 'terrain', etc.).\n            vmin: Minimum value for the colorbar scale.\n            vmax: Maximum value for the colorbar scale.\n            label: Title/label displayed above or beside the colorbar.\n            units: Unit string displayed after values (e.g., '\u00b0C', 'm').\n            orientation: Orientation of the colorbar ('horizontal' or 'vertical').\n            position: Control position ('top-left', 'top-right',\n                'bottom-left', 'bottom-right').\n            bar_thickness: Width/height of the gradient bar in pixels.\n            bar_length: Length of the colorbar in pixels.\n            ticks: Tick configuration dict (e.g., {'count': 5, 'precision': 2}).\n            opacity: Opacity of the colorbar container (0-1).\n            colorbar_id: Unique identifier. If None, auto-generated.\n            **kwargs: Additional Colorbar options.\n\n        Example:\n            &gt;&gt;&gt; m = Map()\n            &gt;&gt;&gt; m.add_cog_layer(\"https://example.com/dem.tif\")\n            &gt;&gt;&gt; m.add_colorbar(\n            ...     colormap=\"terrain\",\n            ...     vmin=0,\n            ...     vmax=4000,\n            ...     label=\"Elevation\",\n            ...     units=\"m\",\n            ... )\n        \"\"\"\n        self._validate_position(position)\n\n        cbar_id = (\n            colorbar_id\n            or f\"colorbar-{len([k for k in self._controls.keys() if k.startswith('colorbar')])}\"\n        )\n\n        js_kwargs: Dict[str, Any] = {\n            \"colormap\": colormap,\n            \"vmin\": vmin,\n            \"vmax\": vmax,\n            \"label\": label,\n            \"units\": units,\n            \"orientation\": orientation,\n            \"position\": position,\n            \"colorbarId\": cbar_id,\n            **kwargs,\n        }\n        if bar_thickness is not None:\n            js_kwargs[\"barThickness\"] = bar_thickness\n        if bar_length is not None:\n            js_kwargs[\"barLength\"] = bar_length\n        if ticks is not None:\n            js_kwargs[\"ticks\"] = ticks\n        if opacity is not None:\n            js_kwargs[\"opacity\"] = opacity\n\n        self.call_js_method(\"addColorbar\", **js_kwargs)\n\n        self._controls = {\n            **self._controls,\n            cbar_id: {\n                \"type\": \"colorbar\",\n                \"colormap\": colormap,\n                \"vmin\": vmin,\n                \"vmax\": vmax,\n                \"label\": label,\n                \"units\": units,\n                \"orientation\": orientation,\n                \"position\": position,\n            },\n        }\n\n    def remove_colorbar(self, colorbar_id: Optional[str] = None) -&gt; None:\n        \"\"\"Remove a colorbar from the map.\n\n        Args:\n            colorbar_id: Colorbar identifier to remove. If None, removes\n                all colorbars.\n        \"\"\"\n        if colorbar_id is None:\n            cbar_keys = [k for k in self._controls.keys() if k.startswith(\"colorbar\")]\n            for key in cbar_keys:\n                self.call_js_method(\"removeColorbar\", colorbarId=key)\n            self._controls = {\n                k: v for k, v in self._controls.items() if not k.startswith(\"colorbar\")\n            }\n        else:\n            self.call_js_method(\"removeColorbar\", colorbarId=colorbar_id)\n            if colorbar_id in self._controls:\n                controls = dict(self._controls)\n                del controls[colorbar_id]\n                self._controls = controls\n\n    def update_colorbar(self, colorbar_id: Optional[str] = None, **kwargs) -&gt; None:\n        \"\"\"Update an existing colorbar's properties.\n\n        Args:\n            colorbar_id: Colorbar identifier to update. If None, updates\n                the first colorbar found.\n            **kwargs: Properties to update (colormap, vmin, vmax, label,\n                units, orientation, bar_thickness, bar_length, ticks, opacity).\n        \"\"\"\n        if colorbar_id is None:\n            cbar_keys = [k for k in self._controls.keys() if k.startswith(\"colorbar\")]\n            if not cbar_keys:\n                raise ValueError(\"No colorbar found to update\")\n            colorbar_id = cbar_keys[0]\n\n        if colorbar_id not in self._controls:\n            raise ValueError(f\"Colorbar '{colorbar_id}' not found\")\n\n        js_kwargs: Dict[str, Any] = {\"colorbarId\": colorbar_id}\n        key_map = {\n            \"bar_thickness\": \"barThickness\",\n            \"bar_length\": \"barLength\",\n        }\n        for key, value in kwargs.items():\n            js_key = key_map.get(key, key)\n            js_kwargs[js_key] = value\n\n        self.call_js_method(\"updateColorbar\", **js_kwargs)\n\n        for key, value in kwargs.items():\n            if key in self._controls.get(colorbar_id, {}):\n                self._controls[colorbar_id][key] = value\n\n    # -------------------------------------------------------------------------\n    # Search / Geocoder Control\n    # -------------------------------------------------------------------------\n\n    def add_search_control(\n        self,\n        position: str = \"top-left\",\n        placeholder: str = \"Search places...\",\n        collapsed: bool = True,\n        fly_to_zoom: int = 14,\n        show_marker: bool = True,\n        marker_color: str = \"#4264fb\",\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a search/geocoder control using Nominatim.\n\n        Provides place search functionality with autocomplete results.\n        Results are geocoded via OpenStreetMap Nominatim service.\n\n        Args:\n            position: Control position ('top-left', 'top-right',\n                'bottom-left', 'bottom-right').\n            placeholder: Placeholder text for the search input.\n            collapsed: Whether the control starts collapsed (icon only).\n            fly_to_zoom: Zoom level to fly to when selecting a result.\n            show_marker: Whether to add a marker at the selected location.\n            marker_color: Color of the result marker.\n            **kwargs: Additional SearchControl options.\n\n        Example:\n            &gt;&gt;&gt; m = Map()\n            &gt;&gt;&gt; m.add_search_control(position=\"top-left\", fly_to_zoom=12)\n        \"\"\"\n        self._validate_position(position)\n        self.call_js_method(\n            \"addSearchControl\",\n            position=position,\n            placeholder=placeholder,\n            collapsed=collapsed,\n            flyToZoom=fly_to_zoom,\n            showMarker=show_marker,\n            markerColor=marker_color,\n            **kwargs,\n        )\n        self._controls = {\n            **self._controls,\n            \"search-control\": {\n                \"type\": \"search-control\",\n                \"position\": position,\n                \"collapsed\": collapsed,\n            },\n        }\n\n    def remove_search_control(self) -&gt; None:\n        \"\"\"Remove the search/geocoder control from the map.\"\"\"\n        self.call_js_method(\"removeSearchControl\")\n        if \"search-control\" in self._controls:\n            controls = dict(self._controls)\n            del controls[\"search-control\"]\n            self._controls = controls\n\n    # -------------------------------------------------------------------------\n    # Measurement Tools\n    # -------------------------------------------------------------------------\n\n    def add_measure_control(\n        self,\n        position: str = \"top-right\",\n        collapsed: bool = True,\n        default_mode: str = \"distance\",\n        distance_unit: str = \"kilometers\",\n        area_unit: str = \"square-kilometers\",\n        line_color: str = \"#3b82f6\",\n        fill_color: str = \"rgba(59, 130, 246, 0.2)\",\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a measurement control for distances and areas.\n\n        Provides tools for measuring distances (polylines) and areas\n        (polygons) interactively on the map.\n\n        Args:\n            position: Control position ('top-left', 'top-right',\n                'bottom-left', 'bottom-right').\n            collapsed: Whether the control starts collapsed.\n            default_mode: Default measurement mode ('distance' or 'area').\n            distance_unit: Distance unit ('kilometers', 'miles', 'meters',\n                'feet', 'nautical-miles').\n            area_unit: Area unit ('square-kilometers', 'square-miles',\n                'square-meters', 'hectares', 'acres').\n            line_color: Line color for distance measurements.\n            fill_color: Fill color for area measurements.\n            **kwargs: Additional MeasureControl options.\n\n        Example:\n            &gt;&gt;&gt; m = Map()\n            &gt;&gt;&gt; m.add_measure_control(\n            ...     default_mode=\"distance\",\n            ...     distance_unit=\"miles\",\n            ... )\n        \"\"\"\n        self._validate_position(position)\n        self.call_js_method(\n            \"addMeasureControl\",\n            position=position,\n            collapsed=collapsed,\n            defaultMode=default_mode,\n            distanceUnit=distance_unit,\n            areaUnit=area_unit,\n            lineColor=line_color,\n            fillColor=fill_color,\n            **kwargs,\n        )\n        self._controls = {\n            **self._controls,\n            \"measure-control\": {\n                \"type\": \"measure-control\",\n                \"position\": position,\n                \"collapsed\": collapsed,\n            },\n        }\n\n    def remove_measure_control(self) -&gt; None:\n        \"\"\"Remove the measurement control from the map.\"\"\"\n        self.call_js_method(\"removeMeasureControl\")\n        if \"measure-control\" in self._controls:\n            controls = dict(self._controls)\n            del controls[\"measure-control\"]\n            self._controls = controls\n\n    # -------------------------------------------------------------------------\n    # Print / Export Control\n    # -------------------------------------------------------------------------\n\n    def add_print_control(\n        self,\n        position: str = \"top-right\",\n        collapsed: bool = True,\n        format: str = \"png\",\n        filename: str = \"map-export\",\n        include_north_arrow: bool = False,\n        include_scale_bar: bool = False,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a print/export control for saving the map as an image.\n\n        Provides an interactive panel for exporting the current map view\n        as PNG, JPEG, or PDF files.\n\n        Args:\n            position: Control position ('top-left', 'top-right',\n                'bottom-left', 'bottom-right').\n            collapsed: Whether the control starts collapsed.\n            format: Default image format ('png', 'jpeg', 'pdf').\n            filename: Default filename (without extension).\n            include_north_arrow: Whether to include a north arrow by default.\n            include_scale_bar: Whether to include a scale bar by default.\n            **kwargs: Additional PrintControl options.\n\n        Example:\n            &gt;&gt;&gt; m = Map()\n            &gt;&gt;&gt; m.add_print_control(\n            ...     format=\"png\",\n            ...     filename=\"my-map\",\n            ...     include_scale_bar=True,\n            ... )\n        \"\"\"\n        self._validate_position(position)\n        self.call_js_method(\n            \"addPrintControl\",\n            position=position,\n            collapsed=collapsed,\n            format=format,\n            filename=filename,\n            includeNorthArrow=include_north_arrow,\n            includeScaleBar=include_scale_bar,\n            **kwargs,\n        )\n        self._controls = {\n            **self._controls,\n            \"print-control\": {\n                \"type\": \"print-control\",\n                \"position\": position,\n                \"collapsed\": collapsed,\n            },\n        }\n\n    def remove_print_control(self) -&gt; None:\n        \"\"\"Remove the print/export control from the map.\"\"\"\n        self.call_js_method(\"removePrintControl\")\n        if \"print-control\" in self._controls:\n            controls = dict(self._controls)\n            del controls[\"print-control\"]\n            self._controls = controls\n\n    # -------------------------------------------------------------------------\n    # FlatGeobuf Layer\n    # -------------------------------------------------------------------------\n\n    def add_flatgeobuf(\n        self,\n        url: str,\n        name: Optional[str] = None,\n        layer_type: Optional[str] = None,\n        paint: Optional[Dict] = None,\n        fit_bounds: bool = True,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a FlatGeobuf layer from a URL.\n\n        Streams and renders cloud-native FlatGeobuf vector data directly\n        in the browser without downloading the entire file.\n\n        Args:\n            url: URL to the FlatGeobuf file.\n            name: Layer name. If None, auto-generated.\n            layer_type: MapLibre layer type ('circle', 'line', 'fill').\n                If None, inferred from geometry type.\n            paint: MapLibre paint properties. If None, defaults are used.\n            fit_bounds: Whether to fit map to data bounds.\n            **kwargs: Additional layer options.\n\n        Example:\n            &gt;&gt;&gt; m = Map()\n            &gt;&gt;&gt; m.add_flatgeobuf(\n            ...     \"https://flatgeobuf.org/test/data/UScounties.fgb\",\n            ...     name=\"counties\",\n            ...     paint={\"fill-color\": \"#088\", \"fill-opacity\": 0.5},\n            ... )\n        \"\"\"\n        layer_id = name or f\"flatgeobuf-{len(self._layers)}\"\n\n        self.call_js_method(\n            \"addFlatGeobuf\",\n            url=url,\n            name=layer_id,\n            layerType=layer_type,\n            paint=paint,\n            fitBounds=fit_bounds,\n            **kwargs,\n        )\n\n        self._layers = {\n            **self._layers,\n            layer_id: {\n                \"id\": layer_id,\n                \"type\": \"flatgeobuf\",\n                \"url\": url,\n            },\n        }\n        self._add_to_layer_dict(layer_id, \"Vector\")\n\n    def remove_flatgeobuf(self, name: str) -&gt; None:\n        \"\"\"Remove a FlatGeobuf layer from the map.\n\n        Args:\n            name: The layer identifier to remove.\n        \"\"\"\n        if name in self._layers:\n            layers = dict(self._layers)\n            del layers[name]\n            self._layers = layers\n        self._remove_from_layer_dict(name)\n        self.call_js_method(\"removeFlatGeobuf\", name=name)\n\n    def _process_deck_data(self, data: Any) -&gt; Any:\n        \"\"\"Process data for deck.gl layers.\n\n        Handles GeoDataFrame, file paths, GeoJSON, and list of dicts.\n\n        Args:\n            data: Input data in various formats.\n\n        Returns:\n            Processed data suitable for deck.gl layers.\n        \"\"\"\n        # Handle GeoDataFrame\n        if hasattr(data, \"__geo_interface__\"):\n            return data.__geo_interface__\n\n        # Handle file paths\n        if isinstance(data, (str, Path)):\n            path = Path(data)\n            if path.exists():\n                try:\n                    import geopandas as gpd\n\n                    gdf = gpd.read_file(path)\n                    return gdf.__geo_interface__\n                except ImportError:\n                    pass\n\n        # Return as-is for lists, dicts, etc.\n        return data\n\n    # -------------------------------------------------------------------------\n    # Layer Management\n    # -------------------------------------------------------------------------\n\n    def add_layer(\n        self,\n        layer_id: str,\n        layer_type: str,\n        source: Union[str, Dict],\n        paint: Optional[Dict] = None,\n        layout: Optional[Dict] = None,\n        before_id: Optional[str] = None,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a generic layer to the map.\n\n        Args:\n            layer_id: Unique layer identifier\n            layer_type: MapLibre layer type\n            source: Source ID or source configuration dict\n            paint: Paint properties\n            layout: Layout properties\n            before_id: ID of layer to insert before\n            **kwargs: Additional layer options\n        \"\"\"\n        layer_config = {\n            \"id\": layer_id,\n            \"type\": layer_type,\n            \"paint\": paint or {},\n            \"layout\": layout or {},\n            **kwargs,\n        }\n\n        if isinstance(source, str):\n            layer_config[\"source\"] = source\n        else:\n            source_id = f\"{layer_id}-source\"\n            self._sources = {**self._sources, source_id: source}\n            self.call_js_method(\"addSource\", source_id, **source)\n            layer_config[\"source\"] = source_id\n\n        self._layers = {**self._layers, layer_id: layer_config}\n        self.call_js_method(\"addLayer\", beforeId=before_id, **layer_config)\n        # Determine category based on layer type\n        layer_type = layer_config.get(\"type\", \"\")\n        if layer_type == \"raster\":\n            self._add_to_layer_dict(layer_id, \"Raster\")\n        else:\n            self._add_to_layer_dict(layer_id, \"Vector\")\n\n    def remove_layer(self, layer_id: str) -&gt; None:\n        \"\"\"Remove a layer from the map.\n\n        Args:\n            layer_id: Layer identifier to remove\n        \"\"\"\n        if layer_id in self._layers:\n            layers = dict(self._layers)\n            del layers[layer_id]\n            self._layers = layers\n        self._remove_from_layer_dict(layer_id)\n        self.call_js_method(\"removeLayer\", layer_id)\n\n    def set_visibility(self, layer_id: str, visible: bool) -&gt; None:\n        \"\"\"Set layer visibility.\n\n        Args:\n            layer_id: Layer identifier\n            visible: Whether layer should be visible\n        \"\"\"\n        self.call_js_method(\"setVisibility\", layer_id, visible)\n\n    def set_opacity(self, layer_id: str, opacity: float) -&gt; None:\n        \"\"\"Set layer opacity.\n\n        Args:\n            layer_id: Layer identifier\n            opacity: Opacity value between 0 and 1\n        \"\"\"\n        self._validate_opacity(opacity)\n        self.call_js_method(\"setOpacity\", layer_id, opacity)\n\n    def set_paint_property(self, layer_id: str, property_name: str, value: Any) -&gt; None:\n        \"\"\"Set a paint property for a layer.\n\n        Args:\n            layer_id: Layer identifier.\n            property_name: Name of the paint property (e.g., 'fill-color').\n            value: New value for the property.\n\n        Example:\n            &gt;&gt;&gt; m.set_paint_property(\"my-layer\", \"fill-color\", \"#ff0000\")\n            &gt;&gt;&gt; m.set_paint_property(\"my-layer\", \"fill-opacity\", 0.5)\n        \"\"\"\n        self.call_js_method(\"setPaintProperty\", layer_id, property_name, value)\n\n    def set_layout_property(\n        self, layer_id: str, property_name: str, value: Any\n    ) -&gt; None:\n        \"\"\"Set a layout property for a layer.\n\n        Args:\n            layer_id: Layer identifier.\n            property_name: Name of the layout property (e.g., 'visibility').\n            value: New value for the property.\n\n        Example:\n            &gt;&gt;&gt; m.set_layout_property(\"my-layer\", \"visibility\", \"none\")\n        \"\"\"\n        self.call_js_method(\"setLayoutProperty\", layer_id, property_name, value)\n\n    def move_layer(self, layer_id: str, before_id: Optional[str] = None) -&gt; None:\n        \"\"\"Move a layer in the layer stack.\n\n        Args:\n            layer_id: Layer identifier to move.\n            before_id: ID of layer to move before. If None, moves to top.\n\n        Example:\n            &gt;&gt;&gt; m.move_layer(\"my-layer\", \"other-layer\")  # Move before other-layer\n            &gt;&gt;&gt; m.move_layer(\"my-layer\")  # Move to top\n        \"\"\"\n        self.call_js_method(\"moveLayer\", layer_id, before_id)\n\n    def get_layer(self, layer_id: str) -&gt; Optional[Dict]:\n        \"\"\"Get layer configuration by ID.\n\n        Args:\n            layer_id: Layer identifier.\n\n        Returns:\n            Layer configuration dict or None if not found.\n        \"\"\"\n        return self._layers.get(layer_id)\n\n    def get_layer_ids(self) -&gt; List[str]:\n        \"\"\"Get list of all layer IDs.\n\n        Returns:\n            List of layer identifiers.\n        \"\"\"\n        return list(self._layers.keys())\n\n    def add_popup(\n        self,\n        layer_id: str,\n        properties: Optional[List[str]] = None,\n        template: Optional[str] = None,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add popup on click for a layer.\n\n        Configures a layer to show a popup when features are clicked.\n\n        Args:\n            layer_id: Layer identifier to add popup to.\n            properties: List of property names to display. If None, shows all.\n            template: Custom HTML template for popup content. Use {property_name}\n                placeholders for values. If None, auto-generates table.\n            **kwargs: Additional popup options (maxWidth, closeButton, etc.).\n\n        Example:\n            &gt;&gt;&gt; m.add_vector(geojson, name=\"cities\")\n            &gt;&gt;&gt; m.add_popup(\"cities\", properties=[\"name\", \"population\"])\n            &gt;&gt;&gt; # Or with custom template:\n            &gt;&gt;&gt; m.add_popup(\"cities\", template=\"&lt;h3&gt;{name}&lt;/h3&gt;&lt;p&gt;Pop: {population}&lt;/p&gt;\")\n        \"\"\"\n        self.call_js_method(\n            \"addPopup\",\n            layerId=layer_id,\n            properties=properties,\n            template=template,\n            **kwargs,\n        )\n\n    # -------------------------------------------------------------------------\n    # Terrain and Image Overlay Methods\n    # -------------------------------------------------------------------------\n\n    def add_3d_terrain(\n        self,\n        source: str = \"terrarium\",\n        exaggeration: float = 1.0,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Enable 3D terrain visualization.\n\n        MapLibre GL JS supports 3D terrain rendering using elevation data\n        from various terrain tile sources.\n\n        Args:\n            source: Terrain source - 'terrarium' (AWS terrain tiles) or\n                'mapbox' (requires Mapbox token) or custom terrain URL.\n            exaggeration: Vertical exaggeration factor. Default 1.0.\n            **kwargs: Additional terrain options.\n\n        Example:\n            &gt;&gt;&gt; from anymap_ts import Map\n            &gt;&gt;&gt; m = Map(center=[-122.4, 37.8], zoom=12, pitch=60)\n            &gt;&gt;&gt; m.add_3d_terrain(exaggeration=1.5)\n        \"\"\"\n        # Define terrain sources\n        terrain_sources = {\n            \"terrarium\": {\n                \"url\": \"https://s3.amazonaws.com/elevation-tiles-prod/terrarium/{z}/{x}/{y}.png\",\n                \"encoding\": \"terrarium\",\n            },\n            \"mapbox\": {\n                \"url\": \"mapbox://mapbox.mapbox-terrain-dem-v1\",\n                \"encoding\": \"mapbox\",\n            },\n        }\n\n        if source in terrain_sources:\n            terrain_config = terrain_sources[source]\n        else:\n            # Assume it's a custom URL\n            terrain_config = {\"url\": source, \"encoding\": \"terrarium\"}\n\n        self.call_js_method(\n            \"addTerrain\",\n            source=terrain_config,\n            exaggeration=exaggeration,\n            **kwargs,\n        )\n\n    def add_image_layer(\n        self,\n        url: str,\n        coordinates: List[List[float]],\n        name: Optional[str] = None,\n        opacity: float = 1.0,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a georeferenced image overlay.\n\n        Overlays an image on the map at specified geographic coordinates.\n\n        Args:\n            url: URL to the image file.\n            coordinates: Four corner coordinates as [[lng, lat], ...] in order:\n                top-left, top-right, bottom-right, bottom-left.\n            name: Layer identifier. If None, auto-generated.\n            opacity: Layer opacity (0-1).\n            **kwargs: Additional layer options.\n\n        Example:\n            &gt;&gt;&gt; from anymap_ts import Map\n            &gt;&gt;&gt; m = Map()\n            &gt;&gt;&gt; m.add_image_layer(\n            ...     url=\"https://example.com/overlay.png\",\n            ...     coordinates=[\n            ...         [-80.425, 46.437],  # top-left\n            ...         [-71.516, 46.437],  # top-right\n            ...         [-71.516, 37.936],  # bottom-right\n            ...         [-80.425, 37.936],  # bottom-left\n            ...     ]\n            ... )\n        \"\"\"\n        self._validate_opacity(opacity)\n        layer_id = name or f\"image-{len(self._layers)}\"\n\n        if len(coordinates) != 4:\n            raise ValueError(\n                \"coordinates must have exactly 4 corner points \"\n                \"[top-left, top-right, bottom-right, bottom-left]\"\n            )\n\n        self.call_js_method(\n            \"addImageLayer\",\n            id=layer_id,\n            url=url,\n            coordinates=coordinates,\n            opacity=opacity,\n            **kwargs,\n        )\n\n        self._layers = {\n            **self._layers,\n            layer_id: {\n                \"id\": layer_id,\n                \"type\": \"image\",\n                \"url\": url,\n                \"coordinates\": coordinates,\n            },\n        }\n        self._add_to_layer_dict(layer_id, \"Raster\")\n\n    # -------------------------------------------------------------------------\n    # Controls\n    # -------------------------------------------------------------------------\n\n    def add_control(\n        self,\n        control_type: str,\n        position: str = \"top-right\",\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a map control.\n\n        Args:\n            control_type: Type of control ('navigation', 'scale', 'fullscreen', etc.)\n            position: Control position\n            **kwargs: Control-specific options\n        \"\"\"\n        self.call_js_method(\"addControl\", control_type, position=position, **kwargs)\n        self._controls = {\n            **self._controls,\n            control_type: {\"type\": control_type, \"position\": position, **kwargs},\n        }\n\n    def remove_control(self, control_type: str) -&gt; None:\n        \"\"\"Remove a map control.\n\n        Args:\n            control_type: Type of control to remove\n        \"\"\"\n        self.call_js_method(\"removeControl\", control_type)\n        if control_type in self._controls:\n            controls = dict(self._controls)\n            del controls[control_type]\n            self._controls = controls\n\n    def add_layer_control(\n        self,\n        layers: Optional[List[str]] = None,\n        position: str = \"top-right\",\n        collapsed: bool = True,\n    ) -&gt; None:\n        \"\"\"Add a layer visibility control.\n\n        Uses maplibre-gl-layer-control for layer toggling and opacity.\n\n        Args:\n            layers: List of layer IDs to include (None = all layers)\n            position: Control position\n            collapsed: Whether control starts collapsed\n        \"\"\"\n        if layers is None:\n            layers = list(self._layers.keys())\n\n        self.call_js_method(\n            \"addLayerControl\",\n            layers=layers,\n            position=position,\n            collapsed=collapsed,\n        )\n        self._controls = {\n            **self._controls,\n            \"layer-control\": {\n                \"layers\": layers,\n                \"position\": position,\n                \"collapsed\": collapsed,\n            },\n        }\n\n    def add_legend(\n        self,\n        title: str,\n        labels: List[str],\n        colors: List[str],\n        position: str = \"bottom-right\",\n        opacity: float = 1.0,\n        legend_id: Optional[str] = None,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a floating legend control to the map.\n\n        Creates a custom legend control with colored boxes and labels that\n        floats over the map in the specified position.\n\n        Args:\n            title: Legend title text\n            labels: List of label strings for each legend item\n            colors: List of hex color strings (e.g., ['#ff0000', '#00ff00', '#0000ff'])\n            position: Legend position ('top-left', 'top-right', 'bottom-left', 'bottom-right')\n            opacity: Legend background opacity (0-1)\n            legend_id: Custom legend identifier (auto-generated if None)\n            **kwargs: Additional legend styling options\n\n        Example:\n            &gt;&gt;&gt; from anymap_ts import Map\n            &gt;&gt;&gt; m = Map()\n            &gt;&gt;&gt; m.add_legend(\n            ...     title=\"Land Cover\",\n            ...     labels=[\"Forest\", \"Water\", \"Urban\"],\n            ...     colors=[\"#228B22\", \"#0000FF\", \"#808080\"],\n            ...     position=\"top-left\"\n            ... )\n        \"\"\"\n        if len(labels) != len(colors):\n            raise ValueError(\"Number of labels must match number of colors\")\n\n        # Validate position\n        self._validate_position(position)\n\n        # Validate colors (basic hex color check)\n        for i, color in enumerate(colors):\n            if not isinstance(color, str) or not color.startswith(\"#\"):\n                raise ValueError(\n                    f\"Color at index {i} must be a hex color string (e.g., '#ff0000')\"\n                )\n\n        legend_id = (\n            legend_id\n            or f\"legend-{len([k for k in self._controls.keys() if k.startswith('legend')])}\"\n        )\n\n        # Prepare legend data\n        legend_items = []\n        for label, color in zip(labels, colors):\n            legend_items.append(\n                {\n                    \"label\": label,\n                    \"color\": color,\n                }\n            )\n\n        # Call JavaScript method to add legend\n        self.call_js_method(\n            \"addLegend\",\n            id=legend_id,\n            title=title,\n            items=legend_items,\n            position=position,\n            opacity=opacity,\n            **kwargs,\n        )\n\n        # Track legend control\n        self._controls = {\n            **self._controls,\n            legend_id: {\n                \"type\": \"legend\",\n                \"title\": title,\n                \"labels\": labels,\n                \"colors\": colors,\n                \"position\": position,\n                \"opacity\": opacity,\n            },\n        }\n\n    def remove_legend(self, legend_id: Optional[str] = None) -&gt; None:\n        \"\"\"Remove a legend control from the map.\n\n        Args:\n            legend_id: Legend identifier to remove. If None, removes all legends.\n        \"\"\"\n        if legend_id is None:\n            # Remove all legends - create a copy of keys before iterating\n            legend_keys = [k for k in self._controls.keys() if k.startswith(\"legend\")]\n            for key in legend_keys:\n                self.call_js_method(\"removeLegend\", key)\n            # Rebuild controls dict without legend keys\n            self._controls = {\n                k: v for k, v in self._controls.items() if not k.startswith(\"legend\")\n            }\n        else:\n            self.call_js_method(\"removeLegend\", legend_id)\n            if legend_id in self._controls:\n                controls = dict(self._controls)\n                del controls[legend_id]\n                self._controls = controls\n\n    def update_legend(\n        self,\n        legend_id: str,\n        title: Optional[str] = None,\n        labels: Optional[List[str]] = None,\n        colors: Optional[List[str]] = None,\n        opacity: Optional[float] = None,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Update an existing legend's properties.\n\n        Args:\n            legend_id: Legend identifier to update\n            title: New title (if provided)\n            labels: New labels list (if provided)\n            colors: New colors list (if provided)\n            opacity: New opacity (if provided)\n            **kwargs: Additional properties to update\n        \"\"\"\n        if legend_id not in self._controls:\n            raise ValueError(f\"Legend '{legend_id}' not found\")\n\n        update_params = {\"id\": legend_id}\n\n        if title is not None:\n            update_params[\"title\"] = title\n            self._controls[legend_id][\"title\"] = title\n\n        if labels is not None and colors is not None:\n            if len(labels) != len(colors):\n                raise ValueError(\"Number of labels must match number of colors\")\n\n            legend_items = [\n                {\"label\": label, \"color\": color} for label, color in zip(labels, colors)\n            ]\n            update_params[\"items\"] = legend_items\n            self._controls[legend_id][\"labels\"] = labels\n            self._controls[legend_id][\"colors\"] = colors\n\n        elif labels is not None or colors is not None:\n            raise ValueError(\"Both labels and colors must be provided together\")\n\n        if opacity is not None:\n            update_params[\"opacity\"] = opacity\n            self._controls[legend_id][\"opacity\"] = opacity\n\n        update_params.update(kwargs)\n        self.call_js_method(\"updateLegend\", **update_params)\n\n    # -------------------------------------------------------------------------\n    # Drawing\n    # -------------------------------------------------------------------------\n\n    def add_draw_control(\n        self,\n        position: str = \"top-right\",\n        draw_modes: Optional[List[str]] = None,\n        edit_modes: Optional[List[str]] = None,\n        collapsed: bool = False,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a drawing control using maplibre-gl-geo-editor.\n\n        Args:\n            position: Control position\n            draw_modes: Drawing modes to enable (e.g., ['polygon', 'line', 'marker'])\n            edit_modes: Edit modes to enable (e.g., ['select', 'drag', 'delete'])\n            collapsed: Whether control starts collapsed\n            **kwargs: Additional geo-editor options\n        \"\"\"\n        if draw_modes is None:\n            draw_modes = [\"polygon\", \"line\", \"rectangle\", \"circle\", \"marker\"]\n        if edit_modes is None:\n            edit_modes = [\"select\", \"drag\", \"change\", \"rotate\", \"delete\"]\n\n        self.call_js_method(\n            \"addDrawControl\",\n            position=position,\n            drawModes=draw_modes,\n            editModes=edit_modes,\n            collapsed=collapsed,\n            **kwargs,\n        )\n        self._controls = {\n            **self._controls,\n            \"draw-control\": {\n                \"position\": position,\n                \"drawModes\": draw_modes,\n                \"editModes\": edit_modes,\n            },\n        }\n\n    def get_draw_data(self) -&gt; Dict:\n        \"\"\"Get the current drawn features as GeoJSON.\n\n        Returns:\n            GeoJSON FeatureCollection of drawn features\n        \"\"\"\n        self.call_js_method(\"getDrawData\")\n        # Small delay to allow JS to update the trait\n        import time\n\n        time.sleep(0.1)\n        return self._draw_data or {\"type\": \"FeatureCollection\", \"features\": []}\n\n    @property\n    def draw_data(self) -&gt; Dict:\n        \"\"\"Property to access current draw data.\"\"\"\n        return self._draw_data or {\"type\": \"FeatureCollection\", \"features\": []}\n\n    def load_draw_data(self, geojson: Dict) -&gt; None:\n        \"\"\"Load GeoJSON features into the drawing layer.\n\n        Args:\n            geojson: GeoJSON FeatureCollection to load\n        \"\"\"\n        self._draw_data = geojson\n        self.call_js_method(\"loadDrawData\", geojson)\n\n    def clear_draw_data(self) -&gt; None:\n        \"\"\"Clear all drawn features.\"\"\"\n        self._draw_data = {\"type\": \"FeatureCollection\", \"features\": []}\n        self.call_js_method(\"clearDrawData\")\n\n    def save_draw_data(\n        self,\n        filepath: Union[str, Path],\n        driver: Optional[str] = None,\n    ) -&gt; None:\n        \"\"\"Save drawn features to a file.\n\n        Args:\n            filepath: Path to save file\n            driver: Output driver (auto-detected from extension if not provided)\n\n        Raises:\n            ImportError: If geopandas is not installed\n        \"\"\"\n        try:\n            import geopandas as gpd\n        except ImportError:\n            raise ImportError(\n                \"geopandas is required to save draw data. \"\n                \"Install with: pip install anymap-ts[vector]\"\n            )\n\n        data = self.get_draw_data()\n        if not data.get(\"features\"):\n            print(\"No features to save\")\n            return\n\n        gdf = gpd.GeoDataFrame.from_features(data[\"features\"])\n        filepath = Path(filepath)\n\n        # Infer driver from extension\n        if driver is None:\n            ext = filepath.suffix.lower()\n            driver_map = {\n                \".geojson\": \"GeoJSON\",\n                \".json\": \"GeoJSON\",\n                \".shp\": \"ESRI Shapefile\",\n                \".gpkg\": \"GPKG\",\n            }\n            driver = driver_map.get(ext, \"GeoJSON\")\n\n        gdf.to_file(filepath, driver=driver)\n\n    # -------------------------------------------------------------------------\n    # GeoJSON Clustering\n    # -------------------------------------------------------------------------\n\n    def add_cluster_layer(\n        self,\n        data: Any,\n        cluster_radius: int = 50,\n        cluster_max_zoom: int = 14,\n        cluster_colors: Optional[List[str]] = None,\n        cluster_steps: Optional[List[int]] = None,\n        cluster_min_radius: int = 15,\n        cluster_max_radius: int = 30,\n        unclustered_color: str = \"#11b4da\",\n        unclustered_radius: int = 8,\n        show_cluster_count: bool = True,\n        name: Optional[str] = None,\n        zoom_on_click: bool = True,\n        fit_bounds: bool = True,\n        **kwargs,\n    ) -&gt; str:\n        \"\"\"Add a clustered point layer with automatic grouping.\n\n        Creates a point layer that automatically clusters nearby points at\n        lower zoom levels. Clicking on clusters zooms in to expand them.\n\n        Args:\n            data: Point data - GeoJSON, GeoDataFrame, file path, or URL.\n            cluster_radius: Radius of each cluster when grouping points (pixels).\n            cluster_max_zoom: Max zoom level to cluster points (above this, all\n                points are shown individually).\n            cluster_colors: List of colors for cluster circles by size.\n                Default: [\"#51bbd6\", \"#f1f075\", \"#f28cb1\"].\n            cluster_steps: Point count thresholds for color changes.\n                Default: [100, 750]. Must have len(cluster_colors) - 1 values.\n            cluster_min_radius: Minimum cluster circle radius in pixels.\n            cluster_max_radius: Maximum cluster circle radius in pixels.\n            unclustered_color: Color for individual (unclustered) points.\n            unclustered_radius: Radius for individual points in pixels.\n            show_cluster_count: Whether to show point count in clusters.\n            name: Layer identifier. If None, auto-generated.\n            zoom_on_click: Whether clicking clusters zooms in to expand them.\n            fit_bounds: Whether to fit map to data bounds.\n            **kwargs: Additional options.\n\n        Returns:\n            The layer identifier.\n\n        Example:\n            &gt;&gt;&gt; from anymap_ts import Map\n            &gt;&gt;&gt; m = Map()\n            &gt;&gt;&gt; m.add_cluster_layer(\n            ...     \"earthquakes.geojson\",\n            ...     cluster_radius=80,\n            ...     cluster_colors=[\"#00ff00\", \"#ffff00\", \"#ff0000\"],\n            ...     cluster_steps=[50, 500],\n            ... )\n        \"\"\"\n        layer_id = name or f\"cluster-{len(self._layers)}\"\n\n        # Default colors and steps\n        if cluster_colors is None:\n            cluster_colors = [\"#51bbd6\", \"#f1f075\", \"#f28cb1\"]\n        if cluster_steps is None:\n            cluster_steps = [100, 750]\n\n        # Validate steps vs colors\n        if len(cluster_steps) != len(cluster_colors) - 1:\n            raise ValueError(\n                f\"cluster_steps must have {len(cluster_colors) - 1} values \"\n                f\"(one less than cluster_colors), got {len(cluster_steps)}\"\n            )\n\n        # Convert data to GeoJSON\n        geojson = to_geojson(data)\n\n        # Handle URL data - fetch GeoJSON\n        if geojson.get(\"type\") == \"url\":\n            url = geojson[\"url\"]\n            geojson = fetch_geojson(url)\n\n        # Get bounds\n        bounds = get_bounds(geojson) if fit_bounds else None\n\n        self.call_js_method(\n            \"addClusterLayer\",\n            data=geojson,\n            name=layer_id,\n            clusterRadius=cluster_radius,\n            clusterMaxZoom=cluster_max_zoom,\n            clusterColors=cluster_colors,\n            clusterSteps=cluster_steps,\n            clusterMinRadius=cluster_min_radius,\n            clusterMaxRadius=cluster_max_radius,\n            unclusteredColor=unclustered_color,\n            unclusteredRadius=unclustered_radius,\n            showClusterCount=show_cluster_count,\n            zoomOnClick=zoom_on_click,\n            fitBounds=fit_bounds,\n            bounds=bounds,\n            **kwargs,\n        )\n\n        self._layers = {\n            **self._layers,\n            layer_id: {\n                \"id\": layer_id,\n                \"type\": \"cluster\",\n                \"source\": f\"{layer_id}-source\",\n            },\n        }\n        self._add_to_layer_dict(layer_id, \"Vector\")\n        return layer_id\n\n    def remove_cluster_layer(self, layer_id: str) -&gt; None:\n        \"\"\"Remove a cluster layer and all its sublayers.\n\n        Args:\n            layer_id: Layer identifier to remove.\n        \"\"\"\n        self._remove_layer_internal(layer_id, \"removeClusterLayer\")\n\n    # -------------------------------------------------------------------------\n    # Choropleth Maps\n    # -------------------------------------------------------------------------\n\n    def add_choropleth(\n        self,\n        data: Any,\n        column: str,\n        cmap: str = \"viridis\",\n        classification: str = \"quantile\",\n        k: int = 5,\n        breaks: Optional[List[float]] = None,\n        fill_opacity: float = 0.7,\n        line_color: str = \"#000000\",\n        line_width: float = 1,\n        legend: bool = True,\n        legend_title: Optional[str] = None,\n        hover: bool = True,\n        layer_id: Optional[str] = None,\n        fit_bounds: bool = True,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a choropleth (thematic) map layer with automatic classification.\n\n        Choropleth maps use color gradients to visualize data values across\n        geographic areas. This method automatically classifies data and applies\n        appropriate colors.\n\n        Args:\n            data: Polygon data - GeoJSON, GeoDataFrame, file path, or URL.\n            column: Property name to visualize (must be numeric).\n            cmap: Colormap name. Any matplotlib colormap is supported when\n                matplotlib is installed. Common options include:\n                - Sequential: 'viridis', 'plasma', 'inferno', 'magma', 'cividis',\n                  'Blues', 'Greens', 'Reds', 'Oranges', 'Purples', 'Greys'\n                - Diverging: 'RdBu', 'RdYlGn', 'RdYlBu', 'Spectral', 'coolwarm'\n                - Qualitative: 'Set1', 'Set2', 'Set3', 'Paired', 'tab10', 'tab20'\n                See: https://matplotlib.org/stable/gallery/color/colormap_reference.html\n            classification: Classification method:\n                - 'quantile': Equal number of features per class\n                - 'equal_interval': Equal value ranges\n                - 'natural_breaks': Jenks natural breaks (requires jenkspy)\n                - 'manual': Use custom breaks\n            k: Number of classes (ignored if classification='manual').\n            breaks: Custom break values for 'manual' classification.\n                Must have k+1 values defining class boundaries.\n            fill_opacity: Polygon fill opacity (0-1).\n            line_color: Polygon outline color.\n            line_width: Polygon outline width.\n            legend: Whether to add a legend.\n            legend_title: Legend title. Defaults to column name.\n            hover: Whether to enable hover highlight effect.\n            layer_id: Layer identifier. If None, auto-generated.\n            fit_bounds: Whether to fit map to data bounds.\n            **kwargs: Additional layer options.\n\n        Example:\n            &gt;&gt;&gt; from anymap_ts import Map\n            &gt;&gt;&gt; m = Map()\n            &gt;&gt;&gt; m.add_choropleth(\n            ...     \"us_states.geojson\",\n            ...     column=\"population\",\n            ...     cmap=\"YlOrRd\",\n            ...     classification=\"quantile\",\n            ...     k=5,\n            ...     legend_title=\"Population\"\n            ... )\n        \"\"\"\n        from .utils import (\n            get_choropleth_colors,\n            compute_breaks,\n            build_step_expression,\n        )\n\n        layer_name = layer_id or f\"choropleth-{len(self._layers)}\"\n\n        # Convert data to GeoJSON\n        geojson = to_geojson(data)\n\n        # Handle URL data - fetch GeoJSON\n        if geojson.get(\"type\") == \"url\":\n            url = geojson[\"url\"]\n            geojson = fetch_geojson(url)\n\n        # Extract values for classification\n        features = geojson.get(\"features\", [])\n        values = []\n        for feature in features:\n            props = feature.get(\"properties\", {})\n            val = props.get(column)\n            if val is not None:\n                try:\n                    values.append(float(val))\n                except (TypeError, ValueError):\n                    pass\n\n        if not values:\n            raise ValueError(f\"No valid numeric values found for column '{column}'\")\n\n        # Compute breaks\n        computed_breaks = compute_breaks(values, classification, k, breaks)\n\n        # Get colors\n        colors = get_choropleth_colors(cmap, k)\n\n        # Build step expression for MapLibre\n        step_expr = build_step_expression(column, computed_breaks, colors)\n\n        # Get bounds\n        bounds = get_bounds(geojson) if fit_bounds else None\n\n        self.call_js_method(\n            \"addChoropleth\",\n            data=geojson,\n            name=layer_name,\n            column=column,\n            stepExpression=step_expr,\n            fillOpacity=fill_opacity,\n            lineColor=line_color,\n            lineWidth=line_width,\n            hover=hover,\n            fitBounds=fit_bounds,\n            bounds=bounds,\n            **kwargs,\n        )\n\n        self._layers = {\n            **self._layers,\n            layer_name: {\n                \"id\": layer_name,\n                \"type\": \"choropleth\",\n                \"source\": f\"{layer_name}-source\",\n                \"column\": column,\n            },\n        }\n        self._add_to_layer_dict(layer_name, \"Vector\")\n\n        # Add legend\n        if legend:\n            title = legend_title or column\n            # Create labels from breaks\n            labels = []\n            for i in range(len(computed_breaks) - 1):\n                low = computed_breaks[i]\n                high = computed_breaks[i + 1]\n                if i == len(computed_breaks) - 2:\n                    labels.append(f\"{low:.1f} - {high:.1f}\")\n                else:\n                    labels.append(f\"{low:.1f} - {high:.1f}\")\n\n            self.add_legend(\n                title=title,\n                labels=labels,\n                colors=colors,\n                position=\"bottom-right\",\n            )\n\n    # -------------------------------------------------------------------------\n    # 3D Buildings\n    # -------------------------------------------------------------------------\n\n    def add_3d_buildings(\n        self,\n        source: str = \"openmaptiles\",\n        min_zoom: float = 14,\n        fill_extrusion_color: str = \"#aaa\",\n        fill_extrusion_opacity: float = 0.6,\n        height_property: str = \"render_height\",\n        base_property: str = \"render_min_height\",\n        layer_id: Optional[str] = None,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add 3D building extrusions from vector tiles.\n\n        Creates 3D building visualizations using fill-extrusion layers.\n        Works best with vector tile styles that include building data.\n\n        Note:\n            This feature requires a map style with vector tile building data.\n            Recommended styles:\n            - MapTiler styles (requires API key)\n            - OpenFreeMap: \"https://tiles.openfreemap.org/styles/liberty\"\n            - Protomaps styles\n\n            CartoDB raster styles (Positron, DarkMatter) do NOT have building\n            data. For those, the method will attempt to add OpenFreeMap tiles\n            as a source, but results may vary.\n\n        Args:\n            source: Building source identifier. Usually auto-detected from\n                the map style.\n            min_zoom: Minimum zoom level to show buildings (default: 14).\n            fill_extrusion_color: Building color as hex string.\n            fill_extrusion_opacity: Building opacity (0-1).\n            height_property: Property name for building height in the\n                vector tiles (default: 'render_height').\n            base_property: Property name for building base height\n                (default: 'render_min_height').\n            layer_id: Layer identifier. If None, uses '3d-buildings'.\n            **kwargs: Additional layer options.\n\n        Example:\n            &gt;&gt;&gt; from anymap_ts import Map\n            &gt;&gt;&gt; # Use a vector style with building data\n            &gt;&gt;&gt; m = Map(\n            ...     center=[-74.0060, 40.7128],\n            ...     zoom=15,\n            ...     pitch=60,\n            ...     style=\"https://tiles.openfreemap.org/styles/liberty\"\n            ... )\n            &gt;&gt;&gt; m.add_3d_buildings(\n            ...     fill_extrusion_color=\"#4682B4\",\n            ...     fill_extrusion_opacity=0.8\n            ... )\n        \"\"\"\n        layer_name = layer_id or \"3d-buildings\"\n\n        self.call_js_method(\n            \"add3DBuildings\",\n            source=source,\n            minZoom=min_zoom,\n            fillExtrusionColor=fill_extrusion_color,\n            fillExtrusionOpacity=fill_extrusion_opacity,\n            heightProperty=height_property,\n            baseProperty=base_property,\n            layerId=layer_name,\n            **kwargs,\n        )\n\n        self._layers = {\n            **self._layers,\n            layer_name: {\n                \"id\": layer_name,\n                \"type\": \"fill-extrusion\",\n            },\n        }\n        self._add_to_layer_dict(layer_name, \"Vector\")\n\n    # -------------------------------------------------------------------------\n    # Route Animation\n    # -------------------------------------------------------------------------\n\n    def animate_along_route(\n        self,\n        route: Any,\n        duration: int = 10000,\n        loop: bool = True,\n        marker_color: str = \"#3388ff\",\n        marker_size: float = 1.0,\n        show_trail: bool = False,\n        trail_color: str = \"#3388ff\",\n        trail_width: float = 3,\n        animation_id: Optional[str] = None,\n        **kwargs,\n    ) -&gt; str:\n        \"\"\"Animate a marker along a route.\n\n        Creates an animated marker that moves along the specified route line.\n\n        Args:\n            route: Route data - LineString GeoJSON, list of coordinates,\n                GeoDataFrame, or file path.\n            duration: Animation duration in milliseconds.\n            loop: Whether to loop the animation.\n            marker_color: Marker color.\n            marker_size: Marker size multiplier.\n            show_trail: Whether to show a trail behind the marker.\n            trail_color: Trail line color.\n            trail_width: Trail line width.\n            animation_id: Animation identifier. If None, auto-generated.\n            **kwargs: Additional animation options.\n\n        Returns:\n            The animation identifier.\n\n        Example:\n            &gt;&gt;&gt; from anymap_ts import Map\n            &gt;&gt;&gt; m = Map()\n            &gt;&gt;&gt; coords = [[-122.4, 37.8], [-122.3, 37.7], [-122.2, 37.8]]\n            &gt;&gt;&gt; anim_id = m.animate_along_route(coords, duration=5000, loop=True)\n        \"\"\"\n        anim_id = animation_id or f\"animation-{len(self._layers)}\"\n\n        # Convert route to coordinates list\n        if isinstance(route, list) and len(route) &gt; 0:\n            if isinstance(route[0], (list, tuple)):\n                # Already a list of coordinates\n                coordinates = route\n            else:\n                raise ValueError(\"Route list must contain coordinate pairs\")\n        elif isinstance(route, dict):\n            # GeoJSON\n            if route.get(\"type\") == \"LineString\":\n                coordinates = route.get(\"coordinates\", [])\n            elif route.get(\"type\") == \"Feature\":\n                geometry = route.get(\"geometry\", {})\n                if geometry.get(\"type\") == \"LineString\":\n                    coordinates = geometry.get(\"coordinates\", [])\n                else:\n                    raise ValueError(\"Feature geometry must be LineString\")\n            elif route.get(\"type\") == \"FeatureCollection\":\n                features = route.get(\"features\", [])\n                if (\n                    features\n                    and features[0].get(\"geometry\", {}).get(\"type\") == \"LineString\"\n                ):\n                    coordinates = features[0][\"geometry\"][\"coordinates\"]\n                else:\n                    raise ValueError(\n                        \"FeatureCollection must contain LineString features\"\n                    )\n            else:\n                raise ValueError(\n                    \"GeoJSON must be LineString, Feature, or FeatureCollection\"\n                )\n        else:\n            # Try to convert using to_geojson\n            geojson = to_geojson(route)\n            if geojson.get(\"type\") == \"url\":\n                geojson = fetch_geojson(geojson[\"url\"])\n            # Extract coordinates from the converted geojson\n            if geojson.get(\"type\") == \"FeatureCollection\":\n                features = geojson.get(\"features\", [])\n                if features:\n                    coordinates = features[0].get(\"geometry\", {}).get(\"coordinates\", [])\n                else:\n                    raise ValueError(\"No features found in data\")\n            elif geojson.get(\"type\") == \"Feature\":\n                coordinates = geojson.get(\"geometry\", {}).get(\"coordinates\", [])\n            else:\n                coordinates = geojson.get(\"coordinates\", [])\n\n        if len(coordinates) &lt; 2:\n            raise ValueError(\"Route must have at least 2 points\")\n\n        self.call_js_method(\n            \"animateAlongRoute\",\n            id=anim_id,\n            coordinates=coordinates,\n            duration=duration,\n            loop=loop,\n            markerColor=marker_color,\n            markerSize=marker_size,\n            showTrail=show_trail,\n            trailColor=trail_color,\n            trailWidth=trail_width,\n            **kwargs,\n        )\n\n        self._layers = {\n            **self._layers,\n            anim_id: {\n                \"id\": anim_id,\n                \"type\": \"animation\",\n            },\n        }\n        return anim_id\n\n    def stop_animation(self, animation_id: str) -&gt; None:\n        \"\"\"Stop a running animation.\n\n        Args:\n            animation_id: Animation identifier to stop.\n        \"\"\"\n        self.call_js_method(\"stopAnimation\", animation_id)\n        if animation_id in self._layers:\n            layers = dict(self._layers)\n            del layers[animation_id]\n            self._layers = layers\n\n    def pause_animation(self, animation_id: str) -&gt; None:\n        \"\"\"Pause a running animation.\n\n        Args:\n            animation_id: Animation identifier to pause.\n        \"\"\"\n        self.call_js_method(\"pauseAnimation\", animation_id)\n\n    def resume_animation(self, animation_id: str) -&gt; None:\n        \"\"\"Resume a paused animation.\n\n        Args:\n            animation_id: Animation identifier to resume.\n        \"\"\"\n        self.call_js_method(\"resumeAnimation\", animation_id)\n\n    def set_animation_speed(self, animation_id: str, speed: float) -&gt; None:\n        \"\"\"Set animation speed multiplier.\n\n        Args:\n            animation_id: Animation identifier.\n            speed: Speed multiplier (1.0 = normal, 2.0 = double speed, etc.).\n        \"\"\"\n        self.call_js_method(\"setAnimationSpeed\", animation_id, speed)\n\n    # -------------------------------------------------------------------------\n    # Feature Hover Effect\n    # -------------------------------------------------------------------------\n\n    def add_hover_effect(\n        self,\n        layer_id: str,\n        highlight_color: Optional[str] = None,\n        highlight_opacity: Optional[float] = None,\n        highlight_outline_width: float = 2,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add hover highlight effect to an existing layer.\n\n        When the mouse hovers over a feature, it will be highlighted with\n        the specified styles.\n\n        Args:\n            layer_id: Layer identifier to add hover effect to.\n            highlight_color: Override fill/line color on hover. If None,\n                the original color is kept but opacity/outline changes.\n            highlight_opacity: Override opacity on hover.\n            highlight_outline_width: Outline width on hover.\n            **kwargs: Additional hover effect options.\n\n        Example:\n            &gt;&gt;&gt; from anymap_ts import Map\n            &gt;&gt;&gt; m = Map()\n            &gt;&gt;&gt; m.add_geojson(\"states.geojson\", name=\"states\")\n            &gt;&gt;&gt; m.add_hover_effect(\"states\", highlight_opacity=0.9)\n        \"\"\"\n        self.call_js_method(\n            \"addHoverEffect\",\n            layerId=layer_id,\n            highlightColor=highlight_color,\n            highlightOpacity=highlight_opacity,\n            highlightOutlineWidth=highlight_outline_width,\n            **kwargs,\n        )\n\n    # -------------------------------------------------------------------------\n    # Sky &amp; Fog\n    # -------------------------------------------------------------------------\n\n    def set_sky(\n        self,\n        sky_color: str = \"#88C6FC\",\n        horizon_color: str = \"#F0E4D4\",\n        fog_color: str = \"#FFFFFF\",\n        sky_horizon_blend: float = 0.5,\n        horizon_fog_blend: float = 0.5,\n        fog_ground_blend: float = 0.5,\n        atmosphere_blend: float = 0.8,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Set sky and fog atmospheric effects for 3D terrain visualization.\n\n        MapLibre v5 unifies sky and fog into a single `map.setSky()` API.\n        Best used with 3D terrain enabled.\n\n        Args:\n            sky_color: Color of the sky. Default is \"#88C6FC\".\n            horizon_color: Color at the horizon. Default is \"#F0E4D4\".\n            fog_color: Color of the fog. Default is \"#FFFFFF\".\n            sky_horizon_blend: Blend between sky and horizon (0-1).\n                Default is 0.5.\n            horizon_fog_blend: Blend between horizon and fog (0-1).\n                Default is 0.5.\n            fog_ground_blend: Blend between fog and ground (0-1).\n                Default is 0.5.\n            atmosphere_blend: Intensity of the atmosphere effect (0-1).\n                Default is 0.8.\n            **kwargs: Additional sky options.\n\n        Example:\n            &gt;&gt;&gt; from anymap_ts import Map\n            &gt;&gt;&gt; m = Map(center=[-122.4, 37.8], zoom=12, pitch=60)\n            &gt;&gt;&gt; m.add_3d_terrain(exaggeration=1.5)\n            &gt;&gt;&gt; m.set_sky()\n        \"\"\"\n        self.call_js_method(\n            \"setSky\",\n            skyColor=sky_color,\n            horizonColor=horizon_color,\n            fogColor=fog_color,\n            skyHorizonBlend=sky_horizon_blend,\n            horizonFogBlend=horizon_fog_blend,\n            fogGroundBlend=fog_ground_blend,\n            atmosphereBlend=atmosphere_blend,\n            **kwargs,\n        )\n\n    def remove_sky(self) -&gt; None:\n        \"\"\"Remove sky and fog atmospheric effects from the map.\n\n        Example:\n            &gt;&gt;&gt; m.remove_sky()\n        \"\"\"\n        self.call_js_method(\"removeSky\")\n\n    # -------------------------------------------------------------------------\n    # Feature Query/Filter\n    # -------------------------------------------------------------------------\n\n    def set_filter(\n        self,\n        layer_id: str,\n        filter_expression: Optional[List] = None,\n    ) -&gt; None:\n        \"\"\"Set or clear a filter on a map layer.\n\n        Uses MapLibre GL JS filter expressions to show/hide features.\n\n        Args:\n            layer_id: The layer to apply the filter to.\n            filter_expression: A MapLibre filter expression (list).\n                Pass None to clear the filter.\n\n        Example:\n            &gt;&gt;&gt; m.set_filter(\"states-layer\", [\"&gt;=\", [\"get\", \"density\"], 100])\n            &gt;&gt;&gt; m.set_filter(\"states-layer\", None)  # Clear filter\n        \"\"\"\n        self.call_js_method(\n            \"setFilter\",\n            layerId=layer_id,\n            filter=filter_expression,\n        )\n\n    def query_rendered_features(\n        self,\n        geometry: Optional[Any] = None,\n        layers: Optional[List[str]] = None,\n        filter_expression: Optional[List] = None,\n    ) -&gt; Dict:\n        \"\"\"Query features currently rendered on the map.\n\n        Results are stored in the `queried_features` property.\n\n        Args:\n            geometry: Optional point {x, y} or bounding box [[x1, y1], [x2, y2]]\n                to limit the query area. If None, queries the entire viewport.\n            layers: Optional list of layer IDs to query. If None, queries all\n                layers.\n            filter_expression: Optional MapLibre filter expression to further\n                filter results.\n\n        Returns:\n            The current queried features dict (may not yet reflect this query\n            if called immediately; use the `queried_features` property).\n\n        Example:\n            &gt;&gt;&gt; m.query_rendered_features(layers=[\"states-layer\"])\n            &gt;&gt;&gt; features = m.queried_features\n        \"\"\"\n        kwargs: Dict[str, Any] = {}\n        if geometry is not None:\n            kwargs[\"geometry\"] = geometry\n        if layers is not None:\n            kwargs[\"layers\"] = layers\n        if filter_expression is not None:\n            kwargs[\"filter\"] = filter_expression\n\n        self.call_js_method(\"queryRenderedFeatures\", **kwargs)\n        return self._queried_features\n\n    def query_source_features(\n        self,\n        source_id: str,\n        source_layer: Optional[str] = None,\n        filter_expression: Optional[List] = None,\n    ) -&gt; Dict:\n        \"\"\"Query features from a source, including features not currently visible.\n\n        Results are stored in the `queried_features` property.\n\n        Args:\n            source_id: The source to query.\n            source_layer: Optional source layer for vector tile sources.\n            filter_expression: Optional MapLibre filter expression.\n\n        Returns:\n            The current queried features dict.\n\n        Example:\n            &gt;&gt;&gt; m.query_source_features(\"states-source\")\n            &gt;&gt;&gt; features = m.queried_features\n        \"\"\"\n        kwargs: Dict[str, Any] = {\"sourceId\": source_id}\n        if source_layer is not None:\n            kwargs[\"sourceLayer\"] = source_layer\n        if filter_expression is not None:\n            kwargs[\"filter\"] = filter_expression\n\n        self.call_js_method(\"querySourceFeatures\", **kwargs)\n        return self._queried_features\n\n    @property\n    def queried_features(self) -&gt; Dict:\n        \"\"\"Get the most recent query results.\n\n        Returns:\n            A GeoJSON FeatureCollection dict with queried features.\n        \"\"\"\n        return self._queried_features\n\n    # -------------------------------------------------------------------------\n    # Video Layer\n    # -------------------------------------------------------------------------\n\n    def add_video_layer(\n        self,\n        urls: List[str],\n        coordinates: List[List[float]],\n        name: Optional[str] = None,\n        opacity: float = 1.0,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a georeferenced video overlay on the map.\n\n        Args:\n            urls: List of video URLs (provide multiple formats for browser\n                compatibility, e.g., [\".mp4\", \".webm\"]).\n            coordinates: Four corner coordinates as [[lng, lat], ...] in order:\n                top-left, top-right, bottom-right, bottom-left.\n            name: Layer identifier. If None, auto-generated.\n            opacity: Layer opacity (0-1). Default is 1.0.\n            **kwargs: Additional layer options.\n\n        Example:\n            &gt;&gt;&gt; m.add_video_layer(\n            ...     urls=[\"https://example.com/video.mp4\"],\n            ...     coordinates=[\n            ...         [-122.51596391658498, 37.56238816766053],\n            ...         [-122.51467645489949, 37.56410183312965],\n            ...         [-122.51309394645498, 37.563391708549425],\n            ...         [-122.51423120498498, 37.56161849366671],\n            ...     ],\n            ... )\n        \"\"\"\n        self._validate_opacity(opacity)\n        layer_id = name or f\"video-{len(self._layers)}\"\n\n        if len(coordinates) != 4:\n            raise ValueError(\n                \"coordinates must have exactly 4 corner points \"\n                \"[top-left, top-right, bottom-right, bottom-left]\"\n            )\n\n        self.call_js_method(\n            \"addVideoLayer\",\n            id=layer_id,\n            urls=urls,\n            coordinates=coordinates,\n            opacity=opacity,\n            **kwargs,\n        )\n\n        self._layers = {\n            **self._layers,\n            layer_id: {\n                \"id\": layer_id,\n                \"type\": \"video\",\n                \"source\": f\"{layer_id}-source\",\n            },\n        }\n        self._add_to_layer_dict(layer_id, \"Raster\")\n\n    def remove_video_layer(self, name: str) -&gt; None:\n        \"\"\"Remove a video layer from the map.\n\n        Args:\n            name: The layer identifier to remove.\n        \"\"\"\n        if name in self._layers:\n            layers = dict(self._layers)\n            del layers[name]\n            self._layers = layers\n        self._remove_from_layer_dict(name)\n        self.call_js_method(\"removeVideoLayer\", id=name)\n\n    def play_video(self, name: str) -&gt; None:\n        \"\"\"Start playing a video layer.\n\n        Args:\n            name: The video layer identifier.\n        \"\"\"\n        self.call_js_method(\"playVideo\", id=name)\n\n    def pause_video(self, name: str) -&gt; None:\n        \"\"\"Pause a video layer.\n\n        Args:\n            name: The video layer identifier.\n        \"\"\"\n        self.call_js_method(\"pauseVideo\", id=name)\n\n    def seek_video(self, name: str, time: float) -&gt; None:\n        \"\"\"Seek to a specific time in a video layer.\n\n        Args:\n            name: The video layer identifier.\n            time: Time in seconds to seek to.\n        \"\"\"\n        self.call_js_method(\"seekVideo\", id=name, time=time)\n\n    # -------------------------------------------------------------------------\n    # Split Map (Swipe/Compare)\n    # -------------------------------------------------------------------------\n\n    def add_split_map(\n        self,\n        left_layer: str,\n        right_layer: str,\n        position: int = 50,\n    ) -&gt; None:\n        \"\"\"Add a split map comparison view with a draggable divider.\n\n        Creates a side-by-side comparison of two layers. The left side shows\n        the left layer and the right side shows the right layer, with a\n        draggable slider to adjust the split position.\n\n        Args:\n            left_layer: Layer ID for the left side.\n            right_layer: Layer ID for the right side.\n            position: Initial slider position as percentage (0-100).\n                Default is 50 (middle).\n\n        Note:\n            Both layers must exist on the map before calling this method.\n            Best suited for raster tile layers (e.g., satellite vs streets).\n\n        Example:\n            &gt;&gt;&gt; m.add_tile_layer(\n            ...     \"https://mt1.google.com/vt/lyrs=s&amp;x={x}&amp;y={y}&amp;z={z}\",\n            ...     name=\"satellite\",\n            ... )\n            &gt;&gt;&gt; m.add_tile_layer(\n            ...     \"https://tile.openstreetmap.org/{z}/{x}/{y}.png\",\n            ...     name=\"osm\",\n            ... )\n            &gt;&gt;&gt; m.add_split_map(\"satellite\", \"osm\")\n        \"\"\"\n        if not 0 &lt;= position &lt;= 100:\n            raise ValueError(f\"position must be between 0 and 100, got {position}\")\n\n        self.call_js_method(\n            \"addSplitMap\",\n            leftLayer=left_layer,\n            rightLayer=right_layer,\n            position=position,\n        )\n\n    def remove_split_map(self) -&gt; None:\n        \"\"\"Remove the split map comparison view.\n\n        Restores the map to normal single-view mode with all layers visible.\n        \"\"\"\n        self.call_js_method(\"removeSplitMap\")\n\n    # -------------------------------------------------------------------------\n    # Globe Projection (Section 3)\n    # -------------------------------------------------------------------------\n\n    def set_projection(self, projection: str = \"mercator\") -&gt; None:\n        \"\"\"Set the map projection.\n\n        MapLibre GL JS v4+ supports globe projection for a 3D globe view.\n\n        Args:\n            projection: Projection type. Supported values: 'mercator', 'globe'.\n\n        Example:\n            &gt;&gt;&gt; m = MapLibreMap()\n            &gt;&gt;&gt; m.set_projection(\"globe\")\n        \"\"\"\n        self.call_js_method(\"setProjection\", projection=projection)\n\n    # -------------------------------------------------------------------------\n    # Source Data Updates (Section 3)\n    # -------------------------------------------------------------------------\n\n    def update_geojson_source(self, source_id: str, data: Any) -&gt; None:\n        \"\"\"Update the data of an existing GeoJSON source in place.\n\n        This enables real-time/streaming data updates without removing\n        and re-adding layers. Critical for live dashboards.\n\n        Args:\n            source_id: The ID of the GeoJSON source to update.\n            data: New GeoJSON data (dict, GeoDataFrame, or URL string).\n\n        Example:\n            &gt;&gt;&gt; m = MapLibreMap()\n            &gt;&gt;&gt; m.add_geojson(\"initial.geojson\", name=\"points\")\n            &gt;&gt;&gt; # Later, update with new data\n            &gt;&gt;&gt; m.update_geojson_source(\"points\", new_geojson_data)\n        \"\"\"\n        processed_data = self._process_deck_data(data)\n        self.call_js_method(\n            \"updateGeoJSONSource\",\n            sourceId=source_id,\n            data=processed_data,\n        )\n\n    # -------------------------------------------------------------------------\n    # Custom Images &amp; Sprites (Section 3)\n    # -------------------------------------------------------------------------\n\n    def add_image(self, name: str, url: str) -&gt; None:\n        \"\"\"Load a custom icon image for use in symbol layers.\n\n        Args:\n            name: Name to reference this image in symbol layers.\n            url: URL to the image file (PNG, JPEG, etc.).\n\n        Example:\n            &gt;&gt;&gt; m = MapLibreMap()\n            &gt;&gt;&gt; m.add_image(\"custom-marker\", \"https://example.com/marker.png\")\n        \"\"\"\n        self.call_js_method(\"addMapImage\", name=name, url=url)\n\n    # -------------------------------------------------------------------------\n    # Tooltip on Hover (Section 3 / Section 6)\n    # -------------------------------------------------------------------------\n\n    def add_tooltip(\n        self,\n        layer_id: str,\n        template: Optional[str] = None,\n        properties: Optional[List[str]] = None,\n    ) -&gt; None:\n        \"\"\"Add a tooltip that shows on feature hover.\n\n        Shows formatted information when hovering over features in a layer.\n\n        Args:\n            layer_id: The ID of the layer to add tooltips to.\n            template: HTML template with {property} placeholders.\n                Example: \"Name: {name}&lt;br&gt;Population: {pop}\".\n            properties: List of property names to display. If None and no\n                template, all properties are shown.\n\n        Example:\n            &gt;&gt;&gt; m = MapLibreMap()\n            &gt;&gt;&gt; m.add_geojson(\"data.geojson\", name=\"cities\")\n            &gt;&gt;&gt; m.add_tooltip(\"cities\", template=\"&lt;b&gt;{name}&lt;/b&gt;&lt;br&gt;Pop: {population}\")\n        \"\"\"\n        self.call_js_method(\n            \"addTooltip\",\n            layerId=layer_id,\n            template=template or \"\",\n            properties=properties,\n        )\n\n    def remove_tooltip(self, layer_id: str) -&gt; None:\n        \"\"\"Remove tooltip from a layer.\n\n        Args:\n            layer_id: The layer identifier.\n        \"\"\"\n        self.call_js_method(\"removeTooltip\", layerId=layer_id)\n\n    # -------------------------------------------------------------------------\n    # Coordinates Display Control (Section 3)\n    # -------------------------------------------------------------------------\n\n    def add_coordinates_control(\n        self,\n        position: str = \"bottom-left\",\n        precision: int = 4,\n    ) -&gt; None:\n        \"\"\"Add a coordinates display showing cursor lat/lng.\n\n        Args:\n            position: Control position ('top-left', 'top-right',\n                'bottom-left', 'bottom-right').\n            precision: Number of decimal places for coordinates.\n\n        Example:\n            &gt;&gt;&gt; m = MapLibreMap()\n            &gt;&gt;&gt; m.add_coordinates_control(position=\"bottom-left\", precision=6)\n        \"\"\"\n        self.call_js_method(\n            \"addCoordinatesControl\",\n            position=position,\n            precision=precision,\n        )\n\n    def remove_coordinates_control(self) -&gt; None:\n        \"\"\"Remove the coordinates display control.\"\"\"\n        self.call_js_method(\"removeCoordinatesControl\")\n\n    # -------------------------------------------------------------------------\n    # Time Slider (Section 4)\n    # -------------------------------------------------------------------------\n\n    def add_time_slider(\n        self,\n        layer_id: str,\n        property: str,\n        min_value: float = 0,\n        max_value: float = 100,\n        step: float = 1,\n        position: str = \"bottom-left\",\n        label: str = \"Time\",\n        auto_play: bool = False,\n        interval: int = 500,\n    ) -&gt; None:\n        \"\"\"Add a time slider to filter data by a temporal property.\n\n        Creates a slider control that filters layer features based on a\n        numeric/temporal property, with optional auto-animation.\n\n        Args:\n            layer_id: Layer ID to filter.\n            property: Property name to filter on.\n            min_value: Minimum slider value.\n            max_value: Maximum slider value.\n            step: Step increment.\n            position: Control position.\n            label: Label text for the slider.\n            auto_play: Whether to auto-animate through values.\n            interval: Animation interval in milliseconds.\n\n        Example:\n            &gt;&gt;&gt; m = MapLibreMap()\n            &gt;&gt;&gt; m.add_geojson(\"events.geojson\", name=\"events\")\n            &gt;&gt;&gt; m.add_time_slider(\"events\", \"year\", min_value=2000, max_value=2024)\n        \"\"\"\n        self.call_js_method(\n            \"addTimeSlider\",\n            layerId=layer_id,\n            property=property,\n            min=min_value,\n            max=max_value,\n            step=step,\n            position=position,\n            label=label,\n            autoPlay=auto_play,\n            interval=interval,\n        )\n\n    def remove_time_slider(self) -&gt; None:\n        \"\"\"Remove the time slider control.\"\"\"\n        self.call_js_method(\"removeTimeSlider\")\n\n    # -------------------------------------------------------------------------\n    # Swipe Map Comparison (Section 6)\n    # -------------------------------------------------------------------------\n\n    def add_swipe_map(self, left_layer: str, right_layer: str) -&gt; None:\n        \"\"\"Add a drag-to-compare swipe control for two layers.\n\n        Unlike split map which is side-by-side, swipe map overlays both\n        layers and uses a draggable divider for before/after comparison.\n\n        Args:\n            left_layer: Layer ID for the left side.\n            right_layer: Layer ID for the right side.\n\n        Example:\n            &gt;&gt;&gt; m = MapLibreMap()\n            &gt;&gt;&gt; m.add_tile_layer(\"...\", name=\"before\")\n            &gt;&gt;&gt; m.add_tile_layer(\"...\", name=\"after\")\n            &gt;&gt;&gt; m.add_swipe_map(\"before\", \"after\")\n        \"\"\"\n        self.call_js_method(\n            \"addSwipeMap\",\n            leftLayer=left_layer,\n            rightLayer=right_layer,\n        )\n\n    def remove_swipe_map(self) -&gt; None:\n        \"\"\"Remove the swipe map comparison control.\"\"\"\n        self.call_js_method(\"removeSwipeMap\")\n\n    # -------------------------------------------------------------------------\n    # Opacity Slider (Section 6)\n    # -------------------------------------------------------------------------\n\n    def add_opacity_slider(\n        self,\n        layer_id: str,\n        position: str = \"top-right\",\n        label: Optional[str] = None,\n    ) -&gt; None:\n        \"\"\"Add a UI slider to control layer opacity.\n\n        Args:\n            layer_id: Layer ID to control opacity for.\n            position: Control position.\n            label: Label text. Defaults to layer_id.\n\n        Example:\n            &gt;&gt;&gt; m = MapLibreMap()\n            &gt;&gt;&gt; m.add_tile_layer(\"...\", name=\"satellite\")\n            &gt;&gt;&gt; m.add_opacity_slider(\"satellite\")\n        \"\"\"\n        self.call_js_method(\n            \"addOpacitySlider\",\n            layerId=layer_id,\n            position=position,\n            label=label or layer_id,\n        )\n\n    def remove_opacity_slider(self, layer_id: str) -&gt; None:\n        \"\"\"Remove the opacity slider for a layer.\n\n        Args:\n            layer_id: Layer identifier.\n        \"\"\"\n        self.call_js_method(\"removeOpacitySlider\", layerId=layer_id)\n\n    # -------------------------------------------------------------------------\n    # Style Switcher (Section 8)\n    # -------------------------------------------------------------------------\n\n    def add_style_switcher(\n        self,\n        styles: Dict[str, str],\n        position: str = \"top-right\",\n    ) -&gt; None:\n        \"\"\"Add a dropdown to switch between map styles.\n\n        Args:\n            styles: Dict mapping style names to style URLs.\n            position: Control position.\n\n        Example:\n            &gt;&gt;&gt; m = MapLibreMap()\n            &gt;&gt;&gt; m.add_style_switcher({\n            ...     \"Light\": \"https://basemaps.cartocdn.com/gl/positron-gl-style/style.json\",\n            ...     \"Dark\": \"https://basemaps.cartocdn.com/gl/dark-matter-gl-style/style.json\",\n            ...     \"Voyager\": \"https://basemaps.cartocdn.com/gl/voyager-gl-style/style.json\",\n            ... })\n        \"\"\"\n        self.call_js_method(\n            \"addStyleSwitcher\",\n            styles=styles,\n            position=position,\n        )\n\n    def remove_style_switcher(self) -&gt; None:\n        \"\"\"Remove the style switcher control.\"\"\"\n        self.call_js_method(\"removeStyleSwitcher\")\n\n    # -------------------------------------------------------------------------\n    # Data Export (Section 7)\n    # -------------------------------------------------------------------------\n\n    def get_visible_features(\n        self,\n        layers: Optional[List[str]] = None,\n    ) -&gt; Optional[Dict]:\n        \"\"\"Get all features currently visible in the viewport.\n\n        This triggers a query to the JavaScript side. The result is\n        returned asynchronously via the ``_queried_features`` trait.\n\n        On the first call, the query is sent and ``None`` is returned\n        because the JavaScript side has not yet responded. Run this\n        method in one notebook cell, then read the result in the next\n        cell (the event loop processes the response between cells).\n\n        Args:\n            layers: Optional list of layer IDs to query. If ``None``,\n                queries all visible layers.\n\n        Returns:\n            GeoJSON FeatureCollection dict if results are available from\n            a previous query, otherwise ``None``.\n\n        Example:\n            &gt;&gt;&gt; # Cell 1 \u2013 trigger the query\n            &gt;&gt;&gt; m.get_visible_features(layers=[\"my-layer\"])\n            &gt;&gt;&gt; # Cell 2 \u2013 read the result\n            &gt;&gt;&gt; m.get_visible_features()\n        \"\"\"\n        if layers is not None:\n            self.call_js_method(\"getVisibleFeatures\", layers=layers)\n        features = self._queried_features\n        if features and \"data\" in features:\n            return features[\"data\"]\n        return None\n\n    def to_geojson(self, layer_id: Optional[str] = None) -&gt; Optional[Dict]:\n        \"\"\"Get layer data as GeoJSON.\n\n        This triggers a query to the JavaScript side. The result is\n        returned asynchronously via the ``_queried_features`` trait.\n\n        On the first call with a ``layer_id``, the query is sent and\n        ``None`` is returned. Run this method in one notebook cell,\n        then call ``to_geojson()`` (without arguments) in the next cell\n        to read the result.\n\n        Args:\n            layer_id: Source/layer ID to export. If ``None``, returns\n                previously queried features.\n\n        Returns:\n            GeoJSON FeatureCollection dict, or ``None`` if not yet\n            available.\n\n        Example:\n            &gt;&gt;&gt; # Cell 1 \u2013 trigger the query\n            &gt;&gt;&gt; m.to_geojson(\"my-data\")\n            &gt;&gt;&gt; # Cell 2 \u2013 read the result\n            &gt;&gt;&gt; result = m.to_geojson()\n        \"\"\"\n        if layer_id:\n            self.call_js_method(\"getLayerData\", sourceId=layer_id)\n        features = self._queried_features\n        if features and \"data\" in features:\n            return features[\"data\"]\n        return None\n\n    def to_geopandas(self, layer_id: Optional[str] = None) -&gt; Any:\n        \"\"\"Get layer data as a GeoDataFrame.\n\n        Requires geopandas to be installed. Works the same as\n        :meth:`to_geojson` \u2013 trigger with a ``layer_id`` in one cell,\n        then call ``to_geopandas()`` in the next cell.\n\n        Args:\n            layer_id: Source/layer ID to export. If ``None``, returns\n                previously queried features.\n\n        Returns:\n            GeoDataFrame, or ``None`` if data not available.\n\n        Example:\n            &gt;&gt;&gt; # Cell 1 \u2013 trigger the query\n            &gt;&gt;&gt; m.to_geojson(\"my-data\")\n            &gt;&gt;&gt; # Cell 2 \u2013 read the result\n            &gt;&gt;&gt; gdf = m.to_geopandas()\n        \"\"\"\n        geojson = self.to_geojson(layer_id)\n        if geojson is None:\n            return None\n        try:\n            import geopandas as gpd\n\n            return gpd.GeoDataFrame.from_features(geojson.get(\"features\", []))\n        except ImportError:\n            raise ImportError(\"geopandas is required for to_geopandas()\")\n\n    # -------------------------------------------------------------------------\n    # HTML Export\n    # -------------------------------------------------------------------------\n\n    def _generate_html_template(self) -&gt; str:\n        \"\"\"Generate standalone HTML for the map.\"\"\"\n        template_path = Path(__file__).parent / \"templates\" / \"maplibre.html\"\n\n        if not template_path.exists():\n            raise FileNotFoundError(\n                f\"HTML template not found at {template_path}. \"\n                \"Please ensure the templates directory is included in the package.\"\n            )\n\n        template = template_path.read_text(encoding=\"utf-8\")\n\n        # Serialize state\n        state = {\n            \"center\": self.center,\n            \"zoom\": self.zoom,\n            \"style\": self.style,\n            \"bearing\": self.bearing,\n            \"pitch\": self.pitch,\n            \"width\": self.width,\n            \"height\": self.height,\n            \"layers\": self._layers,\n            \"sources\": self._sources,\n            \"controls\": self._controls,\n            \"js_calls\": self._js_calls,\n        }\n\n        template = template.replace(\"{{state}}\", json.dumps(state, indent=2))\n        return template\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.maplibre.MapLibreMap.draw_data","title":"<code>draw_data: Dict</code>  <code>property</code> <code>readonly</code>","text":"<p>Property to access current draw data.</p>"},{"location":"anymap_ts/#anymap_ts.maplibre.MapLibreMap.queried_features","title":"<code>queried_features: Dict</code>  <code>property</code> <code>readonly</code>","text":"<p>Get the most recent query results.</p> <p>Returns:</p> Type Description <code>Dict</code> <p>A GeoJSON FeatureCollection dict with queried features.</p>"},{"location":"anymap_ts/#anymap_ts.maplibre.MapLibreMap.__init__","title":"<code>__init__(self, center=(0.0, 0.0), zoom=2.0, width='100%', height='700px', style='https://basemaps.cartocdn.com/gl/positron-gl-style/style.json', bearing=0.0, pitch=0.0, max_pitch=85.0, projection='mercator', controls=None, **kwargs)</code>  <code>special</code>","text":"<p>Initialize a MapLibre map.</p> <p>Parameters:</p> Name Type Description Default <code>center</code> <code>Tuple[float, float]</code> <p>Map center as (longitude, latitude).</p> <code>(0.0, 0.0)</code> <code>zoom</code> <code>float</code> <p>Initial zoom level.</p> <code>2.0</code> <code>width</code> <code>str</code> <p>Map width as CSS string.</p> <code>'100%'</code> <code>height</code> <code>str</code> <p>Map height as CSS string. Default is \"700px\".</p> <code>'700px'</code> <code>style</code> <code>Union[str, Dict]</code> <p>MapLibre style URL or style object. Default is \"https://basemaps.cartocdn.com/gl/positron-gl-style/style.json\".</p> <code>'https://basemaps.cartocdn.com/gl/positron-gl-style/style.json'</code> <code>bearing</code> <code>float</code> <p>Map bearing in degrees.</p> <code>0.0</code> <code>pitch</code> <code>float</code> <p>Map pitch in degrees.</p> <code>0.0</code> <code>max_pitch</code> <code>float</code> <p>Maximum pitch angle in degrees (default: 85).</p> <code>85.0</code> <code>projection</code> <code>str</code> <p>Map projection. Supported values: 'mercator', 'globe'. Default is 'mercator'.</p> <code>'mercator'</code> <code>controls</code> <code>Optional[Dict[str, Any]]</code> <p>Dict of controls to add. If None, defaults to {\"layer-control\": True, \"control-grid\": True}. Use {\"layer-control\": {\"collapsed\": True}} for custom options.</p> <code>None</code> <code>**kwargs</code> <p>Additional widget arguments.</p> <code>{}</code> Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def __init__(\n    self,\n    center: Tuple[float, float] = (0.0, 0.0),\n    zoom: float = 2.0,\n    width: str = \"100%\",\n    height: str = \"700px\",\n    style: Union[\n        str, Dict\n    ] = \"https://basemaps.cartocdn.com/gl/positron-gl-style/style.json\",\n    bearing: float = 0.0,\n    pitch: float = 0.0,\n    max_pitch: float = 85.0,\n    projection: str = \"mercator\",\n    controls: Optional[Dict[str, Any]] = None,\n    **kwargs,\n):\n    \"\"\"Initialize a MapLibre map.\n\n    Args:\n        center: Map center as (longitude, latitude).\n        zoom: Initial zoom level.\n        width: Map width as CSS string.\n        height: Map height as CSS string. Default is \"700px\".\n        style: MapLibre style URL or style object. Default is \"https://basemaps.cartocdn.com/gl/positron-gl-style/style.json\".\n        bearing: Map bearing in degrees.\n        pitch: Map pitch in degrees.\n        max_pitch: Maximum pitch angle in degrees (default: 85).\n        projection: Map projection. Supported values: 'mercator', 'globe'.\n            Default is 'mercator'.\n        controls: Dict of controls to add. If None, defaults to\n            {\"layer-control\": True, \"control-grid\": True}.\n            Use {\"layer-control\": {\"collapsed\": True}} for custom options.\n        **kwargs: Additional widget arguments.\n    \"\"\"\n    # Handle style shortcuts\n    if isinstance(style, str) and not style.startswith(\"http\"):\n        try:\n            style = get_maplibre_style(style)\n        except ValueError:\n            pass  # Use as-is\n\n    super().__init__(\n        center=list(center),\n        zoom=zoom,\n        width=width,\n        height=height,\n        style=style,\n        bearing=bearing,\n        pitch=pitch,\n        max_pitch=max_pitch,\n        projection=projection,\n        **kwargs,\n    )\n\n    # Initialize layer dictionary\n    self._layer_dict = {\"Background\": []}\n\n    # Add default controls\n    if controls is None:\n        controls = {\n            \"layer-control\": True,\n            \"control-grid\": True,\n        }\n\n    for control_name, config in controls.items():\n        if config:\n            if control_name == \"layer-control\":\n                self.add_layer_control(\n                    **(config if isinstance(config, dict) else {})\n                )\n            elif control_name == \"control-grid\":\n                self.add_control_grid(\n                    **(config if isinstance(config, dict) else {})\n                )\n            else:\n                self.add_control(\n                    control_name, **(config if isinstance(config, dict) else {})\n                )\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.maplibre.MapLibreMap.add_3d_buildings","title":"<code>add_3d_buildings(self, source='openmaptiles', min_zoom=14, fill_extrusion_color='#aaa', fill_extrusion_opacity=0.6, height_property='render_height', base_property='render_min_height', layer_id=None, **kwargs)</code>","text":"<p>Add 3D building extrusions from vector tiles.</p> <p>Creates 3D building visualizations using fill-extrusion layers. Works best with vector tile styles that include building data.</p> <p>Note</p> <p>This feature requires a map style with vector tile building data. Recommended styles: - MapTiler styles (requires API key) - OpenFreeMap: \"https://tiles.openfreemap.org/styles/liberty\" - Protomaps styles</p> <p>CartoDB raster styles (Positron, DarkMatter) do NOT have building data. For those, the method will attempt to add OpenFreeMap tiles as a source, but results may vary.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>str</code> <p>Building source identifier. Usually auto-detected from the map style.</p> <code>'openmaptiles'</code> <code>min_zoom</code> <code>float</code> <p>Minimum zoom level to show buildings (default: 14).</p> <code>14</code> <code>fill_extrusion_color</code> <code>str</code> <p>Building color as hex string.</p> <code>'#aaa'</code> <code>fill_extrusion_opacity</code> <code>float</code> <p>Building opacity (0-1).</p> <code>0.6</code> <code>height_property</code> <code>str</code> <p>Property name for building height in the vector tiles (default: 'render_height').</p> <code>'render_height'</code> <code>base_property</code> <code>str</code> <p>Property name for building base height (default: 'render_min_height').</p> <code>'render_min_height'</code> <code>layer_id</code> <code>Optional[str]</code> <p>Layer identifier. If None, uses '3d-buildings'.</p> <code>None</code> <code>**kwargs</code> <p>Additional layer options.</p> <code>{}</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from anymap_ts import Map\n&gt;&gt;&gt; # Use a vector style with building data\n&gt;&gt;&gt; m = Map(\n...     center=[-74.0060, 40.7128],\n...     zoom=15,\n...     pitch=60,\n...     style=\"https://tiles.openfreemap.org/styles/liberty\"\n... )\n&gt;&gt;&gt; m.add_3d_buildings(\n...     fill_extrusion_color=\"#4682B4\",\n...     fill_extrusion_opacity=0.8\n... )\n</code></pre> Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def add_3d_buildings(\n    self,\n    source: str = \"openmaptiles\",\n    min_zoom: float = 14,\n    fill_extrusion_color: str = \"#aaa\",\n    fill_extrusion_opacity: float = 0.6,\n    height_property: str = \"render_height\",\n    base_property: str = \"render_min_height\",\n    layer_id: Optional[str] = None,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add 3D building extrusions from vector tiles.\n\n    Creates 3D building visualizations using fill-extrusion layers.\n    Works best with vector tile styles that include building data.\n\n    Note:\n        This feature requires a map style with vector tile building data.\n        Recommended styles:\n        - MapTiler styles (requires API key)\n        - OpenFreeMap: \"https://tiles.openfreemap.org/styles/liberty\"\n        - Protomaps styles\n\n        CartoDB raster styles (Positron, DarkMatter) do NOT have building\n        data. For those, the method will attempt to add OpenFreeMap tiles\n        as a source, but results may vary.\n\n    Args:\n        source: Building source identifier. Usually auto-detected from\n            the map style.\n        min_zoom: Minimum zoom level to show buildings (default: 14).\n        fill_extrusion_color: Building color as hex string.\n        fill_extrusion_opacity: Building opacity (0-1).\n        height_property: Property name for building height in the\n            vector tiles (default: 'render_height').\n        base_property: Property name for building base height\n            (default: 'render_min_height').\n        layer_id: Layer identifier. If None, uses '3d-buildings'.\n        **kwargs: Additional layer options.\n\n    Example:\n        &gt;&gt;&gt; from anymap_ts import Map\n        &gt;&gt;&gt; # Use a vector style with building data\n        &gt;&gt;&gt; m = Map(\n        ...     center=[-74.0060, 40.7128],\n        ...     zoom=15,\n        ...     pitch=60,\n        ...     style=\"https://tiles.openfreemap.org/styles/liberty\"\n        ... )\n        &gt;&gt;&gt; m.add_3d_buildings(\n        ...     fill_extrusion_color=\"#4682B4\",\n        ...     fill_extrusion_opacity=0.8\n        ... )\n    \"\"\"\n    layer_name = layer_id or \"3d-buildings\"\n\n    self.call_js_method(\n        \"add3DBuildings\",\n        source=source,\n        minZoom=min_zoom,\n        fillExtrusionColor=fill_extrusion_color,\n        fillExtrusionOpacity=fill_extrusion_opacity,\n        heightProperty=height_property,\n        baseProperty=base_property,\n        layerId=layer_name,\n        **kwargs,\n    )\n\n    self._layers = {\n        **self._layers,\n        layer_name: {\n            \"id\": layer_name,\n            \"type\": \"fill-extrusion\",\n        },\n    }\n    self._add_to_layer_dict(layer_name, \"Vector\")\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.maplibre.MapLibreMap.add_3d_terrain","title":"<code>add_3d_terrain(self, source='terrarium', exaggeration=1.0, **kwargs)</code>","text":"<p>Enable 3D terrain visualization.</p> <p>MapLibre GL JS supports 3D terrain rendering using elevation data from various terrain tile sources.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>str</code> <p>Terrain source - 'terrarium' (AWS terrain tiles) or 'mapbox' (requires Mapbox token) or custom terrain URL.</p> <code>'terrarium'</code> <code>exaggeration</code> <code>float</code> <p>Vertical exaggeration factor. Default 1.0.</p> <code>1.0</code> <code>**kwargs</code> <p>Additional terrain options.</p> <code>{}</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from anymap_ts import Map\n&gt;&gt;&gt; m = Map(center=[-122.4, 37.8], zoom=12, pitch=60)\n&gt;&gt;&gt; m.add_3d_terrain(exaggeration=1.5)\n</code></pre> Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def add_3d_terrain(\n    self,\n    source: str = \"terrarium\",\n    exaggeration: float = 1.0,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Enable 3D terrain visualization.\n\n    MapLibre GL JS supports 3D terrain rendering using elevation data\n    from various terrain tile sources.\n\n    Args:\n        source: Terrain source - 'terrarium' (AWS terrain tiles) or\n            'mapbox' (requires Mapbox token) or custom terrain URL.\n        exaggeration: Vertical exaggeration factor. Default 1.0.\n        **kwargs: Additional terrain options.\n\n    Example:\n        &gt;&gt;&gt; from anymap_ts import Map\n        &gt;&gt;&gt; m = Map(center=[-122.4, 37.8], zoom=12, pitch=60)\n        &gt;&gt;&gt; m.add_3d_terrain(exaggeration=1.5)\n    \"\"\"\n    # Define terrain sources\n    terrain_sources = {\n        \"terrarium\": {\n            \"url\": \"https://s3.amazonaws.com/elevation-tiles-prod/terrarium/{z}/{x}/{y}.png\",\n            \"encoding\": \"terrarium\",\n        },\n        \"mapbox\": {\n            \"url\": \"mapbox://mapbox.mapbox-terrain-dem-v1\",\n            \"encoding\": \"mapbox\",\n        },\n    }\n\n    if source in terrain_sources:\n        terrain_config = terrain_sources[source]\n    else:\n        # Assume it's a custom URL\n        terrain_config = {\"url\": source, \"encoding\": \"terrarium\"}\n\n    self.call_js_method(\n        \"addTerrain\",\n        source=terrain_config,\n        exaggeration=exaggeration,\n        **kwargs,\n    )\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.maplibre.MapLibreMap.add_arc_layer","title":"<code>add_arc_layer(self, data, name=None, get_source_position='source', get_target_position='target', get_source_color=None, get_target_color=None, get_width=1, get_height=1, great_circle=False, pickable=True, opacity=0.8, **kwargs)</code>","text":"<p>Add an arc layer for origin-destination visualization using deck.gl.</p> <p>Arc layers are ideal for visualizing connections between locations, such as flight routes, migration patterns, or network flows.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>Array of data objects with source/target coordinates. Each object should have source and target positions.</p> required <code>name</code> <code>Optional[str]</code> <p>Layer ID. If None, auto-generated.</p> <code>None</code> <code>get_source_position</code> <code>Union[str, Any]</code> <p>Accessor for source position [lng, lat]. Can be a string (property name) or a value.</p> <code>'source'</code> <code>get_target_position</code> <code>Union[str, Any]</code> <p>Accessor for target position [lng, lat]. Can be a string (property name) or a value.</p> <code>'target'</code> <code>get_source_color</code> <code>Optional[List[int]]</code> <p>Source end color as [r, g, b, a]. Default: [51, 136, 255, 255] (blue).</p> <code>None</code> <code>get_target_color</code> <code>Optional[List[int]]</code> <p>Target end color as [r, g, b, a]. Default: [255, 136, 51, 255] (orange).</p> <code>None</code> <code>get_width</code> <code>Union[float, str]</code> <p>Arc width in pixels. Can be a number or accessor.</p> <code>1</code> <code>get_height</code> <code>float</code> <p>Arc height multiplier. Higher values create more curved arcs.</p> <code>1</code> <code>great_circle</code> <code>bool</code> <p>Whether to draw arcs along great circles.</p> <code>False</code> <code>pickable</code> <code>bool</code> <p>Whether layer responds to hover/click events.</p> <code>True</code> <code>opacity</code> <code>float</code> <p>Layer opacity (0-1).</p> <code>0.8</code> <code>**kwargs</code> <p>Additional ArcLayer props.</p> <code>{}</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from anymap_ts import MapLibreMap\n&gt;&gt;&gt; m = MapLibreMap()\n&gt;&gt;&gt; arcs = [\n...     {\"source\": [-122.4, 37.8], \"target\": [-73.9, 40.7]},\n...     {\"source\": [-122.4, 37.8], \"target\": [-0.1, 51.5]},\n... ]\n&gt;&gt;&gt; m.add_arc_layer(arcs, name=\"flights\")\n</code></pre> Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def add_arc_layer(\n    self,\n    data: Any,\n    name: Optional[str] = None,\n    get_source_position: Union[str, Any] = \"source\",\n    get_target_position: Union[str, Any] = \"target\",\n    get_source_color: Optional[List[int]] = None,\n    get_target_color: Optional[List[int]] = None,\n    get_width: Union[float, str] = 1,\n    get_height: float = 1,\n    great_circle: bool = False,\n    pickable: bool = True,\n    opacity: float = 0.8,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add an arc layer for origin-destination visualization using deck.gl.\n\n    Arc layers are ideal for visualizing connections between locations,\n    such as flight routes, migration patterns, or network flows.\n\n    Args:\n        data: Array of data objects with source/target coordinates.\n            Each object should have source and target positions.\n        name: Layer ID. If None, auto-generated.\n        get_source_position: Accessor for source position [lng, lat].\n            Can be a string (property name) or a value.\n        get_target_position: Accessor for target position [lng, lat].\n            Can be a string (property name) or a value.\n        get_source_color: Source end color as [r, g, b, a].\n            Default: [51, 136, 255, 255] (blue).\n        get_target_color: Target end color as [r, g, b, a].\n            Default: [255, 136, 51, 255] (orange).\n        get_width: Arc width in pixels. Can be a number or accessor.\n        get_height: Arc height multiplier. Higher values create more curved arcs.\n        great_circle: Whether to draw arcs along great circles.\n        pickable: Whether layer responds to hover/click events.\n        opacity: Layer opacity (0-1).\n        **kwargs: Additional ArcLayer props.\n\n    Example:\n        &gt;&gt;&gt; from anymap_ts import MapLibreMap\n        &gt;&gt;&gt; m = MapLibreMap()\n        &gt;&gt;&gt; arcs = [\n        ...     {\"source\": [-122.4, 37.8], \"target\": [-73.9, 40.7]},\n        ...     {\"source\": [-122.4, 37.8], \"target\": [-0.1, 51.5]},\n        ... ]\n        &gt;&gt;&gt; m.add_arc_layer(arcs, name=\"flights\")\n    \"\"\"\n    layer_id = name or f\"arc-{len(self._layers)}\"\n    processed_data = self._process_deck_data(data)\n\n    self.call_js_method(\n        \"addArcLayer\",\n        id=layer_id,\n        data=processed_data,\n        getSourcePosition=get_source_position,\n        getTargetPosition=get_target_position,\n        getSourceColor=get_source_color or [51, 136, 255, 255],\n        getTargetColor=get_target_color or [255, 136, 51, 255],\n        getWidth=get_width,\n        getHeight=get_height,\n        greatCircle=great_circle,\n        pickable=pickable,\n        opacity=opacity,\n        **kwargs,\n    )\n\n    self._layers = {\n        **self._layers,\n        layer_id: {\n            \"id\": layer_id,\n            \"type\": \"arc\",\n        },\n    }\n    self._add_to_layer_dict(layer_id, \"Deck.gl\")\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.maplibre.MapLibreMap.add_basemap","title":"<code>add_basemap(self, basemap='OpenStreetMap', attribution=None, **kwargs)</code>","text":"<p>Add a basemap layer.</p> <p>Parameters:</p> Name Type Description Default <code>basemap</code> <code>str</code> <p>Name of basemap provider (e.g., \"OpenStreetMap\", \"CartoDB.Positron\")</p> <code>'OpenStreetMap'</code> <code>attribution</code> <code>Optional[str]</code> <p>Custom attribution text</p> <code>None</code> <code>**kwargs</code> <p>Additional options</p> <code>{}</code> Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def add_basemap(\n    self,\n    basemap: str = \"OpenStreetMap\",\n    attribution: Optional[str] = None,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a basemap layer.\n\n    Args:\n        basemap: Name of basemap provider (e.g., \"OpenStreetMap\", \"CartoDB.Positron\")\n        attribution: Custom attribution text\n        **kwargs: Additional options\n    \"\"\"\n    url, default_attribution = get_basemap_url(basemap)\n    self.call_js_method(\n        \"addBasemap\",\n        url,\n        attribution=attribution or default_attribution,\n        name=basemap,\n        **kwargs,\n    )\n\n    # Track in layer dict\n    basemaps = self._layer_dict.get(\"Basemaps\", [])\n    if basemap not in basemaps:\n        self._layer_dict = {\n            **self._layer_dict,\n            \"Basemaps\": basemaps + [basemap],\n        }\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.maplibre.MapLibreMap.add_bitmap_layer","title":"<code>add_bitmap_layer(self, image, bounds, name=None, opacity=1.0, visible=True, pickable=False, desaturate=0, transparent_color=None, tint_color=None, **kwargs)</code>","text":"<p>Add a bitmap layer for image overlay with GPU rendering using deck.gl.</p> <p>Parameters:</p> Name Type Description Default <code>image</code> <code>str</code> <p>URL or data URI of the image.</p> required <code>bounds</code> <code>List[float]</code> <p>Bounding box [west, south, east, north].</p> required <code>name</code> <code>Optional[str]</code> <p>Layer ID. If None, auto-generated.</p> <code>None</code> <code>opacity</code> <code>float</code> <p>Layer opacity (0-1).</p> <code>1.0</code> <code>visible</code> <code>bool</code> <p>Whether layer is visible.</p> <code>True</code> <code>pickable</code> <code>bool</code> <p>Whether layer responds to hover/click events.</p> <code>False</code> <code>desaturate</code> <code>float</code> <p>Desaturation amount (0-1).</p> <code>0</code> <code>transparent_color</code> <code>Optional[List[int]]</code> <p>Color to make transparent [r, g, b, a].</p> <code>None</code> <code>tint_color</code> <code>Optional[List[int]]</code> <p>Color to tint the image [r, g, b].</p> <code>None</code> <code>**kwargs</code> <p>Additional BitmapLayer props.</p> <code>{}</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from anymap_ts import MapLibreMap\n&gt;&gt;&gt; m = MapLibreMap()\n&gt;&gt;&gt; m.add_bitmap_layer(\n...     \"https://example.com/overlay.png\",\n...     bounds=[-122.5, 37.7, -122.3, 37.9],\n... )\n</code></pre> Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def add_bitmap_layer(\n    self,\n    image: str,\n    bounds: List[float],\n    name: Optional[str] = None,\n    opacity: float = 1.0,\n    visible: bool = True,\n    pickable: bool = False,\n    desaturate: float = 0,\n    transparent_color: Optional[List[int]] = None,\n    tint_color: Optional[List[int]] = None,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a bitmap layer for image overlay with GPU rendering using deck.gl.\n\n    Args:\n        image: URL or data URI of the image.\n        bounds: Bounding box [west, south, east, north].\n        name: Layer ID. If None, auto-generated.\n        opacity: Layer opacity (0-1).\n        visible: Whether layer is visible.\n        pickable: Whether layer responds to hover/click events.\n        desaturate: Desaturation amount (0-1).\n        transparent_color: Color to make transparent [r, g, b, a].\n        tint_color: Color to tint the image [r, g, b].\n        **kwargs: Additional BitmapLayer props.\n\n    Example:\n        &gt;&gt;&gt; from anymap_ts import MapLibreMap\n        &gt;&gt;&gt; m = MapLibreMap()\n        &gt;&gt;&gt; m.add_bitmap_layer(\n        ...     \"https://example.com/overlay.png\",\n        ...     bounds=[-122.5, 37.7, -122.3, 37.9],\n        ... )\n    \"\"\"\n    layer_id = name or f\"bitmap-{len(self._layers)}\"\n\n    self.call_js_method(\n        \"addBitmapLayer\",\n        id=layer_id,\n        image=image,\n        bounds=bounds,\n        opacity=opacity,\n        visible=visible,\n        pickable=pickable,\n        desaturate=desaturate,\n        transparentColor=transparent_color or [0, 0, 0, 0],\n        tintColor=tint_color or [255, 255, 255],\n        **kwargs,\n    )\n\n    self._layers = {\n        **self._layers,\n        layer_id: {\"id\": layer_id, \"type\": \"bitmap\"},\n    }\n    self._add_to_layer_dict(layer_id, \"Deck.gl\")\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.maplibre.MapLibreMap.add_choropleth","title":"<code>add_choropleth(self, data, column, cmap='viridis', classification='quantile', k=5, breaks=None, fill_opacity=0.7, line_color='#000000', line_width=1, legend=True, legend_title=None, hover=True, layer_id=None, fit_bounds=True, **kwargs)</code>","text":"<p>Add a choropleth (thematic) map layer with automatic classification.</p> <p>Choropleth maps use color gradients to visualize data values across geographic areas. This method automatically classifies data and applies appropriate colors.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>Polygon data - GeoJSON, GeoDataFrame, file path, or URL.</p> required <code>column</code> <code>str</code> <p>Property name to visualize (must be numeric).</p> required <code>cmap</code> <code>str</code> <p>Colormap name. Any matplotlib colormap is supported when matplotlib is installed. Common options include: - Sequential: 'viridis', 'plasma', 'inferno', 'magma', 'cividis',   'Blues', 'Greens', 'Reds', 'Oranges', 'Purples', 'Greys' - Diverging: 'RdBu', 'RdYlGn', 'RdYlBu', 'Spectral', 'coolwarm' - Qualitative: 'Set1', 'Set2', 'Set3', 'Paired', 'tab10', 'tab20' See: https://matplotlib.org/stable/gallery/color/colormap_reference.html</p> <code>'viridis'</code> <code>classification</code> <code>str</code> <p>Classification method: - 'quantile': Equal number of features per class - 'equal_interval': Equal value ranges - 'natural_breaks': Jenks natural breaks (requires jenkspy) - 'manual': Use custom breaks</p> <code>'quantile'</code> <code>k</code> <code>int</code> <p>Number of classes (ignored if classification='manual').</p> <code>5</code> <code>breaks</code> <code>Optional[List[float]]</code> <p>Custom break values for 'manual' classification. Must have k+1 values defining class boundaries.</p> <code>None</code> <code>fill_opacity</code> <code>float</code> <p>Polygon fill opacity (0-1).</p> <code>0.7</code> <code>line_color</code> <code>str</code> <p>Polygon outline color.</p> <code>'#000000'</code> <code>line_width</code> <code>float</code> <p>Polygon outline width.</p> <code>1</code> <code>legend</code> <code>bool</code> <p>Whether to add a legend.</p> <code>True</code> <code>legend_title</code> <code>Optional[str]</code> <p>Legend title. Defaults to column name.</p> <code>None</code> <code>hover</code> <code>bool</code> <p>Whether to enable hover highlight effect.</p> <code>True</code> <code>layer_id</code> <code>Optional[str]</code> <p>Layer identifier. If None, auto-generated.</p> <code>None</code> <code>fit_bounds</code> <code>bool</code> <p>Whether to fit map to data bounds.</p> <code>True</code> <code>**kwargs</code> <p>Additional layer options.</p> <code>{}</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from anymap_ts import Map\n&gt;&gt;&gt; m = Map()\n&gt;&gt;&gt; m.add_choropleth(\n...     \"us_states.geojson\",\n...     column=\"population\",\n...     cmap=\"YlOrRd\",\n...     classification=\"quantile\",\n...     k=5,\n...     legend_title=\"Population\"\n... )\n</code></pre> Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def add_choropleth(\n    self,\n    data: Any,\n    column: str,\n    cmap: str = \"viridis\",\n    classification: str = \"quantile\",\n    k: int = 5,\n    breaks: Optional[List[float]] = None,\n    fill_opacity: float = 0.7,\n    line_color: str = \"#000000\",\n    line_width: float = 1,\n    legend: bool = True,\n    legend_title: Optional[str] = None,\n    hover: bool = True,\n    layer_id: Optional[str] = None,\n    fit_bounds: bool = True,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a choropleth (thematic) map layer with automatic classification.\n\n    Choropleth maps use color gradients to visualize data values across\n    geographic areas. This method automatically classifies data and applies\n    appropriate colors.\n\n    Args:\n        data: Polygon data - GeoJSON, GeoDataFrame, file path, or URL.\n        column: Property name to visualize (must be numeric).\n        cmap: Colormap name. Any matplotlib colormap is supported when\n            matplotlib is installed. Common options include:\n            - Sequential: 'viridis', 'plasma', 'inferno', 'magma', 'cividis',\n              'Blues', 'Greens', 'Reds', 'Oranges', 'Purples', 'Greys'\n            - Diverging: 'RdBu', 'RdYlGn', 'RdYlBu', 'Spectral', 'coolwarm'\n            - Qualitative: 'Set1', 'Set2', 'Set3', 'Paired', 'tab10', 'tab20'\n            See: https://matplotlib.org/stable/gallery/color/colormap_reference.html\n        classification: Classification method:\n            - 'quantile': Equal number of features per class\n            - 'equal_interval': Equal value ranges\n            - 'natural_breaks': Jenks natural breaks (requires jenkspy)\n            - 'manual': Use custom breaks\n        k: Number of classes (ignored if classification='manual').\n        breaks: Custom break values for 'manual' classification.\n            Must have k+1 values defining class boundaries.\n        fill_opacity: Polygon fill opacity (0-1).\n        line_color: Polygon outline color.\n        line_width: Polygon outline width.\n        legend: Whether to add a legend.\n        legend_title: Legend title. Defaults to column name.\n        hover: Whether to enable hover highlight effect.\n        layer_id: Layer identifier. If None, auto-generated.\n        fit_bounds: Whether to fit map to data bounds.\n        **kwargs: Additional layer options.\n\n    Example:\n        &gt;&gt;&gt; from anymap_ts import Map\n        &gt;&gt;&gt; m = Map()\n        &gt;&gt;&gt; m.add_choropleth(\n        ...     \"us_states.geojson\",\n        ...     column=\"population\",\n        ...     cmap=\"YlOrRd\",\n        ...     classification=\"quantile\",\n        ...     k=5,\n        ...     legend_title=\"Population\"\n        ... )\n    \"\"\"\n    from .utils import (\n        get_choropleth_colors,\n        compute_breaks,\n        build_step_expression,\n    )\n\n    layer_name = layer_id or f\"choropleth-{len(self._layers)}\"\n\n    # Convert data to GeoJSON\n    geojson = to_geojson(data)\n\n    # Handle URL data - fetch GeoJSON\n    if geojson.get(\"type\") == \"url\":\n        url = geojson[\"url\"]\n        geojson = fetch_geojson(url)\n\n    # Extract values for classification\n    features = geojson.get(\"features\", [])\n    values = []\n    for feature in features:\n        props = feature.get(\"properties\", {})\n        val = props.get(column)\n        if val is not None:\n            try:\n                values.append(float(val))\n            except (TypeError, ValueError):\n                pass\n\n    if not values:\n        raise ValueError(f\"No valid numeric values found for column '{column}'\")\n\n    # Compute breaks\n    computed_breaks = compute_breaks(values, classification, k, breaks)\n\n    # Get colors\n    colors = get_choropleth_colors(cmap, k)\n\n    # Build step expression for MapLibre\n    step_expr = build_step_expression(column, computed_breaks, colors)\n\n    # Get bounds\n    bounds = get_bounds(geojson) if fit_bounds else None\n\n    self.call_js_method(\n        \"addChoropleth\",\n        data=geojson,\n        name=layer_name,\n        column=column,\n        stepExpression=step_expr,\n        fillOpacity=fill_opacity,\n        lineColor=line_color,\n        lineWidth=line_width,\n        hover=hover,\n        fitBounds=fit_bounds,\n        bounds=bounds,\n        **kwargs,\n    )\n\n    self._layers = {\n        **self._layers,\n        layer_name: {\n            \"id\": layer_name,\n            \"type\": \"choropleth\",\n            \"source\": f\"{layer_name}-source\",\n            \"column\": column,\n        },\n    }\n    self._add_to_layer_dict(layer_name, \"Vector\")\n\n    # Add legend\n    if legend:\n        title = legend_title or column\n        # Create labels from breaks\n        labels = []\n        for i in range(len(computed_breaks) - 1):\n            low = computed_breaks[i]\n            high = computed_breaks[i + 1]\n            if i == len(computed_breaks) - 2:\n                labels.append(f\"{low:.1f} - {high:.1f}\")\n            else:\n                labels.append(f\"{low:.1f} - {high:.1f}\")\n\n        self.add_legend(\n            title=title,\n            labels=labels,\n            colors=colors,\n            position=\"bottom-right\",\n        )\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.maplibre.MapLibreMap.add_cluster_layer","title":"<code>add_cluster_layer(self, data, cluster_radius=50, cluster_max_zoom=14, cluster_colors=None, cluster_steps=None, cluster_min_radius=15, cluster_max_radius=30, unclustered_color='#11b4da', unclustered_radius=8, show_cluster_count=True, name=None, zoom_on_click=True, fit_bounds=True, **kwargs)</code>","text":"<p>Add a clustered point layer with automatic grouping.</p> <p>Creates a point layer that automatically clusters nearby points at lower zoom levels. Clicking on clusters zooms in to expand them.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>Point data - GeoJSON, GeoDataFrame, file path, or URL.</p> required <code>cluster_radius</code> <code>int</code> <p>Radius of each cluster when grouping points (pixels).</p> <code>50</code> <code>cluster_max_zoom</code> <code>int</code> <p>Max zoom level to cluster points (above this, all points are shown individually).</p> <code>14</code> <code>cluster_colors</code> <code>Optional[List[str]]</code> <p>List of colors for cluster circles by size. Default: [\"#51bbd6\", \"#f1f075\", \"#f28cb1\"].</p> <code>None</code> <code>cluster_steps</code> <code>Optional[List[int]]</code> <p>Point count thresholds for color changes. Default: [100, 750]. Must have len(cluster_colors) - 1 values.</p> <code>None</code> <code>cluster_min_radius</code> <code>int</code> <p>Minimum cluster circle radius in pixels.</p> <code>15</code> <code>cluster_max_radius</code> <code>int</code> <p>Maximum cluster circle radius in pixels.</p> <code>30</code> <code>unclustered_color</code> <code>str</code> <p>Color for individual (unclustered) points.</p> <code>'#11b4da'</code> <code>unclustered_radius</code> <code>int</code> <p>Radius for individual points in pixels.</p> <code>8</code> <code>show_cluster_count</code> <code>bool</code> <p>Whether to show point count in clusters.</p> <code>True</code> <code>name</code> <code>Optional[str]</code> <p>Layer identifier. If None, auto-generated.</p> <code>None</code> <code>zoom_on_click</code> <code>bool</code> <p>Whether clicking clusters zooms in to expand them.</p> <code>True</code> <code>fit_bounds</code> <code>bool</code> <p>Whether to fit map to data bounds.</p> <code>True</code> <code>**kwargs</code> <p>Additional options.</p> <code>{}</code> <p>Returns:</p> Type Description <code>str</code> <p>The layer identifier.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from anymap_ts import Map\n&gt;&gt;&gt; m = Map()\n&gt;&gt;&gt; m.add_cluster_layer(\n...     \"earthquakes.geojson\",\n...     cluster_radius=80,\n...     cluster_colors=[\"#00ff00\", \"#ffff00\", \"#ff0000\"],\n...     cluster_steps=[50, 500],\n... )\n</code></pre> Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def add_cluster_layer(\n    self,\n    data: Any,\n    cluster_radius: int = 50,\n    cluster_max_zoom: int = 14,\n    cluster_colors: Optional[List[str]] = None,\n    cluster_steps: Optional[List[int]] = None,\n    cluster_min_radius: int = 15,\n    cluster_max_radius: int = 30,\n    unclustered_color: str = \"#11b4da\",\n    unclustered_radius: int = 8,\n    show_cluster_count: bool = True,\n    name: Optional[str] = None,\n    zoom_on_click: bool = True,\n    fit_bounds: bool = True,\n    **kwargs,\n) -&gt; str:\n    \"\"\"Add a clustered point layer with automatic grouping.\n\n    Creates a point layer that automatically clusters nearby points at\n    lower zoom levels. Clicking on clusters zooms in to expand them.\n\n    Args:\n        data: Point data - GeoJSON, GeoDataFrame, file path, or URL.\n        cluster_radius: Radius of each cluster when grouping points (pixels).\n        cluster_max_zoom: Max zoom level to cluster points (above this, all\n            points are shown individually).\n        cluster_colors: List of colors for cluster circles by size.\n            Default: [\"#51bbd6\", \"#f1f075\", \"#f28cb1\"].\n        cluster_steps: Point count thresholds for color changes.\n            Default: [100, 750]. Must have len(cluster_colors) - 1 values.\n        cluster_min_radius: Minimum cluster circle radius in pixels.\n        cluster_max_radius: Maximum cluster circle radius in pixels.\n        unclustered_color: Color for individual (unclustered) points.\n        unclustered_radius: Radius for individual points in pixels.\n        show_cluster_count: Whether to show point count in clusters.\n        name: Layer identifier. If None, auto-generated.\n        zoom_on_click: Whether clicking clusters zooms in to expand them.\n        fit_bounds: Whether to fit map to data bounds.\n        **kwargs: Additional options.\n\n    Returns:\n        The layer identifier.\n\n    Example:\n        &gt;&gt;&gt; from anymap_ts import Map\n        &gt;&gt;&gt; m = Map()\n        &gt;&gt;&gt; m.add_cluster_layer(\n        ...     \"earthquakes.geojson\",\n        ...     cluster_radius=80,\n        ...     cluster_colors=[\"#00ff00\", \"#ffff00\", \"#ff0000\"],\n        ...     cluster_steps=[50, 500],\n        ... )\n    \"\"\"\n    layer_id = name or f\"cluster-{len(self._layers)}\"\n\n    # Default colors and steps\n    if cluster_colors is None:\n        cluster_colors = [\"#51bbd6\", \"#f1f075\", \"#f28cb1\"]\n    if cluster_steps is None:\n        cluster_steps = [100, 750]\n\n    # Validate steps vs colors\n    if len(cluster_steps) != len(cluster_colors) - 1:\n        raise ValueError(\n            f\"cluster_steps must have {len(cluster_colors) - 1} values \"\n            f\"(one less than cluster_colors), got {len(cluster_steps)}\"\n        )\n\n    # Convert data to GeoJSON\n    geojson = to_geojson(data)\n\n    # Handle URL data - fetch GeoJSON\n    if geojson.get(\"type\") == \"url\":\n        url = geojson[\"url\"]\n        geojson = fetch_geojson(url)\n\n    # Get bounds\n    bounds = get_bounds(geojson) if fit_bounds else None\n\n    self.call_js_method(\n        \"addClusterLayer\",\n        data=geojson,\n        name=layer_id,\n        clusterRadius=cluster_radius,\n        clusterMaxZoom=cluster_max_zoom,\n        clusterColors=cluster_colors,\n        clusterSteps=cluster_steps,\n        clusterMinRadius=cluster_min_radius,\n        clusterMaxRadius=cluster_max_radius,\n        unclusteredColor=unclustered_color,\n        unclusteredRadius=unclustered_radius,\n        showClusterCount=show_cluster_count,\n        zoomOnClick=zoom_on_click,\n        fitBounds=fit_bounds,\n        bounds=bounds,\n        **kwargs,\n    )\n\n    self._layers = {\n        **self._layers,\n        layer_id: {\n            \"id\": layer_id,\n            \"type\": \"cluster\",\n            \"source\": f\"{layer_id}-source\",\n        },\n    }\n    self._add_to_layer_dict(layer_id, \"Vector\")\n    return layer_id\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.maplibre.MapLibreMap.add_cog_control","title":"<code>add_cog_control(self, position='top-right', collapsed=True, default_url=None, load_default_url=False, default_opacity=1.0, default_colormap='viridis', default_bands='1', default_rescale_min=0, default_rescale_max=255, **kwargs)</code>","text":"<p>Add a COG layer control for loading Cloud Optimized GeoTIFFs via UI.</p> <p>This provides an interactive panel for users to enter COG URLs and configure visualization parameters like colormap and rescaling.</p> <p>Parameters:</p> Name Type Description Default <code>position</code> <code>str</code> <p>Control position ('top-left', 'top-right', 'bottom-left', 'bottom-right').</p> <code>'top-right'</code> <code>collapsed</code> <code>bool</code> <p>Whether the panel starts collapsed.</p> <code>True</code> <code>default_url</code> <code>Optional[str]</code> <p>Default COG URL to pre-fill.</p> <code>None</code> <code>load_default_url</code> <code>bool</code> <p>Whether to auto-load the default URL.</p> <code>False</code> <code>default_opacity</code> <code>float</code> <p>Default layer opacity (0-1).</p> <code>1.0</code> <code>default_colormap</code> <code>str</code> <p>Default colormap name.</p> <code>'viridis'</code> <code>default_bands</code> <code>str</code> <p>Default bands (e.g., '1' or '1,2,3').</p> <code>'1'</code> <code>default_rescale_min</code> <code>float</code> <p>Default minimum value for rescaling.</p> <code>0</code> <code>default_rescale_max</code> <code>float</code> <p>Default maximum value for rescaling.</p> <code>255</code> <code>**kwargs</code> <p>Additional control options.</p> <code>{}</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from anymap_ts import MapLibreMap\n&gt;&gt;&gt; m = MapLibreMap()\n&gt;&gt;&gt; m.add_cog_control(\n...     default_url=\"https://example.com/cog.tif\",\n...     default_colormap=\"terrain\"\n... )\n</code></pre> Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def add_cog_control(\n    self,\n    position: str = \"top-right\",\n    collapsed: bool = True,\n    default_url: Optional[str] = None,\n    load_default_url: bool = False,\n    default_opacity: float = 1.0,\n    default_colormap: str = \"viridis\",\n    default_bands: str = \"1\",\n    default_rescale_min: float = 0,\n    default_rescale_max: float = 255,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a COG layer control for loading Cloud Optimized GeoTIFFs via UI.\n\n    This provides an interactive panel for users to enter COG URLs\n    and configure visualization parameters like colormap and rescaling.\n\n    Args:\n        position: Control position ('top-left', 'top-right', 'bottom-left', 'bottom-right').\n        collapsed: Whether the panel starts collapsed.\n        default_url: Default COG URL to pre-fill.\n        load_default_url: Whether to auto-load the default URL.\n        default_opacity: Default layer opacity (0-1).\n        default_colormap: Default colormap name.\n        default_bands: Default bands (e.g., '1' or '1,2,3').\n        default_rescale_min: Default minimum value for rescaling.\n        default_rescale_max: Default maximum value for rescaling.\n        **kwargs: Additional control options.\n\n    Example:\n        &gt;&gt;&gt; from anymap_ts import MapLibreMap\n        &gt;&gt;&gt; m = MapLibreMap()\n        &gt;&gt;&gt; m.add_cog_control(\n        ...     default_url=\"https://example.com/cog.tif\",\n        ...     default_colormap=\"terrain\"\n        ... )\n    \"\"\"\n    self.call_js_method(\n        \"addCogControl\",\n        position=position,\n        collapsed=collapsed,\n        defaultUrl=default_url or \"\",\n        loadDefaultUrl=load_default_url,\n        defaultOpacity=default_opacity,\n        defaultColormap=default_colormap,\n        defaultBands=default_bands,\n        defaultRescaleMin=default_rescale_min,\n        defaultRescaleMax=default_rescale_max,\n        **kwargs,\n    )\n    self._controls = {\n        **self._controls,\n        \"cog-control\": {\"position\": position, \"collapsed\": collapsed},\n    }\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.maplibre.MapLibreMap.add_cog_layer","title":"<code>add_cog_layer(self, url, name=None, opacity=1.0, visible=True, debug=False, debug_opacity=0.25, max_error=0.125, fit_bounds=True, before_id=None, **kwargs)</code>","text":"<p>Add a Cloud Optimized GeoTIFF (COG) layer using @developmentseed/deck.gl-geotiff.</p> <p>This method renders COG files directly in the browser using GPU-accelerated deck.gl-geotiff rendering with automatic reprojection support.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>URL to the Cloud Optimized GeoTIFF file.</p> required <code>name</code> <code>Optional[str]</code> <p>Layer ID. If None, auto-generated.</p> <code>None</code> <code>opacity</code> <code>float</code> <p>Layer opacity (0-1).</p> <code>1.0</code> <code>visible</code> <code>bool</code> <p>Whether layer is visible.</p> <code>True</code> <code>debug</code> <code>bool</code> <p>Show reprojection mesh for debugging.</p> <code>False</code> <code>debug_opacity</code> <code>float</code> <p>Opacity of debug mesh (0-1).</p> <code>0.25</code> <code>max_error</code> <code>float</code> <p>Maximum reprojection error in pixels. Lower values create denser mesh for better accuracy.</p> <code>0.125</code> <code>fit_bounds</code> <code>bool</code> <p>Whether to fit map to COG bounds after loading.</p> <code>True</code> <code>before_id</code> <code>Optional[str]</code> <p>ID of layer to insert before.</p> <code>None</code> <code>**kwargs</code> <p>Additional COGLayer props.</p> <code>{}</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from anymap_ts import Map\n&gt;&gt;&gt; m = Map()\n&gt;&gt;&gt; m.add_cog_layer(\n...     \"https://example.com/landcover.tif\",\n...     name=\"landcover\",\n...     opacity=0.8\n... )\n</code></pre> Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def add_cog_layer(\n    self,\n    url: str,\n    name: Optional[str] = None,\n    opacity: float = 1.0,\n    visible: bool = True,\n    debug: bool = False,\n    debug_opacity: float = 0.25,\n    max_error: float = 0.125,\n    fit_bounds: bool = True,\n    before_id: Optional[str] = None,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a Cloud Optimized GeoTIFF (COG) layer using @developmentseed/deck.gl-geotiff.\n\n    This method renders COG files directly in the browser using GPU-accelerated\n    deck.gl-geotiff rendering with automatic reprojection support.\n\n    Args:\n        url: URL to the Cloud Optimized GeoTIFF file.\n        name: Layer ID. If None, auto-generated.\n        opacity: Layer opacity (0-1).\n        visible: Whether layer is visible.\n        debug: Show reprojection mesh for debugging.\n        debug_opacity: Opacity of debug mesh (0-1).\n        max_error: Maximum reprojection error in pixels. Lower values\n            create denser mesh for better accuracy.\n        fit_bounds: Whether to fit map to COG bounds after loading.\n        before_id: ID of layer to insert before.\n        **kwargs: Additional COGLayer props.\n\n    Example:\n        &gt;&gt;&gt; from anymap_ts import Map\n        &gt;&gt;&gt; m = Map()\n        &gt;&gt;&gt; m.add_cog_layer(\n        ...     \"https://example.com/landcover.tif\",\n        ...     name=\"landcover\",\n        ...     opacity=0.8\n        ... )\n    \"\"\"\n    layer_id = name or f\"cog-{len(self._layers)}\"\n\n    self.call_js_method(\n        \"addCOGLayer\",\n        id=layer_id,\n        geotiff=url,\n        opacity=opacity,\n        visible=visible,\n        debug=debug,\n        debugOpacity=debug_opacity,\n        maxError=max_error,\n        fitBounds=fit_bounds,\n        beforeId=before_id,\n        **kwargs,\n    )\n\n    self._layers = {\n        **self._layers,\n        layer_id: {\n            \"id\": layer_id,\n            \"type\": \"cog\",\n            \"url\": url,\n        },\n    }\n    self._add_to_layer_dict(layer_id, \"Raster\")\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.maplibre.MapLibreMap.add_colorbar","title":"<code>add_colorbar(self, colormap='viridis', vmin=0, vmax=1, label='', units='', orientation='horizontal', position='bottom-right', bar_thickness=None, bar_length=None, ticks=None, opacity=None, colorbar_id=None, **kwargs)</code>","text":"<p>Add a continuous gradient colorbar to the map.</p> <p>Displays a color gradient legend with customizable colormaps, tick marks, labels, and positioning using maplibre-gl-components.</p> <p>Parameters:</p> Name Type Description Default <code>colormap</code> <code>str</code> <p>Colormap name (e.g., 'viridis', 'plasma', 'inferno', 'magma', 'cividis', 'coolwarm', 'jet', 'terrain', etc.).</p> <code>'viridis'</code> <code>vmin</code> <code>float</code> <p>Minimum value for the colorbar scale.</p> <code>0</code> <code>vmax</code> <code>float</code> <p>Maximum value for the colorbar scale.</p> <code>1</code> <code>label</code> <code>str</code> <p>Title/label displayed above or beside the colorbar.</p> <code>''</code> <code>units</code> <code>str</code> <p>Unit string displayed after values (e.g., '\u00b0C', 'm').</p> <code>''</code> <code>orientation</code> <code>str</code> <p>Orientation of the colorbar ('horizontal' or 'vertical').</p> <code>'horizontal'</code> <code>position</code> <code>str</code> <p>Control position ('top-left', 'top-right', 'bottom-left', 'bottom-right').</p> <code>'bottom-right'</code> <code>bar_thickness</code> <code>Optional[int]</code> <p>Width/height of the gradient bar in pixels.</p> <code>None</code> <code>bar_length</code> <code>Optional[int]</code> <p>Length of the colorbar in pixels.</p> <code>None</code> <code>ticks</code> <code>Optional[Dict]</code> <p>Tick configuration dict (e.g., {'count': 5, 'precision': 2}).</p> <code>None</code> <code>opacity</code> <code>Optional[float]</code> <p>Opacity of the colorbar container (0-1).</p> <code>None</code> <code>colorbar_id</code> <code>Optional[str]</code> <p>Unique identifier. If None, auto-generated.</p> <code>None</code> <code>**kwargs</code> <p>Additional Colorbar options.</p> <code>{}</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; m = Map()\n&gt;&gt;&gt; m.add_cog_layer(\"https://example.com/dem.tif\")\n&gt;&gt;&gt; m.add_colorbar(\n...     colormap=\"terrain\",\n...     vmin=0,\n...     vmax=4000,\n...     label=\"Elevation\",\n...     units=\"m\",\n... )\n</code></pre> Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def add_colorbar(\n    self,\n    colormap: str = \"viridis\",\n    vmin: float = 0,\n    vmax: float = 1,\n    label: str = \"\",\n    units: str = \"\",\n    orientation: str = \"horizontal\",\n    position: str = \"bottom-right\",\n    bar_thickness: Optional[int] = None,\n    bar_length: Optional[int] = None,\n    ticks: Optional[Dict] = None,\n    opacity: Optional[float] = None,\n    colorbar_id: Optional[str] = None,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a continuous gradient colorbar to the map.\n\n    Displays a color gradient legend with customizable colormaps,\n    tick marks, labels, and positioning using maplibre-gl-components.\n\n    Args:\n        colormap: Colormap name (e.g., 'viridis', 'plasma', 'inferno',\n            'magma', 'cividis', 'coolwarm', 'jet', 'terrain', etc.).\n        vmin: Minimum value for the colorbar scale.\n        vmax: Maximum value for the colorbar scale.\n        label: Title/label displayed above or beside the colorbar.\n        units: Unit string displayed after values (e.g., '\u00b0C', 'm').\n        orientation: Orientation of the colorbar ('horizontal' or 'vertical').\n        position: Control position ('top-left', 'top-right',\n            'bottom-left', 'bottom-right').\n        bar_thickness: Width/height of the gradient bar in pixels.\n        bar_length: Length of the colorbar in pixels.\n        ticks: Tick configuration dict (e.g., {'count': 5, 'precision': 2}).\n        opacity: Opacity of the colorbar container (0-1).\n        colorbar_id: Unique identifier. If None, auto-generated.\n        **kwargs: Additional Colorbar options.\n\n    Example:\n        &gt;&gt;&gt; m = Map()\n        &gt;&gt;&gt; m.add_cog_layer(\"https://example.com/dem.tif\")\n        &gt;&gt;&gt; m.add_colorbar(\n        ...     colormap=\"terrain\",\n        ...     vmin=0,\n        ...     vmax=4000,\n        ...     label=\"Elevation\",\n        ...     units=\"m\",\n        ... )\n    \"\"\"\n    self._validate_position(position)\n\n    cbar_id = (\n        colorbar_id\n        or f\"colorbar-{len([k for k in self._controls.keys() if k.startswith('colorbar')])}\"\n    )\n\n    js_kwargs: Dict[str, Any] = {\n        \"colormap\": colormap,\n        \"vmin\": vmin,\n        \"vmax\": vmax,\n        \"label\": label,\n        \"units\": units,\n        \"orientation\": orientation,\n        \"position\": position,\n        \"colorbarId\": cbar_id,\n        **kwargs,\n    }\n    if bar_thickness is not None:\n        js_kwargs[\"barThickness\"] = bar_thickness\n    if bar_length is not None:\n        js_kwargs[\"barLength\"] = bar_length\n    if ticks is not None:\n        js_kwargs[\"ticks\"] = ticks\n    if opacity is not None:\n        js_kwargs[\"opacity\"] = opacity\n\n    self.call_js_method(\"addColorbar\", **js_kwargs)\n\n    self._controls = {\n        **self._controls,\n        cbar_id: {\n            \"type\": \"colorbar\",\n            \"colormap\": colormap,\n            \"vmin\": vmin,\n            \"vmax\": vmax,\n            \"label\": label,\n            \"units\": units,\n            \"orientation\": orientation,\n            \"position\": position,\n        },\n    }\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.maplibre.MapLibreMap.add_column_layer","title":"<code>add_column_layer(self, data, name=None, get_position='coordinates', get_fill_color=None, get_line_color=None, get_elevation=1000, radius=1000, disk_resolution=20, elevation_scale=1, coverage=1, extruded=True, filled=True, stroked=False, wireframe=False, pickable=True, opacity=0.8, **kwargs)</code>","text":"<p>Add a column layer for 3D bar chart visualization using deck.gl.</p> <p>Column layers render cylindrical columns at specified positions, ideal for 3D bar charts on a map.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>Array of data objects with position coordinates.</p> required <code>name</code> <code>Optional[str]</code> <p>Layer ID. If None, auto-generated.</p> <code>None</code> <code>get_position</code> <code>Union[str, Any]</code> <p>Accessor for column position [lng, lat].</p> <code>'coordinates'</code> <code>get_fill_color</code> <code>Optional[Union[List[int], str]]</code> <p>Accessor for fill color [r, g, b, a].</p> <code>None</code> <code>get_line_color</code> <code>Optional[Union[List[int], str]]</code> <p>Accessor for stroke color [r, g, b, a].</p> <code>None</code> <code>get_elevation</code> <code>Union[float, str]</code> <p>Accessor for column height.</p> <code>1000</code> <code>radius</code> <code>float</code> <p>Column radius in meters.</p> <code>1000</code> <code>disk_resolution</code> <code>int</code> <p>Number of sides for column polygon.</p> <code>20</code> <code>elevation_scale</code> <code>float</code> <p>Elevation multiplier.</p> <code>1</code> <code>coverage</code> <code>float</code> <p>Column coverage (0-1).</p> <code>1</code> <code>extruded</code> <code>bool</code> <p>Whether to extrude columns.</p> <code>True</code> <code>filled</code> <code>bool</code> <p>Whether to fill columns.</p> <code>True</code> <code>stroked</code> <code>bool</code> <p>Whether to stroke columns.</p> <code>False</code> <code>wireframe</code> <code>bool</code> <p>Whether to render as wireframe.</p> <code>False</code> <code>pickable</code> <code>bool</code> <p>Whether layer responds to hover/click events.</p> <code>True</code> <code>opacity</code> <code>float</code> <p>Layer opacity (0-1).</p> <code>0.8</code> <code>**kwargs</code> <p>Additional ColumnLayer props.</p> <code>{}</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from anymap_ts import MapLibreMap\n&gt;&gt;&gt; m = MapLibreMap(pitch=45)\n&gt;&gt;&gt; data = [\n...     {\"coordinates\": [-122.4, 37.8], \"value\": 500},\n...     {\"coordinates\": [-122.5, 37.7], \"value\": 1000},\n... ]\n&gt;&gt;&gt; m.add_column_layer(data, get_elevation=\"value\", radius=500)\n</code></pre> Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def add_column_layer(\n    self,\n    data: Any,\n    name: Optional[str] = None,\n    get_position: Union[str, Any] = \"coordinates\",\n    get_fill_color: Optional[Union[List[int], str]] = None,\n    get_line_color: Optional[Union[List[int], str]] = None,\n    get_elevation: Union[float, str] = 1000,\n    radius: float = 1000,\n    disk_resolution: int = 20,\n    elevation_scale: float = 1,\n    coverage: float = 1,\n    extruded: bool = True,\n    filled: bool = True,\n    stroked: bool = False,\n    wireframe: bool = False,\n    pickable: bool = True,\n    opacity: float = 0.8,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a column layer for 3D bar chart visualization using deck.gl.\n\n    Column layers render cylindrical columns at specified positions,\n    ideal for 3D bar charts on a map.\n\n    Args:\n        data: Array of data objects with position coordinates.\n        name: Layer ID. If None, auto-generated.\n        get_position: Accessor for column position [lng, lat].\n        get_fill_color: Accessor for fill color [r, g, b, a].\n        get_line_color: Accessor for stroke color [r, g, b, a].\n        get_elevation: Accessor for column height.\n        radius: Column radius in meters.\n        disk_resolution: Number of sides for column polygon.\n        elevation_scale: Elevation multiplier.\n        coverage: Column coverage (0-1).\n        extruded: Whether to extrude columns.\n        filled: Whether to fill columns.\n        stroked: Whether to stroke columns.\n        wireframe: Whether to render as wireframe.\n        pickable: Whether layer responds to hover/click events.\n        opacity: Layer opacity (0-1).\n        **kwargs: Additional ColumnLayer props.\n\n    Example:\n        &gt;&gt;&gt; from anymap_ts import MapLibreMap\n        &gt;&gt;&gt; m = MapLibreMap(pitch=45)\n        &gt;&gt;&gt; data = [\n        ...     {\"coordinates\": [-122.4, 37.8], \"value\": 500},\n        ...     {\"coordinates\": [-122.5, 37.7], \"value\": 1000},\n        ... ]\n        &gt;&gt;&gt; m.add_column_layer(data, get_elevation=\"value\", radius=500)\n    \"\"\"\n    layer_id = name or f\"column-{len(self._layers)}\"\n    processed_data = self._process_deck_data(data)\n\n    self.call_js_method(\n        \"addColumnLayer\",\n        id=layer_id,\n        data=processed_data,\n        getPosition=get_position,\n        getFillColor=get_fill_color or [255, 140, 0, 200],\n        getLineColor=get_line_color or [0, 0, 0, 255],\n        getElevation=get_elevation,\n        radius=radius,\n        diskResolution=disk_resolution,\n        elevationScale=elevation_scale,\n        coverage=coverage,\n        extruded=extruded,\n        filled=filled,\n        stroked=stroked,\n        wireframe=wireframe,\n        pickable=pickable,\n        opacity=opacity,\n        **kwargs,\n    )\n\n    self._layers = {\n        **self._layers,\n        layer_id: {\"id\": layer_id, \"type\": \"column\"},\n    }\n    self._add_to_layer_dict(layer_id, \"Deck.gl\")\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.maplibre.MapLibreMap.add_contour_layer","title":"<code>add_contour_layer(self, data, name=None, get_position='coordinates', get_weight=1, cell_size=200, contours=None, pickable=True, opacity=1, **kwargs)</code>","text":"<p>Add a contour layer for isoline/isoband generation using deck.gl.</p> <p>Contour layers aggregate point data and generate isolines or isobands, ideal for density visualization and topographic-style maps.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>Array of data objects with position coordinates.</p> required <code>name</code> <code>Optional[str]</code> <p>Layer ID. If None, auto-generated.</p> <code>None</code> <code>get_position</code> <code>Union[str, Any]</code> <p>Accessor for point position [lng, lat].</p> <code>'coordinates'</code> <code>get_weight</code> <code>Union[float, str]</code> <p>Accessor for point weight value.</p> <code>1</code> <code>cell_size</code> <code>float</code> <p>Grid cell size for aggregation in meters.</p> <code>200</code> <code>contours</code> <code>Optional[List[Dict]]</code> <p>Contour definitions [{threshold, color, strokeWidth}, ...].</p> <code>None</code> <code>pickable</code> <code>bool</code> <p>Whether layer responds to hover/click events.</p> <code>True</code> <code>opacity</code> <code>float</code> <p>Layer opacity (0-1).</p> <code>1</code> <code>**kwargs</code> <p>Additional ContourLayer props.</p> <code>{}</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from anymap_ts import MapLibreMap\n&gt;&gt;&gt; m = MapLibreMap()\n&gt;&gt;&gt; points = [\n...     {\"coordinates\": [-122.4, 37.8], \"weight\": 5},\n...     {\"coordinates\": [-122.41, 37.81], \"weight\": 10},\n... ]\n&gt;&gt;&gt; m.add_contour_layer(points, contours=[\n...     {\"threshold\": 1, \"color\": [255, 255, 178], \"strokeWidth\": 1},\n...     {\"threshold\": 5, \"color\": [253, 141, 60], \"strokeWidth\": 2},\n... ])\n</code></pre> Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def add_contour_layer(\n    self,\n    data: Any,\n    name: Optional[str] = None,\n    get_position: Union[str, Any] = \"coordinates\",\n    get_weight: Union[float, str] = 1,\n    cell_size: float = 200,\n    contours: Optional[List[Dict]] = None,\n    pickable: bool = True,\n    opacity: float = 1,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a contour layer for isoline/isoband generation using deck.gl.\n\n    Contour layers aggregate point data and generate isolines or isobands,\n    ideal for density visualization and topographic-style maps.\n\n    Args:\n        data: Array of data objects with position coordinates.\n        name: Layer ID. If None, auto-generated.\n        get_position: Accessor for point position [lng, lat].\n        get_weight: Accessor for point weight value.\n        cell_size: Grid cell size for aggregation in meters.\n        contours: Contour definitions [{threshold, color, strokeWidth}, ...].\n        pickable: Whether layer responds to hover/click events.\n        opacity: Layer opacity (0-1).\n        **kwargs: Additional ContourLayer props.\n\n    Example:\n        &gt;&gt;&gt; from anymap_ts import MapLibreMap\n        &gt;&gt;&gt; m = MapLibreMap()\n        &gt;&gt;&gt; points = [\n        ...     {\"coordinates\": [-122.4, 37.8], \"weight\": 5},\n        ...     {\"coordinates\": [-122.41, 37.81], \"weight\": 10},\n        ... ]\n        &gt;&gt;&gt; m.add_contour_layer(points, contours=[\n        ...     {\"threshold\": 1, \"color\": [255, 255, 178], \"strokeWidth\": 1},\n        ...     {\"threshold\": 5, \"color\": [253, 141, 60], \"strokeWidth\": 2},\n        ... ])\n    \"\"\"\n    layer_id = name or f\"contour-{len(self._layers)}\"\n    processed_data = self._process_deck_data(data)\n\n    default_contours = [\n        {\"threshold\": 1, \"color\": [255, 255, 255], \"strokeWidth\": 1},\n        {\"threshold\": 5, \"color\": [51, 136, 255], \"strokeWidth\": 2},\n        {\"threshold\": 10, \"color\": [0, 0, 255], \"strokeWidth\": 3},\n    ]\n\n    self.call_js_method(\n        \"addContourLayer\",\n        id=layer_id,\n        data=processed_data,\n        getPosition=get_position,\n        getWeight=get_weight,\n        cellSize=cell_size,\n        contours=contours or default_contours,\n        pickable=pickable,\n        opacity=opacity,\n        **kwargs,\n    )\n\n    self._layers = {\n        **self._layers,\n        layer_id: {\n            \"id\": layer_id,\n            \"type\": \"contour\",\n        },\n    }\n    self._add_to_layer_dict(layer_id, \"Deck.gl\")\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.maplibre.MapLibreMap.add_control","title":"<code>add_control(self, control_type, position='top-right', **kwargs)</code>","text":"<p>Add a map control.</p> <p>Parameters:</p> Name Type Description Default <code>control_type</code> <code>str</code> <p>Type of control ('navigation', 'scale', 'fullscreen', etc.)</p> required <code>position</code> <code>str</code> <p>Control position</p> <code>'top-right'</code> <code>**kwargs</code> <p>Control-specific options</p> <code>{}</code> Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def add_control(\n    self,\n    control_type: str,\n    position: str = \"top-right\",\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a map control.\n\n    Args:\n        control_type: Type of control ('navigation', 'scale', 'fullscreen', etc.)\n        position: Control position\n        **kwargs: Control-specific options\n    \"\"\"\n    self.call_js_method(\"addControl\", control_type, position=position, **kwargs)\n    self._controls = {\n        **self._controls,\n        control_type: {\"type\": control_type, \"position\": position, **kwargs},\n    }\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.maplibre.MapLibreMap.add_control_grid","title":"<code>add_control_grid(self, position='top-right', default_controls=None, exclude=None, rows=None, columns=None, collapsed=True, collapsible=True, title='', show_row_column_controls=True, gap=2, basemap_style_url=None, exclude_layers=None, **kwargs)</code>","text":"<p>Add a ControlGrid with all default tools or a custom subset.</p> <p>The ControlGrid provides a collapsible toolbar with up to 26 built-in controls (search, basemap, terrain, measure, draw, etc.) in a configurable grid layout.</p> <p>Parameters:</p> Name Type Description Default <code>position</code> <code>str</code> <p>Control position ('top-left', 'top-right', 'bottom-left', 'bottom-right').</p> <code>'top-right'</code> <code>default_controls</code> <code>Optional[List[str]]</code> <p>Explicit list of control names to include. If None, all 26 default controls are used (minus any in <code>exclude</code>). Valid names: 'globe', 'fullscreen', 'north', 'terrain', 'search', 'viewState', 'inspect', 'vectorDataset', 'basemap', 'measure', 'geoEditor', 'bookmark', 'print', 'minimap', 'swipe', 'streetView', 'addVector', 'cogLayer', 'zarrLayer', 'pmtilesLayer', 'stacLayer', 'stacSearch', 'planetaryComputer', 'gaussianSplat', 'lidar', 'usgsLidar'.</p> <code>None</code> <code>exclude</code> <code>Optional[List[str]]</code> <p>Controls to remove from the default set. Ignored when <code>default_controls</code> is provided.</p> <code>None</code> <code>rows</code> <code>Optional[int]</code> <p>Number of grid rows (auto-calculated if None).</p> <code>None</code> <code>columns</code> <code>Optional[int]</code> <p>Number of grid columns (auto-calculated if None).</p> <code>None</code> <code>collapsed</code> <code>bool</code> <p>Whether the grid starts collapsed. Default True.</p> <code>True</code> <code>collapsible</code> <code>bool</code> <p>Whether the grid can be collapsed. Default True.</p> <code>True</code> <code>title</code> <code>str</code> <p>Optional header title for the grid.</p> <code>''</code> <code>show_row_column_controls</code> <code>bool</code> <p>Show row/column input fields. Default True.</p> <code>True</code> <code>gap</code> <code>int</code> <p>Gap between grid cells in pixels. Default 2.</p> <code>2</code> <code>basemap_style_url</code> <code>Optional[str]</code> <p>Basemap style URL for SwipeControl layer grouping. If None, the current map style is used automatically.</p> <code>None</code> <code>exclude_layers</code> <code>Optional[List[str]]</code> <p>Layer ID patterns to exclude from SwipeControl (e.g., 'measure-', 'gl-draw-'). If None, sensible defaults are applied.</p> <code>None</code> <code>**kwargs</code> <p>Additional ControlGrid options.</p> <code>{}</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from anymap_ts import MapLibreMap\n&gt;&gt;&gt; m = MapLibreMap()\n&gt;&gt;&gt; m.add_control_grid()  # All 26 controls\n&gt;&gt;&gt; # Or with customization:\n&gt;&gt;&gt; m.add_control_grid(\n...     exclude=[\"minimap\", \"streetView\"],\n...     collapsed=True,\n... )\n</code></pre> Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def add_control_grid(\n    self,\n    position: str = \"top-right\",\n    default_controls: Optional[List[str]] = None,\n    exclude: Optional[List[str]] = None,\n    rows: Optional[int] = None,\n    columns: Optional[int] = None,\n    collapsed: bool = True,\n    collapsible: bool = True,\n    title: str = \"\",\n    show_row_column_controls: bool = True,\n    gap: int = 2,\n    basemap_style_url: Optional[str] = None,\n    exclude_layers: Optional[List[str]] = None,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a ControlGrid with all default tools or a custom subset.\n\n    The ControlGrid provides a collapsible toolbar with up to 26 built-in\n    controls (search, basemap, terrain, measure, draw, etc.) in a\n    configurable grid layout.\n\n    Args:\n        position: Control position ('top-left', 'top-right', 'bottom-left',\n            'bottom-right').\n        default_controls: Explicit list of control names to include. If None,\n            all 26 default controls are used (minus any in ``exclude``).\n            Valid names: 'globe', 'fullscreen', 'north', 'terrain', 'search',\n            'viewState', 'inspect', 'vectorDataset', 'basemap', 'measure',\n            'geoEditor', 'bookmark', 'print', 'minimap', 'swipe',\n            'streetView', 'addVector', 'cogLayer', 'zarrLayer',\n            'pmtilesLayer', 'stacLayer', 'stacSearch', 'planetaryComputer',\n            'gaussianSplat', 'lidar', 'usgsLidar'.\n        exclude: Controls to remove from the default set. Ignored when\n            ``default_controls`` is provided.\n        rows: Number of grid rows (auto-calculated if None).\n        columns: Number of grid columns (auto-calculated if None).\n        collapsed: Whether the grid starts collapsed. Default True.\n        collapsible: Whether the grid can be collapsed. Default True.\n        title: Optional header title for the grid.\n        show_row_column_controls: Show row/column input fields. Default True.\n        gap: Gap between grid cells in pixels. Default 2.\n        basemap_style_url: Basemap style URL for SwipeControl layer grouping.\n            If None, the current map style is used automatically.\n        exclude_layers: Layer ID patterns to exclude from SwipeControl\n            (e.g., 'measure-*', 'gl-draw-*'). If None, sensible defaults\n            are applied.\n        **kwargs: Additional ControlGrid options.\n\n    Example:\n        &gt;&gt;&gt; from anymap_ts import MapLibreMap\n        &gt;&gt;&gt; m = MapLibreMap()\n        &gt;&gt;&gt; m.add_control_grid()  # All 26 controls\n        &gt;&gt;&gt; # Or with customization:\n        &gt;&gt;&gt; m.add_control_grid(\n        ...     exclude=[\"minimap\", \"streetView\"],\n        ...     collapsed=True,\n        ... )\n    \"\"\"\n    js_kwargs: Dict[str, Any] = {\n        \"position\": position,\n        \"collapsed\": collapsed,\n        \"collapsible\": collapsible,\n        \"showRowColumnControls\": show_row_column_controls,\n        \"gap\": gap,\n        **kwargs,\n    }\n    if default_controls is not None:\n        js_kwargs[\"defaultControls\"] = default_controls\n    if exclude is not None:\n        js_kwargs[\"exclude\"] = exclude\n    if rows is not None:\n        js_kwargs[\"rows\"] = rows\n    if columns is not None:\n        js_kwargs[\"columns\"] = columns\n    if title:\n        js_kwargs[\"title\"] = title\n    if basemap_style_url is not None:\n        js_kwargs[\"basemapStyleUrl\"] = basemap_style_url\n    if exclude_layers is not None:\n        js_kwargs[\"excludeLayers\"] = exclude_layers\n\n    self.call_js_method(\"addControlGrid\", **js_kwargs)\n    # Save full config for HTML export\n    control_config = {\n        \"position\": position,\n        \"collapsed\": collapsed,\n        \"collapsible\": collapsible,\n    }\n    if default_controls is not None:\n        control_config[\"defaultControls\"] = default_controls\n    if exclude is not None:\n        control_config[\"exclude\"] = exclude\n    if rows is not None:\n        control_config[\"rows\"] = rows\n    if columns is not None:\n        control_config[\"columns\"] = columns\n    self._controls = {\n        **self._controls,\n        \"control-grid\": control_config,\n    }\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.maplibre.MapLibreMap.add_coordinates_control","title":"<code>add_coordinates_control(self, position='bottom-left', precision=4)</code>","text":"<p>Add a coordinates display showing cursor lat/lng.</p> <p>Parameters:</p> Name Type Description Default <code>position</code> <code>str</code> <p>Control position ('top-left', 'top-right', 'bottom-left', 'bottom-right').</p> <code>'bottom-left'</code> <code>precision</code> <code>int</code> <p>Number of decimal places for coordinates.</p> <code>4</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; m = MapLibreMap()\n&gt;&gt;&gt; m.add_coordinates_control(position=\"bottom-left\", precision=6)\n</code></pre> Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def add_coordinates_control(\n    self,\n    position: str = \"bottom-left\",\n    precision: int = 4,\n) -&gt; None:\n    \"\"\"Add a coordinates display showing cursor lat/lng.\n\n    Args:\n        position: Control position ('top-left', 'top-right',\n            'bottom-left', 'bottom-right').\n        precision: Number of decimal places for coordinates.\n\n    Example:\n        &gt;&gt;&gt; m = MapLibreMap()\n        &gt;&gt;&gt; m.add_coordinates_control(position=\"bottom-left\", precision=6)\n    \"\"\"\n    self.call_js_method(\n        \"addCoordinatesControl\",\n        position=position,\n        precision=precision,\n    )\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.maplibre.MapLibreMap.add_deck_heatmap_layer","title":"<code>add_deck_heatmap_layer(self, data, name=None, get_position='coordinates', get_weight=1, radius_pixels=30, intensity=1, threshold=0.05, color_range=None, opacity=1, **kwargs)</code>","text":"<p>Add a GPU-accelerated heatmap layer using deck.gl.</p> <p>This is an alternative to the native MapLibre heatmap layer, using deck.gl's GPU-based rendering for better performance with large datasets.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>Array of data objects with position coordinates.</p> required <code>name</code> <code>Optional[str]</code> <p>Layer ID. If None, auto-generated.</p> <code>None</code> <code>get_position</code> <code>Union[str, Any]</code> <p>Accessor for point position [lng, lat].</p> <code>'coordinates'</code> <code>get_weight</code> <code>Union[float, str]</code> <p>Accessor for point weight value.</p> <code>1</code> <code>radius_pixels</code> <code>float</code> <p>Influence radius in pixels.</p> <code>30</code> <code>intensity</code> <code>float</code> <p>Intensity multiplier.</p> <code>1</code> <code>threshold</code> <code>float</code> <p>Minimum density threshold (0-1).</p> <code>0.05</code> <code>color_range</code> <code>Optional[List[List[int]]]</code> <p>Color gradient [[r, g, b, a], ...].</p> <code>None</code> <code>opacity</code> <code>float</code> <p>Layer opacity (0-1).</p> <code>1</code> <code>**kwargs</code> <p>Additional HeatmapLayer props.</p> <code>{}</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from anymap_ts import MapLibreMap\n&gt;&gt;&gt; m = MapLibreMap()\n&gt;&gt;&gt; points = [\n...     {\"coordinates\": [-122.4, 37.8], \"weight\": 5},\n...     {\"coordinates\": [-122.5, 37.7], \"weight\": 10},\n... ]\n&gt;&gt;&gt; m.add_deck_heatmap_layer(points, get_weight=\"weight\")\n</code></pre> Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def add_deck_heatmap_layer(\n    self,\n    data: Any,\n    name: Optional[str] = None,\n    get_position: Union[str, Any] = \"coordinates\",\n    get_weight: Union[float, str] = 1,\n    radius_pixels: float = 30,\n    intensity: float = 1,\n    threshold: float = 0.05,\n    color_range: Optional[List[List[int]]] = None,\n    opacity: float = 1,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a GPU-accelerated heatmap layer using deck.gl.\n\n    This is an alternative to the native MapLibre heatmap layer, using\n    deck.gl's GPU-based rendering for better performance with large datasets.\n\n    Args:\n        data: Array of data objects with position coordinates.\n        name: Layer ID. If None, auto-generated.\n        get_position: Accessor for point position [lng, lat].\n        get_weight: Accessor for point weight value.\n        radius_pixels: Influence radius in pixels.\n        intensity: Intensity multiplier.\n        threshold: Minimum density threshold (0-1).\n        color_range: Color gradient [[r, g, b, a], ...].\n        opacity: Layer opacity (0-1).\n        **kwargs: Additional HeatmapLayer props.\n\n    Example:\n        &gt;&gt;&gt; from anymap_ts import MapLibreMap\n        &gt;&gt;&gt; m = MapLibreMap()\n        &gt;&gt;&gt; points = [\n        ...     {\"coordinates\": [-122.4, 37.8], \"weight\": 5},\n        ...     {\"coordinates\": [-122.5, 37.7], \"weight\": 10},\n        ... ]\n        &gt;&gt;&gt; m.add_deck_heatmap_layer(points, get_weight=\"weight\")\n    \"\"\"\n    layer_id = name or f\"deck-heatmap-{len(self._layers)}\"\n    processed_data = self._process_deck_data(data)\n\n    default_color_range = [\n        [255, 255, 178, 25],\n        [254, 217, 118, 85],\n        [254, 178, 76, 127],\n        [253, 141, 60, 170],\n        [240, 59, 32, 212],\n        [189, 0, 38, 255],\n    ]\n\n    self.call_js_method(\n        \"addHeatmapLayer\",\n        id=layer_id,\n        data=processed_data,\n        getPosition=get_position,\n        getWeight=get_weight,\n        radiusPixels=radius_pixels,\n        intensity=intensity,\n        threshold=threshold,\n        colorRange=color_range or default_color_range,\n        opacity=opacity,\n        **kwargs,\n    )\n\n    self._layers = {\n        **self._layers,\n        layer_id: {\n            \"id\": layer_id,\n            \"type\": \"deck-heatmap\",\n        },\n    }\n    self._add_to_layer_dict(layer_id, \"Deck.gl\")\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.maplibre.MapLibreMap.add_deckgl_layer","title":"<code>add_deckgl_layer(self, layer_type, data, name=None, **kwargs)</code>","text":"<p>Add a generic deck.gl layer to the map.</p> <p>This method provides a flexible way to add any supported deck.gl layer type using a single interface. For commonly used layers, prefer the specific methods (e.g., add_scatterplot_layer) for better IDE support.</p> <p>Parameters:</p> Name Type Description Default <code>layer_type</code> <code>str</code> <p>The deck.gl layer type (e.g., 'ScatterplotLayer', 'ArcLayer', 'HexagonLayer').</p> required <code>data</code> <code>Any</code> <p>Array of data objects or GeoJSON.</p> required <code>name</code> <code>Optional[str]</code> <p>Layer ID. If None, auto-generated from layer_type.</p> <code>None</code> <code>**kwargs</code> <p>Layer-specific properties passed directly to deck.gl.</p> <code>{}</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from anymap_ts import MapLibreMap\n&gt;&gt;&gt; m = MapLibreMap()\n&gt;&gt;&gt; m.add_deckgl_layer(\n...     \"TripsLayer\",\n...     data=trips_data,\n...     getPath=\"waypoints\",\n...     getTimestamps=\"timestamps\",\n...     trailLength=180,\n... )\n</code></pre> Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def add_deckgl_layer(\n    self,\n    layer_type: str,\n    data: Any,\n    name: Optional[str] = None,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a generic deck.gl layer to the map.\n\n    This method provides a flexible way to add any supported deck.gl layer\n    type using a single interface. For commonly used layers, prefer the\n    specific methods (e.g., add_scatterplot_layer) for better IDE support.\n\n    Args:\n        layer_type: The deck.gl layer type (e.g., 'ScatterplotLayer',\n            'ArcLayer', 'HexagonLayer').\n        data: Array of data objects or GeoJSON.\n        name: Layer ID. If None, auto-generated from layer_type.\n        **kwargs: Layer-specific properties passed directly to deck.gl.\n\n    Example:\n        &gt;&gt;&gt; from anymap_ts import MapLibreMap\n        &gt;&gt;&gt; m = MapLibreMap()\n        &gt;&gt;&gt; m.add_deckgl_layer(\n        ...     \"TripsLayer\",\n        ...     data=trips_data,\n        ...     getPath=\"waypoints\",\n        ...     getTimestamps=\"timestamps\",\n        ...     trailLength=180,\n        ... )\n    \"\"\"\n    layer_type_clean = layer_type.replace(\"Layer\", \"\")\n    prefix = layer_type_clean.lower()\n    layer_id = name or f\"{prefix}-{len(self._layers)}\"\n    processed_data = self._process_deck_data(data)\n\n    self.call_js_method(\n        \"addDeckGLLayer\",\n        layerType=layer_type,\n        id=layer_id,\n        data=processed_data,\n        **kwargs,\n    )\n\n    self._layers = {\n        **self._layers,\n        layer_id: {\n            \"id\": layer_id,\n            \"type\": layer_type,\n        },\n    }\n    self._add_to_layer_dict(layer_id, \"Deck.gl\")\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.maplibre.MapLibreMap.add_draw_control","title":"<code>add_draw_control(self, position='top-right', draw_modes=None, edit_modes=None, collapsed=False, **kwargs)</code>","text":"<p>Add a drawing control using maplibre-gl-geo-editor.</p> <p>Parameters:</p> Name Type Description Default <code>position</code> <code>str</code> <p>Control position</p> <code>'top-right'</code> <code>draw_modes</code> <code>Optional[List[str]]</code> <p>Drawing modes to enable (e.g., ['polygon', 'line', 'marker'])</p> <code>None</code> <code>edit_modes</code> <code>Optional[List[str]]</code> <p>Edit modes to enable (e.g., ['select', 'drag', 'delete'])</p> <code>None</code> <code>collapsed</code> <code>bool</code> <p>Whether control starts collapsed</p> <code>False</code> <code>**kwargs</code> <p>Additional geo-editor options</p> <code>{}</code> Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def add_draw_control(\n    self,\n    position: str = \"top-right\",\n    draw_modes: Optional[List[str]] = None,\n    edit_modes: Optional[List[str]] = None,\n    collapsed: bool = False,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a drawing control using maplibre-gl-geo-editor.\n\n    Args:\n        position: Control position\n        draw_modes: Drawing modes to enable (e.g., ['polygon', 'line', 'marker'])\n        edit_modes: Edit modes to enable (e.g., ['select', 'drag', 'delete'])\n        collapsed: Whether control starts collapsed\n        **kwargs: Additional geo-editor options\n    \"\"\"\n    if draw_modes is None:\n        draw_modes = [\"polygon\", \"line\", \"rectangle\", \"circle\", \"marker\"]\n    if edit_modes is None:\n        edit_modes = [\"select\", \"drag\", \"change\", \"rotate\", \"delete\"]\n\n    self.call_js_method(\n        \"addDrawControl\",\n        position=position,\n        drawModes=draw_modes,\n        editModes=edit_modes,\n        collapsed=collapsed,\n        **kwargs,\n    )\n    self._controls = {\n        **self._controls,\n        \"draw-control\": {\n            \"position\": position,\n            \"drawModes\": draw_modes,\n            \"editModes\": edit_modes,\n        },\n    }\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.maplibre.MapLibreMap.add_flatgeobuf","title":"<code>add_flatgeobuf(self, url, name=None, layer_type=None, paint=None, fit_bounds=True, **kwargs)</code>","text":"<p>Add a FlatGeobuf layer from a URL.</p> <p>Streams and renders cloud-native FlatGeobuf vector data directly in the browser without downloading the entire file.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>URL to the FlatGeobuf file.</p> required <code>name</code> <code>Optional[str]</code> <p>Layer name. If None, auto-generated.</p> <code>None</code> <code>layer_type</code> <code>Optional[str]</code> <p>MapLibre layer type ('circle', 'line', 'fill'). If None, inferred from geometry type.</p> <code>None</code> <code>paint</code> <code>Optional[Dict]</code> <p>MapLibre paint properties. If None, defaults are used.</p> <code>None</code> <code>fit_bounds</code> <code>bool</code> <p>Whether to fit map to data bounds.</p> <code>True</code> <code>**kwargs</code> <p>Additional layer options.</p> <code>{}</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; m = Map()\n&gt;&gt;&gt; m.add_flatgeobuf(\n...     \"https://flatgeobuf.org/test/data/UScounties.fgb\",\n...     name=\"counties\",\n...     paint={\"fill-color\": \"#088\", \"fill-opacity\": 0.5},\n... )\n</code></pre> Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def add_flatgeobuf(\n    self,\n    url: str,\n    name: Optional[str] = None,\n    layer_type: Optional[str] = None,\n    paint: Optional[Dict] = None,\n    fit_bounds: bool = True,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a FlatGeobuf layer from a URL.\n\n    Streams and renders cloud-native FlatGeobuf vector data directly\n    in the browser without downloading the entire file.\n\n    Args:\n        url: URL to the FlatGeobuf file.\n        name: Layer name. If None, auto-generated.\n        layer_type: MapLibre layer type ('circle', 'line', 'fill').\n            If None, inferred from geometry type.\n        paint: MapLibre paint properties. If None, defaults are used.\n        fit_bounds: Whether to fit map to data bounds.\n        **kwargs: Additional layer options.\n\n    Example:\n        &gt;&gt;&gt; m = Map()\n        &gt;&gt;&gt; m.add_flatgeobuf(\n        ...     \"https://flatgeobuf.org/test/data/UScounties.fgb\",\n        ...     name=\"counties\",\n        ...     paint={\"fill-color\": \"#088\", \"fill-opacity\": 0.5},\n        ... )\n    \"\"\"\n    layer_id = name or f\"flatgeobuf-{len(self._layers)}\"\n\n    self.call_js_method(\n        \"addFlatGeobuf\",\n        url=url,\n        name=layer_id,\n        layerType=layer_type,\n        paint=paint,\n        fitBounds=fit_bounds,\n        **kwargs,\n    )\n\n    self._layers = {\n        **self._layers,\n        layer_id: {\n            \"id\": layer_id,\n            \"type\": \"flatgeobuf\",\n            \"url\": url,\n        },\n    }\n    self._add_to_layer_dict(layer_id, \"Vector\")\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.maplibre.MapLibreMap.add_geojson","title":"<code>add_geojson(self, data, layer_type=None, paint=None, name=None, fit_bounds=True, **kwargs)</code>","text":"<p>Add GeoJSON data to the map.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Union[str, Dict]</code> <p>GeoJSON dict or URL to GeoJSON file</p> required <code>layer_type</code> <code>Optional[str]</code> <p>MapLibre layer type</p> <code>None</code> <code>paint</code> <code>Optional[Dict]</code> <p>MapLibre paint properties</p> <code>None</code> <code>name</code> <code>Optional[str]</code> <p>Layer name</p> <code>None</code> <code>fit_bounds</code> <code>bool</code> <p>Whether to fit map to data bounds</p> <code>True</code> <code>**kwargs</code> <p>Additional layer options</p> <code>{}</code> Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def add_geojson(\n    self,\n    data: Union[str, Dict],\n    layer_type: Optional[str] = None,\n    paint: Optional[Dict] = None,\n    name: Optional[str] = None,\n    fit_bounds: bool = True,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add GeoJSON data to the map.\n\n    Args:\n        data: GeoJSON dict or URL to GeoJSON file\n        layer_type: MapLibre layer type\n        paint: MapLibre paint properties\n        name: Layer name\n        fit_bounds: Whether to fit map to data bounds\n        **kwargs: Additional layer options\n    \"\"\"\n    self.add_vector(\n        data,\n        layer_type=layer_type,\n        paint=paint,\n        name=name,\n        fit_bounds=fit_bounds,\n        **kwargs,\n    )\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.maplibre.MapLibreMap.add_geojson_layer","title":"<code>add_geojson_layer(self, data, name=None, get_fill_color=None, get_line_color=None, get_line_width=1, get_point_radius=5, get_elevation=0, extruded=False, wireframe=False, filled=True, stroked=True, line_width_min_pixels=1, point_radius_min_pixels=2, pickable=True, opacity=0.8, **kwargs)</code>","text":"<p>Add a GeoJSON layer with auto-styling using deck.gl.</p> <p>GeoJSON layers render GeoJSON features with automatic geometry type detection and styling, supporting points, lines, and polygons.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>GeoJSON object, URL, or file path.</p> required <code>name</code> <code>Optional[str]</code> <p>Layer ID. If None, auto-generated.</p> <code>None</code> <code>get_fill_color</code> <code>Optional[Union[List[int], str]]</code> <p>Accessor for fill color [r, g, b, a]. Default: [51, 136, 255, 128].</p> <code>None</code> <code>get_line_color</code> <code>Optional[Union[List[int], str]]</code> <p>Accessor for stroke color [r, g, b, a]. Default: [0, 0, 0, 255].</p> <code>None</code> <code>get_line_width</code> <code>Union[float, str]</code> <p>Accessor for stroke width.</p> <code>1</code> <code>get_point_radius</code> <code>Union[float, str]</code> <p>Accessor for point radius.</p> <code>5</code> <code>get_elevation</code> <code>Union[float, str]</code> <p>Accessor for 3D extrusion height.</p> <code>0</code> <code>extruded</code> <code>bool</code> <p>Whether to render as 3D features.</p> <code>False</code> <code>wireframe</code> <code>bool</code> <p>Whether to render wireframe (extruded only).</p> <code>False</code> <code>filled</code> <code>bool</code> <p>Whether to fill features.</p> <code>True</code> <code>stroked</code> <code>bool</code> <p>Whether to draw stroke.</p> <code>True</code> <code>line_width_min_pixels</code> <code>float</code> <p>Minimum stroke width in pixels.</p> <code>1</code> <code>point_radius_min_pixels</code> <code>float</code> <p>Minimum point radius in pixels.</p> <code>2</code> <code>pickable</code> <code>bool</code> <p>Whether layer responds to hover/click events.</p> <code>True</code> <code>opacity</code> <code>float</code> <p>Layer opacity (0-1).</p> <code>0.8</code> <code>**kwargs</code> <p>Additional GeoJsonLayer props.</p> <code>{}</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from anymap_ts import MapLibreMap\n&gt;&gt;&gt; m = MapLibreMap()\n&gt;&gt;&gt; m.add_geojson_layer(\n...     \"https://example.com/data.geojson\",\n...     get_fill_color=[255, 0, 0, 128],\n... )\n</code></pre> Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def add_geojson_layer(\n    self,\n    data: Any,\n    name: Optional[str] = None,\n    get_fill_color: Optional[Union[List[int], str]] = None,\n    get_line_color: Optional[Union[List[int], str]] = None,\n    get_line_width: Union[float, str] = 1,\n    get_point_radius: Union[float, str] = 5,\n    get_elevation: Union[float, str] = 0,\n    extruded: bool = False,\n    wireframe: bool = False,\n    filled: bool = True,\n    stroked: bool = True,\n    line_width_min_pixels: float = 1,\n    point_radius_min_pixels: float = 2,\n    pickable: bool = True,\n    opacity: float = 0.8,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a GeoJSON layer with auto-styling using deck.gl.\n\n    GeoJSON layers render GeoJSON features with automatic geometry type\n    detection and styling, supporting points, lines, and polygons.\n\n    Args:\n        data: GeoJSON object, URL, or file path.\n        name: Layer ID. If None, auto-generated.\n        get_fill_color: Accessor for fill color [r, g, b, a].\n            Default: [51, 136, 255, 128].\n        get_line_color: Accessor for stroke color [r, g, b, a].\n            Default: [0, 0, 0, 255].\n        get_line_width: Accessor for stroke width.\n        get_point_radius: Accessor for point radius.\n        get_elevation: Accessor for 3D extrusion height.\n        extruded: Whether to render as 3D features.\n        wireframe: Whether to render wireframe (extruded only).\n        filled: Whether to fill features.\n        stroked: Whether to draw stroke.\n        line_width_min_pixels: Minimum stroke width in pixels.\n        point_radius_min_pixels: Minimum point radius in pixels.\n        pickable: Whether layer responds to hover/click events.\n        opacity: Layer opacity (0-1).\n        **kwargs: Additional GeoJsonLayer props.\n\n    Example:\n        &gt;&gt;&gt; from anymap_ts import MapLibreMap\n        &gt;&gt;&gt; m = MapLibreMap()\n        &gt;&gt;&gt; m.add_geojson_layer(\n        ...     \"https://example.com/data.geojson\",\n        ...     get_fill_color=[255, 0, 0, 128],\n        ... )\n    \"\"\"\n    layer_id = name or f\"geojson-deck-{len(self._layers)}\"\n    processed_data = self._process_deck_data(data)\n\n    self.call_js_method(\n        \"addGeoJsonLayer\",\n        id=layer_id,\n        data=processed_data,\n        getFillColor=get_fill_color or [51, 136, 255, 128],\n        getLineColor=get_line_color or [0, 0, 0, 255],\n        getLineWidth=get_line_width,\n        getPointRadius=get_point_radius,\n        getElevation=get_elevation,\n        extruded=extruded,\n        wireframe=wireframe,\n        filled=filled,\n        stroked=stroked,\n        lineWidthMinPixels=line_width_min_pixels,\n        pointRadiusMinPixels=point_radius_min_pixels,\n        pickable=pickable,\n        opacity=opacity,\n        **kwargs,\n    )\n\n    self._layers = {\n        **self._layers,\n        layer_id: {\n            \"id\": layer_id,\n            \"type\": \"geojson-deck\",\n        },\n    }\n    self._add_to_layer_dict(layer_id, \"Deck.gl\")\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.maplibre.MapLibreMap.add_grid_cell_layer","title":"<code>add_grid_cell_layer(self, data, name=None, get_position='coordinates', get_color=None, get_elevation=1000, cell_size=200, coverage=1, elevation_scale=1, extruded=True, pickable=True, opacity=0.8, **kwargs)</code>","text":"<p>Add a grid cell layer for pre-aggregated grid visualization using deck.gl.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>Array of data objects with position coordinates.</p> required <code>name</code> <code>Optional[str]</code> <p>Layer ID. If None, auto-generated.</p> <code>None</code> <code>get_position</code> <code>Union[str, Any]</code> <p>Accessor for cell position [lng, lat].</p> <code>'coordinates'</code> <code>get_color</code> <code>Optional[Union[List[int], str]]</code> <p>Accessor for cell color [r, g, b, a].</p> <code>None</code> <code>get_elevation</code> <code>Union[float, str]</code> <p>Accessor for cell height.</p> <code>1000</code> <code>cell_size</code> <code>float</code> <p>Cell size in meters.</p> <code>200</code> <code>coverage</code> <code>float</code> <p>Cell coverage (0-1).</p> <code>1</code> <code>elevation_scale</code> <code>float</code> <p>Elevation multiplier.</p> <code>1</code> <code>extruded</code> <code>bool</code> <p>Whether to extrude cells.</p> <code>True</code> <code>pickable</code> <code>bool</code> <p>Whether layer responds to hover/click events.</p> <code>True</code> <code>opacity</code> <code>float</code> <p>Layer opacity (0-1).</p> <code>0.8</code> <code>**kwargs</code> <p>Additional GridCellLayer props.</p> <code>{}</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from anymap_ts import MapLibreMap\n&gt;&gt;&gt; m = MapLibreMap(pitch=45)\n&gt;&gt;&gt; data = [\n...     {\"coordinates\": [-122.4, 37.8], \"value\": 500},\n... ]\n&gt;&gt;&gt; m.add_grid_cell_layer(data, get_elevation=\"value\")\n</code></pre> Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def add_grid_cell_layer(\n    self,\n    data: Any,\n    name: Optional[str] = None,\n    get_position: Union[str, Any] = \"coordinates\",\n    get_color: Optional[Union[List[int], str]] = None,\n    get_elevation: Union[float, str] = 1000,\n    cell_size: float = 200,\n    coverage: float = 1,\n    elevation_scale: float = 1,\n    extruded: bool = True,\n    pickable: bool = True,\n    opacity: float = 0.8,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a grid cell layer for pre-aggregated grid visualization using deck.gl.\n\n    Args:\n        data: Array of data objects with position coordinates.\n        name: Layer ID. If None, auto-generated.\n        get_position: Accessor for cell position [lng, lat].\n        get_color: Accessor for cell color [r, g, b, a].\n        get_elevation: Accessor for cell height.\n        cell_size: Cell size in meters.\n        coverage: Cell coverage (0-1).\n        elevation_scale: Elevation multiplier.\n        extruded: Whether to extrude cells.\n        pickable: Whether layer responds to hover/click events.\n        opacity: Layer opacity (0-1).\n        **kwargs: Additional GridCellLayer props.\n\n    Example:\n        &gt;&gt;&gt; from anymap_ts import MapLibreMap\n        &gt;&gt;&gt; m = MapLibreMap(pitch=45)\n        &gt;&gt;&gt; data = [\n        ...     {\"coordinates\": [-122.4, 37.8], \"value\": 500},\n        ... ]\n        &gt;&gt;&gt; m.add_grid_cell_layer(data, get_elevation=\"value\")\n    \"\"\"\n    layer_id = name or f\"gridcell-{len(self._layers)}\"\n    processed_data = self._process_deck_data(data)\n\n    self.call_js_method(\n        \"addGridCellLayer\",\n        id=layer_id,\n        data=processed_data,\n        getPosition=get_position,\n        getColor=get_color or [255, 140, 0, 200],\n        getElevation=get_elevation,\n        cellSize=cell_size,\n        coverage=coverage,\n        elevationScale=elevation_scale,\n        extruded=extruded,\n        pickable=pickable,\n        opacity=opacity,\n        **kwargs,\n    )\n\n    self._layers = {\n        **self._layers,\n        layer_id: {\"id\": layer_id, \"type\": \"gridcell\"},\n    }\n    self._add_to_layer_dict(layer_id, \"Deck.gl\")\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.maplibre.MapLibreMap.add_grid_layer","title":"<code>add_grid_layer(self, data, name=None, get_position='coordinates', cell_size=200, elevation_scale=4, extruded=True, color_range=None, pickable=True, opacity=0.8, **kwargs)</code>","text":"<p>Add a grid layer for square grid aggregation using deck.gl.</p> <p>Grid layers aggregate points into square grid cells and render them with height and color based on point density.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>Array of data objects with position coordinates.</p> required <code>name</code> <code>Optional[str]</code> <p>Layer ID. If None, auto-generated.</p> <code>None</code> <code>get_position</code> <code>Union[str, Any]</code> <p>Accessor for point position [lng, lat].</p> <code>'coordinates'</code> <code>cell_size</code> <code>float</code> <p>Grid cell size in meters.</p> <code>200</code> <code>elevation_scale</code> <code>float</code> <p>Elevation multiplier for 3D cells.</p> <code>4</code> <code>extruded</code> <code>bool</code> <p>Whether to render as 3D cells.</p> <code>True</code> <code>color_range</code> <code>Optional[List[List[int]]]</code> <p>Color gradient [[r, g, b], ...].</p> <code>None</code> <code>pickable</code> <code>bool</code> <p>Whether layer responds to hover/click events.</p> <code>True</code> <code>opacity</code> <code>float</code> <p>Layer opacity (0-1).</p> <code>0.8</code> <code>**kwargs</code> <p>Additional GridLayer props.</p> <code>{}</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from anymap_ts import MapLibreMap\n&gt;&gt;&gt; m = MapLibreMap(pitch=45)\n&gt;&gt;&gt; points = [\n...     {\"coordinates\": [-122.4, 37.8]},\n...     {\"coordinates\": [-122.41, 37.81]},\n... ]\n&gt;&gt;&gt; m.add_grid_layer(points, cell_size=500)\n</code></pre> Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def add_grid_layer(\n    self,\n    data: Any,\n    name: Optional[str] = None,\n    get_position: Union[str, Any] = \"coordinates\",\n    cell_size: float = 200,\n    elevation_scale: float = 4,\n    extruded: bool = True,\n    color_range: Optional[List[List[int]]] = None,\n    pickable: bool = True,\n    opacity: float = 0.8,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a grid layer for square grid aggregation using deck.gl.\n\n    Grid layers aggregate points into square grid cells and render them\n    with height and color based on point density.\n\n    Args:\n        data: Array of data objects with position coordinates.\n        name: Layer ID. If None, auto-generated.\n        get_position: Accessor for point position [lng, lat].\n        cell_size: Grid cell size in meters.\n        elevation_scale: Elevation multiplier for 3D cells.\n        extruded: Whether to render as 3D cells.\n        color_range: Color gradient [[r, g, b], ...].\n        pickable: Whether layer responds to hover/click events.\n        opacity: Layer opacity (0-1).\n        **kwargs: Additional GridLayer props.\n\n    Example:\n        &gt;&gt;&gt; from anymap_ts import MapLibreMap\n        &gt;&gt;&gt; m = MapLibreMap(pitch=45)\n        &gt;&gt;&gt; points = [\n        ...     {\"coordinates\": [-122.4, 37.8]},\n        ...     {\"coordinates\": [-122.41, 37.81]},\n        ... ]\n        &gt;&gt;&gt; m.add_grid_layer(points, cell_size=500)\n    \"\"\"\n    layer_id = name or f\"grid-{len(self._layers)}\"\n    processed_data = self._process_deck_data(data)\n\n    default_color_range = [\n        [1, 152, 189],\n        [73, 227, 206],\n        [216, 254, 181],\n        [254, 237, 177],\n        [254, 173, 84],\n        [209, 55, 78],\n    ]\n\n    self.call_js_method(\n        \"addGridLayer\",\n        id=layer_id,\n        data=processed_data,\n        getPosition=get_position,\n        cellSize=cell_size,\n        elevationScale=elevation_scale,\n        extruded=extruded,\n        colorRange=color_range or default_color_range,\n        pickable=pickable,\n        opacity=opacity,\n        **kwargs,\n    )\n\n    self._layers = {\n        **self._layers,\n        layer_id: {\n            \"id\": layer_id,\n            \"type\": \"grid\",\n        },\n    }\n    self._add_to_layer_dict(layer_id, \"Deck.gl\")\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.maplibre.MapLibreMap.add_heatmap","title":"<code>add_heatmap(self, data, weight_property=None, radius=20, intensity=1.0, colormap=None, opacity=0.8, name=None, fit_bounds=True, **kwargs)</code>","text":"<p>Add a heatmap layer to the map.</p> <p>Creates a heatmap visualization from point data using MapLibre's native heatmap layer type.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>Point data - can be GeoJSON, GeoDataFrame, or file path.</p> required <code>weight_property</code> <code>Optional[str]</code> <p>Property name to use for point weights. If None, all points have equal weight.</p> <code>None</code> <code>radius</code> <code>int</code> <p>Radius of influence for each point in pixels.</p> <code>20</code> <code>intensity</code> <code>float</code> <p>Intensity multiplier for the heatmap.</p> <code>1.0</code> <code>colormap</code> <code>Optional[List]</code> <p>Color gradient as list of [stop, color] pairs. Example: [[0, \"blue\"], [0.5, \"yellow\"], [1, \"red\"]] Default: blue-yellow-red gradient.</p> <code>None</code> <code>opacity</code> <code>float</code> <p>Layer opacity (0-1).</p> <code>0.8</code> <code>name</code> <code>Optional[str]</code> <p>Layer identifier. If None, auto-generated.</p> <code>None</code> <code>fit_bounds</code> <code>bool</code> <p>Whether to fit map to data bounds.</p> <code>True</code> <code>**kwargs</code> <p>Additional heatmap layer options.</p> <code>{}</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from anymap_ts import Map\n&gt;&gt;&gt; m = Map()\n&gt;&gt;&gt; m.add_heatmap(\n...     \"earthquakes.geojson\",\n...     weight_property=\"magnitude\",\n...     radius=30,\n...     colormap=[[0, \"blue\"], [0.5, \"lime\"], [1, \"red\"]]\n... )\n</code></pre> Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def add_heatmap(\n    self,\n    data: Any,\n    weight_property: Optional[str] = None,\n    radius: int = 20,\n    intensity: float = 1.0,\n    colormap: Optional[List] = None,\n    opacity: float = 0.8,\n    name: Optional[str] = None,\n    fit_bounds: bool = True,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a heatmap layer to the map.\n\n    Creates a heatmap visualization from point data using MapLibre's\n    native heatmap layer type.\n\n    Args:\n        data: Point data - can be GeoJSON, GeoDataFrame, or file path.\n        weight_property: Property name to use for point weights.\n            If None, all points have equal weight.\n        radius: Radius of influence for each point in pixels.\n        intensity: Intensity multiplier for the heatmap.\n        colormap: Color gradient as list of [stop, color] pairs.\n            Example: [[0, \"blue\"], [0.5, \"yellow\"], [1, \"red\"]]\n            Default: blue-yellow-red gradient.\n        opacity: Layer opacity (0-1).\n        name: Layer identifier. If None, auto-generated.\n        fit_bounds: Whether to fit map to data bounds.\n        **kwargs: Additional heatmap layer options.\n\n    Example:\n        &gt;&gt;&gt; from anymap_ts import Map\n        &gt;&gt;&gt; m = Map()\n        &gt;&gt;&gt; m.add_heatmap(\n        ...     \"earthquakes.geojson\",\n        ...     weight_property=\"magnitude\",\n        ...     radius=30,\n        ...     colormap=[[0, \"blue\"], [0.5, \"lime\"], [1, \"red\"]]\n        ... )\n    \"\"\"\n    self._validate_opacity(opacity)\n    layer_id = name or f\"heatmap-{len(self._layers)}\"\n\n    # Convert data to GeoJSON\n    geojson = to_geojson(data)\n\n    # Handle URL data - fetch GeoJSON\n    if geojson.get(\"type\") == \"url\":\n        url = geojson[\"url\"]\n        geojson = fetch_geojson(url)\n\n    # Default colormap\n    if colormap is None:\n        colormap = [\n            [0, \"rgba(33,102,172,0)\"],\n            [0.2, \"rgb(103,169,207)\"],\n            [0.4, \"rgb(209,229,240)\"],\n            [0.6, \"rgb(253,219,199)\"],\n            [0.8, \"rgb(239,138,98)\"],\n            [1, \"rgb(178,24,43)\"],\n        ]\n\n    # Build heatmap paint properties\n    paint = {\n        \"heatmap-radius\": radius,\n        \"heatmap-intensity\": intensity,\n        \"heatmap-opacity\": opacity,\n        \"heatmap-color\": [\n            \"interpolate\",\n            [\"linear\"],\n            [\"heatmap-density\"],\n        ],\n    }\n\n    # Add colormap stops\n    for stop, color in colormap:\n        paint[\"heatmap-color\"].extend([stop, color])\n\n    # Add weight if specified\n    if weight_property:\n        paint[\"heatmap-weight\"] = [\"get\", weight_property]\n\n    # Get bounds\n    bounds = get_bounds(geojson) if fit_bounds else None\n\n    self.call_js_method(\n        \"addGeoJSON\",\n        data=geojson,\n        name=layer_id,\n        layerType=\"heatmap\",\n        paint=paint,\n        fitBounds=fit_bounds,\n        bounds=bounds,\n        **kwargs,\n    )\n\n    self._layers = {\n        **self._layers,\n        layer_id: {\n            \"id\": layer_id,\n            \"type\": \"heatmap\",\n            \"source\": f\"{layer_id}-source\",\n            \"paint\": paint,\n        },\n    }\n    self._add_to_layer_dict(layer_id, \"Heatmap\")\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.maplibre.MapLibreMap.add_hexagon_layer","title":"<code>add_hexagon_layer(self, data, name=None, get_position='coordinates', radius=1000, elevation_scale=4, extruded=True, color_range=None, pickable=True, opacity=0.8, **kwargs)</code>","text":"<p>Add a hexagon layer for hexagonal binning/aggregation using deck.gl.</p> <p>Hexagon layers aggregate points into hexagonal bins and render them with height and color based on point density.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>Array of data objects with position coordinates.</p> required <code>name</code> <code>Optional[str]</code> <p>Layer ID. If None, auto-generated.</p> <code>None</code> <code>get_position</code> <code>Union[str, Any]</code> <p>Accessor for point position [lng, lat].</p> <code>'coordinates'</code> <code>radius</code> <code>float</code> <p>Hexagon radius in meters.</p> <code>1000</code> <code>elevation_scale</code> <code>float</code> <p>Elevation multiplier for 3D hexagons.</p> <code>4</code> <code>extruded</code> <code>bool</code> <p>Whether to render as 3D hexagons.</p> <code>True</code> <code>color_range</code> <code>Optional[List[List[int]]]</code> <p>Color gradient for aggregation [[r, g, b], ...].</p> <code>None</code> <code>pickable</code> <code>bool</code> <p>Whether layer responds to hover/click events.</p> <code>True</code> <code>opacity</code> <code>float</code> <p>Layer opacity (0-1).</p> <code>0.8</code> <code>**kwargs</code> <p>Additional HexagonLayer props.</p> <code>{}</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from anymap_ts import MapLibreMap\n&gt;&gt;&gt; m = MapLibreMap(pitch=45)\n&gt;&gt;&gt; points = [\n...     {\"coordinates\": [-122.4, 37.8]},\n...     {\"coordinates\": [-122.41, 37.81]},\n... ]\n&gt;&gt;&gt; m.add_hexagon_layer(points, radius=500, elevation_scale=10)\n</code></pre> Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def add_hexagon_layer(\n    self,\n    data: Any,\n    name: Optional[str] = None,\n    get_position: Union[str, Any] = \"coordinates\",\n    radius: float = 1000,\n    elevation_scale: float = 4,\n    extruded: bool = True,\n    color_range: Optional[List[List[int]]] = None,\n    pickable: bool = True,\n    opacity: float = 0.8,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a hexagon layer for hexagonal binning/aggregation using deck.gl.\n\n    Hexagon layers aggregate points into hexagonal bins and render them\n    with height and color based on point density.\n\n    Args:\n        data: Array of data objects with position coordinates.\n        name: Layer ID. If None, auto-generated.\n        get_position: Accessor for point position [lng, lat].\n        radius: Hexagon radius in meters.\n        elevation_scale: Elevation multiplier for 3D hexagons.\n        extruded: Whether to render as 3D hexagons.\n        color_range: Color gradient for aggregation [[r, g, b], ...].\n        pickable: Whether layer responds to hover/click events.\n        opacity: Layer opacity (0-1).\n        **kwargs: Additional HexagonLayer props.\n\n    Example:\n        &gt;&gt;&gt; from anymap_ts import MapLibreMap\n        &gt;&gt;&gt; m = MapLibreMap(pitch=45)\n        &gt;&gt;&gt; points = [\n        ...     {\"coordinates\": [-122.4, 37.8]},\n        ...     {\"coordinates\": [-122.41, 37.81]},\n        ... ]\n        &gt;&gt;&gt; m.add_hexagon_layer(points, radius=500, elevation_scale=10)\n    \"\"\"\n    layer_id = name or f\"hexagon-{len(self._layers)}\"\n    processed_data = self._process_deck_data(data)\n\n    default_color_range = [\n        [1, 152, 189],\n        [73, 227, 206],\n        [216, 254, 181],\n        [254, 237, 177],\n        [254, 173, 84],\n        [209, 55, 78],\n    ]\n\n    self.call_js_method(\n        \"addHexagonLayer\",\n        id=layer_id,\n        data=processed_data,\n        getPosition=get_position,\n        radius=radius,\n        elevationScale=elevation_scale,\n        extruded=extruded,\n        colorRange=color_range or default_color_range,\n        pickable=pickable,\n        opacity=opacity,\n        **kwargs,\n    )\n\n    self._layers = {\n        **self._layers,\n        layer_id: {\n            \"id\": layer_id,\n            \"type\": \"hexagon\",\n        },\n    }\n    self._add_to_layer_dict(layer_id, \"Deck.gl\")\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.maplibre.MapLibreMap.add_hover_effect","title":"<code>add_hover_effect(self, layer_id, highlight_color=None, highlight_opacity=None, highlight_outline_width=2, **kwargs)</code>","text":"<p>Add hover highlight effect to an existing layer.</p> <p>When the mouse hovers over a feature, it will be highlighted with the specified styles.</p> <p>Parameters:</p> Name Type Description Default <code>layer_id</code> <code>str</code> <p>Layer identifier to add hover effect to.</p> required <code>highlight_color</code> <code>Optional[str]</code> <p>Override fill/line color on hover. If None, the original color is kept but opacity/outline changes.</p> <code>None</code> <code>highlight_opacity</code> <code>Optional[float]</code> <p>Override opacity on hover.</p> <code>None</code> <code>highlight_outline_width</code> <code>float</code> <p>Outline width on hover.</p> <code>2</code> <code>**kwargs</code> <p>Additional hover effect options.</p> <code>{}</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from anymap_ts import Map\n&gt;&gt;&gt; m = Map()\n&gt;&gt;&gt; m.add_geojson(\"states.geojson\", name=\"states\")\n&gt;&gt;&gt; m.add_hover_effect(\"states\", highlight_opacity=0.9)\n</code></pre> Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def add_hover_effect(\n    self,\n    layer_id: str,\n    highlight_color: Optional[str] = None,\n    highlight_opacity: Optional[float] = None,\n    highlight_outline_width: float = 2,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add hover highlight effect to an existing layer.\n\n    When the mouse hovers over a feature, it will be highlighted with\n    the specified styles.\n\n    Args:\n        layer_id: Layer identifier to add hover effect to.\n        highlight_color: Override fill/line color on hover. If None,\n            the original color is kept but opacity/outline changes.\n        highlight_opacity: Override opacity on hover.\n        highlight_outline_width: Outline width on hover.\n        **kwargs: Additional hover effect options.\n\n    Example:\n        &gt;&gt;&gt; from anymap_ts import Map\n        &gt;&gt;&gt; m = Map()\n        &gt;&gt;&gt; m.add_geojson(\"states.geojson\", name=\"states\")\n        &gt;&gt;&gt; m.add_hover_effect(\"states\", highlight_opacity=0.9)\n    \"\"\"\n    self.call_js_method(\n        \"addHoverEffect\",\n        layerId=layer_id,\n        highlightColor=highlight_color,\n        highlightOpacity=highlight_opacity,\n        highlightOutlineWidth=highlight_outline_width,\n        **kwargs,\n    )\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.maplibre.MapLibreMap.add_icon_layer","title":"<code>add_icon_layer(self, data, name=None, get_position='coordinates', get_icon='icon', get_size=20, get_color=None, icon_atlas=None, icon_mapping=None, pickable=True, opacity=1, **kwargs)</code>","text":"<p>Add an icon layer for custom icon markers at scale using deck.gl.</p> <p>Icon layers render icons/images at specified positions, ideal for rendering large numbers of custom markers efficiently.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>Array of data objects with position coordinates.</p> required <code>name</code> <code>Optional[str]</code> <p>Layer ID. If None, auto-generated.</p> <code>None</code> <code>get_position</code> <code>Union[str, Any]</code> <p>Accessor for icon position [lng, lat].</p> <code>'coordinates'</code> <code>get_icon</code> <code>Union[str, Any]</code> <p>Accessor for icon name in icon_mapping.</p> <code>'icon'</code> <code>get_size</code> <code>Union[float, str]</code> <p>Accessor for icon size in pixels.</p> <code>20</code> <code>get_color</code> <code>Optional[Union[List[int], str]]</code> <p>Accessor for icon tint color [r, g, b, a]. Default: [255, 255, 255, 255] (white, no tint).</p> <code>None</code> <code>icon_atlas</code> <code>Optional[str]</code> <p>URL to icon atlas image.</p> <code>None</code> <code>icon_mapping</code> <code>Optional[Dict]</code> <p>Dict mapping icon names to atlas coordinates.</p> <code>None</code> <code>pickable</code> <code>bool</code> <p>Whether layer responds to hover/click events.</p> <code>True</code> <code>opacity</code> <code>float</code> <p>Layer opacity (0-1).</p> <code>1</code> <code>**kwargs</code> <p>Additional IconLayer props.</p> <code>{}</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from anymap_ts import MapLibreMap\n&gt;&gt;&gt; m = MapLibreMap()\n&gt;&gt;&gt; markers = [\n...     {\"coordinates\": [-122.4, 37.8], \"icon\": \"marker\", \"size\": 30},\n... ]\n&gt;&gt;&gt; m.add_icon_layer(markers, get_size=\"size\")\n</code></pre> Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def add_icon_layer(\n    self,\n    data: Any,\n    name: Optional[str] = None,\n    get_position: Union[str, Any] = \"coordinates\",\n    get_icon: Union[str, Any] = \"icon\",\n    get_size: Union[float, str] = 20,\n    get_color: Optional[Union[List[int], str]] = None,\n    icon_atlas: Optional[str] = None,\n    icon_mapping: Optional[Dict] = None,\n    pickable: bool = True,\n    opacity: float = 1,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add an icon layer for custom icon markers at scale using deck.gl.\n\n    Icon layers render icons/images at specified positions, ideal for\n    rendering large numbers of custom markers efficiently.\n\n    Args:\n        data: Array of data objects with position coordinates.\n        name: Layer ID. If None, auto-generated.\n        get_position: Accessor for icon position [lng, lat].\n        get_icon: Accessor for icon name in icon_mapping.\n        get_size: Accessor for icon size in pixels.\n        get_color: Accessor for icon tint color [r, g, b, a].\n            Default: [255, 255, 255, 255] (white, no tint).\n        icon_atlas: URL to icon atlas image.\n        icon_mapping: Dict mapping icon names to atlas coordinates.\n        pickable: Whether layer responds to hover/click events.\n        opacity: Layer opacity (0-1).\n        **kwargs: Additional IconLayer props.\n\n    Example:\n        &gt;&gt;&gt; from anymap_ts import MapLibreMap\n        &gt;&gt;&gt; m = MapLibreMap()\n        &gt;&gt;&gt; markers = [\n        ...     {\"coordinates\": [-122.4, 37.8], \"icon\": \"marker\", \"size\": 30},\n        ... ]\n        &gt;&gt;&gt; m.add_icon_layer(markers, get_size=\"size\")\n    \"\"\"\n    layer_id = name or f\"icon-{len(self._layers)}\"\n    processed_data = self._process_deck_data(data)\n\n    self.call_js_method(\n        \"addIconLayer\",\n        id=layer_id,\n        data=processed_data,\n        getPosition=get_position,\n        getIcon=get_icon,\n        getSize=get_size,\n        getColor=get_color or [255, 255, 255, 255],\n        iconAtlas=icon_atlas,\n        iconMapping=icon_mapping,\n        pickable=pickable,\n        opacity=opacity,\n        **kwargs,\n    )\n\n    self._layers = {\n        **self._layers,\n        layer_id: {\n            \"id\": layer_id,\n            \"type\": \"icon\",\n        },\n    }\n    self._add_to_layer_dict(layer_id, \"Deck.gl\")\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.maplibre.MapLibreMap.add_image","title":"<code>add_image(self, name, url)</code>","text":"<p>Load a custom icon image for use in symbol layers.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name to reference this image in symbol layers.</p> required <code>url</code> <code>str</code> <p>URL to the image file (PNG, JPEG, etc.).</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; m = MapLibreMap()\n&gt;&gt;&gt; m.add_image(\"custom-marker\", \"https://example.com/marker.png\")\n</code></pre> Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def add_image(self, name: str, url: str) -&gt; None:\n    \"\"\"Load a custom icon image for use in symbol layers.\n\n    Args:\n        name: Name to reference this image in symbol layers.\n        url: URL to the image file (PNG, JPEG, etc.).\n\n    Example:\n        &gt;&gt;&gt; m = MapLibreMap()\n        &gt;&gt;&gt; m.add_image(\"custom-marker\", \"https://example.com/marker.png\")\n    \"\"\"\n    self.call_js_method(\"addMapImage\", name=name, url=url)\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.maplibre.MapLibreMap.add_image_layer","title":"<code>add_image_layer(self, url, coordinates, name=None, opacity=1.0, **kwargs)</code>","text":"<p>Add a georeferenced image overlay.</p> <p>Overlays an image on the map at specified geographic coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>URL to the image file.</p> required <code>coordinates</code> <code>List[List[float]]</code> <p>Four corner coordinates as [[lng, lat], ...] in order: top-left, top-right, bottom-right, bottom-left.</p> required <code>name</code> <code>Optional[str]</code> <p>Layer identifier. If None, auto-generated.</p> <code>None</code> <code>opacity</code> <code>float</code> <p>Layer opacity (0-1).</p> <code>1.0</code> <code>**kwargs</code> <p>Additional layer options.</p> <code>{}</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from anymap_ts import Map\n&gt;&gt;&gt; m = Map()\n&gt;&gt;&gt; m.add_image_layer(\n...     url=\"https://example.com/overlay.png\",\n...     coordinates=[\n...         [-80.425, 46.437],  # top-left\n...         [-71.516, 46.437],  # top-right\n...         [-71.516, 37.936],  # bottom-right\n...         [-80.425, 37.936],  # bottom-left\n...     ]\n... )\n</code></pre> Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def add_image_layer(\n    self,\n    url: str,\n    coordinates: List[List[float]],\n    name: Optional[str] = None,\n    opacity: float = 1.0,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a georeferenced image overlay.\n\n    Overlays an image on the map at specified geographic coordinates.\n\n    Args:\n        url: URL to the image file.\n        coordinates: Four corner coordinates as [[lng, lat], ...] in order:\n            top-left, top-right, bottom-right, bottom-left.\n        name: Layer identifier. If None, auto-generated.\n        opacity: Layer opacity (0-1).\n        **kwargs: Additional layer options.\n\n    Example:\n        &gt;&gt;&gt; from anymap_ts import Map\n        &gt;&gt;&gt; m = Map()\n        &gt;&gt;&gt; m.add_image_layer(\n        ...     url=\"https://example.com/overlay.png\",\n        ...     coordinates=[\n        ...         [-80.425, 46.437],  # top-left\n        ...         [-71.516, 46.437],  # top-right\n        ...         [-71.516, 37.936],  # bottom-right\n        ...         [-80.425, 37.936],  # bottom-left\n        ...     ]\n        ... )\n    \"\"\"\n    self._validate_opacity(opacity)\n    layer_id = name or f\"image-{len(self._layers)}\"\n\n    if len(coordinates) != 4:\n        raise ValueError(\n            \"coordinates must have exactly 4 corner points \"\n            \"[top-left, top-right, bottom-right, bottom-left]\"\n        )\n\n    self.call_js_method(\n        \"addImageLayer\",\n        id=layer_id,\n        url=url,\n        coordinates=coordinates,\n        opacity=opacity,\n        **kwargs,\n    )\n\n    self._layers = {\n        **self._layers,\n        layer_id: {\n            \"id\": layer_id,\n            \"type\": \"image\",\n            \"url\": url,\n            \"coordinates\": coordinates,\n        },\n    }\n    self._add_to_layer_dict(layer_id, \"Raster\")\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.maplibre.MapLibreMap.add_layer","title":"<code>add_layer(self, layer_id, layer_type, source, paint=None, layout=None, before_id=None, **kwargs)</code>","text":"<p>Add a generic layer to the map.</p> <p>Parameters:</p> Name Type Description Default <code>layer_id</code> <code>str</code> <p>Unique layer identifier</p> required <code>layer_type</code> <code>str</code> <p>MapLibre layer type</p> required <code>source</code> <code>Union[str, Dict]</code> <p>Source ID or source configuration dict</p> required <code>paint</code> <code>Optional[Dict]</code> <p>Paint properties</p> <code>None</code> <code>layout</code> <code>Optional[Dict]</code> <p>Layout properties</p> <code>None</code> <code>before_id</code> <code>Optional[str]</code> <p>ID of layer to insert before</p> <code>None</code> <code>**kwargs</code> <p>Additional layer options</p> <code>{}</code> Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def add_layer(\n    self,\n    layer_id: str,\n    layer_type: str,\n    source: Union[str, Dict],\n    paint: Optional[Dict] = None,\n    layout: Optional[Dict] = None,\n    before_id: Optional[str] = None,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a generic layer to the map.\n\n    Args:\n        layer_id: Unique layer identifier\n        layer_type: MapLibre layer type\n        source: Source ID or source configuration dict\n        paint: Paint properties\n        layout: Layout properties\n        before_id: ID of layer to insert before\n        **kwargs: Additional layer options\n    \"\"\"\n    layer_config = {\n        \"id\": layer_id,\n        \"type\": layer_type,\n        \"paint\": paint or {},\n        \"layout\": layout or {},\n        **kwargs,\n    }\n\n    if isinstance(source, str):\n        layer_config[\"source\"] = source\n    else:\n        source_id = f\"{layer_id}-source\"\n        self._sources = {**self._sources, source_id: source}\n        self.call_js_method(\"addSource\", source_id, **source)\n        layer_config[\"source\"] = source_id\n\n    self._layers = {**self._layers, layer_id: layer_config}\n    self.call_js_method(\"addLayer\", beforeId=before_id, **layer_config)\n    # Determine category based on layer type\n    layer_type = layer_config.get(\"type\", \"\")\n    if layer_type == \"raster\":\n        self._add_to_layer_dict(layer_id, \"Raster\")\n    else:\n        self._add_to_layer_dict(layer_id, \"Vector\")\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.maplibre.MapLibreMap.add_layer_control","title":"<code>add_layer_control(self, layers=None, position='top-right', collapsed=True)</code>","text":"<p>Add a layer visibility control.</p> <p>Uses maplibre-gl-layer-control for layer toggling and opacity.</p> <p>Parameters:</p> Name Type Description Default <code>layers</code> <code>Optional[List[str]]</code> <p>List of layer IDs to include (None = all layers)</p> <code>None</code> <code>position</code> <code>str</code> <p>Control position</p> <code>'top-right'</code> <code>collapsed</code> <code>bool</code> <p>Whether control starts collapsed</p> <code>True</code> Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def add_layer_control(\n    self,\n    layers: Optional[List[str]] = None,\n    position: str = \"top-right\",\n    collapsed: bool = True,\n) -&gt; None:\n    \"\"\"Add a layer visibility control.\n\n    Uses maplibre-gl-layer-control for layer toggling and opacity.\n\n    Args:\n        layers: List of layer IDs to include (None = all layers)\n        position: Control position\n        collapsed: Whether control starts collapsed\n    \"\"\"\n    if layers is None:\n        layers = list(self._layers.keys())\n\n    self.call_js_method(\n        \"addLayerControl\",\n        layers=layers,\n        position=position,\n        collapsed=collapsed,\n    )\n    self._controls = {\n        **self._controls,\n        \"layer-control\": {\n            \"layers\": layers,\n            \"position\": position,\n            \"collapsed\": collapsed,\n        },\n    }\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.maplibre.MapLibreMap.add_legend","title":"<code>add_legend(self, title, labels, colors, position='bottom-right', opacity=1.0, legend_id=None, **kwargs)</code>","text":"<p>Add a floating legend control to the map.</p> <p>Creates a custom legend control with colored boxes and labels that floats over the map in the specified position.</p> <p>Parameters:</p> Name Type Description Default <code>title</code> <code>str</code> <p>Legend title text</p> required <code>labels</code> <code>List[str]</code> <p>List of label strings for each legend item</p> required <code>colors</code> <code>List[str]</code> <p>List of hex color strings (e.g., ['#ff0000', '#00ff00', '#0000ff'])</p> required <code>position</code> <code>str</code> <p>Legend position ('top-left', 'top-right', 'bottom-left', 'bottom-right')</p> <code>'bottom-right'</code> <code>opacity</code> <code>float</code> <p>Legend background opacity (0-1)</p> <code>1.0</code> <code>legend_id</code> <code>Optional[str]</code> <p>Custom legend identifier (auto-generated if None)</p> <code>None</code> <code>**kwargs</code> <p>Additional legend styling options</p> <code>{}</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from anymap_ts import Map\n&gt;&gt;&gt; m = Map()\n&gt;&gt;&gt; m.add_legend(\n...     title=\"Land Cover\",\n...     labels=[\"Forest\", \"Water\", \"Urban\"],\n...     colors=[\"#228B22\", \"#0000FF\", \"#808080\"],\n...     position=\"top-left\"\n... )\n</code></pre> Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def add_legend(\n    self,\n    title: str,\n    labels: List[str],\n    colors: List[str],\n    position: str = \"bottom-right\",\n    opacity: float = 1.0,\n    legend_id: Optional[str] = None,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a floating legend control to the map.\n\n    Creates a custom legend control with colored boxes and labels that\n    floats over the map in the specified position.\n\n    Args:\n        title: Legend title text\n        labels: List of label strings for each legend item\n        colors: List of hex color strings (e.g., ['#ff0000', '#00ff00', '#0000ff'])\n        position: Legend position ('top-left', 'top-right', 'bottom-left', 'bottom-right')\n        opacity: Legend background opacity (0-1)\n        legend_id: Custom legend identifier (auto-generated if None)\n        **kwargs: Additional legend styling options\n\n    Example:\n        &gt;&gt;&gt; from anymap_ts import Map\n        &gt;&gt;&gt; m = Map()\n        &gt;&gt;&gt; m.add_legend(\n        ...     title=\"Land Cover\",\n        ...     labels=[\"Forest\", \"Water\", \"Urban\"],\n        ...     colors=[\"#228B22\", \"#0000FF\", \"#808080\"],\n        ...     position=\"top-left\"\n        ... )\n    \"\"\"\n    if len(labels) != len(colors):\n        raise ValueError(\"Number of labels must match number of colors\")\n\n    # Validate position\n    self._validate_position(position)\n\n    # Validate colors (basic hex color check)\n    for i, color in enumerate(colors):\n        if not isinstance(color, str) or not color.startswith(\"#\"):\n            raise ValueError(\n                f\"Color at index {i} must be a hex color string (e.g., '#ff0000')\"\n            )\n\n    legend_id = (\n        legend_id\n        or f\"legend-{len([k for k in self._controls.keys() if k.startswith('legend')])}\"\n    )\n\n    # Prepare legend data\n    legend_items = []\n    for label, color in zip(labels, colors):\n        legend_items.append(\n            {\n                \"label\": label,\n                \"color\": color,\n            }\n        )\n\n    # Call JavaScript method to add legend\n    self.call_js_method(\n        \"addLegend\",\n        id=legend_id,\n        title=title,\n        items=legend_items,\n        position=position,\n        opacity=opacity,\n        **kwargs,\n    )\n\n    # Track legend control\n    self._controls = {\n        **self._controls,\n        legend_id: {\n            \"type\": \"legend\",\n            \"title\": title,\n            \"labels\": labels,\n            \"colors\": colors,\n            \"position\": position,\n            \"opacity\": opacity,\n        },\n    }\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.maplibre.MapLibreMap.add_lidar_control","title":"<code>add_lidar_control(self, position='top-right', collapsed=True, title='LiDAR Viewer', point_size=2, opacity=1.0, color_scheme='elevation', use_percentile=True, point_budget=1000000, pickable=False, auto_zoom=True, copc_loading_mode=None, streaming_point_budget=5000000, panel_max_height=600, **kwargs)</code>","text":"<p>Add an interactive LiDAR control panel.</p> <p>The LiDAR control provides a UI panel for loading, visualizing, and styling LiDAR point cloud files (LAS, LAZ, COPC formats).</p> <p>Parameters:</p> Name Type Description Default <code>position</code> <code>str</code> <p>Control position ('top-left', 'top-right', 'bottom-left', 'bottom-right').</p> <code>'top-right'</code> <code>collapsed</code> <code>bool</code> <p>Whether the panel starts collapsed.</p> <code>True</code> <code>title</code> <code>str</code> <p>Title displayed on the panel.</p> <code>'LiDAR Viewer'</code> <code>point_size</code> <code>float</code> <p>Point size in pixels.</p> <code>2</code> <code>opacity</code> <code>float</code> <p>Layer opacity (0-1).</p> <code>1.0</code> <code>color_scheme</code> <code>str</code> <p>Color scheme ('elevation', 'intensity', 'classification', 'rgb').</p> <code>'elevation'</code> <code>use_percentile</code> <code>bool</code> <p>Use 2-98% percentile for color scaling.</p> <code>True</code> <code>point_budget</code> <code>int</code> <p>Maximum number of points to display.</p> <code>1000000</code> <code>pickable</code> <code>bool</code> <p>Enable hover/click interactions.</p> <code>False</code> <code>auto_zoom</code> <code>bool</code> <p>Auto-zoom to point cloud after loading.</p> <code>True</code> <code>copc_loading_mode</code> <code>Optional[str]</code> <p>COPC loading mode ('full' or 'dynamic').</p> <code>None</code> <code>streaming_point_budget</code> <code>int</code> <p>Point budget for streaming mode.</p> <code>5000000</code> <code>panel_max_height</code> <code>int</code> <p>Maximum height of the panel in pixels.</p> <code>600</code> <code>**kwargs</code> <p>Additional control options.</p> <code>{}</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from anymap_ts import MapLibreMap\n&gt;&gt;&gt; m = MapLibreMap(pitch=60)\n&gt;&gt;&gt; m.add_lidar_control(color_scheme=\"classification\", pickable=True)\n</code></pre> Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def add_lidar_control(\n    self,\n    position: str = \"top-right\",\n    collapsed: bool = True,\n    title: str = \"LiDAR Viewer\",\n    point_size: float = 2,\n    opacity: float = 1.0,\n    color_scheme: str = \"elevation\",\n    use_percentile: bool = True,\n    point_budget: int = 1000000,\n    pickable: bool = False,\n    auto_zoom: bool = True,\n    copc_loading_mode: Optional[str] = None,\n    streaming_point_budget: int = 5000000,\n    panel_max_height: int = 600,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add an interactive LiDAR control panel.\n\n    The LiDAR control provides a UI panel for loading, visualizing, and\n    styling LiDAR point cloud files (LAS, LAZ, COPC formats).\n\n    Args:\n        position: Control position ('top-left', 'top-right', 'bottom-left', 'bottom-right').\n        collapsed: Whether the panel starts collapsed.\n        title: Title displayed on the panel.\n        point_size: Point size in pixels.\n        opacity: Layer opacity (0-1).\n        color_scheme: Color scheme ('elevation', 'intensity', 'classification', 'rgb').\n        use_percentile: Use 2-98% percentile for color scaling.\n        point_budget: Maximum number of points to display.\n        pickable: Enable hover/click interactions.\n        auto_zoom: Auto-zoom to point cloud after loading.\n        copc_loading_mode: COPC loading mode ('full' or 'dynamic').\n        streaming_point_budget: Point budget for streaming mode.\n        panel_max_height: Maximum height of the panel in pixels.\n        **kwargs: Additional control options.\n\n    Example:\n        &gt;&gt;&gt; from anymap_ts import MapLibreMap\n        &gt;&gt;&gt; m = MapLibreMap(pitch=60)\n        &gt;&gt;&gt; m.add_lidar_control(color_scheme=\"classification\", pickable=True)\n    \"\"\"\n    self.call_js_method(\n        \"addLidarControl\",\n        position=position,\n        collapsed=collapsed,\n        title=title,\n        pointSize=point_size,\n        opacity=opacity,\n        colorScheme=color_scheme,\n        usePercentile=use_percentile,\n        pointBudget=point_budget,\n        pickable=pickable,\n        autoZoom=auto_zoom,\n        copcLoadingMode=copc_loading_mode,\n        streamingPointBudget=streaming_point_budget,\n        panelMaxHeight=panel_max_height,\n        **kwargs,\n    )\n    self._controls = {\n        **self._controls,\n        \"lidar-control\": {\"position\": position, \"collapsed\": collapsed},\n    }\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.maplibre.MapLibreMap.add_lidar_layer","title":"<code>add_lidar_layer(self, source, name=None, color_scheme='elevation', point_size=2, opacity=1.0, pickable=True, auto_zoom=True, streaming_mode=True, point_budget=1000000, **kwargs)</code>","text":"<p>Load and display a LiDAR file from URL or local path.</p> <p>Supports LAS, LAZ, and COPC (Cloud-Optimized Point Cloud) formats. For local files, the file is read and sent as base64 to JavaScript. For URLs, the data is loaded directly via streaming when possible.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>Union[str, Path]</code> <p>URL or local file path to the LiDAR file.</p> required <code>name</code> <code>Optional[str]</code> <p>Layer identifier. If None, auto-generated.</p> <code>None</code> <code>color_scheme</code> <code>str</code> <p>Color scheme ('elevation', 'intensity', 'classification', 'rgb').</p> <code>'elevation'</code> <code>point_size</code> <code>float</code> <p>Point size in pixels.</p> <code>2</code> <code>opacity</code> <code>float</code> <p>Layer opacity (0-1).</p> <code>1.0</code> <code>pickable</code> <code>bool</code> <p>Enable hover/click interactions.</p> <code>True</code> <code>auto_zoom</code> <code>bool</code> <p>Auto-zoom to point cloud after loading.</p> <code>True</code> <code>streaming_mode</code> <code>bool</code> <p>Use streaming mode for large COPC files.</p> <code>True</code> <code>point_budget</code> <code>int</code> <p>Maximum number of points to display.</p> <code>1000000</code> <code>**kwargs</code> <p>Additional layer options.</p> <code>{}</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from anymap_ts import MapLibreMap\n&gt;&gt;&gt; m = MapLibreMap(center=[-123.07, 44.05], zoom=14, pitch=60)\n&gt;&gt;&gt; m.add_lidar_layer(\n...     source=\"https://s3.amazonaws.com/hobu-lidar/autzen-classified.copc.laz\",\n...     name=\"autzen\",\n...     color_scheme=\"classification\",\n... )\n</code></pre> Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def add_lidar_layer(\n    self,\n    source: Union[str, Path],\n    name: Optional[str] = None,\n    color_scheme: str = \"elevation\",\n    point_size: float = 2,\n    opacity: float = 1.0,\n    pickable: bool = True,\n    auto_zoom: bool = True,\n    streaming_mode: bool = True,\n    point_budget: int = 1000000,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Load and display a LiDAR file from URL or local path.\n\n    Supports LAS, LAZ, and COPC (Cloud-Optimized Point Cloud) formats.\n    For local files, the file is read and sent as base64 to JavaScript.\n    For URLs, the data is loaded directly via streaming when possible.\n\n    Args:\n        source: URL or local file path to the LiDAR file.\n        name: Layer identifier. If None, auto-generated.\n        color_scheme: Color scheme ('elevation', 'intensity', 'classification', 'rgb').\n        point_size: Point size in pixels.\n        opacity: Layer opacity (0-1).\n        pickable: Enable hover/click interactions.\n        auto_zoom: Auto-zoom to point cloud after loading.\n        streaming_mode: Use streaming mode for large COPC files.\n        point_budget: Maximum number of points to display.\n        **kwargs: Additional layer options.\n\n    Example:\n        &gt;&gt;&gt; from anymap_ts import MapLibreMap\n        &gt;&gt;&gt; m = MapLibreMap(center=[-123.07, 44.05], zoom=14, pitch=60)\n        &gt;&gt;&gt; m.add_lidar_layer(\n        ...     source=\"https://s3.amazonaws.com/hobu-lidar/autzen-classified.copc.laz\",\n        ...     name=\"autzen\",\n        ...     color_scheme=\"classification\",\n        ... )\n    \"\"\"\n    layer_id = name or f\"lidar-{len(self._layers)}\"\n\n    # Check if source is a local file\n    source_path = Path(source) if isinstance(source, (str, Path)) else None\n    is_local = source_path is not None and source_path.exists()\n\n    if is_local:\n        # Read local file and encode as base64\n        import base64\n\n        with open(source_path, \"rb\") as f:\n            file_data = f.read()\n        source_b64 = base64.b64encode(file_data).decode(\"utf-8\")\n\n        self.call_js_method(\n            \"addLidarLayer\",\n            source=source_b64,\n            name=layer_id,\n            isBase64=True,\n            filename=source_path.name,\n            colorScheme=color_scheme,\n            pointSize=point_size,\n            opacity=opacity,\n            pickable=pickable,\n            autoZoom=auto_zoom,\n            streamingMode=streaming_mode,\n            pointBudget=point_budget,\n            **kwargs,\n        )\n    else:\n        # Load from URL\n        self.call_js_method(\n            \"addLidarLayer\",\n            source=str(source),\n            name=layer_id,\n            isBase64=False,\n            colorScheme=color_scheme,\n            pointSize=point_size,\n            opacity=opacity,\n            pickable=pickable,\n            autoZoom=auto_zoom,\n            streamingMode=streaming_mode,\n            pointBudget=point_budget,\n            **kwargs,\n        )\n\n    self._layers = {\n        **self._layers,\n        layer_id: {\n            \"id\": layer_id,\n            \"type\": \"lidar\",\n            \"source\": str(source),\n        },\n    }\n    self._add_to_layer_dict(layer_id, \"LiDAR\")\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.maplibre.MapLibreMap.add_line_layer","title":"<code>add_line_layer(self, data, name=None, get_source_position='sourcePosition', get_target_position='targetPosition', get_color=None, get_width=1, width_min_pixels=1, pickable=True, opacity=0.8, **kwargs)</code>","text":"<p>Add a line layer for origin-destination line visualization using deck.gl.</p> <p>Line layers render straight line segments between source and target positions. Unlike arc layers, lines are drawn without curvature.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>Array of line objects with source/target positions.</p> required <code>name</code> <code>Optional[str]</code> <p>Layer ID. If None, auto-generated.</p> <code>None</code> <code>get_source_position</code> <code>Union[str, Any]</code> <p>Accessor for source position [lng, lat].</p> <code>'sourcePosition'</code> <code>get_target_position</code> <code>Union[str, Any]</code> <p>Accessor for target position [lng, lat].</p> <code>'targetPosition'</code> <code>get_color</code> <code>Optional[Union[List[int], str]]</code> <p>Accessor for line color [r, g, b] or [r, g, b, a]. Default: [51, 136, 255, 200] (blue).</p> <code>None</code> <code>get_width</code> <code>Union[float, str]</code> <p>Accessor for line width.</p> <code>1</code> <code>width_min_pixels</code> <code>float</code> <p>Minimum line width in pixels.</p> <code>1</code> <code>pickable</code> <code>bool</code> <p>Whether layer responds to hover/click events.</p> <code>True</code> <code>opacity</code> <code>float</code> <p>Layer opacity (0-1).</p> <code>0.8</code> <code>**kwargs</code> <p>Additional LineLayer props.</p> <code>{}</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from anymap_ts import MapLibreMap\n&gt;&gt;&gt; m = MapLibreMap()\n&gt;&gt;&gt; lines = [\n...     {\"sourcePosition\": [-122.4, 37.8], \"targetPosition\": [-73.9, 40.7]},\n... ]\n&gt;&gt;&gt; m.add_line_layer(lines, get_color=[0, 128, 255], get_width=2)\n</code></pre> Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def add_line_layer(\n    self,\n    data: Any,\n    name: Optional[str] = None,\n    get_source_position: Union[str, Any] = \"sourcePosition\",\n    get_target_position: Union[str, Any] = \"targetPosition\",\n    get_color: Optional[Union[List[int], str]] = None,\n    get_width: Union[float, str] = 1,\n    width_min_pixels: float = 1,\n    pickable: bool = True,\n    opacity: float = 0.8,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a line layer for origin-destination line visualization using deck.gl.\n\n    Line layers render straight line segments between source and target\n    positions. Unlike arc layers, lines are drawn without curvature.\n\n    Args:\n        data: Array of line objects with source/target positions.\n        name: Layer ID. If None, auto-generated.\n        get_source_position: Accessor for source position [lng, lat].\n        get_target_position: Accessor for target position [lng, lat].\n        get_color: Accessor for line color [r, g, b] or [r, g, b, a].\n            Default: [51, 136, 255, 200] (blue).\n        get_width: Accessor for line width.\n        width_min_pixels: Minimum line width in pixels.\n        pickable: Whether layer responds to hover/click events.\n        opacity: Layer opacity (0-1).\n        **kwargs: Additional LineLayer props.\n\n    Example:\n        &gt;&gt;&gt; from anymap_ts import MapLibreMap\n        &gt;&gt;&gt; m = MapLibreMap()\n        &gt;&gt;&gt; lines = [\n        ...     {\"sourcePosition\": [-122.4, 37.8], \"targetPosition\": [-73.9, 40.7]},\n        ... ]\n        &gt;&gt;&gt; m.add_line_layer(lines, get_color=[0, 128, 255], get_width=2)\n    \"\"\"\n    layer_id = name or f\"line-{len(self._layers)}\"\n    processed_data = self._process_deck_data(data)\n\n    self.call_js_method(\n        \"addLineLayer\",\n        id=layer_id,\n        data=processed_data,\n        getSourcePosition=get_source_position,\n        getTargetPosition=get_target_position,\n        getColor=get_color or [51, 136, 255, 200],\n        getWidth=get_width,\n        widthMinPixels=width_min_pixels,\n        pickable=pickable,\n        opacity=opacity,\n        **kwargs,\n    )\n\n    self._layers = {\n        **self._layers,\n        layer_id: {\n            \"id\": layer_id,\n            \"type\": \"line\",\n        },\n    }\n    self._add_to_layer_dict(layer_id, \"Deck.gl\")\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.maplibre.MapLibreMap.add_marker","title":"<code>add_marker(self, lng, lat, popup=None, tooltip=None, color='#3388ff', draggable=False, scale=1.0, popup_max_width='240px', tooltip_max_width='240px', name=None, **kwargs)</code>","text":"<p>Add a single marker to the map.</p> <p>Parameters:</p> Name Type Description Default <code>lng</code> <code>float</code> <p>Longitude of the marker.</p> required <code>lat</code> <code>float</code> <p>Latitude of the marker.</p> required <code>popup</code> <code>Optional[str]</code> <p>Optional popup HTML content (shown on click).</p> <code>None</code> <code>tooltip</code> <code>Optional[str]</code> <p>Optional tooltip HTML content (shown on hover).</p> <code>None</code> <code>color</code> <code>str</code> <p>Marker color as hex string.</p> <code>'#3388ff'</code> <code>draggable</code> <code>bool</code> <p>Whether the marker can be dragged.</p> <code>False</code> <code>scale</code> <code>float</code> <p>Marker size multiplier (default 1.0, range 0.1 to 3.0).</p> <code>1.0</code> <code>popup_max_width</code> <code>str</code> <p>Maximum width of popup (CSS value, default \"240px\").</p> <code>'240px'</code> <code>tooltip_max_width</code> <code>str</code> <p>Maximum width of tooltip (CSS value, default \"240px\").</p> <code>'240px'</code> <code>name</code> <code>Optional[str]</code> <p>Marker identifier. If None, auto-generated.</p> <code>None</code> <code>**kwargs</code> <p>Additional marker options.</p> <code>{}</code> <p>Returns:</p> Type Description <code>str</code> <p>The marker identifier.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from anymap_ts import Map\n&gt;&gt;&gt; m = Map(center=[-122.4, 37.8], zoom=10)\n&gt;&gt;&gt; m.add_marker(-122.4, 37.8, popup=\"San Francisco\", tooltip=\"Hover me!\")\n&gt;&gt;&gt; m.add_marker(-122.5, 37.7, scale=1.5, color=\"#ff0000\")\n</code></pre> Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def add_marker(\n    self,\n    lng: float,\n    lat: float,\n    popup: Optional[str] = None,\n    tooltip: Optional[str] = None,\n    color: str = \"#3388ff\",\n    draggable: bool = False,\n    scale: float = 1.0,\n    popup_max_width: str = \"240px\",\n    tooltip_max_width: str = \"240px\",\n    name: Optional[str] = None,\n    **kwargs,\n) -&gt; str:\n    \"\"\"Add a single marker to the map.\n\n    Args:\n        lng: Longitude of the marker.\n        lat: Latitude of the marker.\n        popup: Optional popup HTML content (shown on click).\n        tooltip: Optional tooltip HTML content (shown on hover).\n        color: Marker color as hex string.\n        draggable: Whether the marker can be dragged.\n        scale: Marker size multiplier (default 1.0, range 0.1 to 3.0).\n        popup_max_width: Maximum width of popup (CSS value, default \"240px\").\n        tooltip_max_width: Maximum width of tooltip (CSS value, default \"240px\").\n        name: Marker identifier. If None, auto-generated.\n        **kwargs: Additional marker options.\n\n    Returns:\n        The marker identifier.\n\n    Example:\n        &gt;&gt;&gt; from anymap_ts import Map\n        &gt;&gt;&gt; m = Map(center=[-122.4, 37.8], zoom=10)\n        &gt;&gt;&gt; m.add_marker(-122.4, 37.8, popup=\"San Francisco\", tooltip=\"Hover me!\")\n        &gt;&gt;&gt; m.add_marker(-122.5, 37.7, scale=1.5, color=\"#ff0000\")\n    \"\"\"\n    marker_id = name or f\"marker-{len(self._layers)}\"\n\n    self.call_js_method(\n        \"addMarker\",\n        lng,\n        lat,\n        id=marker_id,\n        popup=popup,\n        tooltip=tooltip,\n        color=color,\n        draggable=draggable,\n        scale=scale,\n        popupMaxWidth=popup_max_width,\n        tooltipMaxWidth=tooltip_max_width,\n        **kwargs,\n    )\n\n    self._layers = {\n        **self._layers,\n        marker_id: {\n            \"id\": marker_id,\n            \"type\": \"marker\",\n            \"lngLat\": [lng, lat],\n        },\n    }\n    self._add_to_layer_dict(marker_id, \"Markers\")\n    return marker_id\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.maplibre.MapLibreMap.add_markers","title":"<code>add_markers(self, data, lng_column=None, lat_column=None, popup_column=None, tooltip_column=None, color='#3388ff', scale=1.0, popup_max_width='240px', tooltip_max_width='240px', draggable=False, name=None, **kwargs)</code>","text":"<p>Add multiple markers from data.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>Data source - can be: - List of dicts with 'lng'/'lon'/'longitude' and 'lat'/'latitude' keys - GeoDataFrame with Point geometries - GeoJSON FeatureCollection with Point features</p> required <code>lng_column</code> <code>Optional[str]</code> <p>Column name for longitude (auto-detected if None).</p> <code>None</code> <code>lat_column</code> <code>Optional[str]</code> <p>Column name for latitude (auto-detected if None).</p> <code>None</code> <code>popup_column</code> <code>Optional[str]</code> <p>Column name for popup content (shown on click).</p> <code>None</code> <code>tooltip_column</code> <code>Optional[str]</code> <p>Column name for tooltip content (shown on hover).</p> <code>None</code> <code>color</code> <code>str</code> <p>Marker color as hex string.</p> <code>'#3388ff'</code> <code>scale</code> <code>float</code> <p>Marker size multiplier (default 1.0, range 0.1 to 3.0).</p> <code>1.0</code> <code>popup_max_width</code> <code>str</code> <p>Maximum width of popup (CSS value, default \"240px\").</p> <code>'240px'</code> <code>tooltip_max_width</code> <code>str</code> <p>Maximum width of tooltip (CSS value, default \"240px\").</p> <code>'240px'</code> <code>draggable</code> <code>bool</code> <p>Whether markers can be dragged.</p> <code>False</code> <code>name</code> <code>Optional[str]</code> <p>Layer identifier. If None, auto-generated.</p> <code>None</code> <code>**kwargs</code> <p>Additional marker options.</p> <code>{}</code> <p>Returns:</p> Type Description <code>str</code> <p>The layer identifier.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from anymap_ts import Map\n&gt;&gt;&gt; m = Map()\n&gt;&gt;&gt; cities = [\n...     {\"name\": \"SF\", \"info\": \"San Francisco\", \"lng\": -122.4, \"lat\": 37.8},\n...     {\"name\": \"NYC\", \"info\": \"New York City\", \"lng\": -74.0, \"lat\": 40.7},\n... ]\n&gt;&gt;&gt; m.add_markers(cities, popup_column=\"name\", tooltip_column=\"info\", scale=1.5)\n</code></pre> Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def add_markers(\n    self,\n    data: Any,\n    lng_column: Optional[str] = None,\n    lat_column: Optional[str] = None,\n    popup_column: Optional[str] = None,\n    tooltip_column: Optional[str] = None,\n    color: str = \"#3388ff\",\n    scale: float = 1.0,\n    popup_max_width: str = \"240px\",\n    tooltip_max_width: str = \"240px\",\n    draggable: bool = False,\n    name: Optional[str] = None,\n    **kwargs,\n) -&gt; str:\n    \"\"\"Add multiple markers from data.\n\n    Args:\n        data: Data source - can be:\n            - List of dicts with 'lng'/'lon'/'longitude' and 'lat'/'latitude' keys\n            - GeoDataFrame with Point geometries\n            - GeoJSON FeatureCollection with Point features\n        lng_column: Column name for longitude (auto-detected if None).\n        lat_column: Column name for latitude (auto-detected if None).\n        popup_column: Column name for popup content (shown on click).\n        tooltip_column: Column name for tooltip content (shown on hover).\n        color: Marker color as hex string.\n        scale: Marker size multiplier (default 1.0, range 0.1 to 3.0).\n        popup_max_width: Maximum width of popup (CSS value, default \"240px\").\n        tooltip_max_width: Maximum width of tooltip (CSS value, default \"240px\").\n        draggable: Whether markers can be dragged.\n        name: Layer identifier. If None, auto-generated.\n        **kwargs: Additional marker options.\n\n    Returns:\n        The layer identifier.\n\n    Example:\n        &gt;&gt;&gt; from anymap_ts import Map\n        &gt;&gt;&gt; m = Map()\n        &gt;&gt;&gt; cities = [\n        ...     {\"name\": \"SF\", \"info\": \"San Francisco\", \"lng\": -122.4, \"lat\": 37.8},\n        ...     {\"name\": \"NYC\", \"info\": \"New York City\", \"lng\": -74.0, \"lat\": 40.7},\n        ... ]\n        &gt;&gt;&gt; m.add_markers(cities, popup_column=\"name\", tooltip_column=\"info\", scale=1.5)\n    \"\"\"\n    layer_id = name or f\"markers-{len(self._layers)}\"\n    markers = []\n\n    # Handle GeoDataFrame\n    if hasattr(data, \"geometry\"):\n        for _, row in data.iterrows():\n            geom = row.geometry\n            if geom.geom_type == \"Point\":\n                marker = {\"lngLat\": [geom.x, geom.y]}\n                if popup_column and popup_column in row:\n                    marker[\"popup\"] = str(row[popup_column])\n                if tooltip_column and tooltip_column in row:\n                    marker[\"tooltip\"] = str(row[tooltip_column])\n                markers.append(marker)\n    # Handle GeoJSON\n    elif isinstance(data, dict) and data.get(\"type\") == \"FeatureCollection\":\n        for feature in data.get(\"features\", []):\n            geom = feature.get(\"geometry\", {})\n            if geom.get(\"type\") == \"Point\":\n                coords = geom.get(\"coordinates\", [])\n                marker = {\"lngLat\": coords[:2]}\n                props = feature.get(\"properties\", {})\n                if popup_column and popup_column in props:\n                    marker[\"popup\"] = str(props[popup_column])\n                if tooltip_column and tooltip_column in props:\n                    marker[\"tooltip\"] = str(props[tooltip_column])\n                markers.append(marker)\n    # Handle list of dicts\n    elif isinstance(data, list):\n        lng_keys = [\"lng\", \"lon\", \"longitude\", \"x\"]\n        lat_keys = [\"lat\", \"latitude\", \"y\"]\n\n        for item in data:\n            if not isinstance(item, dict):\n                continue\n\n            # Find lng/lat values\n            lng_val = None\n            lat_val = None\n\n            if lng_column and lng_column in item:\n                lng_val = item[lng_column]\n            else:\n                for key in lng_keys:\n                    if key in item:\n                        lng_val = item[key]\n                        break\n\n            if lat_column and lat_column in item:\n                lat_val = item[lat_column]\n            else:\n                for key in lat_keys:\n                    if key in item:\n                        lat_val = item[key]\n                        break\n\n            if lng_val is not None and lat_val is not None:\n                marker = {\"lngLat\": [float(lng_val), float(lat_val)]}\n                if popup_column and popup_column in item:\n                    marker[\"popup\"] = str(item[popup_column])\n                if tooltip_column and tooltip_column in item:\n                    marker[\"tooltip\"] = str(item[tooltip_column])\n                markers.append(marker)\n\n    if not markers:\n        raise ValueError(\"No valid point data found in input\")\n\n    self.call_js_method(\n        \"addMarkers\",\n        id=layer_id,\n        markers=markers,\n        color=color,\n        scale=scale,\n        popupMaxWidth=popup_max_width,\n        tooltipMaxWidth=tooltip_max_width,\n        draggable=draggable,\n        **kwargs,\n    )\n\n    self._layers = {\n        **self._layers,\n        layer_id: {\n            \"id\": layer_id,\n            \"type\": \"markers\",\n            \"count\": len(markers),\n        },\n    }\n    self._add_to_layer_dict(layer_id, \"Markers\")\n    return layer_id\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.maplibre.MapLibreMap.add_measure_control","title":"<code>add_measure_control(self, position='top-right', collapsed=True, default_mode='distance', distance_unit='kilometers', area_unit='square-kilometers', line_color='#3b82f6', fill_color='rgba(59, 130, 246, 0.2)', **kwargs)</code>","text":"<p>Add a measurement control for distances and areas.</p> <p>Provides tools for measuring distances (polylines) and areas (polygons) interactively on the map.</p> <p>Parameters:</p> Name Type Description Default <code>position</code> <code>str</code> <p>Control position ('top-left', 'top-right', 'bottom-left', 'bottom-right').</p> <code>'top-right'</code> <code>collapsed</code> <code>bool</code> <p>Whether the control starts collapsed.</p> <code>True</code> <code>default_mode</code> <code>str</code> <p>Default measurement mode ('distance' or 'area').</p> <code>'distance'</code> <code>distance_unit</code> <code>str</code> <p>Distance unit ('kilometers', 'miles', 'meters', 'feet', 'nautical-miles').</p> <code>'kilometers'</code> <code>area_unit</code> <code>str</code> <p>Area unit ('square-kilometers', 'square-miles', 'square-meters', 'hectares', 'acres').</p> <code>'square-kilometers'</code> <code>line_color</code> <code>str</code> <p>Line color for distance measurements.</p> <code>'#3b82f6'</code> <code>fill_color</code> <code>str</code> <p>Fill color for area measurements.</p> <code>'rgba(59, 130, 246, 0.2)'</code> <code>**kwargs</code> <p>Additional MeasureControl options.</p> <code>{}</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; m = Map()\n&gt;&gt;&gt; m.add_measure_control(\n...     default_mode=\"distance\",\n...     distance_unit=\"miles\",\n... )\n</code></pre> Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def add_measure_control(\n    self,\n    position: str = \"top-right\",\n    collapsed: bool = True,\n    default_mode: str = \"distance\",\n    distance_unit: str = \"kilometers\",\n    area_unit: str = \"square-kilometers\",\n    line_color: str = \"#3b82f6\",\n    fill_color: str = \"rgba(59, 130, 246, 0.2)\",\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a measurement control for distances and areas.\n\n    Provides tools for measuring distances (polylines) and areas\n    (polygons) interactively on the map.\n\n    Args:\n        position: Control position ('top-left', 'top-right',\n            'bottom-left', 'bottom-right').\n        collapsed: Whether the control starts collapsed.\n        default_mode: Default measurement mode ('distance' or 'area').\n        distance_unit: Distance unit ('kilometers', 'miles', 'meters',\n            'feet', 'nautical-miles').\n        area_unit: Area unit ('square-kilometers', 'square-miles',\n            'square-meters', 'hectares', 'acres').\n        line_color: Line color for distance measurements.\n        fill_color: Fill color for area measurements.\n        **kwargs: Additional MeasureControl options.\n\n    Example:\n        &gt;&gt;&gt; m = Map()\n        &gt;&gt;&gt; m.add_measure_control(\n        ...     default_mode=\"distance\",\n        ...     distance_unit=\"miles\",\n        ... )\n    \"\"\"\n    self._validate_position(position)\n    self.call_js_method(\n        \"addMeasureControl\",\n        position=position,\n        collapsed=collapsed,\n        defaultMode=default_mode,\n        distanceUnit=distance_unit,\n        areaUnit=area_unit,\n        lineColor=line_color,\n        fillColor=fill_color,\n        **kwargs,\n    )\n    self._controls = {\n        **self._controls,\n        \"measure-control\": {\n            \"type\": \"measure-control\",\n            \"position\": position,\n            \"collapsed\": collapsed,\n        },\n    }\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.maplibre.MapLibreMap.add_opacity_slider","title":"<code>add_opacity_slider(self, layer_id, position='top-right', label=None)</code>","text":"<p>Add a UI slider to control layer opacity.</p> <p>Parameters:</p> Name Type Description Default <code>layer_id</code> <code>str</code> <p>Layer ID to control opacity for.</p> required <code>position</code> <code>str</code> <p>Control position.</p> <code>'top-right'</code> <code>label</code> <code>Optional[str]</code> <p>Label text. Defaults to layer_id.</p> <code>None</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; m = MapLibreMap()\n&gt;&gt;&gt; m.add_tile_layer(\"...\", name=\"satellite\")\n&gt;&gt;&gt; m.add_opacity_slider(\"satellite\")\n</code></pre> Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def add_opacity_slider(\n    self,\n    layer_id: str,\n    position: str = \"top-right\",\n    label: Optional[str] = None,\n) -&gt; None:\n    \"\"\"Add a UI slider to control layer opacity.\n\n    Args:\n        layer_id: Layer ID to control opacity for.\n        position: Control position.\n        label: Label text. Defaults to layer_id.\n\n    Example:\n        &gt;&gt;&gt; m = MapLibreMap()\n        &gt;&gt;&gt; m.add_tile_layer(\"...\", name=\"satellite\")\n        &gt;&gt;&gt; m.add_opacity_slider(\"satellite\")\n    \"\"\"\n    self.call_js_method(\n        \"addOpacitySlider\",\n        layerId=layer_id,\n        position=position,\n        label=label or layer_id,\n    )\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.maplibre.MapLibreMap.add_path_layer","title":"<code>add_path_layer(self, data, name=None, get_path='path', get_color=None, get_width=1, width_scale=1, width_min_pixels=1, pickable=True, opacity=0.8, **kwargs)</code>","text":"<p>Add a path layer for route/trajectory rendering using deck.gl.</p> <p>Path layers render polylines defined by arrays of coordinates, ideal for visualizing routes, trajectories, or any line-based data.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>Array of data objects with path coordinates.</p> required <code>name</code> <code>Optional[str]</code> <p>Layer ID. If None, auto-generated.</p> <code>None</code> <code>get_path</code> <code>Union[str, Any]</code> <p>Accessor for path coordinates [[lng, lat], ...]. Can be a string (property name) or a value.</p> <code>'path'</code> <code>get_color</code> <code>Optional[Union[List[int], str]]</code> <p>Accessor for path color [r, g, b, a]. Default: [51, 136, 255, 200] (blue).</p> <code>None</code> <code>get_width</code> <code>Union[float, str]</code> <p>Accessor for path width in meters.</p> <code>1</code> <code>width_scale</code> <code>float</code> <p>Global width multiplier.</p> <code>1</code> <code>width_min_pixels</code> <code>float</code> <p>Minimum width in pixels.</p> <code>1</code> <code>pickable</code> <code>bool</code> <p>Whether layer responds to hover/click events.</p> <code>True</code> <code>opacity</code> <code>float</code> <p>Layer opacity (0-1).</p> <code>0.8</code> <code>**kwargs</code> <p>Additional PathLayer props.</p> <code>{}</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from anymap_ts import MapLibreMap\n&gt;&gt;&gt; m = MapLibreMap()\n&gt;&gt;&gt; routes = [\n...     {\"path\": [[-122.4, 37.8], [-122.5, 37.7], [-122.6, 37.8]]},\n... ]\n&gt;&gt;&gt; m.add_path_layer(routes, get_color=[255, 0, 0], get_width=3)\n</code></pre> Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def add_path_layer(\n    self,\n    data: Any,\n    name: Optional[str] = None,\n    get_path: Union[str, Any] = \"path\",\n    get_color: Optional[Union[List[int], str]] = None,\n    get_width: Union[float, str] = 1,\n    width_scale: float = 1,\n    width_min_pixels: float = 1,\n    pickable: bool = True,\n    opacity: float = 0.8,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a path layer for route/trajectory rendering using deck.gl.\n\n    Path layers render polylines defined by arrays of coordinates,\n    ideal for visualizing routes, trajectories, or any line-based data.\n\n    Args:\n        data: Array of data objects with path coordinates.\n        name: Layer ID. If None, auto-generated.\n        get_path: Accessor for path coordinates [[lng, lat], ...].\n            Can be a string (property name) or a value.\n        get_color: Accessor for path color [r, g, b, a].\n            Default: [51, 136, 255, 200] (blue).\n        get_width: Accessor for path width in meters.\n        width_scale: Global width multiplier.\n        width_min_pixels: Minimum width in pixels.\n        pickable: Whether layer responds to hover/click events.\n        opacity: Layer opacity (0-1).\n        **kwargs: Additional PathLayer props.\n\n    Example:\n        &gt;&gt;&gt; from anymap_ts import MapLibreMap\n        &gt;&gt;&gt; m = MapLibreMap()\n        &gt;&gt;&gt; routes = [\n        ...     {\"path\": [[-122.4, 37.8], [-122.5, 37.7], [-122.6, 37.8]]},\n        ... ]\n        &gt;&gt;&gt; m.add_path_layer(routes, get_color=[255, 0, 0], get_width=3)\n    \"\"\"\n    layer_id = name or f\"path-{len(self._layers)}\"\n    processed_data = self._process_deck_data(data)\n\n    self.call_js_method(\n        \"addPathLayer\",\n        id=layer_id,\n        data=processed_data,\n        getPath=get_path,\n        getColor=get_color or [51, 136, 255, 200],\n        getWidth=get_width,\n        widthScale=width_scale,\n        widthMinPixels=width_min_pixels,\n        pickable=pickable,\n        opacity=opacity,\n        **kwargs,\n    )\n\n    self._layers = {\n        **self._layers,\n        layer_id: {\n            \"id\": layer_id,\n            \"type\": \"path\",\n        },\n    }\n    self._add_to_layer_dict(layer_id, \"Deck.gl\")\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.maplibre.MapLibreMap.add_pmtiles_control","title":"<code>add_pmtiles_control(self, position='top-right', collapsed=True, default_url=None, load_default_url=False, default_opacity=1.0, default_fill_color='steelblue', default_line_color='#333', default_pickable=True, **kwargs)</code>","text":"<p>Add a PMTiles layer control for loading PMTiles files via UI.</p> <p>This provides an interactive panel for users to enter PMTiles URLs and visualize vector or raster tile data.</p> <p>Parameters:</p> Name Type Description Default <code>position</code> <code>str</code> <p>Control position ('top-left', 'top-right', 'bottom-left', 'bottom-right').</p> <code>'top-right'</code> <code>collapsed</code> <code>bool</code> <p>Whether the panel starts collapsed.</p> <code>True</code> <code>default_url</code> <code>Optional[str]</code> <p>Default PMTiles URL to pre-fill.</p> <code>None</code> <code>load_default_url</code> <code>bool</code> <p>Whether to auto-load the default URL.</p> <code>False</code> <code>default_opacity</code> <code>float</code> <p>Default layer opacity (0-1).</p> <code>1.0</code> <code>default_fill_color</code> <code>str</code> <p>Default fill color for vector polygons.</p> <code>'steelblue'</code> <code>default_line_color</code> <code>str</code> <p>Default line color for vector lines.</p> <code>'#333'</code> <code>default_pickable</code> <code>bool</code> <p>Whether features are clickable by default.</p> <code>True</code> <code>**kwargs</code> <p>Additional control options.</p> <code>{}</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from anymap_ts import MapLibreMap\n&gt;&gt;&gt; m = MapLibreMap()\n&gt;&gt;&gt; m.add_pmtiles_control(\n...     default_url=\"https://pmtiles.io/protomaps(vector)ODbL_firenze.pmtiles\",\n...     load_default_url=True\n... )\n</code></pre> Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def add_pmtiles_control(\n    self,\n    position: str = \"top-right\",\n    collapsed: bool = True,\n    default_url: Optional[str] = None,\n    load_default_url: bool = False,\n    default_opacity: float = 1.0,\n    default_fill_color: str = \"steelblue\",\n    default_line_color: str = \"#333\",\n    default_pickable: bool = True,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a PMTiles layer control for loading PMTiles files via UI.\n\n    This provides an interactive panel for users to enter PMTiles URLs\n    and visualize vector or raster tile data.\n\n    Args:\n        position: Control position ('top-left', 'top-right', 'bottom-left', 'bottom-right').\n        collapsed: Whether the panel starts collapsed.\n        default_url: Default PMTiles URL to pre-fill.\n        load_default_url: Whether to auto-load the default URL.\n        default_opacity: Default layer opacity (0-1).\n        default_fill_color: Default fill color for vector polygons.\n        default_line_color: Default line color for vector lines.\n        default_pickable: Whether features are clickable by default.\n        **kwargs: Additional control options.\n\n    Example:\n        &gt;&gt;&gt; from anymap_ts import MapLibreMap\n        &gt;&gt;&gt; m = MapLibreMap()\n        &gt;&gt;&gt; m.add_pmtiles_control(\n        ...     default_url=\"https://pmtiles.io/protomaps(vector)ODbL_firenze.pmtiles\",\n        ...     load_default_url=True\n        ... )\n    \"\"\"\n    self.call_js_method(\n        \"addPMTilesControl\",\n        position=position,\n        collapsed=collapsed,\n        defaultUrl=default_url or \"\",\n        loadDefaultUrl=load_default_url,\n        defaultOpacity=default_opacity,\n        defaultFillColor=default_fill_color,\n        defaultLineColor=default_line_color,\n        defaultPickable=default_pickable,\n        **kwargs,\n    )\n    self._controls = {\n        **self._controls,\n        \"pmtiles-control\": {\"position\": position, \"collapsed\": collapsed},\n    }\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.maplibre.MapLibreMap.add_pmtiles_layer","title":"<code>add_pmtiles_layer(self, url, layer_id=None, style=None, opacity=1.0, visible=True, fit_bounds=False, source_type='vector', **kwargs)</code>","text":"<p>Add a PMTiles layer for efficient vector or raster tile serving.</p> <p>PMTiles is a single-file archive format for pyramids of map tiles. It enables efficient web-native map serving without requiring a separate tile server infrastructure.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>URL to the PMTiles file (e.g., \"https://example.com/data.pmtiles\").</p> required <code>layer_id</code> <code>Optional[str]</code> <p>Layer identifier. If None, auto-generated.</p> <code>None</code> <code>style</code> <code>Optional[Dict[str, Any]]</code> <p>Layer style configuration for vector tiles. For vector PMTiles, can include: - type: Layer type ('fill', 'line', 'circle', 'symbol') - source-layer: Source layer name from vector tiles - paint properties (e.g., 'fill-color', 'line-width') - layout properties (e.g., 'visibility') Example: {\"type\": \"line\", \"source-layer\": \"roads\", \"line-color\": \"#ff0000\"}</p> <code>None</code> <code>opacity</code> <code>float</code> <p>Layer opacity (0-1).</p> <code>1.0</code> <code>visible</code> <code>bool</code> <p>Whether layer is initially visible.</p> <code>True</code> <code>fit_bounds</code> <code>bool</code> <p>Whether to fit map to layer bounds after loading.</p> <code>False</code> <code>source_type</code> <code>str</code> <p>Source type - \"vector\" for vector PMTiles, \"raster\" for raster PMTiles.</p> <code>'vector'</code> <code>**kwargs</code> <p>Additional layer options.</p> <code>{}</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from anymap_ts import Map\n&gt;&gt;&gt; m = Map()\n&gt;&gt;&gt; # Add vector PMTiles\n&gt;&gt;&gt; m.add_pmtiles_layer(\n...     url=\"https://example.com/countries.pmtiles\",\n...     layer_id=\"countries\",\n...     style={\n...         \"type\": \"fill\",\n...         \"source-layer\": \"countries\",\n...         \"fill-color\": \"#3388ff\",\n...         \"fill-opacity\": 0.6\n...     }\n... )\n&gt;&gt;&gt; # Add raster PMTiles\n&gt;&gt;&gt; m.add_pmtiles_layer(\n...     url=\"https://example.com/satellite.pmtiles\",\n...     layer_id=\"satellite\",\n...     source_type=\"raster\",\n...     opacity=0.8\n... )\n</code></pre> Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def add_pmtiles_layer(\n    self,\n    url: str,\n    layer_id: Optional[str] = None,\n    style: Optional[Dict[str, Any]] = None,\n    opacity: float = 1.0,\n    visible: bool = True,\n    fit_bounds: bool = False,\n    source_type: str = \"vector\",\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a PMTiles layer for efficient vector or raster tile serving.\n\n    PMTiles is a single-file archive format for pyramids of map tiles.\n    It enables efficient web-native map serving without requiring a\n    separate tile server infrastructure.\n\n    Args:\n        url: URL to the PMTiles file (e.g., \"https://example.com/data.pmtiles\").\n        layer_id: Layer identifier. If None, auto-generated.\n        style: Layer style configuration for vector tiles.\n            For vector PMTiles, can include:\n            - type: Layer type ('fill', 'line', 'circle', 'symbol')\n            - source-layer: Source layer name from vector tiles\n            - paint properties (e.g., 'fill-color', 'line-width')\n            - layout properties (e.g., 'visibility')\n            Example: {\"type\": \"line\", \"source-layer\": \"roads\", \"line-color\": \"#ff0000\"}\n        opacity: Layer opacity (0-1).\n        visible: Whether layer is initially visible.\n        fit_bounds: Whether to fit map to layer bounds after loading.\n        source_type: Source type - \"vector\" for vector PMTiles, \"raster\" for raster PMTiles.\n        **kwargs: Additional layer options.\n\n    Example:\n        &gt;&gt;&gt; from anymap_ts import Map\n        &gt;&gt;&gt; m = Map()\n        &gt;&gt;&gt; # Add vector PMTiles\n        &gt;&gt;&gt; m.add_pmtiles_layer(\n        ...     url=\"https://example.com/countries.pmtiles\",\n        ...     layer_id=\"countries\",\n        ...     style={\n        ...         \"type\": \"fill\",\n        ...         \"source-layer\": \"countries\",\n        ...         \"fill-color\": \"#3388ff\",\n        ...         \"fill-opacity\": 0.6\n        ...     }\n        ... )\n        &gt;&gt;&gt; # Add raster PMTiles\n        &gt;&gt;&gt; m.add_pmtiles_layer(\n        ...     url=\"https://example.com/satellite.pmtiles\",\n        ...     layer_id=\"satellite\",\n        ...     source_type=\"raster\",\n        ...     opacity=0.8\n        ... )\n    \"\"\"\n    layer_id = layer_id or f\"pmtiles-{len(self._layers)}\"\n\n    self.call_js_method(\n        \"addPMTilesLayer\",\n        url=url,\n        id=layer_id,\n        style=style or {},\n        opacity=opacity,\n        visible=visible,\n        fitBounds=fit_bounds,\n        sourceType=source_type,\n        name=layer_id,\n        **kwargs,\n    )\n\n    self._layers = {\n        **self._layers,\n        layer_id: {\n            \"id\": layer_id,\n            \"type\": \"pmtiles\",\n            \"url\": url,\n            \"source_type\": source_type,\n        },\n    }\n    category = \"Vector\" if source_type == \"vector\" else \"Raster\"\n    self._add_to_layer_dict(layer_id, category)\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.maplibre.MapLibreMap.add_point_cloud_layer","title":"<code>add_point_cloud_layer(self, data, name=None, get_position='position', get_color=None, get_normal=None, point_size=2, size_units='pixels', pickable=True, opacity=1.0, material=True, coordinate_system=None, coordinate_origin=None, **kwargs)</code>","text":"<p>Add a point cloud layer for 3D point visualization using deck.gl.</p> <p>Point cloud layers render large collections of 3D points, ideal for LiDAR data, photogrammetry outputs, or any 3D point dataset.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>Array of point data with positions. Each point should have x, y, z coordinates (or position array).</p> required <code>name</code> <code>Optional[str]</code> <p>Layer ID. If None, auto-generated.</p> <code>None</code> <code>get_position</code> <code>Union[str, Any]</code> <p>Accessor for point position [x, y, z]. Can be a string (property name) or a value.</p> <code>'position'</code> <code>get_color</code> <code>Optional[Union[List[int], str]]</code> <p>Accessor or value for point color [r, g, b, a]. Default: [255, 255, 255, 255] (white).</p> <code>None</code> <code>get_normal</code> <code>Optional[Union[str, Any]]</code> <p>Accessor for point normal [nx, ny, nz] for lighting. Default: [0, 0, 1] (pointing up).</p> <code>None</code> <code>point_size</code> <code>float</code> <p>Point size in pixels or meters (depends on size_units).</p> <code>2</code> <code>size_units</code> <code>str</code> <p>Size units: 'pixels', 'meters', or 'common'.</p> <code>'pixels'</code> <code>pickable</code> <code>bool</code> <p>Whether layer responds to hover/click events.</p> <code>True</code> <code>opacity</code> <code>float</code> <p>Layer opacity (0-1).</p> <code>1.0</code> <code>material</code> <code>bool</code> <p>Whether to enable lighting effects.</p> <code>True</code> <code>coordinate_system</code> <code>Optional[int]</code> <p>Coordinate system for positions.</p> <code>None</code> <code>coordinate_origin</code> <code>Optional[List[float]]</code> <p>Origin for coordinate system [x, y, z].</p> <code>None</code> <code>**kwargs</code> <p>Additional PointCloudLayer props.</p> <code>{}</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from anymap_ts import MapLibreMap\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; m = MapLibreMap(pitch=45)\n&gt;&gt;&gt; points = [\n...     {\"position\": [-122.4, 37.8, 100], \"color\": [255, 0, 0, 255]},\n...     {\"position\": [-122.3, 37.7, 200], \"color\": [0, 255, 0, 255]},\n... ]\n&gt;&gt;&gt; m.add_point_cloud_layer(points, point_size=5)\n</code></pre> Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def add_point_cloud_layer(\n    self,\n    data: Any,\n    name: Optional[str] = None,\n    get_position: Union[str, Any] = \"position\",\n    get_color: Optional[Union[List[int], str]] = None,\n    get_normal: Optional[Union[str, Any]] = None,\n    point_size: float = 2,\n    size_units: str = \"pixels\",\n    pickable: bool = True,\n    opacity: float = 1.0,\n    material: bool = True,\n    coordinate_system: Optional[int] = None,\n    coordinate_origin: Optional[List[float]] = None,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a point cloud layer for 3D point visualization using deck.gl.\n\n    Point cloud layers render large collections of 3D points, ideal for\n    LiDAR data, photogrammetry outputs, or any 3D point dataset.\n\n    Args:\n        data: Array of point data with positions. Each point should have\n            x, y, z coordinates (or position array).\n        name: Layer ID. If None, auto-generated.\n        get_position: Accessor for point position [x, y, z].\n            Can be a string (property name) or a value.\n        get_color: Accessor or value for point color [r, g, b, a].\n            Default: [255, 255, 255, 255] (white).\n        get_normal: Accessor for point normal [nx, ny, nz] for lighting.\n            Default: [0, 0, 1] (pointing up).\n        point_size: Point size in pixels or meters (depends on size_units).\n        size_units: Size units: 'pixels', 'meters', or 'common'.\n        pickable: Whether layer responds to hover/click events.\n        opacity: Layer opacity (0-1).\n        material: Whether to enable lighting effects.\n        coordinate_system: Coordinate system for positions.\n        coordinate_origin: Origin for coordinate system [x, y, z].\n        **kwargs: Additional PointCloudLayer props.\n\n    Example:\n        &gt;&gt;&gt; from anymap_ts import MapLibreMap\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; m = MapLibreMap(pitch=45)\n        &gt;&gt;&gt; points = [\n        ...     {\"position\": [-122.4, 37.8, 100], \"color\": [255, 0, 0, 255]},\n        ...     {\"position\": [-122.3, 37.7, 200], \"color\": [0, 255, 0, 255]},\n        ... ]\n        &gt;&gt;&gt; m.add_point_cloud_layer(points, point_size=5)\n    \"\"\"\n    layer_id = name or f\"pointcloud-{len(self._layers)}\"\n    processed_data = self._process_deck_data(data)\n\n    self.call_js_method(\n        \"addPointCloudLayer\",\n        id=layer_id,\n        data=processed_data,\n        getPosition=get_position,\n        getColor=get_color or [255, 255, 255, 255],\n        getNormal=get_normal,\n        pointSize=point_size,\n        sizeUnits=size_units,\n        pickable=pickable,\n        opacity=opacity,\n        material=material,\n        coordinateSystem=coordinate_system,\n        coordinateOrigin=coordinate_origin,\n        **kwargs,\n    )\n\n    self._layers = {\n        **self._layers,\n        layer_id: {\n            \"id\": layer_id,\n            \"type\": \"pointcloud\",\n        },\n    }\n    self._add_to_layer_dict(layer_id, \"Deck.gl\")\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.maplibre.MapLibreMap.add_polygon_layer","title":"<code>add_polygon_layer(self, data, name=None, get_polygon='polygon', get_fill_color=None, get_line_color=None, get_line_width=1, get_elevation=0, extruded=False, wireframe=False, filled=True, stroked=True, line_width_min_pixels=1, pickable=True, opacity=0.5, **kwargs)</code>","text":"<p>Add a polygon layer for filled polygon visualization using deck.gl.</p> <p>Polygon layers render filled and/or stroked polygons with optional 3D extrusion, ideal for choropleth maps and area visualizations.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>Array of data objects with polygon coordinates.</p> required <code>name</code> <code>Optional[str]</code> <p>Layer ID. If None, auto-generated.</p> <code>None</code> <code>get_polygon</code> <code>Union[str, Any]</code> <p>Accessor for polygon coordinates. Can be a string (property name) or a value.</p> <code>'polygon'</code> <code>get_fill_color</code> <code>Optional[Union[List[int], str]]</code> <p>Accessor for fill color [r, g, b, a]. Default: [51, 136, 255, 128].</p> <code>None</code> <code>get_line_color</code> <code>Optional[Union[List[int], str]]</code> <p>Accessor for stroke color [r, g, b, a]. Default: [0, 0, 255, 255].</p> <code>None</code> <code>get_line_width</code> <code>Union[float, str]</code> <p>Accessor for stroke width.</p> <code>1</code> <code>get_elevation</code> <code>Union[float, str]</code> <p>Accessor for 3D extrusion height.</p> <code>0</code> <code>extruded</code> <code>bool</code> <p>Whether to render as 3D polygons.</p> <code>False</code> <code>wireframe</code> <code>bool</code> <p>Whether to render wireframe (extruded only).</p> <code>False</code> <code>filled</code> <code>bool</code> <p>Whether to fill polygons.</p> <code>True</code> <code>stroked</code> <code>bool</code> <p>Whether to draw stroke.</p> <code>True</code> <code>line_width_min_pixels</code> <code>float</code> <p>Minimum stroke width in pixels.</p> <code>1</code> <code>pickable</code> <code>bool</code> <p>Whether layer responds to hover/click events.</p> <code>True</code> <code>opacity</code> <code>float</code> <p>Layer opacity (0-1).</p> <code>0.5</code> <code>**kwargs</code> <p>Additional PolygonLayer props.</p> <code>{}</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from anymap_ts import MapLibreMap\n&gt;&gt;&gt; m = MapLibreMap(pitch=45)\n&gt;&gt;&gt; polygons = [\n...     {\"polygon\": [[-122.4, 37.8], [-122.5, 37.7], [-122.3, 37.7]], \"height\": 1000},\n... ]\n&gt;&gt;&gt; m.add_polygon_layer(polygons, extruded=True, get_elevation=\"height\")\n</code></pre> Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def add_polygon_layer(\n    self,\n    data: Any,\n    name: Optional[str] = None,\n    get_polygon: Union[str, Any] = \"polygon\",\n    get_fill_color: Optional[Union[List[int], str]] = None,\n    get_line_color: Optional[Union[List[int], str]] = None,\n    get_line_width: Union[float, str] = 1,\n    get_elevation: Union[float, str] = 0,\n    extruded: bool = False,\n    wireframe: bool = False,\n    filled: bool = True,\n    stroked: bool = True,\n    line_width_min_pixels: float = 1,\n    pickable: bool = True,\n    opacity: float = 0.5,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a polygon layer for filled polygon visualization using deck.gl.\n\n    Polygon layers render filled and/or stroked polygons with optional\n    3D extrusion, ideal for choropleth maps and area visualizations.\n\n    Args:\n        data: Array of data objects with polygon coordinates.\n        name: Layer ID. If None, auto-generated.\n        get_polygon: Accessor for polygon coordinates.\n            Can be a string (property name) or a value.\n        get_fill_color: Accessor for fill color [r, g, b, a].\n            Default: [51, 136, 255, 128].\n        get_line_color: Accessor for stroke color [r, g, b, a].\n            Default: [0, 0, 255, 255].\n        get_line_width: Accessor for stroke width.\n        get_elevation: Accessor for 3D extrusion height.\n        extruded: Whether to render as 3D polygons.\n        wireframe: Whether to render wireframe (extruded only).\n        filled: Whether to fill polygons.\n        stroked: Whether to draw stroke.\n        line_width_min_pixels: Minimum stroke width in pixels.\n        pickable: Whether layer responds to hover/click events.\n        opacity: Layer opacity (0-1).\n        **kwargs: Additional PolygonLayer props.\n\n    Example:\n        &gt;&gt;&gt; from anymap_ts import MapLibreMap\n        &gt;&gt;&gt; m = MapLibreMap(pitch=45)\n        &gt;&gt;&gt; polygons = [\n        ...     {\"polygon\": [[-122.4, 37.8], [-122.5, 37.7], [-122.3, 37.7]], \"height\": 1000},\n        ... ]\n        &gt;&gt;&gt; m.add_polygon_layer(polygons, extruded=True, get_elevation=\"height\")\n    \"\"\"\n    layer_id = name or f\"polygon-{len(self._layers)}\"\n    processed_data = self._process_deck_data(data)\n\n    self.call_js_method(\n        \"addPolygonLayer\",\n        id=layer_id,\n        data=processed_data,\n        getPolygon=get_polygon,\n        getFillColor=get_fill_color or [51, 136, 255, 128],\n        getLineColor=get_line_color or [0, 0, 255, 255],\n        getLineWidth=get_line_width,\n        getElevation=get_elevation,\n        extruded=extruded,\n        wireframe=wireframe,\n        filled=filled,\n        stroked=stroked,\n        lineWidthMinPixels=line_width_min_pixels,\n        pickable=pickable,\n        opacity=opacity,\n        **kwargs,\n    )\n\n    self._layers = {\n        **self._layers,\n        layer_id: {\n            \"id\": layer_id,\n            \"type\": \"polygon\",\n        },\n    }\n    self._add_to_layer_dict(layer_id, \"Deck.gl\")\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.maplibre.MapLibreMap.add_popup","title":"<code>add_popup(self, layer_id, properties=None, template=None, **kwargs)</code>","text":"<p>Add popup on click for a layer.</p> <p>Configures a layer to show a popup when features are clicked.</p> <p>Parameters:</p> Name Type Description Default <code>layer_id</code> <code>str</code> <p>Layer identifier to add popup to.</p> required <code>properties</code> <code>Optional[List[str]]</code> <p>List of property names to display. If None, shows all.</p> <code>None</code> <code>template</code> <code>Optional[str]</code> <p>Custom HTML template for popup content. Use {property_name} placeholders for values. If None, auto-generates table.</p> <code>None</code> <code>**kwargs</code> <p>Additional popup options (maxWidth, closeButton, etc.).</p> <code>{}</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; m.add_vector(geojson, name=\"cities\")\n&gt;&gt;&gt; m.add_popup(\"cities\", properties=[\"name\", \"population\"])\n&gt;&gt;&gt; # Or with custom template:\n&gt;&gt;&gt; m.add_popup(\"cities\", template=\"&lt;h3&gt;{name}&lt;/h3&gt;&lt;p&gt;Pop: {population}&lt;/p&gt;\")\n</code></pre> Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def add_popup(\n    self,\n    layer_id: str,\n    properties: Optional[List[str]] = None,\n    template: Optional[str] = None,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add popup on click for a layer.\n\n    Configures a layer to show a popup when features are clicked.\n\n    Args:\n        layer_id: Layer identifier to add popup to.\n        properties: List of property names to display. If None, shows all.\n        template: Custom HTML template for popup content. Use {property_name}\n            placeholders for values. If None, auto-generates table.\n        **kwargs: Additional popup options (maxWidth, closeButton, etc.).\n\n    Example:\n        &gt;&gt;&gt; m.add_vector(geojson, name=\"cities\")\n        &gt;&gt;&gt; m.add_popup(\"cities\", properties=[\"name\", \"population\"])\n        &gt;&gt;&gt; # Or with custom template:\n        &gt;&gt;&gt; m.add_popup(\"cities\", template=\"&lt;h3&gt;{name}&lt;/h3&gt;&lt;p&gt;Pop: {population}&lt;/p&gt;\")\n    \"\"\"\n    self.call_js_method(\n        \"addPopup\",\n        layerId=layer_id,\n        properties=properties,\n        template=template,\n        **kwargs,\n    )\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.maplibre.MapLibreMap.add_print_control","title":"<code>add_print_control(self, position='top-right', collapsed=True, format='png', filename='map-export', include_north_arrow=False, include_scale_bar=False, **kwargs)</code>","text":"<p>Add a print/export control for saving the map as an image.</p> <p>Provides an interactive panel for exporting the current map view as PNG, JPEG, or PDF files.</p> <p>Parameters:</p> Name Type Description Default <code>position</code> <code>str</code> <p>Control position ('top-left', 'top-right', 'bottom-left', 'bottom-right').</p> <code>'top-right'</code> <code>collapsed</code> <code>bool</code> <p>Whether the control starts collapsed.</p> <code>True</code> <code>format</code> <code>str</code> <p>Default image format ('png', 'jpeg', 'pdf').</p> <code>'png'</code> <code>filename</code> <code>str</code> <p>Default filename (without extension).</p> <code>'map-export'</code> <code>include_north_arrow</code> <code>bool</code> <p>Whether to include a north arrow by default.</p> <code>False</code> <code>include_scale_bar</code> <code>bool</code> <p>Whether to include a scale bar by default.</p> <code>False</code> <code>**kwargs</code> <p>Additional PrintControl options.</p> <code>{}</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; m = Map()\n&gt;&gt;&gt; m.add_print_control(\n...     format=\"png\",\n...     filename=\"my-map\",\n...     include_scale_bar=True,\n... )\n</code></pre> Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def add_print_control(\n    self,\n    position: str = \"top-right\",\n    collapsed: bool = True,\n    format: str = \"png\",\n    filename: str = \"map-export\",\n    include_north_arrow: bool = False,\n    include_scale_bar: bool = False,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a print/export control for saving the map as an image.\n\n    Provides an interactive panel for exporting the current map view\n    as PNG, JPEG, or PDF files.\n\n    Args:\n        position: Control position ('top-left', 'top-right',\n            'bottom-left', 'bottom-right').\n        collapsed: Whether the control starts collapsed.\n        format: Default image format ('png', 'jpeg', 'pdf').\n        filename: Default filename (without extension).\n        include_north_arrow: Whether to include a north arrow by default.\n        include_scale_bar: Whether to include a scale bar by default.\n        **kwargs: Additional PrintControl options.\n\n    Example:\n        &gt;&gt;&gt; m = Map()\n        &gt;&gt;&gt; m.add_print_control(\n        ...     format=\"png\",\n        ...     filename=\"my-map\",\n        ...     include_scale_bar=True,\n        ... )\n    \"\"\"\n    self._validate_position(position)\n    self.call_js_method(\n        \"addPrintControl\",\n        position=position,\n        collapsed=collapsed,\n        format=format,\n        filename=filename,\n        includeNorthArrow=include_north_arrow,\n        includeScaleBar=include_scale_bar,\n        **kwargs,\n    )\n    self._controls = {\n        **self._controls,\n        \"print-control\": {\n            \"type\": \"print-control\",\n            \"position\": position,\n            \"collapsed\": collapsed,\n        },\n    }\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.maplibre.MapLibreMap.add_raster","title":"<code>add_raster(self, source, name=None, attribution='', indexes=None, colormap=None, vmin=None, vmax=None, nodata=None, fit_bounds=True, **kwargs)</code>","text":"<p>Add a raster layer from a local file using localtileserver.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>str</code> <p>Path to local raster file</p> required <code>name</code> <code>Optional[str]</code> <p>Layer name</p> <code>None</code> <code>attribution</code> <code>str</code> <p>Attribution text</p> <code>''</code> <code>indexes</code> <code>Optional[List[int]]</code> <p>Band indexes to use</p> <code>None</code> <code>colormap</code> <code>Optional[str]</code> <p>Colormap name</p> <code>None</code> <code>vmin</code> <code>Optional[float]</code> <p>Minimum value for colormap</p> <code>None</code> <code>vmax</code> <code>Optional[float]</code> <p>Maximum value for colormap</p> <code>None</code> <code>nodata</code> <code>Optional[float]</code> <p>NoData value</p> <code>None</code> <code>fit_bounds</code> <code>bool</code> <p>Whether to fit map to raster bounds</p> <code>True</code> <code>**kwargs</code> <p>Additional options</p> <code>{}</code> Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def add_raster(\n    self,\n    source: str,\n    name: Optional[str] = None,\n    attribution: str = \"\",\n    indexes: Optional[List[int]] = None,\n    colormap: Optional[str] = None,\n    vmin: Optional[float] = None,\n    vmax: Optional[float] = None,\n    nodata: Optional[float] = None,\n    fit_bounds: bool = True,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a raster layer from a local file using localtileserver.\n\n    Args:\n        source: Path to local raster file\n        name: Layer name\n        attribution: Attribution text\n        indexes: Band indexes to use\n        colormap: Colormap name\n        vmin: Minimum value for colormap\n        vmax: Maximum value for colormap\n        nodata: NoData value\n        fit_bounds: Whether to fit map to raster bounds\n        **kwargs: Additional options\n    \"\"\"\n    try:\n        from localtileserver import TileClient\n    except ImportError:\n        raise ImportError(\n            \"localtileserver is required for local raster support. \"\n            \"Install with: pip install anymap-ts[raster]\"\n        )\n\n    client = TileClient(source)\n\n    # Build parameters dict and pass all at once\n    tile_params = {}\n    if indexes:\n        tile_params[\"indexes\"] = indexes\n    if colormap:\n        tile_params[\"colormap\"] = colormap\n    if vmin is not None or vmax is not None:\n        tile_params[\"vmin\"] = vmin if vmin is not None else client.min\n        tile_params[\"vmax\"] = vmax if vmax is not None else client.max\n    if nodata is not None:\n        tile_params[\"nodata\"] = nodata\n\n    tile_url = client.get_tile_url(**tile_params)\n\n    layer_name = name or Path(source).stem\n\n    self.add_tile_layer(\n        tile_url,\n        name=layer_name,\n        attribution=attribution,\n        **kwargs,\n    )\n\n    # Fit bounds if requested\n    if fit_bounds:\n        bounds = client.bounds()\n        if bounds:\n            self.fit_bounds([bounds[0], bounds[1], bounds[2], bounds[3]])\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.maplibre.MapLibreMap.add_scatterplot_layer","title":"<code>add_scatterplot_layer(self, data, name=None, get_position='coordinates', get_radius=5, get_fill_color=None, get_line_color=None, radius_scale=1, radius_min_pixels=1, radius_max_pixels=100, line_width_min_pixels=1, stroked=True, filled=True, pickable=True, opacity=0.8, **kwargs)</code>","text":"<p>Add a scatterplot layer for sized/colored point visualization using deck.gl.</p> <p>Scatterplot layers render circles at given coordinates with configurable radius and color, ideal for point datasets where size and color encode data.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>Array of data objects or GeoJSON with point coordinates.</p> required <code>name</code> <code>Optional[str]</code> <p>Layer ID. If None, auto-generated.</p> <code>None</code> <code>get_position</code> <code>Union[str, Any]</code> <p>Accessor for point position [lng, lat]. Can be a string (property name) or a value.</p> <code>'coordinates'</code> <code>get_radius</code> <code>Union[float, str]</code> <p>Accessor for point radius in meters.</p> <code>5</code> <code>get_fill_color</code> <code>Optional[Union[List[int], str]]</code> <p>Accessor for fill color [r, g, b, a]. Default: [51, 136, 255, 200] (blue).</p> <code>None</code> <code>get_line_color</code> <code>Optional[Union[List[int], str]]</code> <p>Accessor for stroke color [r, g, b, a]. Default: [255, 255, 255, 255] (white).</p> <code>None</code> <code>radius_scale</code> <code>float</code> <p>Global radius multiplier.</p> <code>1</code> <code>radius_min_pixels</code> <code>float</code> <p>Minimum radius in pixels.</p> <code>1</code> <code>radius_max_pixels</code> <code>float</code> <p>Maximum radius in pixels.</p> <code>100</code> <code>line_width_min_pixels</code> <code>float</code> <p>Minimum stroke width in pixels.</p> <code>1</code> <code>stroked</code> <code>bool</code> <p>Whether to draw stroke around points.</p> <code>True</code> <code>filled</code> <code>bool</code> <p>Whether to fill points.</p> <code>True</code> <code>pickable</code> <code>bool</code> <p>Whether layer responds to hover/click events.</p> <code>True</code> <code>opacity</code> <code>float</code> <p>Layer opacity (0-1).</p> <code>0.8</code> <code>**kwargs</code> <p>Additional ScatterplotLayer props.</p> <code>{}</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from anymap_ts import MapLibreMap\n&gt;&gt;&gt; m = MapLibreMap()\n&gt;&gt;&gt; points = [\n...     {\"coordinates\": [-122.4, 37.8], \"size\": 100},\n...     {\"coordinates\": [-122.5, 37.7], \"size\": 200},\n... ]\n&gt;&gt;&gt; m.add_scatterplot_layer(points, get_radius=\"size\")\n</code></pre> Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def add_scatterplot_layer(\n    self,\n    data: Any,\n    name: Optional[str] = None,\n    get_position: Union[str, Any] = \"coordinates\",\n    get_radius: Union[float, str] = 5,\n    get_fill_color: Optional[Union[List[int], str]] = None,\n    get_line_color: Optional[Union[List[int], str]] = None,\n    radius_scale: float = 1,\n    radius_min_pixels: float = 1,\n    radius_max_pixels: float = 100,\n    line_width_min_pixels: float = 1,\n    stroked: bool = True,\n    filled: bool = True,\n    pickable: bool = True,\n    opacity: float = 0.8,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a scatterplot layer for sized/colored point visualization using deck.gl.\n\n    Scatterplot layers render circles at given coordinates with configurable\n    radius and color, ideal for point datasets where size and color encode data.\n\n    Args:\n        data: Array of data objects or GeoJSON with point coordinates.\n        name: Layer ID. If None, auto-generated.\n        get_position: Accessor for point position [lng, lat].\n            Can be a string (property name) or a value.\n        get_radius: Accessor for point radius in meters.\n        get_fill_color: Accessor for fill color [r, g, b, a].\n            Default: [51, 136, 255, 200] (blue).\n        get_line_color: Accessor for stroke color [r, g, b, a].\n            Default: [255, 255, 255, 255] (white).\n        radius_scale: Global radius multiplier.\n        radius_min_pixels: Minimum radius in pixels.\n        radius_max_pixels: Maximum radius in pixels.\n        line_width_min_pixels: Minimum stroke width in pixels.\n        stroked: Whether to draw stroke around points.\n        filled: Whether to fill points.\n        pickable: Whether layer responds to hover/click events.\n        opacity: Layer opacity (0-1).\n        **kwargs: Additional ScatterplotLayer props.\n\n    Example:\n        &gt;&gt;&gt; from anymap_ts import MapLibreMap\n        &gt;&gt;&gt; m = MapLibreMap()\n        &gt;&gt;&gt; points = [\n        ...     {\"coordinates\": [-122.4, 37.8], \"size\": 100},\n        ...     {\"coordinates\": [-122.5, 37.7], \"size\": 200},\n        ... ]\n        &gt;&gt;&gt; m.add_scatterplot_layer(points, get_radius=\"size\")\n    \"\"\"\n    layer_id = name or f\"scatterplot-{len(self._layers)}\"\n    processed_data = self._process_deck_data(data)\n\n    self.call_js_method(\n        \"addScatterplotLayer\",\n        id=layer_id,\n        data=processed_data,\n        getPosition=get_position,\n        getRadius=get_radius,\n        getFillColor=get_fill_color or [51, 136, 255, 200],\n        getLineColor=get_line_color or [255, 255, 255, 255],\n        radiusScale=radius_scale,\n        radiusMinPixels=radius_min_pixels,\n        radiusMaxPixels=radius_max_pixels,\n        lineWidthMinPixels=line_width_min_pixels,\n        stroked=stroked,\n        filled=filled,\n        pickable=pickable,\n        opacity=opacity,\n        **kwargs,\n    )\n\n    self._layers = {\n        **self._layers,\n        layer_id: {\n            \"id\": layer_id,\n            \"type\": \"scatterplot\",\n        },\n    }\n    self._add_to_layer_dict(layer_id, \"Deck.gl\")\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.maplibre.MapLibreMap.add_screen_grid_layer","title":"<code>add_screen_grid_layer(self, data, name=None, get_position='coordinates', get_weight=1, cell_size_pixels=50, color_range=None, pickable=True, opacity=0.8, **kwargs)</code>","text":"<p>Add a screen grid layer for screen-space grid aggregation using deck.gl.</p> <p>Screen grid layers aggregate points into a grid in screen space, providing a fast overview of point density that updates on zoom/pan.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>Array of data objects with position coordinates.</p> required <code>name</code> <code>Optional[str]</code> <p>Layer ID. If None, auto-generated.</p> <code>None</code> <code>get_position</code> <code>Union[str, Any]</code> <p>Accessor for point position [lng, lat].</p> <code>'coordinates'</code> <code>get_weight</code> <code>Union[float, str]</code> <p>Accessor for point weight value.</p> <code>1</code> <code>cell_size_pixels</code> <code>float</code> <p>Grid cell size in screen pixels.</p> <code>50</code> <code>color_range</code> <code>Optional[List[List[int]]]</code> <p>Color gradient [[r, g, b, a], ...].</p> <code>None</code> <code>pickable</code> <code>bool</code> <p>Whether layer responds to hover/click events.</p> <code>True</code> <code>opacity</code> <code>float</code> <p>Layer opacity (0-1).</p> <code>0.8</code> <code>**kwargs</code> <p>Additional ScreenGridLayer props.</p> <code>{}</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from anymap_ts import MapLibreMap\n&gt;&gt;&gt; m = MapLibreMap()\n&gt;&gt;&gt; points = [\n...     {\"coordinates\": [-122.4, 37.8]},\n...     {\"coordinates\": [-122.41, 37.81]},\n... ]\n&gt;&gt;&gt; m.add_screen_grid_layer(points, cell_size_pixels=30)\n</code></pre> Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def add_screen_grid_layer(\n    self,\n    data: Any,\n    name: Optional[str] = None,\n    get_position: Union[str, Any] = \"coordinates\",\n    get_weight: Union[float, str] = 1,\n    cell_size_pixels: float = 50,\n    color_range: Optional[List[List[int]]] = None,\n    pickable: bool = True,\n    opacity: float = 0.8,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a screen grid layer for screen-space grid aggregation using deck.gl.\n\n    Screen grid layers aggregate points into a grid in screen space,\n    providing a fast overview of point density that updates on zoom/pan.\n\n    Args:\n        data: Array of data objects with position coordinates.\n        name: Layer ID. If None, auto-generated.\n        get_position: Accessor for point position [lng, lat].\n        get_weight: Accessor for point weight value.\n        cell_size_pixels: Grid cell size in screen pixels.\n        color_range: Color gradient [[r, g, b, a], ...].\n        pickable: Whether layer responds to hover/click events.\n        opacity: Layer opacity (0-1).\n        **kwargs: Additional ScreenGridLayer props.\n\n    Example:\n        &gt;&gt;&gt; from anymap_ts import MapLibreMap\n        &gt;&gt;&gt; m = MapLibreMap()\n        &gt;&gt;&gt; points = [\n        ...     {\"coordinates\": [-122.4, 37.8]},\n        ...     {\"coordinates\": [-122.41, 37.81]},\n        ... ]\n        &gt;&gt;&gt; m.add_screen_grid_layer(points, cell_size_pixels=30)\n    \"\"\"\n    layer_id = name or f\"screengrid-{len(self._layers)}\"\n    processed_data = self._process_deck_data(data)\n\n    default_color_range = [\n        [255, 255, 178, 25],\n        [254, 217, 118, 85],\n        [254, 178, 76, 127],\n        [253, 141, 60, 170],\n        [240, 59, 32, 212],\n        [189, 0, 38, 255],\n    ]\n\n    self.call_js_method(\n        \"addScreenGridLayer\",\n        id=layer_id,\n        data=processed_data,\n        getPosition=get_position,\n        getWeight=get_weight,\n        cellSizePixels=cell_size_pixels,\n        colorRange=color_range or default_color_range,\n        pickable=pickable,\n        opacity=opacity,\n        **kwargs,\n    )\n\n    self._layers = {\n        **self._layers,\n        layer_id: {\n            \"id\": layer_id,\n            \"type\": \"screengrid\",\n        },\n    }\n    self._add_to_layer_dict(layer_id, \"Deck.gl\")\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.maplibre.MapLibreMap.add_search_control","title":"<code>add_search_control(self, position='top-left', placeholder='Search places...', collapsed=True, fly_to_zoom=14, show_marker=True, marker_color='#4264fb', **kwargs)</code>","text":"<p>Add a search/geocoder control using Nominatim.</p> <p>Provides place search functionality with autocomplete results. Results are geocoded via OpenStreetMap Nominatim service.</p> <p>Parameters:</p> Name Type Description Default <code>position</code> <code>str</code> <p>Control position ('top-left', 'top-right', 'bottom-left', 'bottom-right').</p> <code>'top-left'</code> <code>placeholder</code> <code>str</code> <p>Placeholder text for the search input.</p> <code>'Search places...'</code> <code>collapsed</code> <code>bool</code> <p>Whether the control starts collapsed (icon only).</p> <code>True</code> <code>fly_to_zoom</code> <code>int</code> <p>Zoom level to fly to when selecting a result.</p> <code>14</code> <code>show_marker</code> <code>bool</code> <p>Whether to add a marker at the selected location.</p> <code>True</code> <code>marker_color</code> <code>str</code> <p>Color of the result marker.</p> <code>'#4264fb'</code> <code>**kwargs</code> <p>Additional SearchControl options.</p> <code>{}</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; m = Map()\n&gt;&gt;&gt; m.add_search_control(position=\"top-left\", fly_to_zoom=12)\n</code></pre> Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def add_search_control(\n    self,\n    position: str = \"top-left\",\n    placeholder: str = \"Search places...\",\n    collapsed: bool = True,\n    fly_to_zoom: int = 14,\n    show_marker: bool = True,\n    marker_color: str = \"#4264fb\",\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a search/geocoder control using Nominatim.\n\n    Provides place search functionality with autocomplete results.\n    Results are geocoded via OpenStreetMap Nominatim service.\n\n    Args:\n        position: Control position ('top-left', 'top-right',\n            'bottom-left', 'bottom-right').\n        placeholder: Placeholder text for the search input.\n        collapsed: Whether the control starts collapsed (icon only).\n        fly_to_zoom: Zoom level to fly to when selecting a result.\n        show_marker: Whether to add a marker at the selected location.\n        marker_color: Color of the result marker.\n        **kwargs: Additional SearchControl options.\n\n    Example:\n        &gt;&gt;&gt; m = Map()\n        &gt;&gt;&gt; m.add_search_control(position=\"top-left\", fly_to_zoom=12)\n    \"\"\"\n    self._validate_position(position)\n    self.call_js_method(\n        \"addSearchControl\",\n        position=position,\n        placeholder=placeholder,\n        collapsed=collapsed,\n        flyToZoom=fly_to_zoom,\n        showMarker=show_marker,\n        markerColor=marker_color,\n        **kwargs,\n    )\n    self._controls = {\n        **self._controls,\n        \"search-control\": {\n            \"type\": \"search-control\",\n            \"position\": position,\n            \"collapsed\": collapsed,\n        },\n    }\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.maplibre.MapLibreMap.add_solid_polygon_layer","title":"<code>add_solid_polygon_layer(self, data, name=None, get_polygon='polygon', get_fill_color=None, get_line_color=None, get_elevation=0, filled=True, extruded=False, wireframe=False, elevation_scale=1, pickable=True, opacity=0.8, **kwargs)</code>","text":"<p>Add a solid polygon layer for extruded 3D polygon visualization using deck.gl.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>Array of data objects with polygon coordinates.</p> required <code>name</code> <code>Optional[str]</code> <p>Layer ID. If None, auto-generated.</p> <code>None</code> <code>get_polygon</code> <code>Union[str, Any]</code> <p>Accessor for polygon coordinates.</p> <code>'polygon'</code> <code>get_fill_color</code> <code>Optional[Union[List[int], str]]</code> <p>Accessor for fill color [r, g, b, a].</p> <code>None</code> <code>get_line_color</code> <code>Optional[Union[List[int], str]]</code> <p>Accessor for stroke color [r, g, b, a].</p> <code>None</code> <code>get_elevation</code> <code>Union[float, str]</code> <p>Accessor for 3D extrusion height.</p> <code>0</code> <code>filled</code> <code>bool</code> <p>Whether to fill polygons.</p> <code>True</code> <code>extruded</code> <code>bool</code> <p>Whether to render as 3D polygons.</p> <code>False</code> <code>wireframe</code> <code>bool</code> <p>Whether to render wireframe.</p> <code>False</code> <code>elevation_scale</code> <code>float</code> <p>Elevation multiplier.</p> <code>1</code> <code>pickable</code> <code>bool</code> <p>Whether layer responds to hover/click events.</p> <code>True</code> <code>opacity</code> <code>float</code> <p>Layer opacity (0-1).</p> <code>0.8</code> <code>**kwargs</code> <p>Additional SolidPolygonLayer props.</p> <code>{}</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from anymap_ts import MapLibreMap\n&gt;&gt;&gt; m = MapLibreMap(pitch=45)\n&gt;&gt;&gt; data = [\n...     {\"polygon\": [[-122.4, 37.8], [-122.5, 37.7], [-122.3, 37.7]], \"height\": 500},\n... ]\n&gt;&gt;&gt; m.add_solid_polygon_layer(data, extruded=True, get_elevation=\"height\")\n</code></pre> Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def add_solid_polygon_layer(\n    self,\n    data: Any,\n    name: Optional[str] = None,\n    get_polygon: Union[str, Any] = \"polygon\",\n    get_fill_color: Optional[Union[List[int], str]] = None,\n    get_line_color: Optional[Union[List[int], str]] = None,\n    get_elevation: Union[float, str] = 0,\n    filled: bool = True,\n    extruded: bool = False,\n    wireframe: bool = False,\n    elevation_scale: float = 1,\n    pickable: bool = True,\n    opacity: float = 0.8,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a solid polygon layer for extruded 3D polygon visualization using deck.gl.\n\n    Args:\n        data: Array of data objects with polygon coordinates.\n        name: Layer ID. If None, auto-generated.\n        get_polygon: Accessor for polygon coordinates.\n        get_fill_color: Accessor for fill color [r, g, b, a].\n        get_line_color: Accessor for stroke color [r, g, b, a].\n        get_elevation: Accessor for 3D extrusion height.\n        filled: Whether to fill polygons.\n        extruded: Whether to render as 3D polygons.\n        wireframe: Whether to render wireframe.\n        elevation_scale: Elevation multiplier.\n        pickable: Whether layer responds to hover/click events.\n        opacity: Layer opacity (0-1).\n        **kwargs: Additional SolidPolygonLayer props.\n\n    Example:\n        &gt;&gt;&gt; from anymap_ts import MapLibreMap\n        &gt;&gt;&gt; m = MapLibreMap(pitch=45)\n        &gt;&gt;&gt; data = [\n        ...     {\"polygon\": [[-122.4, 37.8], [-122.5, 37.7], [-122.3, 37.7]], \"height\": 500},\n        ... ]\n        &gt;&gt;&gt; m.add_solid_polygon_layer(data, extruded=True, get_elevation=\"height\")\n    \"\"\"\n    layer_id = name or f\"solidpolygon-{len(self._layers)}\"\n    processed_data = self._process_deck_data(data)\n\n    self.call_js_method(\n        \"addSolidPolygonLayer\",\n        id=layer_id,\n        data=processed_data,\n        getPolygon=get_polygon,\n        getFillColor=get_fill_color or [51, 136, 255, 128],\n        getLineColor=get_line_color or [0, 0, 0, 255],\n        getElevation=get_elevation,\n        filled=filled,\n        extruded=extruded,\n        wireframe=wireframe,\n        elevationScale=elevation_scale,\n        pickable=pickable,\n        opacity=opacity,\n        **kwargs,\n    )\n\n    self._layers = {\n        **self._layers,\n        layer_id: {\"id\": layer_id, \"type\": \"solidpolygon\"},\n    }\n    self._add_to_layer_dict(layer_id, \"Deck.gl\")\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.maplibre.MapLibreMap.add_split_map","title":"<code>add_split_map(self, left_layer, right_layer, position=50)</code>","text":"<p>Add a split map comparison view with a draggable divider.</p> <p>Creates a side-by-side comparison of two layers. The left side shows the left layer and the right side shows the right layer, with a draggable slider to adjust the split position.</p> <p>Parameters:</p> Name Type Description Default <code>left_layer</code> <code>str</code> <p>Layer ID for the left side.</p> required <code>right_layer</code> <code>str</code> <p>Layer ID for the right side.</p> required <code>position</code> <code>int</code> <p>Initial slider position as percentage (0-100). Default is 50 (middle).</p> <code>50</code> <p>Note</p> <p>Both layers must exist on the map before calling this method. Best suited for raster tile layers (e.g., satellite vs streets).</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; m.add_tile_layer(\n...     \"https://mt1.google.com/vt/lyrs=s&amp;x={x}&amp;y={y}&amp;z={z}\",\n...     name=\"satellite\",\n... )\n&gt;&gt;&gt; m.add_tile_layer(\n...     \"https://tile.openstreetmap.org/{z}/{x}/{y}.png\",\n...     name=\"osm\",\n... )\n&gt;&gt;&gt; m.add_split_map(\"satellite\", \"osm\")\n</code></pre> Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def add_split_map(\n    self,\n    left_layer: str,\n    right_layer: str,\n    position: int = 50,\n) -&gt; None:\n    \"\"\"Add a split map comparison view with a draggable divider.\n\n    Creates a side-by-side comparison of two layers. The left side shows\n    the left layer and the right side shows the right layer, with a\n    draggable slider to adjust the split position.\n\n    Args:\n        left_layer: Layer ID for the left side.\n        right_layer: Layer ID for the right side.\n        position: Initial slider position as percentage (0-100).\n            Default is 50 (middle).\n\n    Note:\n        Both layers must exist on the map before calling this method.\n        Best suited for raster tile layers (e.g., satellite vs streets).\n\n    Example:\n        &gt;&gt;&gt; m.add_tile_layer(\n        ...     \"https://mt1.google.com/vt/lyrs=s&amp;x={x}&amp;y={y}&amp;z={z}\",\n        ...     name=\"satellite\",\n        ... )\n        &gt;&gt;&gt; m.add_tile_layer(\n        ...     \"https://tile.openstreetmap.org/{z}/{x}/{y}.png\",\n        ...     name=\"osm\",\n        ... )\n        &gt;&gt;&gt; m.add_split_map(\"satellite\", \"osm\")\n    \"\"\"\n    if not 0 &lt;= position &lt;= 100:\n        raise ValueError(f\"position must be between 0 and 100, got {position}\")\n\n    self.call_js_method(\n        \"addSplitMap\",\n        leftLayer=left_layer,\n        rightLayer=right_layer,\n        position=position,\n    )\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.maplibre.MapLibreMap.add_stac_layer","title":"<code>add_stac_layer(self, url=None, item=None, assets=None, colormap=None, rescale=None, opacity=1.0, layer_id=None, titiler_endpoint='https://titiler.xyz', attribution='STAC', fit_bounds=True, **kwargs)</code>","text":"<p>Add a STAC (SpatioTemporal Asset Catalog) layer to the map.</p> <p>Uses TiTiler to render STAC items as XYZ tiles on the map. Supports both STAC item URLs and pystac Item objects.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>Optional[str]</code> <p>URL to a STAC item JSON</p> <code>None</code> <code>item</code> <code>Optional[Any]</code> <p>A pystac Item object</p> <code>None</code> <code>assets</code> <code>Optional[List[str]]</code> <p>List of asset names/bands to visualize</p> <code>None</code> <code>colormap</code> <code>Optional[str]</code> <p>Colormap name (e.g., 'viridis', 'plasma', 'inferno')</p> <code>None</code> <code>rescale</code> <code>Optional[List[float]]</code> <p>Min/max values for rescaling as [min, max]</p> <code>None</code> <code>opacity</code> <code>float</code> <p>Layer opacity (0-1)</p> <code>1.0</code> <code>layer_id</code> <code>Optional[str]</code> <p>Custom layer identifier</p> <code>None</code> <code>titiler_endpoint</code> <code>str</code> <p>TiTiler server endpoint URL</p> <code>'https://titiler.xyz'</code> <code>attribution</code> <code>str</code> <p>Attribution text for the layer</p> <code>'STAC'</code> <code>fit_bounds</code> <code>bool</code> <p>Whether to fit map to STAC item bounds</p> <code>True</code> <code>**kwargs</code> <p>Additional tile layer options</p> <code>{}</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from anymap_ts import Map\n&gt;&gt;&gt; m = Map()\n&gt;&gt;&gt; # From URL\n&gt;&gt;&gt; m.add_stac_layer(\n...     url=\"https://planetarycomputer.microsoft.com/api/stac/v1/collections/sentinel-2-l2a/items/S2A_MSIL2A_20220101T181901_N0301_R027_T10TEM_20220101T201906\",\n...     assets=[\"red\", \"green\", \"blue\"],\n...     rescale=[0, 3000]\n... )\n&gt;&gt;&gt; # From pystac Item\n&gt;&gt;&gt; import pystac\n&gt;&gt;&gt; item = pystac.Item.from_file(\"path/to/item.json\")\n&gt;&gt;&gt; m.add_stac_layer(item=item, assets=[\"nir\", \"red\"], colormap=\"ndvi\")\n</code></pre> Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def add_stac_layer(\n    self,\n    url: Optional[str] = None,\n    item: Optional[Any] = None,\n    assets: Optional[List[str]] = None,\n    colormap: Optional[str] = None,\n    rescale: Optional[List[float]] = None,\n    opacity: float = 1.0,\n    layer_id: Optional[str] = None,\n    titiler_endpoint: str = \"https://titiler.xyz\",\n    attribution: str = \"STAC\",\n    fit_bounds: bool = True,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a STAC (SpatioTemporal Asset Catalog) layer to the map.\n\n    Uses TiTiler to render STAC items as XYZ tiles on the map.\n    Supports both STAC item URLs and pystac Item objects.\n\n    Args:\n        url: URL to a STAC item JSON\n        item: A pystac Item object\n        assets: List of asset names/bands to visualize\n        colormap: Colormap name (e.g., 'viridis', 'plasma', 'inferno')\n        rescale: Min/max values for rescaling as [min, max]\n        opacity: Layer opacity (0-1)\n        layer_id: Custom layer identifier\n        titiler_endpoint: TiTiler server endpoint URL\n        attribution: Attribution text for the layer\n        fit_bounds: Whether to fit map to STAC item bounds\n        **kwargs: Additional tile layer options\n\n    Example:\n        &gt;&gt;&gt; from anymap_ts import Map\n        &gt;&gt;&gt; m = Map()\n        &gt;&gt;&gt; # From URL\n        &gt;&gt;&gt; m.add_stac_layer(\n        ...     url=\"https://planetarycomputer.microsoft.com/api/stac/v1/collections/sentinel-2-l2a/items/S2A_MSIL2A_20220101T181901_N0301_R027_T10TEM_20220101T201906\",\n        ...     assets=[\"red\", \"green\", \"blue\"],\n        ...     rescale=[0, 3000]\n        ... )\n        &gt;&gt;&gt; # From pystac Item\n        &gt;&gt;&gt; import pystac\n        &gt;&gt;&gt; item = pystac.Item.from_file(\"path/to/item.json\")\n        &gt;&gt;&gt; m.add_stac_layer(item=item, assets=[\"nir\", \"red\"], colormap=\"ndvi\")\n    \"\"\"\n    if url is None and item is None:\n        raise ValueError(\"Either 'url' or 'item' must be provided\")\n\n    if url is not None and item is not None:\n        raise ValueError(\"Provide either 'url' or 'item', not both\")\n\n    # Handle pystac Item object\n    if item is not None:\n        try:\n            # Check if it's a pystac Item\n            if hasattr(item, \"to_dict\") and hasattr(item, \"self_href\"):\n                stac_url = item.self_href\n                if not stac_url:\n                    # Try to get URL from item properties if no self_href\n                    if hasattr(item, \"links\"):\n                        for link in item.links:\n                            if link.rel == \"self\":\n                                stac_url = link.href\n                                break\n                    if not stac_url:\n                        raise ValueError(\n                            \"STAC item must have a self_href or self link for tile generation\"\n                        )\n            else:\n                raise ValueError(\n                    \"Item must be a pystac Item object with to_dict() and self_href attributes\"\n                )\n        except Exception as e:\n            raise ValueError(f\"Invalid STAC item: {e}\")\n    else:\n        stac_url = url\n\n    # Build TiTiler tile URL\n    tile_params = {\"url\": stac_url}\n\n    if assets:\n        tile_params[\"assets\"] = \",\".join(assets)\n    if colormap:\n        tile_params[\"colormap_name\"] = colormap\n    if rescale:\n        if len(rescale) == 2:\n            tile_params[\"rescale\"] = f\"{rescale[0]},{rescale[1]}\"\n        else:\n            raise ValueError(\"rescale must be a list of two values [min, max]\")\n\n    # Construct tile URL template\n    query_string = urlencode(tile_params)\n    tile_url = f\"{titiler_endpoint.rstrip('/')}/stac/tiles/{{z}}/{{x}}/{{y}}?{query_string}\"\n\n    layer_name = layer_id or f\"stac-{len(self._layers)}\"\n\n    # Add as tile layer\n    self.add_tile_layer(\n        url=tile_url,\n        name=layer_name,\n        attribution=attribution,\n        **kwargs,\n    )\n\n    # Update layer info to mark as STAC\n    if layer_name in self._layers:\n        self._layers[layer_name].update(\n            {\n                \"stac_url\": stac_url,\n                \"stac_assets\": assets,\n                \"colormap\": colormap,\n                \"rescale\": rescale,\n            }\n        )\n\n    # Try to fit bounds if requested and we have an item object\n    if fit_bounds and item is not None:\n        try:\n            bbox = item.bbox\n            if bbox and len(bbox) == 4:\n                self.fit_bounds([[bbox[0], bbox[1]], [bbox[2], bbox[3]]])\n        except Exception:\n            pass  # Skip bounds fitting if bbox is not available\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.maplibre.MapLibreMap.add_style_switcher","title":"<code>add_style_switcher(self, styles, position='top-right')</code>","text":"<p>Add a dropdown to switch between map styles.</p> <p>Parameters:</p> Name Type Description Default <code>styles</code> <code>Dict[str, str]</code> <p>Dict mapping style names to style URLs.</p> required <code>position</code> <code>str</code> <p>Control position.</p> <code>'top-right'</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; m = MapLibreMap()\n&gt;&gt;&gt; m.add_style_switcher({\n...     \"Light\": \"https://basemaps.cartocdn.com/gl/positron-gl-style/style.json\",\n...     \"Dark\": \"https://basemaps.cartocdn.com/gl/dark-matter-gl-style/style.json\",\n...     \"Voyager\": \"https://basemaps.cartocdn.com/gl/voyager-gl-style/style.json\",\n... })\n</code></pre> Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def add_style_switcher(\n    self,\n    styles: Dict[str, str],\n    position: str = \"top-right\",\n) -&gt; None:\n    \"\"\"Add a dropdown to switch between map styles.\n\n    Args:\n        styles: Dict mapping style names to style URLs.\n        position: Control position.\n\n    Example:\n        &gt;&gt;&gt; m = MapLibreMap()\n        &gt;&gt;&gt; m.add_style_switcher({\n        ...     \"Light\": \"https://basemaps.cartocdn.com/gl/positron-gl-style/style.json\",\n        ...     \"Dark\": \"https://basemaps.cartocdn.com/gl/dark-matter-gl-style/style.json\",\n        ...     \"Voyager\": \"https://basemaps.cartocdn.com/gl/voyager-gl-style/style.json\",\n        ... })\n    \"\"\"\n    self.call_js_method(\n        \"addStyleSwitcher\",\n        styles=styles,\n        position=position,\n    )\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.maplibre.MapLibreMap.add_swipe_map","title":"<code>add_swipe_map(self, left_layer, right_layer)</code>","text":"<p>Add a drag-to-compare swipe control for two layers.</p> <p>Unlike split map which is side-by-side, swipe map overlays both layers and uses a draggable divider for before/after comparison.</p> <p>Parameters:</p> Name Type Description Default <code>left_layer</code> <code>str</code> <p>Layer ID for the left side.</p> required <code>right_layer</code> <code>str</code> <p>Layer ID for the right side.</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; m = MapLibreMap()\n&gt;&gt;&gt; m.add_tile_layer(\"...\", name=\"before\")\n&gt;&gt;&gt; m.add_tile_layer(\"...\", name=\"after\")\n&gt;&gt;&gt; m.add_swipe_map(\"before\", \"after\")\n</code></pre> Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def add_swipe_map(self, left_layer: str, right_layer: str) -&gt; None:\n    \"\"\"Add a drag-to-compare swipe control for two layers.\n\n    Unlike split map which is side-by-side, swipe map overlays both\n    layers and uses a draggable divider for before/after comparison.\n\n    Args:\n        left_layer: Layer ID for the left side.\n        right_layer: Layer ID for the right side.\n\n    Example:\n        &gt;&gt;&gt; m = MapLibreMap()\n        &gt;&gt;&gt; m.add_tile_layer(\"...\", name=\"before\")\n        &gt;&gt;&gt; m.add_tile_layer(\"...\", name=\"after\")\n        &gt;&gt;&gt; m.add_swipe_map(\"before\", \"after\")\n    \"\"\"\n    self.call_js_method(\n        \"addSwipeMap\",\n        leftLayer=left_layer,\n        rightLayer=right_layer,\n    )\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.maplibre.MapLibreMap.add_text_layer","title":"<code>add_text_layer(self, data, name=None, get_position='coordinates', get_text='text', get_size=12, get_color=None, get_angle=0, text_anchor='middle', alignment_baseline='center', pickable=True, opacity=1, **kwargs)</code>","text":"<p>Add a text layer for label placement using deck.gl.</p> <p>Text layers render text labels at specified positions, ideal for annotating map features or creating label layers.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>Array of data objects with position and text.</p> required <code>name</code> <code>Optional[str]</code> <p>Layer ID. If None, auto-generated.</p> <code>None</code> <code>get_position</code> <code>Union[str, Any]</code> <p>Accessor for text position [lng, lat].</p> <code>'coordinates'</code> <code>get_text</code> <code>Union[str, Any]</code> <p>Accessor for text content string.</p> <code>'text'</code> <code>get_size</code> <code>Union[float, str]</code> <p>Accessor for text size in pixels.</p> <code>12</code> <code>get_color</code> <code>Optional[Union[List[int], str]]</code> <p>Accessor for text color [r, g, b, a]. Default: [0, 0, 0, 255] (black).</p> <code>None</code> <code>get_angle</code> <code>Union[float, str]</code> <p>Accessor for text rotation in degrees.</p> <code>0</code> <code>text_anchor</code> <code>str</code> <p>Horizontal alignment ('start', 'middle', 'end').</p> <code>'middle'</code> <code>alignment_baseline</code> <code>str</code> <p>Vertical alignment ('top', 'center', 'bottom').</p> <code>'center'</code> <code>pickable</code> <code>bool</code> <p>Whether layer responds to hover/click events.</p> <code>True</code> <code>opacity</code> <code>float</code> <p>Layer opacity (0-1).</p> <code>1</code> <code>**kwargs</code> <p>Additional TextLayer props.</p> <code>{}</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from anymap_ts import MapLibreMap\n&gt;&gt;&gt; m = MapLibreMap()\n&gt;&gt;&gt; labels = [\n...     {\"coordinates\": [-122.4, 37.8], \"text\": \"San Francisco\"},\n...     {\"coordinates\": [-118.2, 34.1], \"text\": \"Los Angeles\"},\n... ]\n&gt;&gt;&gt; m.add_text_layer(labels, get_size=16)\n</code></pre> Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def add_text_layer(\n    self,\n    data: Any,\n    name: Optional[str] = None,\n    get_position: Union[str, Any] = \"coordinates\",\n    get_text: Union[str, Any] = \"text\",\n    get_size: Union[float, str] = 12,\n    get_color: Optional[Union[List[int], str]] = None,\n    get_angle: Union[float, str] = 0,\n    text_anchor: str = \"middle\",\n    alignment_baseline: str = \"center\",\n    pickable: bool = True,\n    opacity: float = 1,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a text layer for label placement using deck.gl.\n\n    Text layers render text labels at specified positions, ideal for\n    annotating map features or creating label layers.\n\n    Args:\n        data: Array of data objects with position and text.\n        name: Layer ID. If None, auto-generated.\n        get_position: Accessor for text position [lng, lat].\n        get_text: Accessor for text content string.\n        get_size: Accessor for text size in pixels.\n        get_color: Accessor for text color [r, g, b, a].\n            Default: [0, 0, 0, 255] (black).\n        get_angle: Accessor for text rotation in degrees.\n        text_anchor: Horizontal alignment ('start', 'middle', 'end').\n        alignment_baseline: Vertical alignment ('top', 'center', 'bottom').\n        pickable: Whether layer responds to hover/click events.\n        opacity: Layer opacity (0-1).\n        **kwargs: Additional TextLayer props.\n\n    Example:\n        &gt;&gt;&gt; from anymap_ts import MapLibreMap\n        &gt;&gt;&gt; m = MapLibreMap()\n        &gt;&gt;&gt; labels = [\n        ...     {\"coordinates\": [-122.4, 37.8], \"text\": \"San Francisco\"},\n        ...     {\"coordinates\": [-118.2, 34.1], \"text\": \"Los Angeles\"},\n        ... ]\n        &gt;&gt;&gt; m.add_text_layer(labels, get_size=16)\n    \"\"\"\n    layer_id = name or f\"text-{len(self._layers)}\"\n    processed_data = self._process_deck_data(data)\n\n    self.call_js_method(\n        \"addTextLayer\",\n        id=layer_id,\n        data=processed_data,\n        getPosition=get_position,\n        getText=get_text,\n        getSize=get_size,\n        getColor=get_color or [0, 0, 0, 255],\n        getAngle=get_angle,\n        getTextAnchor=text_anchor,\n        getAlignmentBaseline=alignment_baseline,\n        pickable=pickable,\n        opacity=opacity,\n        **kwargs,\n    )\n\n    self._layers = {\n        **self._layers,\n        layer_id: {\n            \"id\": layer_id,\n            \"type\": \"text\",\n        },\n    }\n    self._add_to_layer_dict(layer_id, \"Deck.gl\")\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.maplibre.MapLibreMap.add_tile_layer","title":"<code>add_tile_layer(self, url, name=None, attribution='', min_zoom=0, max_zoom=22, **kwargs)</code>","text":"<p>Add an XYZ tile layer.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>Tile URL template with {x}, {y}, {z} placeholders</p> required <code>name</code> <code>Optional[str]</code> <p>Layer name</p> <code>None</code> <code>attribution</code> <code>str</code> <p>Attribution text</p> <code>''</code> <code>min_zoom</code> <code>int</code> <p>Minimum zoom level</p> <code>0</code> <code>max_zoom</code> <code>int</code> <p>Maximum zoom level</p> <code>22</code> <code>**kwargs</code> <p>Additional options</p> <code>{}</code> Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def add_tile_layer(\n    self,\n    url: str,\n    name: Optional[str] = None,\n    attribution: str = \"\",\n    min_zoom: int = 0,\n    max_zoom: int = 22,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add an XYZ tile layer.\n\n    Args:\n        url: Tile URL template with {x}, {y}, {z} placeholders\n        name: Layer name\n        attribution: Attribution text\n        min_zoom: Minimum zoom level\n        max_zoom: Maximum zoom level\n        **kwargs: Additional options\n    \"\"\"\n    layer_id = name or f\"tiles-{len(self._layers)}\"\n\n    self.call_js_method(\n        \"addTileLayer\",\n        url,\n        name=layer_id,\n        attribution=attribution,\n        minZoom=min_zoom,\n        maxZoom=max_zoom,\n        **kwargs,\n    )\n\n    # Track layer\n    self._layers = {\n        **self._layers,\n        layer_id: {\n            \"id\": layer_id,\n            \"type\": \"raster\",\n            \"source\": f\"{layer_id}-source\",\n        },\n    }\n    self._add_to_layer_dict(layer_id, \"Raster\")\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.maplibre.MapLibreMap.add_time_slider","title":"<code>add_time_slider(self, layer_id, property, min_value=0, max_value=100, step=1, position='bottom-left', label='Time', auto_play=False, interval=500)</code>","text":"<p>Add a time slider to filter data by a temporal property.</p> <p>Creates a slider control that filters layer features based on a numeric/temporal property, with optional auto-animation.</p> <p>Parameters:</p> Name Type Description Default <code>layer_id</code> <code>str</code> <p>Layer ID to filter.</p> required <code>property</code> <code>str</code> <p>Property name to filter on.</p> required <code>min_value</code> <code>float</code> <p>Minimum slider value.</p> <code>0</code> <code>max_value</code> <code>float</code> <p>Maximum slider value.</p> <code>100</code> <code>step</code> <code>float</code> <p>Step increment.</p> <code>1</code> <code>position</code> <code>str</code> <p>Control position.</p> <code>'bottom-left'</code> <code>label</code> <code>str</code> <p>Label text for the slider.</p> <code>'Time'</code> <code>auto_play</code> <code>bool</code> <p>Whether to auto-animate through values.</p> <code>False</code> <code>interval</code> <code>int</code> <p>Animation interval in milliseconds.</p> <code>500</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; m = MapLibreMap()\n&gt;&gt;&gt; m.add_geojson(\"events.geojson\", name=\"events\")\n&gt;&gt;&gt; m.add_time_slider(\"events\", \"year\", min_value=2000, max_value=2024)\n</code></pre> Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def add_time_slider(\n    self,\n    layer_id: str,\n    property: str,\n    min_value: float = 0,\n    max_value: float = 100,\n    step: float = 1,\n    position: str = \"bottom-left\",\n    label: str = \"Time\",\n    auto_play: bool = False,\n    interval: int = 500,\n) -&gt; None:\n    \"\"\"Add a time slider to filter data by a temporal property.\n\n    Creates a slider control that filters layer features based on a\n    numeric/temporal property, with optional auto-animation.\n\n    Args:\n        layer_id: Layer ID to filter.\n        property: Property name to filter on.\n        min_value: Minimum slider value.\n        max_value: Maximum slider value.\n        step: Step increment.\n        position: Control position.\n        label: Label text for the slider.\n        auto_play: Whether to auto-animate through values.\n        interval: Animation interval in milliseconds.\n\n    Example:\n        &gt;&gt;&gt; m = MapLibreMap()\n        &gt;&gt;&gt; m.add_geojson(\"events.geojson\", name=\"events\")\n        &gt;&gt;&gt; m.add_time_slider(\"events\", \"year\", min_value=2000, max_value=2024)\n    \"\"\"\n    self.call_js_method(\n        \"addTimeSlider\",\n        layerId=layer_id,\n        property=property,\n        min=min_value,\n        max=max_value,\n        step=step,\n        position=position,\n        label=label,\n        autoPlay=auto_play,\n        interval=interval,\n    )\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.maplibre.MapLibreMap.add_tooltip","title":"<code>add_tooltip(self, layer_id, template=None, properties=None)</code>","text":"<p>Add a tooltip that shows on feature hover.</p> <p>Shows formatted information when hovering over features in a layer.</p> <p>Parameters:</p> Name Type Description Default <code>layer_id</code> <code>str</code> <p>The ID of the layer to add tooltips to.</p> required <code>template</code> <code>Optional[str]</code> <p>HTML template with {property} placeholders. Example: \"Name: {name}Population: {pop}\".</p> <code>None</code> <code>properties</code> <code>Optional[List[str]]</code> <p>List of property names to display. If None and no template, all properties are shown.</p> <code>None</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; m = MapLibreMap()\n&gt;&gt;&gt; m.add_geojson(\"data.geojson\", name=\"cities\")\n&gt;&gt;&gt; m.add_tooltip(\"cities\", template=\"&lt;b&gt;{name}&lt;/b&gt;&lt;br&gt;Pop: {population}\")\n</code></pre> Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def add_tooltip(\n    self,\n    layer_id: str,\n    template: Optional[str] = None,\n    properties: Optional[List[str]] = None,\n) -&gt; None:\n    \"\"\"Add a tooltip that shows on feature hover.\n\n    Shows formatted information when hovering over features in a layer.\n\n    Args:\n        layer_id: The ID of the layer to add tooltips to.\n        template: HTML template with {property} placeholders.\n            Example: \"Name: {name}&lt;br&gt;Population: {pop}\".\n        properties: List of property names to display. If None and no\n            template, all properties are shown.\n\n    Example:\n        &gt;&gt;&gt; m = MapLibreMap()\n        &gt;&gt;&gt; m.add_geojson(\"data.geojson\", name=\"cities\")\n        &gt;&gt;&gt; m.add_tooltip(\"cities\", template=\"&lt;b&gt;{name}&lt;/b&gt;&lt;br&gt;Pop: {population}\")\n    \"\"\"\n    self.call_js_method(\n        \"addTooltip\",\n        layerId=layer_id,\n        template=template or \"\",\n        properties=properties,\n    )\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.maplibre.MapLibreMap.add_trips_layer","title":"<code>add_trips_layer(self, data, name=None, get_path='waypoints', get_timestamps='timestamps', get_color=None, width_min_pixels=2, trail_length=180, current_time=0, pickable=True, opacity=0.8, **kwargs)</code>","text":"<p>Add a trips layer for animated trip/trajectory playback using deck.gl.</p> <p>Trips layers render animated paths showing movement over time, ideal for visualizing vehicle routes, migration patterns, or time-based data.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>Array of trip objects with waypoints and timestamps.</p> required <code>name</code> <code>Optional[str]</code> <p>Layer ID. If None, auto-generated.</p> <code>None</code> <code>get_path</code> <code>Union[str, Any]</code> <p>Accessor for waypoint coordinates [[lng, lat], ...].</p> <code>'waypoints'</code> <code>get_timestamps</code> <code>Union[str, Any]</code> <p>Accessor for timestamps at each waypoint.</p> <code>'timestamps'</code> <code>get_color</code> <code>Optional[Union[List[int], str]]</code> <p>Accessor for trip color [r, g, b] or [r, g, b, a]. Default: [253, 128, 93].</p> <code>None</code> <code>width_min_pixels</code> <code>float</code> <p>Minimum trail width in pixels.</p> <code>2</code> <code>trail_length</code> <code>float</code> <p>Trail length in timestamp units.</p> <code>180</code> <code>current_time</code> <code>float</code> <p>Current animation time.</p> <code>0</code> <code>pickable</code> <code>bool</code> <p>Whether layer responds to hover/click events.</p> <code>True</code> <code>opacity</code> <code>float</code> <p>Layer opacity (0-1).</p> <code>0.8</code> <code>**kwargs</code> <p>Additional TripsLayer props.</p> <code>{}</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from anymap_ts import MapLibreMap\n&gt;&gt;&gt; m = MapLibreMap()\n&gt;&gt;&gt; trips = [\n...     {\n...         \"waypoints\": [[-122.4, 37.8], [-122.5, 37.7]],\n...         \"timestamps\": [0, 100]\n...     }\n... ]\n&gt;&gt;&gt; m.add_trips_layer(trips, trail_length=200, current_time=50)\n</code></pre> Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def add_trips_layer(\n    self,\n    data: Any,\n    name: Optional[str] = None,\n    get_path: Union[str, Any] = \"waypoints\",\n    get_timestamps: Union[str, Any] = \"timestamps\",\n    get_color: Optional[Union[List[int], str]] = None,\n    width_min_pixels: float = 2,\n    trail_length: float = 180,\n    current_time: float = 0,\n    pickable: bool = True,\n    opacity: float = 0.8,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a trips layer for animated trip/trajectory playback using deck.gl.\n\n    Trips layers render animated paths showing movement over time, ideal\n    for visualizing vehicle routes, migration patterns, or time-based data.\n\n    Args:\n        data: Array of trip objects with waypoints and timestamps.\n        name: Layer ID. If None, auto-generated.\n        get_path: Accessor for waypoint coordinates [[lng, lat], ...].\n        get_timestamps: Accessor for timestamps at each waypoint.\n        get_color: Accessor for trip color [r, g, b] or [r, g, b, a].\n            Default: [253, 128, 93].\n        width_min_pixels: Minimum trail width in pixels.\n        trail_length: Trail length in timestamp units.\n        current_time: Current animation time.\n        pickable: Whether layer responds to hover/click events.\n        opacity: Layer opacity (0-1).\n        **kwargs: Additional TripsLayer props.\n\n    Example:\n        &gt;&gt;&gt; from anymap_ts import MapLibreMap\n        &gt;&gt;&gt; m = MapLibreMap()\n        &gt;&gt;&gt; trips = [\n        ...     {\n        ...         \"waypoints\": [[-122.4, 37.8], [-122.5, 37.7]],\n        ...         \"timestamps\": [0, 100]\n        ...     }\n        ... ]\n        &gt;&gt;&gt; m.add_trips_layer(trips, trail_length=200, current_time=50)\n    \"\"\"\n    layer_id = name or f\"trips-{len(self._layers)}\"\n    processed_data = self._process_deck_data(data)\n\n    self.call_js_method(\n        \"addTripsLayer\",\n        id=layer_id,\n        data=processed_data,\n        getPath=get_path,\n        getTimestamps=get_timestamps,\n        getColor=get_color or [253, 128, 93],\n        widthMinPixels=width_min_pixels,\n        trailLength=trail_length,\n        currentTime=current_time,\n        pickable=pickable,\n        opacity=opacity,\n        **kwargs,\n    )\n\n    self._layers = {\n        **self._layers,\n        layer_id: {\n            \"id\": layer_id,\n            \"type\": \"trips\",\n        },\n    }\n    self._add_to_layer_dict(layer_id, \"Deck.gl\")\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.maplibre.MapLibreMap.add_vector","title":"<code>add_vector(self, data, layer_type=None, paint=None, name=None, fit_bounds=True, **kwargs)</code>","text":"<p>Add vector data to the map.</p> <p>Supports GeoJSON, GeoDataFrame, or file paths to vector formats.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>GeoJSON dict, GeoDataFrame, or path to vector file</p> required <code>layer_type</code> <code>Optional[str]</code> <p>MapLibre layer type ('circle', 'line', 'fill', 'symbol')</p> <code>None</code> <code>paint</code> <code>Optional[Dict]</code> <p>MapLibre paint properties</p> <code>None</code> <code>name</code> <code>Optional[str]</code> <p>Layer name</p> <code>None</code> <code>fit_bounds</code> <code>bool</code> <p>Whether to fit map to data bounds</p> <code>True</code> <code>**kwargs</code> <p>Additional layer options</p> <code>{}</code> Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def add_vector(\n    self,\n    data: Any,\n    layer_type: Optional[str] = None,\n    paint: Optional[Dict] = None,\n    name: Optional[str] = None,\n    fit_bounds: bool = True,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add vector data to the map.\n\n    Supports GeoJSON, GeoDataFrame, or file paths to vector formats.\n\n    Args:\n        data: GeoJSON dict, GeoDataFrame, or path to vector file\n        layer_type: MapLibre layer type ('circle', 'line', 'fill', 'symbol')\n        paint: MapLibre paint properties\n        name: Layer name\n        fit_bounds: Whether to fit map to data bounds\n        **kwargs: Additional layer options\n    \"\"\"\n    geojson = to_geojson(data)\n\n    layer_id = name or f\"vector-{len(self._layers)}\"\n\n    # Handle URL data - fetch GeoJSON to get bounds and infer layer type\n    if geojson.get(\"type\") == \"url\":\n        url = geojson[\"url\"]\n        # Fetch the actual GeoJSON data from URL\n        geojson = fetch_geojson(url)\n\n    # Infer layer type if not specified\n    if layer_type is None:\n        layer_type = infer_layer_type(geojson)\n\n    # Get default paint if not provided\n    if paint is None:\n        paint = get_default_paint(layer_type)\n\n    # Get bounds (use geojson dict, not original data which may be a URL)\n    bounds = get_bounds(geojson) if fit_bounds else None\n\n    # Call JavaScript\n    self.call_js_method(\n        \"addGeoJSON\",\n        data=geojson,\n        name=layer_id,\n        layerType=layer_type,\n        paint=paint,\n        fitBounds=fit_bounds,\n        bounds=bounds,\n        **kwargs,\n    )\n\n    # Track layer\n    self._layers = {\n        **self._layers,\n        layer_id: {\n            \"id\": layer_id,\n            \"type\": layer_type,\n            \"source\": f\"{layer_id}-source\",\n            \"paint\": paint,\n        },\n    }\n    self._add_to_layer_dict(layer_id, \"Vector\")\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.maplibre.MapLibreMap.add_vector_control","title":"<code>add_vector_control(self, position='top-right', collapsed=True, default_url=None, load_default_url=False, default_opacity=1.0, default_fill_color='#3388ff', default_stroke_color='#3388ff', fit_bounds=True, **kwargs)</code>","text":"<p>Add a vector layer control for loading vector datasets from URLs.</p> <p>This provides an interactive panel for users to enter URLs to GeoJSON, GeoParquet, or FlatGeobuf datasets.</p> <p>Parameters:</p> Name Type Description Default <code>position</code> <code>str</code> <p>Control position ('top-left', 'top-right', 'bottom-left', 'bottom-right').</p> <code>'top-right'</code> <code>collapsed</code> <code>bool</code> <p>Whether the panel starts collapsed.</p> <code>True</code> <code>default_url</code> <code>Optional[str]</code> <p>Default vector URL to pre-fill.</p> <code>None</code> <code>load_default_url</code> <code>bool</code> <p>Whether to auto-load the default URL.</p> <code>False</code> <code>default_opacity</code> <code>float</code> <p>Default layer opacity (0-1).</p> <code>1.0</code> <code>default_fill_color</code> <code>str</code> <p>Default fill color for polygons.</p> <code>'#3388ff'</code> <code>default_stroke_color</code> <code>str</code> <p>Default stroke color for lines/outlines.</p> <code>'#3388ff'</code> <code>fit_bounds</code> <code>bool</code> <p>Whether to fit map to loaded data bounds.</p> <code>True</code> <code>**kwargs</code> <p>Additional control options.</p> <code>{}</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from anymap_ts import MapLibreMap\n&gt;&gt;&gt; m = MapLibreMap()\n&gt;&gt;&gt; m.add_vector_control(\n...     default_url=\"https://example.com/data.geojson\",\n...     default_fill_color=\"#ff0000\"\n... )\n</code></pre> Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def add_vector_control(\n    self,\n    position: str = \"top-right\",\n    collapsed: bool = True,\n    default_url: Optional[str] = None,\n    load_default_url: bool = False,\n    default_opacity: float = 1.0,\n    default_fill_color: str = \"#3388ff\",\n    default_stroke_color: str = \"#3388ff\",\n    fit_bounds: bool = True,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a vector layer control for loading vector datasets from URLs.\n\n    This provides an interactive panel for users to enter URLs to\n    GeoJSON, GeoParquet, or FlatGeobuf datasets.\n\n    Args:\n        position: Control position ('top-left', 'top-right', 'bottom-left', 'bottom-right').\n        collapsed: Whether the panel starts collapsed.\n        default_url: Default vector URL to pre-fill.\n        load_default_url: Whether to auto-load the default URL.\n        default_opacity: Default layer opacity (0-1).\n        default_fill_color: Default fill color for polygons.\n        default_stroke_color: Default stroke color for lines/outlines.\n        fit_bounds: Whether to fit map to loaded data bounds.\n        **kwargs: Additional control options.\n\n    Example:\n        &gt;&gt;&gt; from anymap_ts import MapLibreMap\n        &gt;&gt;&gt; m = MapLibreMap()\n        &gt;&gt;&gt; m.add_vector_control(\n        ...     default_url=\"https://example.com/data.geojson\",\n        ...     default_fill_color=\"#ff0000\"\n        ... )\n    \"\"\"\n    self.call_js_method(\n        \"addVectorControl\",\n        position=position,\n        collapsed=collapsed,\n        defaultUrl=default_url or \"\",\n        loadDefaultUrl=load_default_url,\n        defaultOpacity=default_opacity,\n        defaultFillColor=default_fill_color,\n        defaultStrokeColor=default_stroke_color,\n        fitBounds=fit_bounds,\n        **kwargs,\n    )\n    self._controls = {\n        **self._controls,\n        \"vector-control\": {\"position\": position, \"collapsed\": collapsed},\n    }\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.maplibre.MapLibreMap.add_video_layer","title":"<code>add_video_layer(self, urls, coordinates, name=None, opacity=1.0, **kwargs)</code>","text":"<p>Add a georeferenced video overlay on the map.</p> <p>Parameters:</p> Name Type Description Default <code>urls</code> <code>List[str]</code> <p>List of video URLs (provide multiple formats for browser compatibility, e.g., [\".mp4\", \".webm\"]).</p> required <code>coordinates</code> <code>List[List[float]]</code> <p>Four corner coordinates as [[lng, lat], ...] in order: top-left, top-right, bottom-right, bottom-left.</p> required <code>name</code> <code>Optional[str]</code> <p>Layer identifier. If None, auto-generated.</p> <code>None</code> <code>opacity</code> <code>float</code> <p>Layer opacity (0-1). Default is 1.0.</p> <code>1.0</code> <code>**kwargs</code> <p>Additional layer options.</p> <code>{}</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; m.add_video_layer(\n...     urls=[\"https://example.com/video.mp4\"],\n...     coordinates=[\n...         [-122.51596391658498, 37.56238816766053],\n...         [-122.51467645489949, 37.56410183312965],\n...         [-122.51309394645498, 37.563391708549425],\n...         [-122.51423120498498, 37.56161849366671],\n...     ],\n... )\n</code></pre> Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def add_video_layer(\n    self,\n    urls: List[str],\n    coordinates: List[List[float]],\n    name: Optional[str] = None,\n    opacity: float = 1.0,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a georeferenced video overlay on the map.\n\n    Args:\n        urls: List of video URLs (provide multiple formats for browser\n            compatibility, e.g., [\".mp4\", \".webm\"]).\n        coordinates: Four corner coordinates as [[lng, lat], ...] in order:\n            top-left, top-right, bottom-right, bottom-left.\n        name: Layer identifier. If None, auto-generated.\n        opacity: Layer opacity (0-1). Default is 1.0.\n        **kwargs: Additional layer options.\n\n    Example:\n        &gt;&gt;&gt; m.add_video_layer(\n        ...     urls=[\"https://example.com/video.mp4\"],\n        ...     coordinates=[\n        ...         [-122.51596391658498, 37.56238816766053],\n        ...         [-122.51467645489949, 37.56410183312965],\n        ...         [-122.51309394645498, 37.563391708549425],\n        ...         [-122.51423120498498, 37.56161849366671],\n        ...     ],\n        ... )\n    \"\"\"\n    self._validate_opacity(opacity)\n    layer_id = name or f\"video-{len(self._layers)}\"\n\n    if len(coordinates) != 4:\n        raise ValueError(\n            \"coordinates must have exactly 4 corner points \"\n            \"[top-left, top-right, bottom-right, bottom-left]\"\n        )\n\n    self.call_js_method(\n        \"addVideoLayer\",\n        id=layer_id,\n        urls=urls,\n        coordinates=coordinates,\n        opacity=opacity,\n        **kwargs,\n    )\n\n    self._layers = {\n        **self._layers,\n        layer_id: {\n            \"id\": layer_id,\n            \"type\": \"video\",\n            \"source\": f\"{layer_id}-source\",\n        },\n    }\n    self._add_to_layer_dict(layer_id, \"Raster\")\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.maplibre.MapLibreMap.add_zarr_control","title":"<code>add_zarr_control(self, position='top-right', collapsed=True, default_url=None, load_default_url=False, default_opacity=1.0, default_variable='', default_clim=None, **kwargs)</code>","text":"<p>Add a Zarr layer control for loading Zarr datasets via UI.</p> <p>This provides an interactive panel for users to enter Zarr URLs and configure visualization parameters.</p> <p>Parameters:</p> Name Type Description Default <code>position</code> <code>str</code> <p>Control position ('top-left', 'top-right', 'bottom-left', 'bottom-right').</p> <code>'top-right'</code> <code>collapsed</code> <code>bool</code> <p>Whether the panel starts collapsed.</p> <code>True</code> <code>default_url</code> <code>Optional[str]</code> <p>Default Zarr URL to pre-fill.</p> <code>None</code> <code>load_default_url</code> <code>bool</code> <p>Whether to auto-load the default URL.</p> <code>False</code> <code>default_opacity</code> <code>float</code> <p>Default layer opacity (0-1).</p> <code>1.0</code> <code>default_variable</code> <code>str</code> <p>Default variable name.</p> <code>''</code> <code>default_clim</code> <code>Optional[Tuple[float, float]]</code> <p>Default color limits (min, max).</p> <code>None</code> <code>**kwargs</code> <p>Additional control options.</p> <code>{}</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from anymap_ts import MapLibreMap\n&gt;&gt;&gt; m = MapLibreMap()\n&gt;&gt;&gt; m.add_zarr_control(\n...     default_url=\"https://example.com/data.zarr\",\n...     default_variable=\"temperature\"\n... )\n</code></pre> Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def add_zarr_control(\n    self,\n    position: str = \"top-right\",\n    collapsed: bool = True,\n    default_url: Optional[str] = None,\n    load_default_url: bool = False,\n    default_opacity: float = 1.0,\n    default_variable: str = \"\",\n    default_clim: Optional[Tuple[float, float]] = None,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a Zarr layer control for loading Zarr datasets via UI.\n\n    This provides an interactive panel for users to enter Zarr URLs\n    and configure visualization parameters.\n\n    Args:\n        position: Control position ('top-left', 'top-right', 'bottom-left', 'bottom-right').\n        collapsed: Whether the panel starts collapsed.\n        default_url: Default Zarr URL to pre-fill.\n        load_default_url: Whether to auto-load the default URL.\n        default_opacity: Default layer opacity (0-1).\n        default_variable: Default variable name.\n        default_clim: Default color limits (min, max).\n        **kwargs: Additional control options.\n\n    Example:\n        &gt;&gt;&gt; from anymap_ts import MapLibreMap\n        &gt;&gt;&gt; m = MapLibreMap()\n        &gt;&gt;&gt; m.add_zarr_control(\n        ...     default_url=\"https://example.com/data.zarr\",\n        ...     default_variable=\"temperature\"\n        ... )\n    \"\"\"\n    self.call_js_method(\n        \"addZarrControl\",\n        position=position,\n        collapsed=collapsed,\n        defaultUrl=default_url or \"\",\n        loadDefaultUrl=load_default_url,\n        defaultOpacity=default_opacity,\n        defaultVariable=default_variable,\n        defaultClim=list(default_clim) if default_clim else [0, 1],\n        **kwargs,\n    )\n    self._controls = {\n        **self._controls,\n        \"zarr-control\": {\"position\": position, \"collapsed\": collapsed},\n    }\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.maplibre.MapLibreMap.add_zarr_layer","title":"<code>add_zarr_layer(self, url, variable, name=None, colormap=None, clim=None, opacity=1.0, selector=None, minzoom=0, maxzoom=22, fill_value=None, spatial_dimensions=None, zarr_version=None, bounds=None, **kwargs)</code>","text":"<p>Add a Zarr dataset layer for visualizing multidimensional array data.</p> <p>This method renders Zarr pyramid datasets directly in the browser using GPU-accelerated WebGL rendering via @carbonplan/zarr-layer.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>URL to the Zarr store (pyramid format recommended).</p> required <code>variable</code> <code>str</code> <p>Variable name in the Zarr dataset to visualize.</p> required <code>name</code> <code>Optional[str]</code> <p>Layer ID. If None, auto-generated.</p> <code>None</code> <code>colormap</code> <code>Optional[List[str]]</code> <p>List of hex color strings for visualization. Example: ['#0000ff', '#ffff00', '#ff0000'] (blue-yellow-red). Default: ['#000000', '#ffffff'] (black to white).</p> <code>None</code> <code>clim</code> <code>Optional[Tuple[float, float]]</code> <p>Color range as (min, max) tuple. Default: (0, 100).</p> <code>None</code> <code>opacity</code> <code>float</code> <p>Layer opacity (0-1).</p> <code>1.0</code> <code>selector</code> <code>Optional[Dict[str, Any]]</code> <p>Dimension selector for multi-dimensional data. Example: {\"month\": 4} to select 4th month.</p> <code>None</code> <code>minzoom</code> <code>int</code> <p>Minimum zoom level for rendering.</p> <code>0</code> <code>maxzoom</code> <code>int</code> <p>Maximum zoom level for rendering.</p> <code>22</code> <code>fill_value</code> <code>Optional[float]</code> <p>No-data value (auto-detected from metadata if not set).</p> <code>None</code> <code>spatial_dimensions</code> <code>Optional[Dict[str, str]]</code> <p>Custom spatial dimension names. Example: {\"lat\": \"y\", \"lon\": \"x\"} for non-standard names.</p> <code>None</code> <code>zarr_version</code> <code>Optional[int]</code> <p>Zarr format version (2 or 3). Auto-detected if not set.</p> <code>None</code> <code>bounds</code> <code>Optional[List[float]]</code> <p>Explicit spatial bounds [xMin, yMin, xMax, yMax]. Units depend on CRS: degrees for EPSG:4326, meters for EPSG:3857.</p> <code>None</code> <code>**kwargs</code> <p>Additional ZarrLayer props.</p> <code>{}</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from anymap_ts import Map\n&gt;&gt;&gt; m = Map()\n&gt;&gt;&gt; m.add_zarr_layer(\n...     \"https://example.com/climate.zarr\",\n...     variable=\"temperature\",\n...     clim=(270, 310),\n...     colormap=['#0000ff', '#ffff00', '#ff0000'],\n...     selector={\"month\": 7}\n... )\n</code></pre> Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def add_zarr_layer(\n    self,\n    url: str,\n    variable: str,\n    name: Optional[str] = None,\n    colormap: Optional[List[str]] = None,\n    clim: Optional[Tuple[float, float]] = None,\n    opacity: float = 1.0,\n    selector: Optional[Dict[str, Any]] = None,\n    minzoom: int = 0,\n    maxzoom: int = 22,\n    fill_value: Optional[float] = None,\n    spatial_dimensions: Optional[Dict[str, str]] = None,\n    zarr_version: Optional[int] = None,\n    bounds: Optional[List[float]] = None,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a Zarr dataset layer for visualizing multidimensional array data.\n\n    This method renders Zarr pyramid datasets directly in the browser using\n    GPU-accelerated WebGL rendering via @carbonplan/zarr-layer.\n\n    Args:\n        url: URL to the Zarr store (pyramid format recommended).\n        variable: Variable name in the Zarr dataset to visualize.\n        name: Layer ID. If None, auto-generated.\n        colormap: List of hex color strings for visualization.\n            Example: ['#0000ff', '#ffff00', '#ff0000'] (blue-yellow-red).\n            Default: ['#000000', '#ffffff'] (black to white).\n        clim: Color range as (min, max) tuple.\n            Default: (0, 100).\n        opacity: Layer opacity (0-1).\n        selector: Dimension selector for multi-dimensional data.\n            Example: {\"month\": 4} to select 4th month.\n        minzoom: Minimum zoom level for rendering.\n        maxzoom: Maximum zoom level for rendering.\n        fill_value: No-data value (auto-detected from metadata if not set).\n        spatial_dimensions: Custom spatial dimension names.\n            Example: {\"lat\": \"y\", \"lon\": \"x\"} for non-standard names.\n        zarr_version: Zarr format version (2 or 3). Auto-detected if not set.\n        bounds: Explicit spatial bounds [xMin, yMin, xMax, yMax].\n            Units depend on CRS: degrees for EPSG:4326, meters for EPSG:3857.\n        **kwargs: Additional ZarrLayer props.\n\n    Example:\n        &gt;&gt;&gt; from anymap_ts import Map\n        &gt;&gt;&gt; m = Map()\n        &gt;&gt;&gt; m.add_zarr_layer(\n        ...     \"https://example.com/climate.zarr\",\n        ...     variable=\"temperature\",\n        ...     clim=(270, 310),\n        ...     colormap=['#0000ff', '#ffff00', '#ff0000'],\n        ...     selector={\"month\": 7}\n        ... )\n    \"\"\"\n    layer_id = name or f\"zarr-{len(self._layers)}\"\n\n    self.call_js_method(\n        \"addZarrLayer\",\n        id=layer_id,\n        source=url,\n        variable=variable,\n        colormap=colormap or [\"#000000\", \"#ffffff\"],\n        clim=list(clim) if clim else [0, 100],\n        opacity=opacity,\n        selector=selector or {},\n        minzoom=minzoom,\n        maxzoom=maxzoom,\n        fillValue=fill_value,\n        spatialDimensions=spatial_dimensions,\n        zarrVersion=zarr_version,\n        bounds=bounds,\n        **kwargs,\n    )\n\n    self._layers = {\n        **self._layers,\n        layer_id: {\n            \"id\": layer_id,\n            \"type\": \"zarr\",\n            \"url\": url,\n            \"variable\": variable,\n        },\n    }\n    self._add_to_layer_dict(layer_id, \"Raster\")\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.maplibre.MapLibreMap.animate_along_route","title":"<code>animate_along_route(self, route, duration=10000, loop=True, marker_color='#3388ff', marker_size=1.0, show_trail=False, trail_color='#3388ff', trail_width=3, animation_id=None, **kwargs)</code>","text":"<p>Animate a marker along a route.</p> <p>Creates an animated marker that moves along the specified route line.</p> <p>Parameters:</p> Name Type Description Default <code>route</code> <code>Any</code> <p>Route data - LineString GeoJSON, list of coordinates, GeoDataFrame, or file path.</p> required <code>duration</code> <code>int</code> <p>Animation duration in milliseconds.</p> <code>10000</code> <code>loop</code> <code>bool</code> <p>Whether to loop the animation.</p> <code>True</code> <code>marker_color</code> <code>str</code> <p>Marker color.</p> <code>'#3388ff'</code> <code>marker_size</code> <code>float</code> <p>Marker size multiplier.</p> <code>1.0</code> <code>show_trail</code> <code>bool</code> <p>Whether to show a trail behind the marker.</p> <code>False</code> <code>trail_color</code> <code>str</code> <p>Trail line color.</p> <code>'#3388ff'</code> <code>trail_width</code> <code>float</code> <p>Trail line width.</p> <code>3</code> <code>animation_id</code> <code>Optional[str]</code> <p>Animation identifier. If None, auto-generated.</p> <code>None</code> <code>**kwargs</code> <p>Additional animation options.</p> <code>{}</code> <p>Returns:</p> Type Description <code>str</code> <p>The animation identifier.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from anymap_ts import Map\n&gt;&gt;&gt; m = Map()\n&gt;&gt;&gt; coords = [[-122.4, 37.8], [-122.3, 37.7], [-122.2, 37.8]]\n&gt;&gt;&gt; anim_id = m.animate_along_route(coords, duration=5000, loop=True)\n</code></pre> Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def animate_along_route(\n    self,\n    route: Any,\n    duration: int = 10000,\n    loop: bool = True,\n    marker_color: str = \"#3388ff\",\n    marker_size: float = 1.0,\n    show_trail: bool = False,\n    trail_color: str = \"#3388ff\",\n    trail_width: float = 3,\n    animation_id: Optional[str] = None,\n    **kwargs,\n) -&gt; str:\n    \"\"\"Animate a marker along a route.\n\n    Creates an animated marker that moves along the specified route line.\n\n    Args:\n        route: Route data - LineString GeoJSON, list of coordinates,\n            GeoDataFrame, or file path.\n        duration: Animation duration in milliseconds.\n        loop: Whether to loop the animation.\n        marker_color: Marker color.\n        marker_size: Marker size multiplier.\n        show_trail: Whether to show a trail behind the marker.\n        trail_color: Trail line color.\n        trail_width: Trail line width.\n        animation_id: Animation identifier. If None, auto-generated.\n        **kwargs: Additional animation options.\n\n    Returns:\n        The animation identifier.\n\n    Example:\n        &gt;&gt;&gt; from anymap_ts import Map\n        &gt;&gt;&gt; m = Map()\n        &gt;&gt;&gt; coords = [[-122.4, 37.8], [-122.3, 37.7], [-122.2, 37.8]]\n        &gt;&gt;&gt; anim_id = m.animate_along_route(coords, duration=5000, loop=True)\n    \"\"\"\n    anim_id = animation_id or f\"animation-{len(self._layers)}\"\n\n    # Convert route to coordinates list\n    if isinstance(route, list) and len(route) &gt; 0:\n        if isinstance(route[0], (list, tuple)):\n            # Already a list of coordinates\n            coordinates = route\n        else:\n            raise ValueError(\"Route list must contain coordinate pairs\")\n    elif isinstance(route, dict):\n        # GeoJSON\n        if route.get(\"type\") == \"LineString\":\n            coordinates = route.get(\"coordinates\", [])\n        elif route.get(\"type\") == \"Feature\":\n            geometry = route.get(\"geometry\", {})\n            if geometry.get(\"type\") == \"LineString\":\n                coordinates = geometry.get(\"coordinates\", [])\n            else:\n                raise ValueError(\"Feature geometry must be LineString\")\n        elif route.get(\"type\") == \"FeatureCollection\":\n            features = route.get(\"features\", [])\n            if (\n                features\n                and features[0].get(\"geometry\", {}).get(\"type\") == \"LineString\"\n            ):\n                coordinates = features[0][\"geometry\"][\"coordinates\"]\n            else:\n                raise ValueError(\n                    \"FeatureCollection must contain LineString features\"\n                )\n        else:\n            raise ValueError(\n                \"GeoJSON must be LineString, Feature, or FeatureCollection\"\n            )\n    else:\n        # Try to convert using to_geojson\n        geojson = to_geojson(route)\n        if geojson.get(\"type\") == \"url\":\n            geojson = fetch_geojson(geojson[\"url\"])\n        # Extract coordinates from the converted geojson\n        if geojson.get(\"type\") == \"FeatureCollection\":\n            features = geojson.get(\"features\", [])\n            if features:\n                coordinates = features[0].get(\"geometry\", {}).get(\"coordinates\", [])\n            else:\n                raise ValueError(\"No features found in data\")\n        elif geojson.get(\"type\") == \"Feature\":\n            coordinates = geojson.get(\"geometry\", {}).get(\"coordinates\", [])\n        else:\n            coordinates = geojson.get(\"coordinates\", [])\n\n    if len(coordinates) &lt; 2:\n        raise ValueError(\"Route must have at least 2 points\")\n\n    self.call_js_method(\n        \"animateAlongRoute\",\n        id=anim_id,\n        coordinates=coordinates,\n        duration=duration,\n        loop=loop,\n        markerColor=marker_color,\n        markerSize=marker_size,\n        showTrail=show_trail,\n        trailColor=trail_color,\n        trailWidth=trail_width,\n        **kwargs,\n    )\n\n    self._layers = {\n        **self._layers,\n        anim_id: {\n            \"id\": anim_id,\n            \"type\": \"animation\",\n        },\n    }\n    return anim_id\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.maplibre.MapLibreMap.clear_draw_data","title":"<code>clear_draw_data(self)</code>","text":"<p>Clear all drawn features.</p> Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def clear_draw_data(self) -&gt; None:\n    \"\"\"Clear all drawn features.\"\"\"\n    self._draw_data = {\"type\": \"FeatureCollection\", \"features\": []}\n    self.call_js_method(\"clearDrawData\")\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.maplibre.MapLibreMap.get_draw_data","title":"<code>get_draw_data(self)</code>","text":"<p>Get the current drawn features as GeoJSON.</p> <p>Returns:</p> Type Description <code>Dict</code> <p>GeoJSON FeatureCollection of drawn features</p> Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def get_draw_data(self) -&gt; Dict:\n    \"\"\"Get the current drawn features as GeoJSON.\n\n    Returns:\n        GeoJSON FeatureCollection of drawn features\n    \"\"\"\n    self.call_js_method(\"getDrawData\")\n    # Small delay to allow JS to update the trait\n    import time\n\n    time.sleep(0.1)\n    return self._draw_data or {\"type\": \"FeatureCollection\", \"features\": []}\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.maplibre.MapLibreMap.get_layer","title":"<code>get_layer(self, layer_id)</code>","text":"<p>Get layer configuration by ID.</p> <p>Parameters:</p> Name Type Description Default <code>layer_id</code> <code>str</code> <p>Layer identifier.</p> required <p>Returns:</p> Type Description <code>Optional[Dict]</code> <p>Layer configuration dict or None if not found.</p> Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def get_layer(self, layer_id: str) -&gt; Optional[Dict]:\n    \"\"\"Get layer configuration by ID.\n\n    Args:\n        layer_id: Layer identifier.\n\n    Returns:\n        Layer configuration dict or None if not found.\n    \"\"\"\n    return self._layers.get(layer_id)\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.maplibre.MapLibreMap.get_layer_ids","title":"<code>get_layer_ids(self)</code>","text":"<p>Get list of all layer IDs.</p> <p>Returns:</p> Type Description <code>List[str]</code> <p>List of layer identifiers.</p> Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def get_layer_ids(self) -&gt; List[str]:\n    \"\"\"Get list of all layer IDs.\n\n    Returns:\n        List of layer identifiers.\n    \"\"\"\n    return list(self._layers.keys())\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.maplibre.MapLibreMap.get_visible_features","title":"<code>get_visible_features(self, layers=None)</code>","text":"<p>Get all features currently visible in the viewport.</p> <p>This triggers a query to the JavaScript side. The result is returned asynchronously via the <code>_queried_features</code> trait.</p> <p>On the first call, the query is sent and <code>None</code> is returned because the JavaScript side has not yet responded. Run this method in one notebook cell, then read the result in the next cell (the event loop processes the response between cells).</p> <p>Parameters:</p> Name Type Description Default <code>layers</code> <code>Optional[List[str]]</code> <p>Optional list of layer IDs to query. If <code>None</code>, queries all visible layers.</p> <code>None</code> <p>Returns:</p> Type Description <code>Optional[Dict]</code> <p>GeoJSON FeatureCollection dict if results are available from a previous query, otherwise <code>None</code>.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; # Cell 1 \u2013 trigger the query\n&gt;&gt;&gt; m.get_visible_features(layers=[\"my-layer\"])\n&gt;&gt;&gt; # Cell 2 \u2013 read the result\n&gt;&gt;&gt; m.get_visible_features()\n</code></pre> Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def get_visible_features(\n    self,\n    layers: Optional[List[str]] = None,\n) -&gt; Optional[Dict]:\n    \"\"\"Get all features currently visible in the viewport.\n\n    This triggers a query to the JavaScript side. The result is\n    returned asynchronously via the ``_queried_features`` trait.\n\n    On the first call, the query is sent and ``None`` is returned\n    because the JavaScript side has not yet responded. Run this\n    method in one notebook cell, then read the result in the next\n    cell (the event loop processes the response between cells).\n\n    Args:\n        layers: Optional list of layer IDs to query. If ``None``,\n            queries all visible layers.\n\n    Returns:\n        GeoJSON FeatureCollection dict if results are available from\n        a previous query, otherwise ``None``.\n\n    Example:\n        &gt;&gt;&gt; # Cell 1 \u2013 trigger the query\n        &gt;&gt;&gt; m.get_visible_features(layers=[\"my-layer\"])\n        &gt;&gt;&gt; # Cell 2 \u2013 read the result\n        &gt;&gt;&gt; m.get_visible_features()\n    \"\"\"\n    if layers is not None:\n        self.call_js_method(\"getVisibleFeatures\", layers=layers)\n    features = self._queried_features\n    if features and \"data\" in features:\n        return features[\"data\"]\n    return None\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.maplibre.MapLibreMap.load_draw_data","title":"<code>load_draw_data(self, geojson)</code>","text":"<p>Load GeoJSON features into the drawing layer.</p> <p>Parameters:</p> Name Type Description Default <code>geojson</code> <code>Dict</code> <p>GeoJSON FeatureCollection to load</p> required Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def load_draw_data(self, geojson: Dict) -&gt; None:\n    \"\"\"Load GeoJSON features into the drawing layer.\n\n    Args:\n        geojson: GeoJSON FeatureCollection to load\n    \"\"\"\n    self._draw_data = geojson\n    self.call_js_method(\"loadDrawData\", geojson)\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.maplibre.MapLibreMap.move_layer","title":"<code>move_layer(self, layer_id, before_id=None)</code>","text":"<p>Move a layer in the layer stack.</p> <p>Parameters:</p> Name Type Description Default <code>layer_id</code> <code>str</code> <p>Layer identifier to move.</p> required <code>before_id</code> <code>Optional[str]</code> <p>ID of layer to move before. If None, moves to top.</p> <code>None</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; m.move_layer(\"my-layer\", \"other-layer\")  # Move before other-layer\n&gt;&gt;&gt; m.move_layer(\"my-layer\")  # Move to top\n</code></pre> Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def move_layer(self, layer_id: str, before_id: Optional[str] = None) -&gt; None:\n    \"\"\"Move a layer in the layer stack.\n\n    Args:\n        layer_id: Layer identifier to move.\n        before_id: ID of layer to move before. If None, moves to top.\n\n    Example:\n        &gt;&gt;&gt; m.move_layer(\"my-layer\", \"other-layer\")  # Move before other-layer\n        &gt;&gt;&gt; m.move_layer(\"my-layer\")  # Move to top\n    \"\"\"\n    self.call_js_method(\"moveLayer\", layer_id, before_id)\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.maplibre.MapLibreMap.pause_animation","title":"<code>pause_animation(self, animation_id)</code>","text":"<p>Pause a running animation.</p> <p>Parameters:</p> Name Type Description Default <code>animation_id</code> <code>str</code> <p>Animation identifier to pause.</p> required Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def pause_animation(self, animation_id: str) -&gt; None:\n    \"\"\"Pause a running animation.\n\n    Args:\n        animation_id: Animation identifier to pause.\n    \"\"\"\n    self.call_js_method(\"pauseAnimation\", animation_id)\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.maplibre.MapLibreMap.pause_video","title":"<code>pause_video(self, name)</code>","text":"<p>Pause a video layer.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The video layer identifier.</p> required Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def pause_video(self, name: str) -&gt; None:\n    \"\"\"Pause a video layer.\n\n    Args:\n        name: The video layer identifier.\n    \"\"\"\n    self.call_js_method(\"pauseVideo\", id=name)\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.maplibre.MapLibreMap.play_video","title":"<code>play_video(self, name)</code>","text":"<p>Start playing a video layer.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The video layer identifier.</p> required Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def play_video(self, name: str) -&gt; None:\n    \"\"\"Start playing a video layer.\n\n    Args:\n        name: The video layer identifier.\n    \"\"\"\n    self.call_js_method(\"playVideo\", id=name)\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.maplibre.MapLibreMap.query_rendered_features","title":"<code>query_rendered_features(self, geometry=None, layers=None, filter_expression=None)</code>","text":"<p>Query features currently rendered on the map.</p> <p>Results are stored in the <code>queried_features</code> property.</p> <p>Parameters:</p> Name Type Description Default <code>geometry</code> <code>Optional[Any]</code> <p>Optional point {x, y} or bounding box [[x1, y1], [x2, y2]] to limit the query area. If None, queries the entire viewport.</p> <code>None</code> <code>layers</code> <code>Optional[List[str]]</code> <p>Optional list of layer IDs to query. If None, queries all layers.</p> <code>None</code> <code>filter_expression</code> <code>Optional[List]</code> <p>Optional MapLibre filter expression to further filter results.</p> <code>None</code> <p>Returns:</p> Type Description <code>Dict</code> <p>The current queried features dict (may not yet reflect this query if called immediately; use the <code>queried_features</code> property).</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; m.query_rendered_features(layers=[\"states-layer\"])\n&gt;&gt;&gt; features = m.queried_features\n</code></pre> Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def query_rendered_features(\n    self,\n    geometry: Optional[Any] = None,\n    layers: Optional[List[str]] = None,\n    filter_expression: Optional[List] = None,\n) -&gt; Dict:\n    \"\"\"Query features currently rendered on the map.\n\n    Results are stored in the `queried_features` property.\n\n    Args:\n        geometry: Optional point {x, y} or bounding box [[x1, y1], [x2, y2]]\n            to limit the query area. If None, queries the entire viewport.\n        layers: Optional list of layer IDs to query. If None, queries all\n            layers.\n        filter_expression: Optional MapLibre filter expression to further\n            filter results.\n\n    Returns:\n        The current queried features dict (may not yet reflect this query\n        if called immediately; use the `queried_features` property).\n\n    Example:\n        &gt;&gt;&gt; m.query_rendered_features(layers=[\"states-layer\"])\n        &gt;&gt;&gt; features = m.queried_features\n    \"\"\"\n    kwargs: Dict[str, Any] = {}\n    if geometry is not None:\n        kwargs[\"geometry\"] = geometry\n    if layers is not None:\n        kwargs[\"layers\"] = layers\n    if filter_expression is not None:\n        kwargs[\"filter\"] = filter_expression\n\n    self.call_js_method(\"queryRenderedFeatures\", **kwargs)\n    return self._queried_features\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.maplibre.MapLibreMap.query_source_features","title":"<code>query_source_features(self, source_id, source_layer=None, filter_expression=None)</code>","text":"<p>Query features from a source, including features not currently visible.</p> <p>Results are stored in the <code>queried_features</code> property.</p> <p>Parameters:</p> Name Type Description Default <code>source_id</code> <code>str</code> <p>The source to query.</p> required <code>source_layer</code> <code>Optional[str]</code> <p>Optional source layer for vector tile sources.</p> <code>None</code> <code>filter_expression</code> <code>Optional[List]</code> <p>Optional MapLibre filter expression.</p> <code>None</code> <p>Returns:</p> Type Description <code>Dict</code> <p>The current queried features dict.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; m.query_source_features(\"states-source\")\n&gt;&gt;&gt; features = m.queried_features\n</code></pre> Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def query_source_features(\n    self,\n    source_id: str,\n    source_layer: Optional[str] = None,\n    filter_expression: Optional[List] = None,\n) -&gt; Dict:\n    \"\"\"Query features from a source, including features not currently visible.\n\n    Results are stored in the `queried_features` property.\n\n    Args:\n        source_id: The source to query.\n        source_layer: Optional source layer for vector tile sources.\n        filter_expression: Optional MapLibre filter expression.\n\n    Returns:\n        The current queried features dict.\n\n    Example:\n        &gt;&gt;&gt; m.query_source_features(\"states-source\")\n        &gt;&gt;&gt; features = m.queried_features\n    \"\"\"\n    kwargs: Dict[str, Any] = {\"sourceId\": source_id}\n    if source_layer is not None:\n        kwargs[\"sourceLayer\"] = source_layer\n    if filter_expression is not None:\n        kwargs[\"filter\"] = filter_expression\n\n    self.call_js_method(\"querySourceFeatures\", **kwargs)\n    return self._queried_features\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.maplibre.MapLibreMap.remove_arc_layer","title":"<code>remove_arc_layer(self, layer_id)</code>","text":"<p>Remove an arc layer.</p> <p>Parameters:</p> Name Type Description Default <code>layer_id</code> <code>str</code> <p>Layer identifier to remove.</p> required Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def remove_arc_layer(self, layer_id: str) -&gt; None:\n    \"\"\"Remove an arc layer.\n\n    Args:\n        layer_id: Layer identifier to remove.\n    \"\"\"\n    self._remove_layer_internal(layer_id, \"removeArcLayer\")\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.maplibre.MapLibreMap.remove_cluster_layer","title":"<code>remove_cluster_layer(self, layer_id)</code>","text":"<p>Remove a cluster layer and all its sublayers.</p> <p>Parameters:</p> Name Type Description Default <code>layer_id</code> <code>str</code> <p>Layer identifier to remove.</p> required Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def remove_cluster_layer(self, layer_id: str) -&gt; None:\n    \"\"\"Remove a cluster layer and all its sublayers.\n\n    Args:\n        layer_id: Layer identifier to remove.\n    \"\"\"\n    self._remove_layer_internal(layer_id, \"removeClusterLayer\")\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.maplibre.MapLibreMap.remove_cog_layer","title":"<code>remove_cog_layer(self, layer_id)</code>","text":"<p>Remove a COG layer.</p> <p>Parameters:</p> Name Type Description Default <code>layer_id</code> <code>str</code> <p>Layer identifier to remove.</p> required Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def remove_cog_layer(self, layer_id: str) -&gt; None:\n    \"\"\"Remove a COG layer.\n\n    Args:\n        layer_id: Layer identifier to remove.\n    \"\"\"\n    self._remove_layer_internal(layer_id, \"removeCOGLayer\")\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.maplibre.MapLibreMap.remove_colorbar","title":"<code>remove_colorbar(self, colorbar_id=None)</code>","text":"<p>Remove a colorbar from the map.</p> <p>Parameters:</p> Name Type Description Default <code>colorbar_id</code> <code>Optional[str]</code> <p>Colorbar identifier to remove. If None, removes all colorbars.</p> <code>None</code> Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def remove_colorbar(self, colorbar_id: Optional[str] = None) -&gt; None:\n    \"\"\"Remove a colorbar from the map.\n\n    Args:\n        colorbar_id: Colorbar identifier to remove. If None, removes\n            all colorbars.\n    \"\"\"\n    if colorbar_id is None:\n        cbar_keys = [k for k in self._controls.keys() if k.startswith(\"colorbar\")]\n        for key in cbar_keys:\n            self.call_js_method(\"removeColorbar\", colorbarId=key)\n        self._controls = {\n            k: v for k, v in self._controls.items() if not k.startswith(\"colorbar\")\n        }\n    else:\n        self.call_js_method(\"removeColorbar\", colorbarId=colorbar_id)\n        if colorbar_id in self._controls:\n            controls = dict(self._controls)\n            del controls[colorbar_id]\n            self._controls = controls\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.maplibre.MapLibreMap.remove_control","title":"<code>remove_control(self, control_type)</code>","text":"<p>Remove a map control.</p> <p>Parameters:</p> Name Type Description Default <code>control_type</code> <code>str</code> <p>Type of control to remove</p> required Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def remove_control(self, control_type: str) -&gt; None:\n    \"\"\"Remove a map control.\n\n    Args:\n        control_type: Type of control to remove\n    \"\"\"\n    self.call_js_method(\"removeControl\", control_type)\n    if control_type in self._controls:\n        controls = dict(self._controls)\n        del controls[control_type]\n        self._controls = controls\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.maplibre.MapLibreMap.remove_coordinates_control","title":"<code>remove_coordinates_control(self)</code>","text":"<p>Remove the coordinates display control.</p> Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def remove_coordinates_control(self) -&gt; None:\n    \"\"\"Remove the coordinates display control.\"\"\"\n    self.call_js_method(\"removeCoordinatesControl\")\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.maplibre.MapLibreMap.remove_deck_layer","title":"<code>remove_deck_layer(self, layer_id)</code>","text":"<p>Remove a deck.gl layer from the map.</p> <p>Parameters:</p> Name Type Description Default <code>layer_id</code> <code>str</code> <p>Layer identifier to remove.</p> required Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def remove_deck_layer(self, layer_id: str) -&gt; None:\n    \"\"\"Remove a deck.gl layer from the map.\n\n    Args:\n        layer_id: Layer identifier to remove.\n    \"\"\"\n    self._remove_layer_internal(layer_id, \"removeDeckLayer\")\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.maplibre.MapLibreMap.remove_flatgeobuf","title":"<code>remove_flatgeobuf(self, name)</code>","text":"<p>Remove a FlatGeobuf layer from the map.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The layer identifier to remove.</p> required Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def remove_flatgeobuf(self, name: str) -&gt; None:\n    \"\"\"Remove a FlatGeobuf layer from the map.\n\n    Args:\n        name: The layer identifier to remove.\n    \"\"\"\n    if name in self._layers:\n        layers = dict(self._layers)\n        del layers[name]\n        self._layers = layers\n    self._remove_from_layer_dict(name)\n    self.call_js_method(\"removeFlatGeobuf\", name=name)\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.maplibre.MapLibreMap.remove_layer","title":"<code>remove_layer(self, layer_id)</code>","text":"<p>Remove a layer from the map.</p> <p>Parameters:</p> Name Type Description Default <code>layer_id</code> <code>str</code> <p>Layer identifier to remove</p> required Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def remove_layer(self, layer_id: str) -&gt; None:\n    \"\"\"Remove a layer from the map.\n\n    Args:\n        layer_id: Layer identifier to remove\n    \"\"\"\n    if layer_id in self._layers:\n        layers = dict(self._layers)\n        del layers[layer_id]\n        self._layers = layers\n    self._remove_from_layer_dict(layer_id)\n    self.call_js_method(\"removeLayer\", layer_id)\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.maplibre.MapLibreMap.remove_legend","title":"<code>remove_legend(self, legend_id=None)</code>","text":"<p>Remove a legend control from the map.</p> <p>Parameters:</p> Name Type Description Default <code>legend_id</code> <code>Optional[str]</code> <p>Legend identifier to remove. If None, removes all legends.</p> <code>None</code> Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def remove_legend(self, legend_id: Optional[str] = None) -&gt; None:\n    \"\"\"Remove a legend control from the map.\n\n    Args:\n        legend_id: Legend identifier to remove. If None, removes all legends.\n    \"\"\"\n    if legend_id is None:\n        # Remove all legends - create a copy of keys before iterating\n        legend_keys = [k for k in self._controls.keys() if k.startswith(\"legend\")]\n        for key in legend_keys:\n            self.call_js_method(\"removeLegend\", key)\n        # Rebuild controls dict without legend keys\n        self._controls = {\n            k: v for k, v in self._controls.items() if not k.startswith(\"legend\")\n        }\n    else:\n        self.call_js_method(\"removeLegend\", legend_id)\n        if legend_id in self._controls:\n            controls = dict(self._controls)\n            del controls[legend_id]\n            self._controls = controls\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.maplibre.MapLibreMap.remove_lidar_layer","title":"<code>remove_lidar_layer(self, layer_id=None)</code>","text":"<p>Remove a LiDAR layer.</p> <p>Parameters:</p> Name Type Description Default <code>layer_id</code> <code>Optional[str]</code> <p>Layer identifier to remove. If None, removes all LiDAR layers.</p> <code>None</code> Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def remove_lidar_layer(self, layer_id: Optional[str] = None) -&gt; None:\n    \"\"\"Remove a LiDAR layer.\n\n    Args:\n        layer_id: Layer identifier to remove. If None, removes all LiDAR layers.\n    \"\"\"\n    if layer_id:\n        if layer_id in self._layers:\n            layers = dict(self._layers)\n            del layers[layer_id]\n            self._layers = layers\n        self.call_js_method(\"removeLidarLayer\", id=layer_id)\n    else:\n        # Remove all lidar layers\n        layers = dict(self._layers)\n        self._layers = {k: v for k, v in layers.items() if v.get(\"type\") != \"lidar\"}\n        self.call_js_method(\"removeLidarLayer\")\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.maplibre.MapLibreMap.remove_marker","title":"<code>remove_marker(self, marker_id)</code>","text":"<p>Remove a marker from the map.</p> <p>Parameters:</p> Name Type Description Default <code>marker_id</code> <code>str</code> <p>Marker identifier to remove.</p> required Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def remove_marker(self, marker_id: str) -&gt; None:\n    \"\"\"Remove a marker from the map.\n\n    Args:\n        marker_id: Marker identifier to remove.\n    \"\"\"\n    self._remove_layer_internal(marker_id, \"removeMarker\")\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.maplibre.MapLibreMap.remove_measure_control","title":"<code>remove_measure_control(self)</code>","text":"<p>Remove the measurement control from the map.</p> Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def remove_measure_control(self) -&gt; None:\n    \"\"\"Remove the measurement control from the map.\"\"\"\n    self.call_js_method(\"removeMeasureControl\")\n    if \"measure-control\" in self._controls:\n        controls = dict(self._controls)\n        del controls[\"measure-control\"]\n        self._controls = controls\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.maplibre.MapLibreMap.remove_opacity_slider","title":"<code>remove_opacity_slider(self, layer_id)</code>","text":"<p>Remove the opacity slider for a layer.</p> <p>Parameters:</p> Name Type Description Default <code>layer_id</code> <code>str</code> <p>Layer identifier.</p> required Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def remove_opacity_slider(self, layer_id: str) -&gt; None:\n    \"\"\"Remove the opacity slider for a layer.\n\n    Args:\n        layer_id: Layer identifier.\n    \"\"\"\n    self.call_js_method(\"removeOpacitySlider\", layerId=layer_id)\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.maplibre.MapLibreMap.remove_pmtiles_layer","title":"<code>remove_pmtiles_layer(self, layer_id)</code>","text":"<p>Remove a PMTiles layer.</p> <p>Parameters:</p> Name Type Description Default <code>layer_id</code> <code>str</code> <p>Layer identifier to remove.</p> required Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def remove_pmtiles_layer(self, layer_id: str) -&gt; None:\n    \"\"\"Remove a PMTiles layer.\n\n    Args:\n        layer_id: Layer identifier to remove.\n    \"\"\"\n    self._remove_layer_internal(layer_id, \"removePMTilesLayer\")\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.maplibre.MapLibreMap.remove_point_cloud_layer","title":"<code>remove_point_cloud_layer(self, layer_id)</code>","text":"<p>Remove a point cloud layer.</p> <p>Parameters:</p> Name Type Description Default <code>layer_id</code> <code>str</code> <p>Layer identifier to remove.</p> required Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def remove_point_cloud_layer(self, layer_id: str) -&gt; None:\n    \"\"\"Remove a point cloud layer.\n\n    Args:\n        layer_id: Layer identifier to remove.\n    \"\"\"\n    self._remove_layer_internal(layer_id, \"removePointCloudLayer\")\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.maplibre.MapLibreMap.remove_print_control","title":"<code>remove_print_control(self)</code>","text":"<p>Remove the print/export control from the map.</p> Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def remove_print_control(self) -&gt; None:\n    \"\"\"Remove the print/export control from the map.\"\"\"\n    self.call_js_method(\"removePrintControl\")\n    if \"print-control\" in self._controls:\n        controls = dict(self._controls)\n        del controls[\"print-control\"]\n        self._controls = controls\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.maplibre.MapLibreMap.remove_search_control","title":"<code>remove_search_control(self)</code>","text":"<p>Remove the search/geocoder control from the map.</p> Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def remove_search_control(self) -&gt; None:\n    \"\"\"Remove the search/geocoder control from the map.\"\"\"\n    self.call_js_method(\"removeSearchControl\")\n    if \"search-control\" in self._controls:\n        controls = dict(self._controls)\n        del controls[\"search-control\"]\n        self._controls = controls\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.maplibre.MapLibreMap.remove_sky","title":"<code>remove_sky(self)</code>","text":"<p>Remove sky and fog atmospheric effects from the map.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; m.remove_sky()\n</code></pre> Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def remove_sky(self) -&gt; None:\n    \"\"\"Remove sky and fog atmospheric effects from the map.\n\n    Example:\n        &gt;&gt;&gt; m.remove_sky()\n    \"\"\"\n    self.call_js_method(\"removeSky\")\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.maplibre.MapLibreMap.remove_split_map","title":"<code>remove_split_map(self)</code>","text":"<p>Remove the split map comparison view.</p> <p>Restores the map to normal single-view mode with all layers visible.</p> Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def remove_split_map(self) -&gt; None:\n    \"\"\"Remove the split map comparison view.\n\n    Restores the map to normal single-view mode with all layers visible.\n    \"\"\"\n    self.call_js_method(\"removeSplitMap\")\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.maplibre.MapLibreMap.remove_style_switcher","title":"<code>remove_style_switcher(self)</code>","text":"<p>Remove the style switcher control.</p> Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def remove_style_switcher(self) -&gt; None:\n    \"\"\"Remove the style switcher control.\"\"\"\n    self.call_js_method(\"removeStyleSwitcher\")\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.maplibre.MapLibreMap.remove_swipe_map","title":"<code>remove_swipe_map(self)</code>","text":"<p>Remove the swipe map comparison control.</p> Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def remove_swipe_map(self) -&gt; None:\n    \"\"\"Remove the swipe map comparison control.\"\"\"\n    self.call_js_method(\"removeSwipeMap\")\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.maplibre.MapLibreMap.remove_time_slider","title":"<code>remove_time_slider(self)</code>","text":"<p>Remove the time slider control.</p> Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def remove_time_slider(self) -&gt; None:\n    \"\"\"Remove the time slider control.\"\"\"\n    self.call_js_method(\"removeTimeSlider\")\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.maplibre.MapLibreMap.remove_tooltip","title":"<code>remove_tooltip(self, layer_id)</code>","text":"<p>Remove tooltip from a layer.</p> <p>Parameters:</p> Name Type Description Default <code>layer_id</code> <code>str</code> <p>The layer identifier.</p> required Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def remove_tooltip(self, layer_id: str) -&gt; None:\n    \"\"\"Remove tooltip from a layer.\n\n    Args:\n        layer_id: The layer identifier.\n    \"\"\"\n    self.call_js_method(\"removeTooltip\", layerId=layer_id)\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.maplibre.MapLibreMap.remove_video_layer","title":"<code>remove_video_layer(self, name)</code>","text":"<p>Remove a video layer from the map.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The layer identifier to remove.</p> required Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def remove_video_layer(self, name: str) -&gt; None:\n    \"\"\"Remove a video layer from the map.\n\n    Args:\n        name: The layer identifier to remove.\n    \"\"\"\n    if name in self._layers:\n        layers = dict(self._layers)\n        del layers[name]\n        self._layers = layers\n    self._remove_from_layer_dict(name)\n    self.call_js_method(\"removeVideoLayer\", id=name)\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.maplibre.MapLibreMap.remove_zarr_layer","title":"<code>remove_zarr_layer(self, layer_id)</code>","text":"<p>Remove a Zarr layer.</p> <p>Parameters:</p> Name Type Description Default <code>layer_id</code> <code>str</code> <p>Layer identifier to remove.</p> required Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def remove_zarr_layer(self, layer_id: str) -&gt; None:\n    \"\"\"Remove a Zarr layer.\n\n    Args:\n        layer_id: Layer identifier to remove.\n    \"\"\"\n    self._remove_layer_internal(layer_id, \"removeZarrLayer\")\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.maplibre.MapLibreMap.resume_animation","title":"<code>resume_animation(self, animation_id)</code>","text":"<p>Resume a paused animation.</p> <p>Parameters:</p> Name Type Description Default <code>animation_id</code> <code>str</code> <p>Animation identifier to resume.</p> required Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def resume_animation(self, animation_id: str) -&gt; None:\n    \"\"\"Resume a paused animation.\n\n    Args:\n        animation_id: Animation identifier to resume.\n    \"\"\"\n    self.call_js_method(\"resumeAnimation\", animation_id)\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.maplibre.MapLibreMap.save_draw_data","title":"<code>save_draw_data(self, filepath, driver=None)</code>","text":"<p>Save drawn features to a file.</p> <p>Parameters:</p> Name Type Description Default <code>filepath</code> <code>Union[str, Path]</code> <p>Path to save file</p> required <code>driver</code> <code>Optional[str]</code> <p>Output driver (auto-detected from extension if not provided)</p> <code>None</code> <p>Exceptions:</p> Type Description <code>ImportError</code> <p>If geopandas is not installed</p> Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def save_draw_data(\n    self,\n    filepath: Union[str, Path],\n    driver: Optional[str] = None,\n) -&gt; None:\n    \"\"\"Save drawn features to a file.\n\n    Args:\n        filepath: Path to save file\n        driver: Output driver (auto-detected from extension if not provided)\n\n    Raises:\n        ImportError: If geopandas is not installed\n    \"\"\"\n    try:\n        import geopandas as gpd\n    except ImportError:\n        raise ImportError(\n            \"geopandas is required to save draw data. \"\n            \"Install with: pip install anymap-ts[vector]\"\n        )\n\n    data = self.get_draw_data()\n    if not data.get(\"features\"):\n        print(\"No features to save\")\n        return\n\n    gdf = gpd.GeoDataFrame.from_features(data[\"features\"])\n    filepath = Path(filepath)\n\n    # Infer driver from extension\n    if driver is None:\n        ext = filepath.suffix.lower()\n        driver_map = {\n            \".geojson\": \"GeoJSON\",\n            \".json\": \"GeoJSON\",\n            \".shp\": \"ESRI Shapefile\",\n            \".gpkg\": \"GPKG\",\n        }\n        driver = driver_map.get(ext, \"GeoJSON\")\n\n    gdf.to_file(filepath, driver=driver)\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.maplibre.MapLibreMap.seek_video","title":"<code>seek_video(self, name, time)</code>","text":"<p>Seek to a specific time in a video layer.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The video layer identifier.</p> required <code>time</code> <code>float</code> <p>Time in seconds to seek to.</p> required Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def seek_video(self, name: str, time: float) -&gt; None:\n    \"\"\"Seek to a specific time in a video layer.\n\n    Args:\n        name: The video layer identifier.\n        time: Time in seconds to seek to.\n    \"\"\"\n    self.call_js_method(\"seekVideo\", id=name, time=time)\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.maplibre.MapLibreMap.set_animation_speed","title":"<code>set_animation_speed(self, animation_id, speed)</code>","text":"<p>Set animation speed multiplier.</p> <p>Parameters:</p> Name Type Description Default <code>animation_id</code> <code>str</code> <p>Animation identifier.</p> required <code>speed</code> <code>float</code> <p>Speed multiplier (1.0 = normal, 2.0 = double speed, etc.).</p> required Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def set_animation_speed(self, animation_id: str, speed: float) -&gt; None:\n    \"\"\"Set animation speed multiplier.\n\n    Args:\n        animation_id: Animation identifier.\n        speed: Speed multiplier (1.0 = normal, 2.0 = double speed, etc.).\n    \"\"\"\n    self.call_js_method(\"setAnimationSpeed\", animation_id, speed)\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.maplibre.MapLibreMap.set_filter","title":"<code>set_filter(self, layer_id, filter_expression=None)</code>","text":"<p>Set or clear a filter on a map layer.</p> <p>Uses MapLibre GL JS filter expressions to show/hide features.</p> <p>Parameters:</p> Name Type Description Default <code>layer_id</code> <code>str</code> <p>The layer to apply the filter to.</p> required <code>filter_expression</code> <code>Optional[List]</code> <p>A MapLibre filter expression (list). Pass None to clear the filter.</p> <code>None</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; m.set_filter(\"states-layer\", [\"&gt;=\", [\"get\", \"density\"], 100])\n&gt;&gt;&gt; m.set_filter(\"states-layer\", None)  # Clear filter\n</code></pre> Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def set_filter(\n    self,\n    layer_id: str,\n    filter_expression: Optional[List] = None,\n) -&gt; None:\n    \"\"\"Set or clear a filter on a map layer.\n\n    Uses MapLibre GL JS filter expressions to show/hide features.\n\n    Args:\n        layer_id: The layer to apply the filter to.\n        filter_expression: A MapLibre filter expression (list).\n            Pass None to clear the filter.\n\n    Example:\n        &gt;&gt;&gt; m.set_filter(\"states-layer\", [\"&gt;=\", [\"get\", \"density\"], 100])\n        &gt;&gt;&gt; m.set_filter(\"states-layer\", None)  # Clear filter\n    \"\"\"\n    self.call_js_method(\n        \"setFilter\",\n        layerId=layer_id,\n        filter=filter_expression,\n    )\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.maplibre.MapLibreMap.set_layout_property","title":"<code>set_layout_property(self, layer_id, property_name, value)</code>","text":"<p>Set a layout property for a layer.</p> <p>Parameters:</p> Name Type Description Default <code>layer_id</code> <code>str</code> <p>Layer identifier.</p> required <code>property_name</code> <code>str</code> <p>Name of the layout property (e.g., 'visibility').</p> required <code>value</code> <code>Any</code> <p>New value for the property.</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; m.set_layout_property(\"my-layer\", \"visibility\", \"none\")\n</code></pre> Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def set_layout_property(\n    self, layer_id: str, property_name: str, value: Any\n) -&gt; None:\n    \"\"\"Set a layout property for a layer.\n\n    Args:\n        layer_id: Layer identifier.\n        property_name: Name of the layout property (e.g., 'visibility').\n        value: New value for the property.\n\n    Example:\n        &gt;&gt;&gt; m.set_layout_property(\"my-layer\", \"visibility\", \"none\")\n    \"\"\"\n    self.call_js_method(\"setLayoutProperty\", layer_id, property_name, value)\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.maplibre.MapLibreMap.set_lidar_color_scheme","title":"<code>set_lidar_color_scheme(self, color_scheme)</code>","text":"<p>Set the LiDAR color scheme.</p> <p>Parameters:</p> Name Type Description Default <code>color_scheme</code> <code>str</code> <p>Color scheme ('elevation', 'intensity', 'classification', 'rgb').</p> required Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def set_lidar_color_scheme(self, color_scheme: str) -&gt; None:\n    \"\"\"Set the LiDAR color scheme.\n\n    Args:\n        color_scheme: Color scheme ('elevation', 'intensity', 'classification', 'rgb').\n    \"\"\"\n    self.call_js_method(\"setLidarColorScheme\", colorScheme=color_scheme)\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.maplibre.MapLibreMap.set_lidar_opacity","title":"<code>set_lidar_opacity(self, opacity)</code>","text":"<p>Set the LiDAR layer opacity.</p> <p>Parameters:</p> Name Type Description Default <code>opacity</code> <code>float</code> <p>Opacity value between 0 and 1.</p> required Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def set_lidar_opacity(self, opacity: float) -&gt; None:\n    \"\"\"Set the LiDAR layer opacity.\n\n    Args:\n        opacity: Opacity value between 0 and 1.\n    \"\"\"\n    self.call_js_method(\"setLidarOpacity\", opacity=opacity)\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.maplibre.MapLibreMap.set_lidar_point_size","title":"<code>set_lidar_point_size(self, point_size)</code>","text":"<p>Set the LiDAR point size.</p> <p>Parameters:</p> Name Type Description Default <code>point_size</code> <code>float</code> <p>Point size in pixels.</p> required Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def set_lidar_point_size(self, point_size: float) -&gt; None:\n    \"\"\"Set the LiDAR point size.\n\n    Args:\n        point_size: Point size in pixels.\n    \"\"\"\n    self.call_js_method(\"setLidarPointSize\", pointSize=point_size)\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.maplibre.MapLibreMap.set_opacity","title":"<code>set_opacity(self, layer_id, opacity)</code>","text":"<p>Set layer opacity.</p> <p>Parameters:</p> Name Type Description Default <code>layer_id</code> <code>str</code> <p>Layer identifier</p> required <code>opacity</code> <code>float</code> <p>Opacity value between 0 and 1</p> required Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def set_opacity(self, layer_id: str, opacity: float) -&gt; None:\n    \"\"\"Set layer opacity.\n\n    Args:\n        layer_id: Layer identifier\n        opacity: Opacity value between 0 and 1\n    \"\"\"\n    self._validate_opacity(opacity)\n    self.call_js_method(\"setOpacity\", layer_id, opacity)\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.maplibre.MapLibreMap.set_paint_property","title":"<code>set_paint_property(self, layer_id, property_name, value)</code>","text":"<p>Set a paint property for a layer.</p> <p>Parameters:</p> Name Type Description Default <code>layer_id</code> <code>str</code> <p>Layer identifier.</p> required <code>property_name</code> <code>str</code> <p>Name of the paint property (e.g., 'fill-color').</p> required <code>value</code> <code>Any</code> <p>New value for the property.</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; m.set_paint_property(\"my-layer\", \"fill-color\", \"#ff0000\")\n&gt;&gt;&gt; m.set_paint_property(\"my-layer\", \"fill-opacity\", 0.5)\n</code></pre> Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def set_paint_property(self, layer_id: str, property_name: str, value: Any) -&gt; None:\n    \"\"\"Set a paint property for a layer.\n\n    Args:\n        layer_id: Layer identifier.\n        property_name: Name of the paint property (e.g., 'fill-color').\n        value: New value for the property.\n\n    Example:\n        &gt;&gt;&gt; m.set_paint_property(\"my-layer\", \"fill-color\", \"#ff0000\")\n        &gt;&gt;&gt; m.set_paint_property(\"my-layer\", \"fill-opacity\", 0.5)\n    \"\"\"\n    self.call_js_method(\"setPaintProperty\", layer_id, property_name, value)\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.maplibre.MapLibreMap.set_projection","title":"<code>set_projection(self, projection='mercator')</code>","text":"<p>Set the map projection.</p> <p>MapLibre GL JS v4+ supports globe projection for a 3D globe view.</p> <p>Parameters:</p> Name Type Description Default <code>projection</code> <code>str</code> <p>Projection type. Supported values: 'mercator', 'globe'.</p> <code>'mercator'</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; m = MapLibreMap()\n&gt;&gt;&gt; m.set_projection(\"globe\")\n</code></pre> Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def set_projection(self, projection: str = \"mercator\") -&gt; None:\n    \"\"\"Set the map projection.\n\n    MapLibre GL JS v4+ supports globe projection for a 3D globe view.\n\n    Args:\n        projection: Projection type. Supported values: 'mercator', 'globe'.\n\n    Example:\n        &gt;&gt;&gt; m = MapLibreMap()\n        &gt;&gt;&gt; m.set_projection(\"globe\")\n    \"\"\"\n    self.call_js_method(\"setProjection\", projection=projection)\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.maplibre.MapLibreMap.set_sky","title":"<code>set_sky(self, sky_color='#88C6FC', horizon_color='#F0E4D4', fog_color='#FFFFFF', sky_horizon_blend=0.5, horizon_fog_blend=0.5, fog_ground_blend=0.5, atmosphere_blend=0.8, **kwargs)</code>","text":"<p>Set sky and fog atmospheric effects for 3D terrain visualization.</p> <p>MapLibre v5 unifies sky and fog into a single <code>map.setSky()</code> API. Best used with 3D terrain enabled.</p> <p>Parameters:</p> Name Type Description Default <code>sky_color</code> <code>str</code> <p>Color of the sky. Default is \"#88C6FC\".</p> <code>'#88C6FC'</code> <code>horizon_color</code> <code>str</code> <p>Color at the horizon. Default is \"#F0E4D4\".</p> <code>'#F0E4D4'</code> <code>fog_color</code> <code>str</code> <p>Color of the fog. Default is \"#FFFFFF\".</p> <code>'#FFFFFF'</code> <code>sky_horizon_blend</code> <code>float</code> <p>Blend between sky and horizon (0-1). Default is 0.5.</p> <code>0.5</code> <code>horizon_fog_blend</code> <code>float</code> <p>Blend between horizon and fog (0-1). Default is 0.5.</p> <code>0.5</code> <code>fog_ground_blend</code> <code>float</code> <p>Blend between fog and ground (0-1). Default is 0.5.</p> <code>0.5</code> <code>atmosphere_blend</code> <code>float</code> <p>Intensity of the atmosphere effect (0-1). Default is 0.8.</p> <code>0.8</code> <code>**kwargs</code> <p>Additional sky options.</p> <code>{}</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from anymap_ts import Map\n&gt;&gt;&gt; m = Map(center=[-122.4, 37.8], zoom=12, pitch=60)\n&gt;&gt;&gt; m.add_3d_terrain(exaggeration=1.5)\n&gt;&gt;&gt; m.set_sky()\n</code></pre> Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def set_sky(\n    self,\n    sky_color: str = \"#88C6FC\",\n    horizon_color: str = \"#F0E4D4\",\n    fog_color: str = \"#FFFFFF\",\n    sky_horizon_blend: float = 0.5,\n    horizon_fog_blend: float = 0.5,\n    fog_ground_blend: float = 0.5,\n    atmosphere_blend: float = 0.8,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Set sky and fog atmospheric effects for 3D terrain visualization.\n\n    MapLibre v5 unifies sky and fog into a single `map.setSky()` API.\n    Best used with 3D terrain enabled.\n\n    Args:\n        sky_color: Color of the sky. Default is \"#88C6FC\".\n        horizon_color: Color at the horizon. Default is \"#F0E4D4\".\n        fog_color: Color of the fog. Default is \"#FFFFFF\".\n        sky_horizon_blend: Blend between sky and horizon (0-1).\n            Default is 0.5.\n        horizon_fog_blend: Blend between horizon and fog (0-1).\n            Default is 0.5.\n        fog_ground_blend: Blend between fog and ground (0-1).\n            Default is 0.5.\n        atmosphere_blend: Intensity of the atmosphere effect (0-1).\n            Default is 0.8.\n        **kwargs: Additional sky options.\n\n    Example:\n        &gt;&gt;&gt; from anymap_ts import Map\n        &gt;&gt;&gt; m = Map(center=[-122.4, 37.8], zoom=12, pitch=60)\n        &gt;&gt;&gt; m.add_3d_terrain(exaggeration=1.5)\n        &gt;&gt;&gt; m.set_sky()\n    \"\"\"\n    self.call_js_method(\n        \"setSky\",\n        skyColor=sky_color,\n        horizonColor=horizon_color,\n        fogColor=fog_color,\n        skyHorizonBlend=sky_horizon_blend,\n        horizonFogBlend=horizon_fog_blend,\n        fogGroundBlend=fog_ground_blend,\n        atmosphereBlend=atmosphere_blend,\n        **kwargs,\n    )\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.maplibre.MapLibreMap.set_visibility","title":"<code>set_visibility(self, layer_id, visible)</code>","text":"<p>Set layer visibility.</p> <p>Parameters:</p> Name Type Description Default <code>layer_id</code> <code>str</code> <p>Layer identifier</p> required <code>visible</code> <code>bool</code> <p>Whether layer should be visible</p> required Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def set_visibility(self, layer_id: str, visible: bool) -&gt; None:\n    \"\"\"Set layer visibility.\n\n    Args:\n        layer_id: Layer identifier\n        visible: Whether layer should be visible\n    \"\"\"\n    self.call_js_method(\"setVisibility\", layer_id, visible)\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.maplibre.MapLibreMap.stop_animation","title":"<code>stop_animation(self, animation_id)</code>","text":"<p>Stop a running animation.</p> <p>Parameters:</p> Name Type Description Default <code>animation_id</code> <code>str</code> <p>Animation identifier to stop.</p> required Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def stop_animation(self, animation_id: str) -&gt; None:\n    \"\"\"Stop a running animation.\n\n    Args:\n        animation_id: Animation identifier to stop.\n    \"\"\"\n    self.call_js_method(\"stopAnimation\", animation_id)\n    if animation_id in self._layers:\n        layers = dict(self._layers)\n        del layers[animation_id]\n        self._layers = layers\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.maplibre.MapLibreMap.to_geojson","title":"<code>to_geojson(self, layer_id=None)</code>","text":"<p>Get layer data as GeoJSON.</p> <p>This triggers a query to the JavaScript side. The result is returned asynchronously via the <code>_queried_features</code> trait.</p> <p>On the first call with a <code>layer_id</code>, the query is sent and <code>None</code> is returned. Run this method in one notebook cell, then call <code>to_geojson()</code> (without arguments) in the next cell to read the result.</p> <p>Parameters:</p> Name Type Description Default <code>layer_id</code> <code>Optional[str]</code> <p>Source/layer ID to export. If <code>None</code>, returns previously queried features.</p> <code>None</code> <p>Returns:</p> Type Description <code>Optional[Dict]</code> <p>GeoJSON FeatureCollection dict, or <code>None</code> if not yet available.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; # Cell 1 \u2013 trigger the query\n&gt;&gt;&gt; m.to_geojson(\"my-data\")\n&gt;&gt;&gt; # Cell 2 \u2013 read the result\n&gt;&gt;&gt; result = m.to_geojson()\n</code></pre> Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def to_geojson(self, layer_id: Optional[str] = None) -&gt; Optional[Dict]:\n    \"\"\"Get layer data as GeoJSON.\n\n    This triggers a query to the JavaScript side. The result is\n    returned asynchronously via the ``_queried_features`` trait.\n\n    On the first call with a ``layer_id``, the query is sent and\n    ``None`` is returned. Run this method in one notebook cell,\n    then call ``to_geojson()`` (without arguments) in the next cell\n    to read the result.\n\n    Args:\n        layer_id: Source/layer ID to export. If ``None``, returns\n            previously queried features.\n\n    Returns:\n        GeoJSON FeatureCollection dict, or ``None`` if not yet\n        available.\n\n    Example:\n        &gt;&gt;&gt; # Cell 1 \u2013 trigger the query\n        &gt;&gt;&gt; m.to_geojson(\"my-data\")\n        &gt;&gt;&gt; # Cell 2 \u2013 read the result\n        &gt;&gt;&gt; result = m.to_geojson()\n    \"\"\"\n    if layer_id:\n        self.call_js_method(\"getLayerData\", sourceId=layer_id)\n    features = self._queried_features\n    if features and \"data\" in features:\n        return features[\"data\"]\n    return None\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.maplibre.MapLibreMap.to_geopandas","title":"<code>to_geopandas(self, layer_id=None)</code>","text":"<p>Get layer data as a GeoDataFrame.</p> <p>Requires geopandas to be installed. Works the same as :meth:<code>to_geojson</code> \u2013 trigger with a <code>layer_id</code> in one cell, then call <code>to_geopandas()</code> in the next cell.</p> <p>Parameters:</p> Name Type Description Default <code>layer_id</code> <code>Optional[str]</code> <p>Source/layer ID to export. If <code>None</code>, returns previously queried features.</p> <code>None</code> <p>Returns:</p> Type Description <code>Any</code> <p>GeoDataFrame, or <code>None</code> if data not available.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; # Cell 1 \u2013 trigger the query\n&gt;&gt;&gt; m.to_geojson(\"my-data\")\n&gt;&gt;&gt; # Cell 2 \u2013 read the result\n&gt;&gt;&gt; gdf = m.to_geopandas()\n</code></pre> Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def to_geopandas(self, layer_id: Optional[str] = None) -&gt; Any:\n    \"\"\"Get layer data as a GeoDataFrame.\n\n    Requires geopandas to be installed. Works the same as\n    :meth:`to_geojson` \u2013 trigger with a ``layer_id`` in one cell,\n    then call ``to_geopandas()`` in the next cell.\n\n    Args:\n        layer_id: Source/layer ID to export. If ``None``, returns\n            previously queried features.\n\n    Returns:\n        GeoDataFrame, or ``None`` if data not available.\n\n    Example:\n        &gt;&gt;&gt; # Cell 1 \u2013 trigger the query\n        &gt;&gt;&gt; m.to_geojson(\"my-data\")\n        &gt;&gt;&gt; # Cell 2 \u2013 read the result\n        &gt;&gt;&gt; gdf = m.to_geopandas()\n    \"\"\"\n    geojson = self.to_geojson(layer_id)\n    if geojson is None:\n        return None\n    try:\n        import geopandas as gpd\n\n        return gpd.GeoDataFrame.from_features(geojson.get(\"features\", []))\n    except ImportError:\n        raise ImportError(\"geopandas is required for to_geopandas()\")\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.maplibre.MapLibreMap.update_colorbar","title":"<code>update_colorbar(self, colorbar_id=None, **kwargs)</code>","text":"<p>Update an existing colorbar's properties.</p> <p>Parameters:</p> Name Type Description Default <code>colorbar_id</code> <code>Optional[str]</code> <p>Colorbar identifier to update. If None, updates the first colorbar found.</p> <code>None</code> <code>**kwargs</code> <p>Properties to update (colormap, vmin, vmax, label, units, orientation, bar_thickness, bar_length, ticks, opacity).</p> <code>{}</code> Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def update_colorbar(self, colorbar_id: Optional[str] = None, **kwargs) -&gt; None:\n    \"\"\"Update an existing colorbar's properties.\n\n    Args:\n        colorbar_id: Colorbar identifier to update. If None, updates\n            the first colorbar found.\n        **kwargs: Properties to update (colormap, vmin, vmax, label,\n            units, orientation, bar_thickness, bar_length, ticks, opacity).\n    \"\"\"\n    if colorbar_id is None:\n        cbar_keys = [k for k in self._controls.keys() if k.startswith(\"colorbar\")]\n        if not cbar_keys:\n            raise ValueError(\"No colorbar found to update\")\n        colorbar_id = cbar_keys[0]\n\n    if colorbar_id not in self._controls:\n        raise ValueError(f\"Colorbar '{colorbar_id}' not found\")\n\n    js_kwargs: Dict[str, Any] = {\"colorbarId\": colorbar_id}\n    key_map = {\n        \"bar_thickness\": \"barThickness\",\n        \"bar_length\": \"barLength\",\n    }\n    for key, value in kwargs.items():\n        js_key = key_map.get(key, key)\n        js_kwargs[js_key] = value\n\n    self.call_js_method(\"updateColorbar\", **js_kwargs)\n\n    for key, value in kwargs.items():\n        if key in self._controls.get(colorbar_id, {}):\n            self._controls[colorbar_id][key] = value\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.maplibre.MapLibreMap.update_geojson_source","title":"<code>update_geojson_source(self, source_id, data)</code>","text":"<p>Update the data of an existing GeoJSON source in place.</p> <p>This enables real-time/streaming data updates without removing and re-adding layers. Critical for live dashboards.</p> <p>Parameters:</p> Name Type Description Default <code>source_id</code> <code>str</code> <p>The ID of the GeoJSON source to update.</p> required <code>data</code> <code>Any</code> <p>New GeoJSON data (dict, GeoDataFrame, or URL string).</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; m = MapLibreMap()\n&gt;&gt;&gt; m.add_geojson(\"initial.geojson\", name=\"points\")\n&gt;&gt;&gt; # Later, update with new data\n&gt;&gt;&gt; m.update_geojson_source(\"points\", new_geojson_data)\n</code></pre> Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def update_geojson_source(self, source_id: str, data: Any) -&gt; None:\n    \"\"\"Update the data of an existing GeoJSON source in place.\n\n    This enables real-time/streaming data updates without removing\n    and re-adding layers. Critical for live dashboards.\n\n    Args:\n        source_id: The ID of the GeoJSON source to update.\n        data: New GeoJSON data (dict, GeoDataFrame, or URL string).\n\n    Example:\n        &gt;&gt;&gt; m = MapLibreMap()\n        &gt;&gt;&gt; m.add_geojson(\"initial.geojson\", name=\"points\")\n        &gt;&gt;&gt; # Later, update with new data\n        &gt;&gt;&gt; m.update_geojson_source(\"points\", new_geojson_data)\n    \"\"\"\n    processed_data = self._process_deck_data(data)\n    self.call_js_method(\n        \"updateGeoJSONSource\",\n        sourceId=source_id,\n        data=processed_data,\n    )\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.maplibre.MapLibreMap.update_legend","title":"<code>update_legend(self, legend_id, title=None, labels=None, colors=None, opacity=None, **kwargs)</code>","text":"<p>Update an existing legend's properties.</p> <p>Parameters:</p> Name Type Description Default <code>legend_id</code> <code>str</code> <p>Legend identifier to update</p> required <code>title</code> <code>Optional[str]</code> <p>New title (if provided)</p> <code>None</code> <code>labels</code> <code>Optional[List[str]]</code> <p>New labels list (if provided)</p> <code>None</code> <code>colors</code> <code>Optional[List[str]]</code> <p>New colors list (if provided)</p> <code>None</code> <code>opacity</code> <code>Optional[float]</code> <p>New opacity (if provided)</p> <code>None</code> <code>**kwargs</code> <p>Additional properties to update</p> <code>{}</code> Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def update_legend(\n    self,\n    legend_id: str,\n    title: Optional[str] = None,\n    labels: Optional[List[str]] = None,\n    colors: Optional[List[str]] = None,\n    opacity: Optional[float] = None,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Update an existing legend's properties.\n\n    Args:\n        legend_id: Legend identifier to update\n        title: New title (if provided)\n        labels: New labels list (if provided)\n        colors: New colors list (if provided)\n        opacity: New opacity (if provided)\n        **kwargs: Additional properties to update\n    \"\"\"\n    if legend_id not in self._controls:\n        raise ValueError(f\"Legend '{legend_id}' not found\")\n\n    update_params = {\"id\": legend_id}\n\n    if title is not None:\n        update_params[\"title\"] = title\n        self._controls[legend_id][\"title\"] = title\n\n    if labels is not None and colors is not None:\n        if len(labels) != len(colors):\n            raise ValueError(\"Number of labels must match number of colors\")\n\n        legend_items = [\n            {\"label\": label, \"color\": color} for label, color in zip(labels, colors)\n        ]\n        update_params[\"items\"] = legend_items\n        self._controls[legend_id][\"labels\"] = labels\n        self._controls[legend_id][\"colors\"] = colors\n\n    elif labels is not None or colors is not None:\n        raise ValueError(\"Both labels and colors must be provided together\")\n\n    if opacity is not None:\n        update_params[\"opacity\"] = opacity\n        self._controls[legend_id][\"opacity\"] = opacity\n\n    update_params.update(kwargs)\n    self.call_js_method(\"updateLegend\", **update_params)\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.maplibre.MapLibreMap.update_zarr_layer","title":"<code>update_zarr_layer(self, layer_id, selector=None, clim=None, colormap=None, opacity=None)</code>","text":"<p>Update a Zarr layer's properties dynamically.</p> <p>Parameters:</p> Name Type Description Default <code>layer_id</code> <code>str</code> <p>Layer identifier.</p> required <code>selector</code> <code>Optional[Dict[str, Any]]</code> <p>New dimension selector.</p> <code>None</code> <code>clim</code> <code>Optional[Tuple[float, float]]</code> <p>New color range.</p> <code>None</code> <code>colormap</code> <code>Optional[List[str]]</code> <p>New colormap.</p> <code>None</code> <code>opacity</code> <code>Optional[float]</code> <p>New opacity value (0-1).</p> <code>None</code> Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def update_zarr_layer(\n    self,\n    layer_id: str,\n    selector: Optional[Dict[str, Any]] = None,\n    clim: Optional[Tuple[float, float]] = None,\n    colormap: Optional[List[str]] = None,\n    opacity: Optional[float] = None,\n) -&gt; None:\n    \"\"\"Update a Zarr layer's properties dynamically.\n\n    Args:\n        layer_id: Layer identifier.\n        selector: New dimension selector.\n        clim: New color range.\n        colormap: New colormap.\n        opacity: New opacity value (0-1).\n    \"\"\"\n    update_kwargs: Dict[str, Any] = {\"id\": layer_id}\n    if selector is not None:\n        update_kwargs[\"selector\"] = selector\n    if clim is not None:\n        update_kwargs[\"clim\"] = list(clim)\n    if colormap is not None:\n        update_kwargs[\"colormap\"] = colormap\n    if opacity is not None:\n        update_kwargs[\"opacity\"] = opacity\n    self.call_js_method(\"updateZarrLayer\", **update_kwargs)\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.openlayers","title":"<code>openlayers</code>","text":"<p>OpenLayers map widget implementation.</p>"},{"location":"anymap_ts/#anymap_ts.openlayers.OpenLayersMap","title":"<code> OpenLayersMap            (MapWidget)         </code>","text":"<p>Interactive map widget using OpenLayers.</p> <p>This class provides a Python interface to OpenLayers maps with full bidirectional communication through anywidget. OpenLayers excels at WMS/WMTS support and projection handling.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from anymap_ts import OpenLayersMap\n&gt;&gt;&gt; m = OpenLayersMap(center=[-122.4, 37.8], zoom=10)\n&gt;&gt;&gt; m.add_basemap(\"OpenStreetMap\")\n&gt;&gt;&gt; m.add_wms_layer(\n...     url=\"https://example.com/wms\",\n...     layers=\"layer_name\",\n...     name=\"WMS Layer\"\n... )\n&gt;&gt;&gt; m\n</code></pre> Source code in <code>anymap_ts/openlayers.py</code> <pre><code>class OpenLayersMap(MapWidget):\n    \"\"\"Interactive map widget using OpenLayers.\n\n    This class provides a Python interface to OpenLayers maps with\n    full bidirectional communication through anywidget. OpenLayers\n    excels at WMS/WMTS support and projection handling.\n\n    Example:\n        &gt;&gt;&gt; from anymap_ts import OpenLayersMap\n        &gt;&gt;&gt; m = OpenLayersMap(center=[-122.4, 37.8], zoom=10)\n        &gt;&gt;&gt; m.add_basemap(\"OpenStreetMap\")\n        &gt;&gt;&gt; m.add_wms_layer(\n        ...     url=\"https://example.com/wms\",\n        ...     layers=\"layer_name\",\n        ...     name=\"WMS Layer\"\n        ... )\n        &gt;&gt;&gt; m\n    \"\"\"\n\n    # ESM module and CSS for frontend\n    _esm = STATIC_DIR / \"openlayers.js\"\n    _css = STATIC_DIR / \"openlayers.css\"\n\n    # OpenLayers-specific traits\n    projection = traitlets.Unicode(\"EPSG:3857\").tag(sync=True)\n    rotation = traitlets.Float(0.0).tag(sync=True)\n\n    # Layer tracking\n    _layer_dict = traitlets.Dict({}).tag(sync=True)\n\n    def __init__(\n        self,\n        center: Tuple[float, float] = (0.0, 0.0),\n        zoom: float = 2.0,\n        width: str = \"100%\",\n        height: str = \"600px\",\n        projection: str = \"EPSG:3857\",\n        rotation: float = 0.0,\n        controls: Optional[Dict[str, Any]] = None,\n        **kwargs,\n    ):\n        \"\"\"Initialize an OpenLayers map.\n\n        Args:\n            center: Map center as (longitude, latitude).\n            zoom: Initial zoom level.\n            width: Map width as CSS string.\n            height: Map height as CSS string.\n            projection: Map projection (default EPSG:3857).\n            rotation: Map rotation in radians.\n            controls: Dict of controls to add.\n            **kwargs: Additional widget arguments.\n        \"\"\"\n        super().__init__(\n            center=list(center),\n            zoom=zoom,\n            width=width,\n            height=height,\n            projection=projection,\n            rotation=rotation,\n            **kwargs,\n        )\n\n        # Initialize layer dictionary\n        self._layer_dict = {\"Background\": []}\n\n        # Add default controls\n        if controls is None:\n            controls = {\"zoom\": True, \"attribution\": True}\n\n        for control_name, config in controls.items():\n            if config:\n                self.add_control(\n                    control_name, **(config if isinstance(config, dict) else {})\n                )\n\n    # -------------------------------------------------------------------------\n    # Basemap Methods\n    # -------------------------------------------------------------------------\n\n    def add_basemap(\n        self,\n        basemap: str = \"OpenStreetMap\",\n        attribution: Optional[str] = None,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a basemap layer.\n\n        Args:\n            basemap: Name of basemap provider (e.g., \"OpenStreetMap\", \"CartoDB.Positron\").\n            attribution: Custom attribution text.\n            **kwargs: Additional options.\n        \"\"\"\n        url, default_attribution = get_basemap_url(basemap)\n        self.call_js_method(\n            \"addBasemap\",\n            url,\n            attribution=attribution or default_attribution,\n            name=basemap,\n            **kwargs,\n        )\n\n        basemaps = self._layer_dict.get(\"Basemaps\", [])\n        if basemap not in basemaps:\n            self._layer_dict = {\n                **self._layer_dict,\n                \"Basemaps\": basemaps + [basemap],\n            }\n\n    # -------------------------------------------------------------------------\n    # Tile Layer Methods\n    # -------------------------------------------------------------------------\n\n    def add_tile_layer(\n        self,\n        url: str,\n        name: Optional[str] = None,\n        attribution: str = \"\",\n        min_zoom: int = 0,\n        max_zoom: int = 22,\n        opacity: float = 1.0,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add an XYZ tile layer.\n\n        Args:\n            url: Tile URL template with {x}, {y}, {z} placeholders.\n            name: Layer name.\n            attribution: Attribution text.\n            min_zoom: Minimum zoom level.\n            max_zoom: Maximum zoom level.\n            opacity: Layer opacity.\n            **kwargs: Additional options.\n        \"\"\"\n        layer_id = name or f\"tiles-{len(self._layers)}\"\n\n        self.call_js_method(\n            \"addTileLayer\",\n            url,\n            name=layer_id,\n            attribution=attribution,\n            minZoom=min_zoom,\n            maxZoom=max_zoom,\n            opacity=opacity,\n            **kwargs,\n        )\n\n        self._layers = {\n            **self._layers,\n            layer_id: {\"id\": layer_id, \"type\": \"tile\"},\n        }\n\n    # -------------------------------------------------------------------------\n    # Vector Data Methods\n    # -------------------------------------------------------------------------\n\n    def add_vector(\n        self,\n        data: Any,\n        name: Optional[str] = None,\n        style: Optional[Dict] = None,\n        fit_bounds: bool = True,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add vector data to the map.\n\n        Args:\n            data: GeoJSON dict, GeoDataFrame, or path to vector file.\n            name: Layer name.\n            style: Style configuration dict.\n            fit_bounds: Whether to fit map to data bounds.\n            **kwargs: Additional layer options.\n        \"\"\"\n        geojson = to_geojson(data)\n        layer_id = name or f\"vector-{len(self._layers)}\"\n\n        if style is None:\n            style = self._get_default_style(geojson)\n\n        self.call_js_method(\n            \"addGeoJSON\",\n            data=geojson,\n            name=layer_id,\n            style=style,\n            fitBounds=fit_bounds,\n            **kwargs,\n        )\n\n        self._layers = {\n            **self._layers,\n            layer_id: {\"id\": layer_id, \"type\": \"vector\"},\n        }\n\n    def add_geojson(\n        self,\n        data: Union[str, Dict],\n        name: Optional[str] = None,\n        style: Optional[Dict] = None,\n        fit_bounds: bool = True,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add GeoJSON data to the map.\n\n        Args:\n            data: GeoJSON dict or URL to GeoJSON file.\n            name: Layer name.\n            style: Style configuration dict.\n            fit_bounds: Whether to fit map to data bounds.\n            **kwargs: Additional layer options.\n        \"\"\"\n        self.add_vector(\n            data,\n            name=name,\n            style=style,\n            fit_bounds=fit_bounds,\n            **kwargs,\n        )\n\n    def _get_default_style(self, geojson: Dict) -&gt; Dict:\n        \"\"\"Get default style based on geometry type.\n\n        Args:\n            geojson: GeoJSON data.\n\n        Returns:\n            Style configuration dict.\n        \"\"\"\n        geom_type = self._infer_geom_type(geojson)\n\n        if geom_type in [\"Point\", \"MultiPoint\"]:\n            return {\n                \"fillColor\": \"rgba(51, 136, 255, 0.8)\",\n                \"strokeColor\": \"#ffffff\",\n                \"strokeWidth\": 2,\n                \"radius\": 6,\n            }\n        elif geom_type in [\"LineString\", \"MultiLineString\"]:\n            return {\n                \"strokeColor\": \"#3388ff\",\n                \"strokeWidth\": 3,\n            }\n        else:  # Polygon, MultiPolygon\n            return {\n                \"fillColor\": \"rgba(51, 136, 255, 0.5)\",\n                \"strokeColor\": \"#3388ff\",\n                \"strokeWidth\": 2,\n            }\n\n    def _infer_geom_type(self, geojson: Dict) -&gt; str:\n        \"\"\"Infer geometry type from GeoJSON.\n\n        Args:\n            geojson: GeoJSON data.\n\n        Returns:\n            Geometry type string.\n        \"\"\"\n        if geojson.get(\"type\") == \"FeatureCollection\":\n            features = geojson.get(\"features\", [])\n            if features:\n                return features[0].get(\"geometry\", {}).get(\"type\", \"Point\")\n        elif geojson.get(\"type\") == \"Feature\":\n            return geojson.get(\"geometry\", {}).get(\"type\", \"Point\")\n        return \"Point\"\n\n    # -------------------------------------------------------------------------\n    # WMS/WMTS Methods\n    # -------------------------------------------------------------------------\n\n    def add_wms_layer(\n        self,\n        url: str,\n        layers: str,\n        name: Optional[str] = None,\n        format: str = \"image/png\",\n        transparent: bool = True,\n        server_type: Optional[str] = None,\n        attribution: str = \"\",\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a WMS tile layer.\n\n        Args:\n            url: WMS service URL.\n            layers: Comma-separated layer names.\n            name: Layer name for the map.\n            format: Image format (default: image/png).\n            transparent: Whether to request transparent images.\n            server_type: Server type ('mapserver', 'geoserver', 'qgis').\n            attribution: Attribution text.\n            **kwargs: Additional WMS parameters.\n        \"\"\"\n        layer_id = name or f\"wms-{len(self._layers)}\"\n\n        self.call_js_method(\n            \"addWMSLayer\",\n            url=url,\n            layers=layers,\n            name=layer_id,\n            format=format,\n            transparent=transparent,\n            serverType=server_type,\n            attribution=attribution,\n            **kwargs,\n        )\n\n        self._layers = {\n            **self._layers,\n            layer_id: {\"id\": layer_id, \"type\": \"wms\"},\n        }\n\n    def add_image_wms_layer(\n        self,\n        url: str,\n        layers: str,\n        name: Optional[str] = None,\n        format: str = \"image/png\",\n        transparent: bool = True,\n        server_type: Optional[str] = None,\n        attribution: str = \"\",\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a single-image WMS layer (not tiled).\n\n        Args:\n            url: WMS service URL.\n            layers: Comma-separated layer names.\n            name: Layer name for the map.\n            format: Image format (default: image/png).\n            transparent: Whether to request transparent images.\n            server_type: Server type ('mapserver', 'geoserver', 'qgis').\n            attribution: Attribution text.\n            **kwargs: Additional WMS parameters.\n        \"\"\"\n        layer_id = name or f\"imagewms-{len(self._layers)}\"\n\n        self.call_js_method(\n            \"addImageWMSLayer\",\n            url=url,\n            layers=layers,\n            name=layer_id,\n            format=format,\n            transparent=transparent,\n            serverType=server_type,\n            attribution=attribution,\n            **kwargs,\n        )\n\n        self._layers = {\n            **self._layers,\n            layer_id: {\"id\": layer_id, \"type\": \"imagewms\"},\n        }\n\n    # -------------------------------------------------------------------------\n    # Layer Management\n    # -------------------------------------------------------------------------\n\n    def remove_layer(self, layer_id: str) -&gt; None:\n        \"\"\"Remove a layer from the map.\n\n        Args:\n            layer_id: Layer identifier to remove.\n        \"\"\"\n        if layer_id in self._layers:\n            layers = dict(self._layers)\n            del layers[layer_id]\n            self._layers = layers\n        self.call_js_method(\"removeLayer\", layer_id)\n\n    def set_visibility(self, layer_id: str, visible: bool) -&gt; None:\n        \"\"\"Set layer visibility.\n\n        Args:\n            layer_id: Layer identifier.\n            visible: Whether layer should be visible.\n        \"\"\"\n        self.call_js_method(\"setVisibility\", layer_id, visible)\n\n    def set_opacity(self, layer_id: str, opacity: float) -&gt; None:\n        \"\"\"Set layer opacity.\n\n        Args:\n            layer_id: Layer identifier.\n            opacity: Opacity value between 0 and 1.\n        \"\"\"\n        self.call_js_method(\"setOpacity\", layer_id, opacity)\n\n    # -------------------------------------------------------------------------\n    # Controls\n    # -------------------------------------------------------------------------\n\n    def add_control(\n        self,\n        control_type: str,\n        position: str = \"top-right\",\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a map control.\n\n        Args:\n            control_type: Type of control ('zoom', 'scale', 'fullscreen', etc.).\n            position: Control position.\n            **kwargs: Control-specific options.\n        \"\"\"\n        self.call_js_method(\"addControl\", control_type, position=position, **kwargs)\n        self._controls = {\n            **self._controls,\n            control_type: {\"type\": control_type, \"position\": position, **kwargs},\n        }\n\n    def remove_control(self, control_type: str) -&gt; None:\n        \"\"\"Remove a map control.\n\n        Args:\n            control_type: Type of control to remove.\n        \"\"\"\n        self.call_js_method(\"removeControl\", control_type)\n        if control_type in self._controls:\n            controls = dict(self._controls)\n            del controls[control_type]\n            self._controls = controls\n\n    # -------------------------------------------------------------------------\n    # Navigation\n    # -------------------------------------------------------------------------\n\n    def set_center(self, lng: float, lat: float) -&gt; None:\n        \"\"\"Set the map center.\n\n        Args:\n            lng: Longitude.\n            lat: Latitude.\n        \"\"\"\n        self.center = [lng, lat]\n        self.call_js_method(\"setCenter\", lng, lat)\n\n    def set_zoom(self, zoom: float) -&gt; None:\n        \"\"\"Set the map zoom level.\n\n        Args:\n            zoom: Zoom level.\n        \"\"\"\n        self.zoom = zoom\n        self.call_js_method(\"setZoom\", zoom)\n\n    def fly_to(\n        self,\n        lng: float,\n        lat: float,\n        zoom: Optional[float] = None,\n        duration: int = 2000,\n    ) -&gt; None:\n        \"\"\"Animate to a new location.\n\n        Args:\n            lng: Target longitude.\n            lat: Target latitude.\n            zoom: Target zoom level (optional).\n            duration: Animation duration in milliseconds.\n        \"\"\"\n        self.call_js_method(\n            \"flyTo\", lng, lat, zoom=zoom or self.zoom, duration=duration\n        )\n\n    def fit_bounds(\n        self,\n        bounds: List[float],\n        padding: int = 50,\n        duration: int = 1000,\n    ) -&gt; None:\n        \"\"\"Fit the map to bounds.\n\n        Args:\n            bounds: Bounds as [minLng, minLat, maxLng, maxLat].\n            padding: Padding in pixels.\n            duration: Animation duration in milliseconds.\n        \"\"\"\n        self.call_js_method(\"fitBounds\", bounds, padding=padding, duration=duration)\n\n    def fit_extent(\n        self,\n        extent: List[float],\n        padding: int = 50,\n        duration: int = 1000,\n    ) -&gt; None:\n        \"\"\"Fit the map to an extent (in map projection).\n\n        Args:\n            extent: Extent as [minX, minY, maxX, maxY] in map projection.\n            padding: Padding in pixels.\n            duration: Animation duration in milliseconds.\n        \"\"\"\n        self.call_js_method(\"fitExtent\", extent, padding=padding, duration=duration)\n\n    # -------------------------------------------------------------------------\n    # Markers\n    # -------------------------------------------------------------------------\n\n    def add_marker(\n        self,\n        lng: float,\n        lat: float,\n        popup: Optional[str] = None,\n        color: str = \"#3388ff\",\n        name: Optional[str] = None,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a marker to the map.\n\n        Args:\n            lng: Marker longitude.\n            lat: Marker latitude.\n            popup: Popup content (HTML string).\n            color: Marker color.\n            name: Marker identifier.\n            **kwargs: Additional options.\n        \"\"\"\n        marker_id = name or f\"marker-{len(self._layers)}\"\n        self.call_js_method(\n            \"addMarker\",\n            lng,\n            lat,\n            popup=popup,\n            color=color,\n            id=marker_id,\n            **kwargs,\n        )\n\n    # -------------------------------------------------------------------------\n    # HTML Export\n    # -------------------------------------------------------------------------\n\n    def _generate_html_template(self) -&gt; str:\n        \"\"\"Generate standalone HTML for the map.\"\"\"\n        template_path = Path(__file__).parent / \"templates\" / \"openlayers.html\"\n\n        if template_path.exists():\n            template = template_path.read_text(encoding=\"utf-8\")\n        else:\n            template = self._get_default_template()\n\n        state = {\n            \"center\": self.center,\n            \"zoom\": self.zoom,\n            \"projection\": self.projection,\n            \"rotation\": self.rotation,\n            \"width\": self.width,\n            \"height\": self.height,\n            \"layers\": self._layers,\n            \"controls\": self._controls,\n            \"js_calls\": self._js_calls,\n        }\n\n        template = template.replace(\"{{state}}\", json.dumps(state, indent=2))\n        return template\n\n    def _get_default_template(self) -&gt; str:\n        \"\"\"Get default HTML template.\"\"\"\n        return \"\"\"&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n    &lt;meta charset=\"utf-8\"&gt;\n    &lt;title&gt;OpenLayers Map&lt;/title&gt;\n    &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"&gt;\n    &lt;link rel=\"stylesheet\" href=\"https://cdn.jsdelivr.net/npm/ol@v10.0.0/ol.css\"&gt;\n    &lt;script src=\"https://cdn.jsdelivr.net/npm/ol@v10.0.0/dist/ol.js\"&gt;&lt;/script&gt;\n    &lt;style&gt;\n        * { margin: 0; padding: 0; box-sizing: border-box; }\n        html, body { height: 100%; }\n        #map { position: absolute; top: 0; bottom: 0; width: 100%; }\n    &lt;/style&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;div id=\"map\"&gt;&lt;/div&gt;\n    &lt;script&gt;\n        const state = {{state}};\n\n        const map = new ol.Map({\n            target: 'map',\n            view: new ol.View({\n                center: ol.proj.fromLonLat(state.center),\n                zoom: state.zoom\n            })\n        });\n\n        for (const call of state.js_calls || []) {\n            executeMethod(call.method, call.args, call.kwargs);\n        }\n\n        function executeMethod(method, args, kwargs) {\n            console.log('Executing:', method, args, kwargs);\n        }\n    &lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\"\"\"\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.openlayers.OpenLayersMap.__init__","title":"<code>__init__(self, center=(0.0, 0.0), zoom=2.0, width='100%', height='600px', projection='EPSG:3857', rotation=0.0, controls=None, **kwargs)</code>  <code>special</code>","text":"<p>Initialize an OpenLayers map.</p> <p>Parameters:</p> Name Type Description Default <code>center</code> <code>Tuple[float, float]</code> <p>Map center as (longitude, latitude).</p> <code>(0.0, 0.0)</code> <code>zoom</code> <code>float</code> <p>Initial zoom level.</p> <code>2.0</code> <code>width</code> <code>str</code> <p>Map width as CSS string.</p> <code>'100%'</code> <code>height</code> <code>str</code> <p>Map height as CSS string.</p> <code>'600px'</code> <code>projection</code> <code>str</code> <p>Map projection (default EPSG:3857).</p> <code>'EPSG:3857'</code> <code>rotation</code> <code>float</code> <p>Map rotation in radians.</p> <code>0.0</code> <code>controls</code> <code>Optional[Dict[str, Any]]</code> <p>Dict of controls to add.</p> <code>None</code> <code>**kwargs</code> <p>Additional widget arguments.</p> <code>{}</code> Source code in <code>anymap_ts/openlayers.py</code> <pre><code>def __init__(\n    self,\n    center: Tuple[float, float] = (0.0, 0.0),\n    zoom: float = 2.0,\n    width: str = \"100%\",\n    height: str = \"600px\",\n    projection: str = \"EPSG:3857\",\n    rotation: float = 0.0,\n    controls: Optional[Dict[str, Any]] = None,\n    **kwargs,\n):\n    \"\"\"Initialize an OpenLayers map.\n\n    Args:\n        center: Map center as (longitude, latitude).\n        zoom: Initial zoom level.\n        width: Map width as CSS string.\n        height: Map height as CSS string.\n        projection: Map projection (default EPSG:3857).\n        rotation: Map rotation in radians.\n        controls: Dict of controls to add.\n        **kwargs: Additional widget arguments.\n    \"\"\"\n    super().__init__(\n        center=list(center),\n        zoom=zoom,\n        width=width,\n        height=height,\n        projection=projection,\n        rotation=rotation,\n        **kwargs,\n    )\n\n    # Initialize layer dictionary\n    self._layer_dict = {\"Background\": []}\n\n    # Add default controls\n    if controls is None:\n        controls = {\"zoom\": True, \"attribution\": True}\n\n    for control_name, config in controls.items():\n        if config:\n            self.add_control(\n                control_name, **(config if isinstance(config, dict) else {})\n            )\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.openlayers.OpenLayersMap.add_basemap","title":"<code>add_basemap(self, basemap='OpenStreetMap', attribution=None, **kwargs)</code>","text":"<p>Add a basemap layer.</p> <p>Parameters:</p> Name Type Description Default <code>basemap</code> <code>str</code> <p>Name of basemap provider (e.g., \"OpenStreetMap\", \"CartoDB.Positron\").</p> <code>'OpenStreetMap'</code> <code>attribution</code> <code>Optional[str]</code> <p>Custom attribution text.</p> <code>None</code> <code>**kwargs</code> <p>Additional options.</p> <code>{}</code> Source code in <code>anymap_ts/openlayers.py</code> <pre><code>def add_basemap(\n    self,\n    basemap: str = \"OpenStreetMap\",\n    attribution: Optional[str] = None,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a basemap layer.\n\n    Args:\n        basemap: Name of basemap provider (e.g., \"OpenStreetMap\", \"CartoDB.Positron\").\n        attribution: Custom attribution text.\n        **kwargs: Additional options.\n    \"\"\"\n    url, default_attribution = get_basemap_url(basemap)\n    self.call_js_method(\n        \"addBasemap\",\n        url,\n        attribution=attribution or default_attribution,\n        name=basemap,\n        **kwargs,\n    )\n\n    basemaps = self._layer_dict.get(\"Basemaps\", [])\n    if basemap not in basemaps:\n        self._layer_dict = {\n            **self._layer_dict,\n            \"Basemaps\": basemaps + [basemap],\n        }\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.openlayers.OpenLayersMap.add_control","title":"<code>add_control(self, control_type, position='top-right', **kwargs)</code>","text":"<p>Add a map control.</p> <p>Parameters:</p> Name Type Description Default <code>control_type</code> <code>str</code> <p>Type of control ('zoom', 'scale', 'fullscreen', etc.).</p> required <code>position</code> <code>str</code> <p>Control position.</p> <code>'top-right'</code> <code>**kwargs</code> <p>Control-specific options.</p> <code>{}</code> Source code in <code>anymap_ts/openlayers.py</code> <pre><code>def add_control(\n    self,\n    control_type: str,\n    position: str = \"top-right\",\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a map control.\n\n    Args:\n        control_type: Type of control ('zoom', 'scale', 'fullscreen', etc.).\n        position: Control position.\n        **kwargs: Control-specific options.\n    \"\"\"\n    self.call_js_method(\"addControl\", control_type, position=position, **kwargs)\n    self._controls = {\n        **self._controls,\n        control_type: {\"type\": control_type, \"position\": position, **kwargs},\n    }\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.openlayers.OpenLayersMap.add_geojson","title":"<code>add_geojson(self, data, name=None, style=None, fit_bounds=True, **kwargs)</code>","text":"<p>Add GeoJSON data to the map.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Union[str, Dict]</code> <p>GeoJSON dict or URL to GeoJSON file.</p> required <code>name</code> <code>Optional[str]</code> <p>Layer name.</p> <code>None</code> <code>style</code> <code>Optional[Dict]</code> <p>Style configuration dict.</p> <code>None</code> <code>fit_bounds</code> <code>bool</code> <p>Whether to fit map to data bounds.</p> <code>True</code> <code>**kwargs</code> <p>Additional layer options.</p> <code>{}</code> Source code in <code>anymap_ts/openlayers.py</code> <pre><code>def add_geojson(\n    self,\n    data: Union[str, Dict],\n    name: Optional[str] = None,\n    style: Optional[Dict] = None,\n    fit_bounds: bool = True,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add GeoJSON data to the map.\n\n    Args:\n        data: GeoJSON dict or URL to GeoJSON file.\n        name: Layer name.\n        style: Style configuration dict.\n        fit_bounds: Whether to fit map to data bounds.\n        **kwargs: Additional layer options.\n    \"\"\"\n    self.add_vector(\n        data,\n        name=name,\n        style=style,\n        fit_bounds=fit_bounds,\n        **kwargs,\n    )\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.openlayers.OpenLayersMap.add_image_wms_layer","title":"<code>add_image_wms_layer(self, url, layers, name=None, format='image/png', transparent=True, server_type=None, attribution='', **kwargs)</code>","text":"<p>Add a single-image WMS layer (not tiled).</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>WMS service URL.</p> required <code>layers</code> <code>str</code> <p>Comma-separated layer names.</p> required <code>name</code> <code>Optional[str]</code> <p>Layer name for the map.</p> <code>None</code> <code>format</code> <code>str</code> <p>Image format (default: image/png).</p> <code>'image/png'</code> <code>transparent</code> <code>bool</code> <p>Whether to request transparent images.</p> <code>True</code> <code>server_type</code> <code>Optional[str]</code> <p>Server type ('mapserver', 'geoserver', 'qgis').</p> <code>None</code> <code>attribution</code> <code>str</code> <p>Attribution text.</p> <code>''</code> <code>**kwargs</code> <p>Additional WMS parameters.</p> <code>{}</code> Source code in <code>anymap_ts/openlayers.py</code> <pre><code>def add_image_wms_layer(\n    self,\n    url: str,\n    layers: str,\n    name: Optional[str] = None,\n    format: str = \"image/png\",\n    transparent: bool = True,\n    server_type: Optional[str] = None,\n    attribution: str = \"\",\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a single-image WMS layer (not tiled).\n\n    Args:\n        url: WMS service URL.\n        layers: Comma-separated layer names.\n        name: Layer name for the map.\n        format: Image format (default: image/png).\n        transparent: Whether to request transparent images.\n        server_type: Server type ('mapserver', 'geoserver', 'qgis').\n        attribution: Attribution text.\n        **kwargs: Additional WMS parameters.\n    \"\"\"\n    layer_id = name or f\"imagewms-{len(self._layers)}\"\n\n    self.call_js_method(\n        \"addImageWMSLayer\",\n        url=url,\n        layers=layers,\n        name=layer_id,\n        format=format,\n        transparent=transparent,\n        serverType=server_type,\n        attribution=attribution,\n        **kwargs,\n    )\n\n    self._layers = {\n        **self._layers,\n        layer_id: {\"id\": layer_id, \"type\": \"imagewms\"},\n    }\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.openlayers.OpenLayersMap.add_marker","title":"<code>add_marker(self, lng, lat, popup=None, color='#3388ff', name=None, **kwargs)</code>","text":"<p>Add a marker to the map.</p> <p>Parameters:</p> Name Type Description Default <code>lng</code> <code>float</code> <p>Marker longitude.</p> required <code>lat</code> <code>float</code> <p>Marker latitude.</p> required <code>popup</code> <code>Optional[str]</code> <p>Popup content (HTML string).</p> <code>None</code> <code>color</code> <code>str</code> <p>Marker color.</p> <code>'#3388ff'</code> <code>name</code> <code>Optional[str]</code> <p>Marker identifier.</p> <code>None</code> <code>**kwargs</code> <p>Additional options.</p> <code>{}</code> Source code in <code>anymap_ts/openlayers.py</code> <pre><code>def add_marker(\n    self,\n    lng: float,\n    lat: float,\n    popup: Optional[str] = None,\n    color: str = \"#3388ff\",\n    name: Optional[str] = None,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a marker to the map.\n\n    Args:\n        lng: Marker longitude.\n        lat: Marker latitude.\n        popup: Popup content (HTML string).\n        color: Marker color.\n        name: Marker identifier.\n        **kwargs: Additional options.\n    \"\"\"\n    marker_id = name or f\"marker-{len(self._layers)}\"\n    self.call_js_method(\n        \"addMarker\",\n        lng,\n        lat,\n        popup=popup,\n        color=color,\n        id=marker_id,\n        **kwargs,\n    )\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.openlayers.OpenLayersMap.add_tile_layer","title":"<code>add_tile_layer(self, url, name=None, attribution='', min_zoom=0, max_zoom=22, opacity=1.0, **kwargs)</code>","text":"<p>Add an XYZ tile layer.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>Tile URL template with {x}, {y}, {z} placeholders.</p> required <code>name</code> <code>Optional[str]</code> <p>Layer name.</p> <code>None</code> <code>attribution</code> <code>str</code> <p>Attribution text.</p> <code>''</code> <code>min_zoom</code> <code>int</code> <p>Minimum zoom level.</p> <code>0</code> <code>max_zoom</code> <code>int</code> <p>Maximum zoom level.</p> <code>22</code> <code>opacity</code> <code>float</code> <p>Layer opacity.</p> <code>1.0</code> <code>**kwargs</code> <p>Additional options.</p> <code>{}</code> Source code in <code>anymap_ts/openlayers.py</code> <pre><code>def add_tile_layer(\n    self,\n    url: str,\n    name: Optional[str] = None,\n    attribution: str = \"\",\n    min_zoom: int = 0,\n    max_zoom: int = 22,\n    opacity: float = 1.0,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add an XYZ tile layer.\n\n    Args:\n        url: Tile URL template with {x}, {y}, {z} placeholders.\n        name: Layer name.\n        attribution: Attribution text.\n        min_zoom: Minimum zoom level.\n        max_zoom: Maximum zoom level.\n        opacity: Layer opacity.\n        **kwargs: Additional options.\n    \"\"\"\n    layer_id = name or f\"tiles-{len(self._layers)}\"\n\n    self.call_js_method(\n        \"addTileLayer\",\n        url,\n        name=layer_id,\n        attribution=attribution,\n        minZoom=min_zoom,\n        maxZoom=max_zoom,\n        opacity=opacity,\n        **kwargs,\n    )\n\n    self._layers = {\n        **self._layers,\n        layer_id: {\"id\": layer_id, \"type\": \"tile\"},\n    }\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.openlayers.OpenLayersMap.add_vector","title":"<code>add_vector(self, data, name=None, style=None, fit_bounds=True, **kwargs)</code>","text":"<p>Add vector data to the map.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>GeoJSON dict, GeoDataFrame, or path to vector file.</p> required <code>name</code> <code>Optional[str]</code> <p>Layer name.</p> <code>None</code> <code>style</code> <code>Optional[Dict]</code> <p>Style configuration dict.</p> <code>None</code> <code>fit_bounds</code> <code>bool</code> <p>Whether to fit map to data bounds.</p> <code>True</code> <code>**kwargs</code> <p>Additional layer options.</p> <code>{}</code> Source code in <code>anymap_ts/openlayers.py</code> <pre><code>def add_vector(\n    self,\n    data: Any,\n    name: Optional[str] = None,\n    style: Optional[Dict] = None,\n    fit_bounds: bool = True,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add vector data to the map.\n\n    Args:\n        data: GeoJSON dict, GeoDataFrame, or path to vector file.\n        name: Layer name.\n        style: Style configuration dict.\n        fit_bounds: Whether to fit map to data bounds.\n        **kwargs: Additional layer options.\n    \"\"\"\n    geojson = to_geojson(data)\n    layer_id = name or f\"vector-{len(self._layers)}\"\n\n    if style is None:\n        style = self._get_default_style(geojson)\n\n    self.call_js_method(\n        \"addGeoJSON\",\n        data=geojson,\n        name=layer_id,\n        style=style,\n        fitBounds=fit_bounds,\n        **kwargs,\n    )\n\n    self._layers = {\n        **self._layers,\n        layer_id: {\"id\": layer_id, \"type\": \"vector\"},\n    }\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.openlayers.OpenLayersMap.add_wms_layer","title":"<code>add_wms_layer(self, url, layers, name=None, format='image/png', transparent=True, server_type=None, attribution='', **kwargs)</code>","text":"<p>Add a WMS tile layer.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>WMS service URL.</p> required <code>layers</code> <code>str</code> <p>Comma-separated layer names.</p> required <code>name</code> <code>Optional[str]</code> <p>Layer name for the map.</p> <code>None</code> <code>format</code> <code>str</code> <p>Image format (default: image/png).</p> <code>'image/png'</code> <code>transparent</code> <code>bool</code> <p>Whether to request transparent images.</p> <code>True</code> <code>server_type</code> <code>Optional[str]</code> <p>Server type ('mapserver', 'geoserver', 'qgis').</p> <code>None</code> <code>attribution</code> <code>str</code> <p>Attribution text.</p> <code>''</code> <code>**kwargs</code> <p>Additional WMS parameters.</p> <code>{}</code> Source code in <code>anymap_ts/openlayers.py</code> <pre><code>def add_wms_layer(\n    self,\n    url: str,\n    layers: str,\n    name: Optional[str] = None,\n    format: str = \"image/png\",\n    transparent: bool = True,\n    server_type: Optional[str] = None,\n    attribution: str = \"\",\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a WMS tile layer.\n\n    Args:\n        url: WMS service URL.\n        layers: Comma-separated layer names.\n        name: Layer name for the map.\n        format: Image format (default: image/png).\n        transparent: Whether to request transparent images.\n        server_type: Server type ('mapserver', 'geoserver', 'qgis').\n        attribution: Attribution text.\n        **kwargs: Additional WMS parameters.\n    \"\"\"\n    layer_id = name or f\"wms-{len(self._layers)}\"\n\n    self.call_js_method(\n        \"addWMSLayer\",\n        url=url,\n        layers=layers,\n        name=layer_id,\n        format=format,\n        transparent=transparent,\n        serverType=server_type,\n        attribution=attribution,\n        **kwargs,\n    )\n\n    self._layers = {\n        **self._layers,\n        layer_id: {\"id\": layer_id, \"type\": \"wms\"},\n    }\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.openlayers.OpenLayersMap.fit_bounds","title":"<code>fit_bounds(self, bounds, padding=50, duration=1000)</code>","text":"<p>Fit the map to bounds.</p> <p>Parameters:</p> Name Type Description Default <code>bounds</code> <code>List[float]</code> <p>Bounds as [minLng, minLat, maxLng, maxLat].</p> required <code>padding</code> <code>int</code> <p>Padding in pixels.</p> <code>50</code> <code>duration</code> <code>int</code> <p>Animation duration in milliseconds.</p> <code>1000</code> Source code in <code>anymap_ts/openlayers.py</code> <pre><code>def fit_bounds(\n    self,\n    bounds: List[float],\n    padding: int = 50,\n    duration: int = 1000,\n) -&gt; None:\n    \"\"\"Fit the map to bounds.\n\n    Args:\n        bounds: Bounds as [minLng, minLat, maxLng, maxLat].\n        padding: Padding in pixels.\n        duration: Animation duration in milliseconds.\n    \"\"\"\n    self.call_js_method(\"fitBounds\", bounds, padding=padding, duration=duration)\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.openlayers.OpenLayersMap.fit_extent","title":"<code>fit_extent(self, extent, padding=50, duration=1000)</code>","text":"<p>Fit the map to an extent (in map projection).</p> <p>Parameters:</p> Name Type Description Default <code>extent</code> <code>List[float]</code> <p>Extent as [minX, minY, maxX, maxY] in map projection.</p> required <code>padding</code> <code>int</code> <p>Padding in pixels.</p> <code>50</code> <code>duration</code> <code>int</code> <p>Animation duration in milliseconds.</p> <code>1000</code> Source code in <code>anymap_ts/openlayers.py</code> <pre><code>def fit_extent(\n    self,\n    extent: List[float],\n    padding: int = 50,\n    duration: int = 1000,\n) -&gt; None:\n    \"\"\"Fit the map to an extent (in map projection).\n\n    Args:\n        extent: Extent as [minX, minY, maxX, maxY] in map projection.\n        padding: Padding in pixels.\n        duration: Animation duration in milliseconds.\n    \"\"\"\n    self.call_js_method(\"fitExtent\", extent, padding=padding, duration=duration)\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.openlayers.OpenLayersMap.fly_to","title":"<code>fly_to(self, lng, lat, zoom=None, duration=2000)</code>","text":"<p>Animate to a new location.</p> <p>Parameters:</p> Name Type Description Default <code>lng</code> <code>float</code> <p>Target longitude.</p> required <code>lat</code> <code>float</code> <p>Target latitude.</p> required <code>zoom</code> <code>Optional[float]</code> <p>Target zoom level (optional).</p> <code>None</code> <code>duration</code> <code>int</code> <p>Animation duration in milliseconds.</p> <code>2000</code> Source code in <code>anymap_ts/openlayers.py</code> <pre><code>def fly_to(\n    self,\n    lng: float,\n    lat: float,\n    zoom: Optional[float] = None,\n    duration: int = 2000,\n) -&gt; None:\n    \"\"\"Animate to a new location.\n\n    Args:\n        lng: Target longitude.\n        lat: Target latitude.\n        zoom: Target zoom level (optional).\n        duration: Animation duration in milliseconds.\n    \"\"\"\n    self.call_js_method(\n        \"flyTo\", lng, lat, zoom=zoom or self.zoom, duration=duration\n    )\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.openlayers.OpenLayersMap.remove_control","title":"<code>remove_control(self, control_type)</code>","text":"<p>Remove a map control.</p> <p>Parameters:</p> Name Type Description Default <code>control_type</code> <code>str</code> <p>Type of control to remove.</p> required Source code in <code>anymap_ts/openlayers.py</code> <pre><code>def remove_control(self, control_type: str) -&gt; None:\n    \"\"\"Remove a map control.\n\n    Args:\n        control_type: Type of control to remove.\n    \"\"\"\n    self.call_js_method(\"removeControl\", control_type)\n    if control_type in self._controls:\n        controls = dict(self._controls)\n        del controls[control_type]\n        self._controls = controls\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.openlayers.OpenLayersMap.remove_layer","title":"<code>remove_layer(self, layer_id)</code>","text":"<p>Remove a layer from the map.</p> <p>Parameters:</p> Name Type Description Default <code>layer_id</code> <code>str</code> <p>Layer identifier to remove.</p> required Source code in <code>anymap_ts/openlayers.py</code> <pre><code>def remove_layer(self, layer_id: str) -&gt; None:\n    \"\"\"Remove a layer from the map.\n\n    Args:\n        layer_id: Layer identifier to remove.\n    \"\"\"\n    if layer_id in self._layers:\n        layers = dict(self._layers)\n        del layers[layer_id]\n        self._layers = layers\n    self.call_js_method(\"removeLayer\", layer_id)\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.openlayers.OpenLayersMap.set_center","title":"<code>set_center(self, lng, lat)</code>","text":"<p>Set the map center.</p> <p>Parameters:</p> Name Type Description Default <code>lng</code> <code>float</code> <p>Longitude.</p> required <code>lat</code> <code>float</code> <p>Latitude.</p> required Source code in <code>anymap_ts/openlayers.py</code> <pre><code>def set_center(self, lng: float, lat: float) -&gt; None:\n    \"\"\"Set the map center.\n\n    Args:\n        lng: Longitude.\n        lat: Latitude.\n    \"\"\"\n    self.center = [lng, lat]\n    self.call_js_method(\"setCenter\", lng, lat)\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.openlayers.OpenLayersMap.set_opacity","title":"<code>set_opacity(self, layer_id, opacity)</code>","text":"<p>Set layer opacity.</p> <p>Parameters:</p> Name Type Description Default <code>layer_id</code> <code>str</code> <p>Layer identifier.</p> required <code>opacity</code> <code>float</code> <p>Opacity value between 0 and 1.</p> required Source code in <code>anymap_ts/openlayers.py</code> <pre><code>def set_opacity(self, layer_id: str, opacity: float) -&gt; None:\n    \"\"\"Set layer opacity.\n\n    Args:\n        layer_id: Layer identifier.\n        opacity: Opacity value between 0 and 1.\n    \"\"\"\n    self.call_js_method(\"setOpacity\", layer_id, opacity)\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.openlayers.OpenLayersMap.set_visibility","title":"<code>set_visibility(self, layer_id, visible)</code>","text":"<p>Set layer visibility.</p> <p>Parameters:</p> Name Type Description Default <code>layer_id</code> <code>str</code> <p>Layer identifier.</p> required <code>visible</code> <code>bool</code> <p>Whether layer should be visible.</p> required Source code in <code>anymap_ts/openlayers.py</code> <pre><code>def set_visibility(self, layer_id: str, visible: bool) -&gt; None:\n    \"\"\"Set layer visibility.\n\n    Args:\n        layer_id: Layer identifier.\n        visible: Whether layer should be visible.\n    \"\"\"\n    self.call_js_method(\"setVisibility\", layer_id, visible)\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.openlayers.OpenLayersMap.set_zoom","title":"<code>set_zoom(self, zoom)</code>","text":"<p>Set the map zoom level.</p> <p>Parameters:</p> Name Type Description Default <code>zoom</code> <code>float</code> <p>Zoom level.</p> required Source code in <code>anymap_ts/openlayers.py</code> <pre><code>def set_zoom(self, zoom: float) -&gt; None:\n    \"\"\"Set the map zoom level.\n\n    Args:\n        zoom: Zoom level.\n    \"\"\"\n    self.zoom = zoom\n    self.call_js_method(\"setZoom\", zoom)\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.potree","title":"<code>potree</code>","text":"<p>Potree point cloud viewer widget implementation.</p> <p>Potree is loaded via CDN since it's a complex Three.js-based viewer. This implementation provides a Python wrapper for point cloud visualization.</p>"},{"location":"anymap_ts/#anymap_ts.potree.PotreeViewer","title":"<code> PotreeViewer            (MapWidget)         </code>","text":"<p>Interactive point cloud viewer using Potree.</p> <p>Potree is a WebGL-based point cloud renderer for large-scale LiDAR datasets. This class provides a Python interface for loading and visualizing point clouds.</p> <p>Note: Potree is loaded from CDN due to its complex Three.js dependencies.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from anymap_ts import PotreeViewer\n&gt;&gt;&gt; viewer = PotreeViewer()\n&gt;&gt;&gt; viewer.load_point_cloud(\"path/to/pointcloud/cloud.js\")\n&gt;&gt;&gt; viewer\n</code></pre> Source code in <code>anymap_ts/potree.py</code> <pre><code>class PotreeViewer(MapWidget):\n    \"\"\"Interactive point cloud viewer using Potree.\n\n    Potree is a WebGL-based point cloud renderer for large-scale LiDAR\n    datasets. This class provides a Python interface for loading and\n    visualizing point clouds.\n\n    Note: Potree is loaded from CDN due to its complex Three.js dependencies.\n\n    Example:\n        &gt;&gt;&gt; from anymap_ts import PotreeViewer\n        &gt;&gt;&gt; viewer = PotreeViewer()\n        &gt;&gt;&gt; viewer.load_point_cloud(\"path/to/pointcloud/cloud.js\")\n        &gt;&gt;&gt; viewer\n    \"\"\"\n\n    # ESM module for frontend\n    _esm = STATIC_DIR / \"potree.js\"\n\n    # Potree-specific traits\n    point_budget = traitlets.Int(1000000).tag(sync=True)\n    point_size = traitlets.Float(1.0).tag(sync=True)\n    fov = traitlets.Float(60.0).tag(sync=True)\n    background = traitlets.Unicode(\"#000000\").tag(sync=True)\n\n    # EDL (Eye Dome Lighting) settings\n    edl_enabled = traitlets.Bool(True).tag(sync=True)\n    edl_radius = traitlets.Float(1.4).tag(sync=True)\n    edl_strength = traitlets.Float(0.4).tag(sync=True)\n\n    # Point clouds\n    point_clouds = traitlets.Dict({}).tag(sync=True)\n\n    # Camera\n    camera_position = traitlets.List([0, 0, 100]).tag(sync=True)\n    camera_target = traitlets.List([0, 0, 0]).tag(sync=True)\n\n    def __init__(\n        self,\n        width: str = \"100%\",\n        height: str = \"600px\",\n        point_budget: int = 1000000,\n        point_size: float = 1.0,\n        fov: float = 60.0,\n        background: str = \"#000000\",\n        edl_enabled: bool = True,\n        **kwargs,\n    ):\n        \"\"\"Initialize a Potree viewer.\n\n        Args:\n            width: Widget width as CSS string.\n            height: Widget height as CSS string.\n            point_budget: Maximum number of points to render.\n            point_size: Default point size.\n            fov: Field of view in degrees.\n            background: Background color (hex string).\n            edl_enabled: Enable Eye Dome Lighting.\n            **kwargs: Additional widget arguments.\n        \"\"\"\n        # Potree doesn't use center/zoom like maps\n        super().__init__(\n            center=[0, 0],\n            zoom=1,\n            width=width,\n            height=height,\n            point_budget=point_budget,\n            point_size=point_size,\n            fov=fov,\n            background=background,\n            edl_enabled=edl_enabled,\n            **kwargs,\n        )\n        self.point_clouds = {}\n\n    # -------------------------------------------------------------------------\n    # Point Cloud Methods\n    # -------------------------------------------------------------------------\n\n    def load_point_cloud(\n        self,\n        url: str,\n        name: Optional[str] = None,\n        visible: bool = True,\n        point_size: Optional[float] = None,\n        point_size_type: str = \"adaptive\",\n        shape: str = \"circle\",\n        color: Optional[str] = None,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Load a point cloud.\n\n        Args:\n            url: URL to point cloud (Potree format or LAZ/LAS via Entwine).\n            name: Point cloud name.\n            visible: Whether point cloud is visible.\n            point_size: Point size (overrides default).\n            point_size_type: 'fixed', 'attenuated', or 'adaptive'.\n            shape: Point shape ('square', 'circle', 'paraboloid').\n            color: Point color (hex string or None for native colors).\n            **kwargs: Additional material options.\n        \"\"\"\n        cloud_id = name or f\"pointcloud_{len(self.point_clouds)}\"\n\n        self.point_clouds = {\n            **self.point_clouds,\n            cloud_id: {\n                \"url\": url,\n                \"name\": cloud_id,\n                \"visible\": visible,\n                \"material\": {\n                    \"size\": point_size or self.point_size,\n                    \"pointSizeType\": point_size_type,\n                    \"shape\": shape,\n                    \"color\": color,\n                    **kwargs,\n                },\n            },\n        }\n\n        self.call_js_method(\n            \"loadPointCloud\",\n            url=url,\n            name=cloud_id,\n            visible=visible,\n            material={\n                \"size\": point_size or self.point_size,\n                \"pointSizeType\": point_size_type,\n                \"shape\": shape,\n                \"color\": color,\n                **kwargs,\n            },\n        )\n\n    def remove_point_cloud(self, name: str) -&gt; None:\n        \"\"\"Remove a point cloud.\n\n        Args:\n            name: Point cloud name to remove.\n        \"\"\"\n        if name in self.point_clouds:\n            clouds = dict(self.point_clouds)\n            del clouds[name]\n            self.point_clouds = clouds\n        self.call_js_method(\"removePointCloud\", name=name)\n\n    def set_point_cloud_visibility(self, name: str, visible: bool) -&gt; None:\n        \"\"\"Set point cloud visibility.\n\n        Args:\n            name: Point cloud name.\n            visible: Whether to show the point cloud.\n        \"\"\"\n        self.call_js_method(\"setPointCloudVisibility\", name=name, visible=visible)\n\n    # -------------------------------------------------------------------------\n    # Camera Methods\n    # -------------------------------------------------------------------------\n\n    def set_camera_position(\n        self,\n        x: float,\n        y: float,\n        z: float,\n    ) -&gt; None:\n        \"\"\"Set camera position.\n\n        Args:\n            x: X coordinate.\n            y: Y coordinate.\n            z: Z coordinate.\n        \"\"\"\n        self.camera_position = [x, y, z]\n        self.call_js_method(\"setCameraPosition\", x=x, y=y, z=z)\n\n    def set_camera_target(\n        self,\n        x: float,\n        y: float,\n        z: float,\n    ) -&gt; None:\n        \"\"\"Set camera target (look-at point).\n\n        Args:\n            x: X coordinate.\n            y: Y coordinate.\n            z: Z coordinate.\n        \"\"\"\n        self.camera_target = [x, y, z]\n        self.call_js_method(\"setCameraTarget\", x=x, y=y, z=z)\n\n    def fly_to_point_cloud(self, name: Optional[str] = None) -&gt; None:\n        \"\"\"Fly to a point cloud or all point clouds.\n\n        Args:\n            name: Point cloud name (None for all).\n        \"\"\"\n        self.call_js_method(\"flyToPointCloud\", name=name)\n\n    def reset_camera(self) -&gt; None:\n        \"\"\"Reset camera to default view.\"\"\"\n        self.call_js_method(\"resetCamera\")\n\n    # -------------------------------------------------------------------------\n    # Visualization Settings\n    # -------------------------------------------------------------------------\n\n    def set_point_budget(self, budget: int) -&gt; None:\n        \"\"\"Set the point budget (max points to render).\n\n        Args:\n            budget: Maximum number of points.\n        \"\"\"\n        self.point_budget = budget\n        self.call_js_method(\"setPointBudget\", budget=budget)\n\n    def set_point_size(self, size: float) -&gt; None:\n        \"\"\"Set default point size.\n\n        Args:\n            size: Point size.\n        \"\"\"\n        self.point_size = size\n        self.call_js_method(\"setPointSize\", size=size)\n\n    def set_fov(self, fov: float) -&gt; None:\n        \"\"\"Set field of view.\n\n        Args:\n            fov: Field of view in degrees.\n        \"\"\"\n        self.fov = fov\n        self.call_js_method(\"setFOV\", fov=fov)\n\n    def set_background(self, color: str) -&gt; None:\n        \"\"\"Set background color.\n\n        Args:\n            color: Background color (hex string).\n        \"\"\"\n        self.background = color\n        self.call_js_method(\"setBackground\", color=color)\n\n    def set_edl(\n        self,\n        enabled: bool = True,\n        radius: float = 1.4,\n        strength: float = 0.4,\n    ) -&gt; None:\n        \"\"\"Configure Eye Dome Lighting.\n\n        Args:\n            enabled: Whether to enable EDL.\n            radius: EDL radius.\n            strength: EDL strength.\n        \"\"\"\n        self.edl_enabled = enabled\n        self.edl_radius = radius\n        self.edl_strength = strength\n        self.call_js_method(\n            \"setEDL\",\n            enabled=enabled,\n            radius=radius,\n            strength=strength,\n        )\n\n    # -------------------------------------------------------------------------\n    # Measurement Tools\n    # -------------------------------------------------------------------------\n\n    def add_measurement_tool(self, tool_type: str = \"distance\") -&gt; None:\n        \"\"\"Add a measurement tool.\n\n        Args:\n            tool_type: Type of measurement ('point', 'distance', 'area', 'angle', 'height', 'profile').\n        \"\"\"\n        self.call_js_method(\"addMeasurementTool\", type=tool_type)\n\n    def clear_measurements(self) -&gt; None:\n        \"\"\"Clear all measurements.\"\"\"\n        self.call_js_method(\"clearMeasurements\")\n\n    # -------------------------------------------------------------------------\n    # Clipping\n    # -------------------------------------------------------------------------\n\n    def add_clipping_volume(\n        self,\n        volume_type: str = \"box\",\n        position: Optional[Tuple[float, float, float]] = None,\n        scale: Optional[Tuple[float, float, float]] = None,\n    ) -&gt; None:\n        \"\"\"Add a clipping volume.\n\n        Args:\n            volume_type: Type of volume ('box', 'polygon', 'plane').\n            position: Volume position (x, y, z).\n            scale: Volume scale (x, y, z).\n        \"\"\"\n        self.call_js_method(\n            \"addClippingVolume\",\n            type=volume_type,\n            position=list(position) if position else None,\n            scale=list(scale) if scale else None,\n        )\n\n    def clear_clipping_volumes(self) -&gt; None:\n        \"\"\"Clear all clipping volumes.\"\"\"\n        self.call_js_method(\"clearClippingVolumes\")\n\n    # -------------------------------------------------------------------------\n    # Annotations\n    # -------------------------------------------------------------------------\n\n    def add_annotation(\n        self,\n        position: Tuple[float, float, float],\n        title: str,\n        description: str = \"\",\n        camera_position: Optional[Tuple[float, float, float]] = None,\n        camera_target: Optional[Tuple[float, float, float]] = None,\n    ) -&gt; None:\n        \"\"\"Add an annotation.\n\n        Args:\n            position: Annotation position (x, y, z).\n            title: Annotation title.\n            description: Annotation description.\n            camera_position: Camera position when focused.\n            camera_target: Camera target when focused.\n        \"\"\"\n        self.call_js_method(\n            \"addAnnotation\",\n            position=list(position),\n            title=title,\n            description=description,\n            cameraPosition=list(camera_position) if camera_position else None,\n            cameraTarget=list(camera_target) if camera_target else None,\n        )\n\n    def clear_annotations(self) -&gt; None:\n        \"\"\"Clear all annotations.\"\"\"\n        self.call_js_method(\"clearAnnotations\")\n\n    # -------------------------------------------------------------------------\n    # HTML Export\n    # -------------------------------------------------------------------------\n\n    def _generate_html_template(self) -&gt; str:\n        \"\"\"Generate standalone HTML for Potree viewer.\"\"\"\n        template_path = Path(__file__).parent / \"templates\" / \"potree.html\"\n\n        if template_path.exists():\n            template = template_path.read_text(encoding=\"utf-8\")\n        else:\n            template = self._get_default_template()\n\n        state = {\n            \"point_budget\": self.point_budget,\n            \"point_size\": self.point_size,\n            \"fov\": self.fov,\n            \"background\": self.background,\n            \"edl_enabled\": self.edl_enabled,\n            \"edl_radius\": self.edl_radius,\n            \"edl_strength\": self.edl_strength,\n            \"point_clouds\": self.point_clouds,\n            \"camera_position\": self.camera_position,\n            \"camera_target\": self.camera_target,\n            \"width\": self.width,\n            \"height\": self.height,\n            \"js_calls\": self._js_calls,\n        }\n\n        template = template.replace(\"{{state}}\", json.dumps(state, indent=2))\n        return template\n\n    def _get_default_template(self) -&gt; str:\n        \"\"\"Get default HTML template.\"\"\"\n        return \"\"\"&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n    &lt;meta charset=\"utf-8\"&gt;\n    &lt;title&gt;Potree Viewer&lt;/title&gt;\n    &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"&gt;\n    &lt;style&gt;\n        * { margin: 0; padding: 0; box-sizing: border-box; }\n        html, body { height: 100%; overflow: hidden; }\n        #potree_render_area { position: absolute; top: 0; bottom: 0; width: 100%; }\n    &lt;/style&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;div id=\"potree_render_area\"&gt;&lt;/div&gt;\n    &lt;script&gt;\n        const state = {{state}};\n        document.getElementById('potree_render_area').innerHTML = '&lt;p style=\"color: white; padding: 20px;\"&gt;Potree viewer requires Potree library. Point clouds: ' + Object.keys(state.point_clouds || {}).length + '&lt;/p&gt;';\n    &lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\"\"\"\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.potree.PotreeViewer.__init__","title":"<code>__init__(self, width='100%', height='600px', point_budget=1000000, point_size=1.0, fov=60.0, background='#000000', edl_enabled=True, **kwargs)</code>  <code>special</code>","text":"<p>Initialize a Potree viewer.</p> <p>Parameters:</p> Name Type Description Default <code>width</code> <code>str</code> <p>Widget width as CSS string.</p> <code>'100%'</code> <code>height</code> <code>str</code> <p>Widget height as CSS string.</p> <code>'600px'</code> <code>point_budget</code> <code>int</code> <p>Maximum number of points to render.</p> <code>1000000</code> <code>point_size</code> <code>float</code> <p>Default point size.</p> <code>1.0</code> <code>fov</code> <code>float</code> <p>Field of view in degrees.</p> <code>60.0</code> <code>background</code> <code>str</code> <p>Background color (hex string).</p> <code>'#000000'</code> <code>edl_enabled</code> <code>bool</code> <p>Enable Eye Dome Lighting.</p> <code>True</code> <code>**kwargs</code> <p>Additional widget arguments.</p> <code>{}</code> Source code in <code>anymap_ts/potree.py</code> <pre><code>def __init__(\n    self,\n    width: str = \"100%\",\n    height: str = \"600px\",\n    point_budget: int = 1000000,\n    point_size: float = 1.0,\n    fov: float = 60.0,\n    background: str = \"#000000\",\n    edl_enabled: bool = True,\n    **kwargs,\n):\n    \"\"\"Initialize a Potree viewer.\n\n    Args:\n        width: Widget width as CSS string.\n        height: Widget height as CSS string.\n        point_budget: Maximum number of points to render.\n        point_size: Default point size.\n        fov: Field of view in degrees.\n        background: Background color (hex string).\n        edl_enabled: Enable Eye Dome Lighting.\n        **kwargs: Additional widget arguments.\n    \"\"\"\n    # Potree doesn't use center/zoom like maps\n    super().__init__(\n        center=[0, 0],\n        zoom=1,\n        width=width,\n        height=height,\n        point_budget=point_budget,\n        point_size=point_size,\n        fov=fov,\n        background=background,\n        edl_enabled=edl_enabled,\n        **kwargs,\n    )\n    self.point_clouds = {}\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.potree.PotreeViewer.add_annotation","title":"<code>add_annotation(self, position, title, description='', camera_position=None, camera_target=None)</code>","text":"<p>Add an annotation.</p> <p>Parameters:</p> Name Type Description Default <code>position</code> <code>Tuple[float, float, float]</code> <p>Annotation position (x, y, z).</p> required <code>title</code> <code>str</code> <p>Annotation title.</p> required <code>description</code> <code>str</code> <p>Annotation description.</p> <code>''</code> <code>camera_position</code> <code>Optional[Tuple[float, float, float]]</code> <p>Camera position when focused.</p> <code>None</code> <code>camera_target</code> <code>Optional[Tuple[float, float, float]]</code> <p>Camera target when focused.</p> <code>None</code> Source code in <code>anymap_ts/potree.py</code> <pre><code>def add_annotation(\n    self,\n    position: Tuple[float, float, float],\n    title: str,\n    description: str = \"\",\n    camera_position: Optional[Tuple[float, float, float]] = None,\n    camera_target: Optional[Tuple[float, float, float]] = None,\n) -&gt; None:\n    \"\"\"Add an annotation.\n\n    Args:\n        position: Annotation position (x, y, z).\n        title: Annotation title.\n        description: Annotation description.\n        camera_position: Camera position when focused.\n        camera_target: Camera target when focused.\n    \"\"\"\n    self.call_js_method(\n        \"addAnnotation\",\n        position=list(position),\n        title=title,\n        description=description,\n        cameraPosition=list(camera_position) if camera_position else None,\n        cameraTarget=list(camera_target) if camera_target else None,\n    )\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.potree.PotreeViewer.add_clipping_volume","title":"<code>add_clipping_volume(self, volume_type='box', position=None, scale=None)</code>","text":"<p>Add a clipping volume.</p> <p>Parameters:</p> Name Type Description Default <code>volume_type</code> <code>str</code> <p>Type of volume ('box', 'polygon', 'plane').</p> <code>'box'</code> <code>position</code> <code>Optional[Tuple[float, float, float]]</code> <p>Volume position (x, y, z).</p> <code>None</code> <code>scale</code> <code>Optional[Tuple[float, float, float]]</code> <p>Volume scale (x, y, z).</p> <code>None</code> Source code in <code>anymap_ts/potree.py</code> <pre><code>def add_clipping_volume(\n    self,\n    volume_type: str = \"box\",\n    position: Optional[Tuple[float, float, float]] = None,\n    scale: Optional[Tuple[float, float, float]] = None,\n) -&gt; None:\n    \"\"\"Add a clipping volume.\n\n    Args:\n        volume_type: Type of volume ('box', 'polygon', 'plane').\n        position: Volume position (x, y, z).\n        scale: Volume scale (x, y, z).\n    \"\"\"\n    self.call_js_method(\n        \"addClippingVolume\",\n        type=volume_type,\n        position=list(position) if position else None,\n        scale=list(scale) if scale else None,\n    )\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.potree.PotreeViewer.add_measurement_tool","title":"<code>add_measurement_tool(self, tool_type='distance')</code>","text":"<p>Add a measurement tool.</p> <p>Parameters:</p> Name Type Description Default <code>tool_type</code> <code>str</code> <p>Type of measurement ('point', 'distance', 'area', 'angle', 'height', 'profile').</p> <code>'distance'</code> Source code in <code>anymap_ts/potree.py</code> <pre><code>def add_measurement_tool(self, tool_type: str = \"distance\") -&gt; None:\n    \"\"\"Add a measurement tool.\n\n    Args:\n        tool_type: Type of measurement ('point', 'distance', 'area', 'angle', 'height', 'profile').\n    \"\"\"\n    self.call_js_method(\"addMeasurementTool\", type=tool_type)\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.potree.PotreeViewer.clear_annotations","title":"<code>clear_annotations(self)</code>","text":"<p>Clear all annotations.</p> Source code in <code>anymap_ts/potree.py</code> <pre><code>def clear_annotations(self) -&gt; None:\n    \"\"\"Clear all annotations.\"\"\"\n    self.call_js_method(\"clearAnnotations\")\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.potree.PotreeViewer.clear_clipping_volumes","title":"<code>clear_clipping_volumes(self)</code>","text":"<p>Clear all clipping volumes.</p> Source code in <code>anymap_ts/potree.py</code> <pre><code>def clear_clipping_volumes(self) -&gt; None:\n    \"\"\"Clear all clipping volumes.\"\"\"\n    self.call_js_method(\"clearClippingVolumes\")\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.potree.PotreeViewer.clear_measurements","title":"<code>clear_measurements(self)</code>","text":"<p>Clear all measurements.</p> Source code in <code>anymap_ts/potree.py</code> <pre><code>def clear_measurements(self) -&gt; None:\n    \"\"\"Clear all measurements.\"\"\"\n    self.call_js_method(\"clearMeasurements\")\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.potree.PotreeViewer.fly_to_point_cloud","title":"<code>fly_to_point_cloud(self, name=None)</code>","text":"<p>Fly to a point cloud or all point clouds.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>Optional[str]</code> <p>Point cloud name (None for all).</p> <code>None</code> Source code in <code>anymap_ts/potree.py</code> <pre><code>def fly_to_point_cloud(self, name: Optional[str] = None) -&gt; None:\n    \"\"\"Fly to a point cloud or all point clouds.\n\n    Args:\n        name: Point cloud name (None for all).\n    \"\"\"\n    self.call_js_method(\"flyToPointCloud\", name=name)\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.potree.PotreeViewer.load_point_cloud","title":"<code>load_point_cloud(self, url, name=None, visible=True, point_size=None, point_size_type='adaptive', shape='circle', color=None, **kwargs)</code>","text":"<p>Load a point cloud.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>URL to point cloud (Potree format or LAZ/LAS via Entwine).</p> required <code>name</code> <code>Optional[str]</code> <p>Point cloud name.</p> <code>None</code> <code>visible</code> <code>bool</code> <p>Whether point cloud is visible.</p> <code>True</code> <code>point_size</code> <code>Optional[float]</code> <p>Point size (overrides default).</p> <code>None</code> <code>point_size_type</code> <code>str</code> <p>'fixed', 'attenuated', or 'adaptive'.</p> <code>'adaptive'</code> <code>shape</code> <code>str</code> <p>Point shape ('square', 'circle', 'paraboloid').</p> <code>'circle'</code> <code>color</code> <code>Optional[str]</code> <p>Point color (hex string or None for native colors).</p> <code>None</code> <code>**kwargs</code> <p>Additional material options.</p> <code>{}</code> Source code in <code>anymap_ts/potree.py</code> <pre><code>def load_point_cloud(\n    self,\n    url: str,\n    name: Optional[str] = None,\n    visible: bool = True,\n    point_size: Optional[float] = None,\n    point_size_type: str = \"adaptive\",\n    shape: str = \"circle\",\n    color: Optional[str] = None,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Load a point cloud.\n\n    Args:\n        url: URL to point cloud (Potree format or LAZ/LAS via Entwine).\n        name: Point cloud name.\n        visible: Whether point cloud is visible.\n        point_size: Point size (overrides default).\n        point_size_type: 'fixed', 'attenuated', or 'adaptive'.\n        shape: Point shape ('square', 'circle', 'paraboloid').\n        color: Point color (hex string or None for native colors).\n        **kwargs: Additional material options.\n    \"\"\"\n    cloud_id = name or f\"pointcloud_{len(self.point_clouds)}\"\n\n    self.point_clouds = {\n        **self.point_clouds,\n        cloud_id: {\n            \"url\": url,\n            \"name\": cloud_id,\n            \"visible\": visible,\n            \"material\": {\n                \"size\": point_size or self.point_size,\n                \"pointSizeType\": point_size_type,\n                \"shape\": shape,\n                \"color\": color,\n                **kwargs,\n            },\n        },\n    }\n\n    self.call_js_method(\n        \"loadPointCloud\",\n        url=url,\n        name=cloud_id,\n        visible=visible,\n        material={\n            \"size\": point_size or self.point_size,\n            \"pointSizeType\": point_size_type,\n            \"shape\": shape,\n            \"color\": color,\n            **kwargs,\n        },\n    )\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.potree.PotreeViewer.remove_point_cloud","title":"<code>remove_point_cloud(self, name)</code>","text":"<p>Remove a point cloud.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Point cloud name to remove.</p> required Source code in <code>anymap_ts/potree.py</code> <pre><code>def remove_point_cloud(self, name: str) -&gt; None:\n    \"\"\"Remove a point cloud.\n\n    Args:\n        name: Point cloud name to remove.\n    \"\"\"\n    if name in self.point_clouds:\n        clouds = dict(self.point_clouds)\n        del clouds[name]\n        self.point_clouds = clouds\n    self.call_js_method(\"removePointCloud\", name=name)\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.potree.PotreeViewer.reset_camera","title":"<code>reset_camera(self)</code>","text":"<p>Reset camera to default view.</p> Source code in <code>anymap_ts/potree.py</code> <pre><code>def reset_camera(self) -&gt; None:\n    \"\"\"Reset camera to default view.\"\"\"\n    self.call_js_method(\"resetCamera\")\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.potree.PotreeViewer.set_background","title":"<code>set_background(self, color)</code>","text":"<p>Set background color.</p> <p>Parameters:</p> Name Type Description Default <code>color</code> <code>str</code> <p>Background color (hex string).</p> required Source code in <code>anymap_ts/potree.py</code> <pre><code>def set_background(self, color: str) -&gt; None:\n    \"\"\"Set background color.\n\n    Args:\n        color: Background color (hex string).\n    \"\"\"\n    self.background = color\n    self.call_js_method(\"setBackground\", color=color)\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.potree.PotreeViewer.set_camera_position","title":"<code>set_camera_position(self, x, y, z)</code>","text":"<p>Set camera position.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>float</code> <p>X coordinate.</p> required <code>y</code> <code>float</code> <p>Y coordinate.</p> required <code>z</code> <code>float</code> <p>Z coordinate.</p> required Source code in <code>anymap_ts/potree.py</code> <pre><code>def set_camera_position(\n    self,\n    x: float,\n    y: float,\n    z: float,\n) -&gt; None:\n    \"\"\"Set camera position.\n\n    Args:\n        x: X coordinate.\n        y: Y coordinate.\n        z: Z coordinate.\n    \"\"\"\n    self.camera_position = [x, y, z]\n    self.call_js_method(\"setCameraPosition\", x=x, y=y, z=z)\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.potree.PotreeViewer.set_camera_target","title":"<code>set_camera_target(self, x, y, z)</code>","text":"<p>Set camera target (look-at point).</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>float</code> <p>X coordinate.</p> required <code>y</code> <code>float</code> <p>Y coordinate.</p> required <code>z</code> <code>float</code> <p>Z coordinate.</p> required Source code in <code>anymap_ts/potree.py</code> <pre><code>def set_camera_target(\n    self,\n    x: float,\n    y: float,\n    z: float,\n) -&gt; None:\n    \"\"\"Set camera target (look-at point).\n\n    Args:\n        x: X coordinate.\n        y: Y coordinate.\n        z: Z coordinate.\n    \"\"\"\n    self.camera_target = [x, y, z]\n    self.call_js_method(\"setCameraTarget\", x=x, y=y, z=z)\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.potree.PotreeViewer.set_edl","title":"<code>set_edl(self, enabled=True, radius=1.4, strength=0.4)</code>","text":"<p>Configure Eye Dome Lighting.</p> <p>Parameters:</p> Name Type Description Default <code>enabled</code> <code>bool</code> <p>Whether to enable EDL.</p> <code>True</code> <code>radius</code> <code>float</code> <p>EDL radius.</p> <code>1.4</code> <code>strength</code> <code>float</code> <p>EDL strength.</p> <code>0.4</code> Source code in <code>anymap_ts/potree.py</code> <pre><code>def set_edl(\n    self,\n    enabled: bool = True,\n    radius: float = 1.4,\n    strength: float = 0.4,\n) -&gt; None:\n    \"\"\"Configure Eye Dome Lighting.\n\n    Args:\n        enabled: Whether to enable EDL.\n        radius: EDL radius.\n        strength: EDL strength.\n    \"\"\"\n    self.edl_enabled = enabled\n    self.edl_radius = radius\n    self.edl_strength = strength\n    self.call_js_method(\n        \"setEDL\",\n        enabled=enabled,\n        radius=radius,\n        strength=strength,\n    )\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.potree.PotreeViewer.set_fov","title":"<code>set_fov(self, fov)</code>","text":"<p>Set field of view.</p> <p>Parameters:</p> Name Type Description Default <code>fov</code> <code>float</code> <p>Field of view in degrees.</p> required Source code in <code>anymap_ts/potree.py</code> <pre><code>def set_fov(self, fov: float) -&gt; None:\n    \"\"\"Set field of view.\n\n    Args:\n        fov: Field of view in degrees.\n    \"\"\"\n    self.fov = fov\n    self.call_js_method(\"setFOV\", fov=fov)\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.potree.PotreeViewer.set_point_budget","title":"<code>set_point_budget(self, budget)</code>","text":"<p>Set the point budget (max points to render).</p> <p>Parameters:</p> Name Type Description Default <code>budget</code> <code>int</code> <p>Maximum number of points.</p> required Source code in <code>anymap_ts/potree.py</code> <pre><code>def set_point_budget(self, budget: int) -&gt; None:\n    \"\"\"Set the point budget (max points to render).\n\n    Args:\n        budget: Maximum number of points.\n    \"\"\"\n    self.point_budget = budget\n    self.call_js_method(\"setPointBudget\", budget=budget)\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.potree.PotreeViewer.set_point_cloud_visibility","title":"<code>set_point_cloud_visibility(self, name, visible)</code>","text":"<p>Set point cloud visibility.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Point cloud name.</p> required <code>visible</code> <code>bool</code> <p>Whether to show the point cloud.</p> required Source code in <code>anymap_ts/potree.py</code> <pre><code>def set_point_cloud_visibility(self, name: str, visible: bool) -&gt; None:\n    \"\"\"Set point cloud visibility.\n\n    Args:\n        name: Point cloud name.\n        visible: Whether to show the point cloud.\n    \"\"\"\n    self.call_js_method(\"setPointCloudVisibility\", name=name, visible=visible)\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.potree.PotreeViewer.set_point_size","title":"<code>set_point_size(self, size)</code>","text":"<p>Set default point size.</p> <p>Parameters:</p> Name Type Description Default <code>size</code> <code>float</code> <p>Point size.</p> required Source code in <code>anymap_ts/potree.py</code> <pre><code>def set_point_size(self, size: float) -&gt; None:\n    \"\"\"Set default point size.\n\n    Args:\n        size: Point size.\n    \"\"\"\n    self.point_size = size\n    self.call_js_method(\"setPointSize\", size=size)\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.utils","title":"<code>utils</code>","text":"<p>Utility functions for anymap-ts.</p>"},{"location":"anymap_ts/#anymap_ts.utils.build_step_expression","title":"<code>build_step_expression(column, breaks, colors)</code>","text":"<p>Build a MapLibre step expression for choropleth styling.</p> <p>Parameters:</p> Name Type Description Default <code>column</code> <code>str</code> <p>Property name to style by.</p> required <code>breaks</code> <code>List[float]</code> <p>Break values (k+1 values for k classes).</p> required <code>colors</code> <code>List[str]</code> <p>List of k colors for each class.</p> required <p>Returns:</p> Type Description <code>List</code> <p>MapLibre step expression as a list.</p> Source code in <code>anymap_ts/utils.py</code> <pre><code>def build_step_expression(column: str, breaks: List[float], colors: List[str]) -&gt; List:\n    \"\"\"Build a MapLibre step expression for choropleth styling.\n\n    Args:\n        column: Property name to style by.\n        breaks: Break values (k+1 values for k classes).\n        colors: List of k colors for each class.\n\n    Returns:\n        MapLibre step expression as a list.\n    \"\"\"\n    # MapLibre step expression format:\n    # [\"step\", [\"get\", \"property\"], color0, break1, color1, break2, color2, ...]\n    expr = [\"step\", [\"get\", column], colors[0]]\n\n    # Add breaks and colors (skip the first break which is the minimum)\n    for i in range(1, len(breaks) - 1):\n        expr.append(breaks[i])\n        expr.append(colors[i])\n\n    # Handle the last class\n    if len(colors) &gt; len(breaks) - 1:\n        expr.append(breaks[-1])\n        expr.append(colors[-1])\n\n    return expr\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.utils.compute_breaks","title":"<code>compute_breaks(values, classification, k, manual_breaks=None)</code>","text":"<p>Compute classification breaks for choropleth maps.</p> <p>Parameters:</p> Name Type Description Default <code>values</code> <code>List[float]</code> <p>List of numeric values to classify.</p> required <code>classification</code> <code>str</code> <p>Classification method ('quantile', 'equal_interval', 'natural_breaks', 'manual').</p> required <code>k</code> <code>int</code> <p>Number of classes.</p> required <code>manual_breaks</code> <code>Optional[List[float]]</code> <p>Custom break values for 'manual' classification.</p> <code>None</code> <p>Returns:</p> Type Description <code>List[float]</code> <p>List of break values (k+1 values defining class boundaries).</p> <p>Exceptions:</p> Type Description <code>ValueError</code> <p>If classification method is invalid or breaks are incorrect.</p> Source code in <code>anymap_ts/utils.py</code> <pre><code>def compute_breaks(\n    values: List[float],\n    classification: str,\n    k: int,\n    manual_breaks: Optional[List[float]] = None,\n) -&gt; List[float]:\n    \"\"\"Compute classification breaks for choropleth maps.\n\n    Args:\n        values: List of numeric values to classify.\n        classification: Classification method ('quantile', 'equal_interval',\n            'natural_breaks', 'manual').\n        k: Number of classes.\n        manual_breaks: Custom break values for 'manual' classification.\n\n    Returns:\n        List of break values (k+1 values defining class boundaries).\n\n    Raises:\n        ValueError: If classification method is invalid or breaks are incorrect.\n    \"\"\"\n    if classification == \"manual\":\n        if manual_breaks is None:\n            raise ValueError(\"manual_breaks required for 'manual' classification\")\n        if len(manual_breaks) != k + 1:\n            raise ValueError(f\"manual_breaks must have {k + 1} values for {k} classes\")\n        return manual_breaks\n\n    sorted_values = sorted(values)\n    min_val = sorted_values[0]\n    max_val = sorted_values[-1]\n\n    if classification == \"quantile\":\n        # Equal number of features per class\n        breaks = [min_val]\n        for i in range(1, k):\n            idx = int(len(sorted_values) * i / k)\n            breaks.append(sorted_values[idx])\n        breaks.append(max_val)\n        return breaks\n\n    elif classification == \"equal_interval\":\n        # Equal value ranges\n        interval = (max_val - min_val) / k\n        breaks = [min_val + i * interval for i in range(k + 1)]\n        return breaks\n\n    elif classification == \"natural_breaks\":\n        # Jenks natural breaks - requires jenkspy\n        try:\n            import jenkspy\n\n            breaks = jenkspy.jenks_breaks(values, n_classes=k)\n            return breaks\n        except ImportError:\n            raise ImportError(\n                \"jenkspy is required for natural_breaks classification. \"\n                \"Install with: pip install jenkspy\"\n            )\n\n    else:\n        raise ValueError(\n            f\"Unknown classification method '{classification}'. \"\n            \"Options: 'quantile', 'equal_interval', 'natural_breaks', 'manual'\"\n        )\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.utils.fetch_geojson","title":"<code>fetch_geojson(url)</code>","text":"<p>Fetch GeoJSON data from a URL.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>URL to fetch GeoJSON from</p> required <p>Returns:</p> Type Description <code>Dict</code> <p>GeoJSON dict</p> <p>Exceptions:</p> Type Description <code>ValueError</code> <p>If the URL cannot be fetched or parsed</p> Source code in <code>anymap_ts/utils.py</code> <pre><code>def fetch_geojson(url: str) -&gt; Dict:\n    \"\"\"Fetch GeoJSON data from a URL.\n\n    Args:\n        url: URL to fetch GeoJSON from\n\n    Returns:\n        GeoJSON dict\n\n    Raises:\n        ValueError: If the URL cannot be fetched or parsed\n    \"\"\"\n    try:\n        with urlopen(url, timeout=30) as response:\n            charset = response.headers.get_content_charset() or \"utf-8\"\n            data = response.read().decode(charset)\n            return json.loads(data)\n    except URLError as e:\n        raise ValueError(f\"Failed to fetch GeoJSON from URL: {e}\") from e\n    except UnicodeDecodeError as e:\n        raise ValueError(f\"Failed to decode response as UTF-8: {e}\") from e\n    except json.JSONDecodeError as e:\n        raise ValueError(f\"Invalid JSON at URL: {e}\") from e\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.utils.get_bounds","title":"<code>get_bounds(data)</code>","text":"<p>Calculate bounds from GeoJSON or GeoDataFrame.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>GeoJSON dict or GeoDataFrame</p> required <p>Returns:</p> Type Description <code>Optional[List[float]]</code> <p>[west, south, east, north] bounds or None</p> Source code in <code>anymap_ts/utils.py</code> <pre><code>def get_bounds(data: Any) -&gt; Optional[List[float]]:\n    \"\"\"Calculate bounds from GeoJSON or GeoDataFrame.\n\n    Args:\n        data: GeoJSON dict or GeoDataFrame\n\n    Returns:\n        [west, south, east, north] bounds or None\n    \"\"\"\n    if HAS_GEOPANDAS and isinstance(data, gpd.GeoDataFrame):\n        bounds = data.total_bounds\n        return [bounds[0], bounds[1], bounds[2], bounds[3]]\n\n    if isinstance(data, dict):\n        if HAS_SHAPELY:\n            return _get_geojson_bounds_shapely(data)\n        return _get_geojson_bounds_simple(data)\n\n    return None\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.utils.get_choropleth_colors","title":"<code>get_choropleth_colors(cmap, k)</code>","text":"<p>Get colors for a choropleth map using matplotlib colormaps.</p> <p>Uses matplotlib colormaps when available, falling back to a small set of built-in colormaps if matplotlib is not installed.</p> <p>Parameters:</p> Name Type Description Default <code>cmap</code> <code>str</code> <p>Colormap name. Any matplotlib colormap is supported when matplotlib is installed. Common options include: - Sequential: 'viridis', 'plasma', 'inferno', 'magma', 'cividis',   'Blues', 'Greens', 'Reds', 'Oranges', 'Purples', 'Greys' - Diverging: 'RdBu', 'RdYlGn', 'RdYlBu', 'Spectral', 'coolwarm',   'bwr', 'seismic' - Qualitative: 'Set1', 'Set2', 'Set3', 'Paired', 'tab10', 'tab20' - Perceptually uniform: 'viridis', 'plasma', 'inferno', 'magma'</p> required <code>k</code> <code>int</code> <p>Number of classes/colors to generate.</p> required <p>Returns:</p> Type Description <code>List[str]</code> <p>List of k hex color strings.</p> <p>Exceptions:</p> Type Description <code>ValueError</code> <p>If colormap is not found.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; colors = get_choropleth_colors('viridis', 5)\n&gt;&gt;&gt; colors\n['#440154', '#3b528b', '#21918c', '#5ec962', '#fde725']\n</code></pre> Source code in <code>anymap_ts/utils.py</code> <pre><code>def get_choropleth_colors(cmap: str, k: int) -&gt; List[str]:\n    \"\"\"Get colors for a choropleth map using matplotlib colormaps.\n\n    Uses matplotlib colormaps when available, falling back to a small\n    set of built-in colormaps if matplotlib is not installed.\n\n    Args:\n        cmap: Colormap name. Any matplotlib colormap is supported when\n            matplotlib is installed. Common options include:\n            - Sequential: 'viridis', 'plasma', 'inferno', 'magma', 'cividis',\n              'Blues', 'Greens', 'Reds', 'Oranges', 'Purples', 'Greys'\n            - Diverging: 'RdBu', 'RdYlGn', 'RdYlBu', 'Spectral', 'coolwarm',\n              'bwr', 'seismic'\n            - Qualitative: 'Set1', 'Set2', 'Set3', 'Paired', 'tab10', 'tab20'\n            - Perceptually uniform: 'viridis', 'plasma', 'inferno', 'magma'\n        k: Number of classes/colors to generate.\n\n    Returns:\n        List of k hex color strings.\n\n    Raises:\n        ValueError: If colormap is not found.\n\n    Example:\n        &gt;&gt;&gt; colors = get_choropleth_colors('viridis', 5)\n        &gt;&gt;&gt; colors\n        ['#440154', '#3b528b', '#21918c', '#5ec962', '#fde725']\n    \"\"\"\n    if HAS_MATPLOTLIB:\n        try:\n            # Get the colormap from matplotlib\n            colormap = plt.get_cmap(cmap)\n\n            # Sample k colors evenly from the colormap\n            colors = []\n            for i in range(k):\n                # Sample at evenly spaced points\n                position = i / (k - 1) if k &gt; 1 else 0.5\n                rgba = colormap(position)\n                colors.append(_rgb_to_hex(rgba))\n\n            return colors\n\n        except ValueError:\n            raise ValueError(\n                f\"Unknown colormap '{cmap}'. See matplotlib colormap documentation \"\n                \"for available options: https://matplotlib.org/stable/gallery/color/colormap_reference.html\"\n            )\n    else:\n        # Fallback to built-in colormaps\n        if cmap not in _FALLBACK_COLORMAPS:\n            available = \", \".join(sorted(_FALLBACK_COLORMAPS.keys()))\n            raise ValueError(\n                f\"Colormap '{cmap}' not available. Without matplotlib, only these \"\n                f\"colormaps are available: {available}. \"\n                \"Install matplotlib for full colormap support: pip install matplotlib\"\n            )\n\n        full_colors = _FALLBACK_COLORMAPS[cmap]\n\n        if k &lt;= len(full_colors):\n            # Sample evenly from the colormap\n            step = len(full_colors) / k\n            indices = [int(i * step) for i in range(k)]\n            return [full_colors[i] for i in indices]\n        else:\n            # Interpolate if we need more colors than available\n            # For simplicity, just repeat the last colors\n            colors = full_colors[:]\n            while len(colors) &lt; k:\n                colors.append(colors[-1])\n            return colors[:k]\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.utils.get_default_paint","title":"<code>get_default_paint(layer_type)</code>","text":"<p>Get default paint properties for a layer type.</p> <p>Parameters:</p> Name Type Description Default <code>layer_type</code> <code>str</code> <p>MapLibre layer type</p> required <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Paint properties dict</p> Source code in <code>anymap_ts/utils.py</code> <pre><code>def get_default_paint(layer_type: str) -&gt; Dict[str, Any]:\n    \"\"\"Get default paint properties for a layer type.\n\n    Args:\n        layer_type: MapLibre layer type\n\n    Returns:\n        Paint properties dict\n    \"\"\"\n    defaults = {\n        \"circle\": {\n            \"circle-radius\": 5,\n            \"circle-color\": \"#3388ff\",\n            \"circle-opacity\": 0.8,\n            \"circle-stroke-width\": 1,\n            \"circle-stroke-color\": \"#ffffff\",\n        },\n        \"line\": {\n            \"line-color\": \"#3388ff\",\n            \"line-width\": 2,\n            \"line-opacity\": 0.8,\n        },\n        \"fill\": {\n            \"fill-color\": \"#3388ff\",\n            \"fill-opacity\": 0.5,\n            \"fill-outline-color\": \"#0000ff\",\n        },\n        \"fill-extrusion\": {\n            \"fill-extrusion-color\": \"#3388ff\",\n            \"fill-extrusion-opacity\": 0.6,\n            \"fill-extrusion-height\": 100,\n        },\n        \"raster\": {\n            \"raster-opacity\": 1,\n        },\n        \"heatmap\": {\n            \"heatmap-opacity\": 0.8,\n        },\n    }\n    return defaults.get(layer_type, {})\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.utils.infer_layer_type","title":"<code>infer_layer_type(geojson)</code>","text":"<p>Infer MapLibre layer type from GeoJSON geometry.</p> <p>Parameters:</p> Name Type Description Default <code>geojson</code> <code>Dict</code> <p>GeoJSON dict</p> required <p>Returns:</p> Type Description <code>str</code> <p>Layer type ('circle', 'line', 'fill')</p> Source code in <code>anymap_ts/utils.py</code> <pre><code>def infer_layer_type(geojson: Dict) -&gt; str:\n    \"\"\"Infer MapLibre layer type from GeoJSON geometry.\n\n    Args:\n        geojson: GeoJSON dict\n\n    Returns:\n        Layer type ('circle', 'line', 'fill')\n    \"\"\"\n    geometry_type = None\n\n    if geojson.get(\"type\") == \"FeatureCollection\":\n        features = geojson.get(\"features\", [])\n        if features:\n            geometry_type = features[0].get(\"geometry\", {}).get(\"type\")\n    elif geojson.get(\"type\") == \"Feature\":\n        geometry_type = geojson.get(\"geometry\", {}).get(\"type\")\n    else:\n        geometry_type = geojson.get(\"type\")\n\n    type_map = {\n        \"Point\": \"circle\",\n        \"MultiPoint\": \"circle\",\n        \"LineString\": \"line\",\n        \"MultiLineString\": \"line\",\n        \"Polygon\": \"fill\",\n        \"MultiPolygon\": \"fill\",\n        \"GeometryCollection\": \"fill\",\n    }\n\n    return type_map.get(geometry_type, \"circle\")\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.utils.to_geojson","title":"<code>to_geojson(data)</code>","text":"<p>Convert various data formats to GeoJSON.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>GeoJSON dict, GeoDataFrame, file path, or URL</p> required <p>Returns:</p> Type Description <code>Dict</code> <p>GeoJSON dict</p> <p>Exceptions:</p> Type Description <code>ValueError</code> <p>If data cannot be converted</p> <code>ImportError</code> <p>If geopandas is required but not installed</p> Source code in <code>anymap_ts/utils.py</code> <pre><code>def to_geojson(data: Any) -&gt; Dict:\n    \"\"\"Convert various data formats to GeoJSON.\n\n    Args:\n        data: GeoJSON dict, GeoDataFrame, file path, or URL\n\n    Returns:\n        GeoJSON dict\n\n    Raises:\n        ValueError: If data cannot be converted\n        ImportError: If geopandas is required but not installed\n    \"\"\"\n    # Already a dict (GeoJSON)\n    if isinstance(data, dict):\n        return data\n\n    # GeoDataFrame\n    if HAS_GEOPANDAS and isinstance(data, gpd.GeoDataFrame):\n        return json.loads(data.to_json())\n\n    # File path or URL\n    if isinstance(data, (str, Path)):\n        path_str = str(data)\n\n        # If it's a URL, return as-is (will be handled by JS)\n        if path_str.startswith((\"http://\", \"https://\")):\n            return {\"type\": \"url\", \"url\": path_str}\n\n        # Read file with geopandas\n        if not HAS_GEOPANDAS:\n            raise ImportError(\n                \"geopandas is required to read vector files. \"\n                \"Install with: pip install anymap-ts[vector]\"\n            )\n\n        gdf = gpd.read_file(path_str)\n        return json.loads(gdf.to_json())\n\n    # Has __geo_interface__ (shapely geometry, etc.)\n    if hasattr(data, \"__geo_interface__\"):\n        geo = data.__geo_interface__\n        if geo.get(\"type\") in (\n            \"Point\",\n            \"LineString\",\n            \"Polygon\",\n            \"MultiPoint\",\n            \"MultiLineString\",\n            \"MultiPolygon\",\n            \"GeometryCollection\",\n        ):\n            return {\"type\": \"Feature\", \"geometry\": geo, \"properties\": {}}\n        return geo\n\n    raise ValueError(f\"Cannot convert {type(data)} to GeoJSON\")\n</code></pre>"},{"location":"base/","title":"base module","text":"<p>Base MapWidget class for all map implementations.</p>"},{"location":"base/#anymap_ts.base.MapWidget","title":"<code> MapWidget            (AnyWidget)         </code>","text":"<p>Base class for interactive map widgets.</p> <p>This class provides the core functionality for Python-JavaScript communication using anywidget's traitlet synchronization system.</p> Source code in <code>anymap_ts/base.py</code> <pre><code>class MapWidget(anywidget.AnyWidget):\n    \"\"\"Base class for interactive map widgets.\n\n    This class provides the core functionality for Python-JavaScript communication\n    using anywidget's traitlet synchronization system.\n    \"\"\"\n\n    # Synchronized traits for map state\n    center = traitlets.List([0.0, 0.0]).tag(sync=True)\n    zoom = traitlets.Float(2.0).tag(sync=True)\n    width = traitlets.Unicode(\"100%\").tag(sync=True)\n    height = traitlets.Unicode(\"400px\").tag(sync=True)\n    style = traitlets.Union([traitlets.Unicode(), traitlets.Dict()]).tag(sync=True)\n    max_pitch = traitlets.Float(85.0).tag(sync=True)\n\n    # JavaScript method call queue\n    _js_calls = traitlets.List([]).tag(sync=True)\n    _js_method_counter = traitlets.Int(0)\n\n    # Events from JavaScript\n    _js_events = traitlets.List([]).tag(sync=True)\n\n    # State persistence for layers, sources, and controls\n    _layers = traitlets.Dict({}).tag(sync=True)\n    _sources = traitlets.Dict({}).tag(sync=True)\n    _controls = traitlets.Dict({}).tag(sync=True)\n\n    # Interaction state\n    clicked = traitlets.Dict({}).tag(sync=True)\n    current_bounds = traitlets.List([]).tag(sync=True)\n    current_center = traitlets.List([]).tag(sync=True)\n    current_zoom = traitlets.Float(0.0).tag(sync=True)\n\n    # Drawing data\n    _draw_data = traitlets.Dict({}).tag(sync=True)\n\n    # Queried features (set by JS query methods)\n    _queried_features = traitlets.Dict({}).tag(sync=True)\n\n    def __init__(self, **kwargs):\n        \"\"\"Initialize the MapWidget.\n\n        Args:\n            **kwargs: Additional widget arguments\n        \"\"\"\n        super().__init__(**kwargs)\n        self._event_handlers: Dict[str, List[Callable]] = {}\n        self.observe(self._handle_js_events, names=[\"_js_events\"])\n\n    def _handle_js_events(self, change: Dict[str, Any]) -&gt; None:\n        \"\"\"Process events received from JavaScript.\n\n        Args:\n            change: Traitlet change dict\n        \"\"\"\n        events = change.get(\"new\", [])\n        for event in events:\n            event_type = event.get(\"type\")\n            if event_type in self._event_handlers:\n                for handler in self._event_handlers[event_type]:\n                    try:\n                        handler(event.get(\"data\"))\n                    except Exception as e:\n                        print(f\"Error in event handler for {event_type}: {e}\")\n        # Clear processed events\n        self._js_events = []\n\n    def call_js_method(self, method: str, *args, **kwargs) -&gt; None:\n        \"\"\"Queue a JavaScript method call.\n\n        Args:\n            method: Name of the JavaScript method to call\n            *args: Positional arguments for the method\n            **kwargs: Keyword arguments for the method\n        \"\"\"\n        self._js_method_counter += 1\n        call = {\n            \"id\": self._js_method_counter,\n            \"method\": method,\n            \"args\": list(args),\n            \"kwargs\": kwargs,\n        }\n        self._js_calls = self._js_calls + [call]\n\n    def on_map_event(self, event_type: str, handler: Callable) -&gt; None:\n        \"\"\"Register an event handler.\n\n        Args:\n            event_type: Type of event (e.g., 'click', 'moveend')\n            handler: Callback function to handle the event\n        \"\"\"\n        if event_type not in self._event_handlers:\n            self._event_handlers[event_type] = []\n        self._event_handlers[event_type].append(handler)\n\n    def off_map_event(\n        self, event_type: str, handler: Optional[Callable] = None\n    ) -&gt; None:\n        \"\"\"Unregister an event handler.\n\n        Args:\n            event_type: Type of event\n            handler: Specific handler to remove. If None, removes all handlers.\n        \"\"\"\n        if event_type in self._event_handlers:\n            if handler is None:\n                del self._event_handlers[event_type]\n            else:\n                self._event_handlers[event_type] = [\n                    h for h in self._event_handlers[event_type] if h != handler\n                ]\n\n    def set_center(self, lng: float, lat: float) -&gt; None:\n        \"\"\"Set the map center.\n\n        Args:\n            lng: Longitude\n            lat: Latitude\n        \"\"\"\n        self.center = [lng, lat]\n\n    def set_zoom(self, zoom: float) -&gt; None:\n        \"\"\"Set the map zoom level.\n\n        Args:\n            zoom: Zoom level\n        \"\"\"\n        self.zoom = zoom\n\n    def fly_to(\n        self,\n        lng: float,\n        lat: float,\n        zoom: Optional[float] = None,\n        duration: int = 2000,\n    ) -&gt; None:\n        \"\"\"Fly to a location with animation.\n\n        Args:\n            lng: Longitude\n            lat: Latitude\n            zoom: Optional zoom level\n            duration: Animation duration in milliseconds\n        \"\"\"\n        self.call_js_method(\"flyTo\", lng, lat, zoom=zoom, duration=duration)\n\n    def fit_bounds(\n        self,\n        bounds: List[float],\n        padding: int = 50,\n        duration: int = 1000,\n    ) -&gt; None:\n        \"\"\"Fit the map to the given bounds.\n\n        Args:\n            bounds: [west, south, east, north] bounds\n            padding: Padding in pixels\n            duration: Animation duration in milliseconds\n        \"\"\"\n        self.call_js_method(\"fitBounds\", bounds, padding=padding, duration=duration)\n\n    @property\n    def viewstate(self) -&gt; Dict[str, Any]:\n        \"\"\"Get current view state.\"\"\"\n        return {\n            \"center\": self.current_center or self.center,\n            \"zoom\": self.current_zoom or self.zoom,\n            \"bounds\": self.current_bounds,\n        }\n\n    def _generate_html_template(self) -&gt; str:\n        \"\"\"Generate HTML template for standalone export.\n\n        Override in subclasses for library-specific templates.\n        \"\"\"\n        raise NotImplementedError(\"Subclasses must implement _generate_html_template\")\n\n    def to_html(\n        self,\n        filepath: Optional[Union[str, Path]] = None,\n        title: str = \"Interactive Map\",\n    ) -&gt; Optional[str]:\n        \"\"\"Export map to standalone HTML file.\n\n        Args:\n            filepath: Path to save the HTML file. If None, returns HTML string.\n            title: Title for the HTML page.\n\n        Returns:\n            HTML string if filepath is None, otherwise None.\n        \"\"\"\n        html = self._generate_html_template()\n        html = html.replace(\"{{title}}\", title)\n\n        if filepath:\n            Path(filepath).write_text(html, encoding=\"utf-8\")\n            return None\n        return html\n</code></pre>"},{"location":"base/#anymap_ts.base.MapWidget.viewstate","title":"<code>viewstate: Dict[str, Any]</code>  <code>property</code> <code>readonly</code>","text":"<p>Get current view state.</p>"},{"location":"base/#anymap_ts.base.MapWidget.__init__","title":"<code>__init__(self, **kwargs)</code>  <code>special</code>","text":"<p>Initialize the MapWidget.</p> <p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <p>Additional widget arguments</p> <code>{}</code> Source code in <code>anymap_ts/base.py</code> <pre><code>def __init__(self, **kwargs):\n    \"\"\"Initialize the MapWidget.\n\n    Args:\n        **kwargs: Additional widget arguments\n    \"\"\"\n    super().__init__(**kwargs)\n    self._event_handlers: Dict[str, List[Callable]] = {}\n    self.observe(self._handle_js_events, names=[\"_js_events\"])\n</code></pre>"},{"location":"base/#anymap_ts.base.MapWidget.call_js_method","title":"<code>call_js_method(self, method, *args, **kwargs)</code>","text":"<p>Queue a JavaScript method call.</p> <p>Parameters:</p> Name Type Description Default <code>method</code> <code>str</code> <p>Name of the JavaScript method to call</p> required <code>*args</code> <p>Positional arguments for the method</p> <code>()</code> <code>**kwargs</code> <p>Keyword arguments for the method</p> <code>{}</code> Source code in <code>anymap_ts/base.py</code> <pre><code>def call_js_method(self, method: str, *args, **kwargs) -&gt; None:\n    \"\"\"Queue a JavaScript method call.\n\n    Args:\n        method: Name of the JavaScript method to call\n        *args: Positional arguments for the method\n        **kwargs: Keyword arguments for the method\n    \"\"\"\n    self._js_method_counter += 1\n    call = {\n        \"id\": self._js_method_counter,\n        \"method\": method,\n        \"args\": list(args),\n        \"kwargs\": kwargs,\n    }\n    self._js_calls = self._js_calls + [call]\n</code></pre>"},{"location":"base/#anymap_ts.base.MapWidget.fit_bounds","title":"<code>fit_bounds(self, bounds, padding=50, duration=1000)</code>","text":"<p>Fit the map to the given bounds.</p> <p>Parameters:</p> Name Type Description Default <code>bounds</code> <code>List[float]</code> <p>[west, south, east, north] bounds</p> required <code>padding</code> <code>int</code> <p>Padding in pixels</p> <code>50</code> <code>duration</code> <code>int</code> <p>Animation duration in milliseconds</p> <code>1000</code> Source code in <code>anymap_ts/base.py</code> <pre><code>def fit_bounds(\n    self,\n    bounds: List[float],\n    padding: int = 50,\n    duration: int = 1000,\n) -&gt; None:\n    \"\"\"Fit the map to the given bounds.\n\n    Args:\n        bounds: [west, south, east, north] bounds\n        padding: Padding in pixels\n        duration: Animation duration in milliseconds\n    \"\"\"\n    self.call_js_method(\"fitBounds\", bounds, padding=padding, duration=duration)\n</code></pre>"},{"location":"base/#anymap_ts.base.MapWidget.fly_to","title":"<code>fly_to(self, lng, lat, zoom=None, duration=2000)</code>","text":"<p>Fly to a location with animation.</p> <p>Parameters:</p> Name Type Description Default <code>lng</code> <code>float</code> <p>Longitude</p> required <code>lat</code> <code>float</code> <p>Latitude</p> required <code>zoom</code> <code>Optional[float]</code> <p>Optional zoom level</p> <code>None</code> <code>duration</code> <code>int</code> <p>Animation duration in milliseconds</p> <code>2000</code> Source code in <code>anymap_ts/base.py</code> <pre><code>def fly_to(\n    self,\n    lng: float,\n    lat: float,\n    zoom: Optional[float] = None,\n    duration: int = 2000,\n) -&gt; None:\n    \"\"\"Fly to a location with animation.\n\n    Args:\n        lng: Longitude\n        lat: Latitude\n        zoom: Optional zoom level\n        duration: Animation duration in milliseconds\n    \"\"\"\n    self.call_js_method(\"flyTo\", lng, lat, zoom=zoom, duration=duration)\n</code></pre>"},{"location":"base/#anymap_ts.base.MapWidget.off_map_event","title":"<code>off_map_event(self, event_type, handler=None)</code>","text":"<p>Unregister an event handler.</p> <p>Parameters:</p> Name Type Description Default <code>event_type</code> <code>str</code> <p>Type of event</p> required <code>handler</code> <code>Optional[Callable]</code> <p>Specific handler to remove. If None, removes all handlers.</p> <code>None</code> Source code in <code>anymap_ts/base.py</code> <pre><code>def off_map_event(\n    self, event_type: str, handler: Optional[Callable] = None\n) -&gt; None:\n    \"\"\"Unregister an event handler.\n\n    Args:\n        event_type: Type of event\n        handler: Specific handler to remove. If None, removes all handlers.\n    \"\"\"\n    if event_type in self._event_handlers:\n        if handler is None:\n            del self._event_handlers[event_type]\n        else:\n            self._event_handlers[event_type] = [\n                h for h in self._event_handlers[event_type] if h != handler\n            ]\n</code></pre>"},{"location":"base/#anymap_ts.base.MapWidget.on_map_event","title":"<code>on_map_event(self, event_type, handler)</code>","text":"<p>Register an event handler.</p> <p>Parameters:</p> Name Type Description Default <code>event_type</code> <code>str</code> <p>Type of event (e.g., 'click', 'moveend')</p> required <code>handler</code> <code>Callable</code> <p>Callback function to handle the event</p> required Source code in <code>anymap_ts/base.py</code> <pre><code>def on_map_event(self, event_type: str, handler: Callable) -&gt; None:\n    \"\"\"Register an event handler.\n\n    Args:\n        event_type: Type of event (e.g., 'click', 'moveend')\n        handler: Callback function to handle the event\n    \"\"\"\n    if event_type not in self._event_handlers:\n        self._event_handlers[event_type] = []\n    self._event_handlers[event_type].append(handler)\n</code></pre>"},{"location":"base/#anymap_ts.base.MapWidget.set_center","title":"<code>set_center(self, lng, lat)</code>","text":"<p>Set the map center.</p> <p>Parameters:</p> Name Type Description Default <code>lng</code> <code>float</code> <p>Longitude</p> required <code>lat</code> <code>float</code> <p>Latitude</p> required Source code in <code>anymap_ts/base.py</code> <pre><code>def set_center(self, lng: float, lat: float) -&gt; None:\n    \"\"\"Set the map center.\n\n    Args:\n        lng: Longitude\n        lat: Latitude\n    \"\"\"\n    self.center = [lng, lat]\n</code></pre>"},{"location":"base/#anymap_ts.base.MapWidget.set_zoom","title":"<code>set_zoom(self, zoom)</code>","text":"<p>Set the map zoom level.</p> <p>Parameters:</p> Name Type Description Default <code>zoom</code> <code>float</code> <p>Zoom level</p> required Source code in <code>anymap_ts/base.py</code> <pre><code>def set_zoom(self, zoom: float) -&gt; None:\n    \"\"\"Set the map zoom level.\n\n    Args:\n        zoom: Zoom level\n    \"\"\"\n    self.zoom = zoom\n</code></pre>"},{"location":"base/#anymap_ts.base.MapWidget.to_html","title":"<code>to_html(self, filepath=None, title='Interactive Map')</code>","text":"<p>Export map to standalone HTML file.</p> <p>Parameters:</p> Name Type Description Default <code>filepath</code> <code>Optional[Union[str, Path]]</code> <p>Path to save the HTML file. If None, returns HTML string.</p> <code>None</code> <code>title</code> <code>str</code> <p>Title for the HTML page.</p> <code>'Interactive Map'</code> <p>Returns:</p> Type Description <code>Optional[str]</code> <p>HTML string if filepath is None, otherwise None.</p> Source code in <code>anymap_ts/base.py</code> <pre><code>def to_html(\n    self,\n    filepath: Optional[Union[str, Path]] = None,\n    title: str = \"Interactive Map\",\n) -&gt; Optional[str]:\n    \"\"\"Export map to standalone HTML file.\n\n    Args:\n        filepath: Path to save the HTML file. If None, returns HTML string.\n        title: Title for the HTML page.\n\n    Returns:\n        HTML string if filepath is None, otherwise None.\n    \"\"\"\n    html = self._generate_html_template()\n    html = html.replace(\"{{title}}\", title)\n\n    if filepath:\n        Path(filepath).write_text(html, encoding=\"utf-8\")\n        return None\n    return html\n</code></pre>"},{"location":"basemaps/","title":"basemaps module","text":"<p>Basemap provider utilities.</p>"},{"location":"basemaps/#anymap_ts.basemaps.get_basemap_names","title":"<code>get_basemap_names()</code>","text":"<p>Get list of available basemap names.</p> <p>Returns:</p> Type Description <code>list</code> <p>List of basemap provider names</p> Source code in <code>anymap_ts/basemaps.py</code> <pre><code>def get_basemap_names() -&gt; list:\n    \"\"\"Get list of available basemap names.\n\n    Returns:\n        List of basemap provider names\n    \"\"\"\n    return list(xyz.flatten().keys())\n</code></pre>"},{"location":"basemaps/#anymap_ts.basemaps.get_basemap_url","title":"<code>get_basemap_url(name)</code>","text":"<p>Get tile URL and attribution for a named basemap.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Basemap provider name (e.g., \"OpenStreetMap\", \"CartoDB.Positron\")</p> required <p>Returns:</p> Type Description <code>Tuple[str, str]</code> <p>Tuple of (tile_url, attribution)</p> <p>Exceptions:</p> Type Description <code>ValueError</code> <p>If basemap name is not found</p> Source code in <code>anymap_ts/basemaps.py</code> <pre><code>def get_basemap_url(name: str) -&gt; Tuple[str, str]:\n    \"\"\"Get tile URL and attribution for a named basemap.\n\n    Args:\n        name: Basemap provider name (e.g., \"OpenStreetMap\", \"CartoDB.Positron\")\n\n    Returns:\n        Tuple of (tile_url, attribution)\n\n    Raises:\n        ValueError: If basemap name is not found\n    \"\"\"\n    # Handle shortcuts\n    if name in BASEMAP_SHORTCUTS:\n        name = BASEMAP_SHORTCUTS[name]\n\n    # Handle dot notation for nested providers\n    parts = name.split(\".\")\n    provider = xyz\n    for part in parts:\n        provider = getattr(provider, part, None)\n        if provider is None:\n            raise ValueError(f\"Unknown basemap: {name}\")\n\n    url = provider.build_url()\n    attribution = provider.get(\"attribution\", \"\")\n\n    return url, attribution\n</code></pre>"},{"location":"basemaps/#anymap_ts.basemaps.get_maplibre_style","title":"<code>get_maplibre_style(name)</code>","text":"<p>Get MapLibre style URL by name.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Style name (e.g., \"positron\", \"dark-matter\")</p> required <p>Returns:</p> Type Description <code>str</code> <p>Style URL</p> <p>Exceptions:</p> Type Description <code>ValueError</code> <p>If style name is not found</p> Source code in <code>anymap_ts/basemaps.py</code> <pre><code>def get_maplibre_style(name: str) -&gt; str:\n    \"\"\"Get MapLibre style URL by name.\n\n    Args:\n        name: Style name (e.g., \"positron\", \"dark-matter\")\n\n    Returns:\n        Style URL\n\n    Raises:\n        ValueError: If style name is not found\n    \"\"\"\n    name_lower = name.lower().replace(\"_\", \"-\")\n    if name_lower in MAPLIBRE_STYLES:\n        return MAPLIBRE_STYLES[name_lower]\n    # Assume it's already a URL\n    if name.startswith(\"http\"):\n        return name\n    raise ValueError(f\"Unknown MapLibre style: {name}\")\n</code></pre>"},{"location":"cesium/","title":"cesium module","text":"<p>Cesium 3D globe widget implementation.</p>"},{"location":"cesium/#anymap_ts.cesium.CesiumMap","title":"<code> CesiumMap            (MapWidget)         </code>","text":"<p>Interactive 3D globe widget using Cesium.</p> <p>This class provides a Python interface to Cesium for 3D globe visualization with terrain, 3D Tiles, and imagery layer support.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from anymap_ts import CesiumMap\n&gt;&gt;&gt; m = CesiumMap(center=[-122.4, 37.8], zoom=10)\n&gt;&gt;&gt; m.set_terrain()  # Enable Cesium World Terrain\n&gt;&gt;&gt; m.add_3d_tileset(url=\"path/to/tileset.json\")\n&gt;&gt;&gt; m\n</code></pre> Source code in <code>anymap_ts/cesium.py</code> <pre><code>class CesiumMap(MapWidget):\n    \"\"\"Interactive 3D globe widget using Cesium.\n\n    This class provides a Python interface to Cesium for 3D globe\n    visualization with terrain, 3D Tiles, and imagery layer support.\n\n    Example:\n        &gt;&gt;&gt; from anymap_ts import CesiumMap\n        &gt;&gt;&gt; m = CesiumMap(center=[-122.4, 37.8], zoom=10)\n        &gt;&gt;&gt; m.set_terrain()  # Enable Cesium World Terrain\n        &gt;&gt;&gt; m.add_3d_tileset(url=\"path/to/tileset.json\")\n        &gt;&gt;&gt; m\n    \"\"\"\n\n    # ESM module for frontend\n    _esm = STATIC_DIR / \"cesium.js\"\n    _css = STATIC_DIR / \"cesium.css\"\n\n    # Cesium-specific traits\n    access_token = traitlets.Unicode(\"\").tag(sync=True)\n\n    # Camera position traits\n    camera_height = traitlets.Float(10000000).tag(sync=True)\n    heading = traitlets.Float(0.0).tag(sync=True)\n    pitch = traitlets.Float(-90.0).tag(sync=True)\n    roll = traitlets.Float(0.0).tag(sync=True)\n\n    # Terrain\n    terrain_enabled = traitlets.Bool(False).tag(sync=True)\n\n    def __init__(\n        self,\n        center: Tuple[float, float] = (0.0, 0.0),\n        zoom: float = 2.0,\n        width: str = \"100%\",\n        height: str = \"600px\",\n        access_token: Optional[str] = None,\n        terrain: bool = False,\n        **kwargs,\n    ):\n        \"\"\"Initialize a Cesium 3D globe.\n\n        Args:\n            center: Globe center as (longitude, latitude).\n            zoom: Initial zoom level (converted to camera height).\n            width: Widget width as CSS string.\n            height: Widget height as CSS string.\n            access_token: Cesium Ion access token (uses CESIUM_TOKEN env var if not provided).\n            terrain: Whether to enable terrain on initialization.\n            **kwargs: Additional widget arguments.\n        \"\"\"\n        # Get access token from env if not provided\n        if access_token is None:\n            access_token = get_cesium_token()\n\n        super().__init__(\n            center=list(center),\n            zoom=zoom,\n            width=width,\n            height=height,\n            access_token=access_token,\n            terrain_enabled=terrain,\n            **kwargs,\n        )\n\n        # Enable terrain if requested\n        if terrain:\n            self.set_terrain()\n\n    # -------------------------------------------------------------------------\n    # Basemap/Imagery Methods\n    # -------------------------------------------------------------------------\n\n    def add_basemap(\n        self,\n        basemap: str = \"OpenStreetMap\",\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a basemap imagery layer.\n\n        Args:\n            basemap: Name of basemap (e.g., \"OpenStreetMap\", \"Bing\").\n            **kwargs: Additional options.\n        \"\"\"\n        # Common basemap URLs\n        basemap_urls = {\n            \"OpenStreetMap\": \"https://tile.openstreetmap.org/{z}/{x}/{y}.png\",\n            \"CartoDB.Positron\": \"https://a.basemaps.cartocdn.com/light_all/{z}/{x}/{y}.png\",\n            \"CartoDB.DarkMatter\": \"https://a.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}.png\",\n            \"Stamen.Terrain\": \"https://tiles.stadiamaps.com/tiles/stamen_terrain/{z}/{x}/{y}.png\",\n        }\n\n        url = basemap_urls.get(basemap, basemap_urls[\"OpenStreetMap\"])\n\n        self.call_js_method(\"addBasemap\", url, name=basemap, **kwargs)\n\n    def add_imagery_layer(\n        self,\n        url: str,\n        name: Optional[str] = None,\n        layer_type: str = \"xyz\",\n        alpha: float = 1.0,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add an imagery layer.\n\n        Args:\n            url: Imagery URL or service endpoint.\n            name: Layer name.\n            layer_type: Type of imagery ('xyz', 'wms', 'wmts', 'arcgis').\n            alpha: Layer opacity (0-1).\n            **kwargs: Additional options (layers, parameters for WMS, etc.).\n        \"\"\"\n        layer_id = name or f\"imagery-{len(self._layers)}\"\n\n        self.call_js_method(\n            \"addImageryLayer\",\n            url=url,\n            name=layer_id,\n            type=layer_type,\n            alpha=alpha,\n            **kwargs,\n        )\n\n        self._layers = {\n            **self._layers,\n            layer_id: {\"id\": layer_id, \"type\": \"imagery\"},\n        }\n\n    def remove_imagery_layer(self, name: str) -&gt; None:\n        \"\"\"Remove an imagery layer.\n\n        Args:\n            name: Layer name to remove.\n        \"\"\"\n        if name in self._layers:\n            layers = dict(self._layers)\n            del layers[name]\n            self._layers = layers\n        self.call_js_method(\"removeImageryLayer\", name)\n\n    # -------------------------------------------------------------------------\n    # Terrain Methods\n    # -------------------------------------------------------------------------\n\n    def set_terrain(\n        self,\n        url: Optional[str] = None,\n        request_vertex_normals: bool = True,\n        request_water_mask: bool = True,\n    ) -&gt; None:\n        \"\"\"Enable terrain.\n\n        Args:\n            url: Terrain provider URL. If None, uses Cesium World Terrain (requires Ion token).\n            request_vertex_normals: Request vertex normals for lighting.\n            request_water_mask: Request water mask for water effects.\n        \"\"\"\n        self.terrain_enabled = True\n        self.call_js_method(\n            \"setTerrain\",\n            url=url or \"cesium-world-terrain\",\n            requestVertexNormals=request_vertex_normals,\n            requestWaterMask=request_water_mask,\n        )\n\n    def remove_terrain(self) -&gt; None:\n        \"\"\"Disable terrain and use ellipsoid.\"\"\"\n        self.terrain_enabled = False\n        self.call_js_method(\"removeTerrain\")\n\n    # -------------------------------------------------------------------------\n    # 3D Tiles Methods\n    # -------------------------------------------------------------------------\n\n    def add_3d_tileset(\n        self,\n        url: Union[str, int],\n        name: Optional[str] = None,\n        maximum_screen_space_error: float = 16,\n        fly_to: bool = True,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a 3D Tileset.\n\n        Args:\n            url: URL to tileset.json or Cesium Ion asset ID.\n            name: Tileset name.\n            maximum_screen_space_error: Maximum screen space error for LOD.\n            fly_to: Whether to fly to the tileset after loading.\n            **kwargs: Additional options.\n        \"\"\"\n        layer_id = name or f\"tileset-{len(self._layers)}\"\n\n        self.call_js_method(\n            \"add3DTileset\",\n            url=str(url),\n            name=layer_id,\n            maximumScreenSpaceError=maximum_screen_space_error,\n            flyTo=fly_to,\n            **kwargs,\n        )\n\n        self._layers = {\n            **self._layers,\n            layer_id: {\"id\": layer_id, \"type\": \"3dtiles\"},\n        }\n\n    def remove_3d_tileset(self, name: str) -&gt; None:\n        \"\"\"Remove a 3D Tileset.\n\n        Args:\n            name: Tileset name to remove.\n        \"\"\"\n        if name in self._layers:\n            layers = dict(self._layers)\n            del layers[name]\n            self._layers = layers\n        self.call_js_method(\"remove3DTileset\", name)\n\n    # -------------------------------------------------------------------------\n    # GeoJSON Methods\n    # -------------------------------------------------------------------------\n\n    def add_geojson(\n        self,\n        data: Any,\n        name: Optional[str] = None,\n        stroke: str = \"#3388ff\",\n        stroke_width: float = 2,\n        fill: str = \"rgba(51, 136, 255, 0.5)\",\n        clamp_to_ground: bool = True,\n        fly_to: bool = True,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add GeoJSON data.\n\n        Args:\n            data: GeoJSON dict or file path.\n            name: Data source name.\n            stroke: Stroke color.\n            stroke_width: Stroke width.\n            fill: Fill color.\n            clamp_to_ground: Whether to clamp features to terrain.\n            fly_to: Whether to fly to the data after loading.\n            **kwargs: Additional options.\n        \"\"\"\n        geojson = to_geojson(data)\n        layer_id = name or f\"geojson-{len(self._layers)}\"\n\n        self.call_js_method(\n            \"addGeoJSON\",\n            data=geojson,\n            name=layer_id,\n            stroke=stroke,\n            strokeWidth=stroke_width,\n            fill=fill,\n            clampToGround=clamp_to_ground,\n            flyTo=fly_to,\n            **kwargs,\n        )\n\n        self._layers = {\n            **self._layers,\n            layer_id: {\"id\": layer_id, \"type\": \"geojson\"},\n        }\n\n    def remove_data_source(self, name: str) -&gt; None:\n        \"\"\"Remove a data source (GeoJSON, etc.).\n\n        Args:\n            name: Data source name to remove.\n        \"\"\"\n        if name in self._layers:\n            layers = dict(self._layers)\n            del layers[name]\n            self._layers = layers\n        self.call_js_method(\"removeDataSource\", name)\n\n    # -------------------------------------------------------------------------\n    # Camera Methods\n    # -------------------------------------------------------------------------\n\n    def fly_to(\n        self,\n        lng: float,\n        lat: float,\n        height: Optional[float] = None,\n        zoom: Optional[float] = None,\n        heading: float = 0,\n        pitch: float = -90,\n        roll: float = 0,\n        duration: float = 2,\n    ) -&gt; None:\n        \"\"\"Fly to a location.\n\n        Args:\n            lng: Target longitude.\n            lat: Target latitude.\n            height: Camera height in meters (overrides zoom).\n            zoom: Zoom level (converted to height if height not provided).\n            heading: Camera heading in degrees.\n            pitch: Camera pitch in degrees (default -90 = looking down).\n            roll: Camera roll in degrees.\n            duration: Flight duration in seconds.\n        \"\"\"\n        self.call_js_method(\n            \"flyTo\",\n            lng,\n            lat,\n            height=height,\n            zoom=zoom,\n            heading=heading,\n            pitch=pitch,\n            roll=roll,\n            duration=duration,\n        )\n\n    def zoom_to(self, target: str) -&gt; None:\n        \"\"\"Zoom to a layer or data source.\n\n        Args:\n            target: Name of the layer or data source to zoom to.\n        \"\"\"\n        self.call_js_method(\"zoomTo\", target=target)\n\n    def set_camera(\n        self,\n        longitude: float = 0,\n        latitude: float = 0,\n        height: float = 10000000,\n        heading: float = 0,\n        pitch: float = -90,\n        roll: float = 0,\n    ) -&gt; None:\n        \"\"\"Set the camera position immediately (no animation).\n\n        Args:\n            longitude: Camera longitude.\n            latitude: Camera latitude.\n            height: Camera height in meters.\n            heading: Camera heading in degrees.\n            pitch: Camera pitch in degrees.\n            roll: Camera roll in degrees.\n        \"\"\"\n        self.call_js_method(\n            \"setCamera\",\n            longitude=longitude,\n            latitude=latitude,\n            height=height,\n            heading=heading,\n            pitch=pitch,\n            roll=roll,\n        )\n\n    def reset_view(self, duration: float = 2) -&gt; None:\n        \"\"\"Reset camera to home position.\n\n        Args:\n            duration: Animation duration in seconds.\n        \"\"\"\n        self.call_js_method(\"resetView\", duration=duration)\n\n    # -------------------------------------------------------------------------\n    # Layer Management\n    # -------------------------------------------------------------------------\n\n    def set_visibility(self, name: str, visible: bool) -&gt; None:\n        \"\"\"Set layer visibility.\n\n        Args:\n            name: Layer name.\n            visible: Whether layer should be visible.\n        \"\"\"\n        self.call_js_method(\"setVisibility\", name, visible)\n\n    def set_opacity(self, name: str, opacity: float) -&gt; None:\n        \"\"\"Set layer opacity (imagery layers only).\n\n        Args:\n            name: Layer name.\n            opacity: Opacity value (0-1).\n        \"\"\"\n        self.call_js_method(\"setOpacity\", name, opacity)\n\n    # -------------------------------------------------------------------------\n    # HTML Export\n    # -------------------------------------------------------------------------\n\n    def _generate_html_template(self) -&gt; str:\n        \"\"\"Generate standalone HTML for the globe.\"\"\"\n        template_path = Path(__file__).parent / \"templates\" / \"cesium.html\"\n\n        if template_path.exists():\n            template = template_path.read_text(encoding=\"utf-8\")\n        else:\n            template = self._get_default_template()\n\n        state = {\n            \"center\": self.center,\n            \"zoom\": self.zoom,\n            \"access_token\": self.access_token,\n            \"terrain_enabled\": self.terrain_enabled,\n            \"width\": self.width,\n            \"height\": self.height,\n            \"layers\": self._layers,\n            \"js_calls\": self._js_calls,\n        }\n\n        template = template.replace(\"{{state}}\", json.dumps(state, indent=2))\n        template = template.replace(\"{{access_token}}\", self.access_token)\n        return template\n\n    def _get_default_template(self) -&gt; str:\n        \"\"\"Get default HTML template.\"\"\"\n        return \"\"\"&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n    &lt;meta charset=\"utf-8\"&gt;\n    &lt;title&gt;Cesium Globe&lt;/title&gt;\n    &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"&gt;\n    &lt;script src=\"https://cesium.com/downloads/cesiumjs/releases/1.120/Build/Cesium/Cesium.js\"&gt;&lt;/script&gt;\n    &lt;link href=\"https://cesium.com/downloads/cesiumjs/releases/1.120/Build/Cesium/Widgets/widgets.css\" rel=\"stylesheet\"&gt;\n    &lt;style&gt;\n        * { margin: 0; padding: 0; box-sizing: border-box; }\n        html, body { height: 100%; }\n        #cesiumContainer { position: absolute; top: 0; bottom: 0; width: 100%; }\n    &lt;/style&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;div id=\"cesiumContainer\"&gt;&lt;/div&gt;\n    &lt;script&gt;\n        const state = {{state}};\n\n        if (state.access_token) {\n            Cesium.Ion.defaultAccessToken = state.access_token;\n        }\n\n        const viewer = new Cesium.Viewer('cesiumContainer', {\n            baseLayerPicker: false,\n            geocoder: false,\n            homeButton: false,\n            sceneModePicker: false,\n            navigationHelpButton: false,\n            animation: false,\n            timeline: false\n        });\n\n        for (const call of state.js_calls || []) {\n            executeMethod(call.method, call.args, call.kwargs);\n        }\n\n        function executeMethod(method, args, kwargs) {\n            console.log('Executing:', method, args, kwargs);\n        }\n    &lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\"\"\"\n</code></pre>"},{"location":"cesium/#anymap_ts.cesium.CesiumMap.__init__","title":"<code>__init__(self, center=(0.0, 0.0), zoom=2.0, width='100%', height='600px', access_token=None, terrain=False, **kwargs)</code>  <code>special</code>","text":"<p>Initialize a Cesium 3D globe.</p> <p>Parameters:</p> Name Type Description Default <code>center</code> <code>Tuple[float, float]</code> <p>Globe center as (longitude, latitude).</p> <code>(0.0, 0.0)</code> <code>zoom</code> <code>float</code> <p>Initial zoom level (converted to camera height).</p> <code>2.0</code> <code>width</code> <code>str</code> <p>Widget width as CSS string.</p> <code>'100%'</code> <code>height</code> <code>str</code> <p>Widget height as CSS string.</p> <code>'600px'</code> <code>access_token</code> <code>Optional[str]</code> <p>Cesium Ion access token (uses CESIUM_TOKEN env var if not provided).</p> <code>None</code> <code>terrain</code> <code>bool</code> <p>Whether to enable terrain on initialization.</p> <code>False</code> <code>**kwargs</code> <p>Additional widget arguments.</p> <code>{}</code> Source code in <code>anymap_ts/cesium.py</code> <pre><code>def __init__(\n    self,\n    center: Tuple[float, float] = (0.0, 0.0),\n    zoom: float = 2.0,\n    width: str = \"100%\",\n    height: str = \"600px\",\n    access_token: Optional[str] = None,\n    terrain: bool = False,\n    **kwargs,\n):\n    \"\"\"Initialize a Cesium 3D globe.\n\n    Args:\n        center: Globe center as (longitude, latitude).\n        zoom: Initial zoom level (converted to camera height).\n        width: Widget width as CSS string.\n        height: Widget height as CSS string.\n        access_token: Cesium Ion access token (uses CESIUM_TOKEN env var if not provided).\n        terrain: Whether to enable terrain on initialization.\n        **kwargs: Additional widget arguments.\n    \"\"\"\n    # Get access token from env if not provided\n    if access_token is None:\n        access_token = get_cesium_token()\n\n    super().__init__(\n        center=list(center),\n        zoom=zoom,\n        width=width,\n        height=height,\n        access_token=access_token,\n        terrain_enabled=terrain,\n        **kwargs,\n    )\n\n    # Enable terrain if requested\n    if terrain:\n        self.set_terrain()\n</code></pre>"},{"location":"cesium/#anymap_ts.cesium.CesiumMap.add_3d_tileset","title":"<code>add_3d_tileset(self, url, name=None, maximum_screen_space_error=16, fly_to=True, **kwargs)</code>","text":"<p>Add a 3D Tileset.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>Union[str, int]</code> <p>URL to tileset.json or Cesium Ion asset ID.</p> required <code>name</code> <code>Optional[str]</code> <p>Tileset name.</p> <code>None</code> <code>maximum_screen_space_error</code> <code>float</code> <p>Maximum screen space error for LOD.</p> <code>16</code> <code>fly_to</code> <code>bool</code> <p>Whether to fly to the tileset after loading.</p> <code>True</code> <code>**kwargs</code> <p>Additional options.</p> <code>{}</code> Source code in <code>anymap_ts/cesium.py</code> <pre><code>def add_3d_tileset(\n    self,\n    url: Union[str, int],\n    name: Optional[str] = None,\n    maximum_screen_space_error: float = 16,\n    fly_to: bool = True,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a 3D Tileset.\n\n    Args:\n        url: URL to tileset.json or Cesium Ion asset ID.\n        name: Tileset name.\n        maximum_screen_space_error: Maximum screen space error for LOD.\n        fly_to: Whether to fly to the tileset after loading.\n        **kwargs: Additional options.\n    \"\"\"\n    layer_id = name or f\"tileset-{len(self._layers)}\"\n\n    self.call_js_method(\n        \"add3DTileset\",\n        url=str(url),\n        name=layer_id,\n        maximumScreenSpaceError=maximum_screen_space_error,\n        flyTo=fly_to,\n        **kwargs,\n    )\n\n    self._layers = {\n        **self._layers,\n        layer_id: {\"id\": layer_id, \"type\": \"3dtiles\"},\n    }\n</code></pre>"},{"location":"cesium/#anymap_ts.cesium.CesiumMap.add_basemap","title":"<code>add_basemap(self, basemap='OpenStreetMap', **kwargs)</code>","text":"<p>Add a basemap imagery layer.</p> <p>Parameters:</p> Name Type Description Default <code>basemap</code> <code>str</code> <p>Name of basemap (e.g., \"OpenStreetMap\", \"Bing\").</p> <code>'OpenStreetMap'</code> <code>**kwargs</code> <p>Additional options.</p> <code>{}</code> Source code in <code>anymap_ts/cesium.py</code> <pre><code>def add_basemap(\n    self,\n    basemap: str = \"OpenStreetMap\",\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a basemap imagery layer.\n\n    Args:\n        basemap: Name of basemap (e.g., \"OpenStreetMap\", \"Bing\").\n        **kwargs: Additional options.\n    \"\"\"\n    # Common basemap URLs\n    basemap_urls = {\n        \"OpenStreetMap\": \"https://tile.openstreetmap.org/{z}/{x}/{y}.png\",\n        \"CartoDB.Positron\": \"https://a.basemaps.cartocdn.com/light_all/{z}/{x}/{y}.png\",\n        \"CartoDB.DarkMatter\": \"https://a.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}.png\",\n        \"Stamen.Terrain\": \"https://tiles.stadiamaps.com/tiles/stamen_terrain/{z}/{x}/{y}.png\",\n    }\n\n    url = basemap_urls.get(basemap, basemap_urls[\"OpenStreetMap\"])\n\n    self.call_js_method(\"addBasemap\", url, name=basemap, **kwargs)\n</code></pre>"},{"location":"cesium/#anymap_ts.cesium.CesiumMap.add_geojson","title":"<code>add_geojson(self, data, name=None, stroke='#3388ff', stroke_width=2, fill='rgba(51, 136, 255, 0.5)', clamp_to_ground=True, fly_to=True, **kwargs)</code>","text":"<p>Add GeoJSON data.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>GeoJSON dict or file path.</p> required <code>name</code> <code>Optional[str]</code> <p>Data source name.</p> <code>None</code> <code>stroke</code> <code>str</code> <p>Stroke color.</p> <code>'#3388ff'</code> <code>stroke_width</code> <code>float</code> <p>Stroke width.</p> <code>2</code> <code>fill</code> <code>str</code> <p>Fill color.</p> <code>'rgba(51, 136, 255, 0.5)'</code> <code>clamp_to_ground</code> <code>bool</code> <p>Whether to clamp features to terrain.</p> <code>True</code> <code>fly_to</code> <code>bool</code> <p>Whether to fly to the data after loading.</p> <code>True</code> <code>**kwargs</code> <p>Additional options.</p> <code>{}</code> Source code in <code>anymap_ts/cesium.py</code> <pre><code>def add_geojson(\n    self,\n    data: Any,\n    name: Optional[str] = None,\n    stroke: str = \"#3388ff\",\n    stroke_width: float = 2,\n    fill: str = \"rgba(51, 136, 255, 0.5)\",\n    clamp_to_ground: bool = True,\n    fly_to: bool = True,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add GeoJSON data.\n\n    Args:\n        data: GeoJSON dict or file path.\n        name: Data source name.\n        stroke: Stroke color.\n        stroke_width: Stroke width.\n        fill: Fill color.\n        clamp_to_ground: Whether to clamp features to terrain.\n        fly_to: Whether to fly to the data after loading.\n        **kwargs: Additional options.\n    \"\"\"\n    geojson = to_geojson(data)\n    layer_id = name or f\"geojson-{len(self._layers)}\"\n\n    self.call_js_method(\n        \"addGeoJSON\",\n        data=geojson,\n        name=layer_id,\n        stroke=stroke,\n        strokeWidth=stroke_width,\n        fill=fill,\n        clampToGround=clamp_to_ground,\n        flyTo=fly_to,\n        **kwargs,\n    )\n\n    self._layers = {\n        **self._layers,\n        layer_id: {\"id\": layer_id, \"type\": \"geojson\"},\n    }\n</code></pre>"},{"location":"cesium/#anymap_ts.cesium.CesiumMap.add_imagery_layer","title":"<code>add_imagery_layer(self, url, name=None, layer_type='xyz', alpha=1.0, **kwargs)</code>","text":"<p>Add an imagery layer.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>Imagery URL or service endpoint.</p> required <code>name</code> <code>Optional[str]</code> <p>Layer name.</p> <code>None</code> <code>layer_type</code> <code>str</code> <p>Type of imagery ('xyz', 'wms', 'wmts', 'arcgis').</p> <code>'xyz'</code> <code>alpha</code> <code>float</code> <p>Layer opacity (0-1).</p> <code>1.0</code> <code>**kwargs</code> <p>Additional options (layers, parameters for WMS, etc.).</p> <code>{}</code> Source code in <code>anymap_ts/cesium.py</code> <pre><code>def add_imagery_layer(\n    self,\n    url: str,\n    name: Optional[str] = None,\n    layer_type: str = \"xyz\",\n    alpha: float = 1.0,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add an imagery layer.\n\n    Args:\n        url: Imagery URL or service endpoint.\n        name: Layer name.\n        layer_type: Type of imagery ('xyz', 'wms', 'wmts', 'arcgis').\n        alpha: Layer opacity (0-1).\n        **kwargs: Additional options (layers, parameters for WMS, etc.).\n    \"\"\"\n    layer_id = name or f\"imagery-{len(self._layers)}\"\n\n    self.call_js_method(\n        \"addImageryLayer\",\n        url=url,\n        name=layer_id,\n        type=layer_type,\n        alpha=alpha,\n        **kwargs,\n    )\n\n    self._layers = {\n        **self._layers,\n        layer_id: {\"id\": layer_id, \"type\": \"imagery\"},\n    }\n</code></pre>"},{"location":"cesium/#anymap_ts.cesium.CesiumMap.fly_to","title":"<code>fly_to(self, lng, lat, height=None, zoom=None, heading=0, pitch=-90, roll=0, duration=2)</code>","text":"<p>Fly to a location.</p> <p>Parameters:</p> Name Type Description Default <code>lng</code> <code>float</code> <p>Target longitude.</p> required <code>lat</code> <code>float</code> <p>Target latitude.</p> required <code>height</code> <code>Optional[float]</code> <p>Camera height in meters (overrides zoom).</p> <code>None</code> <code>zoom</code> <code>Optional[float]</code> <p>Zoom level (converted to height if height not provided).</p> <code>None</code> <code>heading</code> <code>float</code> <p>Camera heading in degrees.</p> <code>0</code> <code>pitch</code> <code>float</code> <p>Camera pitch in degrees (default -90 = looking down).</p> <code>-90</code> <code>roll</code> <code>float</code> <p>Camera roll in degrees.</p> <code>0</code> <code>duration</code> <code>float</code> <p>Flight duration in seconds.</p> <code>2</code> Source code in <code>anymap_ts/cesium.py</code> <pre><code>def fly_to(\n    self,\n    lng: float,\n    lat: float,\n    height: Optional[float] = None,\n    zoom: Optional[float] = None,\n    heading: float = 0,\n    pitch: float = -90,\n    roll: float = 0,\n    duration: float = 2,\n) -&gt; None:\n    \"\"\"Fly to a location.\n\n    Args:\n        lng: Target longitude.\n        lat: Target latitude.\n        height: Camera height in meters (overrides zoom).\n        zoom: Zoom level (converted to height if height not provided).\n        heading: Camera heading in degrees.\n        pitch: Camera pitch in degrees (default -90 = looking down).\n        roll: Camera roll in degrees.\n        duration: Flight duration in seconds.\n    \"\"\"\n    self.call_js_method(\n        \"flyTo\",\n        lng,\n        lat,\n        height=height,\n        zoom=zoom,\n        heading=heading,\n        pitch=pitch,\n        roll=roll,\n        duration=duration,\n    )\n</code></pre>"},{"location":"cesium/#anymap_ts.cesium.CesiumMap.remove_3d_tileset","title":"<code>remove_3d_tileset(self, name)</code>","text":"<p>Remove a 3D Tileset.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Tileset name to remove.</p> required Source code in <code>anymap_ts/cesium.py</code> <pre><code>def remove_3d_tileset(self, name: str) -&gt; None:\n    \"\"\"Remove a 3D Tileset.\n\n    Args:\n        name: Tileset name to remove.\n    \"\"\"\n    if name in self._layers:\n        layers = dict(self._layers)\n        del layers[name]\n        self._layers = layers\n    self.call_js_method(\"remove3DTileset\", name)\n</code></pre>"},{"location":"cesium/#anymap_ts.cesium.CesiumMap.remove_data_source","title":"<code>remove_data_source(self, name)</code>","text":"<p>Remove a data source (GeoJSON, etc.).</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Data source name to remove.</p> required Source code in <code>anymap_ts/cesium.py</code> <pre><code>def remove_data_source(self, name: str) -&gt; None:\n    \"\"\"Remove a data source (GeoJSON, etc.).\n\n    Args:\n        name: Data source name to remove.\n    \"\"\"\n    if name in self._layers:\n        layers = dict(self._layers)\n        del layers[name]\n        self._layers = layers\n    self.call_js_method(\"removeDataSource\", name)\n</code></pre>"},{"location":"cesium/#anymap_ts.cesium.CesiumMap.remove_imagery_layer","title":"<code>remove_imagery_layer(self, name)</code>","text":"<p>Remove an imagery layer.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Layer name to remove.</p> required Source code in <code>anymap_ts/cesium.py</code> <pre><code>def remove_imagery_layer(self, name: str) -&gt; None:\n    \"\"\"Remove an imagery layer.\n\n    Args:\n        name: Layer name to remove.\n    \"\"\"\n    if name in self._layers:\n        layers = dict(self._layers)\n        del layers[name]\n        self._layers = layers\n    self.call_js_method(\"removeImageryLayer\", name)\n</code></pre>"},{"location":"cesium/#anymap_ts.cesium.CesiumMap.remove_terrain","title":"<code>remove_terrain(self)</code>","text":"<p>Disable terrain and use ellipsoid.</p> Source code in <code>anymap_ts/cesium.py</code> <pre><code>def remove_terrain(self) -&gt; None:\n    \"\"\"Disable terrain and use ellipsoid.\"\"\"\n    self.terrain_enabled = False\n    self.call_js_method(\"removeTerrain\")\n</code></pre>"},{"location":"cesium/#anymap_ts.cesium.CesiumMap.reset_view","title":"<code>reset_view(self, duration=2)</code>","text":"<p>Reset camera to home position.</p> <p>Parameters:</p> Name Type Description Default <code>duration</code> <code>float</code> <p>Animation duration in seconds.</p> <code>2</code> Source code in <code>anymap_ts/cesium.py</code> <pre><code>def reset_view(self, duration: float = 2) -&gt; None:\n    \"\"\"Reset camera to home position.\n\n    Args:\n        duration: Animation duration in seconds.\n    \"\"\"\n    self.call_js_method(\"resetView\", duration=duration)\n</code></pre>"},{"location":"cesium/#anymap_ts.cesium.CesiumMap.set_camera","title":"<code>set_camera(self, longitude=0, latitude=0, height=10000000, heading=0, pitch=-90, roll=0)</code>","text":"<p>Set the camera position immediately (no animation).</p> <p>Parameters:</p> Name Type Description Default <code>longitude</code> <code>float</code> <p>Camera longitude.</p> <code>0</code> <code>latitude</code> <code>float</code> <p>Camera latitude.</p> <code>0</code> <code>height</code> <code>float</code> <p>Camera height in meters.</p> <code>10000000</code> <code>heading</code> <code>float</code> <p>Camera heading in degrees.</p> <code>0</code> <code>pitch</code> <code>float</code> <p>Camera pitch in degrees.</p> <code>-90</code> <code>roll</code> <code>float</code> <p>Camera roll in degrees.</p> <code>0</code> Source code in <code>anymap_ts/cesium.py</code> <pre><code>def set_camera(\n    self,\n    longitude: float = 0,\n    latitude: float = 0,\n    height: float = 10000000,\n    heading: float = 0,\n    pitch: float = -90,\n    roll: float = 0,\n) -&gt; None:\n    \"\"\"Set the camera position immediately (no animation).\n\n    Args:\n        longitude: Camera longitude.\n        latitude: Camera latitude.\n        height: Camera height in meters.\n        heading: Camera heading in degrees.\n        pitch: Camera pitch in degrees.\n        roll: Camera roll in degrees.\n    \"\"\"\n    self.call_js_method(\n        \"setCamera\",\n        longitude=longitude,\n        latitude=latitude,\n        height=height,\n        heading=heading,\n        pitch=pitch,\n        roll=roll,\n    )\n</code></pre>"},{"location":"cesium/#anymap_ts.cesium.CesiumMap.set_opacity","title":"<code>set_opacity(self, name, opacity)</code>","text":"<p>Set layer opacity (imagery layers only).</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Layer name.</p> required <code>opacity</code> <code>float</code> <p>Opacity value (0-1).</p> required Source code in <code>anymap_ts/cesium.py</code> <pre><code>def set_opacity(self, name: str, opacity: float) -&gt; None:\n    \"\"\"Set layer opacity (imagery layers only).\n\n    Args:\n        name: Layer name.\n        opacity: Opacity value (0-1).\n    \"\"\"\n    self.call_js_method(\"setOpacity\", name, opacity)\n</code></pre>"},{"location":"cesium/#anymap_ts.cesium.CesiumMap.set_terrain","title":"<code>set_terrain(self, url=None, request_vertex_normals=True, request_water_mask=True)</code>","text":"<p>Enable terrain.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>Optional[str]</code> <p>Terrain provider URL. If None, uses Cesium World Terrain (requires Ion token).</p> <code>None</code> <code>request_vertex_normals</code> <code>bool</code> <p>Request vertex normals for lighting.</p> <code>True</code> <code>request_water_mask</code> <code>bool</code> <p>Request water mask for water effects.</p> <code>True</code> Source code in <code>anymap_ts/cesium.py</code> <pre><code>def set_terrain(\n    self,\n    url: Optional[str] = None,\n    request_vertex_normals: bool = True,\n    request_water_mask: bool = True,\n) -&gt; None:\n    \"\"\"Enable terrain.\n\n    Args:\n        url: Terrain provider URL. If None, uses Cesium World Terrain (requires Ion token).\n        request_vertex_normals: Request vertex normals for lighting.\n        request_water_mask: Request water mask for water effects.\n    \"\"\"\n    self.terrain_enabled = True\n    self.call_js_method(\n        \"setTerrain\",\n        url=url or \"cesium-world-terrain\",\n        requestVertexNormals=request_vertex_normals,\n        requestWaterMask=request_water_mask,\n    )\n</code></pre>"},{"location":"cesium/#anymap_ts.cesium.CesiumMap.set_visibility","title":"<code>set_visibility(self, name, visible)</code>","text":"<p>Set layer visibility.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Layer name.</p> required <code>visible</code> <code>bool</code> <p>Whether layer should be visible.</p> required Source code in <code>anymap_ts/cesium.py</code> <pre><code>def set_visibility(self, name: str, visible: bool) -&gt; None:\n    \"\"\"Set layer visibility.\n\n    Args:\n        name: Layer name.\n        visible: Whether layer should be visible.\n    \"\"\"\n    self.call_js_method(\"setVisibility\", name, visible)\n</code></pre>"},{"location":"cesium/#anymap_ts.cesium.CesiumMap.zoom_to","title":"<code>zoom_to(self, target)</code>","text":"<p>Zoom to a layer or data source.</p> <p>Parameters:</p> Name Type Description Default <code>target</code> <code>str</code> <p>Name of the layer or data source to zoom to.</p> required Source code in <code>anymap_ts/cesium.py</code> <pre><code>def zoom_to(self, target: str) -&gt; None:\n    \"\"\"Zoom to a layer or data source.\n\n    Args:\n        target: Name of the layer or data source to zoom to.\n    \"\"\"\n    self.call_js_method(\"zoomTo\", target=target)\n</code></pre>"},{"location":"cesium/#anymap_ts.cesium.get_cesium_token","title":"<code>get_cesium_token()</code>","text":"<p>Get Cesium Ion access token from environment variable.</p> <p>Returns:</p> Type Description <code>str</code> <p>Cesium Ion access token or empty string if not set.</p> Source code in <code>anymap_ts/cesium.py</code> <pre><code>def get_cesium_token() -&gt; str:\n    \"\"\"Get Cesium Ion access token from environment variable.\n\n    Returns:\n        Cesium Ion access token or empty string if not set.\n    \"\"\"\n    return os.environ.get(\"CESIUM_TOKEN\", \"\")\n</code></pre>"},{"location":"contributing/","title":"Contributing","text":"<p>Contributions are welcome, and they are greatly appreciated! Every little bit helps, and credit will always be given.</p>"},{"location":"contributing/#types-of-contributions","title":"Types of Contributions","text":""},{"location":"contributing/#report-bugs","title":"Report Bugs","text":"<p>Report bugs at https://github.com/opengeos/anymap-ts/issues.</p> <p>If you are reporting a bug, please include:</p> <ul> <li>Your operating system name and version.</li> <li>Any details about your local setup that might be helpful in troubleshooting.</li> <li>Detailed steps to reproduce the bug.</li> </ul>"},{"location":"contributing/#fix-bugs","title":"Fix Bugs","text":"<p>Look through the GitHub issues for bugs. Anything tagged with \"bug\" and \"help wanted\" is open to whoever wants to implement it.</p>"},{"location":"contributing/#implement-features","title":"Implement Features","text":"<p>Look through the GitHub issues for features. Anything tagged with \"enhancement\" and \"help wanted\" is open to whoever wants to implement it.</p>"},{"location":"contributing/#write-documentation","title":"Write Documentation","text":"<p>anymap-ts could always use more documentation, whether as part of the official docs, in docstrings, or even on the web in blog posts, articles, and such.</p>"},{"location":"contributing/#submit-feedback","title":"Submit Feedback","text":"<p>The best way to send feedback is to file an issue at https://github.com/opengeos/anymap-ts/issues.</p> <p>If you are proposing a feature:</p> <ul> <li>Explain in detail how it would work.</li> <li>Keep the scope as narrow as possible, to make it easier to implement.</li> <li>Remember that this is a volunteer-driven project, and that contributions are welcome.</li> </ul>"},{"location":"contributing/#get-started","title":"Get Started!","text":"<p>Ready to contribute? Here's how to set up anymap-ts for local development.</p> <ol> <li> <p>Fork the anymap-ts repo on GitHub.</p> </li> <li> <p>Clone your fork locally:</p> <pre><code>git clone git@github.com:your_name_here/anymap-ts.git\n</code></pre> </li> <li> <p>Install your local copy into a virtual environment:</p> <pre><code>cd anymap-ts\npip install -e \".[dev]\"\nnpm install --legacy-peer-deps\n</code></pre> </li> <li> <p>Create a branch for local development:</p> <pre><code>git checkout -b name-of-your-bugfix-or-feature\n</code></pre> </li> <li> <p>Make your changes locally.</p> </li> <li> <p>Build the TypeScript code:</p> <pre><code>npm run build:all\n</code></pre> </li> <li> <p>Commit your changes and push your branch to GitHub:</p> <pre><code>git add .\ngit commit -m \"Your detailed description of your changes.\"\ngit push origin name-of-your-bugfix-or-feature\n</code></pre> </li> <li> <p>Submit a pull request through the GitHub website.</p> </li> </ol>"},{"location":"contributing/#pull-request-guidelines","title":"Pull Request Guidelines","text":"<p>Before you submit a pull request, check that it meets these guidelines:</p> <ol> <li>The pull request should include tests if applicable.</li> <li>If the pull request adds functionality, the docs should be updated.</li> <li>The pull request should work for Python 3.10+.</li> </ol>"},{"location":"contributing/#project-structure","title":"Project Structure","text":"<pre><code>anymap-ts/\n\u251c\u2500\u2500 src/                    # TypeScript source\n\u2502   \u251c\u2500\u2500 core/               # Base classes\n\u2502   \u251c\u2500\u2500 maplibre/           # MapLibre implementation\n\u2502   \u251c\u2500\u2500 mapbox/             # Mapbox implementation\n\u2502   \u251c\u2500\u2500 leaflet/            # Leaflet implementation\n\u2502   \u251c\u2500\u2500 openlayers/         # OpenLayers implementation\n\u2502   \u251c\u2500\u2500 deckgl/             # DeckGL implementation\n\u2502   \u251c\u2500\u2500 cesium/             # Cesium implementation\n\u2502   \u2514\u2500\u2500 types/              # Type definitions\n\u251c\u2500\u2500 anymap_ts/              # Python package\n\u2502   \u251c\u2500\u2500 maplibre.py         # MapLibreMap class\n\u2502   \u251c\u2500\u2500 mapbox.py           # MapboxMap class\n\u2502   \u251c\u2500\u2500 leaflet.py          # LeafletMap class\n\u2502   \u251c\u2500\u2500 openlayers.py       # OpenLayersMap class\n\u2502   \u251c\u2500\u2500 deckgl.py           # DeckGLMap class\n\u2502   \u251c\u2500\u2500 cesium.py           # CesiumMap class\n\u2502   \u251c\u2500\u2500 keplergl.py         # KeplerGLMap class\n\u2502   \u251c\u2500\u2500 potree.py           # PotreeViewer class\n\u2502   \u251c\u2500\u2500 static/             # Built JS/CSS\n\u2502   \u2514\u2500\u2500 templates/          # HTML export templates\n\u2514\u2500\u2500 docs/                   # Documentation\n    \u2514\u2500\u2500 notebooks/          # Example notebooks\n</code></pre>"},{"location":"contributing/#build-commands","title":"Build Commands","text":"<pre><code># Build all libraries\nnpm run build:all\n\n# Build specific library\nnpm run build:maplibre\nnpm run build:mapbox\nnpm run build:leaflet\nnpm run build:deckgl\nnpm run build:openlayers\nnpm run build:cesium\n\n# Watch mode\nnpm run watch\n</code></pre>"},{"location":"deckgl/","title":"deckgl module","text":"<p>DeckGL map widget implementation extending MapLibre with deck.gl layers.</p>"},{"location":"deckgl/#anymap_ts.deckgl.DeckGLMap","title":"<code> DeckGLMap            (MapLibreMap)         </code>","text":"<p>Interactive map widget using MapLibre GL JS with deck.gl overlay.</p> <p>This class extends MapLibreMap with deck.gl visualization layer support for GPU-accelerated geospatial visualizations.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from anymap_ts import DeckGLMap\n&gt;&gt;&gt; m = DeckGLMap(center=[-122.4, 37.8], zoom=10)\n&gt;&gt;&gt; m.add_scatterplot_layer(\n...     data=points,\n...     get_position='coordinates',\n...     get_radius=100,\n...     get_fill_color=[255, 0, 0]\n... )\n&gt;&gt;&gt; m\n</code></pre> Source code in <code>anymap_ts/deckgl.py</code> <pre><code>class DeckGLMap(MapLibreMap):\n    \"\"\"Interactive map widget using MapLibre GL JS with deck.gl overlay.\n\n    This class extends MapLibreMap with deck.gl visualization layer support\n    for GPU-accelerated geospatial visualizations.\n\n    Example:\n        &gt;&gt;&gt; from anymap_ts import DeckGLMap\n        &gt;&gt;&gt; m = DeckGLMap(center=[-122.4, 37.8], zoom=10)\n        &gt;&gt;&gt; m.add_scatterplot_layer(\n        ...     data=points,\n        ...     get_position='coordinates',\n        ...     get_radius=100,\n        ...     get_fill_color=[255, 0, 0]\n        ... )\n        &gt;&gt;&gt; m\n    \"\"\"\n\n    # ESM module for frontend (uses DeckGL-enabled version)\n    _esm = STATIC_DIR / \"deckgl.js\"\n\n    # DeckGL layer tracking\n    _deck_layers = traitlets.Dict({}).tag(sync=True)\n\n    def __init__(\n        self,\n        center: Tuple[float, float] = (0.0, 0.0),\n        zoom: float = 2.0,\n        width: str = \"100%\",\n        height: str = \"600px\",\n        style: Union[str, Dict] = \"https://demotiles.maplibre.org/style.json\",\n        bearing: float = 0.0,\n        pitch: float = 0.0,\n        max_pitch: float = 85.0,\n        controls: Optional[Dict[str, Any]] = None,\n        **kwargs,\n    ):\n        \"\"\"Initialize a DeckGL map.\n\n        Args:\n            center: Map center as (longitude, latitude).\n            zoom: Initial zoom level.\n            width: Map width as CSS string.\n            height: Map height as CSS string.\n            style: MapLibre style URL or style object.\n            bearing: Map bearing in degrees.\n            pitch: Map pitch in degrees.\n            max_pitch: Maximum pitch angle in degrees (default: 85).\n            controls: Dict of controls to add (e.g., {\"navigation\": True}).\n            **kwargs: Additional widget arguments.\n        \"\"\"\n        super().__init__(\n            center=center,\n            zoom=zoom,\n            width=width,\n            height=height,\n            style=style,\n            bearing=bearing,\n            pitch=pitch,\n            max_pitch=max_pitch,\n            controls=controls,\n            **kwargs,\n        )\n        self._deck_layers = {}\n\n    # -------------------------------------------------------------------------\n    # DeckGL Scatterplot Layer\n    # -------------------------------------------------------------------------\n\n    def add_scatterplot_layer(\n        self,\n        data: Any,\n        name: Optional[str] = None,\n        get_position: Union[str, Callable] = \"coordinates\",\n        get_radius: Union[float, str, Callable] = 5,\n        get_fill_color: Union[List[int], str, Callable] = None,\n        get_line_color: Union[List[int], str, Callable] = None,\n        radius_scale: float = 1,\n        radius_min_pixels: float = 1,\n        radius_max_pixels: float = 100,\n        line_width_min_pixels: float = 1,\n        stroked: bool = True,\n        filled: bool = True,\n        pickable: bool = True,\n        opacity: float = 0.8,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a scatterplot layer for point visualization.\n\n        Args:\n            data: Array of data objects or GeoJSON.\n            name: Layer ID.\n            get_position: Accessor for point position [lng, lat].\n            get_radius: Accessor for point radius.\n            get_fill_color: Accessor for fill color [r, g, b, a].\n            get_line_color: Accessor for stroke color [r, g, b, a].\n            radius_scale: Global radius multiplier.\n            radius_min_pixels: Minimum radius in pixels.\n            radius_max_pixels: Maximum radius in pixels.\n            line_width_min_pixels: Minimum stroke width.\n            stroked: Whether to draw stroke.\n            filled: Whether to fill points.\n            pickable: Whether layer responds to hover/click.\n            opacity: Layer opacity.\n            **kwargs: Additional layer props.\n        \"\"\"\n        layer_id = name or f\"scatterplot-{len(self._deck_layers)}\"\n        processed_data = self._process_deck_data(data)\n\n        self.call_js_method(\n            \"addScatterplotLayer\",\n            id=layer_id,\n            data=processed_data,\n            getPosition=get_position,\n            getRadius=get_radius,\n            getFillColor=get_fill_color or [51, 136, 255, 200],\n            getLineColor=get_line_color or [255, 255, 255, 255],\n            radiusScale=radius_scale,\n            radiusMinPixels=radius_min_pixels,\n            radiusMaxPixels=radius_max_pixels,\n            lineWidthMinPixels=line_width_min_pixels,\n            stroked=stroked,\n            filled=filled,\n            pickable=pickable,\n            opacity=opacity,\n            **kwargs,\n        )\n\n        self._deck_layers = {\n            **self._deck_layers,\n            layer_id: {\"type\": \"ScatterplotLayer\", \"id\": layer_id},\n        }\n\n    # -------------------------------------------------------------------------\n    # DeckGL Arc Layer\n    # -------------------------------------------------------------------------\n\n    def add_arc_layer(\n        self,\n        data: Any,\n        name: Optional[str] = None,\n        get_source_position: Union[str, Callable] = \"source\",\n        get_target_position: Union[str, Callable] = \"target\",\n        get_source_color: Union[List[int], str, Callable] = None,\n        get_target_color: Union[List[int], str, Callable] = None,\n        get_width: Union[float, str, Callable] = 1,\n        pickable: bool = True,\n        opacity: float = 0.8,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add an arc layer for origin-destination visualization.\n\n        Args:\n            data: Array of data objects with source/target coordinates.\n            name: Layer ID.\n            get_source_position: Accessor for source position [lng, lat].\n            get_target_position: Accessor for target position [lng, lat].\n            get_source_color: Accessor for source color [r, g, b, a].\n            get_target_color: Accessor for target color [r, g, b, a].\n            get_width: Accessor for arc width.\n            pickable: Whether layer responds to hover/click.\n            opacity: Layer opacity.\n            **kwargs: Additional layer props.\n        \"\"\"\n        layer_id = name or f\"arc-{len(self._deck_layers)}\"\n        processed_data = self._process_deck_data(data)\n\n        self.call_js_method(\n            \"addArcLayer\",\n            id=layer_id,\n            data=processed_data,\n            getSourcePosition=get_source_position,\n            getTargetPosition=get_target_position,\n            getSourceColor=get_source_color or [51, 136, 255, 255],\n            getTargetColor=get_target_color or [255, 136, 51, 255],\n            getWidth=get_width,\n            pickable=pickable,\n            opacity=opacity,\n            **kwargs,\n        )\n\n        self._deck_layers = {\n            **self._deck_layers,\n            layer_id: {\"type\": \"ArcLayer\", \"id\": layer_id},\n        }\n\n    # -------------------------------------------------------------------------\n    # DeckGL Point Cloud Layer\n    # -------------------------------------------------------------------------\n\n    def add_point_cloud_layer(\n        self,\n        data: Any,\n        name: Optional[str] = None,\n        get_position: Union[str, Callable] = \"position\",\n        get_color: Union[List[int], str, Callable] = None,\n        get_normal: Union[str, Callable] = None,\n        point_size: float = 2,\n        size_units: str = \"pixels\",\n        coordinate_system: Optional[str] = None,\n        coordinate_origin: Optional[List[float]] = None,\n        pickable: bool = True,\n        opacity: float = 1.0,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a point cloud layer for 3D point visualization.\n\n        Renders large point cloud datasets typically from LiDAR or 3D scanning.\n        Supports both 2D and 3D coordinates with optional normal vectors for\n        lighting effects.\n\n        Args:\n            data: Array of point data with position [x, y, z] coordinates.\n            name: Layer ID. If None, auto-generated.\n            get_position: Accessor for point position [x, y, z].\n            get_color: Accessor for point color [r, g, b, a].\n            get_normal: Accessor for point normal [nx, ny, nz] for lighting.\n            point_size: Point size in size_units.\n            size_units: Units for point_size ('pixels' or 'meters').\n            coordinate_system: Coordinate system ('CARTESIAN', 'METER_OFFSETS',\n                'LNGLAT', 'LNGLAT_OFFSETS').\n            coordinate_origin: Origin for offset coordinate systems [lng, lat, z].\n            pickable: Whether layer responds to hover/click.\n            opacity: Layer opacity (0-1).\n            **kwargs: Additional PointCloudLayer props.\n\n        Example:\n            &gt;&gt;&gt; m = DeckGLMap()\n            &gt;&gt;&gt; points = [\n            ...     {\"position\": [-122.4, 37.8, 100], \"color\": [255, 0, 0]},\n            ...     {\"position\": [-122.5, 37.7, 200], \"color\": [0, 255, 0]},\n            ... ]\n            &gt;&gt;&gt; m.add_point_cloud_layer(\n            ...     data=points,\n            ...     point_size=5,\n            ...     get_color=\"color\"\n            ... )\n        \"\"\"\n        layer_id = name or f\"pointcloud-{len(self._deck_layers)}\"\n        processed_data = self._process_deck_data(data)\n\n        layer_kwargs = {\n            \"id\": layer_id,\n            \"data\": processed_data,\n            \"getPosition\": get_position,\n            \"getColor\": get_color or [255, 255, 255, 255],\n            \"pointSize\": point_size,\n            \"sizeUnits\": size_units,\n            \"pickable\": pickable,\n            \"opacity\": opacity,\n        }\n\n        if get_normal is not None:\n            layer_kwargs[\"getNormal\"] = get_normal\n\n        if coordinate_system is not None:\n            layer_kwargs[\"coordinateSystem\"] = coordinate_system\n\n        if coordinate_origin is not None:\n            layer_kwargs[\"coordinateOrigin\"] = coordinate_origin\n\n        layer_kwargs.update(kwargs)\n        self.call_js_method(\"addPointCloudLayer\", **layer_kwargs)\n\n        self._deck_layers = {\n            **self._deck_layers,\n            layer_id: {\"type\": \"PointCloudLayer\", \"id\": layer_id},\n        }\n\n    # -------------------------------------------------------------------------\n    # DeckGL Path Layer\n    # -------------------------------------------------------------------------\n\n    def add_path_layer(\n        self,\n        data: Any,\n        name: Optional[str] = None,\n        get_path: Union[str, Callable] = \"path\",\n        get_color: Union[List[int], str, Callable] = None,\n        get_width: Union[float, str, Callable] = 1,\n        width_scale: float = 1,\n        width_min_pixels: float = 1,\n        pickable: bool = True,\n        opacity: float = 0.8,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a path layer for polyline visualization.\n\n        Args:\n            data: Array of data objects with path coordinates.\n            name: Layer ID.\n            get_path: Accessor for path coordinates [[lng, lat], ...].\n            get_color: Accessor for path color [r, g, b, a].\n            get_width: Accessor for path width.\n            width_scale: Global width multiplier.\n            width_min_pixels: Minimum width in pixels.\n            pickable: Whether layer responds to hover/click.\n            opacity: Layer opacity.\n            **kwargs: Additional layer props.\n        \"\"\"\n        layer_id = name or f\"path-{len(self._deck_layers)}\"\n        processed_data = self._process_deck_data(data)\n\n        self.call_js_method(\n            \"addPathLayer\",\n            id=layer_id,\n            data=processed_data,\n            getPath=get_path,\n            getColor=get_color or [51, 136, 255, 200],\n            getWidth=get_width,\n            widthScale=width_scale,\n            widthMinPixels=width_min_pixels,\n            pickable=pickable,\n            opacity=opacity,\n            **kwargs,\n        )\n\n        self._deck_layers = {\n            **self._deck_layers,\n            layer_id: {\"type\": \"PathLayer\", \"id\": layer_id},\n        }\n\n    # -------------------------------------------------------------------------\n    # DeckGL Polygon Layer\n    # -------------------------------------------------------------------------\n\n    def add_polygon_layer(\n        self,\n        data: Any,\n        name: Optional[str] = None,\n        get_polygon: Union[str, Callable] = \"polygon\",\n        get_fill_color: Union[List[int], str, Callable] = None,\n        get_line_color: Union[List[int], str, Callable] = None,\n        get_line_width: Union[float, str, Callable] = 1,\n        get_elevation: Union[float, str, Callable] = 0,\n        extruded: bool = False,\n        wireframe: bool = False,\n        filled: bool = True,\n        stroked: bool = True,\n        line_width_min_pixels: float = 1,\n        pickable: bool = True,\n        opacity: float = 0.5,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a polygon layer for filled polygon visualization.\n\n        Args:\n            data: Array of data objects with polygon coordinates.\n            name: Layer ID.\n            get_polygon: Accessor for polygon coordinates.\n            get_fill_color: Accessor for fill color [r, g, b, a].\n            get_line_color: Accessor for stroke color [r, g, b, a].\n            get_line_width: Accessor for stroke width.\n            get_elevation: Accessor for 3D extrusion height.\n            extruded: Whether to render as 3D polygons.\n            wireframe: Whether to render wireframe (extruded only).\n            filled: Whether to fill polygons.\n            stroked: Whether to draw stroke.\n            line_width_min_pixels: Minimum stroke width.\n            pickable: Whether layer responds to hover/click.\n            opacity: Layer opacity.\n            **kwargs: Additional layer props.\n        \"\"\"\n        layer_id = name or f\"polygon-{len(self._deck_layers)}\"\n        processed_data = self._process_deck_data(data)\n\n        self.call_js_method(\n            \"addPolygonLayer\",\n            id=layer_id,\n            data=processed_data,\n            getPolygon=get_polygon,\n            getFillColor=get_fill_color or [51, 136, 255, 128],\n            getLineColor=get_line_color or [0, 0, 255, 255],\n            getLineWidth=get_line_width,\n            getElevation=get_elevation,\n            extruded=extruded,\n            wireframe=wireframe,\n            filled=filled,\n            stroked=stroked,\n            lineWidthMinPixels=line_width_min_pixels,\n            pickable=pickable,\n            opacity=opacity,\n            **kwargs,\n        )\n\n        self._deck_layers = {\n            **self._deck_layers,\n            layer_id: {\"type\": \"PolygonLayer\", \"id\": layer_id},\n        }\n\n    # -------------------------------------------------------------------------\n    # DeckGL Hexagon Layer\n    # -------------------------------------------------------------------------\n\n    def add_hexagon_layer(\n        self,\n        data: Any,\n        name: Optional[str] = None,\n        get_position: Union[str, Callable] = \"coordinates\",\n        radius: float = 1000,\n        elevation_scale: float = 4,\n        extruded: bool = True,\n        color_range: Optional[List[List[int]]] = None,\n        pickable: bool = True,\n        opacity: float = 0.8,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a hexagon layer for hexbin aggregation visualization.\n\n        Args:\n            data: Array of data objects with position coordinates.\n            name: Layer ID.\n            get_position: Accessor for point position [lng, lat].\n            radius: Hexagon radius in meters.\n            elevation_scale: Elevation multiplier for 3D.\n            extruded: Whether to render as 3D hexagons.\n            color_range: Color gradient for aggregation [[r, g, b], ...].\n            pickable: Whether layer responds to hover/click.\n            opacity: Layer opacity.\n            **kwargs: Additional layer props.\n        \"\"\"\n        layer_id = name or f\"hexagon-{len(self._deck_layers)}\"\n        processed_data = self._process_deck_data(data)\n\n        default_color_range = [\n            [1, 152, 189],\n            [73, 227, 206],\n            [216, 254, 181],\n            [254, 237, 177],\n            [254, 173, 84],\n            [209, 55, 78],\n        ]\n\n        self.call_js_method(\n            \"addHexagonLayer\",\n            id=layer_id,\n            data=processed_data,\n            getPosition=get_position,\n            radius=radius,\n            elevationScale=elevation_scale,\n            extruded=extruded,\n            colorRange=color_range or default_color_range,\n            pickable=pickable,\n            opacity=opacity,\n            **kwargs,\n        )\n\n        self._deck_layers = {\n            **self._deck_layers,\n            layer_id: {\"type\": \"HexagonLayer\", \"id\": layer_id},\n        }\n\n    # -------------------------------------------------------------------------\n    # DeckGL Heatmap Layer\n    # -------------------------------------------------------------------------\n\n    def add_heatmap_layer(\n        self,\n        data: Any,\n        name: Optional[str] = None,\n        get_position: Union[str, Callable] = \"coordinates\",\n        get_weight: Union[float, str, Callable] = 1,\n        radius_pixels: float = 30,\n        intensity: float = 1,\n        threshold: float = 0.05,\n        color_range: Optional[List[List[int]]] = None,\n        opacity: float = 1,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a heatmap layer for density visualization.\n\n        Args:\n            data: Array of data objects with position coordinates.\n            name: Layer ID.\n            get_position: Accessor for point position [lng, lat].\n            get_weight: Accessor for point weight.\n            radius_pixels: Influence radius in pixels.\n            intensity: Intensity multiplier.\n            threshold: Minimum density threshold.\n            color_range: Color gradient [[r, g, b, a], ...].\n            opacity: Layer opacity.\n            **kwargs: Additional layer props.\n        \"\"\"\n        layer_id = name or f\"heatmap-{len(self._deck_layers)}\"\n        processed_data = self._process_deck_data(data)\n\n        default_color_range = [\n            [255, 255, 178, 25],\n            [254, 217, 118, 85],\n            [254, 178, 76, 127],\n            [253, 141, 60, 170],\n            [240, 59, 32, 212],\n            [189, 0, 38, 255],\n        ]\n\n        self.call_js_method(\n            \"addHeatmapLayer\",\n            id=layer_id,\n            data=processed_data,\n            getPosition=get_position,\n            getWeight=get_weight,\n            radiusPixels=radius_pixels,\n            intensity=intensity,\n            threshold=threshold,\n            colorRange=color_range or default_color_range,\n            opacity=opacity,\n            **kwargs,\n        )\n\n        self._deck_layers = {\n            **self._deck_layers,\n            layer_id: {\"type\": \"HeatmapLayer\", \"id\": layer_id},\n        }\n\n    # -------------------------------------------------------------------------\n    # DeckGL Grid Layer\n    # -------------------------------------------------------------------------\n\n    def add_grid_layer(\n        self,\n        data: Any,\n        name: Optional[str] = None,\n        get_position: Union[str, Callable] = \"coordinates\",\n        cell_size: float = 200,\n        elevation_scale: float = 4,\n        extruded: bool = True,\n        color_range: Optional[List[List[int]]] = None,\n        pickable: bool = True,\n        opacity: float = 0.8,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a grid layer for square grid aggregation visualization.\n\n        Args:\n            data: Array of data objects with position coordinates.\n            name: Layer ID.\n            get_position: Accessor for point position [lng, lat].\n            cell_size: Grid cell size in meters.\n            elevation_scale: Elevation multiplier for 3D.\n            extruded: Whether to render as 3D cells.\n            color_range: Color gradient [[r, g, b], ...].\n            pickable: Whether layer responds to hover/click.\n            opacity: Layer opacity.\n            **kwargs: Additional layer props.\n        \"\"\"\n        layer_id = name or f\"grid-{len(self._deck_layers)}\"\n        processed_data = self._process_deck_data(data)\n\n        default_color_range = [\n            [1, 152, 189],\n            [73, 227, 206],\n            [216, 254, 181],\n            [254, 237, 177],\n            [254, 173, 84],\n            [209, 55, 78],\n        ]\n\n        self.call_js_method(\n            \"addGridLayer\",\n            id=layer_id,\n            data=processed_data,\n            getPosition=get_position,\n            cellSize=cell_size,\n            elevationScale=elevation_scale,\n            extruded=extruded,\n            colorRange=color_range or default_color_range,\n            pickable=pickable,\n            opacity=opacity,\n            **kwargs,\n        )\n\n        self._deck_layers = {\n            **self._deck_layers,\n            layer_id: {\"type\": \"GridLayer\", \"id\": layer_id},\n        }\n\n    # -------------------------------------------------------------------------\n    # DeckGL Icon Layer\n    # -------------------------------------------------------------------------\n\n    def add_icon_layer(\n        self,\n        data: Any,\n        name: Optional[str] = None,\n        get_position: Union[str, Callable] = \"coordinates\",\n        get_icon: Union[str, Callable] = \"icon\",\n        get_size: Union[float, str, Callable] = 20,\n        get_color: Union[List[int], str, Callable] = None,\n        icon_atlas: Optional[str] = None,\n        icon_mapping: Optional[Dict] = None,\n        pickable: bool = True,\n        opacity: float = 1,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add an icon layer for custom marker visualization.\n\n        Args:\n            data: Array of data objects with position coordinates.\n            name: Layer ID.\n            get_position: Accessor for icon position [lng, lat].\n            get_icon: Accessor for icon name in icon_mapping.\n            get_size: Accessor for icon size.\n            get_color: Accessor for icon tint color [r, g, b, a].\n            icon_atlas: URL to icon atlas image.\n            icon_mapping: Dict mapping icon names to atlas coordinates.\n            pickable: Whether layer responds to hover/click.\n            opacity: Layer opacity.\n            **kwargs: Additional layer props.\n        \"\"\"\n        layer_id = name or f\"icon-{len(self._deck_layers)}\"\n        processed_data = self._process_deck_data(data)\n\n        self.call_js_method(\n            \"addIconLayer\",\n            id=layer_id,\n            data=processed_data,\n            getPosition=get_position,\n            getIcon=get_icon,\n            getSize=get_size,\n            getColor=get_color or [255, 255, 255, 255],\n            iconAtlas=icon_atlas,\n            iconMapping=icon_mapping,\n            pickable=pickable,\n            opacity=opacity,\n            **kwargs,\n        )\n\n        self._deck_layers = {\n            **self._deck_layers,\n            layer_id: {\"type\": \"IconLayer\", \"id\": layer_id},\n        }\n\n    # -------------------------------------------------------------------------\n    # DeckGL Text Layer\n    # -------------------------------------------------------------------------\n\n    def add_text_layer(\n        self,\n        data: Any,\n        name: Optional[str] = None,\n        get_position: Union[str, Callable] = \"coordinates\",\n        get_text: Union[str, Callable] = \"text\",\n        get_size: Union[float, str, Callable] = 12,\n        get_color: Union[List[int], str, Callable] = None,\n        get_angle: Union[float, str, Callable] = 0,\n        text_anchor: str = \"middle\",\n        alignment_baseline: str = \"center\",\n        pickable: bool = True,\n        opacity: float = 1,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a text layer for label visualization.\n\n        Args:\n            data: Array of data objects with position and text.\n            name: Layer ID.\n            get_position: Accessor for text position [lng, lat].\n            get_text: Accessor for text content.\n            get_size: Accessor for text size.\n            get_color: Accessor for text color [r, g, b, a].\n            get_angle: Accessor for text rotation in degrees.\n            text_anchor: Horizontal alignment ('start', 'middle', 'end').\n            alignment_baseline: Vertical alignment ('top', 'center', 'bottom').\n            pickable: Whether layer responds to hover/click.\n            opacity: Layer opacity.\n            **kwargs: Additional layer props.\n        \"\"\"\n        layer_id = name or f\"text-{len(self._deck_layers)}\"\n        processed_data = self._process_deck_data(data)\n\n        self.call_js_method(\n            \"addTextLayer\",\n            id=layer_id,\n            data=processed_data,\n            getPosition=get_position,\n            getText=get_text,\n            getSize=get_size,\n            getColor=get_color or [0, 0, 0, 255],\n            getAngle=get_angle,\n            getTextAnchor=text_anchor,\n            getAlignmentBaseline=alignment_baseline,\n            pickable=pickable,\n            opacity=opacity,\n            **kwargs,\n        )\n\n        self._deck_layers = {\n            **self._deck_layers,\n            layer_id: {\"type\": \"TextLayer\", \"id\": layer_id},\n        }\n\n    # -------------------------------------------------------------------------\n    # DeckGL GeoJSON Layer\n    # -------------------------------------------------------------------------\n\n    def add_geojson_layer(\n        self,\n        data: Any,\n        name: Optional[str] = None,\n        get_fill_color: Union[List[int], str, Callable] = None,\n        get_line_color: Union[List[int], str, Callable] = None,\n        get_line_width: Union[float, str, Callable] = 1,\n        get_point_radius: Union[float, str, Callable] = 5,\n        get_elevation: Union[float, str, Callable] = 0,\n        extruded: bool = False,\n        wireframe: bool = False,\n        filled: bool = True,\n        stroked: bool = True,\n        line_width_min_pixels: float = 1,\n        point_radius_min_pixels: float = 2,\n        pickable: bool = True,\n        opacity: float = 0.8,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a GeoJSON layer for rendering GeoJSON features.\n\n        Args:\n            data: GeoJSON object or URL.\n            name: Layer ID.\n            get_fill_color: Accessor for fill color [r, g, b, a].\n            get_line_color: Accessor for stroke color [r, g, b, a].\n            get_line_width: Accessor for stroke width.\n            get_point_radius: Accessor for point radius.\n            get_elevation: Accessor for 3D extrusion height.\n            extruded: Whether to render as 3D features.\n            wireframe: Whether to render wireframe (extruded only).\n            filled: Whether to fill features.\n            stroked: Whether to draw stroke.\n            line_width_min_pixels: Minimum stroke width.\n            point_radius_min_pixels: Minimum point radius.\n            pickable: Whether layer responds to hover/click.\n            opacity: Layer opacity.\n            **kwargs: Additional layer props.\n        \"\"\"\n        layer_id = name or f\"geojson-{len(self._deck_layers)}\"\n        processed_data = self._process_deck_data(data)\n\n        self.call_js_method(\n            \"addGeoJsonLayer\",\n            id=layer_id,\n            data=processed_data,\n            getFillColor=get_fill_color or [51, 136, 255, 128],\n            getLineColor=get_line_color or [0, 0, 0, 255],\n            getLineWidth=get_line_width,\n            getPointRadius=get_point_radius,\n            getElevation=get_elevation,\n            extruded=extruded,\n            wireframe=wireframe,\n            filled=filled,\n            stroked=stroked,\n            lineWidthMinPixels=line_width_min_pixels,\n            pointRadiusMinPixels=point_radius_min_pixels,\n            pickable=pickable,\n            opacity=opacity,\n            **kwargs,\n        )\n\n        self._deck_layers = {\n            **self._deck_layers,\n            layer_id: {\"type\": \"GeoJsonLayer\", \"id\": layer_id},\n        }\n\n    # -------------------------------------------------------------------------\n    # DeckGL Contour Layer\n    # -------------------------------------------------------------------------\n\n    def add_contour_layer(\n        self,\n        data: Any,\n        name: Optional[str] = None,\n        get_position: Union[str, Callable] = \"coordinates\",\n        get_weight: Union[float, str, Callable] = 1,\n        cell_size: float = 200,\n        contours: Optional[List[Dict]] = None,\n        pickable: bool = True,\n        opacity: float = 1,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a contour layer for isoline visualization.\n\n        Args:\n            data: Array of data objects with position coordinates.\n            name: Layer ID.\n            get_position: Accessor for point position [lng, lat].\n            get_weight: Accessor for point weight.\n            cell_size: Grid cell size for aggregation.\n            contours: Contour definitions [{threshold, color, strokeWidth}, ...].\n            pickable: Whether layer responds to hover/click.\n            opacity: Layer opacity.\n            **kwargs: Additional layer props.\n        \"\"\"\n        layer_id = name or f\"contour-{len(self._deck_layers)}\"\n        processed_data = self._process_deck_data(data)\n\n        default_contours = [\n            {\"threshold\": 1, \"color\": [255, 255, 255], \"strokeWidth\": 1},\n            {\"threshold\": 5, \"color\": [51, 136, 255], \"strokeWidth\": 2},\n            {\"threshold\": 10, \"color\": [0, 0, 255], \"strokeWidth\": 3},\n        ]\n\n        self.call_js_method(\n            \"addContourLayer\",\n            id=layer_id,\n            data=processed_data,\n            getPosition=get_position,\n            getWeight=get_weight,\n            cellSize=cell_size,\n            contours=contours or default_contours,\n            pickable=pickable,\n            opacity=opacity,\n            **kwargs,\n        )\n\n        self._deck_layers = {\n            **self._deck_layers,\n            layer_id: {\"type\": \"ContourLayer\", \"id\": layer_id},\n        }\n\n    # -------------------------------------------------------------------------\n    # DeckGL Screen Grid Layer\n    # -------------------------------------------------------------------------\n\n    def add_screen_grid_layer(\n        self,\n        data: Any,\n        name: Optional[str] = None,\n        get_position: Union[str, Callable] = \"coordinates\",\n        get_weight: Union[float, str, Callable] = 1,\n        cell_size_pixels: float = 50,\n        color_range: Optional[List[List[int]]] = None,\n        pickable: bool = True,\n        opacity: float = 0.8,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a screen grid layer for screen-space grid aggregation.\n\n        Args:\n            data: Array of data objects with position coordinates.\n            name: Layer ID.\n            get_position: Accessor for point position [lng, lat].\n            get_weight: Accessor for point weight.\n            cell_size_pixels: Grid cell size in pixels.\n            color_range: Color gradient [[r, g, b, a], ...].\n            pickable: Whether layer responds to hover/click.\n            opacity: Layer opacity.\n            **kwargs: Additional layer props.\n        \"\"\"\n        layer_id = name or f\"screengrid-{len(self._deck_layers)}\"\n        processed_data = self._process_deck_data(data)\n\n        default_color_range = [\n            [255, 255, 178, 25],\n            [254, 217, 118, 85],\n            [254, 178, 76, 127],\n            [253, 141, 60, 170],\n            [240, 59, 32, 212],\n            [189, 0, 38, 255],\n        ]\n\n        self.call_js_method(\n            \"addScreenGridLayer\",\n            id=layer_id,\n            data=processed_data,\n            getPosition=get_position,\n            getWeight=get_weight,\n            cellSizePixels=cell_size_pixels,\n            colorRange=color_range or default_color_range,\n            pickable=pickable,\n            opacity=opacity,\n            **kwargs,\n        )\n\n        self._deck_layers = {\n            **self._deck_layers,\n            layer_id: {\"type\": \"ScreenGridLayer\", \"id\": layer_id},\n        }\n\n    # -------------------------------------------------------------------------\n    # Generic DeckGL Layer\n    # -------------------------------------------------------------------------\n\n    def add_deckgl_layer(\n        self,\n        layer_type: str,\n        data: Any,\n        name: Optional[str] = None,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a generic deck.gl layer to the map.\n\n        This method provides a flexible way to add any supported deck.gl layer\n        type using a single interface. For commonly used layers, prefer the\n        specific methods (e.g., add_scatterplot_layer) for better IDE support.\n\n        Args:\n            layer_type: The deck.gl layer type. Supported types include:\n                'ScatterplotLayer', 'ArcLayer', 'PathLayer', 'PolygonLayer',\n                'HexagonLayer', 'HeatmapLayer', 'GridLayer', 'IconLayer',\n                'TextLayer', 'GeoJsonLayer', 'ContourLayer', 'ScreenGridLayer',\n                'PointCloudLayer', 'TripsLayer', 'LineLayer'.\n            data: Array of data objects or GeoJSON.\n            name: Layer ID. If None, auto-generated from layer_type.\n            **kwargs: Layer-specific properties passed directly to deck.gl.\n                Common properties include:\n                - opacity: Layer opacity (0-1)\n                - pickable: Whether layer responds to hover/click\n                - getPosition: Accessor for position coordinates\n                - getColor/getFillColor/getLineColor: Color accessors\n\n        Example:\n            &gt;&gt;&gt; m = DeckGLMap()\n            &gt;&gt;&gt; # Add a TripsLayer with animation\n            &gt;&gt;&gt; m.add_deckgl_layer(\n            ...     'TripsLayer',\n            ...     data=trips_data,\n            ...     getPath='waypoints',\n            ...     getTimestamps='timestamps',\n            ...     getColor=[253, 128, 93],\n            ...     trailLength=180,\n            ... )\n            &gt;&gt;&gt; # Add a LineLayer\n            &gt;&gt;&gt; m.add_deckgl_layer(\n            ...     'LineLayer',\n            ...     data=lines_data,\n            ...     getSourcePosition='source',\n            ...     getTargetPosition='target',\n            ...     getColor=[0, 128, 255],\n            ... )\n        \"\"\"\n        # Normalize layer type and create prefix\n        layer_type_clean = layer_type.replace(\"Layer\", \"\")\n        prefix = layer_type_clean.lower()\n        layer_id = name or f\"{prefix}-{len(self._deck_layers)}\"\n        processed_data = self._process_deck_data(data)\n\n        self.call_js_method(\n            \"addDeckGLLayer\",\n            layerType=layer_type,\n            id=layer_id,\n            data=processed_data,\n            **kwargs,\n        )\n\n        self._deck_layers = {\n            **self._deck_layers,\n            layer_id: {\"type\": layer_type, \"id\": layer_id},\n        }\n\n    # -------------------------------------------------------------------------\n    # DeckGL Trips Layer\n    # -------------------------------------------------------------------------\n\n    def add_trips_layer(\n        self,\n        data: Any,\n        name: Optional[str] = None,\n        get_path: Union[str, Callable] = \"waypoints\",\n        get_timestamps: Union[str, Callable] = \"timestamps\",\n        get_color: Union[List[int], str, Callable] = None,\n        width_min_pixels: float = 2,\n        trail_length: float = 180,\n        current_time: float = 0,\n        pickable: bool = True,\n        opacity: float = 0.8,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a trips layer for animated path visualization.\n\n        The TripsLayer renders animated paths showing movement over time,\n        ideal for visualizing vehicle routes, migration patterns, or any\n        time-based trajectory data.\n\n        Args:\n            data: Array of trip objects with waypoints and timestamps.\n            name: Layer ID. If None, auto-generated.\n            get_path: Accessor for waypoint coordinates [[lng, lat], ...].\n            get_timestamps: Accessor for timestamps at each waypoint.\n            get_color: Accessor for trip color [r, g, b] or [r, g, b, a].\n            width_min_pixels: Minimum trail width in pixels.\n            trail_length: Trail length in timestamp units.\n            current_time: Current animation time.\n            pickable: Whether layer responds to hover/click.\n            opacity: Layer opacity (0-1).\n            **kwargs: Additional TripsLayer props.\n\n        Example:\n            &gt;&gt;&gt; m = DeckGLMap()\n            &gt;&gt;&gt; trips = [\n            ...     {\n            ...         \"waypoints\": [[-122.4, 37.8], [-122.5, 37.7], [-122.6, 37.8]],\n            ...         \"timestamps\": [0, 50, 100]\n            ...     }\n            ... ]\n            &gt;&gt;&gt; m.add_trips_layer(\n            ...     data=trips,\n            ...     trail_length=180,\n            ...     current_time=50,\n            ... )\n        \"\"\"\n        layer_id = name or f\"trips-{len(self._deck_layers)}\"\n        processed_data = self._process_deck_data(data)\n\n        self.call_js_method(\n            \"addTripsLayer\",\n            id=layer_id,\n            data=processed_data,\n            getPath=get_path,\n            getTimestamps=get_timestamps,\n            getColor=get_color or [253, 128, 93],\n            widthMinPixels=width_min_pixels,\n            trailLength=trail_length,\n            currentTime=current_time,\n            pickable=pickable,\n            opacity=opacity,\n            **kwargs,\n        )\n\n        self._deck_layers = {\n            **self._deck_layers,\n            layer_id: {\"type\": \"TripsLayer\", \"id\": layer_id},\n        }\n\n    # -------------------------------------------------------------------------\n    # DeckGL Line Layer\n    # -------------------------------------------------------------------------\n\n    def add_line_layer(\n        self,\n        data: Any,\n        name: Optional[str] = None,\n        get_source_position: Union[str, Callable] = \"sourcePosition\",\n        get_target_position: Union[str, Callable] = \"targetPosition\",\n        get_color: Union[List[int], str, Callable] = None,\n        get_width: Union[float, str, Callable] = 1,\n        width_min_pixels: float = 1,\n        pickable: bool = True,\n        opacity: float = 0.8,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a line layer for simple line segment visualization.\n\n        The LineLayer renders straight line segments between source and\n        target positions. Unlike ArcLayer, lines are drawn directly\n        without curvature.\n\n        Args:\n            data: Array of line objects with source/target positions.\n            name: Layer ID. If None, auto-generated.\n            get_source_position: Accessor for source position [lng, lat].\n            get_target_position: Accessor for target position [lng, lat].\n            get_color: Accessor for line color [r, g, b] or [r, g, b, a].\n            get_width: Accessor for line width.\n            width_min_pixels: Minimum line width in pixels.\n            pickable: Whether layer responds to hover/click.\n            opacity: Layer opacity (0-1).\n            **kwargs: Additional LineLayer props.\n\n        Example:\n            &gt;&gt;&gt; m = DeckGLMap()\n            &gt;&gt;&gt; lines = [\n            ...     {\"sourcePosition\": [-122.4, 37.8], \"targetPosition\": [-122.5, 37.7]},\n            ...     {\"sourcePosition\": [-122.5, 37.7], \"targetPosition\": [-122.6, 37.8]},\n            ... ]\n            &gt;&gt;&gt; m.add_line_layer(\n            ...     data=lines,\n            ...     get_color=[0, 128, 255],\n            ...     get_width=2,\n            ... )\n        \"\"\"\n        layer_id = name or f\"line-{len(self._deck_layers)}\"\n        processed_data = self._process_deck_data(data)\n\n        self.call_js_method(\n            \"addLineLayer\",\n            id=layer_id,\n            data=processed_data,\n            getSourcePosition=get_source_position,\n            getTargetPosition=get_target_position,\n            getColor=get_color or [51, 136, 255, 200],\n            getWidth=get_width,\n            widthMinPixels=width_min_pixels,\n            pickable=pickable,\n            opacity=opacity,\n            **kwargs,\n        )\n\n        self._deck_layers = {\n            **self._deck_layers,\n            layer_id: {\"type\": \"LineLayer\", \"id\": layer_id},\n        }\n\n    # -------------------------------------------------------------------------\n    # DeckGL COG Layer\n    # -------------------------------------------------------------------------\n\n    def add_cog_layer(\n        self,\n        url: str,\n        name: Optional[str] = None,\n        opacity: float = 1.0,\n        visible: bool = True,\n        debug: bool = False,\n        debug_opacity: float = 0.25,\n        max_error: float = 0.125,\n        fit_bounds: bool = True,\n        before_id: Optional[str] = None,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a Cloud Optimized GeoTIFF (COG) layer using @developmentseed/deck.gl-geotiff.\n\n        This method renders COG files directly in the browser using GPU-accelerated\n        deck.gl rendering with automatic reprojection support.\n\n        Args:\n            url: URL to the Cloud Optimized GeoTIFF file.\n            name: Layer ID. If None, auto-generated.\n            opacity: Layer opacity (0-1).\n            visible: Whether layer is visible.\n            debug: Show reprojection mesh for debugging.\n            debug_opacity: Opacity of debug mesh (0-1).\n            max_error: Maximum reprojection error in pixels. Lower values\n                create denser mesh for better accuracy.\n            fit_bounds: Whether to fit map to COG bounds after loading.\n            before_id: ID of layer to insert before.\n            **kwargs: Additional COGLayer props.\n\n        Example:\n            &gt;&gt;&gt; m = DeckGLMap()\n            &gt;&gt;&gt; m.add_cog_layer(\n            ...     \"https://example.com/landcover.tif\",\n            ...     name=\"landcover\",\n            ...     opacity=0.8\n            ... )\n        \"\"\"\n        # Use a monotonically increasing counter to avoid ID collisions when layers are removed.\n        counter = getattr(self, \"_cog_layer_counter\", 0)\n        layer_id = name or f\"cog-{counter}\"\n        self._cog_layer_counter = counter + 1\n\n        self.call_js_method(\n            \"addCOGLayer\",\n            id=layer_id,\n            geotiff=url,\n            opacity=opacity,\n            visible=visible,\n            debug=debug,\n            debugOpacity=debug_opacity,\n            maxError=max_error,\n            fitBounds=fit_bounds,\n            beforeId=before_id,\n            **kwargs,\n        )\n\n        self._deck_layers = {\n            **self._deck_layers,\n            layer_id: {\"type\": \"COGLayer\", \"id\": layer_id, \"url\": url},\n        }\n\n    # -------------------------------------------------------------------------\n    # New DeckGL Layer Types\n    # -------------------------------------------------------------------------\n\n    def add_bitmap_layer(\n        self,\n        image: str,\n        bounds: List[float],\n        name: Optional[str] = None,\n        opacity: float = 1.0,\n        visible: bool = True,\n        pickable: bool = False,\n        desaturate: float = 0,\n        transparent_color: Optional[List[int]] = None,\n        tint_color: Optional[List[int]] = None,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a bitmap layer for raster image overlay.\n\n        Args:\n            image: URL or data URI of the image.\n            bounds: Bounding box [west, south, east, north].\n            name: Layer ID.\n            opacity: Layer opacity (0-1).\n            visible: Whether layer is visible.\n            pickable: Whether layer responds to hover/click.\n            desaturate: Desaturation amount (0-1).\n            transparent_color: Color to make transparent [r, g, b, a].\n            tint_color: Color to tint the image [r, g, b].\n            **kwargs: Additional BitmapLayer props.\n        \"\"\"\n        layer_id = name or f\"bitmap-{len(self._deck_layers)}\"\n\n        self.call_js_method(\n            \"addBitmapLayer\",\n            id=layer_id,\n            image=image,\n            bounds=bounds,\n            opacity=opacity,\n            visible=visible,\n            pickable=pickable,\n            desaturate=desaturate,\n            transparentColor=transparent_color or [0, 0, 0, 0],\n            tintColor=tint_color or [255, 255, 255],\n            **kwargs,\n        )\n\n        self._deck_layers = {\n            **self._deck_layers,\n            layer_id: {\"type\": \"BitmapLayer\", \"id\": layer_id},\n        }\n\n    def add_column_layer(\n        self,\n        data: Any,\n        name: Optional[str] = None,\n        get_position: Union[str, Callable] = \"coordinates\",\n        get_fill_color: Union[List[int], str, Callable] = None,\n        get_line_color: Union[List[int], str, Callable] = None,\n        get_elevation: Union[float, str, Callable] = 1000,\n        radius: float = 1000,\n        disk_resolution: int = 20,\n        elevation_scale: float = 1,\n        coverage: float = 1,\n        extruded: bool = True,\n        filled: bool = True,\n        stroked: bool = False,\n        wireframe: bool = False,\n        pickable: bool = True,\n        opacity: float = 0.8,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a column layer for 3D column/bar visualization.\n\n        Args:\n            data: Array of data objects with position coordinates.\n            name: Layer ID.\n            get_position: Accessor for column position [lng, lat].\n            get_fill_color: Accessor for fill color [r, g, b, a].\n            get_line_color: Accessor for stroke color [r, g, b, a].\n            get_elevation: Accessor for column height.\n            radius: Column radius in meters.\n            disk_resolution: Number of sides for column polygon.\n            elevation_scale: Elevation multiplier.\n            coverage: Column coverage (0-1).\n            extruded: Whether to extrude columns.\n            filled: Whether to fill columns.\n            stroked: Whether to stroke columns.\n            wireframe: Whether to render as wireframe.\n            pickable: Whether layer responds to hover/click.\n            opacity: Layer opacity.\n            **kwargs: Additional ColumnLayer props.\n        \"\"\"\n        layer_id = name or f\"column-{len(self._deck_layers)}\"\n        processed_data = self._process_deck_data(data)\n\n        self.call_js_method(\n            \"addColumnLayer\",\n            id=layer_id,\n            data=processed_data,\n            getPosition=get_position,\n            getFillColor=get_fill_color or [255, 140, 0, 200],\n            getLineColor=get_line_color or [0, 0, 0, 255],\n            getElevation=get_elevation,\n            radius=radius,\n            diskResolution=disk_resolution,\n            elevationScale=elevation_scale,\n            coverage=coverage,\n            extruded=extruded,\n            filled=filled,\n            stroked=stroked,\n            wireframe=wireframe,\n            pickable=pickable,\n            opacity=opacity,\n            **kwargs,\n        )\n\n        self._deck_layers = {\n            **self._deck_layers,\n            layer_id: {\"type\": \"ColumnLayer\", \"id\": layer_id},\n        }\n\n    def add_grid_cell_layer(\n        self,\n        data: Any,\n        name: Optional[str] = None,\n        get_position: Union[str, Callable] = \"coordinates\",\n        get_color: Union[List[int], str, Callable] = None,\n        get_elevation: Union[float, str, Callable] = 1000,\n        cell_size: float = 200,\n        coverage: float = 1,\n        elevation_scale: float = 1,\n        extruded: bool = True,\n        pickable: bool = True,\n        opacity: float = 0.8,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a grid cell layer for pre-aggregated grid visualization.\n\n        Args:\n            data: Array of data objects with position coordinates.\n            name: Layer ID.\n            get_position: Accessor for cell position [lng, lat].\n            get_color: Accessor for cell color [r, g, b, a].\n            get_elevation: Accessor for cell height.\n            cell_size: Cell size in meters.\n            coverage: Cell coverage (0-1).\n            elevation_scale: Elevation multiplier.\n            extruded: Whether to extrude cells.\n            pickable: Whether layer responds to hover/click.\n            opacity: Layer opacity.\n            **kwargs: Additional GridCellLayer props.\n        \"\"\"\n        layer_id = name or f\"gridcell-{len(self._deck_layers)}\"\n        processed_data = self._process_deck_data(data)\n\n        self.call_js_method(\n            \"addGridCellLayer\",\n            id=layer_id,\n            data=processed_data,\n            getPosition=get_position,\n            getColor=get_color or [255, 140, 0, 200],\n            getElevation=get_elevation,\n            cellSize=cell_size,\n            coverage=coverage,\n            elevationScale=elevation_scale,\n            extruded=extruded,\n            pickable=pickable,\n            opacity=opacity,\n            **kwargs,\n        )\n\n        self._deck_layers = {\n            **self._deck_layers,\n            layer_id: {\"type\": \"GridCellLayer\", \"id\": layer_id},\n        }\n\n    def add_solid_polygon_layer(\n        self,\n        data: Any,\n        name: Optional[str] = None,\n        get_polygon: Union[str, Callable] = \"polygon\",\n        get_fill_color: Union[List[int], str, Callable] = None,\n        get_line_color: Union[List[int], str, Callable] = None,\n        get_elevation: Union[float, str, Callable] = 0,\n        filled: bool = True,\n        extruded: bool = False,\n        wireframe: bool = False,\n        elevation_scale: float = 1,\n        pickable: bool = True,\n        opacity: float = 0.8,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a solid polygon layer for filled polygon visualization.\n\n        Args:\n            data: Array of data objects with polygon coordinates.\n            name: Layer ID.\n            get_polygon: Accessor for polygon coordinates.\n            get_fill_color: Accessor for fill color [r, g, b, a].\n            get_line_color: Accessor for stroke color [r, g, b, a].\n            get_elevation: Accessor for 3D extrusion height.\n            filled: Whether to fill polygons.\n            extruded: Whether to render as 3D polygons.\n            wireframe: Whether to render wireframe.\n            elevation_scale: Elevation multiplier.\n            pickable: Whether layer responds to hover/click.\n            opacity: Layer opacity.\n            **kwargs: Additional SolidPolygonLayer props.\n        \"\"\"\n        layer_id = name or f\"solidpolygon-{len(self._deck_layers)}\"\n        processed_data = self._process_deck_data(data)\n\n        self.call_js_method(\n            \"addSolidPolygonLayer\",\n            id=layer_id,\n            data=processed_data,\n            getPolygon=get_polygon,\n            getFillColor=get_fill_color or [51, 136, 255, 128],\n            getLineColor=get_line_color or [0, 0, 0, 255],\n            getElevation=get_elevation,\n            filled=filled,\n            extruded=extruded,\n            wireframe=wireframe,\n            elevationScale=elevation_scale,\n            pickable=pickable,\n            opacity=opacity,\n            **kwargs,\n        )\n\n        self._deck_layers = {\n            **self._deck_layers,\n            layer_id: {\"type\": \"SolidPolygonLayer\", \"id\": layer_id},\n        }\n\n    def add_tile_layer(\n        self,\n        data: Union[str, List[str]],\n        name: Optional[str] = None,\n        min_zoom: int = 0,\n        max_zoom: int = 19,\n        tile_size: int = 256,\n        pickable: bool = False,\n        visible: bool = True,\n        opacity: float = 1.0,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a tile layer for raster tile visualization.\n\n        Args:\n            data: Tile URL template with {z}/{x}/{y} placeholders.\n            name: Layer ID.\n            min_zoom: Minimum zoom level.\n            max_zoom: Maximum zoom level.\n            tile_size: Tile size in pixels.\n            pickable: Whether layer responds to hover/click.\n            visible: Whether layer is visible.\n            opacity: Layer opacity (0-1).\n            **kwargs: Additional TileLayer props.\n        \"\"\"\n        layer_id = name or f\"tile-{len(self._deck_layers)}\"\n\n        self.call_js_method(\n            \"addTileLayer\",\n            id=layer_id,\n            data=data,\n            minZoom=min_zoom,\n            maxZoom=max_zoom,\n            tileSize=tile_size,\n            pickable=pickable,\n            visible=visible,\n            opacity=opacity,\n            **kwargs,\n        )\n\n        self._deck_layers = {\n            **self._deck_layers,\n            layer_id: {\"type\": \"TileLayer\", \"id\": layer_id},\n        }\n\n    def add_mvt_layer(\n        self,\n        data: Union[str, List[str]],\n        name: Optional[str] = None,\n        min_zoom: int = 0,\n        max_zoom: int = 14,\n        binary: bool = True,\n        get_fill_color: Union[List[int], str, Callable] = None,\n        get_line_color: Union[List[int], str, Callable] = None,\n        get_line_width: Union[float, str, Callable] = 1,\n        get_point_radius: Union[float, str, Callable] = 5,\n        line_width_min_pixels: float = 1,\n        point_radius_min_pixels: float = 2,\n        pickable: bool = True,\n        visible: bool = True,\n        opacity: float = 1.0,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a Mapbox Vector Tile (MVT) layer.\n\n        Args:\n            data: MVT tile URL template with {z}/{x}/{y} placeholders.\n            name: Layer ID.\n            min_zoom: Minimum zoom level.\n            max_zoom: Maximum zoom level.\n            binary: Whether to use binary format.\n            get_fill_color: Accessor for fill color [r, g, b, a].\n            get_line_color: Accessor for stroke color [r, g, b, a].\n            get_line_width: Accessor for line width.\n            get_point_radius: Accessor for point radius.\n            line_width_min_pixels: Minimum line width in pixels.\n            point_radius_min_pixels: Minimum point radius in pixels.\n            pickable: Whether layer responds to hover/click.\n            visible: Whether layer is visible.\n            opacity: Layer opacity (0-1).\n            **kwargs: Additional MVTLayer props.\n        \"\"\"\n        layer_id = name or f\"mvt-{len(self._deck_layers)}\"\n\n        self.call_js_method(\n            \"addMVTLayer\",\n            id=layer_id,\n            data=data,\n            minZoom=min_zoom,\n            maxZoom=max_zoom,\n            binary=binary,\n            getFillColor=get_fill_color or [51, 136, 255, 128],\n            getLineColor=get_line_color or [0, 0, 0, 255],\n            getLineWidth=get_line_width,\n            getPointRadius=get_point_radius,\n            lineWidthMinPixels=line_width_min_pixels,\n            pointRadiusMinPixels=point_radius_min_pixels,\n            pickable=pickable,\n            visible=visible,\n            opacity=opacity,\n            **kwargs,\n        )\n\n        self._deck_layers = {\n            **self._deck_layers,\n            layer_id: {\"type\": \"MVTLayer\", \"id\": layer_id},\n        }\n\n    def add_tile3d_layer(\n        self,\n        data: str,\n        name: Optional[str] = None,\n        point_size: float = 1,\n        pickable: bool = True,\n        visible: bool = True,\n        opacity: float = 1.0,\n        load_options: Optional[Dict] = None,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a 3D Tiles layer for 3D building/terrain visualization.\n\n        Args:\n            data: URL to tileset.json.\n            name: Layer ID.\n            point_size: Point size for point cloud tiles.\n            pickable: Whether layer responds to hover/click.\n            visible: Whether layer is visible.\n            opacity: Layer opacity (0-1).\n            load_options: Loader options for tile loading.\n            **kwargs: Additional Tile3DLayer props.\n        \"\"\"\n        layer_id = name or f\"tile3d-{len(self._deck_layers)}\"\n\n        self.call_js_method(\n            \"addTile3DLayer\",\n            id=layer_id,\n            data=data,\n            pointSize=point_size,\n            pickable=pickable,\n            visible=visible,\n            opacity=opacity,\n            loadOptions=load_options or {},\n            **kwargs,\n        )\n\n        self._deck_layers = {\n            **self._deck_layers,\n            layer_id: {\"type\": \"Tile3DLayer\", \"id\": layer_id},\n        }\n\n    def add_terrain_layer(\n        self,\n        elevation_data: Union[str, List[str]],\n        name: Optional[str] = None,\n        texture: Optional[str] = None,\n        mesh_max_error: float = 4.0,\n        bounds: Optional[List[float]] = None,\n        elevation_decoder: Optional[Dict] = None,\n        pickable: bool = False,\n        visible: bool = True,\n        opacity: float = 1.0,\n        wireframe: bool = False,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a terrain layer for 3D terrain visualization.\n\n        Args:\n            elevation_data: URL to elevation tiles (e.g., Mapbox terrain).\n            name: Layer ID.\n            texture: URL to texture tiles for terrain surface.\n            mesh_max_error: Maximum mesh error in meters.\n            bounds: Bounding box [west, south, east, north].\n            elevation_decoder: Decoder for elevation data format.\n            pickable: Whether layer responds to hover/click.\n            visible: Whether layer is visible.\n            opacity: Layer opacity (0-1).\n            wireframe: Whether to render as wireframe.\n            **kwargs: Additional TerrainLayer props.\n        \"\"\"\n        layer_id = name or f\"terrain-{len(self._deck_layers)}\"\n\n        default_decoder = {\n            \"rScaler\": 256,\n            \"gScaler\": 1,\n            \"bScaler\": 1 / 256,\n            \"offset\": -32768,\n        }\n\n        self.call_js_method(\n            \"addTerrainLayer\",\n            id=layer_id,\n            elevationData=elevation_data,\n            texture=texture,\n            meshMaxError=mesh_max_error,\n            bounds=bounds,\n            elevationDecoder=elevation_decoder or default_decoder,\n            pickable=pickable,\n            visible=visible,\n            opacity=opacity,\n            wireframe=wireframe,\n            **kwargs,\n        )\n\n        self._deck_layers = {\n            **self._deck_layers,\n            layer_id: {\"type\": \"TerrainLayer\", \"id\": layer_id},\n        }\n\n    def add_great_circle_layer(\n        self,\n        data: Any,\n        name: Optional[str] = None,\n        get_source_position: Union[str, Callable] = \"source\",\n        get_target_position: Union[str, Callable] = \"target\",\n        get_source_color: Union[List[int], str, Callable] = None,\n        get_target_color: Union[List[int], str, Callable] = None,\n        get_width: Union[float, str, Callable] = 1,\n        width_min_pixels: float = 1,\n        width_max_pixels: float = 100,\n        pickable: bool = True,\n        opacity: float = 0.8,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a great circle layer for geodesic arc visualization.\n\n        Args:\n            data: Array of data objects with source/target coordinates.\n            name: Layer ID.\n            get_source_position: Accessor for source position [lng, lat].\n            get_target_position: Accessor for target position [lng, lat].\n            get_source_color: Accessor for source color [r, g, b, a].\n            get_target_color: Accessor for target color [r, g, b, a].\n            get_width: Accessor for line width.\n            width_min_pixels: Minimum line width in pixels.\n            width_max_pixels: Maximum line width in pixels.\n            pickable: Whether layer responds to hover/click.\n            opacity: Layer opacity.\n            **kwargs: Additional GreatCircleLayer props.\n        \"\"\"\n        layer_id = name or f\"greatcircle-{len(self._deck_layers)}\"\n        processed_data = self._process_deck_data(data)\n\n        self.call_js_method(\n            \"addGreatCircleLayer\",\n            id=layer_id,\n            data=processed_data,\n            getSourcePosition=get_source_position,\n            getTargetPosition=get_target_position,\n            getSourceColor=get_source_color or [51, 136, 255, 255],\n            getTargetColor=get_target_color or [255, 136, 51, 255],\n            getWidth=get_width,\n            widthMinPixels=width_min_pixels,\n            widthMaxPixels=width_max_pixels,\n            pickable=pickable,\n            opacity=opacity,\n            **kwargs,\n        )\n\n        self._deck_layers = {\n            **self._deck_layers,\n            layer_id: {\"type\": \"GreatCircleLayer\", \"id\": layer_id},\n        }\n\n    def add_h3_hexagon_layer(\n        self,\n        data: Any,\n        name: Optional[str] = None,\n        get_hexagon: Union[str, Callable] = \"hexagon\",\n        get_fill_color: Union[List[int], str, Callable] = None,\n        get_line_color: Union[List[int], str, Callable] = None,\n        get_elevation: Union[float, str, Callable] = 0,\n        filled: bool = True,\n        stroked: bool = True,\n        extruded: bool = False,\n        wireframe: bool = False,\n        elevation_scale: float = 1,\n        coverage: float = 1,\n        high_precision: bool = False,\n        pickable: bool = True,\n        opacity: float = 0.8,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add an H3 hexagon layer for H3 spatial index visualization.\n\n        Args:\n            data: Array of data objects with H3 index.\n            name: Layer ID.\n            get_hexagon: Accessor for H3 index string.\n            get_fill_color: Accessor for fill color [r, g, b, a].\n            get_line_color: Accessor for stroke color [r, g, b, a].\n            get_elevation: Accessor for 3D extrusion height.\n            filled: Whether to fill hexagons.\n            stroked: Whether to stroke hexagons.\n            extruded: Whether to render as 3D hexagons.\n            wireframe: Whether to render wireframe.\n            elevation_scale: Elevation multiplier.\n            coverage: Hexagon coverage (0-1).\n            high_precision: Use high precision rendering.\n            pickable: Whether layer responds to hover/click.\n            opacity: Layer opacity.\n            **kwargs: Additional H3HexagonLayer props.\n        \"\"\"\n        layer_id = name or f\"h3hexagon-{len(self._deck_layers)}\"\n        processed_data = self._process_deck_data(data)\n\n        self.call_js_method(\n            \"addH3HexagonLayer\",\n            id=layer_id,\n            data=processed_data,\n            getHexagon=get_hexagon,\n            getFillColor=get_fill_color or [51, 136, 255, 128],\n            getLineColor=get_line_color or [0, 0, 0, 255],\n            getElevation=get_elevation,\n            filled=filled,\n            stroked=stroked,\n            extruded=extruded,\n            wireframe=wireframe,\n            elevationScale=elevation_scale,\n            coverage=coverage,\n            highPrecision=high_precision,\n            pickable=pickable,\n            opacity=opacity,\n            **kwargs,\n        )\n\n        self._deck_layers = {\n            **self._deck_layers,\n            layer_id: {\"type\": \"H3HexagonLayer\", \"id\": layer_id},\n        }\n\n    def add_h3_cluster_layer(\n        self,\n        data: Any,\n        name: Optional[str] = None,\n        get_hexagons: Union[str, Callable] = \"hexagons\",\n        get_fill_color: Union[List[int], str, Callable] = None,\n        get_line_color: Union[List[int], str, Callable] = None,\n        get_line_width: Union[float, str, Callable] = 1,\n        filled: bool = True,\n        stroked: bool = True,\n        extruded: bool = False,\n        elevation_scale: float = 1,\n        pickable: bool = True,\n        opacity: float = 0.8,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add an H3 cluster layer for grouped H3 cell visualization.\n\n        Args:\n            data: Array of data objects with H3 index arrays.\n            name: Layer ID.\n            get_hexagons: Accessor for array of H3 index strings.\n            get_fill_color: Accessor for fill color [r, g, b, a].\n            get_line_color: Accessor for stroke color [r, g, b, a].\n            get_line_width: Accessor for line width.\n            filled: Whether to fill clusters.\n            stroked: Whether to stroke clusters.\n            extruded: Whether to render as 3D.\n            elevation_scale: Elevation multiplier.\n            pickable: Whether layer responds to hover/click.\n            opacity: Layer opacity.\n            **kwargs: Additional H3ClusterLayer props.\n        \"\"\"\n        layer_id = name or f\"h3cluster-{len(self._deck_layers)}\"\n        processed_data = self._process_deck_data(data)\n\n        self.call_js_method(\n            \"addH3ClusterLayer\",\n            id=layer_id,\n            data=processed_data,\n            getHexagons=get_hexagons,\n            getFillColor=get_fill_color or [51, 136, 255, 128],\n            getLineColor=get_line_color or [0, 0, 0, 255],\n            getLineWidth=get_line_width,\n            filled=filled,\n            stroked=stroked,\n            extruded=extruded,\n            elevationScale=elevation_scale,\n            pickable=pickable,\n            opacity=opacity,\n            **kwargs,\n        )\n\n        self._deck_layers = {\n            **self._deck_layers,\n            layer_id: {\"type\": \"H3ClusterLayer\", \"id\": layer_id},\n        }\n\n    def add_s2_layer(\n        self,\n        data: Any,\n        name: Optional[str] = None,\n        get_s2_token: Union[str, Callable] = \"s2Token\",\n        get_fill_color: Union[List[int], str, Callable] = None,\n        get_line_color: Union[List[int], str, Callable] = None,\n        get_line_width: Union[float, str, Callable] = 1,\n        get_elevation: Union[float, str, Callable] = 0,\n        filled: bool = True,\n        stroked: bool = True,\n        extruded: bool = False,\n        wireframe: bool = False,\n        elevation_scale: float = 1,\n        pickable: bool = True,\n        opacity: float = 0.8,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add an S2 layer for S2 geometry cell visualization.\n\n        Args:\n            data: Array of data objects with S2 token.\n            name: Layer ID.\n            get_s2_token: Accessor for S2 token string.\n            get_fill_color: Accessor for fill color [r, g, b, a].\n            get_line_color: Accessor for stroke color [r, g, b, a].\n            get_line_width: Accessor for line width.\n            get_elevation: Accessor for 3D extrusion height.\n            filled: Whether to fill cells.\n            stroked: Whether to stroke cells.\n            extruded: Whether to render as 3D.\n            wireframe: Whether to render wireframe.\n            elevation_scale: Elevation multiplier.\n            pickable: Whether layer responds to hover/click.\n            opacity: Layer opacity.\n            **kwargs: Additional S2Layer props.\n        \"\"\"\n        layer_id = name or f\"s2-{len(self._deck_layers)}\"\n        processed_data = self._process_deck_data(data)\n\n        self.call_js_method(\n            \"addS2Layer\",\n            id=layer_id,\n            data=processed_data,\n            getS2Token=get_s2_token,\n            getFillColor=get_fill_color or [51, 136, 255, 128],\n            getLineColor=get_line_color or [0, 0, 0, 255],\n            getLineWidth=get_line_width,\n            getElevation=get_elevation,\n            filled=filled,\n            stroked=stroked,\n            extruded=extruded,\n            wireframe=wireframe,\n            elevationScale=elevation_scale,\n            pickable=pickable,\n            opacity=opacity,\n            **kwargs,\n        )\n\n        self._deck_layers = {\n            **self._deck_layers,\n            layer_id: {\"type\": \"S2Layer\", \"id\": layer_id},\n        }\n\n    def add_quadkey_layer(\n        self,\n        data: Any,\n        name: Optional[str] = None,\n        get_quadkey: Union[str, Callable] = \"quadkey\",\n        get_fill_color: Union[List[int], str, Callable] = None,\n        get_line_color: Union[List[int], str, Callable] = None,\n        get_line_width: Union[float, str, Callable] = 1,\n        get_elevation: Union[float, str, Callable] = 0,\n        filled: bool = True,\n        stroked: bool = True,\n        extruded: bool = False,\n        wireframe: bool = False,\n        elevation_scale: float = 1,\n        pickable: bool = True,\n        opacity: float = 0.8,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a Quadkey layer for Bing Maps tile index visualization.\n\n        Args:\n            data: Array of data objects with quadkey.\n            name: Layer ID.\n            get_quadkey: Accessor for quadkey string.\n            get_fill_color: Accessor for fill color [r, g, b, a].\n            get_line_color: Accessor for stroke color [r, g, b, a].\n            get_line_width: Accessor for line width.\n            get_elevation: Accessor for 3D extrusion height.\n            filled: Whether to fill cells.\n            stroked: Whether to stroke cells.\n            extruded: Whether to render as 3D.\n            wireframe: Whether to render wireframe.\n            elevation_scale: Elevation multiplier.\n            pickable: Whether layer responds to hover/click.\n            opacity: Layer opacity.\n            **kwargs: Additional QuadkeyLayer props.\n        \"\"\"\n        layer_id = name or f\"quadkey-{len(self._deck_layers)}\"\n        processed_data = self._process_deck_data(data)\n\n        self.call_js_method(\n            \"addQuadkeyLayer\",\n            id=layer_id,\n            data=processed_data,\n            getQuadkey=get_quadkey,\n            getFillColor=get_fill_color or [51, 136, 255, 128],\n            getLineColor=get_line_color or [0, 0, 0, 255],\n            getLineWidth=get_line_width,\n            getElevation=get_elevation,\n            filled=filled,\n            stroked=stroked,\n            extruded=extruded,\n            wireframe=wireframe,\n            elevationScale=elevation_scale,\n            pickable=pickable,\n            opacity=opacity,\n            **kwargs,\n        )\n\n        self._deck_layers = {\n            **self._deck_layers,\n            layer_id: {\"type\": \"QuadkeyLayer\", \"id\": layer_id},\n        }\n\n    def add_geohash_layer(\n        self,\n        data: Any,\n        name: Optional[str] = None,\n        get_geohash: Union[str, Callable] = \"geohash\",\n        get_fill_color: Union[List[int], str, Callable] = None,\n        get_line_color: Union[List[int], str, Callable] = None,\n        get_line_width: Union[float, str, Callable] = 1,\n        get_elevation: Union[float, str, Callable] = 0,\n        filled: bool = True,\n        stroked: bool = True,\n        extruded: bool = False,\n        wireframe: bool = False,\n        elevation_scale: float = 1,\n        pickable: bool = True,\n        opacity: float = 0.8,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a Geohash layer for geohash cell visualization.\n\n        Args:\n            data: Array of data objects with geohash.\n            name: Layer ID.\n            get_geohash: Accessor for geohash string.\n            get_fill_color: Accessor for fill color [r, g, b, a].\n            get_line_color: Accessor for stroke color [r, g, b, a].\n            get_line_width: Accessor for line width.\n            get_elevation: Accessor for 3D extrusion height.\n            filled: Whether to fill cells.\n            stroked: Whether to stroke cells.\n            extruded: Whether to render as 3D.\n            wireframe: Whether to render wireframe.\n            elevation_scale: Elevation multiplier.\n            pickable: Whether layer responds to hover/click.\n            opacity: Layer opacity.\n            **kwargs: Additional GeohashLayer props.\n        \"\"\"\n        layer_id = name or f\"geohash-{len(self._deck_layers)}\"\n        processed_data = self._process_deck_data(data)\n\n        self.call_js_method(\n            \"addGeohashLayer\",\n            id=layer_id,\n            data=processed_data,\n            getGeohash=get_geohash,\n            getFillColor=get_fill_color or [51, 136, 255, 128],\n            getLineColor=get_line_color or [0, 0, 0, 255],\n            getLineWidth=get_line_width,\n            getElevation=get_elevation,\n            filled=filled,\n            stroked=stroked,\n            extruded=extruded,\n            wireframe=wireframe,\n            elevationScale=elevation_scale,\n            pickable=pickable,\n            opacity=opacity,\n            **kwargs,\n        )\n\n        self._deck_layers = {\n            **self._deck_layers,\n            layer_id: {\"type\": \"GeohashLayer\", \"id\": layer_id},\n        }\n\n    def add_wms_layer(\n        self,\n        data: str,\n        name: Optional[str] = None,\n        service_type: str = \"wms\",\n        layers: Optional[List[str]] = None,\n        srs: Optional[str] = None,\n        pickable: bool = False,\n        visible: bool = True,\n        opacity: float = 1.0,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a WMS layer for OGC Web Map Service visualization.\n\n        Args:\n            data: WMS base URL.\n            name: Layer ID.\n            service_type: Service type ('wms' or 'template').\n            layers: WMS layer names to request.\n            srs: Spatial reference system (e.g., 'EPSG:4326').\n            pickable: Whether layer responds to hover/click.\n            visible: Whether layer is visible.\n            opacity: Layer opacity (0-1).\n            **kwargs: Additional WMSLayer props.\n        \"\"\"\n        layer_id = name or f\"wms-{len(self._deck_layers)}\"\n\n        self.call_js_method(\n            \"addWMSLayer\",\n            id=layer_id,\n            data=data,\n            serviceType=service_type,\n            layers=layers,\n            srs=srs,\n            pickable=pickable,\n            visible=visible,\n            opacity=opacity,\n            **kwargs,\n        )\n\n        self._deck_layers = {\n            **self._deck_layers,\n            layer_id: {\"type\": \"WMSLayer\", \"id\": layer_id},\n        }\n\n    def add_simple_mesh_layer(\n        self,\n        data: Any,\n        mesh: str,\n        name: Optional[str] = None,\n        texture: Optional[str] = None,\n        get_position: Union[str, Callable] = \"coordinates\",\n        get_color: Union[List[int], str, Callable] = None,\n        get_orientation: Union[str, Callable] = None,\n        get_scale: Union[str, Callable] = None,\n        get_translation: Union[str, Callable] = None,\n        size_scale: float = 1,\n        wireframe: bool = False,\n        pickable: bool = True,\n        opacity: float = 1.0,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a simple mesh layer for 3D mesh visualization.\n\n        Args:\n            data: Array of data objects with position coordinates.\n            mesh: URL to OBJ/glTF mesh file.\n            name: Layer ID.\n            texture: URL to texture image.\n            get_position: Accessor for mesh position [lng, lat, z].\n            get_color: Accessor for mesh color [r, g, b, a].\n            get_orientation: Accessor for mesh orientation [pitch, yaw, roll].\n            get_scale: Accessor for mesh scale [x, y, z].\n            get_translation: Accessor for mesh translation [x, y, z].\n            size_scale: Global size multiplier.\n            wireframe: Whether to render as wireframe.\n            pickable: Whether layer responds to hover/click.\n            opacity: Layer opacity (0-1).\n            **kwargs: Additional SimpleMeshLayer props.\n        \"\"\"\n        layer_id = name or f\"simplemesh-{len(self._deck_layers)}\"\n        processed_data = self._process_deck_data(data)\n\n        layer_kwargs = {\n            \"id\": layer_id,\n            \"data\": processed_data,\n            \"mesh\": mesh,\n            \"getPosition\": get_position,\n            \"getColor\": get_color or [255, 255, 255, 255],\n            \"sizeScale\": size_scale,\n            \"wireframe\": wireframe,\n            \"pickable\": pickable,\n            \"opacity\": opacity,\n        }\n\n        if texture:\n            layer_kwargs[\"texture\"] = texture\n        if get_orientation:\n            layer_kwargs[\"getOrientation\"] = get_orientation\n        if get_scale:\n            layer_kwargs[\"getScale\"] = get_scale\n        if get_translation:\n            layer_kwargs[\"getTranslation\"] = get_translation\n\n        layer_kwargs.update(kwargs)\n        self.call_js_method(\"addSimpleMeshLayer\", **layer_kwargs)\n\n        self._deck_layers = {\n            **self._deck_layers,\n            layer_id: {\"type\": \"SimpleMeshLayer\", \"id\": layer_id},\n        }\n\n    def add_scenegraph_layer(\n        self,\n        data: Any,\n        scenegraph: str,\n        name: Optional[str] = None,\n        get_position: Union[str, Callable] = \"coordinates\",\n        get_color: Union[List[int], str, Callable] = None,\n        get_orientation: Union[str, Callable] = None,\n        get_scale: Union[str, Callable] = None,\n        get_translation: Union[str, Callable] = None,\n        size_scale: float = 1,\n        size_min_pixels: float = 0,\n        size_max_pixels: float = 10000,\n        pickable: bool = True,\n        opacity: float = 1.0,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a scenegraph layer for glTF model visualization.\n\n        Args:\n            data: Array of data objects with position coordinates.\n            scenegraph: URL to glTF/GLB model file.\n            name: Layer ID.\n            get_position: Accessor for model position [lng, lat, z].\n            get_color: Accessor for model tint color [r, g, b, a].\n            get_orientation: Accessor for model orientation [pitch, yaw, roll].\n            get_scale: Accessor for model scale [x, y, z].\n            get_translation: Accessor for model translation [x, y, z].\n            size_scale: Global size multiplier.\n            size_min_pixels: Minimum model size in pixels.\n            size_max_pixels: Maximum model size in pixels.\n            pickable: Whether layer responds to hover/click.\n            opacity: Layer opacity (0-1).\n            **kwargs: Additional ScenegraphLayer props.\n        \"\"\"\n        layer_id = name or f\"scenegraph-{len(self._deck_layers)}\"\n        processed_data = self._process_deck_data(data)\n\n        layer_kwargs = {\n            \"id\": layer_id,\n            \"data\": processed_data,\n            \"scenegraph\": scenegraph,\n            \"getPosition\": get_position,\n            \"getColor\": get_color or [255, 255, 255, 255],\n            \"sizeScale\": size_scale,\n            \"sizeMinPixels\": size_min_pixels,\n            \"sizeMaxPixels\": size_max_pixels,\n            \"pickable\": pickable,\n            \"opacity\": opacity,\n        }\n\n        if get_orientation:\n            layer_kwargs[\"getOrientation\"] = get_orientation\n        if get_scale:\n            layer_kwargs[\"getScale\"] = get_scale\n        if get_translation:\n            layer_kwargs[\"getTranslation\"] = get_translation\n\n        layer_kwargs.update(kwargs)\n        self.call_js_method(\"addScenegraphLayer\", **layer_kwargs)\n\n        self._deck_layers = {\n            **self._deck_layers,\n            layer_id: {\"type\": \"ScenegraphLayer\", \"id\": layer_id},\n        }\n\n    def remove_cog_layer(self, layer_id: str) -&gt; None:\n        \"\"\"Remove a COG layer.\n\n        Args:\n            layer_id: Layer identifier to remove.\n        \"\"\"\n        self.remove_deck_layer(layer_id)\n\n    # -------------------------------------------------------------------------\n    # DeckGL Layer Management\n    # -------------------------------------------------------------------------\n\n    def remove_deck_layer(self, layer_id: str) -&gt; None:\n        \"\"\"Remove a deck.gl layer.\n\n        Args:\n            layer_id: Layer identifier to remove.\n        \"\"\"\n        if layer_id in self._deck_layers:\n            layers = dict(self._deck_layers)\n            del layers[layer_id]\n            self._deck_layers = layers\n        self.call_js_method(\"removeDeckLayer\", layer_id)\n\n    def set_deck_layer_visibility(self, layer_id: str, visible: bool) -&gt; None:\n        \"\"\"Set deck.gl layer visibility.\n\n        Args:\n            layer_id: Layer identifier.\n            visible: Whether layer should be visible.\n        \"\"\"\n        self.call_js_method(\"setDeckLayerVisibility\", layer_id, visible)\n\n    # -------------------------------------------------------------------------\n    # Data Processing Helpers\n    # -------------------------------------------------------------------------\n\n    def _process_deck_data(self, data: Any) -&gt; Any:\n        \"\"\"Process data for deck.gl layers.\n\n        Handles GeoDataFrame, GeoJSON, and list of dicts.\n\n        Args:\n            data: Input data in various formats.\n\n        Returns:\n            Processed data suitable for deck.gl.\n        \"\"\"\n        # Handle GeoDataFrame\n        if hasattr(data, \"__geo_interface__\"):\n            return json.loads(data.to_json())\n\n        # Handle file path\n        if isinstance(data, (str, Path)):\n            path = Path(data)\n            if path.exists() and path.suffix.lower() in [\".geojson\", \".json\"]:\n                with open(path) as f:\n                    return json.load(f)\n            # Could be URL, return as-is\n            return str(data)\n\n        # Handle dict (GeoJSON or config)\n        if isinstance(data, dict):\n            return data\n\n        # Handle list of dicts\n        if isinstance(data, list):\n            return data\n\n        return data\n\n    # -------------------------------------------------------------------------\n    # HTML Export\n    # -------------------------------------------------------------------------\n\n    def _generate_html_template(self) -&gt; str:\n        \"\"\"Generate standalone HTML for the DeckGL map.\"\"\"\n        template_path = Path(__file__).parent / \"templates\" / \"deckgl.html\"\n\n        if template_path.exists():\n            template = template_path.read_text(encoding=\"utf-8\")\n        else:\n            template = self._get_default_template()\n\n        # Serialize state\n        state = {\n            \"center\": self.center,\n            \"zoom\": self.zoom,\n            \"style\": self.style,\n            \"bearing\": self.bearing,\n            \"pitch\": self.pitch,\n            \"width\": self.width,\n            \"height\": self.height,\n            \"layers\": self._layers,\n            \"sources\": self._sources,\n            \"controls\": self._controls,\n            \"deckLayers\": self._deck_layers,\n            \"js_calls\": self._js_calls,\n        }\n\n        template = template.replace(\"{{state}}\", json.dumps(state, indent=2))\n        return template\n</code></pre>"},{"location":"deckgl/#anymap_ts.deckgl.DeckGLMap.__init__","title":"<code>__init__(self, center=(0.0, 0.0), zoom=2.0, width='100%', height='600px', style='https://demotiles.maplibre.org/style.json', bearing=0.0, pitch=0.0, max_pitch=85.0, controls=None, **kwargs)</code>  <code>special</code>","text":"<p>Initialize a DeckGL map.</p> <p>Parameters:</p> Name Type Description Default <code>center</code> <code>Tuple[float, float]</code> <p>Map center as (longitude, latitude).</p> <code>(0.0, 0.0)</code> <code>zoom</code> <code>float</code> <p>Initial zoom level.</p> <code>2.0</code> <code>width</code> <code>str</code> <p>Map width as CSS string.</p> <code>'100%'</code> <code>height</code> <code>str</code> <p>Map height as CSS string.</p> <code>'600px'</code> <code>style</code> <code>Union[str, Dict]</code> <p>MapLibre style URL or style object.</p> <code>'https://demotiles.maplibre.org/style.json'</code> <code>bearing</code> <code>float</code> <p>Map bearing in degrees.</p> <code>0.0</code> <code>pitch</code> <code>float</code> <p>Map pitch in degrees.</p> <code>0.0</code> <code>max_pitch</code> <code>float</code> <p>Maximum pitch angle in degrees (default: 85).</p> <code>85.0</code> <code>controls</code> <code>Optional[Dict[str, Any]]</code> <p>Dict of controls to add (e.g., {\"navigation\": True}).</p> <code>None</code> <code>**kwargs</code> <p>Additional widget arguments.</p> <code>{}</code> Source code in <code>anymap_ts/deckgl.py</code> <pre><code>def __init__(\n    self,\n    center: Tuple[float, float] = (0.0, 0.0),\n    zoom: float = 2.0,\n    width: str = \"100%\",\n    height: str = \"600px\",\n    style: Union[str, Dict] = \"https://demotiles.maplibre.org/style.json\",\n    bearing: float = 0.0,\n    pitch: float = 0.0,\n    max_pitch: float = 85.0,\n    controls: Optional[Dict[str, Any]] = None,\n    **kwargs,\n):\n    \"\"\"Initialize a DeckGL map.\n\n    Args:\n        center: Map center as (longitude, latitude).\n        zoom: Initial zoom level.\n        width: Map width as CSS string.\n        height: Map height as CSS string.\n        style: MapLibre style URL or style object.\n        bearing: Map bearing in degrees.\n        pitch: Map pitch in degrees.\n        max_pitch: Maximum pitch angle in degrees (default: 85).\n        controls: Dict of controls to add (e.g., {\"navigation\": True}).\n        **kwargs: Additional widget arguments.\n    \"\"\"\n    super().__init__(\n        center=center,\n        zoom=zoom,\n        width=width,\n        height=height,\n        style=style,\n        bearing=bearing,\n        pitch=pitch,\n        max_pitch=max_pitch,\n        controls=controls,\n        **kwargs,\n    )\n    self._deck_layers = {}\n</code></pre>"},{"location":"deckgl/#anymap_ts.deckgl.DeckGLMap.add_arc_layer","title":"<code>add_arc_layer(self, data, name=None, get_source_position='source', get_target_position='target', get_source_color=None, get_target_color=None, get_width=1, pickable=True, opacity=0.8, **kwargs)</code>","text":"<p>Add an arc layer for origin-destination visualization.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>Array of data objects with source/target coordinates.</p> required <code>name</code> <code>Optional[str]</code> <p>Layer ID.</p> <code>None</code> <code>get_source_position</code> <code>Union[str, Callable]</code> <p>Accessor for source position [lng, lat].</p> <code>'source'</code> <code>get_target_position</code> <code>Union[str, Callable]</code> <p>Accessor for target position [lng, lat].</p> <code>'target'</code> <code>get_source_color</code> <code>Union[List[int], str, Callable]</code> <p>Accessor for source color [r, g, b, a].</p> <code>None</code> <code>get_target_color</code> <code>Union[List[int], str, Callable]</code> <p>Accessor for target color [r, g, b, a].</p> <code>None</code> <code>get_width</code> <code>Union[float, str, Callable]</code> <p>Accessor for arc width.</p> <code>1</code> <code>pickable</code> <code>bool</code> <p>Whether layer responds to hover/click.</p> <code>True</code> <code>opacity</code> <code>float</code> <p>Layer opacity.</p> <code>0.8</code> <code>**kwargs</code> <p>Additional layer props.</p> <code>{}</code> Source code in <code>anymap_ts/deckgl.py</code> <pre><code>def add_arc_layer(\n    self,\n    data: Any,\n    name: Optional[str] = None,\n    get_source_position: Union[str, Callable] = \"source\",\n    get_target_position: Union[str, Callable] = \"target\",\n    get_source_color: Union[List[int], str, Callable] = None,\n    get_target_color: Union[List[int], str, Callable] = None,\n    get_width: Union[float, str, Callable] = 1,\n    pickable: bool = True,\n    opacity: float = 0.8,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add an arc layer for origin-destination visualization.\n\n    Args:\n        data: Array of data objects with source/target coordinates.\n        name: Layer ID.\n        get_source_position: Accessor for source position [lng, lat].\n        get_target_position: Accessor for target position [lng, lat].\n        get_source_color: Accessor for source color [r, g, b, a].\n        get_target_color: Accessor for target color [r, g, b, a].\n        get_width: Accessor for arc width.\n        pickable: Whether layer responds to hover/click.\n        opacity: Layer opacity.\n        **kwargs: Additional layer props.\n    \"\"\"\n    layer_id = name or f\"arc-{len(self._deck_layers)}\"\n    processed_data = self._process_deck_data(data)\n\n    self.call_js_method(\n        \"addArcLayer\",\n        id=layer_id,\n        data=processed_data,\n        getSourcePosition=get_source_position,\n        getTargetPosition=get_target_position,\n        getSourceColor=get_source_color or [51, 136, 255, 255],\n        getTargetColor=get_target_color or [255, 136, 51, 255],\n        getWidth=get_width,\n        pickable=pickable,\n        opacity=opacity,\n        **kwargs,\n    )\n\n    self._deck_layers = {\n        **self._deck_layers,\n        layer_id: {\"type\": \"ArcLayer\", \"id\": layer_id},\n    }\n</code></pre>"},{"location":"deckgl/#anymap_ts.deckgl.DeckGLMap.add_bitmap_layer","title":"<code>add_bitmap_layer(self, image, bounds, name=None, opacity=1.0, visible=True, pickable=False, desaturate=0, transparent_color=None, tint_color=None, **kwargs)</code>","text":"<p>Add a bitmap layer for raster image overlay.</p> <p>Parameters:</p> Name Type Description Default <code>image</code> <code>str</code> <p>URL or data URI of the image.</p> required <code>bounds</code> <code>List[float]</code> <p>Bounding box [west, south, east, north].</p> required <code>name</code> <code>Optional[str]</code> <p>Layer ID.</p> <code>None</code> <code>opacity</code> <code>float</code> <p>Layer opacity (0-1).</p> <code>1.0</code> <code>visible</code> <code>bool</code> <p>Whether layer is visible.</p> <code>True</code> <code>pickable</code> <code>bool</code> <p>Whether layer responds to hover/click.</p> <code>False</code> <code>desaturate</code> <code>float</code> <p>Desaturation amount (0-1).</p> <code>0</code> <code>transparent_color</code> <code>Optional[List[int]]</code> <p>Color to make transparent [r, g, b, a].</p> <code>None</code> <code>tint_color</code> <code>Optional[List[int]]</code> <p>Color to tint the image [r, g, b].</p> <code>None</code> <code>**kwargs</code> <p>Additional BitmapLayer props.</p> <code>{}</code> Source code in <code>anymap_ts/deckgl.py</code> <pre><code>def add_bitmap_layer(\n    self,\n    image: str,\n    bounds: List[float],\n    name: Optional[str] = None,\n    opacity: float = 1.0,\n    visible: bool = True,\n    pickable: bool = False,\n    desaturate: float = 0,\n    transparent_color: Optional[List[int]] = None,\n    tint_color: Optional[List[int]] = None,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a bitmap layer for raster image overlay.\n\n    Args:\n        image: URL or data URI of the image.\n        bounds: Bounding box [west, south, east, north].\n        name: Layer ID.\n        opacity: Layer opacity (0-1).\n        visible: Whether layer is visible.\n        pickable: Whether layer responds to hover/click.\n        desaturate: Desaturation amount (0-1).\n        transparent_color: Color to make transparent [r, g, b, a].\n        tint_color: Color to tint the image [r, g, b].\n        **kwargs: Additional BitmapLayer props.\n    \"\"\"\n    layer_id = name or f\"bitmap-{len(self._deck_layers)}\"\n\n    self.call_js_method(\n        \"addBitmapLayer\",\n        id=layer_id,\n        image=image,\n        bounds=bounds,\n        opacity=opacity,\n        visible=visible,\n        pickable=pickable,\n        desaturate=desaturate,\n        transparentColor=transparent_color or [0, 0, 0, 0],\n        tintColor=tint_color or [255, 255, 255],\n        **kwargs,\n    )\n\n    self._deck_layers = {\n        **self._deck_layers,\n        layer_id: {\"type\": \"BitmapLayer\", \"id\": layer_id},\n    }\n</code></pre>"},{"location":"deckgl/#anymap_ts.deckgl.DeckGLMap.add_cog_layer","title":"<code>add_cog_layer(self, url, name=None, opacity=1.0, visible=True, debug=False, debug_opacity=0.25, max_error=0.125, fit_bounds=True, before_id=None, **kwargs)</code>","text":"<p>Add a Cloud Optimized GeoTIFF (COG) layer using @developmentseed/deck.gl-geotiff.</p> <p>This method renders COG files directly in the browser using GPU-accelerated deck.gl rendering with automatic reprojection support.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>URL to the Cloud Optimized GeoTIFF file.</p> required <code>name</code> <code>Optional[str]</code> <p>Layer ID. If None, auto-generated.</p> <code>None</code> <code>opacity</code> <code>float</code> <p>Layer opacity (0-1).</p> <code>1.0</code> <code>visible</code> <code>bool</code> <p>Whether layer is visible.</p> <code>True</code> <code>debug</code> <code>bool</code> <p>Show reprojection mesh for debugging.</p> <code>False</code> <code>debug_opacity</code> <code>float</code> <p>Opacity of debug mesh (0-1).</p> <code>0.25</code> <code>max_error</code> <code>float</code> <p>Maximum reprojection error in pixels. Lower values create denser mesh for better accuracy.</p> <code>0.125</code> <code>fit_bounds</code> <code>bool</code> <p>Whether to fit map to COG bounds after loading.</p> <code>True</code> <code>before_id</code> <code>Optional[str]</code> <p>ID of layer to insert before.</p> <code>None</code> <code>**kwargs</code> <p>Additional COGLayer props.</p> <code>{}</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; m = DeckGLMap()\n&gt;&gt;&gt; m.add_cog_layer(\n...     \"https://example.com/landcover.tif\",\n...     name=\"landcover\",\n...     opacity=0.8\n... )\n</code></pre> Source code in <code>anymap_ts/deckgl.py</code> <pre><code>def add_cog_layer(\n    self,\n    url: str,\n    name: Optional[str] = None,\n    opacity: float = 1.0,\n    visible: bool = True,\n    debug: bool = False,\n    debug_opacity: float = 0.25,\n    max_error: float = 0.125,\n    fit_bounds: bool = True,\n    before_id: Optional[str] = None,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a Cloud Optimized GeoTIFF (COG) layer using @developmentseed/deck.gl-geotiff.\n\n    This method renders COG files directly in the browser using GPU-accelerated\n    deck.gl rendering with automatic reprojection support.\n\n    Args:\n        url: URL to the Cloud Optimized GeoTIFF file.\n        name: Layer ID. If None, auto-generated.\n        opacity: Layer opacity (0-1).\n        visible: Whether layer is visible.\n        debug: Show reprojection mesh for debugging.\n        debug_opacity: Opacity of debug mesh (0-1).\n        max_error: Maximum reprojection error in pixels. Lower values\n            create denser mesh for better accuracy.\n        fit_bounds: Whether to fit map to COG bounds after loading.\n        before_id: ID of layer to insert before.\n        **kwargs: Additional COGLayer props.\n\n    Example:\n        &gt;&gt;&gt; m = DeckGLMap()\n        &gt;&gt;&gt; m.add_cog_layer(\n        ...     \"https://example.com/landcover.tif\",\n        ...     name=\"landcover\",\n        ...     opacity=0.8\n        ... )\n    \"\"\"\n    # Use a monotonically increasing counter to avoid ID collisions when layers are removed.\n    counter = getattr(self, \"_cog_layer_counter\", 0)\n    layer_id = name or f\"cog-{counter}\"\n    self._cog_layer_counter = counter + 1\n\n    self.call_js_method(\n        \"addCOGLayer\",\n        id=layer_id,\n        geotiff=url,\n        opacity=opacity,\n        visible=visible,\n        debug=debug,\n        debugOpacity=debug_opacity,\n        maxError=max_error,\n        fitBounds=fit_bounds,\n        beforeId=before_id,\n        **kwargs,\n    )\n\n    self._deck_layers = {\n        **self._deck_layers,\n        layer_id: {\"type\": \"COGLayer\", \"id\": layer_id, \"url\": url},\n    }\n</code></pre>"},{"location":"deckgl/#anymap_ts.deckgl.DeckGLMap.add_column_layer","title":"<code>add_column_layer(self, data, name=None, get_position='coordinates', get_fill_color=None, get_line_color=None, get_elevation=1000, radius=1000, disk_resolution=20, elevation_scale=1, coverage=1, extruded=True, filled=True, stroked=False, wireframe=False, pickable=True, opacity=0.8, **kwargs)</code>","text":"<p>Add a column layer for 3D column/bar visualization.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>Array of data objects with position coordinates.</p> required <code>name</code> <code>Optional[str]</code> <p>Layer ID.</p> <code>None</code> <code>get_position</code> <code>Union[str, Callable]</code> <p>Accessor for column position [lng, lat].</p> <code>'coordinates'</code> <code>get_fill_color</code> <code>Union[List[int], str, Callable]</code> <p>Accessor for fill color [r, g, b, a].</p> <code>None</code> <code>get_line_color</code> <code>Union[List[int], str, Callable]</code> <p>Accessor for stroke color [r, g, b, a].</p> <code>None</code> <code>get_elevation</code> <code>Union[float, str, Callable]</code> <p>Accessor for column height.</p> <code>1000</code> <code>radius</code> <code>float</code> <p>Column radius in meters.</p> <code>1000</code> <code>disk_resolution</code> <code>int</code> <p>Number of sides for column polygon.</p> <code>20</code> <code>elevation_scale</code> <code>float</code> <p>Elevation multiplier.</p> <code>1</code> <code>coverage</code> <code>float</code> <p>Column coverage (0-1).</p> <code>1</code> <code>extruded</code> <code>bool</code> <p>Whether to extrude columns.</p> <code>True</code> <code>filled</code> <code>bool</code> <p>Whether to fill columns.</p> <code>True</code> <code>stroked</code> <code>bool</code> <p>Whether to stroke columns.</p> <code>False</code> <code>wireframe</code> <code>bool</code> <p>Whether to render as wireframe.</p> <code>False</code> <code>pickable</code> <code>bool</code> <p>Whether layer responds to hover/click.</p> <code>True</code> <code>opacity</code> <code>float</code> <p>Layer opacity.</p> <code>0.8</code> <code>**kwargs</code> <p>Additional ColumnLayer props.</p> <code>{}</code> Source code in <code>anymap_ts/deckgl.py</code> <pre><code>def add_column_layer(\n    self,\n    data: Any,\n    name: Optional[str] = None,\n    get_position: Union[str, Callable] = \"coordinates\",\n    get_fill_color: Union[List[int], str, Callable] = None,\n    get_line_color: Union[List[int], str, Callable] = None,\n    get_elevation: Union[float, str, Callable] = 1000,\n    radius: float = 1000,\n    disk_resolution: int = 20,\n    elevation_scale: float = 1,\n    coverage: float = 1,\n    extruded: bool = True,\n    filled: bool = True,\n    stroked: bool = False,\n    wireframe: bool = False,\n    pickable: bool = True,\n    opacity: float = 0.8,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a column layer for 3D column/bar visualization.\n\n    Args:\n        data: Array of data objects with position coordinates.\n        name: Layer ID.\n        get_position: Accessor for column position [lng, lat].\n        get_fill_color: Accessor for fill color [r, g, b, a].\n        get_line_color: Accessor for stroke color [r, g, b, a].\n        get_elevation: Accessor for column height.\n        radius: Column radius in meters.\n        disk_resolution: Number of sides for column polygon.\n        elevation_scale: Elevation multiplier.\n        coverage: Column coverage (0-1).\n        extruded: Whether to extrude columns.\n        filled: Whether to fill columns.\n        stroked: Whether to stroke columns.\n        wireframe: Whether to render as wireframe.\n        pickable: Whether layer responds to hover/click.\n        opacity: Layer opacity.\n        **kwargs: Additional ColumnLayer props.\n    \"\"\"\n    layer_id = name or f\"column-{len(self._deck_layers)}\"\n    processed_data = self._process_deck_data(data)\n\n    self.call_js_method(\n        \"addColumnLayer\",\n        id=layer_id,\n        data=processed_data,\n        getPosition=get_position,\n        getFillColor=get_fill_color or [255, 140, 0, 200],\n        getLineColor=get_line_color or [0, 0, 0, 255],\n        getElevation=get_elevation,\n        radius=radius,\n        diskResolution=disk_resolution,\n        elevationScale=elevation_scale,\n        coverage=coverage,\n        extruded=extruded,\n        filled=filled,\n        stroked=stroked,\n        wireframe=wireframe,\n        pickable=pickable,\n        opacity=opacity,\n        **kwargs,\n    )\n\n    self._deck_layers = {\n        **self._deck_layers,\n        layer_id: {\"type\": \"ColumnLayer\", \"id\": layer_id},\n    }\n</code></pre>"},{"location":"deckgl/#anymap_ts.deckgl.DeckGLMap.add_contour_layer","title":"<code>add_contour_layer(self, data, name=None, get_position='coordinates', get_weight=1, cell_size=200, contours=None, pickable=True, opacity=1, **kwargs)</code>","text":"<p>Add a contour layer for isoline visualization.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>Array of data objects with position coordinates.</p> required <code>name</code> <code>Optional[str]</code> <p>Layer ID.</p> <code>None</code> <code>get_position</code> <code>Union[str, Callable]</code> <p>Accessor for point position [lng, lat].</p> <code>'coordinates'</code> <code>get_weight</code> <code>Union[float, str, Callable]</code> <p>Accessor for point weight.</p> <code>1</code> <code>cell_size</code> <code>float</code> <p>Grid cell size for aggregation.</p> <code>200</code> <code>contours</code> <code>Optional[List[Dict]]</code> <p>Contour definitions [{threshold, color, strokeWidth}, ...].</p> <code>None</code> <code>pickable</code> <code>bool</code> <p>Whether layer responds to hover/click.</p> <code>True</code> <code>opacity</code> <code>float</code> <p>Layer opacity.</p> <code>1</code> <code>**kwargs</code> <p>Additional layer props.</p> <code>{}</code> Source code in <code>anymap_ts/deckgl.py</code> <pre><code>def add_contour_layer(\n    self,\n    data: Any,\n    name: Optional[str] = None,\n    get_position: Union[str, Callable] = \"coordinates\",\n    get_weight: Union[float, str, Callable] = 1,\n    cell_size: float = 200,\n    contours: Optional[List[Dict]] = None,\n    pickable: bool = True,\n    opacity: float = 1,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a contour layer for isoline visualization.\n\n    Args:\n        data: Array of data objects with position coordinates.\n        name: Layer ID.\n        get_position: Accessor for point position [lng, lat].\n        get_weight: Accessor for point weight.\n        cell_size: Grid cell size for aggregation.\n        contours: Contour definitions [{threshold, color, strokeWidth}, ...].\n        pickable: Whether layer responds to hover/click.\n        opacity: Layer opacity.\n        **kwargs: Additional layer props.\n    \"\"\"\n    layer_id = name or f\"contour-{len(self._deck_layers)}\"\n    processed_data = self._process_deck_data(data)\n\n    default_contours = [\n        {\"threshold\": 1, \"color\": [255, 255, 255], \"strokeWidth\": 1},\n        {\"threshold\": 5, \"color\": [51, 136, 255], \"strokeWidth\": 2},\n        {\"threshold\": 10, \"color\": [0, 0, 255], \"strokeWidth\": 3},\n    ]\n\n    self.call_js_method(\n        \"addContourLayer\",\n        id=layer_id,\n        data=processed_data,\n        getPosition=get_position,\n        getWeight=get_weight,\n        cellSize=cell_size,\n        contours=contours or default_contours,\n        pickable=pickable,\n        opacity=opacity,\n        **kwargs,\n    )\n\n    self._deck_layers = {\n        **self._deck_layers,\n        layer_id: {\"type\": \"ContourLayer\", \"id\": layer_id},\n    }\n</code></pre>"},{"location":"deckgl/#anymap_ts.deckgl.DeckGLMap.add_deckgl_layer","title":"<code>add_deckgl_layer(self, layer_type, data, name=None, **kwargs)</code>","text":"<p>Add a generic deck.gl layer to the map.</p> <p>This method provides a flexible way to add any supported deck.gl layer type using a single interface. For commonly used layers, prefer the specific methods (e.g., add_scatterplot_layer) for better IDE support.</p> <p>Parameters:</p> Name Type Description Default <code>layer_type</code> <code>str</code> <p>The deck.gl layer type. Supported types include: 'ScatterplotLayer', 'ArcLayer', 'PathLayer', 'PolygonLayer', 'HexagonLayer', 'HeatmapLayer', 'GridLayer', 'IconLayer', 'TextLayer', 'GeoJsonLayer', 'ContourLayer', 'ScreenGridLayer', 'PointCloudLayer', 'TripsLayer', 'LineLayer'.</p> required <code>data</code> <code>Any</code> <p>Array of data objects or GeoJSON.</p> required <code>name</code> <code>Optional[str]</code> <p>Layer ID. If None, auto-generated from layer_type.</p> <code>None</code> <code>**kwargs</code> <p>Layer-specific properties passed directly to deck.gl. Common properties include: - opacity: Layer opacity (0-1) - pickable: Whether layer responds to hover/click - getPosition: Accessor for position coordinates - getColor/getFillColor/getLineColor: Color accessors</p> <code>{}</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; m = DeckGLMap()\n&gt;&gt;&gt; # Add a TripsLayer with animation\n&gt;&gt;&gt; m.add_deckgl_layer(\n...     'TripsLayer',\n...     data=trips_data,\n...     getPath='waypoints',\n...     getTimestamps='timestamps',\n...     getColor=[253, 128, 93],\n...     trailLength=180,\n... )\n&gt;&gt;&gt; # Add a LineLayer\n&gt;&gt;&gt; m.add_deckgl_layer(\n...     'LineLayer',\n...     data=lines_data,\n...     getSourcePosition='source',\n...     getTargetPosition='target',\n...     getColor=[0, 128, 255],\n... )\n</code></pre> Source code in <code>anymap_ts/deckgl.py</code> <pre><code>def add_deckgl_layer(\n    self,\n    layer_type: str,\n    data: Any,\n    name: Optional[str] = None,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a generic deck.gl layer to the map.\n\n    This method provides a flexible way to add any supported deck.gl layer\n    type using a single interface. For commonly used layers, prefer the\n    specific methods (e.g., add_scatterplot_layer) for better IDE support.\n\n    Args:\n        layer_type: The deck.gl layer type. Supported types include:\n            'ScatterplotLayer', 'ArcLayer', 'PathLayer', 'PolygonLayer',\n            'HexagonLayer', 'HeatmapLayer', 'GridLayer', 'IconLayer',\n            'TextLayer', 'GeoJsonLayer', 'ContourLayer', 'ScreenGridLayer',\n            'PointCloudLayer', 'TripsLayer', 'LineLayer'.\n        data: Array of data objects or GeoJSON.\n        name: Layer ID. If None, auto-generated from layer_type.\n        **kwargs: Layer-specific properties passed directly to deck.gl.\n            Common properties include:\n            - opacity: Layer opacity (0-1)\n            - pickable: Whether layer responds to hover/click\n            - getPosition: Accessor for position coordinates\n            - getColor/getFillColor/getLineColor: Color accessors\n\n    Example:\n        &gt;&gt;&gt; m = DeckGLMap()\n        &gt;&gt;&gt; # Add a TripsLayer with animation\n        &gt;&gt;&gt; m.add_deckgl_layer(\n        ...     'TripsLayer',\n        ...     data=trips_data,\n        ...     getPath='waypoints',\n        ...     getTimestamps='timestamps',\n        ...     getColor=[253, 128, 93],\n        ...     trailLength=180,\n        ... )\n        &gt;&gt;&gt; # Add a LineLayer\n        &gt;&gt;&gt; m.add_deckgl_layer(\n        ...     'LineLayer',\n        ...     data=lines_data,\n        ...     getSourcePosition='source',\n        ...     getTargetPosition='target',\n        ...     getColor=[0, 128, 255],\n        ... )\n    \"\"\"\n    # Normalize layer type and create prefix\n    layer_type_clean = layer_type.replace(\"Layer\", \"\")\n    prefix = layer_type_clean.lower()\n    layer_id = name or f\"{prefix}-{len(self._deck_layers)}\"\n    processed_data = self._process_deck_data(data)\n\n    self.call_js_method(\n        \"addDeckGLLayer\",\n        layerType=layer_type,\n        id=layer_id,\n        data=processed_data,\n        **kwargs,\n    )\n\n    self._deck_layers = {\n        **self._deck_layers,\n        layer_id: {\"type\": layer_type, \"id\": layer_id},\n    }\n</code></pre>"},{"location":"deckgl/#anymap_ts.deckgl.DeckGLMap.add_geohash_layer","title":"<code>add_geohash_layer(self, data, name=None, get_geohash='geohash', get_fill_color=None, get_line_color=None, get_line_width=1, get_elevation=0, filled=True, stroked=True, extruded=False, wireframe=False, elevation_scale=1, pickable=True, opacity=0.8, **kwargs)</code>","text":"<p>Add a Geohash layer for geohash cell visualization.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>Array of data objects with geohash.</p> required <code>name</code> <code>Optional[str]</code> <p>Layer ID.</p> <code>None</code> <code>get_geohash</code> <code>Union[str, Callable]</code> <p>Accessor for geohash string.</p> <code>'geohash'</code> <code>get_fill_color</code> <code>Union[List[int], str, Callable]</code> <p>Accessor for fill color [r, g, b, a].</p> <code>None</code> <code>get_line_color</code> <code>Union[List[int], str, Callable]</code> <p>Accessor for stroke color [r, g, b, a].</p> <code>None</code> <code>get_line_width</code> <code>Union[float, str, Callable]</code> <p>Accessor for line width.</p> <code>1</code> <code>get_elevation</code> <code>Union[float, str, Callable]</code> <p>Accessor for 3D extrusion height.</p> <code>0</code> <code>filled</code> <code>bool</code> <p>Whether to fill cells.</p> <code>True</code> <code>stroked</code> <code>bool</code> <p>Whether to stroke cells.</p> <code>True</code> <code>extruded</code> <code>bool</code> <p>Whether to render as 3D.</p> <code>False</code> <code>wireframe</code> <code>bool</code> <p>Whether to render wireframe.</p> <code>False</code> <code>elevation_scale</code> <code>float</code> <p>Elevation multiplier.</p> <code>1</code> <code>pickable</code> <code>bool</code> <p>Whether layer responds to hover/click.</p> <code>True</code> <code>opacity</code> <code>float</code> <p>Layer opacity.</p> <code>0.8</code> <code>**kwargs</code> <p>Additional GeohashLayer props.</p> <code>{}</code> Source code in <code>anymap_ts/deckgl.py</code> <pre><code>def add_geohash_layer(\n    self,\n    data: Any,\n    name: Optional[str] = None,\n    get_geohash: Union[str, Callable] = \"geohash\",\n    get_fill_color: Union[List[int], str, Callable] = None,\n    get_line_color: Union[List[int], str, Callable] = None,\n    get_line_width: Union[float, str, Callable] = 1,\n    get_elevation: Union[float, str, Callable] = 0,\n    filled: bool = True,\n    stroked: bool = True,\n    extruded: bool = False,\n    wireframe: bool = False,\n    elevation_scale: float = 1,\n    pickable: bool = True,\n    opacity: float = 0.8,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a Geohash layer for geohash cell visualization.\n\n    Args:\n        data: Array of data objects with geohash.\n        name: Layer ID.\n        get_geohash: Accessor for geohash string.\n        get_fill_color: Accessor for fill color [r, g, b, a].\n        get_line_color: Accessor for stroke color [r, g, b, a].\n        get_line_width: Accessor for line width.\n        get_elevation: Accessor for 3D extrusion height.\n        filled: Whether to fill cells.\n        stroked: Whether to stroke cells.\n        extruded: Whether to render as 3D.\n        wireframe: Whether to render wireframe.\n        elevation_scale: Elevation multiplier.\n        pickable: Whether layer responds to hover/click.\n        opacity: Layer opacity.\n        **kwargs: Additional GeohashLayer props.\n    \"\"\"\n    layer_id = name or f\"geohash-{len(self._deck_layers)}\"\n    processed_data = self._process_deck_data(data)\n\n    self.call_js_method(\n        \"addGeohashLayer\",\n        id=layer_id,\n        data=processed_data,\n        getGeohash=get_geohash,\n        getFillColor=get_fill_color or [51, 136, 255, 128],\n        getLineColor=get_line_color or [0, 0, 0, 255],\n        getLineWidth=get_line_width,\n        getElevation=get_elevation,\n        filled=filled,\n        stroked=stroked,\n        extruded=extruded,\n        wireframe=wireframe,\n        elevationScale=elevation_scale,\n        pickable=pickable,\n        opacity=opacity,\n        **kwargs,\n    )\n\n    self._deck_layers = {\n        **self._deck_layers,\n        layer_id: {\"type\": \"GeohashLayer\", \"id\": layer_id},\n    }\n</code></pre>"},{"location":"deckgl/#anymap_ts.deckgl.DeckGLMap.add_geojson_layer","title":"<code>add_geojson_layer(self, data, name=None, get_fill_color=None, get_line_color=None, get_line_width=1, get_point_radius=5, get_elevation=0, extruded=False, wireframe=False, filled=True, stroked=True, line_width_min_pixels=1, point_radius_min_pixels=2, pickable=True, opacity=0.8, **kwargs)</code>","text":"<p>Add a GeoJSON layer for rendering GeoJSON features.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>GeoJSON object or URL.</p> required <code>name</code> <code>Optional[str]</code> <p>Layer ID.</p> <code>None</code> <code>get_fill_color</code> <code>Union[List[int], str, Callable]</code> <p>Accessor for fill color [r, g, b, a].</p> <code>None</code> <code>get_line_color</code> <code>Union[List[int], str, Callable]</code> <p>Accessor for stroke color [r, g, b, a].</p> <code>None</code> <code>get_line_width</code> <code>Union[float, str, Callable]</code> <p>Accessor for stroke width.</p> <code>1</code> <code>get_point_radius</code> <code>Union[float, str, Callable]</code> <p>Accessor for point radius.</p> <code>5</code> <code>get_elevation</code> <code>Union[float, str, Callable]</code> <p>Accessor for 3D extrusion height.</p> <code>0</code> <code>extruded</code> <code>bool</code> <p>Whether to render as 3D features.</p> <code>False</code> <code>wireframe</code> <code>bool</code> <p>Whether to render wireframe (extruded only).</p> <code>False</code> <code>filled</code> <code>bool</code> <p>Whether to fill features.</p> <code>True</code> <code>stroked</code> <code>bool</code> <p>Whether to draw stroke.</p> <code>True</code> <code>line_width_min_pixels</code> <code>float</code> <p>Minimum stroke width.</p> <code>1</code> <code>point_radius_min_pixels</code> <code>float</code> <p>Minimum point radius.</p> <code>2</code> <code>pickable</code> <code>bool</code> <p>Whether layer responds to hover/click.</p> <code>True</code> <code>opacity</code> <code>float</code> <p>Layer opacity.</p> <code>0.8</code> <code>**kwargs</code> <p>Additional layer props.</p> <code>{}</code> Source code in <code>anymap_ts/deckgl.py</code> <pre><code>def add_geojson_layer(\n    self,\n    data: Any,\n    name: Optional[str] = None,\n    get_fill_color: Union[List[int], str, Callable] = None,\n    get_line_color: Union[List[int], str, Callable] = None,\n    get_line_width: Union[float, str, Callable] = 1,\n    get_point_radius: Union[float, str, Callable] = 5,\n    get_elevation: Union[float, str, Callable] = 0,\n    extruded: bool = False,\n    wireframe: bool = False,\n    filled: bool = True,\n    stroked: bool = True,\n    line_width_min_pixels: float = 1,\n    point_radius_min_pixels: float = 2,\n    pickable: bool = True,\n    opacity: float = 0.8,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a GeoJSON layer for rendering GeoJSON features.\n\n    Args:\n        data: GeoJSON object or URL.\n        name: Layer ID.\n        get_fill_color: Accessor for fill color [r, g, b, a].\n        get_line_color: Accessor for stroke color [r, g, b, a].\n        get_line_width: Accessor for stroke width.\n        get_point_radius: Accessor for point radius.\n        get_elevation: Accessor for 3D extrusion height.\n        extruded: Whether to render as 3D features.\n        wireframe: Whether to render wireframe (extruded only).\n        filled: Whether to fill features.\n        stroked: Whether to draw stroke.\n        line_width_min_pixels: Minimum stroke width.\n        point_radius_min_pixels: Minimum point radius.\n        pickable: Whether layer responds to hover/click.\n        opacity: Layer opacity.\n        **kwargs: Additional layer props.\n    \"\"\"\n    layer_id = name or f\"geojson-{len(self._deck_layers)}\"\n    processed_data = self._process_deck_data(data)\n\n    self.call_js_method(\n        \"addGeoJsonLayer\",\n        id=layer_id,\n        data=processed_data,\n        getFillColor=get_fill_color or [51, 136, 255, 128],\n        getLineColor=get_line_color or [0, 0, 0, 255],\n        getLineWidth=get_line_width,\n        getPointRadius=get_point_radius,\n        getElevation=get_elevation,\n        extruded=extruded,\n        wireframe=wireframe,\n        filled=filled,\n        stroked=stroked,\n        lineWidthMinPixels=line_width_min_pixels,\n        pointRadiusMinPixels=point_radius_min_pixels,\n        pickable=pickable,\n        opacity=opacity,\n        **kwargs,\n    )\n\n    self._deck_layers = {\n        **self._deck_layers,\n        layer_id: {\"type\": \"GeoJsonLayer\", \"id\": layer_id},\n    }\n</code></pre>"},{"location":"deckgl/#anymap_ts.deckgl.DeckGLMap.add_great_circle_layer","title":"<code>add_great_circle_layer(self, data, name=None, get_source_position='source', get_target_position='target', get_source_color=None, get_target_color=None, get_width=1, width_min_pixels=1, width_max_pixels=100, pickable=True, opacity=0.8, **kwargs)</code>","text":"<p>Add a great circle layer for geodesic arc visualization.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>Array of data objects with source/target coordinates.</p> required <code>name</code> <code>Optional[str]</code> <p>Layer ID.</p> <code>None</code> <code>get_source_position</code> <code>Union[str, Callable]</code> <p>Accessor for source position [lng, lat].</p> <code>'source'</code> <code>get_target_position</code> <code>Union[str, Callable]</code> <p>Accessor for target position [lng, lat].</p> <code>'target'</code> <code>get_source_color</code> <code>Union[List[int], str, Callable]</code> <p>Accessor for source color [r, g, b, a].</p> <code>None</code> <code>get_target_color</code> <code>Union[List[int], str, Callable]</code> <p>Accessor for target color [r, g, b, a].</p> <code>None</code> <code>get_width</code> <code>Union[float, str, Callable]</code> <p>Accessor for line width.</p> <code>1</code> <code>width_min_pixels</code> <code>float</code> <p>Minimum line width in pixels.</p> <code>1</code> <code>width_max_pixels</code> <code>float</code> <p>Maximum line width in pixels.</p> <code>100</code> <code>pickable</code> <code>bool</code> <p>Whether layer responds to hover/click.</p> <code>True</code> <code>opacity</code> <code>float</code> <p>Layer opacity.</p> <code>0.8</code> <code>**kwargs</code> <p>Additional GreatCircleLayer props.</p> <code>{}</code> Source code in <code>anymap_ts/deckgl.py</code> <pre><code>def add_great_circle_layer(\n    self,\n    data: Any,\n    name: Optional[str] = None,\n    get_source_position: Union[str, Callable] = \"source\",\n    get_target_position: Union[str, Callable] = \"target\",\n    get_source_color: Union[List[int], str, Callable] = None,\n    get_target_color: Union[List[int], str, Callable] = None,\n    get_width: Union[float, str, Callable] = 1,\n    width_min_pixels: float = 1,\n    width_max_pixels: float = 100,\n    pickable: bool = True,\n    opacity: float = 0.8,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a great circle layer for geodesic arc visualization.\n\n    Args:\n        data: Array of data objects with source/target coordinates.\n        name: Layer ID.\n        get_source_position: Accessor for source position [lng, lat].\n        get_target_position: Accessor for target position [lng, lat].\n        get_source_color: Accessor for source color [r, g, b, a].\n        get_target_color: Accessor for target color [r, g, b, a].\n        get_width: Accessor for line width.\n        width_min_pixels: Minimum line width in pixels.\n        width_max_pixels: Maximum line width in pixels.\n        pickable: Whether layer responds to hover/click.\n        opacity: Layer opacity.\n        **kwargs: Additional GreatCircleLayer props.\n    \"\"\"\n    layer_id = name or f\"greatcircle-{len(self._deck_layers)}\"\n    processed_data = self._process_deck_data(data)\n\n    self.call_js_method(\n        \"addGreatCircleLayer\",\n        id=layer_id,\n        data=processed_data,\n        getSourcePosition=get_source_position,\n        getTargetPosition=get_target_position,\n        getSourceColor=get_source_color or [51, 136, 255, 255],\n        getTargetColor=get_target_color or [255, 136, 51, 255],\n        getWidth=get_width,\n        widthMinPixels=width_min_pixels,\n        widthMaxPixels=width_max_pixels,\n        pickable=pickable,\n        opacity=opacity,\n        **kwargs,\n    )\n\n    self._deck_layers = {\n        **self._deck_layers,\n        layer_id: {\"type\": \"GreatCircleLayer\", \"id\": layer_id},\n    }\n</code></pre>"},{"location":"deckgl/#anymap_ts.deckgl.DeckGLMap.add_grid_cell_layer","title":"<code>add_grid_cell_layer(self, data, name=None, get_position='coordinates', get_color=None, get_elevation=1000, cell_size=200, coverage=1, elevation_scale=1, extruded=True, pickable=True, opacity=0.8, **kwargs)</code>","text":"<p>Add a grid cell layer for pre-aggregated grid visualization.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>Array of data objects with position coordinates.</p> required <code>name</code> <code>Optional[str]</code> <p>Layer ID.</p> <code>None</code> <code>get_position</code> <code>Union[str, Callable]</code> <p>Accessor for cell position [lng, lat].</p> <code>'coordinates'</code> <code>get_color</code> <code>Union[List[int], str, Callable]</code> <p>Accessor for cell color [r, g, b, a].</p> <code>None</code> <code>get_elevation</code> <code>Union[float, str, Callable]</code> <p>Accessor for cell height.</p> <code>1000</code> <code>cell_size</code> <code>float</code> <p>Cell size in meters.</p> <code>200</code> <code>coverage</code> <code>float</code> <p>Cell coverage (0-1).</p> <code>1</code> <code>elevation_scale</code> <code>float</code> <p>Elevation multiplier.</p> <code>1</code> <code>extruded</code> <code>bool</code> <p>Whether to extrude cells.</p> <code>True</code> <code>pickable</code> <code>bool</code> <p>Whether layer responds to hover/click.</p> <code>True</code> <code>opacity</code> <code>float</code> <p>Layer opacity.</p> <code>0.8</code> <code>**kwargs</code> <p>Additional GridCellLayer props.</p> <code>{}</code> Source code in <code>anymap_ts/deckgl.py</code> <pre><code>def add_grid_cell_layer(\n    self,\n    data: Any,\n    name: Optional[str] = None,\n    get_position: Union[str, Callable] = \"coordinates\",\n    get_color: Union[List[int], str, Callable] = None,\n    get_elevation: Union[float, str, Callable] = 1000,\n    cell_size: float = 200,\n    coverage: float = 1,\n    elevation_scale: float = 1,\n    extruded: bool = True,\n    pickable: bool = True,\n    opacity: float = 0.8,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a grid cell layer for pre-aggregated grid visualization.\n\n    Args:\n        data: Array of data objects with position coordinates.\n        name: Layer ID.\n        get_position: Accessor for cell position [lng, lat].\n        get_color: Accessor for cell color [r, g, b, a].\n        get_elevation: Accessor for cell height.\n        cell_size: Cell size in meters.\n        coverage: Cell coverage (0-1).\n        elevation_scale: Elevation multiplier.\n        extruded: Whether to extrude cells.\n        pickable: Whether layer responds to hover/click.\n        opacity: Layer opacity.\n        **kwargs: Additional GridCellLayer props.\n    \"\"\"\n    layer_id = name or f\"gridcell-{len(self._deck_layers)}\"\n    processed_data = self._process_deck_data(data)\n\n    self.call_js_method(\n        \"addGridCellLayer\",\n        id=layer_id,\n        data=processed_data,\n        getPosition=get_position,\n        getColor=get_color or [255, 140, 0, 200],\n        getElevation=get_elevation,\n        cellSize=cell_size,\n        coverage=coverage,\n        elevationScale=elevation_scale,\n        extruded=extruded,\n        pickable=pickable,\n        opacity=opacity,\n        **kwargs,\n    )\n\n    self._deck_layers = {\n        **self._deck_layers,\n        layer_id: {\"type\": \"GridCellLayer\", \"id\": layer_id},\n    }\n</code></pre>"},{"location":"deckgl/#anymap_ts.deckgl.DeckGLMap.add_grid_layer","title":"<code>add_grid_layer(self, data, name=None, get_position='coordinates', cell_size=200, elevation_scale=4, extruded=True, color_range=None, pickable=True, opacity=0.8, **kwargs)</code>","text":"<p>Add a grid layer for square grid aggregation visualization.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>Array of data objects with position coordinates.</p> required <code>name</code> <code>Optional[str]</code> <p>Layer ID.</p> <code>None</code> <code>get_position</code> <code>Union[str, Callable]</code> <p>Accessor for point position [lng, lat].</p> <code>'coordinates'</code> <code>cell_size</code> <code>float</code> <p>Grid cell size in meters.</p> <code>200</code> <code>elevation_scale</code> <code>float</code> <p>Elevation multiplier for 3D.</p> <code>4</code> <code>extruded</code> <code>bool</code> <p>Whether to render as 3D cells.</p> <code>True</code> <code>color_range</code> <code>Optional[List[List[int]]]</code> <p>Color gradient [[r, g, b], ...].</p> <code>None</code> <code>pickable</code> <code>bool</code> <p>Whether layer responds to hover/click.</p> <code>True</code> <code>opacity</code> <code>float</code> <p>Layer opacity.</p> <code>0.8</code> <code>**kwargs</code> <p>Additional layer props.</p> <code>{}</code> Source code in <code>anymap_ts/deckgl.py</code> <pre><code>def add_grid_layer(\n    self,\n    data: Any,\n    name: Optional[str] = None,\n    get_position: Union[str, Callable] = \"coordinates\",\n    cell_size: float = 200,\n    elevation_scale: float = 4,\n    extruded: bool = True,\n    color_range: Optional[List[List[int]]] = None,\n    pickable: bool = True,\n    opacity: float = 0.8,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a grid layer for square grid aggregation visualization.\n\n    Args:\n        data: Array of data objects with position coordinates.\n        name: Layer ID.\n        get_position: Accessor for point position [lng, lat].\n        cell_size: Grid cell size in meters.\n        elevation_scale: Elevation multiplier for 3D.\n        extruded: Whether to render as 3D cells.\n        color_range: Color gradient [[r, g, b], ...].\n        pickable: Whether layer responds to hover/click.\n        opacity: Layer opacity.\n        **kwargs: Additional layer props.\n    \"\"\"\n    layer_id = name or f\"grid-{len(self._deck_layers)}\"\n    processed_data = self._process_deck_data(data)\n\n    default_color_range = [\n        [1, 152, 189],\n        [73, 227, 206],\n        [216, 254, 181],\n        [254, 237, 177],\n        [254, 173, 84],\n        [209, 55, 78],\n    ]\n\n    self.call_js_method(\n        \"addGridLayer\",\n        id=layer_id,\n        data=processed_data,\n        getPosition=get_position,\n        cellSize=cell_size,\n        elevationScale=elevation_scale,\n        extruded=extruded,\n        colorRange=color_range or default_color_range,\n        pickable=pickable,\n        opacity=opacity,\n        **kwargs,\n    )\n\n    self._deck_layers = {\n        **self._deck_layers,\n        layer_id: {\"type\": \"GridLayer\", \"id\": layer_id},\n    }\n</code></pre>"},{"location":"deckgl/#anymap_ts.deckgl.DeckGLMap.add_h3_cluster_layer","title":"<code>add_h3_cluster_layer(self, data, name=None, get_hexagons='hexagons', get_fill_color=None, get_line_color=None, get_line_width=1, filled=True, stroked=True, extruded=False, elevation_scale=1, pickable=True, opacity=0.8, **kwargs)</code>","text":"<p>Add an H3 cluster layer for grouped H3 cell visualization.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>Array of data objects with H3 index arrays.</p> required <code>name</code> <code>Optional[str]</code> <p>Layer ID.</p> <code>None</code> <code>get_hexagons</code> <code>Union[str, Callable]</code> <p>Accessor for array of H3 index strings.</p> <code>'hexagons'</code> <code>get_fill_color</code> <code>Union[List[int], str, Callable]</code> <p>Accessor for fill color [r, g, b, a].</p> <code>None</code> <code>get_line_color</code> <code>Union[List[int], str, Callable]</code> <p>Accessor for stroke color [r, g, b, a].</p> <code>None</code> <code>get_line_width</code> <code>Union[float, str, Callable]</code> <p>Accessor for line width.</p> <code>1</code> <code>filled</code> <code>bool</code> <p>Whether to fill clusters.</p> <code>True</code> <code>stroked</code> <code>bool</code> <p>Whether to stroke clusters.</p> <code>True</code> <code>extruded</code> <code>bool</code> <p>Whether to render as 3D.</p> <code>False</code> <code>elevation_scale</code> <code>float</code> <p>Elevation multiplier.</p> <code>1</code> <code>pickable</code> <code>bool</code> <p>Whether layer responds to hover/click.</p> <code>True</code> <code>opacity</code> <code>float</code> <p>Layer opacity.</p> <code>0.8</code> <code>**kwargs</code> <p>Additional H3ClusterLayer props.</p> <code>{}</code> Source code in <code>anymap_ts/deckgl.py</code> <pre><code>def add_h3_cluster_layer(\n    self,\n    data: Any,\n    name: Optional[str] = None,\n    get_hexagons: Union[str, Callable] = \"hexagons\",\n    get_fill_color: Union[List[int], str, Callable] = None,\n    get_line_color: Union[List[int], str, Callable] = None,\n    get_line_width: Union[float, str, Callable] = 1,\n    filled: bool = True,\n    stroked: bool = True,\n    extruded: bool = False,\n    elevation_scale: float = 1,\n    pickable: bool = True,\n    opacity: float = 0.8,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add an H3 cluster layer for grouped H3 cell visualization.\n\n    Args:\n        data: Array of data objects with H3 index arrays.\n        name: Layer ID.\n        get_hexagons: Accessor for array of H3 index strings.\n        get_fill_color: Accessor for fill color [r, g, b, a].\n        get_line_color: Accessor for stroke color [r, g, b, a].\n        get_line_width: Accessor for line width.\n        filled: Whether to fill clusters.\n        stroked: Whether to stroke clusters.\n        extruded: Whether to render as 3D.\n        elevation_scale: Elevation multiplier.\n        pickable: Whether layer responds to hover/click.\n        opacity: Layer opacity.\n        **kwargs: Additional H3ClusterLayer props.\n    \"\"\"\n    layer_id = name or f\"h3cluster-{len(self._deck_layers)}\"\n    processed_data = self._process_deck_data(data)\n\n    self.call_js_method(\n        \"addH3ClusterLayer\",\n        id=layer_id,\n        data=processed_data,\n        getHexagons=get_hexagons,\n        getFillColor=get_fill_color or [51, 136, 255, 128],\n        getLineColor=get_line_color or [0, 0, 0, 255],\n        getLineWidth=get_line_width,\n        filled=filled,\n        stroked=stroked,\n        extruded=extruded,\n        elevationScale=elevation_scale,\n        pickable=pickable,\n        opacity=opacity,\n        **kwargs,\n    )\n\n    self._deck_layers = {\n        **self._deck_layers,\n        layer_id: {\"type\": \"H3ClusterLayer\", \"id\": layer_id},\n    }\n</code></pre>"},{"location":"deckgl/#anymap_ts.deckgl.DeckGLMap.add_h3_hexagon_layer","title":"<code>add_h3_hexagon_layer(self, data, name=None, get_hexagon='hexagon', get_fill_color=None, get_line_color=None, get_elevation=0, filled=True, stroked=True, extruded=False, wireframe=False, elevation_scale=1, coverage=1, high_precision=False, pickable=True, opacity=0.8, **kwargs)</code>","text":"<p>Add an H3 hexagon layer for H3 spatial index visualization.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>Array of data objects with H3 index.</p> required <code>name</code> <code>Optional[str]</code> <p>Layer ID.</p> <code>None</code> <code>get_hexagon</code> <code>Union[str, Callable]</code> <p>Accessor for H3 index string.</p> <code>'hexagon'</code> <code>get_fill_color</code> <code>Union[List[int], str, Callable]</code> <p>Accessor for fill color [r, g, b, a].</p> <code>None</code> <code>get_line_color</code> <code>Union[List[int], str, Callable]</code> <p>Accessor for stroke color [r, g, b, a].</p> <code>None</code> <code>get_elevation</code> <code>Union[float, str, Callable]</code> <p>Accessor for 3D extrusion height.</p> <code>0</code> <code>filled</code> <code>bool</code> <p>Whether to fill hexagons.</p> <code>True</code> <code>stroked</code> <code>bool</code> <p>Whether to stroke hexagons.</p> <code>True</code> <code>extruded</code> <code>bool</code> <p>Whether to render as 3D hexagons.</p> <code>False</code> <code>wireframe</code> <code>bool</code> <p>Whether to render wireframe.</p> <code>False</code> <code>elevation_scale</code> <code>float</code> <p>Elevation multiplier.</p> <code>1</code> <code>coverage</code> <code>float</code> <p>Hexagon coverage (0-1).</p> <code>1</code> <code>high_precision</code> <code>bool</code> <p>Use high precision rendering.</p> <code>False</code> <code>pickable</code> <code>bool</code> <p>Whether layer responds to hover/click.</p> <code>True</code> <code>opacity</code> <code>float</code> <p>Layer opacity.</p> <code>0.8</code> <code>**kwargs</code> <p>Additional H3HexagonLayer props.</p> <code>{}</code> Source code in <code>anymap_ts/deckgl.py</code> <pre><code>def add_h3_hexagon_layer(\n    self,\n    data: Any,\n    name: Optional[str] = None,\n    get_hexagon: Union[str, Callable] = \"hexagon\",\n    get_fill_color: Union[List[int], str, Callable] = None,\n    get_line_color: Union[List[int], str, Callable] = None,\n    get_elevation: Union[float, str, Callable] = 0,\n    filled: bool = True,\n    stroked: bool = True,\n    extruded: bool = False,\n    wireframe: bool = False,\n    elevation_scale: float = 1,\n    coverage: float = 1,\n    high_precision: bool = False,\n    pickable: bool = True,\n    opacity: float = 0.8,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add an H3 hexagon layer for H3 spatial index visualization.\n\n    Args:\n        data: Array of data objects with H3 index.\n        name: Layer ID.\n        get_hexagon: Accessor for H3 index string.\n        get_fill_color: Accessor for fill color [r, g, b, a].\n        get_line_color: Accessor for stroke color [r, g, b, a].\n        get_elevation: Accessor for 3D extrusion height.\n        filled: Whether to fill hexagons.\n        stroked: Whether to stroke hexagons.\n        extruded: Whether to render as 3D hexagons.\n        wireframe: Whether to render wireframe.\n        elevation_scale: Elevation multiplier.\n        coverage: Hexagon coverage (0-1).\n        high_precision: Use high precision rendering.\n        pickable: Whether layer responds to hover/click.\n        opacity: Layer opacity.\n        **kwargs: Additional H3HexagonLayer props.\n    \"\"\"\n    layer_id = name or f\"h3hexagon-{len(self._deck_layers)}\"\n    processed_data = self._process_deck_data(data)\n\n    self.call_js_method(\n        \"addH3HexagonLayer\",\n        id=layer_id,\n        data=processed_data,\n        getHexagon=get_hexagon,\n        getFillColor=get_fill_color or [51, 136, 255, 128],\n        getLineColor=get_line_color or [0, 0, 0, 255],\n        getElevation=get_elevation,\n        filled=filled,\n        stroked=stroked,\n        extruded=extruded,\n        wireframe=wireframe,\n        elevationScale=elevation_scale,\n        coverage=coverage,\n        highPrecision=high_precision,\n        pickable=pickable,\n        opacity=opacity,\n        **kwargs,\n    )\n\n    self._deck_layers = {\n        **self._deck_layers,\n        layer_id: {\"type\": \"H3HexagonLayer\", \"id\": layer_id},\n    }\n</code></pre>"},{"location":"deckgl/#anymap_ts.deckgl.DeckGLMap.add_heatmap_layer","title":"<code>add_heatmap_layer(self, data, name=None, get_position='coordinates', get_weight=1, radius_pixels=30, intensity=1, threshold=0.05, color_range=None, opacity=1, **kwargs)</code>","text":"<p>Add a heatmap layer for density visualization.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>Array of data objects with position coordinates.</p> required <code>name</code> <code>Optional[str]</code> <p>Layer ID.</p> <code>None</code> <code>get_position</code> <code>Union[str, Callable]</code> <p>Accessor for point position [lng, lat].</p> <code>'coordinates'</code> <code>get_weight</code> <code>Union[float, str, Callable]</code> <p>Accessor for point weight.</p> <code>1</code> <code>radius_pixels</code> <code>float</code> <p>Influence radius in pixels.</p> <code>30</code> <code>intensity</code> <code>float</code> <p>Intensity multiplier.</p> <code>1</code> <code>threshold</code> <code>float</code> <p>Minimum density threshold.</p> <code>0.05</code> <code>color_range</code> <code>Optional[List[List[int]]]</code> <p>Color gradient [[r, g, b, a], ...].</p> <code>None</code> <code>opacity</code> <code>float</code> <p>Layer opacity.</p> <code>1</code> <code>**kwargs</code> <p>Additional layer props.</p> <code>{}</code> Source code in <code>anymap_ts/deckgl.py</code> <pre><code>def add_heatmap_layer(\n    self,\n    data: Any,\n    name: Optional[str] = None,\n    get_position: Union[str, Callable] = \"coordinates\",\n    get_weight: Union[float, str, Callable] = 1,\n    radius_pixels: float = 30,\n    intensity: float = 1,\n    threshold: float = 0.05,\n    color_range: Optional[List[List[int]]] = None,\n    opacity: float = 1,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a heatmap layer for density visualization.\n\n    Args:\n        data: Array of data objects with position coordinates.\n        name: Layer ID.\n        get_position: Accessor for point position [lng, lat].\n        get_weight: Accessor for point weight.\n        radius_pixels: Influence radius in pixels.\n        intensity: Intensity multiplier.\n        threshold: Minimum density threshold.\n        color_range: Color gradient [[r, g, b, a], ...].\n        opacity: Layer opacity.\n        **kwargs: Additional layer props.\n    \"\"\"\n    layer_id = name or f\"heatmap-{len(self._deck_layers)}\"\n    processed_data = self._process_deck_data(data)\n\n    default_color_range = [\n        [255, 255, 178, 25],\n        [254, 217, 118, 85],\n        [254, 178, 76, 127],\n        [253, 141, 60, 170],\n        [240, 59, 32, 212],\n        [189, 0, 38, 255],\n    ]\n\n    self.call_js_method(\n        \"addHeatmapLayer\",\n        id=layer_id,\n        data=processed_data,\n        getPosition=get_position,\n        getWeight=get_weight,\n        radiusPixels=radius_pixels,\n        intensity=intensity,\n        threshold=threshold,\n        colorRange=color_range or default_color_range,\n        opacity=opacity,\n        **kwargs,\n    )\n\n    self._deck_layers = {\n        **self._deck_layers,\n        layer_id: {\"type\": \"HeatmapLayer\", \"id\": layer_id},\n    }\n</code></pre>"},{"location":"deckgl/#anymap_ts.deckgl.DeckGLMap.add_hexagon_layer","title":"<code>add_hexagon_layer(self, data, name=None, get_position='coordinates', radius=1000, elevation_scale=4, extruded=True, color_range=None, pickable=True, opacity=0.8, **kwargs)</code>","text":"<p>Add a hexagon layer for hexbin aggregation visualization.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>Array of data objects with position coordinates.</p> required <code>name</code> <code>Optional[str]</code> <p>Layer ID.</p> <code>None</code> <code>get_position</code> <code>Union[str, Callable]</code> <p>Accessor for point position [lng, lat].</p> <code>'coordinates'</code> <code>radius</code> <code>float</code> <p>Hexagon radius in meters.</p> <code>1000</code> <code>elevation_scale</code> <code>float</code> <p>Elevation multiplier for 3D.</p> <code>4</code> <code>extruded</code> <code>bool</code> <p>Whether to render as 3D hexagons.</p> <code>True</code> <code>color_range</code> <code>Optional[List[List[int]]]</code> <p>Color gradient for aggregation [[r, g, b], ...].</p> <code>None</code> <code>pickable</code> <code>bool</code> <p>Whether layer responds to hover/click.</p> <code>True</code> <code>opacity</code> <code>float</code> <p>Layer opacity.</p> <code>0.8</code> <code>**kwargs</code> <p>Additional layer props.</p> <code>{}</code> Source code in <code>anymap_ts/deckgl.py</code> <pre><code>def add_hexagon_layer(\n    self,\n    data: Any,\n    name: Optional[str] = None,\n    get_position: Union[str, Callable] = \"coordinates\",\n    radius: float = 1000,\n    elevation_scale: float = 4,\n    extruded: bool = True,\n    color_range: Optional[List[List[int]]] = None,\n    pickable: bool = True,\n    opacity: float = 0.8,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a hexagon layer for hexbin aggregation visualization.\n\n    Args:\n        data: Array of data objects with position coordinates.\n        name: Layer ID.\n        get_position: Accessor for point position [lng, lat].\n        radius: Hexagon radius in meters.\n        elevation_scale: Elevation multiplier for 3D.\n        extruded: Whether to render as 3D hexagons.\n        color_range: Color gradient for aggregation [[r, g, b], ...].\n        pickable: Whether layer responds to hover/click.\n        opacity: Layer opacity.\n        **kwargs: Additional layer props.\n    \"\"\"\n    layer_id = name or f\"hexagon-{len(self._deck_layers)}\"\n    processed_data = self._process_deck_data(data)\n\n    default_color_range = [\n        [1, 152, 189],\n        [73, 227, 206],\n        [216, 254, 181],\n        [254, 237, 177],\n        [254, 173, 84],\n        [209, 55, 78],\n    ]\n\n    self.call_js_method(\n        \"addHexagonLayer\",\n        id=layer_id,\n        data=processed_data,\n        getPosition=get_position,\n        radius=radius,\n        elevationScale=elevation_scale,\n        extruded=extruded,\n        colorRange=color_range or default_color_range,\n        pickable=pickable,\n        opacity=opacity,\n        **kwargs,\n    )\n\n    self._deck_layers = {\n        **self._deck_layers,\n        layer_id: {\"type\": \"HexagonLayer\", \"id\": layer_id},\n    }\n</code></pre>"},{"location":"deckgl/#anymap_ts.deckgl.DeckGLMap.add_icon_layer","title":"<code>add_icon_layer(self, data, name=None, get_position='coordinates', get_icon='icon', get_size=20, get_color=None, icon_atlas=None, icon_mapping=None, pickable=True, opacity=1, **kwargs)</code>","text":"<p>Add an icon layer for custom marker visualization.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>Array of data objects with position coordinates.</p> required <code>name</code> <code>Optional[str]</code> <p>Layer ID.</p> <code>None</code> <code>get_position</code> <code>Union[str, Callable]</code> <p>Accessor for icon position [lng, lat].</p> <code>'coordinates'</code> <code>get_icon</code> <code>Union[str, Callable]</code> <p>Accessor for icon name in icon_mapping.</p> <code>'icon'</code> <code>get_size</code> <code>Union[float, str, Callable]</code> <p>Accessor for icon size.</p> <code>20</code> <code>get_color</code> <code>Union[List[int], str, Callable]</code> <p>Accessor for icon tint color [r, g, b, a].</p> <code>None</code> <code>icon_atlas</code> <code>Optional[str]</code> <p>URL to icon atlas image.</p> <code>None</code> <code>icon_mapping</code> <code>Optional[Dict]</code> <p>Dict mapping icon names to atlas coordinates.</p> <code>None</code> <code>pickable</code> <code>bool</code> <p>Whether layer responds to hover/click.</p> <code>True</code> <code>opacity</code> <code>float</code> <p>Layer opacity.</p> <code>1</code> <code>**kwargs</code> <p>Additional layer props.</p> <code>{}</code> Source code in <code>anymap_ts/deckgl.py</code> <pre><code>def add_icon_layer(\n    self,\n    data: Any,\n    name: Optional[str] = None,\n    get_position: Union[str, Callable] = \"coordinates\",\n    get_icon: Union[str, Callable] = \"icon\",\n    get_size: Union[float, str, Callable] = 20,\n    get_color: Union[List[int], str, Callable] = None,\n    icon_atlas: Optional[str] = None,\n    icon_mapping: Optional[Dict] = None,\n    pickable: bool = True,\n    opacity: float = 1,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add an icon layer for custom marker visualization.\n\n    Args:\n        data: Array of data objects with position coordinates.\n        name: Layer ID.\n        get_position: Accessor for icon position [lng, lat].\n        get_icon: Accessor for icon name in icon_mapping.\n        get_size: Accessor for icon size.\n        get_color: Accessor for icon tint color [r, g, b, a].\n        icon_atlas: URL to icon atlas image.\n        icon_mapping: Dict mapping icon names to atlas coordinates.\n        pickable: Whether layer responds to hover/click.\n        opacity: Layer opacity.\n        **kwargs: Additional layer props.\n    \"\"\"\n    layer_id = name or f\"icon-{len(self._deck_layers)}\"\n    processed_data = self._process_deck_data(data)\n\n    self.call_js_method(\n        \"addIconLayer\",\n        id=layer_id,\n        data=processed_data,\n        getPosition=get_position,\n        getIcon=get_icon,\n        getSize=get_size,\n        getColor=get_color or [255, 255, 255, 255],\n        iconAtlas=icon_atlas,\n        iconMapping=icon_mapping,\n        pickable=pickable,\n        opacity=opacity,\n        **kwargs,\n    )\n\n    self._deck_layers = {\n        **self._deck_layers,\n        layer_id: {\"type\": \"IconLayer\", \"id\": layer_id},\n    }\n</code></pre>"},{"location":"deckgl/#anymap_ts.deckgl.DeckGLMap.add_line_layer","title":"<code>add_line_layer(self, data, name=None, get_source_position='sourcePosition', get_target_position='targetPosition', get_color=None, get_width=1, width_min_pixels=1, pickable=True, opacity=0.8, **kwargs)</code>","text":"<p>Add a line layer for simple line segment visualization.</p> <p>The LineLayer renders straight line segments between source and target positions. Unlike ArcLayer, lines are drawn directly without curvature.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>Array of line objects with source/target positions.</p> required <code>name</code> <code>Optional[str]</code> <p>Layer ID. If None, auto-generated.</p> <code>None</code> <code>get_source_position</code> <code>Union[str, Callable]</code> <p>Accessor for source position [lng, lat].</p> <code>'sourcePosition'</code> <code>get_target_position</code> <code>Union[str, Callable]</code> <p>Accessor for target position [lng, lat].</p> <code>'targetPosition'</code> <code>get_color</code> <code>Union[List[int], str, Callable]</code> <p>Accessor for line color [r, g, b] or [r, g, b, a].</p> <code>None</code> <code>get_width</code> <code>Union[float, str, Callable]</code> <p>Accessor for line width.</p> <code>1</code> <code>width_min_pixels</code> <code>float</code> <p>Minimum line width in pixels.</p> <code>1</code> <code>pickable</code> <code>bool</code> <p>Whether layer responds to hover/click.</p> <code>True</code> <code>opacity</code> <code>float</code> <p>Layer opacity (0-1).</p> <code>0.8</code> <code>**kwargs</code> <p>Additional LineLayer props.</p> <code>{}</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; m = DeckGLMap()\n&gt;&gt;&gt; lines = [\n...     {\"sourcePosition\": [-122.4, 37.8], \"targetPosition\": [-122.5, 37.7]},\n...     {\"sourcePosition\": [-122.5, 37.7], \"targetPosition\": [-122.6, 37.8]},\n... ]\n&gt;&gt;&gt; m.add_line_layer(\n...     data=lines,\n...     get_color=[0, 128, 255],\n...     get_width=2,\n... )\n</code></pre> Source code in <code>anymap_ts/deckgl.py</code> <pre><code>def add_line_layer(\n    self,\n    data: Any,\n    name: Optional[str] = None,\n    get_source_position: Union[str, Callable] = \"sourcePosition\",\n    get_target_position: Union[str, Callable] = \"targetPosition\",\n    get_color: Union[List[int], str, Callable] = None,\n    get_width: Union[float, str, Callable] = 1,\n    width_min_pixels: float = 1,\n    pickable: bool = True,\n    opacity: float = 0.8,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a line layer for simple line segment visualization.\n\n    The LineLayer renders straight line segments between source and\n    target positions. Unlike ArcLayer, lines are drawn directly\n    without curvature.\n\n    Args:\n        data: Array of line objects with source/target positions.\n        name: Layer ID. If None, auto-generated.\n        get_source_position: Accessor for source position [lng, lat].\n        get_target_position: Accessor for target position [lng, lat].\n        get_color: Accessor for line color [r, g, b] or [r, g, b, a].\n        get_width: Accessor for line width.\n        width_min_pixels: Minimum line width in pixels.\n        pickable: Whether layer responds to hover/click.\n        opacity: Layer opacity (0-1).\n        **kwargs: Additional LineLayer props.\n\n    Example:\n        &gt;&gt;&gt; m = DeckGLMap()\n        &gt;&gt;&gt; lines = [\n        ...     {\"sourcePosition\": [-122.4, 37.8], \"targetPosition\": [-122.5, 37.7]},\n        ...     {\"sourcePosition\": [-122.5, 37.7], \"targetPosition\": [-122.6, 37.8]},\n        ... ]\n        &gt;&gt;&gt; m.add_line_layer(\n        ...     data=lines,\n        ...     get_color=[0, 128, 255],\n        ...     get_width=2,\n        ... )\n    \"\"\"\n    layer_id = name or f\"line-{len(self._deck_layers)}\"\n    processed_data = self._process_deck_data(data)\n\n    self.call_js_method(\n        \"addLineLayer\",\n        id=layer_id,\n        data=processed_data,\n        getSourcePosition=get_source_position,\n        getTargetPosition=get_target_position,\n        getColor=get_color or [51, 136, 255, 200],\n        getWidth=get_width,\n        widthMinPixels=width_min_pixels,\n        pickable=pickable,\n        opacity=opacity,\n        **kwargs,\n    )\n\n    self._deck_layers = {\n        **self._deck_layers,\n        layer_id: {\"type\": \"LineLayer\", \"id\": layer_id},\n    }\n</code></pre>"},{"location":"deckgl/#anymap_ts.deckgl.DeckGLMap.add_mvt_layer","title":"<code>add_mvt_layer(self, data, name=None, min_zoom=0, max_zoom=14, binary=True, get_fill_color=None, get_line_color=None, get_line_width=1, get_point_radius=5, line_width_min_pixels=1, point_radius_min_pixels=2, pickable=True, visible=True, opacity=1.0, **kwargs)</code>","text":"<p>Add a Mapbox Vector Tile (MVT) layer.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Union[str, List[str]]</code> <p>MVT tile URL template with {z}/{x}/{y} placeholders.</p> required <code>name</code> <code>Optional[str]</code> <p>Layer ID.</p> <code>None</code> <code>min_zoom</code> <code>int</code> <p>Minimum zoom level.</p> <code>0</code> <code>max_zoom</code> <code>int</code> <p>Maximum zoom level.</p> <code>14</code> <code>binary</code> <code>bool</code> <p>Whether to use binary format.</p> <code>True</code> <code>get_fill_color</code> <code>Union[List[int], str, Callable]</code> <p>Accessor for fill color [r, g, b, a].</p> <code>None</code> <code>get_line_color</code> <code>Union[List[int], str, Callable]</code> <p>Accessor for stroke color [r, g, b, a].</p> <code>None</code> <code>get_line_width</code> <code>Union[float, str, Callable]</code> <p>Accessor for line width.</p> <code>1</code> <code>get_point_radius</code> <code>Union[float, str, Callable]</code> <p>Accessor for point radius.</p> <code>5</code> <code>line_width_min_pixels</code> <code>float</code> <p>Minimum line width in pixels.</p> <code>1</code> <code>point_radius_min_pixels</code> <code>float</code> <p>Minimum point radius in pixels.</p> <code>2</code> <code>pickable</code> <code>bool</code> <p>Whether layer responds to hover/click.</p> <code>True</code> <code>visible</code> <code>bool</code> <p>Whether layer is visible.</p> <code>True</code> <code>opacity</code> <code>float</code> <p>Layer opacity (0-1).</p> <code>1.0</code> <code>**kwargs</code> <p>Additional MVTLayer props.</p> <code>{}</code> Source code in <code>anymap_ts/deckgl.py</code> <pre><code>def add_mvt_layer(\n    self,\n    data: Union[str, List[str]],\n    name: Optional[str] = None,\n    min_zoom: int = 0,\n    max_zoom: int = 14,\n    binary: bool = True,\n    get_fill_color: Union[List[int], str, Callable] = None,\n    get_line_color: Union[List[int], str, Callable] = None,\n    get_line_width: Union[float, str, Callable] = 1,\n    get_point_radius: Union[float, str, Callable] = 5,\n    line_width_min_pixels: float = 1,\n    point_radius_min_pixels: float = 2,\n    pickable: bool = True,\n    visible: bool = True,\n    opacity: float = 1.0,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a Mapbox Vector Tile (MVT) layer.\n\n    Args:\n        data: MVT tile URL template with {z}/{x}/{y} placeholders.\n        name: Layer ID.\n        min_zoom: Minimum zoom level.\n        max_zoom: Maximum zoom level.\n        binary: Whether to use binary format.\n        get_fill_color: Accessor for fill color [r, g, b, a].\n        get_line_color: Accessor for stroke color [r, g, b, a].\n        get_line_width: Accessor for line width.\n        get_point_radius: Accessor for point radius.\n        line_width_min_pixels: Minimum line width in pixels.\n        point_radius_min_pixels: Minimum point radius in pixels.\n        pickable: Whether layer responds to hover/click.\n        visible: Whether layer is visible.\n        opacity: Layer opacity (0-1).\n        **kwargs: Additional MVTLayer props.\n    \"\"\"\n    layer_id = name or f\"mvt-{len(self._deck_layers)}\"\n\n    self.call_js_method(\n        \"addMVTLayer\",\n        id=layer_id,\n        data=data,\n        minZoom=min_zoom,\n        maxZoom=max_zoom,\n        binary=binary,\n        getFillColor=get_fill_color or [51, 136, 255, 128],\n        getLineColor=get_line_color or [0, 0, 0, 255],\n        getLineWidth=get_line_width,\n        getPointRadius=get_point_radius,\n        lineWidthMinPixels=line_width_min_pixels,\n        pointRadiusMinPixels=point_radius_min_pixels,\n        pickable=pickable,\n        visible=visible,\n        opacity=opacity,\n        **kwargs,\n    )\n\n    self._deck_layers = {\n        **self._deck_layers,\n        layer_id: {\"type\": \"MVTLayer\", \"id\": layer_id},\n    }\n</code></pre>"},{"location":"deckgl/#anymap_ts.deckgl.DeckGLMap.add_path_layer","title":"<code>add_path_layer(self, data, name=None, get_path='path', get_color=None, get_width=1, width_scale=1, width_min_pixels=1, pickable=True, opacity=0.8, **kwargs)</code>","text":"<p>Add a path layer for polyline visualization.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>Array of data objects with path coordinates.</p> required <code>name</code> <code>Optional[str]</code> <p>Layer ID.</p> <code>None</code> <code>get_path</code> <code>Union[str, Callable]</code> <p>Accessor for path coordinates [[lng, lat], ...].</p> <code>'path'</code> <code>get_color</code> <code>Union[List[int], str, Callable]</code> <p>Accessor for path color [r, g, b, a].</p> <code>None</code> <code>get_width</code> <code>Union[float, str, Callable]</code> <p>Accessor for path width.</p> <code>1</code> <code>width_scale</code> <code>float</code> <p>Global width multiplier.</p> <code>1</code> <code>width_min_pixels</code> <code>float</code> <p>Minimum width in pixels.</p> <code>1</code> <code>pickable</code> <code>bool</code> <p>Whether layer responds to hover/click.</p> <code>True</code> <code>opacity</code> <code>float</code> <p>Layer opacity.</p> <code>0.8</code> <code>**kwargs</code> <p>Additional layer props.</p> <code>{}</code> Source code in <code>anymap_ts/deckgl.py</code> <pre><code>def add_path_layer(\n    self,\n    data: Any,\n    name: Optional[str] = None,\n    get_path: Union[str, Callable] = \"path\",\n    get_color: Union[List[int], str, Callable] = None,\n    get_width: Union[float, str, Callable] = 1,\n    width_scale: float = 1,\n    width_min_pixels: float = 1,\n    pickable: bool = True,\n    opacity: float = 0.8,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a path layer for polyline visualization.\n\n    Args:\n        data: Array of data objects with path coordinates.\n        name: Layer ID.\n        get_path: Accessor for path coordinates [[lng, lat], ...].\n        get_color: Accessor for path color [r, g, b, a].\n        get_width: Accessor for path width.\n        width_scale: Global width multiplier.\n        width_min_pixels: Minimum width in pixels.\n        pickable: Whether layer responds to hover/click.\n        opacity: Layer opacity.\n        **kwargs: Additional layer props.\n    \"\"\"\n    layer_id = name or f\"path-{len(self._deck_layers)}\"\n    processed_data = self._process_deck_data(data)\n\n    self.call_js_method(\n        \"addPathLayer\",\n        id=layer_id,\n        data=processed_data,\n        getPath=get_path,\n        getColor=get_color or [51, 136, 255, 200],\n        getWidth=get_width,\n        widthScale=width_scale,\n        widthMinPixels=width_min_pixels,\n        pickable=pickable,\n        opacity=opacity,\n        **kwargs,\n    )\n\n    self._deck_layers = {\n        **self._deck_layers,\n        layer_id: {\"type\": \"PathLayer\", \"id\": layer_id},\n    }\n</code></pre>"},{"location":"deckgl/#anymap_ts.deckgl.DeckGLMap.add_point_cloud_layer","title":"<code>add_point_cloud_layer(self, data, name=None, get_position='position', get_color=None, get_normal=None, point_size=2, size_units='pixels', coordinate_system=None, coordinate_origin=None, pickable=True, opacity=1.0, **kwargs)</code>","text":"<p>Add a point cloud layer for 3D point visualization.</p> <p>Renders large point cloud datasets typically from LiDAR or 3D scanning. Supports both 2D and 3D coordinates with optional normal vectors for lighting effects.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>Array of point data with position [x, y, z] coordinates.</p> required <code>name</code> <code>Optional[str]</code> <p>Layer ID. If None, auto-generated.</p> <code>None</code> <code>get_position</code> <code>Union[str, Callable]</code> <p>Accessor for point position [x, y, z].</p> <code>'position'</code> <code>get_color</code> <code>Union[List[int], str, Callable]</code> <p>Accessor for point color [r, g, b, a].</p> <code>None</code> <code>get_normal</code> <code>Union[str, Callable]</code> <p>Accessor for point normal [nx, ny, nz] for lighting.</p> <code>None</code> <code>point_size</code> <code>float</code> <p>Point size in size_units.</p> <code>2</code> <code>size_units</code> <code>str</code> <p>Units for point_size ('pixels' or 'meters').</p> <code>'pixels'</code> <code>coordinate_system</code> <code>Optional[str]</code> <p>Coordinate system ('CARTESIAN', 'METER_OFFSETS', 'LNGLAT', 'LNGLAT_OFFSETS').</p> <code>None</code> <code>coordinate_origin</code> <code>Optional[List[float]]</code> <p>Origin for offset coordinate systems [lng, lat, z].</p> <code>None</code> <code>pickable</code> <code>bool</code> <p>Whether layer responds to hover/click.</p> <code>True</code> <code>opacity</code> <code>float</code> <p>Layer opacity (0-1).</p> <code>1.0</code> <code>**kwargs</code> <p>Additional PointCloudLayer props.</p> <code>{}</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; m = DeckGLMap()\n&gt;&gt;&gt; points = [\n...     {\"position\": [-122.4, 37.8, 100], \"color\": [255, 0, 0]},\n...     {\"position\": [-122.5, 37.7, 200], \"color\": [0, 255, 0]},\n... ]\n&gt;&gt;&gt; m.add_point_cloud_layer(\n...     data=points,\n...     point_size=5,\n...     get_color=\"color\"\n... )\n</code></pre> Source code in <code>anymap_ts/deckgl.py</code> <pre><code>def add_point_cloud_layer(\n    self,\n    data: Any,\n    name: Optional[str] = None,\n    get_position: Union[str, Callable] = \"position\",\n    get_color: Union[List[int], str, Callable] = None,\n    get_normal: Union[str, Callable] = None,\n    point_size: float = 2,\n    size_units: str = \"pixels\",\n    coordinate_system: Optional[str] = None,\n    coordinate_origin: Optional[List[float]] = None,\n    pickable: bool = True,\n    opacity: float = 1.0,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a point cloud layer for 3D point visualization.\n\n    Renders large point cloud datasets typically from LiDAR or 3D scanning.\n    Supports both 2D and 3D coordinates with optional normal vectors for\n    lighting effects.\n\n    Args:\n        data: Array of point data with position [x, y, z] coordinates.\n        name: Layer ID. If None, auto-generated.\n        get_position: Accessor for point position [x, y, z].\n        get_color: Accessor for point color [r, g, b, a].\n        get_normal: Accessor for point normal [nx, ny, nz] for lighting.\n        point_size: Point size in size_units.\n        size_units: Units for point_size ('pixels' or 'meters').\n        coordinate_system: Coordinate system ('CARTESIAN', 'METER_OFFSETS',\n            'LNGLAT', 'LNGLAT_OFFSETS').\n        coordinate_origin: Origin for offset coordinate systems [lng, lat, z].\n        pickable: Whether layer responds to hover/click.\n        opacity: Layer opacity (0-1).\n        **kwargs: Additional PointCloudLayer props.\n\n    Example:\n        &gt;&gt;&gt; m = DeckGLMap()\n        &gt;&gt;&gt; points = [\n        ...     {\"position\": [-122.4, 37.8, 100], \"color\": [255, 0, 0]},\n        ...     {\"position\": [-122.5, 37.7, 200], \"color\": [0, 255, 0]},\n        ... ]\n        &gt;&gt;&gt; m.add_point_cloud_layer(\n        ...     data=points,\n        ...     point_size=5,\n        ...     get_color=\"color\"\n        ... )\n    \"\"\"\n    layer_id = name or f\"pointcloud-{len(self._deck_layers)}\"\n    processed_data = self._process_deck_data(data)\n\n    layer_kwargs = {\n        \"id\": layer_id,\n        \"data\": processed_data,\n        \"getPosition\": get_position,\n        \"getColor\": get_color or [255, 255, 255, 255],\n        \"pointSize\": point_size,\n        \"sizeUnits\": size_units,\n        \"pickable\": pickable,\n        \"opacity\": opacity,\n    }\n\n    if get_normal is not None:\n        layer_kwargs[\"getNormal\"] = get_normal\n\n    if coordinate_system is not None:\n        layer_kwargs[\"coordinateSystem\"] = coordinate_system\n\n    if coordinate_origin is not None:\n        layer_kwargs[\"coordinateOrigin\"] = coordinate_origin\n\n    layer_kwargs.update(kwargs)\n    self.call_js_method(\"addPointCloudLayer\", **layer_kwargs)\n\n    self._deck_layers = {\n        **self._deck_layers,\n        layer_id: {\"type\": \"PointCloudLayer\", \"id\": layer_id},\n    }\n</code></pre>"},{"location":"deckgl/#anymap_ts.deckgl.DeckGLMap.add_polygon_layer","title":"<code>add_polygon_layer(self, data, name=None, get_polygon='polygon', get_fill_color=None, get_line_color=None, get_line_width=1, get_elevation=0, extruded=False, wireframe=False, filled=True, stroked=True, line_width_min_pixels=1, pickable=True, opacity=0.5, **kwargs)</code>","text":"<p>Add a polygon layer for filled polygon visualization.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>Array of data objects with polygon coordinates.</p> required <code>name</code> <code>Optional[str]</code> <p>Layer ID.</p> <code>None</code> <code>get_polygon</code> <code>Union[str, Callable]</code> <p>Accessor for polygon coordinates.</p> <code>'polygon'</code> <code>get_fill_color</code> <code>Union[List[int], str, Callable]</code> <p>Accessor for fill color [r, g, b, a].</p> <code>None</code> <code>get_line_color</code> <code>Union[List[int], str, Callable]</code> <p>Accessor for stroke color [r, g, b, a].</p> <code>None</code> <code>get_line_width</code> <code>Union[float, str, Callable]</code> <p>Accessor for stroke width.</p> <code>1</code> <code>get_elevation</code> <code>Union[float, str, Callable]</code> <p>Accessor for 3D extrusion height.</p> <code>0</code> <code>extruded</code> <code>bool</code> <p>Whether to render as 3D polygons.</p> <code>False</code> <code>wireframe</code> <code>bool</code> <p>Whether to render wireframe (extruded only).</p> <code>False</code> <code>filled</code> <code>bool</code> <p>Whether to fill polygons.</p> <code>True</code> <code>stroked</code> <code>bool</code> <p>Whether to draw stroke.</p> <code>True</code> <code>line_width_min_pixels</code> <code>float</code> <p>Minimum stroke width.</p> <code>1</code> <code>pickable</code> <code>bool</code> <p>Whether layer responds to hover/click.</p> <code>True</code> <code>opacity</code> <code>float</code> <p>Layer opacity.</p> <code>0.5</code> <code>**kwargs</code> <p>Additional layer props.</p> <code>{}</code> Source code in <code>anymap_ts/deckgl.py</code> <pre><code>def add_polygon_layer(\n    self,\n    data: Any,\n    name: Optional[str] = None,\n    get_polygon: Union[str, Callable] = \"polygon\",\n    get_fill_color: Union[List[int], str, Callable] = None,\n    get_line_color: Union[List[int], str, Callable] = None,\n    get_line_width: Union[float, str, Callable] = 1,\n    get_elevation: Union[float, str, Callable] = 0,\n    extruded: bool = False,\n    wireframe: bool = False,\n    filled: bool = True,\n    stroked: bool = True,\n    line_width_min_pixels: float = 1,\n    pickable: bool = True,\n    opacity: float = 0.5,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a polygon layer for filled polygon visualization.\n\n    Args:\n        data: Array of data objects with polygon coordinates.\n        name: Layer ID.\n        get_polygon: Accessor for polygon coordinates.\n        get_fill_color: Accessor for fill color [r, g, b, a].\n        get_line_color: Accessor for stroke color [r, g, b, a].\n        get_line_width: Accessor for stroke width.\n        get_elevation: Accessor for 3D extrusion height.\n        extruded: Whether to render as 3D polygons.\n        wireframe: Whether to render wireframe (extruded only).\n        filled: Whether to fill polygons.\n        stroked: Whether to draw stroke.\n        line_width_min_pixels: Minimum stroke width.\n        pickable: Whether layer responds to hover/click.\n        opacity: Layer opacity.\n        **kwargs: Additional layer props.\n    \"\"\"\n    layer_id = name or f\"polygon-{len(self._deck_layers)}\"\n    processed_data = self._process_deck_data(data)\n\n    self.call_js_method(\n        \"addPolygonLayer\",\n        id=layer_id,\n        data=processed_data,\n        getPolygon=get_polygon,\n        getFillColor=get_fill_color or [51, 136, 255, 128],\n        getLineColor=get_line_color or [0, 0, 255, 255],\n        getLineWidth=get_line_width,\n        getElevation=get_elevation,\n        extruded=extruded,\n        wireframe=wireframe,\n        filled=filled,\n        stroked=stroked,\n        lineWidthMinPixels=line_width_min_pixels,\n        pickable=pickable,\n        opacity=opacity,\n        **kwargs,\n    )\n\n    self._deck_layers = {\n        **self._deck_layers,\n        layer_id: {\"type\": \"PolygonLayer\", \"id\": layer_id},\n    }\n</code></pre>"},{"location":"deckgl/#anymap_ts.deckgl.DeckGLMap.add_quadkey_layer","title":"<code>add_quadkey_layer(self, data, name=None, get_quadkey='quadkey', get_fill_color=None, get_line_color=None, get_line_width=1, get_elevation=0, filled=True, stroked=True, extruded=False, wireframe=False, elevation_scale=1, pickable=True, opacity=0.8, **kwargs)</code>","text":"<p>Add a Quadkey layer for Bing Maps tile index visualization.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>Array of data objects with quadkey.</p> required <code>name</code> <code>Optional[str]</code> <p>Layer ID.</p> <code>None</code> <code>get_quadkey</code> <code>Union[str, Callable]</code> <p>Accessor for quadkey string.</p> <code>'quadkey'</code> <code>get_fill_color</code> <code>Union[List[int], str, Callable]</code> <p>Accessor for fill color [r, g, b, a].</p> <code>None</code> <code>get_line_color</code> <code>Union[List[int], str, Callable]</code> <p>Accessor for stroke color [r, g, b, a].</p> <code>None</code> <code>get_line_width</code> <code>Union[float, str, Callable]</code> <p>Accessor for line width.</p> <code>1</code> <code>get_elevation</code> <code>Union[float, str, Callable]</code> <p>Accessor for 3D extrusion height.</p> <code>0</code> <code>filled</code> <code>bool</code> <p>Whether to fill cells.</p> <code>True</code> <code>stroked</code> <code>bool</code> <p>Whether to stroke cells.</p> <code>True</code> <code>extruded</code> <code>bool</code> <p>Whether to render as 3D.</p> <code>False</code> <code>wireframe</code> <code>bool</code> <p>Whether to render wireframe.</p> <code>False</code> <code>elevation_scale</code> <code>float</code> <p>Elevation multiplier.</p> <code>1</code> <code>pickable</code> <code>bool</code> <p>Whether layer responds to hover/click.</p> <code>True</code> <code>opacity</code> <code>float</code> <p>Layer opacity.</p> <code>0.8</code> <code>**kwargs</code> <p>Additional QuadkeyLayer props.</p> <code>{}</code> Source code in <code>anymap_ts/deckgl.py</code> <pre><code>def add_quadkey_layer(\n    self,\n    data: Any,\n    name: Optional[str] = None,\n    get_quadkey: Union[str, Callable] = \"quadkey\",\n    get_fill_color: Union[List[int], str, Callable] = None,\n    get_line_color: Union[List[int], str, Callable] = None,\n    get_line_width: Union[float, str, Callable] = 1,\n    get_elevation: Union[float, str, Callable] = 0,\n    filled: bool = True,\n    stroked: bool = True,\n    extruded: bool = False,\n    wireframe: bool = False,\n    elevation_scale: float = 1,\n    pickable: bool = True,\n    opacity: float = 0.8,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a Quadkey layer for Bing Maps tile index visualization.\n\n    Args:\n        data: Array of data objects with quadkey.\n        name: Layer ID.\n        get_quadkey: Accessor for quadkey string.\n        get_fill_color: Accessor for fill color [r, g, b, a].\n        get_line_color: Accessor for stroke color [r, g, b, a].\n        get_line_width: Accessor for line width.\n        get_elevation: Accessor for 3D extrusion height.\n        filled: Whether to fill cells.\n        stroked: Whether to stroke cells.\n        extruded: Whether to render as 3D.\n        wireframe: Whether to render wireframe.\n        elevation_scale: Elevation multiplier.\n        pickable: Whether layer responds to hover/click.\n        opacity: Layer opacity.\n        **kwargs: Additional QuadkeyLayer props.\n    \"\"\"\n    layer_id = name or f\"quadkey-{len(self._deck_layers)}\"\n    processed_data = self._process_deck_data(data)\n\n    self.call_js_method(\n        \"addQuadkeyLayer\",\n        id=layer_id,\n        data=processed_data,\n        getQuadkey=get_quadkey,\n        getFillColor=get_fill_color or [51, 136, 255, 128],\n        getLineColor=get_line_color or [0, 0, 0, 255],\n        getLineWidth=get_line_width,\n        getElevation=get_elevation,\n        filled=filled,\n        stroked=stroked,\n        extruded=extruded,\n        wireframe=wireframe,\n        elevationScale=elevation_scale,\n        pickable=pickable,\n        opacity=opacity,\n        **kwargs,\n    )\n\n    self._deck_layers = {\n        **self._deck_layers,\n        layer_id: {\"type\": \"QuadkeyLayer\", \"id\": layer_id},\n    }\n</code></pre>"},{"location":"deckgl/#anymap_ts.deckgl.DeckGLMap.add_s2_layer","title":"<code>add_s2_layer(self, data, name=None, get_s2_token='s2Token', get_fill_color=None, get_line_color=None, get_line_width=1, get_elevation=0, filled=True, stroked=True, extruded=False, wireframe=False, elevation_scale=1, pickable=True, opacity=0.8, **kwargs)</code>","text":"<p>Add an S2 layer for S2 geometry cell visualization.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>Array of data objects with S2 token.</p> required <code>name</code> <code>Optional[str]</code> <p>Layer ID.</p> <code>None</code> <code>get_s2_token</code> <code>Union[str, Callable]</code> <p>Accessor for S2 token string.</p> <code>'s2Token'</code> <code>get_fill_color</code> <code>Union[List[int], str, Callable]</code> <p>Accessor for fill color [r, g, b, a].</p> <code>None</code> <code>get_line_color</code> <code>Union[List[int], str, Callable]</code> <p>Accessor for stroke color [r, g, b, a].</p> <code>None</code> <code>get_line_width</code> <code>Union[float, str, Callable]</code> <p>Accessor for line width.</p> <code>1</code> <code>get_elevation</code> <code>Union[float, str, Callable]</code> <p>Accessor for 3D extrusion height.</p> <code>0</code> <code>filled</code> <code>bool</code> <p>Whether to fill cells.</p> <code>True</code> <code>stroked</code> <code>bool</code> <p>Whether to stroke cells.</p> <code>True</code> <code>extruded</code> <code>bool</code> <p>Whether to render as 3D.</p> <code>False</code> <code>wireframe</code> <code>bool</code> <p>Whether to render wireframe.</p> <code>False</code> <code>elevation_scale</code> <code>float</code> <p>Elevation multiplier.</p> <code>1</code> <code>pickable</code> <code>bool</code> <p>Whether layer responds to hover/click.</p> <code>True</code> <code>opacity</code> <code>float</code> <p>Layer opacity.</p> <code>0.8</code> <code>**kwargs</code> <p>Additional S2Layer props.</p> <code>{}</code> Source code in <code>anymap_ts/deckgl.py</code> <pre><code>def add_s2_layer(\n    self,\n    data: Any,\n    name: Optional[str] = None,\n    get_s2_token: Union[str, Callable] = \"s2Token\",\n    get_fill_color: Union[List[int], str, Callable] = None,\n    get_line_color: Union[List[int], str, Callable] = None,\n    get_line_width: Union[float, str, Callable] = 1,\n    get_elevation: Union[float, str, Callable] = 0,\n    filled: bool = True,\n    stroked: bool = True,\n    extruded: bool = False,\n    wireframe: bool = False,\n    elevation_scale: float = 1,\n    pickable: bool = True,\n    opacity: float = 0.8,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add an S2 layer for S2 geometry cell visualization.\n\n    Args:\n        data: Array of data objects with S2 token.\n        name: Layer ID.\n        get_s2_token: Accessor for S2 token string.\n        get_fill_color: Accessor for fill color [r, g, b, a].\n        get_line_color: Accessor for stroke color [r, g, b, a].\n        get_line_width: Accessor for line width.\n        get_elevation: Accessor for 3D extrusion height.\n        filled: Whether to fill cells.\n        stroked: Whether to stroke cells.\n        extruded: Whether to render as 3D.\n        wireframe: Whether to render wireframe.\n        elevation_scale: Elevation multiplier.\n        pickable: Whether layer responds to hover/click.\n        opacity: Layer opacity.\n        **kwargs: Additional S2Layer props.\n    \"\"\"\n    layer_id = name or f\"s2-{len(self._deck_layers)}\"\n    processed_data = self._process_deck_data(data)\n\n    self.call_js_method(\n        \"addS2Layer\",\n        id=layer_id,\n        data=processed_data,\n        getS2Token=get_s2_token,\n        getFillColor=get_fill_color or [51, 136, 255, 128],\n        getLineColor=get_line_color or [0, 0, 0, 255],\n        getLineWidth=get_line_width,\n        getElevation=get_elevation,\n        filled=filled,\n        stroked=stroked,\n        extruded=extruded,\n        wireframe=wireframe,\n        elevationScale=elevation_scale,\n        pickable=pickable,\n        opacity=opacity,\n        **kwargs,\n    )\n\n    self._deck_layers = {\n        **self._deck_layers,\n        layer_id: {\"type\": \"S2Layer\", \"id\": layer_id},\n    }\n</code></pre>"},{"location":"deckgl/#anymap_ts.deckgl.DeckGLMap.add_scatterplot_layer","title":"<code>add_scatterplot_layer(self, data, name=None, get_position='coordinates', get_radius=5, get_fill_color=None, get_line_color=None, radius_scale=1, radius_min_pixels=1, radius_max_pixels=100, line_width_min_pixels=1, stroked=True, filled=True, pickable=True, opacity=0.8, **kwargs)</code>","text":"<p>Add a scatterplot layer for point visualization.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>Array of data objects or GeoJSON.</p> required <code>name</code> <code>Optional[str]</code> <p>Layer ID.</p> <code>None</code> <code>get_position</code> <code>Union[str, Callable]</code> <p>Accessor for point position [lng, lat].</p> <code>'coordinates'</code> <code>get_radius</code> <code>Union[float, str, Callable]</code> <p>Accessor for point radius.</p> <code>5</code> <code>get_fill_color</code> <code>Union[List[int], str, Callable]</code> <p>Accessor for fill color [r, g, b, a].</p> <code>None</code> <code>get_line_color</code> <code>Union[List[int], str, Callable]</code> <p>Accessor for stroke color [r, g, b, a].</p> <code>None</code> <code>radius_scale</code> <code>float</code> <p>Global radius multiplier.</p> <code>1</code> <code>radius_min_pixels</code> <code>float</code> <p>Minimum radius in pixels.</p> <code>1</code> <code>radius_max_pixels</code> <code>float</code> <p>Maximum radius in pixels.</p> <code>100</code> <code>line_width_min_pixels</code> <code>float</code> <p>Minimum stroke width.</p> <code>1</code> <code>stroked</code> <code>bool</code> <p>Whether to draw stroke.</p> <code>True</code> <code>filled</code> <code>bool</code> <p>Whether to fill points.</p> <code>True</code> <code>pickable</code> <code>bool</code> <p>Whether layer responds to hover/click.</p> <code>True</code> <code>opacity</code> <code>float</code> <p>Layer opacity.</p> <code>0.8</code> <code>**kwargs</code> <p>Additional layer props.</p> <code>{}</code> Source code in <code>anymap_ts/deckgl.py</code> <pre><code>def add_scatterplot_layer(\n    self,\n    data: Any,\n    name: Optional[str] = None,\n    get_position: Union[str, Callable] = \"coordinates\",\n    get_radius: Union[float, str, Callable] = 5,\n    get_fill_color: Union[List[int], str, Callable] = None,\n    get_line_color: Union[List[int], str, Callable] = None,\n    radius_scale: float = 1,\n    radius_min_pixels: float = 1,\n    radius_max_pixels: float = 100,\n    line_width_min_pixels: float = 1,\n    stroked: bool = True,\n    filled: bool = True,\n    pickable: bool = True,\n    opacity: float = 0.8,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a scatterplot layer for point visualization.\n\n    Args:\n        data: Array of data objects or GeoJSON.\n        name: Layer ID.\n        get_position: Accessor for point position [lng, lat].\n        get_radius: Accessor for point radius.\n        get_fill_color: Accessor for fill color [r, g, b, a].\n        get_line_color: Accessor for stroke color [r, g, b, a].\n        radius_scale: Global radius multiplier.\n        radius_min_pixels: Minimum radius in pixels.\n        radius_max_pixels: Maximum radius in pixels.\n        line_width_min_pixels: Minimum stroke width.\n        stroked: Whether to draw stroke.\n        filled: Whether to fill points.\n        pickable: Whether layer responds to hover/click.\n        opacity: Layer opacity.\n        **kwargs: Additional layer props.\n    \"\"\"\n    layer_id = name or f\"scatterplot-{len(self._deck_layers)}\"\n    processed_data = self._process_deck_data(data)\n\n    self.call_js_method(\n        \"addScatterplotLayer\",\n        id=layer_id,\n        data=processed_data,\n        getPosition=get_position,\n        getRadius=get_radius,\n        getFillColor=get_fill_color or [51, 136, 255, 200],\n        getLineColor=get_line_color or [255, 255, 255, 255],\n        radiusScale=radius_scale,\n        radiusMinPixels=radius_min_pixels,\n        radiusMaxPixels=radius_max_pixels,\n        lineWidthMinPixels=line_width_min_pixels,\n        stroked=stroked,\n        filled=filled,\n        pickable=pickable,\n        opacity=opacity,\n        **kwargs,\n    )\n\n    self._deck_layers = {\n        **self._deck_layers,\n        layer_id: {\"type\": \"ScatterplotLayer\", \"id\": layer_id},\n    }\n</code></pre>"},{"location":"deckgl/#anymap_ts.deckgl.DeckGLMap.add_scenegraph_layer","title":"<code>add_scenegraph_layer(self, data, scenegraph, name=None, get_position='coordinates', get_color=None, get_orientation=None, get_scale=None, get_translation=None, size_scale=1, size_min_pixels=0, size_max_pixels=10000, pickable=True, opacity=1.0, **kwargs)</code>","text":"<p>Add a scenegraph layer for glTF model visualization.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>Array of data objects with position coordinates.</p> required <code>scenegraph</code> <code>str</code> <p>URL to glTF/GLB model file.</p> required <code>name</code> <code>Optional[str]</code> <p>Layer ID.</p> <code>None</code> <code>get_position</code> <code>Union[str, Callable]</code> <p>Accessor for model position [lng, lat, z].</p> <code>'coordinates'</code> <code>get_color</code> <code>Union[List[int], str, Callable]</code> <p>Accessor for model tint color [r, g, b, a].</p> <code>None</code> <code>get_orientation</code> <code>Union[str, Callable]</code> <p>Accessor for model orientation [pitch, yaw, roll].</p> <code>None</code> <code>get_scale</code> <code>Union[str, Callable]</code> <p>Accessor for model scale [x, y, z].</p> <code>None</code> <code>get_translation</code> <code>Union[str, Callable]</code> <p>Accessor for model translation [x, y, z].</p> <code>None</code> <code>size_scale</code> <code>float</code> <p>Global size multiplier.</p> <code>1</code> <code>size_min_pixels</code> <code>float</code> <p>Minimum model size in pixels.</p> <code>0</code> <code>size_max_pixels</code> <code>float</code> <p>Maximum model size in pixels.</p> <code>10000</code> <code>pickable</code> <code>bool</code> <p>Whether layer responds to hover/click.</p> <code>True</code> <code>opacity</code> <code>float</code> <p>Layer opacity (0-1).</p> <code>1.0</code> <code>**kwargs</code> <p>Additional ScenegraphLayer props.</p> <code>{}</code> Source code in <code>anymap_ts/deckgl.py</code> <pre><code>def add_scenegraph_layer(\n    self,\n    data: Any,\n    scenegraph: str,\n    name: Optional[str] = None,\n    get_position: Union[str, Callable] = \"coordinates\",\n    get_color: Union[List[int], str, Callable] = None,\n    get_orientation: Union[str, Callable] = None,\n    get_scale: Union[str, Callable] = None,\n    get_translation: Union[str, Callable] = None,\n    size_scale: float = 1,\n    size_min_pixels: float = 0,\n    size_max_pixels: float = 10000,\n    pickable: bool = True,\n    opacity: float = 1.0,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a scenegraph layer for glTF model visualization.\n\n    Args:\n        data: Array of data objects with position coordinates.\n        scenegraph: URL to glTF/GLB model file.\n        name: Layer ID.\n        get_position: Accessor for model position [lng, lat, z].\n        get_color: Accessor for model tint color [r, g, b, a].\n        get_orientation: Accessor for model orientation [pitch, yaw, roll].\n        get_scale: Accessor for model scale [x, y, z].\n        get_translation: Accessor for model translation [x, y, z].\n        size_scale: Global size multiplier.\n        size_min_pixels: Minimum model size in pixels.\n        size_max_pixels: Maximum model size in pixels.\n        pickable: Whether layer responds to hover/click.\n        opacity: Layer opacity (0-1).\n        **kwargs: Additional ScenegraphLayer props.\n    \"\"\"\n    layer_id = name or f\"scenegraph-{len(self._deck_layers)}\"\n    processed_data = self._process_deck_data(data)\n\n    layer_kwargs = {\n        \"id\": layer_id,\n        \"data\": processed_data,\n        \"scenegraph\": scenegraph,\n        \"getPosition\": get_position,\n        \"getColor\": get_color or [255, 255, 255, 255],\n        \"sizeScale\": size_scale,\n        \"sizeMinPixels\": size_min_pixels,\n        \"sizeMaxPixels\": size_max_pixels,\n        \"pickable\": pickable,\n        \"opacity\": opacity,\n    }\n\n    if get_orientation:\n        layer_kwargs[\"getOrientation\"] = get_orientation\n    if get_scale:\n        layer_kwargs[\"getScale\"] = get_scale\n    if get_translation:\n        layer_kwargs[\"getTranslation\"] = get_translation\n\n    layer_kwargs.update(kwargs)\n    self.call_js_method(\"addScenegraphLayer\", **layer_kwargs)\n\n    self._deck_layers = {\n        **self._deck_layers,\n        layer_id: {\"type\": \"ScenegraphLayer\", \"id\": layer_id},\n    }\n</code></pre>"},{"location":"deckgl/#anymap_ts.deckgl.DeckGLMap.add_screen_grid_layer","title":"<code>add_screen_grid_layer(self, data, name=None, get_position='coordinates', get_weight=1, cell_size_pixels=50, color_range=None, pickable=True, opacity=0.8, **kwargs)</code>","text":"<p>Add a screen grid layer for screen-space grid aggregation.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>Array of data objects with position coordinates.</p> required <code>name</code> <code>Optional[str]</code> <p>Layer ID.</p> <code>None</code> <code>get_position</code> <code>Union[str, Callable]</code> <p>Accessor for point position [lng, lat].</p> <code>'coordinates'</code> <code>get_weight</code> <code>Union[float, str, Callable]</code> <p>Accessor for point weight.</p> <code>1</code> <code>cell_size_pixels</code> <code>float</code> <p>Grid cell size in pixels.</p> <code>50</code> <code>color_range</code> <code>Optional[List[List[int]]]</code> <p>Color gradient [[r, g, b, a], ...].</p> <code>None</code> <code>pickable</code> <code>bool</code> <p>Whether layer responds to hover/click.</p> <code>True</code> <code>opacity</code> <code>float</code> <p>Layer opacity.</p> <code>0.8</code> <code>**kwargs</code> <p>Additional layer props.</p> <code>{}</code> Source code in <code>anymap_ts/deckgl.py</code> <pre><code>def add_screen_grid_layer(\n    self,\n    data: Any,\n    name: Optional[str] = None,\n    get_position: Union[str, Callable] = \"coordinates\",\n    get_weight: Union[float, str, Callable] = 1,\n    cell_size_pixels: float = 50,\n    color_range: Optional[List[List[int]]] = None,\n    pickable: bool = True,\n    opacity: float = 0.8,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a screen grid layer for screen-space grid aggregation.\n\n    Args:\n        data: Array of data objects with position coordinates.\n        name: Layer ID.\n        get_position: Accessor for point position [lng, lat].\n        get_weight: Accessor for point weight.\n        cell_size_pixels: Grid cell size in pixels.\n        color_range: Color gradient [[r, g, b, a], ...].\n        pickable: Whether layer responds to hover/click.\n        opacity: Layer opacity.\n        **kwargs: Additional layer props.\n    \"\"\"\n    layer_id = name or f\"screengrid-{len(self._deck_layers)}\"\n    processed_data = self._process_deck_data(data)\n\n    default_color_range = [\n        [255, 255, 178, 25],\n        [254, 217, 118, 85],\n        [254, 178, 76, 127],\n        [253, 141, 60, 170],\n        [240, 59, 32, 212],\n        [189, 0, 38, 255],\n    ]\n\n    self.call_js_method(\n        \"addScreenGridLayer\",\n        id=layer_id,\n        data=processed_data,\n        getPosition=get_position,\n        getWeight=get_weight,\n        cellSizePixels=cell_size_pixels,\n        colorRange=color_range or default_color_range,\n        pickable=pickable,\n        opacity=opacity,\n        **kwargs,\n    )\n\n    self._deck_layers = {\n        **self._deck_layers,\n        layer_id: {\"type\": \"ScreenGridLayer\", \"id\": layer_id},\n    }\n</code></pre>"},{"location":"deckgl/#anymap_ts.deckgl.DeckGLMap.add_simple_mesh_layer","title":"<code>add_simple_mesh_layer(self, data, mesh, name=None, texture=None, get_position='coordinates', get_color=None, get_orientation=None, get_scale=None, get_translation=None, size_scale=1, wireframe=False, pickable=True, opacity=1.0, **kwargs)</code>","text":"<p>Add a simple mesh layer for 3D mesh visualization.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>Array of data objects with position coordinates.</p> required <code>mesh</code> <code>str</code> <p>URL to OBJ/glTF mesh file.</p> required <code>name</code> <code>Optional[str]</code> <p>Layer ID.</p> <code>None</code> <code>texture</code> <code>Optional[str]</code> <p>URL to texture image.</p> <code>None</code> <code>get_position</code> <code>Union[str, Callable]</code> <p>Accessor for mesh position [lng, lat, z].</p> <code>'coordinates'</code> <code>get_color</code> <code>Union[List[int], str, Callable]</code> <p>Accessor for mesh color [r, g, b, a].</p> <code>None</code> <code>get_orientation</code> <code>Union[str, Callable]</code> <p>Accessor for mesh orientation [pitch, yaw, roll].</p> <code>None</code> <code>get_scale</code> <code>Union[str, Callable]</code> <p>Accessor for mesh scale [x, y, z].</p> <code>None</code> <code>get_translation</code> <code>Union[str, Callable]</code> <p>Accessor for mesh translation [x, y, z].</p> <code>None</code> <code>size_scale</code> <code>float</code> <p>Global size multiplier.</p> <code>1</code> <code>wireframe</code> <code>bool</code> <p>Whether to render as wireframe.</p> <code>False</code> <code>pickable</code> <code>bool</code> <p>Whether layer responds to hover/click.</p> <code>True</code> <code>opacity</code> <code>float</code> <p>Layer opacity (0-1).</p> <code>1.0</code> <code>**kwargs</code> <p>Additional SimpleMeshLayer props.</p> <code>{}</code> Source code in <code>anymap_ts/deckgl.py</code> <pre><code>def add_simple_mesh_layer(\n    self,\n    data: Any,\n    mesh: str,\n    name: Optional[str] = None,\n    texture: Optional[str] = None,\n    get_position: Union[str, Callable] = \"coordinates\",\n    get_color: Union[List[int], str, Callable] = None,\n    get_orientation: Union[str, Callable] = None,\n    get_scale: Union[str, Callable] = None,\n    get_translation: Union[str, Callable] = None,\n    size_scale: float = 1,\n    wireframe: bool = False,\n    pickable: bool = True,\n    opacity: float = 1.0,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a simple mesh layer for 3D mesh visualization.\n\n    Args:\n        data: Array of data objects with position coordinates.\n        mesh: URL to OBJ/glTF mesh file.\n        name: Layer ID.\n        texture: URL to texture image.\n        get_position: Accessor for mesh position [lng, lat, z].\n        get_color: Accessor for mesh color [r, g, b, a].\n        get_orientation: Accessor for mesh orientation [pitch, yaw, roll].\n        get_scale: Accessor for mesh scale [x, y, z].\n        get_translation: Accessor for mesh translation [x, y, z].\n        size_scale: Global size multiplier.\n        wireframe: Whether to render as wireframe.\n        pickable: Whether layer responds to hover/click.\n        opacity: Layer opacity (0-1).\n        **kwargs: Additional SimpleMeshLayer props.\n    \"\"\"\n    layer_id = name or f\"simplemesh-{len(self._deck_layers)}\"\n    processed_data = self._process_deck_data(data)\n\n    layer_kwargs = {\n        \"id\": layer_id,\n        \"data\": processed_data,\n        \"mesh\": mesh,\n        \"getPosition\": get_position,\n        \"getColor\": get_color or [255, 255, 255, 255],\n        \"sizeScale\": size_scale,\n        \"wireframe\": wireframe,\n        \"pickable\": pickable,\n        \"opacity\": opacity,\n    }\n\n    if texture:\n        layer_kwargs[\"texture\"] = texture\n    if get_orientation:\n        layer_kwargs[\"getOrientation\"] = get_orientation\n    if get_scale:\n        layer_kwargs[\"getScale\"] = get_scale\n    if get_translation:\n        layer_kwargs[\"getTranslation\"] = get_translation\n\n    layer_kwargs.update(kwargs)\n    self.call_js_method(\"addSimpleMeshLayer\", **layer_kwargs)\n\n    self._deck_layers = {\n        **self._deck_layers,\n        layer_id: {\"type\": \"SimpleMeshLayer\", \"id\": layer_id},\n    }\n</code></pre>"},{"location":"deckgl/#anymap_ts.deckgl.DeckGLMap.add_solid_polygon_layer","title":"<code>add_solid_polygon_layer(self, data, name=None, get_polygon='polygon', get_fill_color=None, get_line_color=None, get_elevation=0, filled=True, extruded=False, wireframe=False, elevation_scale=1, pickable=True, opacity=0.8, **kwargs)</code>","text":"<p>Add a solid polygon layer for filled polygon visualization.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>Array of data objects with polygon coordinates.</p> required <code>name</code> <code>Optional[str]</code> <p>Layer ID.</p> <code>None</code> <code>get_polygon</code> <code>Union[str, Callable]</code> <p>Accessor for polygon coordinates.</p> <code>'polygon'</code> <code>get_fill_color</code> <code>Union[List[int], str, Callable]</code> <p>Accessor for fill color [r, g, b, a].</p> <code>None</code> <code>get_line_color</code> <code>Union[List[int], str, Callable]</code> <p>Accessor for stroke color [r, g, b, a].</p> <code>None</code> <code>get_elevation</code> <code>Union[float, str, Callable]</code> <p>Accessor for 3D extrusion height.</p> <code>0</code> <code>filled</code> <code>bool</code> <p>Whether to fill polygons.</p> <code>True</code> <code>extruded</code> <code>bool</code> <p>Whether to render as 3D polygons.</p> <code>False</code> <code>wireframe</code> <code>bool</code> <p>Whether to render wireframe.</p> <code>False</code> <code>elevation_scale</code> <code>float</code> <p>Elevation multiplier.</p> <code>1</code> <code>pickable</code> <code>bool</code> <p>Whether layer responds to hover/click.</p> <code>True</code> <code>opacity</code> <code>float</code> <p>Layer opacity.</p> <code>0.8</code> <code>**kwargs</code> <p>Additional SolidPolygonLayer props.</p> <code>{}</code> Source code in <code>anymap_ts/deckgl.py</code> <pre><code>def add_solid_polygon_layer(\n    self,\n    data: Any,\n    name: Optional[str] = None,\n    get_polygon: Union[str, Callable] = \"polygon\",\n    get_fill_color: Union[List[int], str, Callable] = None,\n    get_line_color: Union[List[int], str, Callable] = None,\n    get_elevation: Union[float, str, Callable] = 0,\n    filled: bool = True,\n    extruded: bool = False,\n    wireframe: bool = False,\n    elevation_scale: float = 1,\n    pickable: bool = True,\n    opacity: float = 0.8,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a solid polygon layer for filled polygon visualization.\n\n    Args:\n        data: Array of data objects with polygon coordinates.\n        name: Layer ID.\n        get_polygon: Accessor for polygon coordinates.\n        get_fill_color: Accessor for fill color [r, g, b, a].\n        get_line_color: Accessor for stroke color [r, g, b, a].\n        get_elevation: Accessor for 3D extrusion height.\n        filled: Whether to fill polygons.\n        extruded: Whether to render as 3D polygons.\n        wireframe: Whether to render wireframe.\n        elevation_scale: Elevation multiplier.\n        pickable: Whether layer responds to hover/click.\n        opacity: Layer opacity.\n        **kwargs: Additional SolidPolygonLayer props.\n    \"\"\"\n    layer_id = name or f\"solidpolygon-{len(self._deck_layers)}\"\n    processed_data = self._process_deck_data(data)\n\n    self.call_js_method(\n        \"addSolidPolygonLayer\",\n        id=layer_id,\n        data=processed_data,\n        getPolygon=get_polygon,\n        getFillColor=get_fill_color or [51, 136, 255, 128],\n        getLineColor=get_line_color or [0, 0, 0, 255],\n        getElevation=get_elevation,\n        filled=filled,\n        extruded=extruded,\n        wireframe=wireframe,\n        elevationScale=elevation_scale,\n        pickable=pickable,\n        opacity=opacity,\n        **kwargs,\n    )\n\n    self._deck_layers = {\n        **self._deck_layers,\n        layer_id: {\"type\": \"SolidPolygonLayer\", \"id\": layer_id},\n    }\n</code></pre>"},{"location":"deckgl/#anymap_ts.deckgl.DeckGLMap.add_terrain_layer","title":"<code>add_terrain_layer(self, elevation_data, name=None, texture=None, mesh_max_error=4.0, bounds=None, elevation_decoder=None, pickable=False, visible=True, opacity=1.0, wireframe=False, **kwargs)</code>","text":"<p>Add a terrain layer for 3D terrain visualization.</p> <p>Parameters:</p> Name Type Description Default <code>elevation_data</code> <code>Union[str, List[str]]</code> <p>URL to elevation tiles (e.g., Mapbox terrain).</p> required <code>name</code> <code>Optional[str]</code> <p>Layer ID.</p> <code>None</code> <code>texture</code> <code>Optional[str]</code> <p>URL to texture tiles for terrain surface.</p> <code>None</code> <code>mesh_max_error</code> <code>float</code> <p>Maximum mesh error in meters.</p> <code>4.0</code> <code>bounds</code> <code>Optional[List[float]]</code> <p>Bounding box [west, south, east, north].</p> <code>None</code> <code>elevation_decoder</code> <code>Optional[Dict]</code> <p>Decoder for elevation data format.</p> <code>None</code> <code>pickable</code> <code>bool</code> <p>Whether layer responds to hover/click.</p> <code>False</code> <code>visible</code> <code>bool</code> <p>Whether layer is visible.</p> <code>True</code> <code>opacity</code> <code>float</code> <p>Layer opacity (0-1).</p> <code>1.0</code> <code>wireframe</code> <code>bool</code> <p>Whether to render as wireframe.</p> <code>False</code> <code>**kwargs</code> <p>Additional TerrainLayer props.</p> <code>{}</code> Source code in <code>anymap_ts/deckgl.py</code> <pre><code>def add_terrain_layer(\n    self,\n    elevation_data: Union[str, List[str]],\n    name: Optional[str] = None,\n    texture: Optional[str] = None,\n    mesh_max_error: float = 4.0,\n    bounds: Optional[List[float]] = None,\n    elevation_decoder: Optional[Dict] = None,\n    pickable: bool = False,\n    visible: bool = True,\n    opacity: float = 1.0,\n    wireframe: bool = False,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a terrain layer for 3D terrain visualization.\n\n    Args:\n        elevation_data: URL to elevation tiles (e.g., Mapbox terrain).\n        name: Layer ID.\n        texture: URL to texture tiles for terrain surface.\n        mesh_max_error: Maximum mesh error in meters.\n        bounds: Bounding box [west, south, east, north].\n        elevation_decoder: Decoder for elevation data format.\n        pickable: Whether layer responds to hover/click.\n        visible: Whether layer is visible.\n        opacity: Layer opacity (0-1).\n        wireframe: Whether to render as wireframe.\n        **kwargs: Additional TerrainLayer props.\n    \"\"\"\n    layer_id = name or f\"terrain-{len(self._deck_layers)}\"\n\n    default_decoder = {\n        \"rScaler\": 256,\n        \"gScaler\": 1,\n        \"bScaler\": 1 / 256,\n        \"offset\": -32768,\n    }\n\n    self.call_js_method(\n        \"addTerrainLayer\",\n        id=layer_id,\n        elevationData=elevation_data,\n        texture=texture,\n        meshMaxError=mesh_max_error,\n        bounds=bounds,\n        elevationDecoder=elevation_decoder or default_decoder,\n        pickable=pickable,\n        visible=visible,\n        opacity=opacity,\n        wireframe=wireframe,\n        **kwargs,\n    )\n\n    self._deck_layers = {\n        **self._deck_layers,\n        layer_id: {\"type\": \"TerrainLayer\", \"id\": layer_id},\n    }\n</code></pre>"},{"location":"deckgl/#anymap_ts.deckgl.DeckGLMap.add_text_layer","title":"<code>add_text_layer(self, data, name=None, get_position='coordinates', get_text='text', get_size=12, get_color=None, get_angle=0, text_anchor='middle', alignment_baseline='center', pickable=True, opacity=1, **kwargs)</code>","text":"<p>Add a text layer for label visualization.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>Array of data objects with position and text.</p> required <code>name</code> <code>Optional[str]</code> <p>Layer ID.</p> <code>None</code> <code>get_position</code> <code>Union[str, Callable]</code> <p>Accessor for text position [lng, lat].</p> <code>'coordinates'</code> <code>get_text</code> <code>Union[str, Callable]</code> <p>Accessor for text content.</p> <code>'text'</code> <code>get_size</code> <code>Union[float, str, Callable]</code> <p>Accessor for text size.</p> <code>12</code> <code>get_color</code> <code>Union[List[int], str, Callable]</code> <p>Accessor for text color [r, g, b, a].</p> <code>None</code> <code>get_angle</code> <code>Union[float, str, Callable]</code> <p>Accessor for text rotation in degrees.</p> <code>0</code> <code>text_anchor</code> <code>str</code> <p>Horizontal alignment ('start', 'middle', 'end').</p> <code>'middle'</code> <code>alignment_baseline</code> <code>str</code> <p>Vertical alignment ('top', 'center', 'bottom').</p> <code>'center'</code> <code>pickable</code> <code>bool</code> <p>Whether layer responds to hover/click.</p> <code>True</code> <code>opacity</code> <code>float</code> <p>Layer opacity.</p> <code>1</code> <code>**kwargs</code> <p>Additional layer props.</p> <code>{}</code> Source code in <code>anymap_ts/deckgl.py</code> <pre><code>def add_text_layer(\n    self,\n    data: Any,\n    name: Optional[str] = None,\n    get_position: Union[str, Callable] = \"coordinates\",\n    get_text: Union[str, Callable] = \"text\",\n    get_size: Union[float, str, Callable] = 12,\n    get_color: Union[List[int], str, Callable] = None,\n    get_angle: Union[float, str, Callable] = 0,\n    text_anchor: str = \"middle\",\n    alignment_baseline: str = \"center\",\n    pickable: bool = True,\n    opacity: float = 1,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a text layer for label visualization.\n\n    Args:\n        data: Array of data objects with position and text.\n        name: Layer ID.\n        get_position: Accessor for text position [lng, lat].\n        get_text: Accessor for text content.\n        get_size: Accessor for text size.\n        get_color: Accessor for text color [r, g, b, a].\n        get_angle: Accessor for text rotation in degrees.\n        text_anchor: Horizontal alignment ('start', 'middle', 'end').\n        alignment_baseline: Vertical alignment ('top', 'center', 'bottom').\n        pickable: Whether layer responds to hover/click.\n        opacity: Layer opacity.\n        **kwargs: Additional layer props.\n    \"\"\"\n    layer_id = name or f\"text-{len(self._deck_layers)}\"\n    processed_data = self._process_deck_data(data)\n\n    self.call_js_method(\n        \"addTextLayer\",\n        id=layer_id,\n        data=processed_data,\n        getPosition=get_position,\n        getText=get_text,\n        getSize=get_size,\n        getColor=get_color or [0, 0, 0, 255],\n        getAngle=get_angle,\n        getTextAnchor=text_anchor,\n        getAlignmentBaseline=alignment_baseline,\n        pickable=pickable,\n        opacity=opacity,\n        **kwargs,\n    )\n\n    self._deck_layers = {\n        **self._deck_layers,\n        layer_id: {\"type\": \"TextLayer\", \"id\": layer_id},\n    }\n</code></pre>"},{"location":"deckgl/#anymap_ts.deckgl.DeckGLMap.add_tile3d_layer","title":"<code>add_tile3d_layer(self, data, name=None, point_size=1, pickable=True, visible=True, opacity=1.0, load_options=None, **kwargs)</code>","text":"<p>Add a 3D Tiles layer for 3D building/terrain visualization.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>str</code> <p>URL to tileset.json.</p> required <code>name</code> <code>Optional[str]</code> <p>Layer ID.</p> <code>None</code> <code>point_size</code> <code>float</code> <p>Point size for point cloud tiles.</p> <code>1</code> <code>pickable</code> <code>bool</code> <p>Whether layer responds to hover/click.</p> <code>True</code> <code>visible</code> <code>bool</code> <p>Whether layer is visible.</p> <code>True</code> <code>opacity</code> <code>float</code> <p>Layer opacity (0-1).</p> <code>1.0</code> <code>load_options</code> <code>Optional[Dict]</code> <p>Loader options for tile loading.</p> <code>None</code> <code>**kwargs</code> <p>Additional Tile3DLayer props.</p> <code>{}</code> Source code in <code>anymap_ts/deckgl.py</code> <pre><code>def add_tile3d_layer(\n    self,\n    data: str,\n    name: Optional[str] = None,\n    point_size: float = 1,\n    pickable: bool = True,\n    visible: bool = True,\n    opacity: float = 1.0,\n    load_options: Optional[Dict] = None,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a 3D Tiles layer for 3D building/terrain visualization.\n\n    Args:\n        data: URL to tileset.json.\n        name: Layer ID.\n        point_size: Point size for point cloud tiles.\n        pickable: Whether layer responds to hover/click.\n        visible: Whether layer is visible.\n        opacity: Layer opacity (0-1).\n        load_options: Loader options for tile loading.\n        **kwargs: Additional Tile3DLayer props.\n    \"\"\"\n    layer_id = name or f\"tile3d-{len(self._deck_layers)}\"\n\n    self.call_js_method(\n        \"addTile3DLayer\",\n        id=layer_id,\n        data=data,\n        pointSize=point_size,\n        pickable=pickable,\n        visible=visible,\n        opacity=opacity,\n        loadOptions=load_options or {},\n        **kwargs,\n    )\n\n    self._deck_layers = {\n        **self._deck_layers,\n        layer_id: {\"type\": \"Tile3DLayer\", \"id\": layer_id},\n    }\n</code></pre>"},{"location":"deckgl/#anymap_ts.deckgl.DeckGLMap.add_tile_layer","title":"<code>add_tile_layer(self, data, name=None, min_zoom=0, max_zoom=19, tile_size=256, pickable=False, visible=True, opacity=1.0, **kwargs)</code>","text":"<p>Add a tile layer for raster tile visualization.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Union[str, List[str]]</code> <p>Tile URL template with {z}/{x}/{y} placeholders.</p> required <code>name</code> <code>Optional[str]</code> <p>Layer ID.</p> <code>None</code> <code>min_zoom</code> <code>int</code> <p>Minimum zoom level.</p> <code>0</code> <code>max_zoom</code> <code>int</code> <p>Maximum zoom level.</p> <code>19</code> <code>tile_size</code> <code>int</code> <p>Tile size in pixels.</p> <code>256</code> <code>pickable</code> <code>bool</code> <p>Whether layer responds to hover/click.</p> <code>False</code> <code>visible</code> <code>bool</code> <p>Whether layer is visible.</p> <code>True</code> <code>opacity</code> <code>float</code> <p>Layer opacity (0-1).</p> <code>1.0</code> <code>**kwargs</code> <p>Additional TileLayer props.</p> <code>{}</code> Source code in <code>anymap_ts/deckgl.py</code> <pre><code>def add_tile_layer(\n    self,\n    data: Union[str, List[str]],\n    name: Optional[str] = None,\n    min_zoom: int = 0,\n    max_zoom: int = 19,\n    tile_size: int = 256,\n    pickable: bool = False,\n    visible: bool = True,\n    opacity: float = 1.0,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a tile layer for raster tile visualization.\n\n    Args:\n        data: Tile URL template with {z}/{x}/{y} placeholders.\n        name: Layer ID.\n        min_zoom: Minimum zoom level.\n        max_zoom: Maximum zoom level.\n        tile_size: Tile size in pixels.\n        pickable: Whether layer responds to hover/click.\n        visible: Whether layer is visible.\n        opacity: Layer opacity (0-1).\n        **kwargs: Additional TileLayer props.\n    \"\"\"\n    layer_id = name or f\"tile-{len(self._deck_layers)}\"\n\n    self.call_js_method(\n        \"addTileLayer\",\n        id=layer_id,\n        data=data,\n        minZoom=min_zoom,\n        maxZoom=max_zoom,\n        tileSize=tile_size,\n        pickable=pickable,\n        visible=visible,\n        opacity=opacity,\n        **kwargs,\n    )\n\n    self._deck_layers = {\n        **self._deck_layers,\n        layer_id: {\"type\": \"TileLayer\", \"id\": layer_id},\n    }\n</code></pre>"},{"location":"deckgl/#anymap_ts.deckgl.DeckGLMap.add_trips_layer","title":"<code>add_trips_layer(self, data, name=None, get_path='waypoints', get_timestamps='timestamps', get_color=None, width_min_pixels=2, trail_length=180, current_time=0, pickable=True, opacity=0.8, **kwargs)</code>","text":"<p>Add a trips layer for animated path visualization.</p> <p>The TripsLayer renders animated paths showing movement over time, ideal for visualizing vehicle routes, migration patterns, or any time-based trajectory data.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>Array of trip objects with waypoints and timestamps.</p> required <code>name</code> <code>Optional[str]</code> <p>Layer ID. If None, auto-generated.</p> <code>None</code> <code>get_path</code> <code>Union[str, Callable]</code> <p>Accessor for waypoint coordinates [[lng, lat], ...].</p> <code>'waypoints'</code> <code>get_timestamps</code> <code>Union[str, Callable]</code> <p>Accessor for timestamps at each waypoint.</p> <code>'timestamps'</code> <code>get_color</code> <code>Union[List[int], str, Callable]</code> <p>Accessor for trip color [r, g, b] or [r, g, b, a].</p> <code>None</code> <code>width_min_pixels</code> <code>float</code> <p>Minimum trail width in pixels.</p> <code>2</code> <code>trail_length</code> <code>float</code> <p>Trail length in timestamp units.</p> <code>180</code> <code>current_time</code> <code>float</code> <p>Current animation time.</p> <code>0</code> <code>pickable</code> <code>bool</code> <p>Whether layer responds to hover/click.</p> <code>True</code> <code>opacity</code> <code>float</code> <p>Layer opacity (0-1).</p> <code>0.8</code> <code>**kwargs</code> <p>Additional TripsLayer props.</p> <code>{}</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; m = DeckGLMap()\n&gt;&gt;&gt; trips = [\n...     {\n...         \"waypoints\": [[-122.4, 37.8], [-122.5, 37.7], [-122.6, 37.8]],\n...         \"timestamps\": [0, 50, 100]\n...     }\n... ]\n&gt;&gt;&gt; m.add_trips_layer(\n...     data=trips,\n...     trail_length=180,\n...     current_time=50,\n... )\n</code></pre> Source code in <code>anymap_ts/deckgl.py</code> <pre><code>def add_trips_layer(\n    self,\n    data: Any,\n    name: Optional[str] = None,\n    get_path: Union[str, Callable] = \"waypoints\",\n    get_timestamps: Union[str, Callable] = \"timestamps\",\n    get_color: Union[List[int], str, Callable] = None,\n    width_min_pixels: float = 2,\n    trail_length: float = 180,\n    current_time: float = 0,\n    pickable: bool = True,\n    opacity: float = 0.8,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a trips layer for animated path visualization.\n\n    The TripsLayer renders animated paths showing movement over time,\n    ideal for visualizing vehicle routes, migration patterns, or any\n    time-based trajectory data.\n\n    Args:\n        data: Array of trip objects with waypoints and timestamps.\n        name: Layer ID. If None, auto-generated.\n        get_path: Accessor for waypoint coordinates [[lng, lat], ...].\n        get_timestamps: Accessor for timestamps at each waypoint.\n        get_color: Accessor for trip color [r, g, b] or [r, g, b, a].\n        width_min_pixels: Minimum trail width in pixels.\n        trail_length: Trail length in timestamp units.\n        current_time: Current animation time.\n        pickable: Whether layer responds to hover/click.\n        opacity: Layer opacity (0-1).\n        **kwargs: Additional TripsLayer props.\n\n    Example:\n        &gt;&gt;&gt; m = DeckGLMap()\n        &gt;&gt;&gt; trips = [\n        ...     {\n        ...         \"waypoints\": [[-122.4, 37.8], [-122.5, 37.7], [-122.6, 37.8]],\n        ...         \"timestamps\": [0, 50, 100]\n        ...     }\n        ... ]\n        &gt;&gt;&gt; m.add_trips_layer(\n        ...     data=trips,\n        ...     trail_length=180,\n        ...     current_time=50,\n        ... )\n    \"\"\"\n    layer_id = name or f\"trips-{len(self._deck_layers)}\"\n    processed_data = self._process_deck_data(data)\n\n    self.call_js_method(\n        \"addTripsLayer\",\n        id=layer_id,\n        data=processed_data,\n        getPath=get_path,\n        getTimestamps=get_timestamps,\n        getColor=get_color or [253, 128, 93],\n        widthMinPixels=width_min_pixels,\n        trailLength=trail_length,\n        currentTime=current_time,\n        pickable=pickable,\n        opacity=opacity,\n        **kwargs,\n    )\n\n    self._deck_layers = {\n        **self._deck_layers,\n        layer_id: {\"type\": \"TripsLayer\", \"id\": layer_id},\n    }\n</code></pre>"},{"location":"deckgl/#anymap_ts.deckgl.DeckGLMap.add_wms_layer","title":"<code>add_wms_layer(self, data, name=None, service_type='wms', layers=None, srs=None, pickable=False, visible=True, opacity=1.0, **kwargs)</code>","text":"<p>Add a WMS layer for OGC Web Map Service visualization.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>str</code> <p>WMS base URL.</p> required <code>name</code> <code>Optional[str]</code> <p>Layer ID.</p> <code>None</code> <code>service_type</code> <code>str</code> <p>Service type ('wms' or 'template').</p> <code>'wms'</code> <code>layers</code> <code>Optional[List[str]]</code> <p>WMS layer names to request.</p> <code>None</code> <code>srs</code> <code>Optional[str]</code> <p>Spatial reference system (e.g., 'EPSG:4326').</p> <code>None</code> <code>pickable</code> <code>bool</code> <p>Whether layer responds to hover/click.</p> <code>False</code> <code>visible</code> <code>bool</code> <p>Whether layer is visible.</p> <code>True</code> <code>opacity</code> <code>float</code> <p>Layer opacity (0-1).</p> <code>1.0</code> <code>**kwargs</code> <p>Additional WMSLayer props.</p> <code>{}</code> Source code in <code>anymap_ts/deckgl.py</code> <pre><code>def add_wms_layer(\n    self,\n    data: str,\n    name: Optional[str] = None,\n    service_type: str = \"wms\",\n    layers: Optional[List[str]] = None,\n    srs: Optional[str] = None,\n    pickable: bool = False,\n    visible: bool = True,\n    opacity: float = 1.0,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a WMS layer for OGC Web Map Service visualization.\n\n    Args:\n        data: WMS base URL.\n        name: Layer ID.\n        service_type: Service type ('wms' or 'template').\n        layers: WMS layer names to request.\n        srs: Spatial reference system (e.g., 'EPSG:4326').\n        pickable: Whether layer responds to hover/click.\n        visible: Whether layer is visible.\n        opacity: Layer opacity (0-1).\n        **kwargs: Additional WMSLayer props.\n    \"\"\"\n    layer_id = name or f\"wms-{len(self._deck_layers)}\"\n\n    self.call_js_method(\n        \"addWMSLayer\",\n        id=layer_id,\n        data=data,\n        serviceType=service_type,\n        layers=layers,\n        srs=srs,\n        pickable=pickable,\n        visible=visible,\n        opacity=opacity,\n        **kwargs,\n    )\n\n    self._deck_layers = {\n        **self._deck_layers,\n        layer_id: {\"type\": \"WMSLayer\", \"id\": layer_id},\n    }\n</code></pre>"},{"location":"deckgl/#anymap_ts.deckgl.DeckGLMap.remove_cog_layer","title":"<code>remove_cog_layer(self, layer_id)</code>","text":"<p>Remove a COG layer.</p> <p>Parameters:</p> Name Type Description Default <code>layer_id</code> <code>str</code> <p>Layer identifier to remove.</p> required Source code in <code>anymap_ts/deckgl.py</code> <pre><code>def remove_cog_layer(self, layer_id: str) -&gt; None:\n    \"\"\"Remove a COG layer.\n\n    Args:\n        layer_id: Layer identifier to remove.\n    \"\"\"\n    self.remove_deck_layer(layer_id)\n</code></pre>"},{"location":"deckgl/#anymap_ts.deckgl.DeckGLMap.remove_deck_layer","title":"<code>remove_deck_layer(self, layer_id)</code>","text":"<p>Remove a deck.gl layer.</p> <p>Parameters:</p> Name Type Description Default <code>layer_id</code> <code>str</code> <p>Layer identifier to remove.</p> required Source code in <code>anymap_ts/deckgl.py</code> <pre><code>def remove_deck_layer(self, layer_id: str) -&gt; None:\n    \"\"\"Remove a deck.gl layer.\n\n    Args:\n        layer_id: Layer identifier to remove.\n    \"\"\"\n    if layer_id in self._deck_layers:\n        layers = dict(self._deck_layers)\n        del layers[layer_id]\n        self._deck_layers = layers\n    self.call_js_method(\"removeDeckLayer\", layer_id)\n</code></pre>"},{"location":"deckgl/#anymap_ts.deckgl.DeckGLMap.set_deck_layer_visibility","title":"<code>set_deck_layer_visibility(self, layer_id, visible)</code>","text":"<p>Set deck.gl layer visibility.</p> <p>Parameters:</p> Name Type Description Default <code>layer_id</code> <code>str</code> <p>Layer identifier.</p> required <code>visible</code> <code>bool</code> <p>Whether layer should be visible.</p> required Source code in <code>anymap_ts/deckgl.py</code> <pre><code>def set_deck_layer_visibility(self, layer_id: str, visible: bool) -&gt; None:\n    \"\"\"Set deck.gl layer visibility.\n\n    Args:\n        layer_id: Layer identifier.\n        visible: Whether layer should be visible.\n    \"\"\"\n    self.call_js_method(\"setDeckLayerVisibility\", layer_id, visible)\n</code></pre>"},{"location":"installation/","title":"Installation","text":""},{"location":"installation/#stable-release","title":"Stable release","text":"<p>To install anymap-ts from PyPI, run this command in your terminal:</p> <pre><code>pip install anymap-ts\n</code></pre> <p>To install anymap-ts from conda-forge, run this command in your terminal:</p> <pre><code>conda install -c conda-forge anymap-ts\n</code></pre>"},{"location":"installation/#from-sources","title":"From sources","text":"<p>To install anymap-ts from sources, run this command in your terminal:</p> <pre><code>pip install git+https://github.com/opengeos/anymap-ts\n</code></pre>"},{"location":"installation/#optional-dependencies","title":"Optional dependencies","text":"<pre><code># For vector data support (GeoDataFrame)\npip install anymap-ts[vector]\n\n# For local raster support (localtileserver)\npip install anymap-ts[raster]\n\n# All optional dependencies\npip install anymap-ts[all]\n</code></pre>"},{"location":"installation/#development-installation","title":"Development installation","text":"<pre><code>git clone https://github.com/opengeos/anymap-ts.git\ncd anymap-ts\npip install -e \".[dev]\"\n</code></pre>"},{"location":"installation/#environment-variables","title":"Environment Variables","text":"Variable Library Description <code>MAPBOX_TOKEN</code> Mapbox, KeplerGL Mapbox access token <code>CESIUM_TOKEN</code> Cesium Cesium Ion access token"},{"location":"keplergl/","title":"keplergl module","text":"<p>KeplerGL map widget implementation.</p> <p>KeplerGL is loaded via CDN since it's React-based and requires complex setup. This implementation provides a Python wrapper with data management capabilities.</p>"},{"location":"keplergl/#anymap_ts.keplergl.KeplerGLMap","title":"<code> KeplerGLMap            (MapWidget)         </code>","text":"<p>Interactive map widget using KeplerGL.</p> <p>KeplerGL is a powerful data visualization tool built on top of deck.gl. This class provides a Python interface for adding data and configuring the KeplerGL visualization.</p> <p>Note: KeplerGL is loaded from CDN due to its React-based architecture.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from anymap_ts import KeplerGLMap\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; m = KeplerGLMap()\n&gt;&gt;&gt; df = pd.DataFrame({\n...     'lat': [37.7749, 37.8044],\n...     'lng': [-122.4194, -122.2712],\n...     'value': [100, 200]\n... })\n&gt;&gt;&gt; m.add_data(df, name='points')\n&gt;&gt;&gt; m\n</code></pre> Source code in <code>anymap_ts/keplergl.py</code> <pre><code>class KeplerGLMap(MapWidget):\n    \"\"\"Interactive map widget using KeplerGL.\n\n    KeplerGL is a powerful data visualization tool built on top of deck.gl.\n    This class provides a Python interface for adding data and configuring\n    the KeplerGL visualization.\n\n    Note: KeplerGL is loaded from CDN due to its React-based architecture.\n\n    Example:\n        &gt;&gt;&gt; from anymap_ts import KeplerGLMap\n        &gt;&gt;&gt; import pandas as pd\n        &gt;&gt;&gt; m = KeplerGLMap()\n        &gt;&gt;&gt; df = pd.DataFrame({\n        ...     'lat': [37.7749, 37.8044],\n        ...     'lng': [-122.4194, -122.2712],\n        ...     'value': [100, 200]\n        ... })\n        &gt;&gt;&gt; m.add_data(df, name='points')\n        &gt;&gt;&gt; m\n    \"\"\"\n\n    # ESM module for frontend\n    _esm = STATIC_DIR / \"keplergl.js\"\n\n    # KeplerGL-specific traits\n    config = traitlets.Dict({}).tag(sync=True)\n    datasets = traitlets.Dict({}).tag(sync=True)\n    read_only = traitlets.Bool(False).tag(sync=True)\n    show_data_table = traitlets.Bool(True).tag(sync=True)\n\n    # Mapbox token for basemaps\n    mapbox_token = traitlets.Unicode(\"\").tag(sync=True)\n\n    def __init__(\n        self,\n        center: Tuple[float, float] = (-122.4, 37.8),\n        zoom: float = 10.0,\n        width: str = \"100%\",\n        height: str = \"600px\",\n        config: Optional[Dict] = None,\n        read_only: bool = False,\n        show_data_table: bool = True,\n        mapbox_token: Optional[str] = None,\n        **kwargs,\n    ):\n        \"\"\"Initialize a KeplerGL map.\n\n        Args:\n            center: Map center as (longitude, latitude).\n            zoom: Initial zoom level.\n            width: Widget width as CSS string.\n            height: Widget height as CSS string.\n            config: KeplerGL configuration dict.\n            read_only: Whether the UI is read-only.\n            show_data_table: Whether to show the data table panel.\n            mapbox_token: Mapbox access token for basemaps.\n            **kwargs: Additional widget arguments.\n        \"\"\"\n        import os\n\n        if mapbox_token is None:\n            mapbox_token = os.environ.get(\"MAPBOX_TOKEN\", \"\")\n\n        super().__init__(\n            center=list(center),\n            zoom=zoom,\n            width=width,\n            height=height,\n            config=config or {},\n            read_only=read_only,\n            show_data_table=show_data_table,\n            mapbox_token=mapbox_token,\n            **kwargs,\n        )\n        self.datasets = {}\n\n    # -------------------------------------------------------------------------\n    # Data Methods\n    # -------------------------------------------------------------------------\n\n    def add_data(\n        self,\n        data: Any,\n        name: Optional[str] = None,\n    ) -&gt; None:\n        \"\"\"Add data to the map.\n\n        Args:\n            data: Data to add (DataFrame, GeoDataFrame, dict, or file path).\n            name: Dataset name/label.\n        \"\"\"\n        dataset_id = name or f\"data_{uuid.uuid4().hex[:8]}\"\n        processed_data = self._process_data(data)\n\n        self.datasets = {\n            **self.datasets,\n            dataset_id: {\n                \"info\": {\n                    \"id\": dataset_id,\n                    \"label\": dataset_id,\n                },\n                \"data\": processed_data,\n            },\n        }\n\n        self.call_js_method(\n            \"addData\",\n            dataId=dataset_id,\n            data=processed_data,\n        )\n\n    def _process_data(self, data: Any) -&gt; Dict:\n        \"\"\"Process data into KeplerGL format.\n\n        Args:\n            data: Input data.\n\n        Returns:\n            Processed data dict with fields and rows.\n        \"\"\"\n        # Handle DataFrame\n        if hasattr(data, \"to_dict\"):\n            # Check if it's a GeoDataFrame\n            if hasattr(data, \"geometry\"):\n                # Convert to GeoJSON for geometry columns\n                geojson = json.loads(data.to_json())\n                return {\n                    \"type\": \"geojson\",\n                    \"data\": geojson,\n                }\n            else:\n                # Regular DataFrame\n                fields = []\n                for col in data.columns:\n                    dtype = str(data[col].dtype)\n                    if \"int\" in dtype:\n                        field_type = \"integer\"\n                    elif \"float\" in dtype:\n                        field_type = \"real\"\n                    elif \"datetime\" in dtype:\n                        field_type = \"timestamp\"\n                    elif \"bool\" in dtype:\n                        field_type = \"boolean\"\n                    else:\n                        field_type = \"string\"\n\n                    fields.append({\"name\": col, \"type\": field_type})\n\n                # Convert to list of lists\n                rows = data.values.tolist()\n\n                return {\n                    \"fields\": fields,\n                    \"rows\": rows,\n                }\n\n        # Handle dict (assume it's already GeoJSON or processed)\n        if isinstance(data, dict):\n            if \"type\" in data and data[\"type\"] in [\n                \"FeatureCollection\",\n                \"Feature\",\n                \"Point\",\n                \"LineString\",\n                \"Polygon\",\n                \"MultiPoint\",\n                \"MultiLineString\",\n                \"MultiPolygon\",\n            ]:\n                return {\"type\": \"geojson\", \"data\": data}\n            return data\n\n        # Handle file path\n        if isinstance(data, (str, Path)):\n            path = Path(data)\n            if path.exists():\n                if path.suffix.lower() in [\".geojson\", \".json\"]:\n                    with open(path) as f:\n                        geojson = json.load(f)\n                    return {\"type\": \"geojson\", \"data\": geojson}\n                elif path.suffix.lower() == \".csv\":\n                    try:\n                        import pandas as pd\n\n                        df = pd.read_csv(path)\n                        return self._process_data(df)\n                    except ImportError:\n                        raise ImportError(\n                            \"pandas is required to load CSV files. \"\n                            \"Install with: pip install pandas\"\n                        )\n\n        return data\n\n    def remove_data(self, name: str) -&gt; None:\n        \"\"\"Remove a dataset.\n\n        Args:\n            name: Dataset name to remove.\n        \"\"\"\n        if name in self.datasets:\n            datasets = dict(self.datasets)\n            del datasets[name]\n            self.datasets = datasets\n        self.call_js_method(\"removeData\", dataId=name)\n\n    # -------------------------------------------------------------------------\n    # Configuration Methods\n    # -------------------------------------------------------------------------\n\n    def set_config(self, config: Dict) -&gt; None:\n        \"\"\"Set the KeplerGL configuration.\n\n        Args:\n            config: Configuration dict.\n        \"\"\"\n        self.config = config\n        self.call_js_method(\"setConfig\", config=config)\n\n    def get_config(self) -&gt; Dict:\n        \"\"\"Get the current KeplerGL configuration.\n\n        Returns:\n            Configuration dict.\n        \"\"\"\n        return self.config\n\n    def save_config(self, filepath: Union[str, Path]) -&gt; None:\n        \"\"\"Save configuration to a JSON file.\n\n        Args:\n            filepath: Path to save the configuration.\n        \"\"\"\n        with open(filepath, \"w\") as f:\n            json.dump(self.config, f, indent=2)\n\n    def load_config(self, filepath: Union[str, Path]) -&gt; None:\n        \"\"\"Load configuration from a JSON file.\n\n        Args:\n            filepath: Path to the configuration file.\n        \"\"\"\n        with open(filepath) as f:\n            config = json.load(f)\n        self.set_config(config)\n\n    # -------------------------------------------------------------------------\n    # Filter Methods\n    # -------------------------------------------------------------------------\n\n    def add_filter(\n        self,\n        data_id: str,\n        field: str,\n        filter_type: str = \"range\",\n        value: Optional[Any] = None,\n    ) -&gt; None:\n        \"\"\"Add a filter to the visualization.\n\n        Args:\n            data_id: Dataset ID to filter.\n            field: Field name to filter on.\n            filter_type: Type of filter ('range', 'select', 'time').\n            value: Filter value(s).\n        \"\"\"\n        filter_config = {\n            \"dataId\": [data_id],\n            \"name\": [field],\n            \"type\": filter_type,\n        }\n        if value is not None:\n            filter_config[\"value\"] = value\n\n        self.call_js_method(\"addFilter\", filter=filter_config)\n\n    # -------------------------------------------------------------------------\n    # Layer Methods\n    # -------------------------------------------------------------------------\n\n    def add_layer(\n        self,\n        layer_type: str,\n        data_id: str,\n        columns: Dict[str, str],\n        label: Optional[str] = None,\n        color: Optional[List[int]] = None,\n        vis_config: Optional[Dict] = None,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a layer to the visualization.\n\n        Args:\n            layer_type: Layer type ('point', 'arc', 'line', 'hexagon', 'heatmap', etc.).\n            data_id: Dataset ID for the layer.\n            columns: Column mapping (e.g., {'lat': 'latitude', 'lng': 'longitude'}).\n            label: Layer label.\n            color: Layer color as [r, g, b].\n            vis_config: Visual configuration.\n            **kwargs: Additional layer options.\n        \"\"\"\n        layer_config = {\n            \"type\": layer_type,\n            \"config\": {\n                \"dataId\": data_id,\n                \"label\": label or f\"{layer_type}_layer\",\n                \"columns\": columns,\n                \"isVisible\": True,\n            },\n        }\n        if color:\n            layer_config[\"config\"][\"color\"] = color\n        if vis_config:\n            layer_config[\"config\"][\"visConfig\"] = vis_config\n\n        layer_config[\"config\"].update(kwargs)\n\n        self.call_js_method(\"addLayer\", layer=layer_config)\n\n    # -------------------------------------------------------------------------\n    # View Methods\n    # -------------------------------------------------------------------------\n\n    def fly_to(\n        self,\n        lng: float,\n        lat: float,\n        zoom: Optional[float] = None,\n    ) -&gt; None:\n        \"\"\"Fly to a location.\n\n        Args:\n            lng: Target longitude.\n            lat: Target latitude.\n            zoom: Target zoom level.\n        \"\"\"\n        self.center = [lng, lat]\n        if zoom is not None:\n            self.zoom = zoom\n        self.call_js_method(\"flyTo\", lng=lng, lat=lat, zoom=zoom or self.zoom)\n\n    # -------------------------------------------------------------------------\n    # HTML Export\n    # -------------------------------------------------------------------------\n\n    def _generate_html_template(self) -&gt; str:\n        \"\"\"Generate standalone HTML for KeplerGL.\"\"\"\n        template_path = Path(__file__).parent / \"templates\" / \"keplergl.html\"\n\n        if template_path.exists():\n            template = template_path.read_text(encoding=\"utf-8\")\n        else:\n            template = self._get_default_template()\n\n        state = {\n            \"center\": self.center,\n            \"zoom\": self.zoom,\n            \"config\": self.config,\n            \"datasets\": self.datasets,\n            \"read_only\": self.read_only,\n            \"mapbox_token\": self.mapbox_token,\n            \"width\": self.width,\n            \"height\": self.height,\n            \"js_calls\": self._js_calls,\n        }\n\n        template = template.replace(\"{{state}}\", json.dumps(state, indent=2))\n        return template\n\n    def _get_default_template(self) -&gt; str:\n        \"\"\"Get default HTML template.\"\"\"\n        return \"\"\"&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n    &lt;meta charset=\"utf-8\"&gt;\n    &lt;title&gt;KeplerGL Map&lt;/title&gt;\n    &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"&gt;\n    &lt;style&gt;\n        * { margin: 0; padding: 0; box-sizing: border-box; }\n        html, body { height: 100%; }\n        #app { position: absolute; top: 0; bottom: 0; width: 100%; }\n    &lt;/style&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;div id=\"app\"&gt;&lt;/div&gt;\n    &lt;script&gt;\n        const state = {{state}};\n        // KeplerGL requires React/Redux setup - simplified placeholder\n        document.getElementById('app').innerHTML = '&lt;p&gt;KeplerGL visualization requires full React setup. Use Jupyter widget for interactive visualization.&lt;/p&gt;';\n    &lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\"\"\"\n\n    def _repr_html_(self) -&gt; str:\n        \"\"\"Return HTML representation for Jupyter (uses iframe with CDN KeplerGL).\"\"\"\n        state = {\n            \"center\": self.center,\n            \"zoom\": self.zoom,\n            \"config\": self.config,\n            \"datasets\": self.datasets,\n            \"mapbox_token\": self.mapbox_token,\n        }\n\n        html = f\"\"\"\n        &lt;iframe\n            srcdoc='\n            &lt;!DOCTYPE html&gt;\n            &lt;html&gt;\n            &lt;head&gt;\n                &lt;meta charset=\"utf-8\"&gt;\n                &lt;script src=\"https://unpkg.com/react@16.8.4/umd/react.production.min.js\"&gt;&lt;/script&gt;\n                &lt;script src=\"https://unpkg.com/react-dom@16.8.4/umd/react-dom.production.min.js\"&gt;&lt;/script&gt;\n                &lt;script src=\"https://unpkg.com/kepler.gl@3.0.0/umd/keplergl.min.js\"&gt;&lt;/script&gt;\n                &lt;link href=\"https://unpkg.com/kepler.gl@3.0.0/umd/keplergl.min.css\" rel=\"stylesheet\" /&gt;\n                &lt;style&gt;\n                    body {{ margin: 0; padding: 0; overflow: hidden; }}\n                    #app {{ width: 100vw; height: 100vh; }}\n                &lt;/style&gt;\n            &lt;/head&gt;\n            &lt;body&gt;\n                &lt;div id=\"app\"&gt;&lt;/div&gt;\n                &lt;script&gt;\n                    const state = {json.dumps(state)};\n                    // KeplerGL requires complex React setup\n                    document.getElementById(\"app\").innerHTML = \"KeplerGL widget - use anywidget interface for full interactivity\";\n                &lt;/script&gt;\n            &lt;/body&gt;\n            &lt;/html&gt;\n            '\n            width=\"{self.width}\"\n            height=\"{self.height}\"\n            frameborder=\"0\"\n        &gt;&lt;/iframe&gt;\n        \"\"\"\n        return html\n</code></pre>"},{"location":"keplergl/#anymap_ts.keplergl.KeplerGLMap.__init__","title":"<code>__init__(self, center=(-122.4, 37.8), zoom=10.0, width='100%', height='600px', config=None, read_only=False, show_data_table=True, mapbox_token=None, **kwargs)</code>  <code>special</code>","text":"<p>Initialize a KeplerGL map.</p> <p>Parameters:</p> Name Type Description Default <code>center</code> <code>Tuple[float, float]</code> <p>Map center as (longitude, latitude).</p> <code>(-122.4, 37.8)</code> <code>zoom</code> <code>float</code> <p>Initial zoom level.</p> <code>10.0</code> <code>width</code> <code>str</code> <p>Widget width as CSS string.</p> <code>'100%'</code> <code>height</code> <code>str</code> <p>Widget height as CSS string.</p> <code>'600px'</code> <code>config</code> <code>Optional[Dict]</code> <p>KeplerGL configuration dict.</p> <code>None</code> <code>read_only</code> <code>bool</code> <p>Whether the UI is read-only.</p> <code>False</code> <code>show_data_table</code> <code>bool</code> <p>Whether to show the data table panel.</p> <code>True</code> <code>mapbox_token</code> <code>Optional[str]</code> <p>Mapbox access token for basemaps.</p> <code>None</code> <code>**kwargs</code> <p>Additional widget arguments.</p> <code>{}</code> Source code in <code>anymap_ts/keplergl.py</code> <pre><code>def __init__(\n    self,\n    center: Tuple[float, float] = (-122.4, 37.8),\n    zoom: float = 10.0,\n    width: str = \"100%\",\n    height: str = \"600px\",\n    config: Optional[Dict] = None,\n    read_only: bool = False,\n    show_data_table: bool = True,\n    mapbox_token: Optional[str] = None,\n    **kwargs,\n):\n    \"\"\"Initialize a KeplerGL map.\n\n    Args:\n        center: Map center as (longitude, latitude).\n        zoom: Initial zoom level.\n        width: Widget width as CSS string.\n        height: Widget height as CSS string.\n        config: KeplerGL configuration dict.\n        read_only: Whether the UI is read-only.\n        show_data_table: Whether to show the data table panel.\n        mapbox_token: Mapbox access token for basemaps.\n        **kwargs: Additional widget arguments.\n    \"\"\"\n    import os\n\n    if mapbox_token is None:\n        mapbox_token = os.environ.get(\"MAPBOX_TOKEN\", \"\")\n\n    super().__init__(\n        center=list(center),\n        zoom=zoom,\n        width=width,\n        height=height,\n        config=config or {},\n        read_only=read_only,\n        show_data_table=show_data_table,\n        mapbox_token=mapbox_token,\n        **kwargs,\n    )\n    self.datasets = {}\n</code></pre>"},{"location":"keplergl/#anymap_ts.keplergl.KeplerGLMap.add_data","title":"<code>add_data(self, data, name=None)</code>","text":"<p>Add data to the map.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>Data to add (DataFrame, GeoDataFrame, dict, or file path).</p> required <code>name</code> <code>Optional[str]</code> <p>Dataset name/label.</p> <code>None</code> Source code in <code>anymap_ts/keplergl.py</code> <pre><code>def add_data(\n    self,\n    data: Any,\n    name: Optional[str] = None,\n) -&gt; None:\n    \"\"\"Add data to the map.\n\n    Args:\n        data: Data to add (DataFrame, GeoDataFrame, dict, or file path).\n        name: Dataset name/label.\n    \"\"\"\n    dataset_id = name or f\"data_{uuid.uuid4().hex[:8]}\"\n    processed_data = self._process_data(data)\n\n    self.datasets = {\n        **self.datasets,\n        dataset_id: {\n            \"info\": {\n                \"id\": dataset_id,\n                \"label\": dataset_id,\n            },\n            \"data\": processed_data,\n        },\n    }\n\n    self.call_js_method(\n        \"addData\",\n        dataId=dataset_id,\n        data=processed_data,\n    )\n</code></pre>"},{"location":"keplergl/#anymap_ts.keplergl.KeplerGLMap.add_filter","title":"<code>add_filter(self, data_id, field, filter_type='range', value=None)</code>","text":"<p>Add a filter to the visualization.</p> <p>Parameters:</p> Name Type Description Default <code>data_id</code> <code>str</code> <p>Dataset ID to filter.</p> required <code>field</code> <code>str</code> <p>Field name to filter on.</p> required <code>filter_type</code> <code>str</code> <p>Type of filter ('range', 'select', 'time').</p> <code>'range'</code> <code>value</code> <code>Optional[Any]</code> <p>Filter value(s).</p> <code>None</code> Source code in <code>anymap_ts/keplergl.py</code> <pre><code>def add_filter(\n    self,\n    data_id: str,\n    field: str,\n    filter_type: str = \"range\",\n    value: Optional[Any] = None,\n) -&gt; None:\n    \"\"\"Add a filter to the visualization.\n\n    Args:\n        data_id: Dataset ID to filter.\n        field: Field name to filter on.\n        filter_type: Type of filter ('range', 'select', 'time').\n        value: Filter value(s).\n    \"\"\"\n    filter_config = {\n        \"dataId\": [data_id],\n        \"name\": [field],\n        \"type\": filter_type,\n    }\n    if value is not None:\n        filter_config[\"value\"] = value\n\n    self.call_js_method(\"addFilter\", filter=filter_config)\n</code></pre>"},{"location":"keplergl/#anymap_ts.keplergl.KeplerGLMap.add_layer","title":"<code>add_layer(self, layer_type, data_id, columns, label=None, color=None, vis_config=None, **kwargs)</code>","text":"<p>Add a layer to the visualization.</p> <p>Parameters:</p> Name Type Description Default <code>layer_type</code> <code>str</code> <p>Layer type ('point', 'arc', 'line', 'hexagon', 'heatmap', etc.).</p> required <code>data_id</code> <code>str</code> <p>Dataset ID for the layer.</p> required <code>columns</code> <code>Dict[str, str]</code> <p>Column mapping (e.g., {'lat': 'latitude', 'lng': 'longitude'}).</p> required <code>label</code> <code>Optional[str]</code> <p>Layer label.</p> <code>None</code> <code>color</code> <code>Optional[List[int]]</code> <p>Layer color as [r, g, b].</p> <code>None</code> <code>vis_config</code> <code>Optional[Dict]</code> <p>Visual configuration.</p> <code>None</code> <code>**kwargs</code> <p>Additional layer options.</p> <code>{}</code> Source code in <code>anymap_ts/keplergl.py</code> <pre><code>def add_layer(\n    self,\n    layer_type: str,\n    data_id: str,\n    columns: Dict[str, str],\n    label: Optional[str] = None,\n    color: Optional[List[int]] = None,\n    vis_config: Optional[Dict] = None,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a layer to the visualization.\n\n    Args:\n        layer_type: Layer type ('point', 'arc', 'line', 'hexagon', 'heatmap', etc.).\n        data_id: Dataset ID for the layer.\n        columns: Column mapping (e.g., {'lat': 'latitude', 'lng': 'longitude'}).\n        label: Layer label.\n        color: Layer color as [r, g, b].\n        vis_config: Visual configuration.\n        **kwargs: Additional layer options.\n    \"\"\"\n    layer_config = {\n        \"type\": layer_type,\n        \"config\": {\n            \"dataId\": data_id,\n            \"label\": label or f\"{layer_type}_layer\",\n            \"columns\": columns,\n            \"isVisible\": True,\n        },\n    }\n    if color:\n        layer_config[\"config\"][\"color\"] = color\n    if vis_config:\n        layer_config[\"config\"][\"visConfig\"] = vis_config\n\n    layer_config[\"config\"].update(kwargs)\n\n    self.call_js_method(\"addLayer\", layer=layer_config)\n</code></pre>"},{"location":"keplergl/#anymap_ts.keplergl.KeplerGLMap.fly_to","title":"<code>fly_to(self, lng, lat, zoom=None)</code>","text":"<p>Fly to a location.</p> <p>Parameters:</p> Name Type Description Default <code>lng</code> <code>float</code> <p>Target longitude.</p> required <code>lat</code> <code>float</code> <p>Target latitude.</p> required <code>zoom</code> <code>Optional[float]</code> <p>Target zoom level.</p> <code>None</code> Source code in <code>anymap_ts/keplergl.py</code> <pre><code>def fly_to(\n    self,\n    lng: float,\n    lat: float,\n    zoom: Optional[float] = None,\n) -&gt; None:\n    \"\"\"Fly to a location.\n\n    Args:\n        lng: Target longitude.\n        lat: Target latitude.\n        zoom: Target zoom level.\n    \"\"\"\n    self.center = [lng, lat]\n    if zoom is not None:\n        self.zoom = zoom\n    self.call_js_method(\"flyTo\", lng=lng, lat=lat, zoom=zoom or self.zoom)\n</code></pre>"},{"location":"keplergl/#anymap_ts.keplergl.KeplerGLMap.get_config","title":"<code>get_config(self)</code>","text":"<p>Get the current KeplerGL configuration.</p> <p>Returns:</p> Type Description <code>Dict</code> <p>Configuration dict.</p> Source code in <code>anymap_ts/keplergl.py</code> <pre><code>def get_config(self) -&gt; Dict:\n    \"\"\"Get the current KeplerGL configuration.\n\n    Returns:\n        Configuration dict.\n    \"\"\"\n    return self.config\n</code></pre>"},{"location":"keplergl/#anymap_ts.keplergl.KeplerGLMap.load_config","title":"<code>load_config(self, filepath)</code>","text":"<p>Load configuration from a JSON file.</p> <p>Parameters:</p> Name Type Description Default <code>filepath</code> <code>Union[str, Path]</code> <p>Path to the configuration file.</p> required Source code in <code>anymap_ts/keplergl.py</code> <pre><code>def load_config(self, filepath: Union[str, Path]) -&gt; None:\n    \"\"\"Load configuration from a JSON file.\n\n    Args:\n        filepath: Path to the configuration file.\n    \"\"\"\n    with open(filepath) as f:\n        config = json.load(f)\n    self.set_config(config)\n</code></pre>"},{"location":"keplergl/#anymap_ts.keplergl.KeplerGLMap.remove_data","title":"<code>remove_data(self, name)</code>","text":"<p>Remove a dataset.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Dataset name to remove.</p> required Source code in <code>anymap_ts/keplergl.py</code> <pre><code>def remove_data(self, name: str) -&gt; None:\n    \"\"\"Remove a dataset.\n\n    Args:\n        name: Dataset name to remove.\n    \"\"\"\n    if name in self.datasets:\n        datasets = dict(self.datasets)\n        del datasets[name]\n        self.datasets = datasets\n    self.call_js_method(\"removeData\", dataId=name)\n</code></pre>"},{"location":"keplergl/#anymap_ts.keplergl.KeplerGLMap.save_config","title":"<code>save_config(self, filepath)</code>","text":"<p>Save configuration to a JSON file.</p> <p>Parameters:</p> Name Type Description Default <code>filepath</code> <code>Union[str, Path]</code> <p>Path to save the configuration.</p> required Source code in <code>anymap_ts/keplergl.py</code> <pre><code>def save_config(self, filepath: Union[str, Path]) -&gt; None:\n    \"\"\"Save configuration to a JSON file.\n\n    Args:\n        filepath: Path to save the configuration.\n    \"\"\"\n    with open(filepath, \"w\") as f:\n        json.dump(self.config, f, indent=2)\n</code></pre>"},{"location":"keplergl/#anymap_ts.keplergl.KeplerGLMap.set_config","title":"<code>set_config(self, config)</code>","text":"<p>Set the KeplerGL configuration.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>Dict</code> <p>Configuration dict.</p> required Source code in <code>anymap_ts/keplergl.py</code> <pre><code>def set_config(self, config: Dict) -&gt; None:\n    \"\"\"Set the KeplerGL configuration.\n\n    Args:\n        config: Configuration dict.\n    \"\"\"\n    self.config = config\n    self.call_js_method(\"setConfig\", config=config)\n</code></pre>"},{"location":"leaflet/","title":"leaflet module","text":"<p>Leaflet map widget implementation.</p>"},{"location":"leaflet/#anymap_ts.leaflet.LeafletMap","title":"<code> LeafletMap            (MapWidget)         </code>","text":"<p>Interactive map widget using Leaflet.</p> <p>This class provides a Python interface to Leaflet maps with full bidirectional communication through anywidget.</p> <p>Note</p> <p>Leaflet uses [lat, lng] order internally, but this class accepts [lng, lat] for consistency with other map libraries.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from anymap_ts import LeafletMap\n&gt;&gt;&gt; m = LeafletMap(center=[-122.4, 37.8], zoom=10)\n&gt;&gt;&gt; m.add_basemap(\"OpenStreetMap\")\n&gt;&gt;&gt; m\n</code></pre> Source code in <code>anymap_ts/leaflet.py</code> <pre><code>class LeafletMap(MapWidget):\n    \"\"\"Interactive map widget using Leaflet.\n\n    This class provides a Python interface to Leaflet maps with\n    full bidirectional communication through anywidget.\n\n    Note:\n        Leaflet uses [lat, lng] order internally, but this class\n        accepts [lng, lat] for consistency with other map libraries.\n\n    Example:\n        &gt;&gt;&gt; from anymap_ts import LeafletMap\n        &gt;&gt;&gt; m = LeafletMap(center=[-122.4, 37.8], zoom=10)\n        &gt;&gt;&gt; m.add_basemap(\"OpenStreetMap\")\n        &gt;&gt;&gt; m\n    \"\"\"\n\n    # ESM module for frontend\n    _esm = STATIC_DIR / \"leaflet.js\"\n    _css = STATIC_DIR / \"leaflet.css\"\n\n    # Layer tracking\n    _layer_dict = traitlets.Dict({}).tag(sync=True)\n\n    def __init__(\n        self,\n        center: Tuple[float, float] = (0.0, 0.0),\n        zoom: float = 2.0,\n        width: str = \"100%\",\n        height: str = \"600px\",\n        controls: Optional[Dict[str, Any]] = None,\n        **kwargs,\n    ):\n        \"\"\"Initialize a Leaflet map.\n\n        Args:\n            center: Map center as (longitude, latitude).\n            zoom: Initial zoom level.\n            width: Map width as CSS string.\n            height: Map height as CSS string.\n            controls: Dict of controls to add (e.g., {\"zoom\": True}).\n            **kwargs: Additional widget arguments.\n        \"\"\"\n        super().__init__(\n            center=list(center),\n            zoom=zoom,\n            width=width,\n            height=height,\n            style=\"\",  # Leaflet doesn't use style URLs\n            **kwargs,\n        )\n\n        # Initialize layer dictionary\n        self._layer_dict = {\"Background\": []}\n\n        # Add default controls\n        if controls is None:\n            controls = {\n                \"scale\": {\"position\": \"bottom-left\"},\n                \"attribution\": {\"position\": \"bottom-right\"},\n                \"layers\": {\"position\": \"top-right\"},\n            }\n\n        for control_name, config in controls.items():\n            if config:\n                self.add_control(\n                    control_name, **(config if isinstance(config, dict) else {})\n                )\n\n    # -------------------------------------------------------------------------\n    # Basemap Methods\n    # -------------------------------------------------------------------------\n\n    def add_basemap(\n        self,\n        basemap: str = \"OpenStreetMap\",\n        attribution: Optional[str] = None,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a basemap layer.\n\n        Args:\n            basemap: Name of basemap provider (e.g., \"OpenStreetMap\", \"CartoDB.Positron\").\n            attribution: Custom attribution text.\n            **kwargs: Additional options.\n        \"\"\"\n        try:\n            url, default_attribution = get_basemap_url(basemap)\n        except (ValueError, KeyError):\n            url = basemap\n            default_attribution = \"\"\n\n        self.call_js_method(\n            \"addBasemap\",\n            url,\n            attribution=attribution or default_attribution,\n            name=basemap,\n            **kwargs,\n        )\n\n        # Track in layer dict\n        basemaps = self._layer_dict.get(\"Basemaps\", [])\n        if basemap not in basemaps:\n            self._layer_dict = {\n                **self._layer_dict,\n                \"Basemaps\": basemaps + [basemap],\n            }\n\n    # -------------------------------------------------------------------------\n    # Vector Data Methods\n    # -------------------------------------------------------------------------\n\n    def add_vector(\n        self,\n        data: Any,\n        style: Optional[Dict] = None,\n        name: Optional[str] = None,\n        fit_bounds: bool = True,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add vector data to the map.\n\n        Supports GeoJSON, GeoDataFrame, or file paths to vector formats.\n\n        Args:\n            data: GeoJSON dict, GeoDataFrame, or path to vector file.\n            style: Leaflet style properties.\n            name: Layer name.\n            fit_bounds: Whether to fit map to data bounds.\n            **kwargs: Additional layer options.\n        \"\"\"\n        geojson = to_geojson(data)\n\n        # Handle URL data\n        if geojson.get(\"type\") == \"url\":\n            self.add_geojson(\n                geojson[\"url\"],\n                style=style,\n                name=name,\n                fit_bounds=fit_bounds,\n                **kwargs,\n            )\n            return\n\n        layer_id = name or f\"vector-{len(self._layers)}\"\n\n        # Get default style if not provided\n        if style is None:\n            layer_type = _infer_leaflet_type(geojson)\n            style = _get_default_style(layer_type)\n\n        # Get bounds\n        bounds = get_bounds(data) if fit_bounds else None\n\n        # Call JavaScript\n        self.call_js_method(\n            \"addGeoJSON\",\n            data=geojson,\n            name=layer_id,\n            style=style,\n            fitBounds=fit_bounds,\n            bounds=bounds,\n            **kwargs,\n        )\n\n        # Track layer\n        self._layers = {\n            **self._layers,\n            layer_id: {\n                \"id\": layer_id,\n                \"type\": \"geojson\",\n                \"style\": style,\n            },\n        }\n\n    def add_geojson(\n        self,\n        data: Union[str, Dict],\n        style: Optional[Dict] = None,\n        name: Optional[str] = None,\n        fit_bounds: bool = True,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add GeoJSON data to the map.\n\n        Args:\n            data: GeoJSON dict or URL to GeoJSON file.\n            style: Leaflet style properties.\n            name: Layer name.\n            fit_bounds: Whether to fit map to data bounds.\n            **kwargs: Additional layer options.\n        \"\"\"\n        self.add_vector(\n            data,\n            style=style,\n            name=name,\n            fit_bounds=fit_bounds,\n            **kwargs,\n        )\n\n    # -------------------------------------------------------------------------\n    # Raster Data Methods\n    # -------------------------------------------------------------------------\n\n    def add_tile_layer(\n        self,\n        url: str,\n        name: Optional[str] = None,\n        attribution: str = \"\",\n        min_zoom: int = 0,\n        max_zoom: int = 22,\n        opacity: float = 1.0,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add an XYZ tile layer.\n\n        Args:\n            url: Tile URL template with {x}, {y}, {z} placeholders.\n            name: Layer name.\n            attribution: Attribution text.\n            min_zoom: Minimum zoom level.\n            max_zoom: Maximum zoom level.\n            opacity: Layer opacity.\n            **kwargs: Additional options.\n        \"\"\"\n        layer_id = name or f\"tiles-{len(self._layers)}\"\n\n        self.call_js_method(\n            \"addTileLayer\",\n            url,\n            name=layer_id,\n            attribution=attribution,\n            minZoom=min_zoom,\n            maxZoom=max_zoom,\n            opacity=opacity,\n            **kwargs,\n        )\n\n        # Track layer\n        self._layers = {\n            **self._layers,\n            layer_id: {\n                \"id\": layer_id,\n                \"type\": \"tile\",\n            },\n        }\n\n    # -------------------------------------------------------------------------\n    # Layer Management\n    # -------------------------------------------------------------------------\n\n    def remove_layer(self, layer_id: str) -&gt; None:\n        \"\"\"Remove a layer from the map.\n\n        Args:\n            layer_id: Layer identifier to remove.\n        \"\"\"\n        if layer_id in self._layers:\n            layers = dict(self._layers)\n            del layers[layer_id]\n            self._layers = layers\n        self.call_js_method(\"removeLayer\", layer_id)\n\n    def set_visibility(self, layer_id: str, visible: bool) -&gt; None:\n        \"\"\"Set layer visibility.\n\n        Args:\n            layer_id: Layer identifier.\n            visible: Whether layer should be visible.\n        \"\"\"\n        self.call_js_method(\"setVisibility\", layer_id, visible)\n\n    def set_opacity(self, layer_id: str, opacity: float) -&gt; None:\n        \"\"\"Set layer opacity.\n\n        Args:\n            layer_id: Layer identifier.\n            opacity: Opacity value between 0 and 1.\n        \"\"\"\n        self.call_js_method(\"setOpacity\", layer_id, opacity)\n\n    # -------------------------------------------------------------------------\n    # Controls\n    # -------------------------------------------------------------------------\n\n    def add_control(\n        self,\n        control_type: str,\n        position: str = \"topright\",\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a map control.\n\n        Args:\n            control_type: Type of control ('zoom', 'scale', 'attribution', 'layers').\n            position: Control position ('topleft', 'topright', 'bottomleft', 'bottomright').\n            **kwargs: Control-specific options.\n        \"\"\"\n        # Convert position format\n        position_map = {\n            \"top-left\": \"topleft\",\n            \"top-right\": \"topright\",\n            \"bottom-left\": \"bottomleft\",\n            \"bottom-right\": \"bottomright\",\n        }\n        pos = position_map.get(position, position)\n\n        self.call_js_method(\"addControl\", control_type, position=pos, **kwargs)\n        self._controls = {\n            **self._controls,\n            control_type: {\"type\": control_type, \"position\": pos, **kwargs},\n        }\n\n    def remove_control(self, control_type: str) -&gt; None:\n        \"\"\"Remove a map control.\n\n        Args:\n            control_type: Type of control to remove.\n        \"\"\"\n        self.call_js_method(\"removeControl\", control_type)\n        if control_type in self._controls:\n            controls = dict(self._controls)\n            del controls[control_type]\n            self._controls = controls\n\n    def add_layer_control(\n        self,\n        position: str = \"topright\",\n        collapsed: bool = True,\n    ) -&gt; None:\n        \"\"\"Add a layer control for toggling layer visibility.\n\n        Args:\n            position: Control position.\n            collapsed: Whether control starts collapsed.\n        \"\"\"\n        self.add_control(\"layers\", position=position, collapsed=collapsed)\n\n    # -------------------------------------------------------------------------\n    # Markers\n    # -------------------------------------------------------------------------\n\n    def add_marker(\n        self,\n        lng: float,\n        lat: float,\n        popup: Optional[str] = None,\n        marker_id: Optional[str] = None,\n    ) -&gt; None:\n        \"\"\"Add a marker to the map.\n\n        Args:\n            lng: Longitude.\n            lat: Latitude.\n            popup: HTML content for popup.\n            marker_id: Unique marker ID.\n        \"\"\"\n        self.call_js_method(\"addMarker\", lng, lat, popup=popup, id=marker_id)\n\n    def remove_marker(self, marker_id: str) -&gt; None:\n        \"\"\"Remove a marker from the map.\n\n        Args:\n            marker_id: Marker ID to remove.\n        \"\"\"\n        self.call_js_method(\"removeMarker\", marker_id)\n\n    # -------------------------------------------------------------------------\n    # HTML Export\n    # -------------------------------------------------------------------------\n\n    def _generate_html_template(self) -&gt; str:\n        \"\"\"Generate standalone HTML for the map.\"\"\"\n        template_path = Path(__file__).parent / \"templates\" / \"leaflet.html\"\n\n        if template_path.exists():\n            template = template_path.read_text(encoding=\"utf-8\")\n        else:\n            template = self._get_default_template()\n\n        # Serialize state\n        state = {\n            \"center\": self.center,\n            \"zoom\": self.zoom,\n            \"width\": self.width,\n            \"height\": self.height,\n            \"layers\": self._layers,\n            \"controls\": self._controls,\n            \"js_calls\": self._js_calls,\n        }\n\n        template = template.replace(\"{{state}}\", json.dumps(state, indent=2))\n        return template\n\n    def _get_default_template(self) -&gt; str:\n        \"\"\"Get default HTML template.\"\"\"\n        return \"\"\"&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n    &lt;meta charset=\"utf-8\"&gt;\n    &lt;title&gt;{{title}}&lt;/title&gt;\n    &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"&gt;\n    &lt;link rel=\"stylesheet\" href=\"https://unpkg.com/leaflet@1.9.4/dist/leaflet.css\" /&gt;\n    &lt;script src=\"https://unpkg.com/leaflet@1.9.4/dist/leaflet.js\"&gt;&lt;/script&gt;\n    &lt;style&gt;\n        body { margin: 0; padding: 0; }\n        #map { position: absolute; top: 0; bottom: 0; width: 100%; }\n    &lt;/style&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;div id=\"map\"&gt;&lt;/div&gt;\n    &lt;script&gt;\n        const state = {{state}};\n\n        // Note: Leaflet uses [lat, lng], but we store [lng, lat]\n        const map = L.map('map').setView([state.center[1], state.center[0]], state.zoom);\n\n        // Replay JS calls\n        for (const call of state.js_calls || []) {\n            try {\n                executeMethod(call.method, call.args, call.kwargs);\n            } catch (e) {\n                console.error('Error executing', call.method, e);\n            }\n        }\n\n        function executeMethod(method, args, kwargs) {\n            switch (method) {\n                case 'addBasemap':\n                case 'addTileLayer':\n                    const url = args[0];\n                    L.tileLayer(url, {\n                        attribution: kwargs.attribution || '',\n                        maxZoom: kwargs.maxZoom || 22,\n                        minZoom: kwargs.minZoom || 0,\n                        opacity: kwargs.opacity || 1\n                    }).addTo(map);\n                    break;\n\n                case 'addGeoJSON':\n                    const geojson = kwargs.data;\n                    const style = kwargs.style || {\n                        color: '#3388ff',\n                        weight: 2,\n                        opacity: 0.8,\n                        fillOpacity: 0.5\n                    };\n                    const layer = L.geoJSON(geojson, {\n                        style: style,\n                        pointToLayer: (feature, latlng) =&gt; L.circleMarker(latlng, style)\n                    }).addTo(map);\n\n                    if (kwargs.fitBounds) {\n                        map.fitBounds(layer.getBounds(), { padding: [50, 50] });\n                    }\n                    break;\n\n                case 'addControl':\n                    const controlType = args[0];\n                    const position = kwargs.position || 'topright';\n                    if (controlType === 'zoom' || controlType === 'navigation') {\n                        L.control.zoom({ position }).addTo(map);\n                    } else if (controlType === 'scale') {\n                        L.control.scale({ position, imperial: false }).addTo(map);\n                    }\n                    break;\n\n                case 'addMarker':\n                    const [lng, lat] = args;\n                    const marker = L.marker([lat, lng]).addTo(map);\n                    if (kwargs.popup) {\n                        marker.bindPopup(kwargs.popup);\n                    }\n                    break;\n\n                case 'flyTo':\n                    map.flyTo([args[1], args[0]], kwargs.zoom || map.getZoom(), {\n                        duration: (kwargs.duration || 2000) / 1000\n                    });\n                    break;\n\n                case 'fitBounds':\n                    const bounds = args[0];\n                    map.fitBounds([\n                        [bounds[1], bounds[0]],\n                        [bounds[3], bounds[2]]\n                    ], { padding: [kwargs.padding || 50, kwargs.padding || 50] });\n                    break;\n\n                default:\n                    console.log('Unknown method:', method);\n            }\n        }\n    &lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\"\"\"\n</code></pre>"},{"location":"leaflet/#anymap_ts.leaflet.LeafletMap.__init__","title":"<code>__init__(self, center=(0.0, 0.0), zoom=2.0, width='100%', height='600px', controls=None, **kwargs)</code>  <code>special</code>","text":"<p>Initialize a Leaflet map.</p> <p>Parameters:</p> Name Type Description Default <code>center</code> <code>Tuple[float, float]</code> <p>Map center as (longitude, latitude).</p> <code>(0.0, 0.0)</code> <code>zoom</code> <code>float</code> <p>Initial zoom level.</p> <code>2.0</code> <code>width</code> <code>str</code> <p>Map width as CSS string.</p> <code>'100%'</code> <code>height</code> <code>str</code> <p>Map height as CSS string.</p> <code>'600px'</code> <code>controls</code> <code>Optional[Dict[str, Any]]</code> <p>Dict of controls to add (e.g., {\"zoom\": True}).</p> <code>None</code> <code>**kwargs</code> <p>Additional widget arguments.</p> <code>{}</code> Source code in <code>anymap_ts/leaflet.py</code> <pre><code>def __init__(\n    self,\n    center: Tuple[float, float] = (0.0, 0.0),\n    zoom: float = 2.0,\n    width: str = \"100%\",\n    height: str = \"600px\",\n    controls: Optional[Dict[str, Any]] = None,\n    **kwargs,\n):\n    \"\"\"Initialize a Leaflet map.\n\n    Args:\n        center: Map center as (longitude, latitude).\n        zoom: Initial zoom level.\n        width: Map width as CSS string.\n        height: Map height as CSS string.\n        controls: Dict of controls to add (e.g., {\"zoom\": True}).\n        **kwargs: Additional widget arguments.\n    \"\"\"\n    super().__init__(\n        center=list(center),\n        zoom=zoom,\n        width=width,\n        height=height,\n        style=\"\",  # Leaflet doesn't use style URLs\n        **kwargs,\n    )\n\n    # Initialize layer dictionary\n    self._layer_dict = {\"Background\": []}\n\n    # Add default controls\n    if controls is None:\n        controls = {\n            \"scale\": {\"position\": \"bottom-left\"},\n            \"attribution\": {\"position\": \"bottom-right\"},\n            \"layers\": {\"position\": \"top-right\"},\n        }\n\n    for control_name, config in controls.items():\n        if config:\n            self.add_control(\n                control_name, **(config if isinstance(config, dict) else {})\n            )\n</code></pre>"},{"location":"leaflet/#anymap_ts.leaflet.LeafletMap.add_basemap","title":"<code>add_basemap(self, basemap='OpenStreetMap', attribution=None, **kwargs)</code>","text":"<p>Add a basemap layer.</p> <p>Parameters:</p> Name Type Description Default <code>basemap</code> <code>str</code> <p>Name of basemap provider (e.g., \"OpenStreetMap\", \"CartoDB.Positron\").</p> <code>'OpenStreetMap'</code> <code>attribution</code> <code>Optional[str]</code> <p>Custom attribution text.</p> <code>None</code> <code>**kwargs</code> <p>Additional options.</p> <code>{}</code> Source code in <code>anymap_ts/leaflet.py</code> <pre><code>def add_basemap(\n    self,\n    basemap: str = \"OpenStreetMap\",\n    attribution: Optional[str] = None,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a basemap layer.\n\n    Args:\n        basemap: Name of basemap provider (e.g., \"OpenStreetMap\", \"CartoDB.Positron\").\n        attribution: Custom attribution text.\n        **kwargs: Additional options.\n    \"\"\"\n    try:\n        url, default_attribution = get_basemap_url(basemap)\n    except (ValueError, KeyError):\n        url = basemap\n        default_attribution = \"\"\n\n    self.call_js_method(\n        \"addBasemap\",\n        url,\n        attribution=attribution or default_attribution,\n        name=basemap,\n        **kwargs,\n    )\n\n    # Track in layer dict\n    basemaps = self._layer_dict.get(\"Basemaps\", [])\n    if basemap not in basemaps:\n        self._layer_dict = {\n            **self._layer_dict,\n            \"Basemaps\": basemaps + [basemap],\n        }\n</code></pre>"},{"location":"leaflet/#anymap_ts.leaflet.LeafletMap.add_control","title":"<code>add_control(self, control_type, position='topright', **kwargs)</code>","text":"<p>Add a map control.</p> <p>Parameters:</p> Name Type Description Default <code>control_type</code> <code>str</code> <p>Type of control ('zoom', 'scale', 'attribution', 'layers').</p> required <code>position</code> <code>str</code> <p>Control position ('topleft', 'topright', 'bottomleft', 'bottomright').</p> <code>'topright'</code> <code>**kwargs</code> <p>Control-specific options.</p> <code>{}</code> Source code in <code>anymap_ts/leaflet.py</code> <pre><code>def add_control(\n    self,\n    control_type: str,\n    position: str = \"topright\",\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a map control.\n\n    Args:\n        control_type: Type of control ('zoom', 'scale', 'attribution', 'layers').\n        position: Control position ('topleft', 'topright', 'bottomleft', 'bottomright').\n        **kwargs: Control-specific options.\n    \"\"\"\n    # Convert position format\n    position_map = {\n        \"top-left\": \"topleft\",\n        \"top-right\": \"topright\",\n        \"bottom-left\": \"bottomleft\",\n        \"bottom-right\": \"bottomright\",\n    }\n    pos = position_map.get(position, position)\n\n    self.call_js_method(\"addControl\", control_type, position=pos, **kwargs)\n    self._controls = {\n        **self._controls,\n        control_type: {\"type\": control_type, \"position\": pos, **kwargs},\n    }\n</code></pre>"},{"location":"leaflet/#anymap_ts.leaflet.LeafletMap.add_geojson","title":"<code>add_geojson(self, data, style=None, name=None, fit_bounds=True, **kwargs)</code>","text":"<p>Add GeoJSON data to the map.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Union[str, Dict]</code> <p>GeoJSON dict or URL to GeoJSON file.</p> required <code>style</code> <code>Optional[Dict]</code> <p>Leaflet style properties.</p> <code>None</code> <code>name</code> <code>Optional[str]</code> <p>Layer name.</p> <code>None</code> <code>fit_bounds</code> <code>bool</code> <p>Whether to fit map to data bounds.</p> <code>True</code> <code>**kwargs</code> <p>Additional layer options.</p> <code>{}</code> Source code in <code>anymap_ts/leaflet.py</code> <pre><code>def add_geojson(\n    self,\n    data: Union[str, Dict],\n    style: Optional[Dict] = None,\n    name: Optional[str] = None,\n    fit_bounds: bool = True,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add GeoJSON data to the map.\n\n    Args:\n        data: GeoJSON dict or URL to GeoJSON file.\n        style: Leaflet style properties.\n        name: Layer name.\n        fit_bounds: Whether to fit map to data bounds.\n        **kwargs: Additional layer options.\n    \"\"\"\n    self.add_vector(\n        data,\n        style=style,\n        name=name,\n        fit_bounds=fit_bounds,\n        **kwargs,\n    )\n</code></pre>"},{"location":"leaflet/#anymap_ts.leaflet.LeafletMap.add_layer_control","title":"<code>add_layer_control(self, position='topright', collapsed=True)</code>","text":"<p>Add a layer control for toggling layer visibility.</p> <p>Parameters:</p> Name Type Description Default <code>position</code> <code>str</code> <p>Control position.</p> <code>'topright'</code> <code>collapsed</code> <code>bool</code> <p>Whether control starts collapsed.</p> <code>True</code> Source code in <code>anymap_ts/leaflet.py</code> <pre><code>def add_layer_control(\n    self,\n    position: str = \"topright\",\n    collapsed: bool = True,\n) -&gt; None:\n    \"\"\"Add a layer control for toggling layer visibility.\n\n    Args:\n        position: Control position.\n        collapsed: Whether control starts collapsed.\n    \"\"\"\n    self.add_control(\"layers\", position=position, collapsed=collapsed)\n</code></pre>"},{"location":"leaflet/#anymap_ts.leaflet.LeafletMap.add_marker","title":"<code>add_marker(self, lng, lat, popup=None, marker_id=None)</code>","text":"<p>Add a marker to the map.</p> <p>Parameters:</p> Name Type Description Default <code>lng</code> <code>float</code> <p>Longitude.</p> required <code>lat</code> <code>float</code> <p>Latitude.</p> required <code>popup</code> <code>Optional[str]</code> <p>HTML content for popup.</p> <code>None</code> <code>marker_id</code> <code>Optional[str]</code> <p>Unique marker ID.</p> <code>None</code> Source code in <code>anymap_ts/leaflet.py</code> <pre><code>def add_marker(\n    self,\n    lng: float,\n    lat: float,\n    popup: Optional[str] = None,\n    marker_id: Optional[str] = None,\n) -&gt; None:\n    \"\"\"Add a marker to the map.\n\n    Args:\n        lng: Longitude.\n        lat: Latitude.\n        popup: HTML content for popup.\n        marker_id: Unique marker ID.\n    \"\"\"\n    self.call_js_method(\"addMarker\", lng, lat, popup=popup, id=marker_id)\n</code></pre>"},{"location":"leaflet/#anymap_ts.leaflet.LeafletMap.add_tile_layer","title":"<code>add_tile_layer(self, url, name=None, attribution='', min_zoom=0, max_zoom=22, opacity=1.0, **kwargs)</code>","text":"<p>Add an XYZ tile layer.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>Tile URL template with {x}, {y}, {z} placeholders.</p> required <code>name</code> <code>Optional[str]</code> <p>Layer name.</p> <code>None</code> <code>attribution</code> <code>str</code> <p>Attribution text.</p> <code>''</code> <code>min_zoom</code> <code>int</code> <p>Minimum zoom level.</p> <code>0</code> <code>max_zoom</code> <code>int</code> <p>Maximum zoom level.</p> <code>22</code> <code>opacity</code> <code>float</code> <p>Layer opacity.</p> <code>1.0</code> <code>**kwargs</code> <p>Additional options.</p> <code>{}</code> Source code in <code>anymap_ts/leaflet.py</code> <pre><code>def add_tile_layer(\n    self,\n    url: str,\n    name: Optional[str] = None,\n    attribution: str = \"\",\n    min_zoom: int = 0,\n    max_zoom: int = 22,\n    opacity: float = 1.0,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add an XYZ tile layer.\n\n    Args:\n        url: Tile URL template with {x}, {y}, {z} placeholders.\n        name: Layer name.\n        attribution: Attribution text.\n        min_zoom: Minimum zoom level.\n        max_zoom: Maximum zoom level.\n        opacity: Layer opacity.\n        **kwargs: Additional options.\n    \"\"\"\n    layer_id = name or f\"tiles-{len(self._layers)}\"\n\n    self.call_js_method(\n        \"addTileLayer\",\n        url,\n        name=layer_id,\n        attribution=attribution,\n        minZoom=min_zoom,\n        maxZoom=max_zoom,\n        opacity=opacity,\n        **kwargs,\n    )\n\n    # Track layer\n    self._layers = {\n        **self._layers,\n        layer_id: {\n            \"id\": layer_id,\n            \"type\": \"tile\",\n        },\n    }\n</code></pre>"},{"location":"leaflet/#anymap_ts.leaflet.LeafletMap.add_vector","title":"<code>add_vector(self, data, style=None, name=None, fit_bounds=True, **kwargs)</code>","text":"<p>Add vector data to the map.</p> <p>Supports GeoJSON, GeoDataFrame, or file paths to vector formats.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>GeoJSON dict, GeoDataFrame, or path to vector file.</p> required <code>style</code> <code>Optional[Dict]</code> <p>Leaflet style properties.</p> <code>None</code> <code>name</code> <code>Optional[str]</code> <p>Layer name.</p> <code>None</code> <code>fit_bounds</code> <code>bool</code> <p>Whether to fit map to data bounds.</p> <code>True</code> <code>**kwargs</code> <p>Additional layer options.</p> <code>{}</code> Source code in <code>anymap_ts/leaflet.py</code> <pre><code>def add_vector(\n    self,\n    data: Any,\n    style: Optional[Dict] = None,\n    name: Optional[str] = None,\n    fit_bounds: bool = True,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add vector data to the map.\n\n    Supports GeoJSON, GeoDataFrame, or file paths to vector formats.\n\n    Args:\n        data: GeoJSON dict, GeoDataFrame, or path to vector file.\n        style: Leaflet style properties.\n        name: Layer name.\n        fit_bounds: Whether to fit map to data bounds.\n        **kwargs: Additional layer options.\n    \"\"\"\n    geojson = to_geojson(data)\n\n    # Handle URL data\n    if geojson.get(\"type\") == \"url\":\n        self.add_geojson(\n            geojson[\"url\"],\n            style=style,\n            name=name,\n            fit_bounds=fit_bounds,\n            **kwargs,\n        )\n        return\n\n    layer_id = name or f\"vector-{len(self._layers)}\"\n\n    # Get default style if not provided\n    if style is None:\n        layer_type = _infer_leaflet_type(geojson)\n        style = _get_default_style(layer_type)\n\n    # Get bounds\n    bounds = get_bounds(data) if fit_bounds else None\n\n    # Call JavaScript\n    self.call_js_method(\n        \"addGeoJSON\",\n        data=geojson,\n        name=layer_id,\n        style=style,\n        fitBounds=fit_bounds,\n        bounds=bounds,\n        **kwargs,\n    )\n\n    # Track layer\n    self._layers = {\n        **self._layers,\n        layer_id: {\n            \"id\": layer_id,\n            \"type\": \"geojson\",\n            \"style\": style,\n        },\n    }\n</code></pre>"},{"location":"leaflet/#anymap_ts.leaflet.LeafletMap.remove_control","title":"<code>remove_control(self, control_type)</code>","text":"<p>Remove a map control.</p> <p>Parameters:</p> Name Type Description Default <code>control_type</code> <code>str</code> <p>Type of control to remove.</p> required Source code in <code>anymap_ts/leaflet.py</code> <pre><code>def remove_control(self, control_type: str) -&gt; None:\n    \"\"\"Remove a map control.\n\n    Args:\n        control_type: Type of control to remove.\n    \"\"\"\n    self.call_js_method(\"removeControl\", control_type)\n    if control_type in self._controls:\n        controls = dict(self._controls)\n        del controls[control_type]\n        self._controls = controls\n</code></pre>"},{"location":"leaflet/#anymap_ts.leaflet.LeafletMap.remove_layer","title":"<code>remove_layer(self, layer_id)</code>","text":"<p>Remove a layer from the map.</p> <p>Parameters:</p> Name Type Description Default <code>layer_id</code> <code>str</code> <p>Layer identifier to remove.</p> required Source code in <code>anymap_ts/leaflet.py</code> <pre><code>def remove_layer(self, layer_id: str) -&gt; None:\n    \"\"\"Remove a layer from the map.\n\n    Args:\n        layer_id: Layer identifier to remove.\n    \"\"\"\n    if layer_id in self._layers:\n        layers = dict(self._layers)\n        del layers[layer_id]\n        self._layers = layers\n    self.call_js_method(\"removeLayer\", layer_id)\n</code></pre>"},{"location":"leaflet/#anymap_ts.leaflet.LeafletMap.remove_marker","title":"<code>remove_marker(self, marker_id)</code>","text":"<p>Remove a marker from the map.</p> <p>Parameters:</p> Name Type Description Default <code>marker_id</code> <code>str</code> <p>Marker ID to remove.</p> required Source code in <code>anymap_ts/leaflet.py</code> <pre><code>def remove_marker(self, marker_id: str) -&gt; None:\n    \"\"\"Remove a marker from the map.\n\n    Args:\n        marker_id: Marker ID to remove.\n    \"\"\"\n    self.call_js_method(\"removeMarker\", marker_id)\n</code></pre>"},{"location":"leaflet/#anymap_ts.leaflet.LeafletMap.set_opacity","title":"<code>set_opacity(self, layer_id, opacity)</code>","text":"<p>Set layer opacity.</p> <p>Parameters:</p> Name Type Description Default <code>layer_id</code> <code>str</code> <p>Layer identifier.</p> required <code>opacity</code> <code>float</code> <p>Opacity value between 0 and 1.</p> required Source code in <code>anymap_ts/leaflet.py</code> <pre><code>def set_opacity(self, layer_id: str, opacity: float) -&gt; None:\n    \"\"\"Set layer opacity.\n\n    Args:\n        layer_id: Layer identifier.\n        opacity: Opacity value between 0 and 1.\n    \"\"\"\n    self.call_js_method(\"setOpacity\", layer_id, opacity)\n</code></pre>"},{"location":"leaflet/#anymap_ts.leaflet.LeafletMap.set_visibility","title":"<code>set_visibility(self, layer_id, visible)</code>","text":"<p>Set layer visibility.</p> <p>Parameters:</p> Name Type Description Default <code>layer_id</code> <code>str</code> <p>Layer identifier.</p> required <code>visible</code> <code>bool</code> <p>Whether layer should be visible.</p> required Source code in <code>anymap_ts/leaflet.py</code> <pre><code>def set_visibility(self, layer_id: str, visible: bool) -&gt; None:\n    \"\"\"Set layer visibility.\n\n    Args:\n        layer_id: Layer identifier.\n        visible: Whether layer should be visible.\n    \"\"\"\n    self.call_js_method(\"setVisibility\", layer_id, visible)\n</code></pre>"},{"location":"mapbox/","title":"mapbox module","text":"<p>Mapbox GL JS map widget implementation.</p>"},{"location":"mapbox/#anymap_ts.mapbox.MapboxMap","title":"<code> MapboxMap            (MapWidget)         </code>","text":"<p>Interactive map widget using Mapbox GL JS.</p> <p>This class provides a Python interface to Mapbox GL JS maps with full bidirectional communication through anywidget.</p> <p>Note</p> <p>Requires a Mapbox access token. Set via MAPBOX_TOKEN environment variable or pass directly to the constructor.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from anymap_ts import MapboxMap\n&gt;&gt;&gt; m = MapboxMap(center=[-122.4, 37.8], zoom=10)\n&gt;&gt;&gt; m.add_basemap(\"mapbox://styles/mapbox/streets-v12\")\n&gt;&gt;&gt; m\n</code></pre> Source code in <code>anymap_ts/mapbox.py</code> <pre><code>class MapboxMap(MapWidget):\n    \"\"\"Interactive map widget using Mapbox GL JS.\n\n    This class provides a Python interface to Mapbox GL JS maps with\n    full bidirectional communication through anywidget.\n\n    Note:\n        Requires a Mapbox access token. Set via MAPBOX_TOKEN environment\n        variable or pass directly to the constructor.\n\n    Example:\n        &gt;&gt;&gt; from anymap_ts import MapboxMap\n        &gt;&gt;&gt; m = MapboxMap(center=[-122.4, 37.8], zoom=10)\n        &gt;&gt;&gt; m.add_basemap(\"mapbox://styles/mapbox/streets-v12\")\n        &gt;&gt;&gt; m\n    \"\"\"\n\n    # ESM module for frontend\n    _esm = STATIC_DIR / \"mapbox.js\"\n    _css = STATIC_DIR / \"mapbox.css\"\n\n    # Mapbox-specific traits\n    access_token = traitlets.Unicode(\"\").tag(sync=True)\n    bearing = traitlets.Float(0.0).tag(sync=True)\n    pitch = traitlets.Float(0.0).tag(sync=True)\n    antialias = traitlets.Bool(True).tag(sync=True)\n    double_click_zoom = traitlets.Bool(True).tag(sync=True)\n\n    # Layer tracking\n    _layer_dict = traitlets.Dict({}).tag(sync=True)\n\n    def __init__(\n        self,\n        center: Tuple[float, float] = (0.0, 0.0),\n        zoom: float = 2.0,\n        width: str = \"100%\",\n        height: str = \"600px\",\n        style: str = \"mapbox://styles/mapbox/streets-v12\",\n        bearing: float = 0.0,\n        pitch: float = 0.0,\n        max_pitch: float = 85.0,\n        access_token: Optional[str] = None,\n        controls: Optional[Dict[str, Any]] = None,\n        **kwargs,\n    ):\n        \"\"\"Initialize a Mapbox map.\n\n        Args:\n            center: Map center as (longitude, latitude).\n            zoom: Initial zoom level.\n            width: Map width as CSS string.\n            height: Map height as CSS string.\n            style: Mapbox style URL (e.g., \"mapbox://styles/mapbox/streets-v12\").\n            bearing: Map bearing in degrees.\n            pitch: Map pitch in degrees.\n            max_pitch: Maximum pitch angle in degrees (default: 85).\n            access_token: Mapbox access token. If None, reads from MAPBOX_TOKEN env var.\n            controls: Dict of controls to add (e.g., {\"navigation\": True}).\n            **kwargs: Additional widget arguments.\n        \"\"\"\n        # Get access token\n        token = access_token or get_mapbox_token()\n        if not token:\n            print(\n                \"Warning: No Mapbox access token provided. \"\n                \"Set MAPBOX_TOKEN environment variable or pass access_token parameter.\"\n            )\n\n        super().__init__(\n            center=list(center),\n            zoom=zoom,\n            width=width,\n            height=height,\n            style=style,\n            bearing=bearing,\n            pitch=pitch,\n            max_pitch=max_pitch,\n            access_token=token,\n            **kwargs,\n        )\n\n        # Initialize layer dictionary\n        self._layer_dict = {\"Background\": []}\n\n        # Add default controls\n        if controls is None:\n            controls = {\"navigation\": True, \"fullscreen\": True}\n\n        for control_name, config in controls.items():\n            if config:\n                self.add_control(\n                    control_name, **(config if isinstance(config, dict) else {})\n                )\n\n    def set_access_token(self, token: str) -&gt; None:\n        \"\"\"Set the Mapbox access token.\n\n        Args:\n            token: Mapbox access token.\n        \"\"\"\n        self.access_token = token\n\n    # -------------------------------------------------------------------------\n    # Layer Dict Helpers\n    # -------------------------------------------------------------------------\n\n    def _add_to_layer_dict(self, layer_id: str, category: str = \"Overlays\") -&gt; None:\n        \"\"\"Add a layer to the layer dictionary for UI tracking.\"\"\"\n        layers = self._layer_dict.get(category, [])\n        if layer_id not in layers:\n            self._layer_dict = {\n                **self._layer_dict,\n                category: layers + [layer_id],\n            }\n\n    def _remove_from_layer_dict(self, layer_id: str) -&gt; None:\n        \"\"\"Remove a layer from the layer dictionary.\"\"\"\n        new_dict = {}\n        for category, layers in self._layer_dict.items():\n            if layer_id in layers:\n                new_layers = [lid for lid in layers if lid != layer_id]\n                if new_layers:\n                    new_dict[category] = new_layers\n            else:\n                new_dict[category] = layers\n        self._layer_dict = new_dict\n\n    def _validate_opacity(self, opacity: float, param_name: str = \"opacity\") -&gt; float:\n        \"\"\"Validate opacity value is between 0 and 1.\"\"\"\n        if not 0 &lt;= opacity &lt;= 1:\n            raise ValueError(f\"{param_name} must be between 0 and 1, got {opacity}\")\n        return opacity\n\n    def _validate_position(self, position: str) -&gt; str:\n        \"\"\"Validate control position is valid.\"\"\"\n        valid_positions = [\"top-left\", \"top-right\", \"bottom-left\", \"bottom-right\"]\n        if position not in valid_positions:\n            raise ValueError(\n                f\"Position must be one of: {', '.join(valid_positions)}, got '{position}'\"\n            )\n        return position\n\n    def _remove_layer_internal(self, layer_id: str, js_method: str) -&gt; None:\n        \"\"\"Internal helper to remove a layer.\"\"\"\n        if layer_id in self._layers:\n            layers = dict(self._layers)\n            del layers[layer_id]\n            self._layers = layers\n        self._remove_from_layer_dict(layer_id)\n        self.call_js_method(js_method, layer_id)\n\n    # -------------------------------------------------------------------------\n    # Basemap Methods\n    # -------------------------------------------------------------------------\n\n    def add_basemap(\n        self,\n        basemap: str = \"mapbox://styles/mapbox/streets-v12\",\n        attribution: Optional[str] = None,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a basemap layer.\n\n        For Mapbox styles, use the style URL format:\n        - \"mapbox://styles/mapbox/streets-v12\"\n        - \"mapbox://styles/mapbox/satellite-v9\"\n        - \"mapbox://styles/mapbox/satellite-streets-v12\"\n        - \"mapbox://styles/mapbox/light-v11\"\n        - \"mapbox://styles/mapbox/dark-v11\"\n        - \"mapbox://styles/mapbox/outdoors-v12\"\n\n        Or use XYZ tile URLs for custom basemaps.\n\n        Args:\n            basemap: Mapbox style URL or XYZ tile URL.\n            attribution: Custom attribution text.\n            **kwargs: Additional options.\n        \"\"\"\n        # If it's a Mapbox style URL, set it as the map style\n        if basemap.startswith(\"mapbox://\"):\n            self.style = basemap\n            return\n\n        # Otherwise, treat as XYZ tile URL\n        try:\n            url, default_attribution = get_basemap_url(basemap)\n        except (ValueError, KeyError):\n            url = basemap\n            default_attribution = \"\"\n\n        self.call_js_method(\n            \"addBasemap\",\n            url,\n            attribution=attribution or default_attribution,\n            name=basemap,\n            **kwargs,\n        )\n\n        # Track in layer dict\n        basemaps = self._layer_dict.get(\"Basemaps\", [])\n        if basemap not in basemaps:\n            self._layer_dict = {\n                **self._layer_dict,\n                \"Basemaps\": basemaps + [basemap],\n            }\n\n    # -------------------------------------------------------------------------\n    # Vector Data Methods\n    # -------------------------------------------------------------------------\n\n    def add_vector(\n        self,\n        data: Any,\n        layer_type: Optional[str] = None,\n        paint: Optional[Dict] = None,\n        name: Optional[str] = None,\n        fit_bounds: bool = True,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add vector data to the map.\n\n        Supports GeoJSON, GeoDataFrame, or file paths to vector formats.\n\n        Args:\n            data: GeoJSON dict, GeoDataFrame, or path to vector file.\n            layer_type: Mapbox layer type ('circle', 'line', 'fill', 'symbol').\n            paint: Mapbox paint properties.\n            name: Layer name.\n            fit_bounds: Whether to fit map to data bounds.\n            **kwargs: Additional layer options.\n        \"\"\"\n        geojson = to_geojson(data)\n\n        layer_id = name or f\"vector-{len(self._layers)}\"\n\n        # Handle URL data - fetch GeoJSON to get bounds and infer layer type\n        if geojson.get(\"type\") == \"url\":\n            url = geojson[\"url\"]\n            geojson = fetch_geojson(url)\n\n        # Infer layer type if not specified\n        if layer_type is None:\n            layer_type = infer_layer_type(geojson)\n\n        # Get default paint if not provided\n        if paint is None:\n            paint = get_default_paint(layer_type)\n\n        # Get bounds (use geojson dict, not original data which may be a URL)\n        bounds = get_bounds(geojson) if fit_bounds else None\n\n        # Call JavaScript\n        self.call_js_method(\n            \"addGeoJSON\",\n            data=geojson,\n            name=layer_id,\n            layerType=layer_type,\n            paint=paint,\n            fitBounds=fit_bounds,\n            bounds=bounds,\n            **kwargs,\n        )\n\n        # Track layer\n        self._layers = {\n            **self._layers,\n            layer_id: {\n                \"id\": layer_id,\n                \"type\": layer_type,\n                \"source\": f\"{layer_id}-source\",\n                \"paint\": paint,\n            },\n        }\n        self._add_to_layer_dict(layer_id, \"Vector\")\n\n    def add_geojson(\n        self,\n        data: Union[str, Dict],\n        layer_type: Optional[str] = None,\n        paint: Optional[Dict] = None,\n        name: Optional[str] = None,\n        fit_bounds: bool = True,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add GeoJSON data to the map.\n\n        Args:\n            data: GeoJSON dict or URL to GeoJSON file.\n            layer_type: Mapbox layer type.\n            paint: Mapbox paint properties.\n            name: Layer name.\n            fit_bounds: Whether to fit map to data bounds.\n            **kwargs: Additional layer options.\n        \"\"\"\n        self.add_vector(\n            data,\n            layer_type=layer_type,\n            paint=paint,\n            name=name,\n            fit_bounds=fit_bounds,\n            **kwargs,\n        )\n\n    # -------------------------------------------------------------------------\n    # Raster Data Methods\n    # -------------------------------------------------------------------------\n\n    def add_tile_layer(\n        self,\n        url: str,\n        name: Optional[str] = None,\n        attribution: str = \"\",\n        min_zoom: int = 0,\n        max_zoom: int = 22,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add an XYZ tile layer.\n\n        Args:\n            url: Tile URL template with {x}, {y}, {z} placeholders.\n            name: Layer name.\n            attribution: Attribution text.\n            min_zoom: Minimum zoom level.\n            max_zoom: Maximum zoom level.\n            **kwargs: Additional options.\n        \"\"\"\n        layer_id = name or f\"tiles-{len(self._layers)}\"\n\n        self.call_js_method(\n            \"addTileLayer\",\n            url,\n            name=layer_id,\n            attribution=attribution,\n            minZoom=min_zoom,\n            maxZoom=max_zoom,\n            **kwargs,\n        )\n\n        # Track layer\n        self._layers = {\n            **self._layers,\n            layer_id: {\n                \"id\": layer_id,\n                \"type\": \"raster\",\n                \"source\": f\"{layer_id}-source\",\n            },\n        }\n        self._add_to_layer_dict(layer_id, \"Raster\")\n\n    def add_raster(\n        self,\n        source: str,\n        name: Optional[str] = None,\n        attribution: str = \"\",\n        indexes: Optional[List[int]] = None,\n        colormap: Optional[str] = None,\n        vmin: Optional[float] = None,\n        vmax: Optional[float] = None,\n        nodata: Optional[float] = None,\n        fit_bounds: bool = True,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a raster layer from a local file using localtileserver.\"\"\"\n        try:\n            from localtileserver import TileClient\n        except ImportError:\n            raise ImportError(\n                \"localtileserver is required for local raster support. \"\n                \"Install with: pip install anymap-ts[raster]\"\n            )\n\n        client = TileClient(source)\n\n        tile_params = {}\n        if indexes:\n            tile_params[\"indexes\"] = indexes\n        if colormap:\n            tile_params[\"colormap\"] = colormap\n        if vmin is not None or vmax is not None:\n            tile_params[\"vmin\"] = vmin if vmin is not None else client.min\n            tile_params[\"vmax\"] = vmax if vmax is not None else client.max\n        if nodata is not None:\n            tile_params[\"nodata\"] = nodata\n\n        tile_url = client.get_tile_url(**tile_params)\n\n        layer_name = name or Path(source).stem\n\n        self.add_tile_layer(\n            tile_url,\n            name=layer_name,\n            attribution=attribution,\n            **kwargs,\n        )\n\n        if fit_bounds:\n            bounds = client.bounds()\n            if bounds:\n                self.fit_bounds([bounds[0], bounds[1], bounds[2], bounds[3]])\n\n    def add_stac_layer(\n        self,\n        url: Optional[str] = None,\n        item: Optional[Any] = None,\n        assets: Optional[List[str]] = None,\n        colormap: Optional[str] = None,\n        rescale: Optional[List[float]] = None,\n        opacity: float = 1.0,\n        layer_id: Optional[str] = None,\n        titiler_endpoint: str = \"https://titiler.xyz\",\n        attribution: str = \"STAC\",\n        fit_bounds: bool = True,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a STAC (SpatioTemporal Asset Catalog) layer to the map.\"\"\"\n        if url is None and item is None:\n            raise ValueError(\"Either 'url' or 'item' must be provided\")\n\n        if url is not None and item is not None:\n            raise ValueError(\"Provide either 'url' or 'item', not both\")\n\n        if item is not None:\n            try:\n                if hasattr(item, \"to_dict\") and hasattr(item, \"self_href\"):\n                    stac_url = item.self_href\n                    if not stac_url and hasattr(item, \"links\"):\n                        for link in item.links:\n                            if link.rel == \"self\":\n                                stac_url = link.href\n                                break\n                    if not stac_url:\n                        raise ValueError(\"STAC item must have a self_href or self link\")\n                else:\n                    raise ValueError(\n                        \"Item must be a pystac Item object with to_dict() and self_href\"\n                    )\n            except Exception as e:\n                raise ValueError(f\"Invalid STAC item: {e}\")\n        else:\n            stac_url = url\n\n        tile_params = {\"url\": stac_url}\n        if assets:\n            tile_params[\"assets\"] = \",\".join(assets)\n        if colormap:\n            tile_params[\"colormap_name\"] = colormap\n        if rescale:\n            if len(rescale) == 2:\n                tile_params[\"rescale\"] = f\"{rescale[0]},{rescale[1]}\"\n            else:\n                raise ValueError(\"rescale must be a list of two values [min, max]\")\n\n        query_string = urlencode(tile_params)\n        tile_url = f\"{titiler_endpoint.rstrip('/')}/stac/tiles/{{z}}/{{x}}/{{y}}?{query_string}\"\n\n        layer_name = layer_id or f\"stac-{len(self._layers)}\"\n\n        self.add_tile_layer(\n            url=tile_url,\n            name=layer_name,\n            attribution=attribution,\n            **kwargs,\n        )\n\n        if fit_bounds and item is not None:\n            try:\n                bbox = item.bbox\n                if bbox and len(bbox) == 4:\n                    self.fit_bounds([[bbox[0], bbox[1]], [bbox[2], bbox[3]]])\n            except Exception:\n                pass\n\n    # -------------------------------------------------------------------------\n    # COG Layer (deck.gl)\n    # -------------------------------------------------------------------------\n\n    def add_heatmap(\n        self,\n        data: Any,\n        weight_property: Optional[str] = None,\n        radius: int = 20,\n        intensity: float = 1.0,\n        colormap: Optional[List] = None,\n        opacity: float = 0.8,\n        name: Optional[str] = None,\n        fit_bounds: bool = True,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a heatmap layer to the map.\"\"\"\n        self._validate_opacity(opacity)\n        layer_id = name or f\"heatmap-{len(self._layers)}\"\n\n        geojson = to_geojson(data)\n\n        if geojson.get(\"type\") == \"url\":\n            url = geojson[\"url\"]\n            geojson = fetch_geojson(url)\n\n        if colormap is None:\n            colormap = [\n                [0, \"rgba(33,102,172,0)\"],\n                [0.2, \"rgb(103,169,207)\"],\n                [0.4, \"rgb(209,229,240)\"],\n                [0.6, \"rgb(253,219,199)\"],\n                [0.8, \"rgb(239,138,98)\"],\n                [1, \"rgb(178,24,43)\"],\n            ]\n\n        paint = {\n            \"heatmap-radius\": radius,\n            \"heatmap-intensity\": intensity,\n            \"heatmap-opacity\": opacity,\n            \"heatmap-color\": [\n                \"interpolate\",\n                [\"linear\"],\n                [\"heatmap-density\"],\n            ],\n        }\n\n        for stop, color in colormap:\n            paint[\"heatmap-color\"].extend([stop, color])\n\n        if weight_property:\n            paint[\"heatmap-weight\"] = [\"get\", weight_property]\n\n        bounds = get_bounds(geojson) if fit_bounds else None\n\n        self.call_js_method(\n            \"addGeoJSON\",\n            data=geojson,\n            name=layer_id,\n            layerType=\"heatmap\",\n            paint=paint,\n            fitBounds=fit_bounds,\n            bounds=bounds,\n            **kwargs,\n        )\n\n        self._layers = {\n            **self._layers,\n            layer_id: {\n                \"id\": layer_id,\n                \"type\": \"heatmap\",\n                \"source\": f\"{layer_id}-source\",\n                \"paint\": paint,\n            },\n        }\n        self._add_to_layer_dict(layer_id, \"Heatmap\")\n\n    def add_cog_layer(\n        self,\n        url: str,\n        name: Optional[str] = None,\n        opacity: float = 1.0,\n        visible: bool = True,\n        debug: bool = False,\n        debug_opacity: float = 0.25,\n        max_error: float = 0.125,\n        fit_bounds: bool = True,\n        before_id: Optional[str] = None,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a Cloud Optimized GeoTIFF (COG) layer using deck.gl-raster.\n\n        This method renders COG files directly in the browser using GPU-accelerated\n        deck.gl rendering with automatic reprojection support.\n\n        Args:\n            url: URL to the Cloud Optimized GeoTIFF file.\n            name: Layer ID. If None, auto-generated.\n            opacity: Layer opacity (0-1).\n            visible: Whether layer is visible.\n            debug: Show reprojection mesh for debugging.\n            debug_opacity: Opacity of debug mesh (0-1).\n            max_error: Maximum reprojection error in pixels. Lower values\n                create denser mesh for better accuracy.\n            fit_bounds: Whether to fit map to COG bounds after loading.\n            before_id: ID of layer to insert before.\n            **kwargs: Additional COGLayer props.\n\n        Example:\n            &gt;&gt;&gt; from anymap_ts import MapboxMap\n            &gt;&gt;&gt; m = MapboxMap()\n            &gt;&gt;&gt; m.add_cog_layer(\n            ...     \"https://example.com/landcover.tif\",\n            ...     name=\"landcover\",\n            ...     opacity=0.8\n            ... )\n        \"\"\"\n        layer_id = name or f\"cog-{len(self._layers)}\"\n\n        self.call_js_method(\n            \"addCOGLayer\",\n            id=layer_id,\n            geotiff=url,\n            opacity=opacity,\n            visible=visible,\n            debug=debug,\n            debugOpacity=debug_opacity,\n            maxError=max_error,\n            fitBounds=fit_bounds,\n            beforeId=before_id,\n            **kwargs,\n        )\n\n        self._layers = {\n            **self._layers,\n            layer_id: {\n                \"id\": layer_id,\n                \"type\": \"cog\",\n                \"url\": url,\n            },\n        }\n        self._add_to_layer_dict(layer_id, \"Raster\")\n\n    def remove_cog_layer(self, layer_id: str) -&gt; None:\n        \"\"\"Remove a COG layer.\"\"\"\n        self._remove_layer_internal(layer_id, \"removeCOGLayer\")\n\n    def add_zarr_layer(\n        self,\n        url: str,\n        variable: str,\n        name: Optional[str] = None,\n        colormap: Optional[List[str]] = None,\n        clim: Optional[Tuple[float, float]] = None,\n        opacity: float = 1.0,\n        selector: Optional[Dict[str, Any]] = None,\n        minzoom: int = 0,\n        maxzoom: int = 22,\n        fill_value: Optional[float] = None,\n        spatial_dimensions: Optional[Dict[str, str]] = None,\n        zarr_version: Optional[int] = None,\n        bounds: Optional[List[float]] = None,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a Zarr dataset layer for visualizing multidimensional array data.\"\"\"\n        layer_id = name or f\"zarr-{len(self._layers)}\"\n\n        self.call_js_method(\n            \"addZarrLayer\",\n            id=layer_id,\n            source=url,\n            variable=variable,\n            colormap=colormap or [\"#000000\", \"#ffffff\"],\n            clim=list(clim) if clim else [0, 100],\n            opacity=opacity,\n            selector=selector or {},\n            minzoom=minzoom,\n            maxzoom=maxzoom,\n            fillValue=fill_value,\n            spatialDimensions=spatial_dimensions,\n            zarrVersion=zarr_version,\n            bounds=bounds,\n            **kwargs,\n        )\n\n        self._layers = {\n            **self._layers,\n            layer_id: {\n                \"id\": layer_id,\n                \"type\": \"zarr\",\n                \"url\": url,\n                \"variable\": variable,\n            },\n        }\n        self._add_to_layer_dict(layer_id, \"Raster\")\n\n    def remove_zarr_layer(self, layer_id: str) -&gt; None:\n        \"\"\"Remove a Zarr layer.\"\"\"\n        self._remove_layer_internal(layer_id, \"removeZarrLayer\")\n\n    def update_zarr_layer(\n        self,\n        layer_id: str,\n        selector: Optional[Dict[str, Any]] = None,\n        clim: Optional[Tuple[float, float]] = None,\n        colormap: Optional[List[str]] = None,\n        opacity: Optional[float] = None,\n    ) -&gt; None:\n        \"\"\"Update a Zarr layer's properties dynamically.\"\"\"\n        update_kwargs: Dict[str, Any] = {\"id\": layer_id}\n        if selector is not None:\n            update_kwargs[\"selector\"] = selector\n        if clim is not None:\n            update_kwargs[\"clim\"] = list(clim)\n        if colormap is not None:\n            update_kwargs[\"colormap\"] = colormap\n        if opacity is not None:\n            update_kwargs[\"opacity\"] = opacity\n        self.call_js_method(\"updateZarrLayer\", **update_kwargs)\n\n    def add_pmtiles_layer(\n        self,\n        url: str,\n        layer_id: Optional[str] = None,\n        style: Optional[Dict[str, Any]] = None,\n        opacity: float = 1.0,\n        visible: bool = True,\n        fit_bounds: bool = False,\n        source_type: str = \"vector\",\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a PMTiles layer for efficient vector or raster tile serving.\"\"\"\n        layer_id = layer_id or f\"pmtiles-{len(self._layers)}\"\n\n        self.call_js_method(\n            \"addPMTilesLayer\",\n            url=url,\n            id=layer_id,\n            style=style or {},\n            opacity=opacity,\n            visible=visible,\n            fitBounds=fit_bounds,\n            sourceType=source_type,\n            name=layer_id,\n            **kwargs,\n        )\n\n        self._layers = {\n            **self._layers,\n            layer_id: {\n                \"id\": layer_id,\n                \"type\": \"pmtiles\",\n                \"url\": url,\n                \"source_type\": source_type,\n            },\n        }\n        category = \"Vector\" if source_type == \"vector\" else \"Raster\"\n        self._add_to_layer_dict(layer_id, category)\n\n    def remove_pmtiles_layer(self, layer_id: str) -&gt; None:\n        \"\"\"Remove a PMTiles layer.\"\"\"\n        self._remove_layer_internal(layer_id, \"removePMTilesLayer\")\n\n    # -------------------------------------------------------------------------\n    # Arc Layer (deck.gl)\n    # -------------------------------------------------------------------------\n\n    def add_arc_layer(\n        self,\n        data: Any,\n        name: Optional[str] = None,\n        get_source_position: Union[str, Any] = \"source\",\n        get_target_position: Union[str, Any] = \"target\",\n        get_source_color: Optional[List[int]] = None,\n        get_target_color: Optional[List[int]] = None,\n        get_width: Union[float, str] = 1,\n        get_height: float = 1,\n        great_circle: bool = False,\n        pickable: bool = True,\n        opacity: float = 0.8,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add an arc layer for origin-destination visualization using deck.gl.\n\n        Arc layers are ideal for visualizing connections between locations,\n        such as flight routes, migration patterns, or network flows.\n\n        Args:\n            data: Array of data objects with source/target coordinates.\n                Each object should have source and target positions.\n            name: Layer ID. If None, auto-generated.\n            get_source_position: Accessor for source position [lng, lat].\n                Can be a string (property name) or a value.\n            get_target_position: Accessor for target position [lng, lat].\n                Can be a string (property name) or a value.\n            get_source_color: Source end color as [r, g, b, a].\n                Default: [51, 136, 255, 255] (blue).\n            get_target_color: Target end color as [r, g, b, a].\n                Default: [255, 136, 51, 255] (orange).\n            get_width: Arc width in pixels. Can be a number or accessor.\n            get_height: Arc height multiplier. Higher values create more curved arcs.\n            great_circle: Whether to draw arcs along great circles.\n            pickable: Whether layer responds to hover/click events.\n            opacity: Layer opacity (0-1).\n            **kwargs: Additional ArcLayer props.\n\n        Example:\n            &gt;&gt;&gt; from anymap_ts import MapboxMap\n            &gt;&gt;&gt; m = MapboxMap()\n            &gt;&gt;&gt; arcs = [\n            ...     {\"source\": [-122.4, 37.8], \"target\": [-73.9, 40.7]},\n            ...     {\"source\": [-122.4, 37.8], \"target\": [-0.1, 51.5]},\n            ... ]\n            &gt;&gt;&gt; m.add_arc_layer(arcs, name=\"flights\")\n        \"\"\"\n        layer_id = name or f\"arc-{len(self._layers)}\"\n        processed_data = self._process_deck_data(data)\n\n        self.call_js_method(\n            \"addArcLayer\",\n            id=layer_id,\n            data=processed_data,\n            getSourcePosition=get_source_position,\n            getTargetPosition=get_target_position,\n            getSourceColor=get_source_color or [51, 136, 255, 255],\n            getTargetColor=get_target_color or [255, 136, 51, 255],\n            getWidth=get_width,\n            getHeight=get_height,\n            greatCircle=great_circle,\n            pickable=pickable,\n            opacity=opacity,\n            **kwargs,\n        )\n\n        self._layers = {\n            **self._layers,\n            layer_id: {\n                \"id\": layer_id,\n                \"type\": \"arc\",\n            },\n        }\n        self._add_to_layer_dict(layer_id, \"Deck.gl\")\n\n    def remove_arc_layer(self, layer_id: str) -&gt; None:\n        \"\"\"Remove an arc layer.\"\"\"\n        self._remove_layer_internal(layer_id, \"removeArcLayer\")\n\n    # -------------------------------------------------------------------------\n    # PointCloud Layer (deck.gl)\n    # -------------------------------------------------------------------------\n\n    def add_point_cloud_layer(\n        self,\n        data: Any,\n        name: Optional[str] = None,\n        get_position: Union[str, Any] = \"position\",\n        get_color: Optional[Union[List[int], str]] = None,\n        get_normal: Optional[Union[str, Any]] = None,\n        point_size: float = 2,\n        size_units: str = \"pixels\",\n        pickable: bool = True,\n        opacity: float = 1.0,\n        material: bool = True,\n        coordinate_system: Optional[int] = None,\n        coordinate_origin: Optional[List[float]] = None,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a point cloud layer for 3D point visualization using deck.gl.\n\n        Point cloud layers render large collections of 3D points, ideal for\n        LiDAR data, photogrammetry outputs, or any 3D point dataset.\n\n        Args:\n            data: Array of point data with positions. Each point should have\n                x, y, z coordinates (or position array).\n            name: Layer ID. If None, auto-generated.\n            get_position: Accessor for point position [x, y, z].\n                Can be a string (property name) or a value.\n            get_color: Accessor or value for point color [r, g, b, a].\n                Default: [255, 255, 255, 255] (white).\n            get_normal: Accessor for point normal [nx, ny, nz] for lighting.\n                Default: [0, 0, 1] (pointing up).\n            point_size: Point size in pixels or meters (depends on size_units).\n            size_units: Size units: 'pixels', 'meters', or 'common'.\n            pickable: Whether layer responds to hover/click events.\n            opacity: Layer opacity (0-1).\n            material: Whether to enable lighting effects.\n            coordinate_system: Coordinate system for positions.\n            coordinate_origin: Origin for coordinate system [x, y, z].\n            **kwargs: Additional PointCloudLayer props.\n\n        Example:\n            &gt;&gt;&gt; from anymap_ts import MapboxMap\n            &gt;&gt;&gt; m = MapboxMap(pitch=45)\n            &gt;&gt;&gt; points = [\n            ...     {\"position\": [-122.4, 37.8, 100], \"color\": [255, 0, 0, 255]},\n            ...     {\"position\": [-122.3, 37.7, 200], \"color\": [0, 255, 0, 255]},\n            ... ]\n            &gt;&gt;&gt; m.add_point_cloud_layer(points, point_size=5)\n        \"\"\"\n        layer_id = name or f\"pointcloud-{len(self._layers)}\"\n        processed_data = self._process_deck_data(data)\n\n        self.call_js_method(\n            \"addPointCloudLayer\",\n            id=layer_id,\n            data=processed_data,\n            getPosition=get_position,\n            getColor=get_color or [255, 255, 255, 255],\n            getNormal=get_normal,\n            pointSize=point_size,\n            sizeUnits=size_units,\n            pickable=pickable,\n            opacity=opacity,\n            material=material,\n            coordinateSystem=coordinate_system,\n            coordinateOrigin=coordinate_origin,\n            **kwargs,\n        )\n\n        self._layers = {\n            **self._layers,\n            layer_id: {\n                \"id\": layer_id,\n                \"type\": \"pointcloud\",\n            },\n        }\n        self._add_to_layer_dict(layer_id, \"Deck.gl\")\n\n    def remove_point_cloud_layer(self, layer_id: str) -&gt; None:\n        \"\"\"Remove a point cloud layer.\"\"\"\n        self._remove_layer_internal(layer_id, \"removePointCloudLayer\")\n\n    def add_scatterplot_layer(\n        self,\n        data: Any,\n        name: Optional[str] = None,\n        get_position: Union[str, Any] = \"coordinates\",\n        get_radius: Union[float, str] = 5,\n        get_fill_color: Optional[Union[List[int], str]] = None,\n        get_line_color: Optional[Union[List[int], str]] = None,\n        radius_scale: float = 1,\n        radius_min_pixels: float = 1,\n        radius_max_pixels: float = 100,\n        line_width_min_pixels: float = 1,\n        stroked: bool = True,\n        filled: bool = True,\n        pickable: bool = True,\n        opacity: float = 0.8,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a scatterplot layer using deck.gl.\"\"\"\n        layer_id = name or f\"scatterplot-{len(self._layers)}\"\n        processed_data = self._process_deck_data(data)\n\n        self.call_js_method(\n            \"addScatterplotLayer\",\n            id=layer_id,\n            data=processed_data,\n            getPosition=get_position,\n            getRadius=get_radius,\n            getFillColor=get_fill_color or [51, 136, 255, 200],\n            getLineColor=get_line_color or [255, 255, 255, 255],\n            radiusScale=radius_scale,\n            radiusMinPixels=radius_min_pixels,\n            radiusMaxPixels=radius_max_pixels,\n            lineWidthMinPixels=line_width_min_pixels,\n            stroked=stroked,\n            filled=filled,\n            pickable=pickable,\n            opacity=opacity,\n            **kwargs,\n        )\n\n        self._layers = {\n            **self._layers,\n            layer_id: {\"id\": layer_id, \"type\": \"scatterplot\"},\n        }\n        self._add_to_layer_dict(layer_id, \"Deck.gl\")\n\n    def add_path_layer(\n        self,\n        data: Any,\n        name: Optional[str] = None,\n        get_path: Union[str, Any] = \"path\",\n        get_color: Optional[Union[List[int], str]] = None,\n        get_width: Union[float, str] = 1,\n        width_scale: float = 1,\n        width_min_pixels: float = 1,\n        pickable: bool = True,\n        opacity: float = 0.8,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a path layer using deck.gl.\"\"\"\n        layer_id = name or f\"path-{len(self._layers)}\"\n        processed_data = self._process_deck_data(data)\n\n        self.call_js_method(\n            \"addPathLayer\",\n            id=layer_id,\n            data=processed_data,\n            getPath=get_path,\n            getColor=get_color or [51, 136, 255, 200],\n            getWidth=get_width,\n            widthScale=width_scale,\n            widthMinPixels=width_min_pixels,\n            pickable=pickable,\n            opacity=opacity,\n            **kwargs,\n        )\n\n        self._layers = {**self._layers, layer_id: {\"id\": layer_id, \"type\": \"path\"}}\n        self._add_to_layer_dict(layer_id, \"Deck.gl\")\n\n    def add_polygon_layer(\n        self,\n        data: Any,\n        name: Optional[str] = None,\n        get_polygon: Union[str, Any] = \"polygon\",\n        get_fill_color: Optional[Union[List[int], str]] = None,\n        get_line_color: Optional[Union[List[int], str]] = None,\n        get_line_width: Union[float, str] = 1,\n        get_elevation: Union[float, str] = 0,\n        extruded: bool = False,\n        wireframe: bool = False,\n        filled: bool = True,\n        stroked: bool = True,\n        line_width_min_pixels: float = 1,\n        pickable: bool = True,\n        opacity: float = 0.5,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a polygon layer using deck.gl.\"\"\"\n        layer_id = name or f\"polygon-{len(self._layers)}\"\n        processed_data = self._process_deck_data(data)\n\n        self.call_js_method(\n            \"addPolygonLayer\",\n            id=layer_id,\n            data=processed_data,\n            getPolygon=get_polygon,\n            getFillColor=get_fill_color or [51, 136, 255, 128],\n            getLineColor=get_line_color or [0, 0, 255, 255],\n            getLineWidth=get_line_width,\n            getElevation=get_elevation,\n            extruded=extruded,\n            wireframe=wireframe,\n            filled=filled,\n            stroked=stroked,\n            lineWidthMinPixels=line_width_min_pixels,\n            pickable=pickable,\n            opacity=opacity,\n            **kwargs,\n        )\n\n        self._layers = {**self._layers, layer_id: {\"id\": layer_id, \"type\": \"polygon\"}}\n        self._add_to_layer_dict(layer_id, \"Deck.gl\")\n\n    def add_hexagon_layer(\n        self,\n        data: Any,\n        name: Optional[str] = None,\n        get_position: Union[str, Any] = \"coordinates\",\n        radius: float = 1000,\n        elevation_scale: float = 4,\n        extruded: bool = True,\n        color_range: Optional[List[List[int]]] = None,\n        pickable: bool = True,\n        opacity: float = 0.8,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a hexagon layer using deck.gl.\"\"\"\n        layer_id = name or f\"hexagon-{len(self._layers)}\"\n        processed_data = self._process_deck_data(data)\n\n        default_color_range = [\n            [1, 152, 189],\n            [73, 227, 206],\n            [216, 254, 181],\n            [254, 237, 177],\n            [254, 173, 84],\n            [209, 55, 78],\n        ]\n\n        self.call_js_method(\n            \"addHexagonLayer\",\n            id=layer_id,\n            data=processed_data,\n            getPosition=get_position,\n            radius=radius,\n            elevationScale=elevation_scale,\n            extruded=extruded,\n            colorRange=color_range or default_color_range,\n            pickable=pickable,\n            opacity=opacity,\n            **kwargs,\n        )\n\n        self._layers = {**self._layers, layer_id: {\"id\": layer_id, \"type\": \"hexagon\"}}\n        self._add_to_layer_dict(layer_id, \"Deck.gl\")\n\n    def add_deck_heatmap_layer(\n        self,\n        data: Any,\n        name: Optional[str] = None,\n        get_position: Union[str, Any] = \"coordinates\",\n        get_weight: Union[float, str] = 1,\n        radius_pixels: float = 30,\n        intensity: float = 1,\n        threshold: float = 0.05,\n        color_range: Optional[List[List[int]]] = None,\n        opacity: float = 1,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a GPU-accelerated heatmap layer using deck.gl.\"\"\"\n        layer_id = name or f\"deck-heatmap-{len(self._layers)}\"\n        processed_data = self._process_deck_data(data)\n\n        default_color_range = [\n            [255, 255, 178, 25],\n            [254, 217, 118, 85],\n            [254, 178, 76, 127],\n            [253, 141, 60, 170],\n            [240, 59, 32, 212],\n            [189, 0, 38, 255],\n        ]\n\n        self.call_js_method(\n            \"addHeatmapLayer\",\n            id=layer_id,\n            data=processed_data,\n            getPosition=get_position,\n            getWeight=get_weight,\n            radiusPixels=radius_pixels,\n            intensity=intensity,\n            threshold=threshold,\n            colorRange=color_range or default_color_range,\n            opacity=opacity,\n            **kwargs,\n        )\n\n        self._layers = {\n            **self._layers,\n            layer_id: {\"id\": layer_id, \"type\": \"deck-heatmap\"},\n        }\n        self._add_to_layer_dict(layer_id, \"Deck.gl\")\n\n    def add_grid_layer(\n        self,\n        data: Any,\n        name: Optional[str] = None,\n        get_position: Union[str, Any] = \"coordinates\",\n        cell_size: float = 200,\n        elevation_scale: float = 4,\n        extruded: bool = True,\n        color_range: Optional[List[List[int]]] = None,\n        pickable: bool = True,\n        opacity: float = 0.8,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a grid layer using deck.gl.\"\"\"\n        layer_id = name or f\"grid-{len(self._layers)}\"\n        processed_data = self._process_deck_data(data)\n\n        default_color_range = [\n            [1, 152, 189],\n            [73, 227, 206],\n            [216, 254, 181],\n            [254, 237, 177],\n            [254, 173, 84],\n            [209, 55, 78],\n        ]\n\n        self.call_js_method(\n            \"addGridLayer\",\n            id=layer_id,\n            data=processed_data,\n            getPosition=get_position,\n            cellSize=cell_size,\n            elevationScale=elevation_scale,\n            extruded=extruded,\n            colorRange=color_range or default_color_range,\n            pickable=pickable,\n            opacity=opacity,\n            **kwargs,\n        )\n\n        self._layers = {**self._layers, layer_id: {\"id\": layer_id, \"type\": \"grid\"}}\n        self._add_to_layer_dict(layer_id, \"Deck.gl\")\n\n    def add_icon_layer(\n        self,\n        data: Any,\n        name: Optional[str] = None,\n        get_position: Union[str, Any] = \"coordinates\",\n        get_icon: Union[str, Any] = \"icon\",\n        get_size: Union[float, str] = 20,\n        get_color: Optional[Union[List[int], str]] = None,\n        icon_atlas: Optional[str] = None,\n        icon_mapping: Optional[Dict] = None,\n        pickable: bool = True,\n        opacity: float = 1,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add an icon layer using deck.gl.\"\"\"\n        layer_id = name or f\"icon-{len(self._layers)}\"\n        processed_data = self._process_deck_data(data)\n\n        self.call_js_method(\n            \"addIconLayer\",\n            id=layer_id,\n            data=processed_data,\n            getPosition=get_position,\n            getIcon=get_icon,\n            getSize=get_size,\n            getColor=get_color or [255, 255, 255, 255],\n            iconAtlas=icon_atlas,\n            iconMapping=icon_mapping,\n            pickable=pickable,\n            opacity=opacity,\n            **kwargs,\n        )\n\n        self._layers = {**self._layers, layer_id: {\"id\": layer_id, \"type\": \"icon\"}}\n        self._add_to_layer_dict(layer_id, \"Deck.gl\")\n\n    def add_text_layer(\n        self,\n        data: Any,\n        name: Optional[str] = None,\n        get_position: Union[str, Any] = \"coordinates\",\n        get_text: Union[str, Any] = \"text\",\n        get_size: Union[float, str] = 12,\n        get_color: Optional[Union[List[int], str]] = None,\n        get_angle: Union[float, str] = 0,\n        text_anchor: str = \"middle\",\n        alignment_baseline: str = \"center\",\n        pickable: bool = True,\n        opacity: float = 1,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a text layer using deck.gl.\"\"\"\n        layer_id = name or f\"text-{len(self._layers)}\"\n        processed_data = self._process_deck_data(data)\n\n        self.call_js_method(\n            \"addTextLayer\",\n            id=layer_id,\n            data=processed_data,\n            getPosition=get_position,\n            getText=get_text,\n            getSize=get_size,\n            getColor=get_color or [0, 0, 0, 255],\n            getAngle=get_angle,\n            getTextAnchor=text_anchor,\n            getAlignmentBaseline=alignment_baseline,\n            pickable=pickable,\n            opacity=opacity,\n            **kwargs,\n        )\n\n        self._layers = {**self._layers, layer_id: {\"id\": layer_id, \"type\": \"text\"}}\n        self._add_to_layer_dict(layer_id, \"Deck.gl\")\n\n    def add_geojson_layer(\n        self,\n        data: Any,\n        name: Optional[str] = None,\n        get_fill_color: Optional[Union[List[int], str]] = None,\n        get_line_color: Optional[Union[List[int], str]] = None,\n        get_line_width: Union[float, str] = 1,\n        get_point_radius: Union[float, str] = 5,\n        get_elevation: Union[float, str] = 0,\n        extruded: bool = False,\n        wireframe: bool = False,\n        filled: bool = True,\n        stroked: bool = True,\n        line_width_min_pixels: float = 1,\n        point_radius_min_pixels: float = 2,\n        pickable: bool = True,\n        opacity: float = 0.8,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a GeoJSON layer with auto-styling using deck.gl.\"\"\"\n        layer_id = name or f\"geojson-deck-{len(self._layers)}\"\n        processed_data = self._process_deck_data(data)\n\n        self.call_js_method(\n            \"addGeoJsonLayer\",\n            id=layer_id,\n            data=processed_data,\n            getFillColor=get_fill_color or [51, 136, 255, 128],\n            getLineColor=get_line_color or [0, 0, 0, 255],\n            getLineWidth=get_line_width,\n            getPointRadius=get_point_radius,\n            getElevation=get_elevation,\n            extruded=extruded,\n            wireframe=wireframe,\n            filled=filled,\n            stroked=stroked,\n            lineWidthMinPixels=line_width_min_pixels,\n            pointRadiusMinPixels=point_radius_min_pixels,\n            pickable=pickable,\n            opacity=opacity,\n            **kwargs,\n        )\n\n        self._layers = {\n            **self._layers,\n            layer_id: {\"id\": layer_id, \"type\": \"geojson-deck\"},\n        }\n        self._add_to_layer_dict(layer_id, \"Deck.gl\")\n\n    def add_contour_layer(\n        self,\n        data: Any,\n        name: Optional[str] = None,\n        get_position: Union[str, Any] = \"coordinates\",\n        get_weight: Union[float, str] = 1,\n        cell_size: float = 200,\n        contours: Optional[List[Dict]] = None,\n        pickable: bool = True,\n        opacity: float = 1,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a contour layer using deck.gl.\"\"\"\n        layer_id = name or f\"contour-{len(self._layers)}\"\n        processed_data = self._process_deck_data(data)\n\n        default_contours = [\n            {\"threshold\": 1, \"color\": [255, 255, 255], \"strokeWidth\": 1},\n            {\"threshold\": 5, \"color\": [51, 136, 255], \"strokeWidth\": 2},\n            {\"threshold\": 10, \"color\": [0, 0, 255], \"strokeWidth\": 3},\n        ]\n\n        self.call_js_method(\n            \"addContourLayer\",\n            id=layer_id,\n            data=processed_data,\n            getPosition=get_position,\n            getWeight=get_weight,\n            cellSize=cell_size,\n            contours=contours or default_contours,\n            pickable=pickable,\n            opacity=opacity,\n            **kwargs,\n        )\n\n        self._layers = {**self._layers, layer_id: {\"id\": layer_id, \"type\": \"contour\"}}\n        self._add_to_layer_dict(layer_id, \"Deck.gl\")\n\n    def add_screen_grid_layer(\n        self,\n        data: Any,\n        name: Optional[str] = None,\n        get_position: Union[str, Any] = \"coordinates\",\n        get_weight: Union[float, str] = 1,\n        cell_size_pixels: float = 50,\n        color_range: Optional[List[List[int]]] = None,\n        pickable: bool = True,\n        opacity: float = 0.8,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a screen grid layer using deck.gl.\"\"\"\n        layer_id = name or f\"screengrid-{len(self._layers)}\"\n        processed_data = self._process_deck_data(data)\n\n        default_color_range = [\n            [255, 255, 178, 25],\n            [254, 217, 118, 85],\n            [254, 178, 76, 127],\n            [253, 141, 60, 170],\n            [240, 59, 32, 212],\n            [189, 0, 38, 255],\n        ]\n\n        self.call_js_method(\n            \"addScreenGridLayer\",\n            id=layer_id,\n            data=processed_data,\n            getPosition=get_position,\n            getWeight=get_weight,\n            cellSizePixels=cell_size_pixels,\n            colorRange=color_range or default_color_range,\n            pickable=pickable,\n            opacity=opacity,\n            **kwargs,\n        )\n\n        self._layers = {\n            **self._layers,\n            layer_id: {\"id\": layer_id, \"type\": \"screengrid\"},\n        }\n        self._add_to_layer_dict(layer_id, \"Deck.gl\")\n\n    def add_trips_layer(\n        self,\n        data: Any,\n        name: Optional[str] = None,\n        get_path: Union[str, Any] = \"waypoints\",\n        get_timestamps: Union[str, Any] = \"timestamps\",\n        get_color: Optional[Union[List[int], str]] = None,\n        width_min_pixels: float = 2,\n        trail_length: float = 180,\n        current_time: float = 0,\n        pickable: bool = True,\n        opacity: float = 0.8,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a trips layer using deck.gl.\"\"\"\n        layer_id = name or f\"trips-{len(self._layers)}\"\n        processed_data = self._process_deck_data(data)\n\n        self.call_js_method(\n            \"addTripsLayer\",\n            id=layer_id,\n            data=processed_data,\n            getPath=get_path,\n            getTimestamps=get_timestamps,\n            getColor=get_color or [253, 128, 93],\n            widthMinPixels=width_min_pixels,\n            trailLength=trail_length,\n            currentTime=current_time,\n            pickable=pickable,\n            opacity=opacity,\n            **kwargs,\n        )\n\n        self._layers = {**self._layers, layer_id: {\"id\": layer_id, \"type\": \"trips\"}}\n        self._add_to_layer_dict(layer_id, \"Deck.gl\")\n\n    def add_line_layer(\n        self,\n        data: Any,\n        name: Optional[str] = None,\n        get_source_position: Union[str, Any] = \"sourcePosition\",\n        get_target_position: Union[str, Any] = \"targetPosition\",\n        get_color: Optional[Union[List[int], str]] = None,\n        get_width: Union[float, str] = 1,\n        width_min_pixels: float = 1,\n        pickable: bool = True,\n        opacity: float = 0.8,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a line layer using deck.gl.\"\"\"\n        layer_id = name or f\"line-{len(self._layers)}\"\n        processed_data = self._process_deck_data(data)\n\n        self.call_js_method(\n            \"addLineLayer\",\n            id=layer_id,\n            data=processed_data,\n            getSourcePosition=get_source_position,\n            getTargetPosition=get_target_position,\n            getColor=get_color or [51, 136, 255, 200],\n            getWidth=get_width,\n            widthMinPixels=width_min_pixels,\n            pickable=pickable,\n            opacity=opacity,\n            **kwargs,\n        )\n\n        self._layers = {**self._layers, layer_id: {\"id\": layer_id, \"type\": \"line\"}}\n        self._add_to_layer_dict(layer_id, \"Deck.gl\")\n\n    def add_deckgl_layer(\n        self,\n        layer_type: str,\n        data: Any,\n        name: Optional[str] = None,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a generic deck.gl layer to the map.\"\"\"\n        layer_type_clean = layer_type.replace(\"Layer\", \"\")\n        prefix = layer_type_clean.lower()\n        layer_id = name or f\"{prefix}-{len(self._layers)}\"\n        processed_data = self._process_deck_data(data)\n\n        self.call_js_method(\n            \"addDeckGLLayer\",\n            layerType=layer_type,\n            id=layer_id,\n            data=processed_data,\n            **kwargs,\n        )\n\n        self._layers = {**self._layers, layer_id: {\"id\": layer_id, \"type\": layer_type}}\n        self._add_to_layer_dict(layer_id, \"Deck.gl\")\n\n    def remove_deck_layer(self, layer_id: str) -&gt; None:\n        \"\"\"Remove a deck.gl layer from the map.\"\"\"\n        self._remove_layer_internal(layer_id, \"removeDeckLayer\")\n\n    def add_column_layer(\n        self,\n        data: Any,\n        name: Optional[str] = None,\n        get_position: Union[str, Any] = \"coordinates\",\n        get_fill_color: Optional[Union[List[int], str]] = None,\n        get_line_color: Optional[Union[List[int], str]] = None,\n        get_elevation: Union[float, str] = 1000,\n        radius: float = 1000,\n        disk_resolution: int = 20,\n        elevation_scale: float = 1,\n        coverage: float = 1,\n        extruded: bool = True,\n        filled: bool = True,\n        stroked: bool = False,\n        wireframe: bool = False,\n        pickable: bool = True,\n        opacity: float = 0.8,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a column layer using deck.gl.\"\"\"\n        layer_id = name or f\"column-{len(self._layers)}\"\n        processed_data = self._process_deck_data(data)\n\n        self.call_js_method(\n            \"addColumnLayer\",\n            id=layer_id,\n            data=processed_data,\n            getPosition=get_position,\n            getFillColor=get_fill_color or [255, 140, 0, 200],\n            getLineColor=get_line_color or [0, 0, 0, 255],\n            getElevation=get_elevation,\n            radius=radius,\n            diskResolution=disk_resolution,\n            elevationScale=elevation_scale,\n            coverage=coverage,\n            extruded=extruded,\n            filled=filled,\n            stroked=stroked,\n            wireframe=wireframe,\n            pickable=pickable,\n            opacity=opacity,\n            **kwargs,\n        )\n\n        self._layers = {**self._layers, layer_id: {\"id\": layer_id, \"type\": \"column\"}}\n        self._add_to_layer_dict(layer_id, \"Deck.gl\")\n\n    def add_bitmap_layer(\n        self,\n        image: str,\n        bounds: List[float],\n        name: Optional[str] = None,\n        opacity: float = 1.0,\n        visible: bool = True,\n        pickable: bool = False,\n        desaturate: float = 0,\n        transparent_color: Optional[List[int]] = None,\n        tint_color: Optional[List[int]] = None,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a bitmap layer using deck.gl.\"\"\"\n        layer_id = name or f\"bitmap-{len(self._layers)}\"\n\n        self.call_js_method(\n            \"addBitmapLayer\",\n            id=layer_id,\n            image=image,\n            bounds=bounds,\n            opacity=opacity,\n            visible=visible,\n            pickable=pickable,\n            desaturate=desaturate,\n            transparentColor=transparent_color or [0, 0, 0, 0],\n            tintColor=tint_color or [255, 255, 255],\n            **kwargs,\n        )\n\n        self._layers = {**self._layers, layer_id: {\"id\": layer_id, \"type\": \"bitmap\"}}\n        self._add_to_layer_dict(layer_id, \"Deck.gl\")\n\n    def add_solid_polygon_layer(\n        self,\n        data: Any,\n        name: Optional[str] = None,\n        get_polygon: Union[str, Any] = \"polygon\",\n        get_fill_color: Optional[Union[List[int], str]] = None,\n        get_line_color: Optional[Union[List[int], str]] = None,\n        get_elevation: Union[float, str] = 0,\n        filled: bool = True,\n        extruded: bool = False,\n        wireframe: bool = False,\n        elevation_scale: float = 1,\n        pickable: bool = True,\n        opacity: float = 0.8,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a solid polygon layer using deck.gl.\"\"\"\n        layer_id = name or f\"solidpolygon-{len(self._layers)}\"\n        processed_data = self._process_deck_data(data)\n\n        self.call_js_method(\n            \"addSolidPolygonLayer\",\n            id=layer_id,\n            data=processed_data,\n            getPolygon=get_polygon,\n            getFillColor=get_fill_color or [51, 136, 255, 128],\n            getLineColor=get_line_color or [0, 0, 0, 255],\n            getElevation=get_elevation,\n            filled=filled,\n            extruded=extruded,\n            wireframe=wireframe,\n            elevationScale=elevation_scale,\n            pickable=pickable,\n            opacity=opacity,\n            **kwargs,\n        )\n\n        self._layers = {\n            **self._layers,\n            layer_id: {\"id\": layer_id, \"type\": \"solidpolygon\"},\n        }\n        self._add_to_layer_dict(layer_id, \"Deck.gl\")\n\n    def add_grid_cell_layer(\n        self,\n        data: Any,\n        name: Optional[str] = None,\n        get_position: Union[str, Any] = \"coordinates\",\n        get_color: Optional[Union[List[int], str]] = None,\n        get_elevation: Union[float, str] = 1000,\n        cell_size: float = 200,\n        coverage: float = 1,\n        elevation_scale: float = 1,\n        extruded: bool = True,\n        pickable: bool = True,\n        opacity: float = 0.8,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a grid cell layer using deck.gl.\"\"\"\n        layer_id = name or f\"gridcell-{len(self._layers)}\"\n        processed_data = self._process_deck_data(data)\n\n        self.call_js_method(\n            \"addGridCellLayer\",\n            id=layer_id,\n            data=processed_data,\n            getPosition=get_position,\n            getColor=get_color or [255, 140, 0, 200],\n            getElevation=get_elevation,\n            cellSize=cell_size,\n            coverage=coverage,\n            elevationScale=elevation_scale,\n            extruded=extruded,\n            pickable=pickable,\n            opacity=opacity,\n            **kwargs,\n        )\n\n        self._layers = {\n            **self._layers,\n            layer_id: {\"id\": layer_id, \"type\": \"gridcell\"},\n        }\n        self._add_to_layer_dict(layer_id, \"Deck.gl\")\n\n    # -------------------------------------------------------------------------\n    # LiDAR Layers (maplibre-gl-lidar)\n    # -------------------------------------------------------------------------\n\n    def add_lidar_control(\n        self,\n        position: str = \"top-right\",\n        collapsed: bool = True,\n        title: str = \"LiDAR Viewer\",\n        point_size: float = 2,\n        opacity: float = 1.0,\n        color_scheme: str = \"elevation\",\n        use_percentile: bool = True,\n        point_budget: int = 1000000,\n        pickable: bool = False,\n        auto_zoom: bool = True,\n        copc_loading_mode: Optional[str] = None,\n        streaming_point_budget: int = 5000000,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add an interactive LiDAR control panel.\n\n        The LiDAR control provides a UI panel for loading, visualizing, and\n        styling LiDAR point cloud files (LAS, LAZ, COPC formats).\n\n        Args:\n            position: Control position ('top-left', 'top-right', 'bottom-left', 'bottom-right').\n            collapsed: Whether the panel starts collapsed.\n            title: Title displayed on the panel.\n            point_size: Point size in pixels.\n            opacity: Layer opacity (0-1).\n            color_scheme: Color scheme ('elevation', 'intensity', 'classification', 'rgb').\n            use_percentile: Use 2-98% percentile for color scaling.\n            point_budget: Maximum number of points to display.\n            pickable: Enable hover/click interactions.\n            auto_zoom: Auto-zoom to point cloud after loading.\n            copc_loading_mode: COPC loading mode ('full' or 'dynamic').\n            streaming_point_budget: Point budget for streaming mode.\n            **kwargs: Additional control options.\n\n        Example:\n            &gt;&gt;&gt; from anymap_ts import MapboxMap\n            &gt;&gt;&gt; m = MapboxMap(pitch=60)\n            &gt;&gt;&gt; m.add_lidar_control(color_scheme=\"classification\", pickable=True)\n        \"\"\"\n        self.call_js_method(\n            \"addLidarControl\",\n            position=position,\n            collapsed=collapsed,\n            title=title,\n            pointSize=point_size,\n            opacity=opacity,\n            colorScheme=color_scheme,\n            usePercentile=use_percentile,\n            pointBudget=point_budget,\n            pickable=pickable,\n            autoZoom=auto_zoom,\n            copcLoadingMode=copc_loading_mode,\n            streamingPointBudget=streaming_point_budget,\n            **kwargs,\n        )\n        self._controls = {\n            **self._controls,\n            \"lidar-control\": {\"position\": position, \"collapsed\": collapsed},\n        }\n\n    def add_lidar_layer(\n        self,\n        source: Union[str, Path],\n        name: Optional[str] = None,\n        color_scheme: str = \"elevation\",\n        point_size: float = 2,\n        opacity: float = 1.0,\n        pickable: bool = True,\n        auto_zoom: bool = True,\n        streaming_mode: bool = True,\n        point_budget: int = 1000000,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Load and display a LiDAR file from URL or local path.\n\n        Supports LAS, LAZ, and COPC (Cloud-Optimized Point Cloud) formats.\n        For local files, the file is read and sent as base64 to JavaScript.\n        For URLs, the data is loaded directly via streaming when possible.\n\n        Args:\n            source: URL or local file path to the LiDAR file.\n            name: Layer identifier. If None, auto-generated.\n            color_scheme: Color scheme ('elevation', 'intensity', 'classification', 'rgb').\n            point_size: Point size in pixels.\n            opacity: Layer opacity (0-1).\n            pickable: Enable hover/click interactions.\n            auto_zoom: Auto-zoom to point cloud after loading.\n            streaming_mode: Use streaming mode for large COPC files.\n            point_budget: Maximum number of points to display.\n            **kwargs: Additional layer options.\n\n        Example:\n            &gt;&gt;&gt; from anymap_ts import MapboxMap\n            &gt;&gt;&gt; m = MapboxMap(center=[-123.07, 44.05], zoom=14, pitch=60)\n            &gt;&gt;&gt; m.add_lidar_layer(\n            ...     source=\"https://s3.amazonaws.com/hobu-lidar/autzen-classified.copc.laz\",\n            ...     name=\"autzen\",\n            ...     color_scheme=\"classification\",\n            ... )\n        \"\"\"\n        import base64\n\n        layer_id = name or f\"lidar-{len(self._layers)}\"\n\n        # Check if source is a local file\n        source_path = Path(source) if isinstance(source, (str, Path)) else None\n        is_local = source_path is not None and source_path.exists()\n\n        if is_local:\n            # Read local file and encode as base64\n            with open(source_path, \"rb\") as f:\n                file_data = f.read()\n            source_b64 = base64.b64encode(file_data).decode(\"utf-8\")\n\n            self.call_js_method(\n                \"addLidarLayer\",\n                source=source_b64,\n                name=layer_id,\n                isBase64=True,\n                filename=source_path.name,\n                colorScheme=color_scheme,\n                pointSize=point_size,\n                opacity=opacity,\n                pickable=pickable,\n                autoZoom=auto_zoom,\n                streamingMode=streaming_mode,\n                pointBudget=point_budget,\n                **kwargs,\n            )\n        else:\n            # Load from URL\n            self.call_js_method(\n                \"addLidarLayer\",\n                source=str(source),\n                name=layer_id,\n                isBase64=False,\n                colorScheme=color_scheme,\n                pointSize=point_size,\n                opacity=opacity,\n                pickable=pickable,\n                autoZoom=auto_zoom,\n                streamingMode=streaming_mode,\n                pointBudget=point_budget,\n                **kwargs,\n            )\n\n        self._layers = {\n            **self._layers,\n            layer_id: {\n                \"id\": layer_id,\n                \"type\": \"lidar\",\n                \"source\": str(source),\n            },\n        }\n\n    def remove_lidar_layer(self, layer_id: Optional[str] = None) -&gt; None:\n        \"\"\"Remove a LiDAR layer.\n\n        Args:\n            layer_id: Layer identifier to remove. If None, removes all LiDAR layers.\n        \"\"\"\n        if layer_id:\n            if layer_id in self._layers:\n                layers = dict(self._layers)\n                del layers[layer_id]\n                self._layers = layers\n            self.call_js_method(\"removeLidarLayer\", id=layer_id)\n        else:\n            # Remove all lidar layers\n            layers = dict(self._layers)\n            self._layers = {k: v for k, v in layers.items() if v.get(\"type\") != \"lidar\"}\n            self.call_js_method(\"removeLidarLayer\")\n\n    def set_lidar_color_scheme(self, color_scheme: str) -&gt; None:\n        \"\"\"Set the LiDAR color scheme.\n\n        Args:\n            color_scheme: Color scheme ('elevation', 'intensity', 'classification', 'rgb').\n        \"\"\"\n        self.call_js_method(\"setLidarColorScheme\", colorScheme=color_scheme)\n\n    def set_lidar_point_size(self, point_size: float) -&gt; None:\n        \"\"\"Set the LiDAR point size.\n\n        Args:\n            point_size: Point size in pixels.\n        \"\"\"\n        self.call_js_method(\"setLidarPointSize\", pointSize=point_size)\n\n    def set_lidar_opacity(self, opacity: float) -&gt; None:\n        \"\"\"Set the LiDAR layer opacity.\n\n        Args:\n            opacity: Opacity value between 0 and 1.\n        \"\"\"\n        self.call_js_method(\"setLidarOpacity\", opacity=opacity)\n\n    def _process_deck_data(self, data: Any) -&gt; Any:\n        \"\"\"Process data for deck.gl layers.\n\n        Handles GeoDataFrame, file paths, GeoJSON, and list of dicts.\n\n        Args:\n            data: Input data in various formats.\n\n        Returns:\n            Processed data suitable for deck.gl layers.\n        \"\"\"\n        # Handle GeoDataFrame\n        if hasattr(data, \"__geo_interface__\"):\n            return data.__geo_interface__\n\n        # Handle file paths\n        if isinstance(data, (str, Path)):\n            path = Path(data)\n            if path.exists():\n                try:\n                    import geopandas as gpd\n\n                    gdf = gpd.read_file(path)\n                    return gdf.__geo_interface__\n                except ImportError:\n                    pass\n\n        # Return as-is for lists, dicts, etc.\n        return data\n\n    # -------------------------------------------------------------------------\n    # Terrain Methods (Mapbox-specific)\n    # -------------------------------------------------------------------------\n\n    def add_terrain(\n        self, exaggeration: float = 1.0, source: str = \"mapbox-dem\"\n    ) -&gt; None:\n        \"\"\"Add 3D terrain to the map.\n\n        Args:\n            exaggeration: Terrain exaggeration factor.\n            source: Terrain source ID.\n        \"\"\"\n        self.call_js_method(\"addTerrain\", source=source, exaggeration=exaggeration)\n\n    def remove_terrain(self) -&gt; None:\n        \"\"\"Remove 3D terrain from the map.\"\"\"\n        self.call_js_method(\"removeTerrain\")\n\n    def add_3d_terrain(\n        self, exaggeration: float = 1.0, source: str = \"mapbox-dem\", **kwargs\n    ) -&gt; None:\n        \"\"\"Alias for add_terrain for MapLibre compatibility.\"\"\"\n        self.add_terrain(exaggeration=exaggeration, source=source)\n\n    # -------------------------------------------------------------------------\n    # Layer Management\n    # -------------------------------------------------------------------------\n\n    def add_layer(\n        self,\n        layer_id: str,\n        layer_type: str,\n        source: Union[str, Dict],\n        paint: Optional[Dict] = None,\n        layout: Optional[Dict] = None,\n        before_id: Optional[str] = None,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a generic layer to the map.\n\n        Args:\n            layer_id: Unique layer identifier.\n            layer_type: Mapbox layer type.\n            source: Source ID or source configuration dict.\n            paint: Paint properties.\n            layout: Layout properties.\n            before_id: ID of layer to insert before.\n            **kwargs: Additional layer options.\n        \"\"\"\n        layer_config = {\n            \"id\": layer_id,\n            \"type\": layer_type,\n            \"paint\": paint or {},\n            \"layout\": layout or {},\n            **kwargs,\n        }\n\n        if isinstance(source, str):\n            layer_config[\"source\"] = source\n        else:\n            source_id = f\"{layer_id}-source\"\n            self._sources = {**self._sources, source_id: source}\n            self.call_js_method(\"addSource\", source_id, **source)\n            layer_config[\"source\"] = source_id\n\n        self._layers = {**self._layers, layer_id: layer_config}\n        self.call_js_method(\"addLayer\", beforeId=before_id, **layer_config)\n        lt = layer_config.get(\"type\", \"\")\n        self._add_to_layer_dict(layer_id, \"Raster\" if lt == \"raster\" else \"Vector\")\n\n    def remove_layer(self, layer_id: str) -&gt; None:\n        \"\"\"Remove a layer from the map.\"\"\"\n        if layer_id in self._layers:\n            layers = dict(self._layers)\n            del layers[layer_id]\n            self._layers = layers\n        self._remove_from_layer_dict(layer_id)\n        self.call_js_method(\"removeLayer\", layer_id)\n\n    def set_visibility(self, layer_id: str, visible: bool) -&gt; None:\n        \"\"\"Set layer visibility.\n\n        Args:\n            layer_id: Layer identifier.\n            visible: Whether layer should be visible.\n        \"\"\"\n        self.call_js_method(\"setVisibility\", layer_id, visible)\n\n    def set_opacity(self, layer_id: str, opacity: float) -&gt; None:\n        \"\"\"Set layer opacity.\"\"\"\n        self._validate_opacity(opacity)\n        self.call_js_method(\"setOpacity\", layer_id, opacity)\n\n    def set_paint_property(self, layer_id: str, property_name: str, value: Any) -&gt; None:\n        \"\"\"Set a paint property for a layer.\"\"\"\n        self.call_js_method(\"setPaintProperty\", layer_id, property_name, value)\n\n    def set_layout_property(\n        self, layer_id: str, property_name: str, value: Any\n    ) -&gt; None:\n        \"\"\"Set a layout property for a layer.\"\"\"\n        self.call_js_method(\"setLayoutProperty\", layer_id, property_name, value)\n\n    def move_layer(self, layer_id: str, before_id: Optional[str] = None) -&gt; None:\n        \"\"\"Move a layer in the layer stack.\"\"\"\n        self.call_js_method(\"moveLayer\", layer_id, before_id)\n\n    def get_layer(self, layer_id: str) -&gt; Optional[Dict]:\n        \"\"\"Get layer configuration by ID.\"\"\"\n        return self._layers.get(layer_id)\n\n    def get_layer_ids(self) -&gt; List[str]:\n        \"\"\"Get list of all layer IDs.\"\"\"\n        return list(self._layers.keys())\n\n    def add_popup(\n        self,\n        layer_id: str,\n        properties: Optional[List[str]] = None,\n        template: Optional[str] = None,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add popup on click for a layer.\"\"\"\n        self.call_js_method(\n            \"addPopup\",\n            layerId=layer_id,\n            properties=properties,\n            template=template,\n            **kwargs,\n        )\n\n    # -------------------------------------------------------------------------\n    # Controls\n    # -------------------------------------------------------------------------\n\n    def add_control(\n        self,\n        control_type: str,\n        position: str = \"top-right\",\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a map control.\n\n        Args:\n            control_type: Type of control ('navigation', 'scale', 'fullscreen', etc.).\n            position: Control position.\n            **kwargs: Control-specific options.\n        \"\"\"\n        self.call_js_method(\"addControl\", control_type, position=position, **kwargs)\n        self._controls = {\n            **self._controls,\n            control_type: {\"type\": control_type, \"position\": position, **kwargs},\n        }\n\n    def remove_control(self, control_type: str) -&gt; None:\n        \"\"\"Remove a map control.\"\"\"\n        self.call_js_method(\"removeControl\", control_type)\n        if control_type in self._controls:\n            controls = dict(self._controls)\n            del controls[control_type]\n            self._controls = controls\n\n    def add_layer_control(\n        self,\n        layers: Optional[List[str]] = None,\n        position: str = \"top-right\",\n        collapsed: bool = True,\n    ) -&gt; None:\n        \"\"\"Add a layer visibility control.\"\"\"\n        if layers is None:\n            layers = list(self._layers.keys())\n\n        self.call_js_method(\n            \"addLayerControl\",\n            layers=layers,\n            position=position,\n            collapsed=collapsed,\n        )\n        self._controls = {\n            **self._controls,\n            \"layer-control\": {\n                \"layers\": layers,\n                \"position\": position,\n                \"collapsed\": collapsed,\n            },\n        }\n\n    def add_colorbar(\n        self,\n        colormap: str = \"viridis\",\n        vmin: float = 0,\n        vmax: float = 1,\n        label: str = \"\",\n        units: str = \"\",\n        orientation: str = \"horizontal\",\n        position: str = \"bottom-right\",\n        bar_thickness: Optional[int] = None,\n        bar_length: Optional[int] = None,\n        ticks: Optional[Dict] = None,\n        opacity: Optional[float] = None,\n        colorbar_id: Optional[str] = None,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a continuous gradient colorbar to the map.\"\"\"\n        self._validate_position(position)\n\n        cbar_id = (\n            colorbar_id\n            or f\"colorbar-{len([k for k in self._controls.keys() if k.startswith('colorbar')])}\"\n        )\n\n        js_kwargs: Dict[str, Any] = {\n            \"colormap\": colormap,\n            \"vmin\": vmin,\n            \"vmax\": vmax,\n            \"label\": label,\n            \"units\": units,\n            \"orientation\": orientation,\n            \"position\": position,\n            \"colorbarId\": cbar_id,\n            **kwargs,\n        }\n        if bar_thickness is not None:\n            js_kwargs[\"barThickness\"] = bar_thickness\n        if bar_length is not None:\n            js_kwargs[\"barLength\"] = bar_length\n        if ticks is not None:\n            js_kwargs[\"ticks\"] = ticks\n        if opacity is not None:\n            js_kwargs[\"opacity\"] = opacity\n\n        self.call_js_method(\"addColorbar\", **js_kwargs)\n\n        self._controls = {\n            **self._controls,\n            cbar_id: {\n                \"type\": \"colorbar\",\n                \"colormap\": colormap,\n                \"vmin\": vmin,\n                \"vmax\": vmax,\n                \"label\": label,\n                \"units\": units,\n                \"orientation\": orientation,\n                \"position\": position,\n            },\n        }\n\n    def remove_colorbar(self, colorbar_id: Optional[str] = None) -&gt; None:\n        \"\"\"Remove a colorbar from the map.\"\"\"\n        if colorbar_id is None:\n            cbar_keys = [k for k in self._controls.keys() if k.startswith(\"colorbar\")]\n            for key in cbar_keys:\n                self.call_js_method(\"removeColorbar\", colorbarId=key)\n            self._controls = {\n                k: v for k, v in self._controls.items() if not k.startswith(\"colorbar\")\n            }\n        else:\n            self.call_js_method(\"removeColorbar\", colorbarId=colorbar_id)\n            if colorbar_id in self._controls:\n                controls = dict(self._controls)\n                del controls[colorbar_id]\n                self._controls = controls\n\n    def update_colorbar(self, colorbar_id: Optional[str] = None, **kwargs) -&gt; None:\n        \"\"\"Update an existing colorbar's properties.\"\"\"\n        if colorbar_id is None:\n            cbar_keys = [k for k in self._controls.keys() if k.startswith(\"colorbar\")]\n            if not cbar_keys:\n                raise ValueError(\"No colorbar found to update\")\n            colorbar_id = cbar_keys[0]\n\n        if colorbar_id not in self._controls:\n            raise ValueError(f\"Colorbar '{colorbar_id}' not found\")\n\n        js_kwargs: Dict[str, Any] = {\"colorbarId\": colorbar_id}\n        key_map = {\"bar_thickness\": \"barThickness\", \"bar_length\": \"barLength\"}\n        for key, value in kwargs.items():\n            js_key = key_map.get(key, key)\n            js_kwargs[js_key] = value\n\n        self.call_js_method(\"updateColorbar\", **js_kwargs)\n\n    def add_search_control(\n        self,\n        position: str = \"top-left\",\n        placeholder: str = \"Search places...\",\n        collapsed: bool = True,\n        fly_to_zoom: int = 14,\n        show_marker: bool = True,\n        marker_color: str = \"#4264fb\",\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a search/geocoder control.\"\"\"\n        self._validate_position(position)\n        self.call_js_method(\n            \"addSearchControl\",\n            position=position,\n            placeholder=placeholder,\n            collapsed=collapsed,\n            flyToZoom=fly_to_zoom,\n            showMarker=show_marker,\n            markerColor=marker_color,\n            **kwargs,\n        )\n        self._controls = {\n            **self._controls,\n            \"search-control\": {\n                \"type\": \"search-control\",\n                \"position\": position,\n                \"collapsed\": collapsed,\n            },\n        }\n\n    def remove_search_control(self) -&gt; None:\n        \"\"\"Remove the search/geocoder control.\"\"\"\n        self.call_js_method(\"removeSearchControl\")\n        if \"search-control\" in self._controls:\n            controls = dict(self._controls)\n            del controls[\"search-control\"]\n            self._controls = controls\n\n    def add_measure_control(\n        self,\n        position: str = \"top-right\",\n        collapsed: bool = True,\n        default_mode: str = \"distance\",\n        distance_unit: str = \"kilometers\",\n        area_unit: str = \"square-kilometers\",\n        line_color: str = \"#3b82f6\",\n        fill_color: str = \"rgba(59, 130, 246, 0.2)\",\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a measurement control.\"\"\"\n        self._validate_position(position)\n        self.call_js_method(\n            \"addMeasureControl\",\n            position=position,\n            collapsed=collapsed,\n            defaultMode=default_mode,\n            distanceUnit=distance_unit,\n            areaUnit=area_unit,\n            lineColor=line_color,\n            fillColor=fill_color,\n            **kwargs,\n        )\n        self._controls = {\n            **self._controls,\n            \"measure-control\": {\n                \"type\": \"measure-control\",\n                \"position\": position,\n                \"collapsed\": collapsed,\n            },\n        }\n\n    def remove_measure_control(self) -&gt; None:\n        \"\"\"Remove the measurement control.\"\"\"\n        self.call_js_method(\"removeMeasureControl\")\n        if \"measure-control\" in self._controls:\n            controls = dict(self._controls)\n            del controls[\"measure-control\"]\n            self._controls = controls\n\n    def add_print_control(\n        self,\n        position: str = \"top-right\",\n        collapsed: bool = True,\n        format: str = \"png\",\n        filename: str = \"map-export\",\n        include_north_arrow: bool = False,\n        include_scale_bar: bool = False,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a print/export control.\"\"\"\n        self._validate_position(position)\n        self.call_js_method(\n            \"addPrintControl\",\n            position=position,\n            collapsed=collapsed,\n            format=format,\n            filename=filename,\n            includeNorthArrow=include_north_arrow,\n            includeScaleBar=include_scale_bar,\n            **kwargs,\n        )\n        self._controls = {\n            **self._controls,\n            \"print-control\": {\n                \"type\": \"print-control\",\n                \"position\": position,\n                \"collapsed\": collapsed,\n            },\n        }\n\n    def remove_print_control(self) -&gt; None:\n        \"\"\"Remove the print/export control.\"\"\"\n        self.call_js_method(\"removePrintControl\")\n        if \"print-control\" in self._controls:\n            controls = dict(self._controls)\n            del controls[\"print-control\"]\n            self._controls = controls\n\n    def add_coordinates_control(\n        self,\n        position: str = \"bottom-left\",\n        precision: int = 4,\n    ) -&gt; None:\n        \"\"\"Add a coordinates display control.\"\"\"\n        self.call_js_method(\n            \"addCoordinatesControl\",\n            position=position,\n            precision=precision,\n        )\n\n    def remove_coordinates_control(self) -&gt; None:\n        \"\"\"Remove the coordinates display control.\"\"\"\n        self.call_js_method(\"removeCoordinatesControl\")\n\n    def add_time_slider(\n        self,\n        layer_id: str,\n        property: str,\n        min_value: float = 0,\n        max_value: float = 100,\n        step: float = 1,\n        position: str = \"bottom-left\",\n        label: str = \"Time\",\n        auto_play: bool = False,\n        interval: int = 500,\n    ) -&gt; None:\n        \"\"\"Add a time slider to filter data by a temporal property.\"\"\"\n        self.call_js_method(\n            \"addTimeSlider\",\n            layerId=layer_id,\n            property=property,\n            min=min_value,\n            max=max_value,\n            step=step,\n            position=position,\n            label=label,\n            autoPlay=auto_play,\n            interval=interval,\n        )\n\n    def remove_time_slider(self) -&gt; None:\n        \"\"\"Remove the time slider control.\"\"\"\n        self.call_js_method(\"removeTimeSlider\")\n\n    def add_opacity_slider(\n        self,\n        layer_id: str,\n        position: str = \"top-right\",\n        label: Optional[str] = None,\n    ) -&gt; None:\n        \"\"\"Add a UI slider to control layer opacity.\"\"\"\n        self.call_js_method(\n            \"addOpacitySlider\",\n            layerId=layer_id,\n            position=position,\n            label=label or layer_id,\n        )\n\n    def remove_opacity_slider(self, layer_id: str) -&gt; None:\n        \"\"\"Remove the opacity slider for a layer.\"\"\"\n        self.call_js_method(\"removeOpacitySlider\", layerId=layer_id)\n\n    def add_style_switcher(\n        self,\n        styles: Dict[str, str],\n        position: str = \"top-right\",\n    ) -&gt; None:\n        \"\"\"Add a dropdown to switch between map styles.\"\"\"\n        self.call_js_method(\n            \"addStyleSwitcher\",\n            styles=styles,\n            position=position,\n        )\n\n    def remove_style_switcher(self) -&gt; None:\n        \"\"\"Remove the style switcher control.\"\"\"\n        self.call_js_method(\"removeStyleSwitcher\")\n\n    def add_pmtiles_control(\n        self,\n        position: str = \"top-right\",\n        collapsed: bool = True,\n        default_url: Optional[str] = None,\n        load_default_url: bool = False,\n        default_opacity: float = 1.0,\n        default_fill_color: str = \"steelblue\",\n        default_line_color: str = \"#333\",\n        default_pickable: bool = True,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a PMTiles layer control.\"\"\"\n        self.call_js_method(\n            \"addPMTilesControl\",\n            position=position,\n            collapsed=collapsed,\n            defaultUrl=default_url or \"\",\n            loadDefaultUrl=load_default_url,\n            defaultOpacity=default_opacity,\n            defaultFillColor=default_fill_color,\n            defaultLineColor=default_line_color,\n            defaultPickable=default_pickable,\n            **kwargs,\n        )\n        self._controls = {\n            **self._controls,\n            \"pmtiles-control\": {\"position\": position, \"collapsed\": collapsed},\n        }\n\n    def add_cog_control(\n        self,\n        position: str = \"top-right\",\n        collapsed: bool = True,\n        default_url: Optional[str] = None,\n        load_default_url: bool = False,\n        default_opacity: float = 1.0,\n        default_colormap: str = \"viridis\",\n        default_bands: str = \"1\",\n        default_rescale_min: float = 0,\n        default_rescale_max: float = 255,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a COG layer control.\"\"\"\n        self.call_js_method(\n            \"addCogControl\",\n            position=position,\n            collapsed=collapsed,\n            defaultUrl=default_url or \"\",\n            loadDefaultUrl=load_default_url,\n            defaultOpacity=default_opacity,\n            defaultColormap=default_colormap,\n            defaultBands=default_bands,\n            defaultRescaleMin=default_rescale_min,\n            defaultRescaleMax=default_rescale_max,\n            **kwargs,\n        )\n        self._controls = {\n            **self._controls,\n            \"cog-control\": {\"position\": position, \"collapsed\": collapsed},\n        }\n\n    def add_zarr_control(\n        self,\n        position: str = \"top-right\",\n        collapsed: bool = True,\n        default_url: Optional[str] = None,\n        load_default_url: bool = False,\n        default_opacity: float = 1.0,\n        default_variable: str = \"\",\n        default_clim: Optional[Tuple[float, float]] = None,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a Zarr layer control.\"\"\"\n        self.call_js_method(\n            \"addZarrControl\",\n            position=position,\n            collapsed=collapsed,\n            defaultUrl=default_url or \"\",\n            loadDefaultUrl=load_default_url,\n            defaultOpacity=default_opacity,\n            defaultVariable=default_variable,\n            defaultClim=list(default_clim) if default_clim else [0, 1],\n            **kwargs,\n        )\n        self._controls = {\n            **self._controls,\n            \"zarr-control\": {\"position\": position, \"collapsed\": collapsed},\n        }\n\n    def add_vector_control(\n        self,\n        position: str = \"top-right\",\n        collapsed: bool = True,\n        default_url: Optional[str] = None,\n        load_default_url: bool = False,\n        default_opacity: float = 1.0,\n        default_fill_color: str = \"#3388ff\",\n        default_stroke_color: str = \"#3388ff\",\n        fit_bounds: bool = True,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a vector layer control.\"\"\"\n        self.call_js_method(\n            \"addVectorControl\",\n            position=position,\n            collapsed=collapsed,\n            defaultUrl=default_url or \"\",\n            loadDefaultUrl=load_default_url,\n            defaultOpacity=default_opacity,\n            defaultFillColor=default_fill_color,\n            defaultStrokeColor=default_stroke_color,\n            fitBounds=fit_bounds,\n            **kwargs,\n        )\n        self._controls = {\n            **self._controls,\n            \"vector-control\": {\"position\": position, \"collapsed\": collapsed},\n        }\n\n    def add_control_grid(\n        self,\n        position: str = \"top-right\",\n        default_controls: Optional[List[str]] = None,\n        exclude: Optional[List[str]] = None,\n        rows: Optional[int] = None,\n        columns: Optional[int] = None,\n        collapsed: bool = True,\n        collapsible: bool = True,\n        title: str = \"\",\n        show_row_column_controls: bool = True,\n        gap: int = 2,\n        basemap_style_url: Optional[str] = None,\n        exclude_layers: Optional[List[str]] = None,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a ControlGrid with all default tools or a custom subset.\"\"\"\n        js_kwargs: Dict[str, Any] = {\n            \"position\": position,\n            \"collapsed\": collapsed,\n            \"collapsible\": collapsible,\n            \"showRowColumnControls\": show_row_column_controls,\n            \"gap\": gap,\n            **kwargs,\n        }\n        if default_controls is not None:\n            js_kwargs[\"defaultControls\"] = default_controls\n        if exclude is not None:\n            js_kwargs[\"exclude\"] = exclude\n        if rows is not None:\n            js_kwargs[\"rows\"] = rows\n        if columns is not None:\n            js_kwargs[\"columns\"] = columns\n        if title:\n            js_kwargs[\"title\"] = title\n        if basemap_style_url is not None:\n            js_kwargs[\"basemapStyleUrl\"] = basemap_style_url\n        if exclude_layers is not None:\n            js_kwargs[\"excludeLayers\"] = exclude_layers\n\n        self.call_js_method(\"addControlGrid\", **js_kwargs)\n        self._controls = {\n            **self._controls,\n            \"control-grid\": {\n                \"position\": position,\n                \"collapsed\": collapsed,\n                \"collapsible\": collapsible,\n            },\n        }\n\n    def add_legend(\n        self,\n        title: str,\n        labels: List[str],\n        colors: List[str],\n        position: str = \"bottom-right\",\n        opacity: float = 1.0,\n        legend_id: Optional[str] = None,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a floating legend control to the map.\"\"\"\n        if len(labels) != len(colors):\n            raise ValueError(\"Number of labels must match number of colors\")\n\n        self._validate_position(position)\n\n        for i, color in enumerate(colors):\n            if not isinstance(color, str) or not color.startswith(\"#\"):\n                raise ValueError(\n                    f\"Color at index {i} must be a hex color string (e.g., '#ff0000')\"\n                )\n\n        legend_id = (\n            legend_id\n            or f\"legend-{len([k for k in self._controls.keys() if k.startswith('legend')])}\"\n        )\n\n        legend_items = [\n            {\"label\": label, \"color\": color} for label, color in zip(labels, colors)\n        ]\n\n        self.call_js_method(\n            \"addLegend\",\n            id=legend_id,\n            title=title,\n            items=legend_items,\n            position=position,\n            opacity=opacity,\n            **kwargs,\n        )\n\n        self._controls = {\n            **self._controls,\n            legend_id: {\n                \"type\": \"legend\",\n                \"title\": title,\n                \"labels\": labels,\n                \"colors\": colors,\n                \"position\": position,\n                \"opacity\": opacity,\n            },\n        }\n\n    def remove_legend(self, legend_id: Optional[str] = None) -&gt; None:\n        \"\"\"Remove a legend control from the map.\"\"\"\n        if legend_id is None:\n            legend_keys = [k for k in self._controls.keys() if k.startswith(\"legend\")]\n            for key in legend_keys:\n                self.call_js_method(\"removeLegend\", key)\n            self._controls = {\n                k: v for k, v in self._controls.items() if not k.startswith(\"legend\")\n            }\n        else:\n            self.call_js_method(\"removeLegend\", legend_id)\n            if legend_id in self._controls:\n                controls = dict(self._controls)\n                del controls[legend_id]\n                self._controls = controls\n\n    def update_legend(\n        self,\n        legend_id: str,\n        title: Optional[str] = None,\n        labels: Optional[List[str]] = None,\n        colors: Optional[List[str]] = None,\n        opacity: Optional[float] = None,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Update an existing legend's properties.\"\"\"\n        if legend_id not in self._controls:\n            raise ValueError(f\"Legend '{legend_id}' not found\")\n\n        update_params = {\"id\": legend_id}\n\n        if title is not None:\n            update_params[\"title\"] = title\n            self._controls[legend_id][\"title\"] = title\n\n        if labels is not None and colors is not None:\n            if len(labels) != len(colors):\n                raise ValueError(\"Number of labels must match number of colors\")\n\n            legend_items = [\n                {\"label\": label, \"color\": color} for label, color in zip(labels, colors)\n            ]\n            update_params[\"items\"] = legend_items\n            self._controls[legend_id][\"labels\"] = labels\n            self._controls[legend_id][\"colors\"] = colors\n\n        elif labels is not None or colors is not None:\n            raise ValueError(\"Both labels and colors must be provided together\")\n\n        if opacity is not None:\n            update_params[\"opacity\"] = opacity\n            self._controls[legend_id][\"opacity\"] = opacity\n\n        update_params.update(kwargs)\n        self.call_js_method(\"updateLegend\", **update_params)\n\n    def add_tooltip(\n        self,\n        layer_id: str,\n        template: Optional[str] = None,\n        properties: Optional[List[str]] = None,\n    ) -&gt; None:\n        \"\"\"Add a tooltip that shows on feature hover.\"\"\"\n        self.call_js_method(\n            \"addTooltip\",\n            layerId=layer_id,\n            template=template or \"\",\n            properties=properties,\n        )\n\n    def remove_tooltip(self, layer_id: str) -&gt; None:\n        \"\"\"Remove tooltip from a layer.\"\"\"\n        self.call_js_method(\"removeTooltip\", layerId=layer_id)\n\n    def add_flatgeobuf(\n        self,\n        url: str,\n        name: Optional[str] = None,\n        layer_type: Optional[str] = None,\n        paint: Optional[Dict] = None,\n        fit_bounds: bool = True,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a FlatGeobuf layer from a URL.\"\"\"\n        layer_id = name or f\"flatgeobuf-{len(self._layers)}\"\n\n        self.call_js_method(\n            \"addFlatGeobuf\",\n            url=url,\n            name=layer_id,\n            layerType=layer_type,\n            paint=paint,\n            fitBounds=fit_bounds,\n            **kwargs,\n        )\n\n        self._layers = {\n            **self._layers,\n            layer_id: {\n                \"id\": layer_id,\n                \"type\": \"flatgeobuf\",\n                \"url\": url,\n            },\n        }\n        self._add_to_layer_dict(layer_id, \"Vector\")\n\n    def remove_flatgeobuf(self, name: str) -&gt; None:\n        \"\"\"Remove a FlatGeobuf layer from the map.\"\"\"\n        if name in self._layers:\n            layers = dict(self._layers)\n            del layers[name]\n            self._layers = layers\n        self._remove_from_layer_dict(name)\n        self.call_js_method(\"removeFlatGeobuf\", name=name)\n\n    def add_draw_control(\n        self,\n        position: str = \"top-right\",\n        draw_modes: Optional[List[str]] = None,\n        edit_modes: Optional[List[str]] = None,\n        collapsed: bool = False,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a drawing control.\"\"\"\n        if draw_modes is None:\n            draw_modes = [\"polygon\", \"line\", \"rectangle\", \"circle\", \"marker\"]\n        if edit_modes is None:\n            edit_modes = [\"select\", \"drag\", \"change\", \"rotate\", \"delete\"]\n\n        self.call_js_method(\n            \"addDrawControl\",\n            position=position,\n            drawModes=draw_modes,\n            editModes=edit_modes,\n            collapsed=collapsed,\n            **kwargs,\n        )\n        self._controls = {\n            **self._controls,\n            \"draw-control\": {\n                \"position\": position,\n                \"drawModes\": draw_modes,\n                \"editModes\": edit_modes,\n            },\n        }\n\n    def get_draw_data(self) -&gt; Dict:\n        \"\"\"Get the current drawn features as GeoJSON.\"\"\"\n        self.call_js_method(\"getDrawData\")\n        import time\n\n        time.sleep(0.1)\n        return self._draw_data or {\"type\": \"FeatureCollection\", \"features\": []}\n\n    @property\n    def draw_data(self) -&gt; Dict:\n        \"\"\"Property to access current draw data.\"\"\"\n        return self._draw_data or {\"type\": \"FeatureCollection\", \"features\": []}\n\n    def load_draw_data(self, geojson: Dict) -&gt; None:\n        \"\"\"Load GeoJSON features into the drawing layer.\"\"\"\n        self._draw_data = geojson\n        self.call_js_method(\"loadDrawData\", geojson)\n\n    def clear_draw_data(self) -&gt; None:\n        \"\"\"Clear all drawn features.\"\"\"\n        self._draw_data = {\"type\": \"FeatureCollection\", \"features\": []}\n        self.call_js_method(\"clearDrawData\")\n\n    def save_draw_data(\n        self,\n        filepath: Union[str, Path],\n        driver: Optional[str] = None,\n    ) -&gt; None:\n        \"\"\"Save drawn features to a file.\"\"\"\n        try:\n            import geopandas as gpd\n        except ImportError:\n            raise ImportError(\n                \"geopandas is required to save draw data. \"\n                \"Install with: pip install anymap-ts[vector]\"\n            )\n\n        data = self.get_draw_data()\n        if not data.get(\"features\"):\n            print(\"No features to save\")\n            return\n\n        gdf = gpd.GeoDataFrame.from_features(data[\"features\"])\n        filepath = Path(filepath)\n\n        if driver is None:\n            ext = filepath.suffix.lower()\n            driver_map = {\n                \".geojson\": \"GeoJSON\",\n                \".json\": \"GeoJSON\",\n                \".shp\": \"ESRI Shapefile\",\n                \".gpkg\": \"GPKG\",\n            }\n            driver = driver_map.get(ext, \"GeoJSON\")\n\n        gdf.to_file(filepath, driver=driver)\n\n    def add_cluster_layer(\n        self,\n        data: Any,\n        cluster_radius: int = 50,\n        cluster_max_zoom: int = 14,\n        cluster_colors: Optional[List[str]] = None,\n        cluster_steps: Optional[List[int]] = None,\n        cluster_min_radius: int = 15,\n        cluster_max_radius: int = 30,\n        unclustered_color: str = \"#11b4da\",\n        unclustered_radius: int = 8,\n        show_cluster_count: bool = True,\n        name: Optional[str] = None,\n        zoom_on_click: bool = True,\n        fit_bounds: bool = True,\n        **kwargs,\n    ) -&gt; str:\n        \"\"\"Add a clustered point layer.\"\"\"\n        layer_id = name or f\"cluster-{len(self._layers)}\"\n\n        if cluster_colors is None:\n            cluster_colors = [\"#51bbd6\", \"#f1f075\", \"#f28cb1\"]\n        if cluster_steps is None:\n            cluster_steps = [100, 750]\n\n        if len(cluster_steps) != len(cluster_colors) - 1:\n            raise ValueError(\n                f\"cluster_steps must have {len(cluster_colors) - 1} values \"\n                f\"(one less than cluster_colors), got {len(cluster_steps)}\"\n            )\n\n        geojson = to_geojson(data)\n\n        if geojson.get(\"type\") == \"url\":\n            url = geojson[\"url\"]\n            geojson = fetch_geojson(url)\n\n        bounds = get_bounds(geojson) if fit_bounds else None\n\n        self.call_js_method(\n            \"addClusterLayer\",\n            data=geojson,\n            name=layer_id,\n            clusterRadius=cluster_radius,\n            clusterMaxZoom=cluster_max_zoom,\n            clusterColors=cluster_colors,\n            clusterSteps=cluster_steps,\n            clusterMinRadius=cluster_min_radius,\n            clusterMaxRadius=cluster_max_radius,\n            unclusteredColor=unclustered_color,\n            unclusteredRadius=unclustered_radius,\n            showClusterCount=show_cluster_count,\n            zoomOnClick=zoom_on_click,\n            fitBounds=fit_bounds,\n            bounds=bounds,\n            **kwargs,\n        )\n\n        self._layers = {\n            **self._layers,\n            layer_id: {\n                \"id\": layer_id,\n                \"type\": \"cluster\",\n                \"source\": f\"{layer_id}-source\",\n            },\n        }\n        self._add_to_layer_dict(layer_id, \"Vector\")\n        return layer_id\n\n    def remove_cluster_layer(self, layer_id: str) -&gt; None:\n        \"\"\"Remove a cluster layer.\"\"\"\n        self._remove_layer_internal(layer_id, \"removeClusterLayer\")\n\n    def add_choropleth(\n        self,\n        data: Any,\n        column: str,\n        cmap: str = \"viridis\",\n        classification: str = \"quantile\",\n        k: int = 5,\n        breaks: Optional[List[float]] = None,\n        fill_opacity: float = 0.7,\n        line_color: str = \"#000000\",\n        line_width: float = 1,\n        legend: bool = True,\n        legend_title: Optional[str] = None,\n        hover: bool = True,\n        layer_id: Optional[str] = None,\n        fit_bounds: bool = True,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a choropleth (thematic) map layer.\"\"\"\n        from .utils import (\n            get_choropleth_colors,\n            compute_breaks,\n            build_step_expression,\n        )\n\n        layer_name = layer_id or f\"choropleth-{len(self._layers)}\"\n\n        geojson = to_geojson(data)\n\n        if geojson.get(\"type\") == \"url\":\n            url = geojson[\"url\"]\n            geojson = fetch_geojson(url)\n\n        features = geojson.get(\"features\", [])\n        values = []\n        for feature in features:\n            props = feature.get(\"properties\", {})\n            val = props.get(column)\n            if val is not None:\n                try:\n                    values.append(float(val))\n                except (TypeError, ValueError):\n                    pass\n\n        if not values:\n            raise ValueError(f\"No valid numeric values found for column '{column}'\")\n\n        computed_breaks = compute_breaks(values, classification, k, breaks)\n\n        colors = get_choropleth_colors(cmap, k)\n\n        step_expr = build_step_expression(column, computed_breaks, colors)\n\n        bounds = get_bounds(geojson) if fit_bounds else None\n\n        self.call_js_method(\n            \"addChoropleth\",\n            data=geojson,\n            name=layer_name,\n            column=column,\n            stepExpression=step_expr,\n            fillOpacity=fill_opacity,\n            lineColor=line_color,\n            lineWidth=line_width,\n            hover=hover,\n            fitBounds=fit_bounds,\n            bounds=bounds,\n            **kwargs,\n        )\n\n        self._layers = {\n            **self._layers,\n            layer_name: {\n                \"id\": layer_name,\n                \"type\": \"choropleth\",\n                \"source\": f\"{layer_name}-source\",\n                \"column\": column,\n            },\n        }\n        self._add_to_layer_dict(layer_name, \"Vector\")\n\n        if legend:\n            title = legend_title or column\n            labels = []\n            for i in range(len(computed_breaks) - 1):\n                low = computed_breaks[i]\n                high = computed_breaks[i + 1]\n                labels.append(f\"{low:.1f} - {high:.1f}\")\n\n            self.add_legend(\n                title=title,\n                labels=labels,\n                colors=colors,\n                position=\"bottom-right\",\n            )\n\n    def add_3d_buildings(\n        self,\n        source: str = \"openmaptiles\",\n        min_zoom: float = 14,\n        fill_extrusion_color: str = \"#aaa\",\n        fill_extrusion_opacity: float = 0.6,\n        height_property: str = \"render_height\",\n        base_property: str = \"render_min_height\",\n        layer_id: Optional[str] = None,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add 3D building extrusions from vector tiles.\"\"\"\n        layer_name = layer_id or \"3d-buildings\"\n\n        self.call_js_method(\n            \"add3DBuildings\",\n            source=source,\n            minZoom=min_zoom,\n            fillExtrusionColor=fill_extrusion_color,\n            fillExtrusionOpacity=fill_extrusion_opacity,\n            heightProperty=height_property,\n            baseProperty=base_property,\n            layerId=layer_name,\n            **kwargs,\n        )\n\n        self._layers = {\n            **self._layers,\n            layer_name: {\n                \"id\": layer_name,\n                \"type\": \"fill-extrusion\",\n            },\n        }\n        self._add_to_layer_dict(layer_name, \"Vector\")\n\n    def animate_along_route(\n        self,\n        route: Any,\n        duration: int = 10000,\n        loop: bool = True,\n        marker_color: str = \"#3388ff\",\n        marker_size: float = 1.0,\n        show_trail: bool = False,\n        trail_color: str = \"#3388ff\",\n        trail_width: float = 3,\n        animation_id: Optional[str] = None,\n        **kwargs,\n    ) -&gt; str:\n        \"\"\"Animate a marker along a route.\"\"\"\n        anim_id = animation_id or f\"animation-{len(self._layers)}\"\n\n        if isinstance(route, list) and len(route) &gt; 0:\n            if isinstance(route[0], (list, tuple)):\n                coordinates = route\n            else:\n                raise ValueError(\"Route list must contain coordinate pairs\")\n        elif isinstance(route, dict):\n            if route.get(\"type\") == \"LineString\":\n                coordinates = route.get(\"coordinates\", [])\n            elif route.get(\"type\") == \"Feature\":\n                geometry = route.get(\"geometry\", {})\n                if geometry.get(\"type\") == \"LineString\":\n                    coordinates = geometry.get(\"coordinates\", [])\n                else:\n                    raise ValueError(\"Feature geometry must be LineString\")\n            elif route.get(\"type\") == \"FeatureCollection\":\n                features = route.get(\"features\", [])\n                if (\n                    features\n                    and features[0].get(\"geometry\", {}).get(\"type\") == \"LineString\"\n                ):\n                    coordinates = features[0][\"geometry\"][\"coordinates\"]\n                else:\n                    raise ValueError(\n                        \"FeatureCollection must contain LineString features\"\n                    )\n            else:\n                raise ValueError(\n                    \"GeoJSON must be LineString, Feature, or FeatureCollection\"\n                )\n        else:\n            geojson = to_geojson(route)\n            if geojson.get(\"type\") == \"url\":\n                geojson = fetch_geojson(geojson[\"url\"])\n            if geojson.get(\"type\") == \"FeatureCollection\":\n                features = geojson.get(\"features\", [])\n                if features:\n                    coordinates = features[0].get(\"geometry\", {}).get(\"coordinates\", [])\n                else:\n                    raise ValueError(\"No features found in data\")\n            elif geojson.get(\"type\") == \"Feature\":\n                coordinates = geojson.get(\"geometry\", {}).get(\"coordinates\", [])\n            else:\n                coordinates = geojson.get(\"coordinates\", [])\n\n        if len(coordinates) &lt; 2:\n            raise ValueError(\"Route must have at least 2 points\")\n\n        self.call_js_method(\n            \"animateAlongRoute\",\n            id=anim_id,\n            coordinates=coordinates,\n            duration=duration,\n            loop=loop,\n            markerColor=marker_color,\n            markerSize=marker_size,\n            showTrail=show_trail,\n            trailColor=trail_color,\n            trailWidth=trail_width,\n            **kwargs,\n        )\n\n        self._layers = {\n            **self._layers,\n            anim_id: {\n                \"id\": anim_id,\n                \"type\": \"animation\",\n            },\n        }\n        return anim_id\n\n    def stop_animation(self, animation_id: str) -&gt; None:\n        \"\"\"Stop a running animation.\"\"\"\n        self.call_js_method(\"stopAnimation\", animation_id)\n        if animation_id in self._layers:\n            layers = dict(self._layers)\n            del layers[animation_id]\n            self._layers = layers\n\n    def pause_animation(self, animation_id: str) -&gt; None:\n        \"\"\"Pause a running animation.\"\"\"\n        self.call_js_method(\"pauseAnimation\", animation_id)\n\n    def resume_animation(self, animation_id: str) -&gt; None:\n        \"\"\"Resume a paused animation.\"\"\"\n        self.call_js_method(\"resumeAnimation\", animation_id)\n\n    def set_animation_speed(self, animation_id: str, speed: float) -&gt; None:\n        \"\"\"Set animation speed multiplier.\"\"\"\n        self.call_js_method(\"setAnimationSpeed\", animation_id, speed)\n\n    def add_hover_effect(\n        self,\n        layer_id: str,\n        highlight_color: Optional[str] = None,\n        highlight_opacity: Optional[float] = None,\n        highlight_outline_width: float = 2,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add hover highlight effect to an existing layer.\"\"\"\n        self.call_js_method(\n            \"addHoverEffect\",\n            layerId=layer_id,\n            highlightColor=highlight_color,\n            highlightOpacity=highlight_opacity,\n            highlightOutlineWidth=highlight_outline_width,\n            **kwargs,\n        )\n\n    def set_fog(\n        self,\n        color: Optional[str] = None,\n        high_color: Optional[str] = None,\n        low_color: Optional[str] = None,\n        horizon_blend: Optional[float] = None,\n        range: Optional[List[float]] = None,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Set fog atmospheric effect (Mapbox uses map.setFog() API).\"\"\"\n        self.call_js_method(\n            \"setFog\",\n            color=color,\n            highColor=high_color,\n            lowColor=low_color,\n            horizonBlend=horizon_blend,\n            range=range,\n            **kwargs,\n        )\n\n    def remove_fog(self) -&gt; None:\n        \"\"\"Remove fog atmospheric effects from the map.\"\"\"\n        self.call_js_method(\"removeFog\")\n\n    def add_image_layer(\n        self,\n        url: str,\n        coordinates: List[List[float]],\n        name: Optional[str] = None,\n        opacity: float = 1.0,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a georeferenced image overlay.\"\"\"\n        self._validate_opacity(opacity)\n        layer_id = name or f\"image-{len(self._layers)}\"\n\n        if len(coordinates) != 4:\n            raise ValueError(\n                \"coordinates must have exactly 4 corner points \"\n                \"[top-left, top-right, bottom-right, bottom-left]\"\n            )\n\n        self.call_js_method(\n            \"addImageLayer\",\n            id=layer_id,\n            url=url,\n            coordinates=coordinates,\n            opacity=opacity,\n            **kwargs,\n        )\n\n        self._layers = {\n            **self._layers,\n            layer_id: {\n                \"id\": layer_id,\n                \"type\": \"image\",\n                \"url\": url,\n                \"coordinates\": coordinates,\n            },\n        }\n        self._add_to_layer_dict(layer_id, \"Raster\")\n\n    def add_video_layer(\n        self,\n        urls: List[str],\n        coordinates: List[List[float]],\n        name: Optional[str] = None,\n        opacity: float = 1.0,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a georeferenced video overlay on the map.\"\"\"\n        self._validate_opacity(opacity)\n        layer_id = name or f\"video-{len(self._layers)}\"\n\n        if len(coordinates) != 4:\n            raise ValueError(\n                \"coordinates must have exactly 4 corner points \"\n                \"[top-left, top-right, bottom-right, bottom-left]\"\n            )\n\n        self.call_js_method(\n            \"addVideoLayer\",\n            id=layer_id,\n            urls=urls,\n            coordinates=coordinates,\n            opacity=opacity,\n            **kwargs,\n        )\n\n        self._layers = {\n            **self._layers,\n            layer_id: {\n                \"id\": layer_id,\n                \"type\": \"video\",\n                \"source\": f\"{layer_id}-source\",\n            },\n        }\n        self._add_to_layer_dict(layer_id, \"Raster\")\n\n    def remove_video_layer(self, name: str) -&gt; None:\n        \"\"\"Remove a video layer from the map.\"\"\"\n        if name in self._layers:\n            layers = dict(self._layers)\n            del layers[name]\n            self._layers = layers\n        self._remove_from_layer_dict(name)\n        self.call_js_method(\"removeVideoLayer\", id=name)\n\n    def play_video(self, name: str) -&gt; None:\n        \"\"\"Start playing a video layer.\"\"\"\n        self.call_js_method(\"playVideo\", id=name)\n\n    def pause_video(self, name: str) -&gt; None:\n        \"\"\"Pause a video layer.\"\"\"\n        self.call_js_method(\"pauseVideo\", id=name)\n\n    def seek_video(self, name: str, time: float) -&gt; None:\n        \"\"\"Seek to a specific time in a video layer.\"\"\"\n        self.call_js_method(\"seekVideo\", id=name, time=time)\n\n    def add_split_map(\n        self,\n        left_layer: str,\n        right_layer: str,\n        position: int = 50,\n    ) -&gt; None:\n        \"\"\"Add a split map comparison view with a draggable divider.\"\"\"\n        if not 0 &lt;= position &lt;= 100:\n            raise ValueError(f\"position must be between 0 and 100, got {position}\")\n\n        self.call_js_method(\n            \"addSplitMap\",\n            leftLayer=left_layer,\n            rightLayer=right_layer,\n            position=position,\n        )\n\n    def remove_split_map(self) -&gt; None:\n        \"\"\"Remove the split map comparison view.\"\"\"\n        self.call_js_method(\"removeSplitMap\")\n\n    def set_projection(self, projection: str = \"mercator\") -&gt; None:\n        \"\"\"Set the map projection (Mapbox supports 'globe' and 'mercator').\"\"\"\n        self.call_js_method(\"setProjection\", projection=projection)\n\n    def update_geojson_source(self, source_id: str, data: Any) -&gt; None:\n        \"\"\"Update the data of an existing GeoJSON source in place.\"\"\"\n        processed_data = self._process_deck_data(data)\n        self.call_js_method(\n            \"updateGeoJSONSource\",\n            sourceId=source_id,\n            data=processed_data,\n        )\n\n    def add_image(self, name: str, url: str) -&gt; None:\n        \"\"\"Load a custom icon image for use in symbol layers.\"\"\"\n        self.call_js_method(\"addMapImage\", name=name, url=url)\n\n    def add_swipe_map(self, left_layer: str, right_layer: str) -&gt; None:\n        \"\"\"Add a drag-to-compare swipe control for two layers.\"\"\"\n        self.call_js_method(\n            \"addSwipeMap\",\n            leftLayer=left_layer,\n            rightLayer=right_layer,\n        )\n\n    def remove_swipe_map(self) -&gt; None:\n        \"\"\"Remove the swipe map comparison control.\"\"\"\n        self.call_js_method(\"removeSwipeMap\")\n\n    def set_filter(\n        self,\n        layer_id: str,\n        filter_expression: Optional[List] = None,\n    ) -&gt; None:\n        \"\"\"Set or clear a filter on a map layer.\"\"\"\n        self.call_js_method(\n            \"setFilter\",\n            layerId=layer_id,\n            filter=filter_expression,\n        )\n\n    def query_rendered_features(\n        self,\n        geometry: Optional[Any] = None,\n        layers: Optional[List[str]] = None,\n        filter_expression: Optional[List] = None,\n    ) -&gt; Dict:\n        \"\"\"Query features currently rendered on the map.\"\"\"\n        kwargs: Dict[str, Any] = {}\n        if geometry is not None:\n            kwargs[\"geometry\"] = geometry\n        if layers is not None:\n            kwargs[\"layers\"] = layers\n        if filter_expression is not None:\n            kwargs[\"filter\"] = filter_expression\n\n        self.call_js_method(\"queryRenderedFeatures\", **kwargs)\n        return self._queried_features\n\n    def query_source_features(\n        self,\n        source_id: str,\n        source_layer: Optional[str] = None,\n        filter_expression: Optional[List] = None,\n    ) -&gt; Dict:\n        \"\"\"Query features from a source.\"\"\"\n        kwargs: Dict[str, Any] = {\"sourceId\": source_id}\n        if source_layer is not None:\n            kwargs[\"sourceLayer\"] = source_layer\n        if filter_expression is not None:\n            kwargs[\"filter\"] = filter_expression\n\n        self.call_js_method(\"querySourceFeatures\", **kwargs)\n        return self._queried_features\n\n    @property\n    def queried_features(self) -&gt; Dict:\n        \"\"\"Get the most recent query results.\"\"\"\n        return self._queried_features\n\n    def get_visible_features(\n        self,\n        layers: Optional[List[str]] = None,\n    ) -&gt; Optional[Dict]:\n        \"\"\"Get all features currently visible in the viewport.\"\"\"\n        if layers is not None:\n            self.call_js_method(\"getVisibleFeatures\", layers=layers)\n        features = self._queried_features\n        if features and \"data\" in features:\n            return features[\"data\"]\n        return None\n\n    def to_geojson(self, layer_id: Optional[str] = None) -&gt; Optional[Dict]:\n        \"\"\"Get layer data as GeoJSON.\"\"\"\n        if layer_id:\n            self.call_js_method(\"getLayerData\", sourceId=layer_id)\n        features = self._queried_features\n        if features and \"data\" in features:\n            return features[\"data\"]\n        return None\n\n    def to_geopandas(self, layer_id: Optional[str] = None) -&gt; Any:\n        \"\"\"Get layer data as a GeoDataFrame.\"\"\"\n        geojson = self.to_geojson(layer_id)\n        if geojson is None:\n            return None\n        try:\n            import geopandas as gpd\n\n            return gpd.GeoDataFrame.from_features(geojson.get(\"features\", []))\n        except ImportError:\n            raise ImportError(\"geopandas is required for to_geopandas()\")\n\n    # -------------------------------------------------------------------------\n    # Markers\n    # -------------------------------------------------------------------------\n\n    def add_marker(\n        self,\n        lng: float,\n        lat: float,\n        popup: Optional[str] = None,\n        tooltip: Optional[str] = None,\n        color: str = \"#3388ff\",\n        draggable: bool = False,\n        scale: float = 1.0,\n        popup_max_width: str = \"240px\",\n        tooltip_max_width: str = \"240px\",\n        name: Optional[str] = None,\n        **kwargs,\n    ) -&gt; str:\n        \"\"\"Add a single marker to the map.\"\"\"\n        marker_id = name or f\"marker-{len(self._layers)}\"\n\n        self.call_js_method(\n            \"addMarker\",\n            lng,\n            lat,\n            id=marker_id,\n            popup=popup,\n            tooltip=tooltip,\n            color=color,\n            draggable=draggable,\n            scale=scale,\n            popupMaxWidth=popup_max_width,\n            tooltipMaxWidth=tooltip_max_width,\n            **kwargs,\n        )\n\n        self._layers = {\n            **self._layers,\n            marker_id: {\n                \"id\": marker_id,\n                \"type\": \"marker\",\n                \"lngLat\": [lng, lat],\n            },\n        }\n        self._add_to_layer_dict(marker_id, \"Markers\")\n        return marker_id\n\n    def add_markers(\n        self,\n        data: Any,\n        lng_column: Optional[str] = None,\n        lat_column: Optional[str] = None,\n        popup_column: Optional[str] = None,\n        tooltip_column: Optional[str] = None,\n        color: str = \"#3388ff\",\n        scale: float = 1.0,\n        popup_max_width: str = \"240px\",\n        tooltip_max_width: str = \"240px\",\n        draggable: bool = False,\n        name: Optional[str] = None,\n        **kwargs,\n    ) -&gt; str:\n        \"\"\"Add multiple markers from data.\"\"\"\n        layer_id = name or f\"markers-{len(self._layers)}\"\n        markers = []\n\n        if hasattr(data, \"geometry\"):\n            for _, row in data.iterrows():\n                geom = row.geometry\n                if geom.geom_type == \"Point\":\n                    marker = {\"lngLat\": [geom.x, geom.y]}\n                    if popup_column and popup_column in row:\n                        marker[\"popup\"] = str(row[popup_column])\n                    if tooltip_column and tooltip_column in row:\n                        marker[\"tooltip\"] = str(row[tooltip_column])\n                    markers.append(marker)\n        elif isinstance(data, dict) and data.get(\"type\") == \"FeatureCollection\":\n            for feature in data.get(\"features\", []):\n                geom = feature.get(\"geometry\", {})\n                if geom.get(\"type\") == \"Point\":\n                    coords = geom.get(\"coordinates\", [])\n                    marker = {\"lngLat\": coords[:2]}\n                    props = feature.get(\"properties\", {})\n                    if popup_column and popup_column in props:\n                        marker[\"popup\"] = str(props[popup_column])\n                    if tooltip_column and tooltip_column in props:\n                        marker[\"tooltip\"] = str(props[tooltip_column])\n                    markers.append(marker)\n        elif isinstance(data, list):\n            lng_keys = [\"lng\", \"lon\", \"longitude\", \"x\"]\n            lat_keys = [\"lat\", \"latitude\", \"y\"]\n\n            for item in data:\n                if not isinstance(item, dict):\n                    continue\n\n                lng_val = None\n                lat_val = None\n\n                if lng_column and lng_column in item:\n                    lng_val = item[lng_column]\n                else:\n                    for key in lng_keys:\n                        if key in item:\n                            lng_val = item[key]\n                            break\n\n                if lat_column and lat_column in item:\n                    lat_val = item[lat_column]\n                else:\n                    for key in lat_keys:\n                        if key in item:\n                            lat_val = item[key]\n                            break\n\n                if lng_val is not None and lat_val is not None:\n                    marker = {\"lngLat\": [float(lng_val), float(lat_val)]}\n                    if popup_column and popup_column in item:\n                        marker[\"popup\"] = str(item[popup_column])\n                    if tooltip_column and tooltip_column in item:\n                        marker[\"tooltip\"] = str(item[tooltip_column])\n                    markers.append(marker)\n\n        if not markers:\n            raise ValueError(\"No valid point data found in input\")\n\n        self.call_js_method(\n            \"addMarkers\",\n            id=layer_id,\n            markers=markers,\n            color=color,\n            scale=scale,\n            popupMaxWidth=popup_max_width,\n            tooltipMaxWidth=tooltip_max_width,\n            draggable=draggable,\n            **kwargs,\n        )\n\n        self._layers = {\n            **self._layers,\n            layer_id: {\n                \"id\": layer_id,\n                \"type\": \"markers\",\n                \"count\": len(markers),\n            },\n        }\n        self._add_to_layer_dict(layer_id, \"Markers\")\n        return layer_id\n\n    def remove_marker(self, marker_id: str) -&gt; None:\n        \"\"\"Remove a marker from the map.\"\"\"\n        self._remove_layer_internal(marker_id, \"removeMarker\")\n\n    # -------------------------------------------------------------------------\n    # HTML Export\n    # -------------------------------------------------------------------------\n\n    def _generate_html_template(self) -&gt; str:\n        \"\"\"Generate standalone HTML for the map.\"\"\"\n        template_path = Path(__file__).parent / \"templates\" / \"mapbox.html\"\n\n        if template_path.exists():\n            template = template_path.read_text(encoding=\"utf-8\")\n        else:\n            template = self._get_default_template()\n\n        # Serialize state\n        state = {\n            \"center\": self.center,\n            \"zoom\": self.zoom,\n            \"style\": self.style,\n            \"bearing\": self.bearing,\n            \"pitch\": self.pitch,\n            \"width\": self.width,\n            \"height\": self.height,\n            \"layers\": self._layers,\n            \"sources\": self._sources,\n            \"controls\": self._controls,\n            \"js_calls\": self._js_calls,\n            \"access_token\": self.access_token,\n        }\n\n        template = template.replace(\"{{state}}\", json.dumps(state, indent=2))\n        return template\n\n    def _get_default_template(self) -&gt; str:\n        \"\"\"Get default HTML template.\"\"\"\n        return \"\"\"&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n    &lt;meta charset=\"utf-8\"&gt;\n    &lt;title&gt;{{title}}&lt;/title&gt;\n    &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"&gt;\n    &lt;script src=\"https://api.mapbox.com/mapbox-gl-js/v3.0.0/mapbox-gl.js\"&gt;&lt;/script&gt;\n    &lt;link href=\"https://api.mapbox.com/mapbox-gl-js/v3.0.0/mapbox-gl.css\" rel=\"stylesheet\" /&gt;\n    &lt;style&gt;\n        body { margin: 0; padding: 0; }\n        #map { position: absolute; top: 0; bottom: 0; width: 100%; }\n    &lt;/style&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;div id=\"map\"&gt;&lt;/div&gt;\n    &lt;script&gt;\n        const state = {{state}};\n\n        mapboxgl.accessToken = state.access_token;\n\n        const map = new mapboxgl.Map({\n            container: 'map',\n            style: state.style,\n            center: state.center,\n            zoom: state.zoom,\n            bearing: state.bearing || 0,\n            pitch: state.pitch || 0\n        });\n\n        map.on('load', function() {\n            // Replay JS calls\n            for (const call of state.js_calls || []) {\n                try {\n                    executeMethod(call.method, call.args, call.kwargs);\n                } catch (e) {\n                    console.error('Error executing', call.method, e);\n                }\n            }\n        });\n\n        function executeMethod(method, args, kwargs) {\n            switch (method) {\n                case 'addBasemap':\n                    const url = args[0];\n                    const name = kwargs.name || 'basemap';\n                    const sourceId = 'basemap-' + name;\n                    if (!map.getSource(sourceId)) {\n                        map.addSource(sourceId, {\n                            type: 'raster',\n                            tiles: [url],\n                            tileSize: 256,\n                            attribution: kwargs.attribution || ''\n                        });\n                    }\n                    if (!map.getLayer(sourceId)) {\n                        map.addLayer({\n                            id: sourceId,\n                            type: 'raster',\n                            source: sourceId\n                        });\n                    }\n                    break;\n\n                case 'addGeoJSON':\n                    const layerName = kwargs.name;\n                    const sourceIdGeo = layerName + '-source';\n                    if (!map.getSource(sourceIdGeo)) {\n                        map.addSource(sourceIdGeo, {\n                            type: 'geojson',\n                            data: kwargs.data\n                        });\n                    }\n                    if (!map.getLayer(layerName)) {\n                        map.addLayer({\n                            id: layerName,\n                            type: kwargs.layerType || 'circle',\n                            source: sourceIdGeo,\n                            paint: kwargs.paint || {}\n                        });\n                    }\n                    if (kwargs.fitBounds &amp;&amp; kwargs.bounds) {\n                        map.fitBounds([\n                            [kwargs.bounds[0], kwargs.bounds[1]],\n                            [kwargs.bounds[2], kwargs.bounds[3]]\n                        ], { padding: 50 });\n                    }\n                    break;\n\n                case 'addTileLayer':\n                    const tileUrl = args[0];\n                    const tileName = kwargs.name;\n                    const tileSourceId = tileName + '-source';\n                    if (!map.getSource(tileSourceId)) {\n                        map.addSource(tileSourceId, {\n                            type: 'raster',\n                            tiles: [tileUrl],\n                            tileSize: 256,\n                            attribution: kwargs.attribution || ''\n                        });\n                    }\n                    if (!map.getLayer(tileName)) {\n                        map.addLayer({\n                            id: tileName,\n                            type: 'raster',\n                            source: tileSourceId\n                        });\n                    }\n                    break;\n\n                case 'addControl':\n                    const controlType = args[0];\n                    const position = kwargs.position || 'top-right';\n                    let control;\n                    switch (controlType) {\n                        case 'navigation':\n                            control = new mapboxgl.NavigationControl();\n                            break;\n                        case 'scale':\n                            control = new mapboxgl.ScaleControl();\n                            break;\n                        case 'fullscreen':\n                            control = new mapboxgl.FullscreenControl();\n                            break;\n                    }\n                    if (control) {\n                        map.addControl(control, position);\n                    }\n                    break;\n\n                case 'addTerrain':\n                    const terrainSource = kwargs.source || 'mapbox-dem';\n                    if (!map.getSource(terrainSource)) {\n                        map.addSource(terrainSource, {\n                            type: 'raster-dem',\n                            url: 'mapbox://mapbox.mapbox-terrain-dem-v1',\n                            tileSize: 512,\n                            maxzoom: 14\n                        });\n                    }\n                    map.setTerrain({ source: terrainSource, exaggeration: kwargs.exaggeration || 1 });\n                    break;\n\n                case 'removeTerrain':\n                    map.setTerrain(null);\n                    break;\n\n                case 'flyTo':\n                    map.flyTo({\n                        center: [args[0], args[1]],\n                        zoom: kwargs.zoom,\n                        duration: kwargs.duration || 2000\n                    });\n                    break;\n\n                case 'fitBounds':\n                    const bounds = args[0];\n                    map.fitBounds([\n                        [bounds[0], bounds[1]],\n                        [bounds[2], bounds[3]]\n                    ], {\n                        padding: kwargs.padding || 50,\n                        duration: kwargs.duration || 1000\n                    });\n                    break;\n\n                case 'addMarker':\n                    new mapboxgl.Marker({ color: kwargs.color || '#3388ff' })\n                        .setLngLat([args[0], args[1]])\n                        .addTo(map);\n                    break;\n\n                default:\n                    console.log('Unknown method:', method);\n            }\n        }\n    &lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\"\"\"\n</code></pre>"},{"location":"mapbox/#anymap_ts.mapbox.MapboxMap.draw_data","title":"<code>draw_data: Dict</code>  <code>property</code> <code>readonly</code>","text":"<p>Property to access current draw data.</p>"},{"location":"mapbox/#anymap_ts.mapbox.MapboxMap.queried_features","title":"<code>queried_features: Dict</code>  <code>property</code> <code>readonly</code>","text":"<p>Get the most recent query results.</p>"},{"location":"mapbox/#anymap_ts.mapbox.MapboxMap.__init__","title":"<code>__init__(self, center=(0.0, 0.0), zoom=2.0, width='100%', height='600px', style='mapbox://styles/mapbox/streets-v12', bearing=0.0, pitch=0.0, max_pitch=85.0, access_token=None, controls=None, **kwargs)</code>  <code>special</code>","text":"<p>Initialize a Mapbox map.</p> <p>Parameters:</p> Name Type Description Default <code>center</code> <code>Tuple[float, float]</code> <p>Map center as (longitude, latitude).</p> <code>(0.0, 0.0)</code> <code>zoom</code> <code>float</code> <p>Initial zoom level.</p> <code>2.0</code> <code>width</code> <code>str</code> <p>Map width as CSS string.</p> <code>'100%'</code> <code>height</code> <code>str</code> <p>Map height as CSS string.</p> <code>'600px'</code> <code>style</code> <code>str</code> <p>Mapbox style URL (e.g., \"mapbox://styles/mapbox/streets-v12\").</p> <code>'mapbox://styles/mapbox/streets-v12'</code> <code>bearing</code> <code>float</code> <p>Map bearing in degrees.</p> <code>0.0</code> <code>pitch</code> <code>float</code> <p>Map pitch in degrees.</p> <code>0.0</code> <code>max_pitch</code> <code>float</code> <p>Maximum pitch angle in degrees (default: 85).</p> <code>85.0</code> <code>access_token</code> <code>Optional[str]</code> <p>Mapbox access token. If None, reads from MAPBOX_TOKEN env var.</p> <code>None</code> <code>controls</code> <code>Optional[Dict[str, Any]]</code> <p>Dict of controls to add (e.g., {\"navigation\": True}).</p> <code>None</code> <code>**kwargs</code> <p>Additional widget arguments.</p> <code>{}</code> Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def __init__(\n    self,\n    center: Tuple[float, float] = (0.0, 0.0),\n    zoom: float = 2.0,\n    width: str = \"100%\",\n    height: str = \"600px\",\n    style: str = \"mapbox://styles/mapbox/streets-v12\",\n    bearing: float = 0.0,\n    pitch: float = 0.0,\n    max_pitch: float = 85.0,\n    access_token: Optional[str] = None,\n    controls: Optional[Dict[str, Any]] = None,\n    **kwargs,\n):\n    \"\"\"Initialize a Mapbox map.\n\n    Args:\n        center: Map center as (longitude, latitude).\n        zoom: Initial zoom level.\n        width: Map width as CSS string.\n        height: Map height as CSS string.\n        style: Mapbox style URL (e.g., \"mapbox://styles/mapbox/streets-v12\").\n        bearing: Map bearing in degrees.\n        pitch: Map pitch in degrees.\n        max_pitch: Maximum pitch angle in degrees (default: 85).\n        access_token: Mapbox access token. If None, reads from MAPBOX_TOKEN env var.\n        controls: Dict of controls to add (e.g., {\"navigation\": True}).\n        **kwargs: Additional widget arguments.\n    \"\"\"\n    # Get access token\n    token = access_token or get_mapbox_token()\n    if not token:\n        print(\n            \"Warning: No Mapbox access token provided. \"\n            \"Set MAPBOX_TOKEN environment variable or pass access_token parameter.\"\n        )\n\n    super().__init__(\n        center=list(center),\n        zoom=zoom,\n        width=width,\n        height=height,\n        style=style,\n        bearing=bearing,\n        pitch=pitch,\n        max_pitch=max_pitch,\n        access_token=token,\n        **kwargs,\n    )\n\n    # Initialize layer dictionary\n    self._layer_dict = {\"Background\": []}\n\n    # Add default controls\n    if controls is None:\n        controls = {\"navigation\": True, \"fullscreen\": True}\n\n    for control_name, config in controls.items():\n        if config:\n            self.add_control(\n                control_name, **(config if isinstance(config, dict) else {})\n            )\n</code></pre>"},{"location":"mapbox/#anymap_ts.mapbox.MapboxMap.add_3d_buildings","title":"<code>add_3d_buildings(self, source='openmaptiles', min_zoom=14, fill_extrusion_color='#aaa', fill_extrusion_opacity=0.6, height_property='render_height', base_property='render_min_height', layer_id=None, **kwargs)</code>","text":"<p>Add 3D building extrusions from vector tiles.</p> Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def add_3d_buildings(\n    self,\n    source: str = \"openmaptiles\",\n    min_zoom: float = 14,\n    fill_extrusion_color: str = \"#aaa\",\n    fill_extrusion_opacity: float = 0.6,\n    height_property: str = \"render_height\",\n    base_property: str = \"render_min_height\",\n    layer_id: Optional[str] = None,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add 3D building extrusions from vector tiles.\"\"\"\n    layer_name = layer_id or \"3d-buildings\"\n\n    self.call_js_method(\n        \"add3DBuildings\",\n        source=source,\n        minZoom=min_zoom,\n        fillExtrusionColor=fill_extrusion_color,\n        fillExtrusionOpacity=fill_extrusion_opacity,\n        heightProperty=height_property,\n        baseProperty=base_property,\n        layerId=layer_name,\n        **kwargs,\n    )\n\n    self._layers = {\n        **self._layers,\n        layer_name: {\n            \"id\": layer_name,\n            \"type\": \"fill-extrusion\",\n        },\n    }\n    self._add_to_layer_dict(layer_name, \"Vector\")\n</code></pre>"},{"location":"mapbox/#anymap_ts.mapbox.MapboxMap.add_3d_terrain","title":"<code>add_3d_terrain(self, exaggeration=1.0, source='mapbox-dem', **kwargs)</code>","text":"<p>Alias for add_terrain for MapLibre compatibility.</p> Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def add_3d_terrain(\n    self, exaggeration: float = 1.0, source: str = \"mapbox-dem\", **kwargs\n) -&gt; None:\n    \"\"\"Alias for add_terrain for MapLibre compatibility.\"\"\"\n    self.add_terrain(exaggeration=exaggeration, source=source)\n</code></pre>"},{"location":"mapbox/#anymap_ts.mapbox.MapboxMap.add_arc_layer","title":"<code>add_arc_layer(self, data, name=None, get_source_position='source', get_target_position='target', get_source_color=None, get_target_color=None, get_width=1, get_height=1, great_circle=False, pickable=True, opacity=0.8, **kwargs)</code>","text":"<p>Add an arc layer for origin-destination visualization using deck.gl.</p> <p>Arc layers are ideal for visualizing connections between locations, such as flight routes, migration patterns, or network flows.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>Array of data objects with source/target coordinates. Each object should have source and target positions.</p> required <code>name</code> <code>Optional[str]</code> <p>Layer ID. If None, auto-generated.</p> <code>None</code> <code>get_source_position</code> <code>Union[str, Any]</code> <p>Accessor for source position [lng, lat]. Can be a string (property name) or a value.</p> <code>'source'</code> <code>get_target_position</code> <code>Union[str, Any]</code> <p>Accessor for target position [lng, lat]. Can be a string (property name) or a value.</p> <code>'target'</code> <code>get_source_color</code> <code>Optional[List[int]]</code> <p>Source end color as [r, g, b, a]. Default: [51, 136, 255, 255] (blue).</p> <code>None</code> <code>get_target_color</code> <code>Optional[List[int]]</code> <p>Target end color as [r, g, b, a]. Default: [255, 136, 51, 255] (orange).</p> <code>None</code> <code>get_width</code> <code>Union[float, str]</code> <p>Arc width in pixels. Can be a number or accessor.</p> <code>1</code> <code>get_height</code> <code>float</code> <p>Arc height multiplier. Higher values create more curved arcs.</p> <code>1</code> <code>great_circle</code> <code>bool</code> <p>Whether to draw arcs along great circles.</p> <code>False</code> <code>pickable</code> <code>bool</code> <p>Whether layer responds to hover/click events.</p> <code>True</code> <code>opacity</code> <code>float</code> <p>Layer opacity (0-1).</p> <code>0.8</code> <code>**kwargs</code> <p>Additional ArcLayer props.</p> <code>{}</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from anymap_ts import MapboxMap\n&gt;&gt;&gt; m = MapboxMap()\n&gt;&gt;&gt; arcs = [\n...     {\"source\": [-122.4, 37.8], \"target\": [-73.9, 40.7]},\n...     {\"source\": [-122.4, 37.8], \"target\": [-0.1, 51.5]},\n... ]\n&gt;&gt;&gt; m.add_arc_layer(arcs, name=\"flights\")\n</code></pre> Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def add_arc_layer(\n    self,\n    data: Any,\n    name: Optional[str] = None,\n    get_source_position: Union[str, Any] = \"source\",\n    get_target_position: Union[str, Any] = \"target\",\n    get_source_color: Optional[List[int]] = None,\n    get_target_color: Optional[List[int]] = None,\n    get_width: Union[float, str] = 1,\n    get_height: float = 1,\n    great_circle: bool = False,\n    pickable: bool = True,\n    opacity: float = 0.8,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add an arc layer for origin-destination visualization using deck.gl.\n\n    Arc layers are ideal for visualizing connections between locations,\n    such as flight routes, migration patterns, or network flows.\n\n    Args:\n        data: Array of data objects with source/target coordinates.\n            Each object should have source and target positions.\n        name: Layer ID. If None, auto-generated.\n        get_source_position: Accessor for source position [lng, lat].\n            Can be a string (property name) or a value.\n        get_target_position: Accessor for target position [lng, lat].\n            Can be a string (property name) or a value.\n        get_source_color: Source end color as [r, g, b, a].\n            Default: [51, 136, 255, 255] (blue).\n        get_target_color: Target end color as [r, g, b, a].\n            Default: [255, 136, 51, 255] (orange).\n        get_width: Arc width in pixels. Can be a number or accessor.\n        get_height: Arc height multiplier. Higher values create more curved arcs.\n        great_circle: Whether to draw arcs along great circles.\n        pickable: Whether layer responds to hover/click events.\n        opacity: Layer opacity (0-1).\n        **kwargs: Additional ArcLayer props.\n\n    Example:\n        &gt;&gt;&gt; from anymap_ts import MapboxMap\n        &gt;&gt;&gt; m = MapboxMap()\n        &gt;&gt;&gt; arcs = [\n        ...     {\"source\": [-122.4, 37.8], \"target\": [-73.9, 40.7]},\n        ...     {\"source\": [-122.4, 37.8], \"target\": [-0.1, 51.5]},\n        ... ]\n        &gt;&gt;&gt; m.add_arc_layer(arcs, name=\"flights\")\n    \"\"\"\n    layer_id = name or f\"arc-{len(self._layers)}\"\n    processed_data = self._process_deck_data(data)\n\n    self.call_js_method(\n        \"addArcLayer\",\n        id=layer_id,\n        data=processed_data,\n        getSourcePosition=get_source_position,\n        getTargetPosition=get_target_position,\n        getSourceColor=get_source_color or [51, 136, 255, 255],\n        getTargetColor=get_target_color or [255, 136, 51, 255],\n        getWidth=get_width,\n        getHeight=get_height,\n        greatCircle=great_circle,\n        pickable=pickable,\n        opacity=opacity,\n        **kwargs,\n    )\n\n    self._layers = {\n        **self._layers,\n        layer_id: {\n            \"id\": layer_id,\n            \"type\": \"arc\",\n        },\n    }\n    self._add_to_layer_dict(layer_id, \"Deck.gl\")\n</code></pre>"},{"location":"mapbox/#anymap_ts.mapbox.MapboxMap.add_basemap","title":"<code>add_basemap(self, basemap='mapbox://styles/mapbox/streets-v12', attribution=None, **kwargs)</code>","text":"<p>Add a basemap layer.</p> <p>For Mapbox styles, use the style URL format: - \"mapbox://styles/mapbox/streets-v12\" - \"mapbox://styles/mapbox/satellite-v9\" - \"mapbox://styles/mapbox/satellite-streets-v12\" - \"mapbox://styles/mapbox/light-v11\" - \"mapbox://styles/mapbox/dark-v11\" - \"mapbox://styles/mapbox/outdoors-v12\"</p> <p>Or use XYZ tile URLs for custom basemaps.</p> <p>Parameters:</p> Name Type Description Default <code>basemap</code> <code>str</code> <p>Mapbox style URL or XYZ tile URL.</p> <code>'mapbox://styles/mapbox/streets-v12'</code> <code>attribution</code> <code>Optional[str]</code> <p>Custom attribution text.</p> <code>None</code> <code>**kwargs</code> <p>Additional options.</p> <code>{}</code> Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def add_basemap(\n    self,\n    basemap: str = \"mapbox://styles/mapbox/streets-v12\",\n    attribution: Optional[str] = None,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a basemap layer.\n\n    For Mapbox styles, use the style URL format:\n    - \"mapbox://styles/mapbox/streets-v12\"\n    - \"mapbox://styles/mapbox/satellite-v9\"\n    - \"mapbox://styles/mapbox/satellite-streets-v12\"\n    - \"mapbox://styles/mapbox/light-v11\"\n    - \"mapbox://styles/mapbox/dark-v11\"\n    - \"mapbox://styles/mapbox/outdoors-v12\"\n\n    Or use XYZ tile URLs for custom basemaps.\n\n    Args:\n        basemap: Mapbox style URL or XYZ tile URL.\n        attribution: Custom attribution text.\n        **kwargs: Additional options.\n    \"\"\"\n    # If it's a Mapbox style URL, set it as the map style\n    if basemap.startswith(\"mapbox://\"):\n        self.style = basemap\n        return\n\n    # Otherwise, treat as XYZ tile URL\n    try:\n        url, default_attribution = get_basemap_url(basemap)\n    except (ValueError, KeyError):\n        url = basemap\n        default_attribution = \"\"\n\n    self.call_js_method(\n        \"addBasemap\",\n        url,\n        attribution=attribution or default_attribution,\n        name=basemap,\n        **kwargs,\n    )\n\n    # Track in layer dict\n    basemaps = self._layer_dict.get(\"Basemaps\", [])\n    if basemap not in basemaps:\n        self._layer_dict = {\n            **self._layer_dict,\n            \"Basemaps\": basemaps + [basemap],\n        }\n</code></pre>"},{"location":"mapbox/#anymap_ts.mapbox.MapboxMap.add_bitmap_layer","title":"<code>add_bitmap_layer(self, image, bounds, name=None, opacity=1.0, visible=True, pickable=False, desaturate=0, transparent_color=None, tint_color=None, **kwargs)</code>","text":"<p>Add a bitmap layer using deck.gl.</p> Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def add_bitmap_layer(\n    self,\n    image: str,\n    bounds: List[float],\n    name: Optional[str] = None,\n    opacity: float = 1.0,\n    visible: bool = True,\n    pickable: bool = False,\n    desaturate: float = 0,\n    transparent_color: Optional[List[int]] = None,\n    tint_color: Optional[List[int]] = None,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a bitmap layer using deck.gl.\"\"\"\n    layer_id = name or f\"bitmap-{len(self._layers)}\"\n\n    self.call_js_method(\n        \"addBitmapLayer\",\n        id=layer_id,\n        image=image,\n        bounds=bounds,\n        opacity=opacity,\n        visible=visible,\n        pickable=pickable,\n        desaturate=desaturate,\n        transparentColor=transparent_color or [0, 0, 0, 0],\n        tintColor=tint_color or [255, 255, 255],\n        **kwargs,\n    )\n\n    self._layers = {**self._layers, layer_id: {\"id\": layer_id, \"type\": \"bitmap\"}}\n    self._add_to_layer_dict(layer_id, \"Deck.gl\")\n</code></pre>"},{"location":"mapbox/#anymap_ts.mapbox.MapboxMap.add_choropleth","title":"<code>add_choropleth(self, data, column, cmap='viridis', classification='quantile', k=5, breaks=None, fill_opacity=0.7, line_color='#000000', line_width=1, legend=True, legend_title=None, hover=True, layer_id=None, fit_bounds=True, **kwargs)</code>","text":"<p>Add a choropleth (thematic) map layer.</p> Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def add_choropleth(\n    self,\n    data: Any,\n    column: str,\n    cmap: str = \"viridis\",\n    classification: str = \"quantile\",\n    k: int = 5,\n    breaks: Optional[List[float]] = None,\n    fill_opacity: float = 0.7,\n    line_color: str = \"#000000\",\n    line_width: float = 1,\n    legend: bool = True,\n    legend_title: Optional[str] = None,\n    hover: bool = True,\n    layer_id: Optional[str] = None,\n    fit_bounds: bool = True,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a choropleth (thematic) map layer.\"\"\"\n    from .utils import (\n        get_choropleth_colors,\n        compute_breaks,\n        build_step_expression,\n    )\n\n    layer_name = layer_id or f\"choropleth-{len(self._layers)}\"\n\n    geojson = to_geojson(data)\n\n    if geojson.get(\"type\") == \"url\":\n        url = geojson[\"url\"]\n        geojson = fetch_geojson(url)\n\n    features = geojson.get(\"features\", [])\n    values = []\n    for feature in features:\n        props = feature.get(\"properties\", {})\n        val = props.get(column)\n        if val is not None:\n            try:\n                values.append(float(val))\n            except (TypeError, ValueError):\n                pass\n\n    if not values:\n        raise ValueError(f\"No valid numeric values found for column '{column}'\")\n\n    computed_breaks = compute_breaks(values, classification, k, breaks)\n\n    colors = get_choropleth_colors(cmap, k)\n\n    step_expr = build_step_expression(column, computed_breaks, colors)\n\n    bounds = get_bounds(geojson) if fit_bounds else None\n\n    self.call_js_method(\n        \"addChoropleth\",\n        data=geojson,\n        name=layer_name,\n        column=column,\n        stepExpression=step_expr,\n        fillOpacity=fill_opacity,\n        lineColor=line_color,\n        lineWidth=line_width,\n        hover=hover,\n        fitBounds=fit_bounds,\n        bounds=bounds,\n        **kwargs,\n    )\n\n    self._layers = {\n        **self._layers,\n        layer_name: {\n            \"id\": layer_name,\n            \"type\": \"choropleth\",\n            \"source\": f\"{layer_name}-source\",\n            \"column\": column,\n        },\n    }\n    self._add_to_layer_dict(layer_name, \"Vector\")\n\n    if legend:\n        title = legend_title or column\n        labels = []\n        for i in range(len(computed_breaks) - 1):\n            low = computed_breaks[i]\n            high = computed_breaks[i + 1]\n            labels.append(f\"{low:.1f} - {high:.1f}\")\n\n        self.add_legend(\n            title=title,\n            labels=labels,\n            colors=colors,\n            position=\"bottom-right\",\n        )\n</code></pre>"},{"location":"mapbox/#anymap_ts.mapbox.MapboxMap.add_cluster_layer","title":"<code>add_cluster_layer(self, data, cluster_radius=50, cluster_max_zoom=14, cluster_colors=None, cluster_steps=None, cluster_min_radius=15, cluster_max_radius=30, unclustered_color='#11b4da', unclustered_radius=8, show_cluster_count=True, name=None, zoom_on_click=True, fit_bounds=True, **kwargs)</code>","text":"<p>Add a clustered point layer.</p> Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def add_cluster_layer(\n    self,\n    data: Any,\n    cluster_radius: int = 50,\n    cluster_max_zoom: int = 14,\n    cluster_colors: Optional[List[str]] = None,\n    cluster_steps: Optional[List[int]] = None,\n    cluster_min_radius: int = 15,\n    cluster_max_radius: int = 30,\n    unclustered_color: str = \"#11b4da\",\n    unclustered_radius: int = 8,\n    show_cluster_count: bool = True,\n    name: Optional[str] = None,\n    zoom_on_click: bool = True,\n    fit_bounds: bool = True,\n    **kwargs,\n) -&gt; str:\n    \"\"\"Add a clustered point layer.\"\"\"\n    layer_id = name or f\"cluster-{len(self._layers)}\"\n\n    if cluster_colors is None:\n        cluster_colors = [\"#51bbd6\", \"#f1f075\", \"#f28cb1\"]\n    if cluster_steps is None:\n        cluster_steps = [100, 750]\n\n    if len(cluster_steps) != len(cluster_colors) - 1:\n        raise ValueError(\n            f\"cluster_steps must have {len(cluster_colors) - 1} values \"\n            f\"(one less than cluster_colors), got {len(cluster_steps)}\"\n        )\n\n    geojson = to_geojson(data)\n\n    if geojson.get(\"type\") == \"url\":\n        url = geojson[\"url\"]\n        geojson = fetch_geojson(url)\n\n    bounds = get_bounds(geojson) if fit_bounds else None\n\n    self.call_js_method(\n        \"addClusterLayer\",\n        data=geojson,\n        name=layer_id,\n        clusterRadius=cluster_radius,\n        clusterMaxZoom=cluster_max_zoom,\n        clusterColors=cluster_colors,\n        clusterSteps=cluster_steps,\n        clusterMinRadius=cluster_min_radius,\n        clusterMaxRadius=cluster_max_radius,\n        unclusteredColor=unclustered_color,\n        unclusteredRadius=unclustered_radius,\n        showClusterCount=show_cluster_count,\n        zoomOnClick=zoom_on_click,\n        fitBounds=fit_bounds,\n        bounds=bounds,\n        **kwargs,\n    )\n\n    self._layers = {\n        **self._layers,\n        layer_id: {\n            \"id\": layer_id,\n            \"type\": \"cluster\",\n            \"source\": f\"{layer_id}-source\",\n        },\n    }\n    self._add_to_layer_dict(layer_id, \"Vector\")\n    return layer_id\n</code></pre>"},{"location":"mapbox/#anymap_ts.mapbox.MapboxMap.add_cog_control","title":"<code>add_cog_control(self, position='top-right', collapsed=True, default_url=None, load_default_url=False, default_opacity=1.0, default_colormap='viridis', default_bands='1', default_rescale_min=0, default_rescale_max=255, **kwargs)</code>","text":"<p>Add a COG layer control.</p> Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def add_cog_control(\n    self,\n    position: str = \"top-right\",\n    collapsed: bool = True,\n    default_url: Optional[str] = None,\n    load_default_url: bool = False,\n    default_opacity: float = 1.0,\n    default_colormap: str = \"viridis\",\n    default_bands: str = \"1\",\n    default_rescale_min: float = 0,\n    default_rescale_max: float = 255,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a COG layer control.\"\"\"\n    self.call_js_method(\n        \"addCogControl\",\n        position=position,\n        collapsed=collapsed,\n        defaultUrl=default_url or \"\",\n        loadDefaultUrl=load_default_url,\n        defaultOpacity=default_opacity,\n        defaultColormap=default_colormap,\n        defaultBands=default_bands,\n        defaultRescaleMin=default_rescale_min,\n        defaultRescaleMax=default_rescale_max,\n        **kwargs,\n    )\n    self._controls = {\n        **self._controls,\n        \"cog-control\": {\"position\": position, \"collapsed\": collapsed},\n    }\n</code></pre>"},{"location":"mapbox/#anymap_ts.mapbox.MapboxMap.add_cog_layer","title":"<code>add_cog_layer(self, url, name=None, opacity=1.0, visible=True, debug=False, debug_opacity=0.25, max_error=0.125, fit_bounds=True, before_id=None, **kwargs)</code>","text":"<p>Add a Cloud Optimized GeoTIFF (COG) layer using deck.gl-raster.</p> <p>This method renders COG files directly in the browser using GPU-accelerated deck.gl rendering with automatic reprojection support.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>URL to the Cloud Optimized GeoTIFF file.</p> required <code>name</code> <code>Optional[str]</code> <p>Layer ID. If None, auto-generated.</p> <code>None</code> <code>opacity</code> <code>float</code> <p>Layer opacity (0-1).</p> <code>1.0</code> <code>visible</code> <code>bool</code> <p>Whether layer is visible.</p> <code>True</code> <code>debug</code> <code>bool</code> <p>Show reprojection mesh for debugging.</p> <code>False</code> <code>debug_opacity</code> <code>float</code> <p>Opacity of debug mesh (0-1).</p> <code>0.25</code> <code>max_error</code> <code>float</code> <p>Maximum reprojection error in pixels. Lower values create denser mesh for better accuracy.</p> <code>0.125</code> <code>fit_bounds</code> <code>bool</code> <p>Whether to fit map to COG bounds after loading.</p> <code>True</code> <code>before_id</code> <code>Optional[str]</code> <p>ID of layer to insert before.</p> <code>None</code> <code>**kwargs</code> <p>Additional COGLayer props.</p> <code>{}</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from anymap_ts import MapboxMap\n&gt;&gt;&gt; m = MapboxMap()\n&gt;&gt;&gt; m.add_cog_layer(\n...     \"https://example.com/landcover.tif\",\n...     name=\"landcover\",\n...     opacity=0.8\n... )\n</code></pre> Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def add_cog_layer(\n    self,\n    url: str,\n    name: Optional[str] = None,\n    opacity: float = 1.0,\n    visible: bool = True,\n    debug: bool = False,\n    debug_opacity: float = 0.25,\n    max_error: float = 0.125,\n    fit_bounds: bool = True,\n    before_id: Optional[str] = None,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a Cloud Optimized GeoTIFF (COG) layer using deck.gl-raster.\n\n    This method renders COG files directly in the browser using GPU-accelerated\n    deck.gl rendering with automatic reprojection support.\n\n    Args:\n        url: URL to the Cloud Optimized GeoTIFF file.\n        name: Layer ID. If None, auto-generated.\n        opacity: Layer opacity (0-1).\n        visible: Whether layer is visible.\n        debug: Show reprojection mesh for debugging.\n        debug_opacity: Opacity of debug mesh (0-1).\n        max_error: Maximum reprojection error in pixels. Lower values\n            create denser mesh for better accuracy.\n        fit_bounds: Whether to fit map to COG bounds after loading.\n        before_id: ID of layer to insert before.\n        **kwargs: Additional COGLayer props.\n\n    Example:\n        &gt;&gt;&gt; from anymap_ts import MapboxMap\n        &gt;&gt;&gt; m = MapboxMap()\n        &gt;&gt;&gt; m.add_cog_layer(\n        ...     \"https://example.com/landcover.tif\",\n        ...     name=\"landcover\",\n        ...     opacity=0.8\n        ... )\n    \"\"\"\n    layer_id = name or f\"cog-{len(self._layers)}\"\n\n    self.call_js_method(\n        \"addCOGLayer\",\n        id=layer_id,\n        geotiff=url,\n        opacity=opacity,\n        visible=visible,\n        debug=debug,\n        debugOpacity=debug_opacity,\n        maxError=max_error,\n        fitBounds=fit_bounds,\n        beforeId=before_id,\n        **kwargs,\n    )\n\n    self._layers = {\n        **self._layers,\n        layer_id: {\n            \"id\": layer_id,\n            \"type\": \"cog\",\n            \"url\": url,\n        },\n    }\n    self._add_to_layer_dict(layer_id, \"Raster\")\n</code></pre>"},{"location":"mapbox/#anymap_ts.mapbox.MapboxMap.add_colorbar","title":"<code>add_colorbar(self, colormap='viridis', vmin=0, vmax=1, label='', units='', orientation='horizontal', position='bottom-right', bar_thickness=None, bar_length=None, ticks=None, opacity=None, colorbar_id=None, **kwargs)</code>","text":"<p>Add a continuous gradient colorbar to the map.</p> Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def add_colorbar(\n    self,\n    colormap: str = \"viridis\",\n    vmin: float = 0,\n    vmax: float = 1,\n    label: str = \"\",\n    units: str = \"\",\n    orientation: str = \"horizontal\",\n    position: str = \"bottom-right\",\n    bar_thickness: Optional[int] = None,\n    bar_length: Optional[int] = None,\n    ticks: Optional[Dict] = None,\n    opacity: Optional[float] = None,\n    colorbar_id: Optional[str] = None,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a continuous gradient colorbar to the map.\"\"\"\n    self._validate_position(position)\n\n    cbar_id = (\n        colorbar_id\n        or f\"colorbar-{len([k for k in self._controls.keys() if k.startswith('colorbar')])}\"\n    )\n\n    js_kwargs: Dict[str, Any] = {\n        \"colormap\": colormap,\n        \"vmin\": vmin,\n        \"vmax\": vmax,\n        \"label\": label,\n        \"units\": units,\n        \"orientation\": orientation,\n        \"position\": position,\n        \"colorbarId\": cbar_id,\n        **kwargs,\n    }\n    if bar_thickness is not None:\n        js_kwargs[\"barThickness\"] = bar_thickness\n    if bar_length is not None:\n        js_kwargs[\"barLength\"] = bar_length\n    if ticks is not None:\n        js_kwargs[\"ticks\"] = ticks\n    if opacity is not None:\n        js_kwargs[\"opacity\"] = opacity\n\n    self.call_js_method(\"addColorbar\", **js_kwargs)\n\n    self._controls = {\n        **self._controls,\n        cbar_id: {\n            \"type\": \"colorbar\",\n            \"colormap\": colormap,\n            \"vmin\": vmin,\n            \"vmax\": vmax,\n            \"label\": label,\n            \"units\": units,\n            \"orientation\": orientation,\n            \"position\": position,\n        },\n    }\n</code></pre>"},{"location":"mapbox/#anymap_ts.mapbox.MapboxMap.add_column_layer","title":"<code>add_column_layer(self, data, name=None, get_position='coordinates', get_fill_color=None, get_line_color=None, get_elevation=1000, radius=1000, disk_resolution=20, elevation_scale=1, coverage=1, extruded=True, filled=True, stroked=False, wireframe=False, pickable=True, opacity=0.8, **kwargs)</code>","text":"<p>Add a column layer using deck.gl.</p> Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def add_column_layer(\n    self,\n    data: Any,\n    name: Optional[str] = None,\n    get_position: Union[str, Any] = \"coordinates\",\n    get_fill_color: Optional[Union[List[int], str]] = None,\n    get_line_color: Optional[Union[List[int], str]] = None,\n    get_elevation: Union[float, str] = 1000,\n    radius: float = 1000,\n    disk_resolution: int = 20,\n    elevation_scale: float = 1,\n    coverage: float = 1,\n    extruded: bool = True,\n    filled: bool = True,\n    stroked: bool = False,\n    wireframe: bool = False,\n    pickable: bool = True,\n    opacity: float = 0.8,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a column layer using deck.gl.\"\"\"\n    layer_id = name or f\"column-{len(self._layers)}\"\n    processed_data = self._process_deck_data(data)\n\n    self.call_js_method(\n        \"addColumnLayer\",\n        id=layer_id,\n        data=processed_data,\n        getPosition=get_position,\n        getFillColor=get_fill_color or [255, 140, 0, 200],\n        getLineColor=get_line_color or [0, 0, 0, 255],\n        getElevation=get_elevation,\n        radius=radius,\n        diskResolution=disk_resolution,\n        elevationScale=elevation_scale,\n        coverage=coverage,\n        extruded=extruded,\n        filled=filled,\n        stroked=stroked,\n        wireframe=wireframe,\n        pickable=pickable,\n        opacity=opacity,\n        **kwargs,\n    )\n\n    self._layers = {**self._layers, layer_id: {\"id\": layer_id, \"type\": \"column\"}}\n    self._add_to_layer_dict(layer_id, \"Deck.gl\")\n</code></pre>"},{"location":"mapbox/#anymap_ts.mapbox.MapboxMap.add_contour_layer","title":"<code>add_contour_layer(self, data, name=None, get_position='coordinates', get_weight=1, cell_size=200, contours=None, pickable=True, opacity=1, **kwargs)</code>","text":"<p>Add a contour layer using deck.gl.</p> Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def add_contour_layer(\n    self,\n    data: Any,\n    name: Optional[str] = None,\n    get_position: Union[str, Any] = \"coordinates\",\n    get_weight: Union[float, str] = 1,\n    cell_size: float = 200,\n    contours: Optional[List[Dict]] = None,\n    pickable: bool = True,\n    opacity: float = 1,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a contour layer using deck.gl.\"\"\"\n    layer_id = name or f\"contour-{len(self._layers)}\"\n    processed_data = self._process_deck_data(data)\n\n    default_contours = [\n        {\"threshold\": 1, \"color\": [255, 255, 255], \"strokeWidth\": 1},\n        {\"threshold\": 5, \"color\": [51, 136, 255], \"strokeWidth\": 2},\n        {\"threshold\": 10, \"color\": [0, 0, 255], \"strokeWidth\": 3},\n    ]\n\n    self.call_js_method(\n        \"addContourLayer\",\n        id=layer_id,\n        data=processed_data,\n        getPosition=get_position,\n        getWeight=get_weight,\n        cellSize=cell_size,\n        contours=contours or default_contours,\n        pickable=pickable,\n        opacity=opacity,\n        **kwargs,\n    )\n\n    self._layers = {**self._layers, layer_id: {\"id\": layer_id, \"type\": \"contour\"}}\n    self._add_to_layer_dict(layer_id, \"Deck.gl\")\n</code></pre>"},{"location":"mapbox/#anymap_ts.mapbox.MapboxMap.add_control","title":"<code>add_control(self, control_type, position='top-right', **kwargs)</code>","text":"<p>Add a map control.</p> <p>Parameters:</p> Name Type Description Default <code>control_type</code> <code>str</code> <p>Type of control ('navigation', 'scale', 'fullscreen', etc.).</p> required <code>position</code> <code>str</code> <p>Control position.</p> <code>'top-right'</code> <code>**kwargs</code> <p>Control-specific options.</p> <code>{}</code> Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def add_control(\n    self,\n    control_type: str,\n    position: str = \"top-right\",\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a map control.\n\n    Args:\n        control_type: Type of control ('navigation', 'scale', 'fullscreen', etc.).\n        position: Control position.\n        **kwargs: Control-specific options.\n    \"\"\"\n    self.call_js_method(\"addControl\", control_type, position=position, **kwargs)\n    self._controls = {\n        **self._controls,\n        control_type: {\"type\": control_type, \"position\": position, **kwargs},\n    }\n</code></pre>"},{"location":"mapbox/#anymap_ts.mapbox.MapboxMap.add_control_grid","title":"<code>add_control_grid(self, position='top-right', default_controls=None, exclude=None, rows=None, columns=None, collapsed=True, collapsible=True, title='', show_row_column_controls=True, gap=2, basemap_style_url=None, exclude_layers=None, **kwargs)</code>","text":"<p>Add a ControlGrid with all default tools or a custom subset.</p> Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def add_control_grid(\n    self,\n    position: str = \"top-right\",\n    default_controls: Optional[List[str]] = None,\n    exclude: Optional[List[str]] = None,\n    rows: Optional[int] = None,\n    columns: Optional[int] = None,\n    collapsed: bool = True,\n    collapsible: bool = True,\n    title: str = \"\",\n    show_row_column_controls: bool = True,\n    gap: int = 2,\n    basemap_style_url: Optional[str] = None,\n    exclude_layers: Optional[List[str]] = None,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a ControlGrid with all default tools or a custom subset.\"\"\"\n    js_kwargs: Dict[str, Any] = {\n        \"position\": position,\n        \"collapsed\": collapsed,\n        \"collapsible\": collapsible,\n        \"showRowColumnControls\": show_row_column_controls,\n        \"gap\": gap,\n        **kwargs,\n    }\n    if default_controls is not None:\n        js_kwargs[\"defaultControls\"] = default_controls\n    if exclude is not None:\n        js_kwargs[\"exclude\"] = exclude\n    if rows is not None:\n        js_kwargs[\"rows\"] = rows\n    if columns is not None:\n        js_kwargs[\"columns\"] = columns\n    if title:\n        js_kwargs[\"title\"] = title\n    if basemap_style_url is not None:\n        js_kwargs[\"basemapStyleUrl\"] = basemap_style_url\n    if exclude_layers is not None:\n        js_kwargs[\"excludeLayers\"] = exclude_layers\n\n    self.call_js_method(\"addControlGrid\", **js_kwargs)\n    self._controls = {\n        **self._controls,\n        \"control-grid\": {\n            \"position\": position,\n            \"collapsed\": collapsed,\n            \"collapsible\": collapsible,\n        },\n    }\n</code></pre>"},{"location":"mapbox/#anymap_ts.mapbox.MapboxMap.add_coordinates_control","title":"<code>add_coordinates_control(self, position='bottom-left', precision=4)</code>","text":"<p>Add a coordinates display control.</p> Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def add_coordinates_control(\n    self,\n    position: str = \"bottom-left\",\n    precision: int = 4,\n) -&gt; None:\n    \"\"\"Add a coordinates display control.\"\"\"\n    self.call_js_method(\n        \"addCoordinatesControl\",\n        position=position,\n        precision=precision,\n    )\n</code></pre>"},{"location":"mapbox/#anymap_ts.mapbox.MapboxMap.add_deck_heatmap_layer","title":"<code>add_deck_heatmap_layer(self, data, name=None, get_position='coordinates', get_weight=1, radius_pixels=30, intensity=1, threshold=0.05, color_range=None, opacity=1, **kwargs)</code>","text":"<p>Add a GPU-accelerated heatmap layer using deck.gl.</p> Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def add_deck_heatmap_layer(\n    self,\n    data: Any,\n    name: Optional[str] = None,\n    get_position: Union[str, Any] = \"coordinates\",\n    get_weight: Union[float, str] = 1,\n    radius_pixels: float = 30,\n    intensity: float = 1,\n    threshold: float = 0.05,\n    color_range: Optional[List[List[int]]] = None,\n    opacity: float = 1,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a GPU-accelerated heatmap layer using deck.gl.\"\"\"\n    layer_id = name or f\"deck-heatmap-{len(self._layers)}\"\n    processed_data = self._process_deck_data(data)\n\n    default_color_range = [\n        [255, 255, 178, 25],\n        [254, 217, 118, 85],\n        [254, 178, 76, 127],\n        [253, 141, 60, 170],\n        [240, 59, 32, 212],\n        [189, 0, 38, 255],\n    ]\n\n    self.call_js_method(\n        \"addHeatmapLayer\",\n        id=layer_id,\n        data=processed_data,\n        getPosition=get_position,\n        getWeight=get_weight,\n        radiusPixels=radius_pixels,\n        intensity=intensity,\n        threshold=threshold,\n        colorRange=color_range or default_color_range,\n        opacity=opacity,\n        **kwargs,\n    )\n\n    self._layers = {\n        **self._layers,\n        layer_id: {\"id\": layer_id, \"type\": \"deck-heatmap\"},\n    }\n    self._add_to_layer_dict(layer_id, \"Deck.gl\")\n</code></pre>"},{"location":"mapbox/#anymap_ts.mapbox.MapboxMap.add_deckgl_layer","title":"<code>add_deckgl_layer(self, layer_type, data, name=None, **kwargs)</code>","text":"<p>Add a generic deck.gl layer to the map.</p> Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def add_deckgl_layer(\n    self,\n    layer_type: str,\n    data: Any,\n    name: Optional[str] = None,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a generic deck.gl layer to the map.\"\"\"\n    layer_type_clean = layer_type.replace(\"Layer\", \"\")\n    prefix = layer_type_clean.lower()\n    layer_id = name or f\"{prefix}-{len(self._layers)}\"\n    processed_data = self._process_deck_data(data)\n\n    self.call_js_method(\n        \"addDeckGLLayer\",\n        layerType=layer_type,\n        id=layer_id,\n        data=processed_data,\n        **kwargs,\n    )\n\n    self._layers = {**self._layers, layer_id: {\"id\": layer_id, \"type\": layer_type}}\n    self._add_to_layer_dict(layer_id, \"Deck.gl\")\n</code></pre>"},{"location":"mapbox/#anymap_ts.mapbox.MapboxMap.add_draw_control","title":"<code>add_draw_control(self, position='top-right', draw_modes=None, edit_modes=None, collapsed=False, **kwargs)</code>","text":"<p>Add a drawing control.</p> Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def add_draw_control(\n    self,\n    position: str = \"top-right\",\n    draw_modes: Optional[List[str]] = None,\n    edit_modes: Optional[List[str]] = None,\n    collapsed: bool = False,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a drawing control.\"\"\"\n    if draw_modes is None:\n        draw_modes = [\"polygon\", \"line\", \"rectangle\", \"circle\", \"marker\"]\n    if edit_modes is None:\n        edit_modes = [\"select\", \"drag\", \"change\", \"rotate\", \"delete\"]\n\n    self.call_js_method(\n        \"addDrawControl\",\n        position=position,\n        drawModes=draw_modes,\n        editModes=edit_modes,\n        collapsed=collapsed,\n        **kwargs,\n    )\n    self._controls = {\n        **self._controls,\n        \"draw-control\": {\n            \"position\": position,\n            \"drawModes\": draw_modes,\n            \"editModes\": edit_modes,\n        },\n    }\n</code></pre>"},{"location":"mapbox/#anymap_ts.mapbox.MapboxMap.add_flatgeobuf","title":"<code>add_flatgeobuf(self, url, name=None, layer_type=None, paint=None, fit_bounds=True, **kwargs)</code>","text":"<p>Add a FlatGeobuf layer from a URL.</p> Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def add_flatgeobuf(\n    self,\n    url: str,\n    name: Optional[str] = None,\n    layer_type: Optional[str] = None,\n    paint: Optional[Dict] = None,\n    fit_bounds: bool = True,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a FlatGeobuf layer from a URL.\"\"\"\n    layer_id = name or f\"flatgeobuf-{len(self._layers)}\"\n\n    self.call_js_method(\n        \"addFlatGeobuf\",\n        url=url,\n        name=layer_id,\n        layerType=layer_type,\n        paint=paint,\n        fitBounds=fit_bounds,\n        **kwargs,\n    )\n\n    self._layers = {\n        **self._layers,\n        layer_id: {\n            \"id\": layer_id,\n            \"type\": \"flatgeobuf\",\n            \"url\": url,\n        },\n    }\n    self._add_to_layer_dict(layer_id, \"Vector\")\n</code></pre>"},{"location":"mapbox/#anymap_ts.mapbox.MapboxMap.add_geojson","title":"<code>add_geojson(self, data, layer_type=None, paint=None, name=None, fit_bounds=True, **kwargs)</code>","text":"<p>Add GeoJSON data to the map.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Union[str, Dict]</code> <p>GeoJSON dict or URL to GeoJSON file.</p> required <code>layer_type</code> <code>Optional[str]</code> <p>Mapbox layer type.</p> <code>None</code> <code>paint</code> <code>Optional[Dict]</code> <p>Mapbox paint properties.</p> <code>None</code> <code>name</code> <code>Optional[str]</code> <p>Layer name.</p> <code>None</code> <code>fit_bounds</code> <code>bool</code> <p>Whether to fit map to data bounds.</p> <code>True</code> <code>**kwargs</code> <p>Additional layer options.</p> <code>{}</code> Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def add_geojson(\n    self,\n    data: Union[str, Dict],\n    layer_type: Optional[str] = None,\n    paint: Optional[Dict] = None,\n    name: Optional[str] = None,\n    fit_bounds: bool = True,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add GeoJSON data to the map.\n\n    Args:\n        data: GeoJSON dict or URL to GeoJSON file.\n        layer_type: Mapbox layer type.\n        paint: Mapbox paint properties.\n        name: Layer name.\n        fit_bounds: Whether to fit map to data bounds.\n        **kwargs: Additional layer options.\n    \"\"\"\n    self.add_vector(\n        data,\n        layer_type=layer_type,\n        paint=paint,\n        name=name,\n        fit_bounds=fit_bounds,\n        **kwargs,\n    )\n</code></pre>"},{"location":"mapbox/#anymap_ts.mapbox.MapboxMap.add_geojson_layer","title":"<code>add_geojson_layer(self, data, name=None, get_fill_color=None, get_line_color=None, get_line_width=1, get_point_radius=5, get_elevation=0, extruded=False, wireframe=False, filled=True, stroked=True, line_width_min_pixels=1, point_radius_min_pixels=2, pickable=True, opacity=0.8, **kwargs)</code>","text":"<p>Add a GeoJSON layer with auto-styling using deck.gl.</p> Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def add_geojson_layer(\n    self,\n    data: Any,\n    name: Optional[str] = None,\n    get_fill_color: Optional[Union[List[int], str]] = None,\n    get_line_color: Optional[Union[List[int], str]] = None,\n    get_line_width: Union[float, str] = 1,\n    get_point_radius: Union[float, str] = 5,\n    get_elevation: Union[float, str] = 0,\n    extruded: bool = False,\n    wireframe: bool = False,\n    filled: bool = True,\n    stroked: bool = True,\n    line_width_min_pixels: float = 1,\n    point_radius_min_pixels: float = 2,\n    pickable: bool = True,\n    opacity: float = 0.8,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a GeoJSON layer with auto-styling using deck.gl.\"\"\"\n    layer_id = name or f\"geojson-deck-{len(self._layers)}\"\n    processed_data = self._process_deck_data(data)\n\n    self.call_js_method(\n        \"addGeoJsonLayer\",\n        id=layer_id,\n        data=processed_data,\n        getFillColor=get_fill_color or [51, 136, 255, 128],\n        getLineColor=get_line_color or [0, 0, 0, 255],\n        getLineWidth=get_line_width,\n        getPointRadius=get_point_radius,\n        getElevation=get_elevation,\n        extruded=extruded,\n        wireframe=wireframe,\n        filled=filled,\n        stroked=stroked,\n        lineWidthMinPixels=line_width_min_pixels,\n        pointRadiusMinPixels=point_radius_min_pixels,\n        pickable=pickable,\n        opacity=opacity,\n        **kwargs,\n    )\n\n    self._layers = {\n        **self._layers,\n        layer_id: {\"id\": layer_id, \"type\": \"geojson-deck\"},\n    }\n    self._add_to_layer_dict(layer_id, \"Deck.gl\")\n</code></pre>"},{"location":"mapbox/#anymap_ts.mapbox.MapboxMap.add_grid_cell_layer","title":"<code>add_grid_cell_layer(self, data, name=None, get_position='coordinates', get_color=None, get_elevation=1000, cell_size=200, coverage=1, elevation_scale=1, extruded=True, pickable=True, opacity=0.8, **kwargs)</code>","text":"<p>Add a grid cell layer using deck.gl.</p> Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def add_grid_cell_layer(\n    self,\n    data: Any,\n    name: Optional[str] = None,\n    get_position: Union[str, Any] = \"coordinates\",\n    get_color: Optional[Union[List[int], str]] = None,\n    get_elevation: Union[float, str] = 1000,\n    cell_size: float = 200,\n    coverage: float = 1,\n    elevation_scale: float = 1,\n    extruded: bool = True,\n    pickable: bool = True,\n    opacity: float = 0.8,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a grid cell layer using deck.gl.\"\"\"\n    layer_id = name or f\"gridcell-{len(self._layers)}\"\n    processed_data = self._process_deck_data(data)\n\n    self.call_js_method(\n        \"addGridCellLayer\",\n        id=layer_id,\n        data=processed_data,\n        getPosition=get_position,\n        getColor=get_color or [255, 140, 0, 200],\n        getElevation=get_elevation,\n        cellSize=cell_size,\n        coverage=coverage,\n        elevationScale=elevation_scale,\n        extruded=extruded,\n        pickable=pickable,\n        opacity=opacity,\n        **kwargs,\n    )\n\n    self._layers = {\n        **self._layers,\n        layer_id: {\"id\": layer_id, \"type\": \"gridcell\"},\n    }\n    self._add_to_layer_dict(layer_id, \"Deck.gl\")\n</code></pre>"},{"location":"mapbox/#anymap_ts.mapbox.MapboxMap.add_grid_layer","title":"<code>add_grid_layer(self, data, name=None, get_position='coordinates', cell_size=200, elevation_scale=4, extruded=True, color_range=None, pickable=True, opacity=0.8, **kwargs)</code>","text":"<p>Add a grid layer using deck.gl.</p> Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def add_grid_layer(\n    self,\n    data: Any,\n    name: Optional[str] = None,\n    get_position: Union[str, Any] = \"coordinates\",\n    cell_size: float = 200,\n    elevation_scale: float = 4,\n    extruded: bool = True,\n    color_range: Optional[List[List[int]]] = None,\n    pickable: bool = True,\n    opacity: float = 0.8,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a grid layer using deck.gl.\"\"\"\n    layer_id = name or f\"grid-{len(self._layers)}\"\n    processed_data = self._process_deck_data(data)\n\n    default_color_range = [\n        [1, 152, 189],\n        [73, 227, 206],\n        [216, 254, 181],\n        [254, 237, 177],\n        [254, 173, 84],\n        [209, 55, 78],\n    ]\n\n    self.call_js_method(\n        \"addGridLayer\",\n        id=layer_id,\n        data=processed_data,\n        getPosition=get_position,\n        cellSize=cell_size,\n        elevationScale=elevation_scale,\n        extruded=extruded,\n        colorRange=color_range or default_color_range,\n        pickable=pickable,\n        opacity=opacity,\n        **kwargs,\n    )\n\n    self._layers = {**self._layers, layer_id: {\"id\": layer_id, \"type\": \"grid\"}}\n    self._add_to_layer_dict(layer_id, \"Deck.gl\")\n</code></pre>"},{"location":"mapbox/#anymap_ts.mapbox.MapboxMap.add_heatmap","title":"<code>add_heatmap(self, data, weight_property=None, radius=20, intensity=1.0, colormap=None, opacity=0.8, name=None, fit_bounds=True, **kwargs)</code>","text":"<p>Add a heatmap layer to the map.</p> Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def add_heatmap(\n    self,\n    data: Any,\n    weight_property: Optional[str] = None,\n    radius: int = 20,\n    intensity: float = 1.0,\n    colormap: Optional[List] = None,\n    opacity: float = 0.8,\n    name: Optional[str] = None,\n    fit_bounds: bool = True,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a heatmap layer to the map.\"\"\"\n    self._validate_opacity(opacity)\n    layer_id = name or f\"heatmap-{len(self._layers)}\"\n\n    geojson = to_geojson(data)\n\n    if geojson.get(\"type\") == \"url\":\n        url = geojson[\"url\"]\n        geojson = fetch_geojson(url)\n\n    if colormap is None:\n        colormap = [\n            [0, \"rgba(33,102,172,0)\"],\n            [0.2, \"rgb(103,169,207)\"],\n            [0.4, \"rgb(209,229,240)\"],\n            [0.6, \"rgb(253,219,199)\"],\n            [0.8, \"rgb(239,138,98)\"],\n            [1, \"rgb(178,24,43)\"],\n        ]\n\n    paint = {\n        \"heatmap-radius\": radius,\n        \"heatmap-intensity\": intensity,\n        \"heatmap-opacity\": opacity,\n        \"heatmap-color\": [\n            \"interpolate\",\n            [\"linear\"],\n            [\"heatmap-density\"],\n        ],\n    }\n\n    for stop, color in colormap:\n        paint[\"heatmap-color\"].extend([stop, color])\n\n    if weight_property:\n        paint[\"heatmap-weight\"] = [\"get\", weight_property]\n\n    bounds = get_bounds(geojson) if fit_bounds else None\n\n    self.call_js_method(\n        \"addGeoJSON\",\n        data=geojson,\n        name=layer_id,\n        layerType=\"heatmap\",\n        paint=paint,\n        fitBounds=fit_bounds,\n        bounds=bounds,\n        **kwargs,\n    )\n\n    self._layers = {\n        **self._layers,\n        layer_id: {\n            \"id\": layer_id,\n            \"type\": \"heatmap\",\n            \"source\": f\"{layer_id}-source\",\n            \"paint\": paint,\n        },\n    }\n    self._add_to_layer_dict(layer_id, \"Heatmap\")\n</code></pre>"},{"location":"mapbox/#anymap_ts.mapbox.MapboxMap.add_hexagon_layer","title":"<code>add_hexagon_layer(self, data, name=None, get_position='coordinates', radius=1000, elevation_scale=4, extruded=True, color_range=None, pickable=True, opacity=0.8, **kwargs)</code>","text":"<p>Add a hexagon layer using deck.gl.</p> Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def add_hexagon_layer(\n    self,\n    data: Any,\n    name: Optional[str] = None,\n    get_position: Union[str, Any] = \"coordinates\",\n    radius: float = 1000,\n    elevation_scale: float = 4,\n    extruded: bool = True,\n    color_range: Optional[List[List[int]]] = None,\n    pickable: bool = True,\n    opacity: float = 0.8,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a hexagon layer using deck.gl.\"\"\"\n    layer_id = name or f\"hexagon-{len(self._layers)}\"\n    processed_data = self._process_deck_data(data)\n\n    default_color_range = [\n        [1, 152, 189],\n        [73, 227, 206],\n        [216, 254, 181],\n        [254, 237, 177],\n        [254, 173, 84],\n        [209, 55, 78],\n    ]\n\n    self.call_js_method(\n        \"addHexagonLayer\",\n        id=layer_id,\n        data=processed_data,\n        getPosition=get_position,\n        radius=radius,\n        elevationScale=elevation_scale,\n        extruded=extruded,\n        colorRange=color_range or default_color_range,\n        pickable=pickable,\n        opacity=opacity,\n        **kwargs,\n    )\n\n    self._layers = {**self._layers, layer_id: {\"id\": layer_id, \"type\": \"hexagon\"}}\n    self._add_to_layer_dict(layer_id, \"Deck.gl\")\n</code></pre>"},{"location":"mapbox/#anymap_ts.mapbox.MapboxMap.add_hover_effect","title":"<code>add_hover_effect(self, layer_id, highlight_color=None, highlight_opacity=None, highlight_outline_width=2, **kwargs)</code>","text":"<p>Add hover highlight effect to an existing layer.</p> Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def add_hover_effect(\n    self,\n    layer_id: str,\n    highlight_color: Optional[str] = None,\n    highlight_opacity: Optional[float] = None,\n    highlight_outline_width: float = 2,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add hover highlight effect to an existing layer.\"\"\"\n    self.call_js_method(\n        \"addHoverEffect\",\n        layerId=layer_id,\n        highlightColor=highlight_color,\n        highlightOpacity=highlight_opacity,\n        highlightOutlineWidth=highlight_outline_width,\n        **kwargs,\n    )\n</code></pre>"},{"location":"mapbox/#anymap_ts.mapbox.MapboxMap.add_icon_layer","title":"<code>add_icon_layer(self, data, name=None, get_position='coordinates', get_icon='icon', get_size=20, get_color=None, icon_atlas=None, icon_mapping=None, pickable=True, opacity=1, **kwargs)</code>","text":"<p>Add an icon layer using deck.gl.</p> Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def add_icon_layer(\n    self,\n    data: Any,\n    name: Optional[str] = None,\n    get_position: Union[str, Any] = \"coordinates\",\n    get_icon: Union[str, Any] = \"icon\",\n    get_size: Union[float, str] = 20,\n    get_color: Optional[Union[List[int], str]] = None,\n    icon_atlas: Optional[str] = None,\n    icon_mapping: Optional[Dict] = None,\n    pickable: bool = True,\n    opacity: float = 1,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add an icon layer using deck.gl.\"\"\"\n    layer_id = name or f\"icon-{len(self._layers)}\"\n    processed_data = self._process_deck_data(data)\n\n    self.call_js_method(\n        \"addIconLayer\",\n        id=layer_id,\n        data=processed_data,\n        getPosition=get_position,\n        getIcon=get_icon,\n        getSize=get_size,\n        getColor=get_color or [255, 255, 255, 255],\n        iconAtlas=icon_atlas,\n        iconMapping=icon_mapping,\n        pickable=pickable,\n        opacity=opacity,\n        **kwargs,\n    )\n\n    self._layers = {**self._layers, layer_id: {\"id\": layer_id, \"type\": \"icon\"}}\n    self._add_to_layer_dict(layer_id, \"Deck.gl\")\n</code></pre>"},{"location":"mapbox/#anymap_ts.mapbox.MapboxMap.add_image","title":"<code>add_image(self, name, url)</code>","text":"<p>Load a custom icon image for use in symbol layers.</p> Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def add_image(self, name: str, url: str) -&gt; None:\n    \"\"\"Load a custom icon image for use in symbol layers.\"\"\"\n    self.call_js_method(\"addMapImage\", name=name, url=url)\n</code></pre>"},{"location":"mapbox/#anymap_ts.mapbox.MapboxMap.add_image_layer","title":"<code>add_image_layer(self, url, coordinates, name=None, opacity=1.0, **kwargs)</code>","text":"<p>Add a georeferenced image overlay.</p> Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def add_image_layer(\n    self,\n    url: str,\n    coordinates: List[List[float]],\n    name: Optional[str] = None,\n    opacity: float = 1.0,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a georeferenced image overlay.\"\"\"\n    self._validate_opacity(opacity)\n    layer_id = name or f\"image-{len(self._layers)}\"\n\n    if len(coordinates) != 4:\n        raise ValueError(\n            \"coordinates must have exactly 4 corner points \"\n            \"[top-left, top-right, bottom-right, bottom-left]\"\n        )\n\n    self.call_js_method(\n        \"addImageLayer\",\n        id=layer_id,\n        url=url,\n        coordinates=coordinates,\n        opacity=opacity,\n        **kwargs,\n    )\n\n    self._layers = {\n        **self._layers,\n        layer_id: {\n            \"id\": layer_id,\n            \"type\": \"image\",\n            \"url\": url,\n            \"coordinates\": coordinates,\n        },\n    }\n    self._add_to_layer_dict(layer_id, \"Raster\")\n</code></pre>"},{"location":"mapbox/#anymap_ts.mapbox.MapboxMap.add_layer","title":"<code>add_layer(self, layer_id, layer_type, source, paint=None, layout=None, before_id=None, **kwargs)</code>","text":"<p>Add a generic layer to the map.</p> <p>Parameters:</p> Name Type Description Default <code>layer_id</code> <code>str</code> <p>Unique layer identifier.</p> required <code>layer_type</code> <code>str</code> <p>Mapbox layer type.</p> required <code>source</code> <code>Union[str, Dict]</code> <p>Source ID or source configuration dict.</p> required <code>paint</code> <code>Optional[Dict]</code> <p>Paint properties.</p> <code>None</code> <code>layout</code> <code>Optional[Dict]</code> <p>Layout properties.</p> <code>None</code> <code>before_id</code> <code>Optional[str]</code> <p>ID of layer to insert before.</p> <code>None</code> <code>**kwargs</code> <p>Additional layer options.</p> <code>{}</code> Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def add_layer(\n    self,\n    layer_id: str,\n    layer_type: str,\n    source: Union[str, Dict],\n    paint: Optional[Dict] = None,\n    layout: Optional[Dict] = None,\n    before_id: Optional[str] = None,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a generic layer to the map.\n\n    Args:\n        layer_id: Unique layer identifier.\n        layer_type: Mapbox layer type.\n        source: Source ID or source configuration dict.\n        paint: Paint properties.\n        layout: Layout properties.\n        before_id: ID of layer to insert before.\n        **kwargs: Additional layer options.\n    \"\"\"\n    layer_config = {\n        \"id\": layer_id,\n        \"type\": layer_type,\n        \"paint\": paint or {},\n        \"layout\": layout or {},\n        **kwargs,\n    }\n\n    if isinstance(source, str):\n        layer_config[\"source\"] = source\n    else:\n        source_id = f\"{layer_id}-source\"\n        self._sources = {**self._sources, source_id: source}\n        self.call_js_method(\"addSource\", source_id, **source)\n        layer_config[\"source\"] = source_id\n\n    self._layers = {**self._layers, layer_id: layer_config}\n    self.call_js_method(\"addLayer\", beforeId=before_id, **layer_config)\n    lt = layer_config.get(\"type\", \"\")\n    self._add_to_layer_dict(layer_id, \"Raster\" if lt == \"raster\" else \"Vector\")\n</code></pre>"},{"location":"mapbox/#anymap_ts.mapbox.MapboxMap.add_layer_control","title":"<code>add_layer_control(self, layers=None, position='top-right', collapsed=True)</code>","text":"<p>Add a layer visibility control.</p> Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def add_layer_control(\n    self,\n    layers: Optional[List[str]] = None,\n    position: str = \"top-right\",\n    collapsed: bool = True,\n) -&gt; None:\n    \"\"\"Add a layer visibility control.\"\"\"\n    if layers is None:\n        layers = list(self._layers.keys())\n\n    self.call_js_method(\n        \"addLayerControl\",\n        layers=layers,\n        position=position,\n        collapsed=collapsed,\n    )\n    self._controls = {\n        **self._controls,\n        \"layer-control\": {\n            \"layers\": layers,\n            \"position\": position,\n            \"collapsed\": collapsed,\n        },\n    }\n</code></pre>"},{"location":"mapbox/#anymap_ts.mapbox.MapboxMap.add_legend","title":"<code>add_legend(self, title, labels, colors, position='bottom-right', opacity=1.0, legend_id=None, **kwargs)</code>","text":"<p>Add a floating legend control to the map.</p> Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def add_legend(\n    self,\n    title: str,\n    labels: List[str],\n    colors: List[str],\n    position: str = \"bottom-right\",\n    opacity: float = 1.0,\n    legend_id: Optional[str] = None,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a floating legend control to the map.\"\"\"\n    if len(labels) != len(colors):\n        raise ValueError(\"Number of labels must match number of colors\")\n\n    self._validate_position(position)\n\n    for i, color in enumerate(colors):\n        if not isinstance(color, str) or not color.startswith(\"#\"):\n            raise ValueError(\n                f\"Color at index {i} must be a hex color string (e.g., '#ff0000')\"\n            )\n\n    legend_id = (\n        legend_id\n        or f\"legend-{len([k for k in self._controls.keys() if k.startswith('legend')])}\"\n    )\n\n    legend_items = [\n        {\"label\": label, \"color\": color} for label, color in zip(labels, colors)\n    ]\n\n    self.call_js_method(\n        \"addLegend\",\n        id=legend_id,\n        title=title,\n        items=legend_items,\n        position=position,\n        opacity=opacity,\n        **kwargs,\n    )\n\n    self._controls = {\n        **self._controls,\n        legend_id: {\n            \"type\": \"legend\",\n            \"title\": title,\n            \"labels\": labels,\n            \"colors\": colors,\n            \"position\": position,\n            \"opacity\": opacity,\n        },\n    }\n</code></pre>"},{"location":"mapbox/#anymap_ts.mapbox.MapboxMap.add_lidar_control","title":"<code>add_lidar_control(self, position='top-right', collapsed=True, title='LiDAR Viewer', point_size=2, opacity=1.0, color_scheme='elevation', use_percentile=True, point_budget=1000000, pickable=False, auto_zoom=True, copc_loading_mode=None, streaming_point_budget=5000000, **kwargs)</code>","text":"<p>Add an interactive LiDAR control panel.</p> <p>The LiDAR control provides a UI panel for loading, visualizing, and styling LiDAR point cloud files (LAS, LAZ, COPC formats).</p> <p>Parameters:</p> Name Type Description Default <code>position</code> <code>str</code> <p>Control position ('top-left', 'top-right', 'bottom-left', 'bottom-right').</p> <code>'top-right'</code> <code>collapsed</code> <code>bool</code> <p>Whether the panel starts collapsed.</p> <code>True</code> <code>title</code> <code>str</code> <p>Title displayed on the panel.</p> <code>'LiDAR Viewer'</code> <code>point_size</code> <code>float</code> <p>Point size in pixels.</p> <code>2</code> <code>opacity</code> <code>float</code> <p>Layer opacity (0-1).</p> <code>1.0</code> <code>color_scheme</code> <code>str</code> <p>Color scheme ('elevation', 'intensity', 'classification', 'rgb').</p> <code>'elevation'</code> <code>use_percentile</code> <code>bool</code> <p>Use 2-98% percentile for color scaling.</p> <code>True</code> <code>point_budget</code> <code>int</code> <p>Maximum number of points to display.</p> <code>1000000</code> <code>pickable</code> <code>bool</code> <p>Enable hover/click interactions.</p> <code>False</code> <code>auto_zoom</code> <code>bool</code> <p>Auto-zoom to point cloud after loading.</p> <code>True</code> <code>copc_loading_mode</code> <code>Optional[str]</code> <p>COPC loading mode ('full' or 'dynamic').</p> <code>None</code> <code>streaming_point_budget</code> <code>int</code> <p>Point budget for streaming mode.</p> <code>5000000</code> <code>**kwargs</code> <p>Additional control options.</p> <code>{}</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from anymap_ts import MapboxMap\n&gt;&gt;&gt; m = MapboxMap(pitch=60)\n&gt;&gt;&gt; m.add_lidar_control(color_scheme=\"classification\", pickable=True)\n</code></pre> Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def add_lidar_control(\n    self,\n    position: str = \"top-right\",\n    collapsed: bool = True,\n    title: str = \"LiDAR Viewer\",\n    point_size: float = 2,\n    opacity: float = 1.0,\n    color_scheme: str = \"elevation\",\n    use_percentile: bool = True,\n    point_budget: int = 1000000,\n    pickable: bool = False,\n    auto_zoom: bool = True,\n    copc_loading_mode: Optional[str] = None,\n    streaming_point_budget: int = 5000000,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add an interactive LiDAR control panel.\n\n    The LiDAR control provides a UI panel for loading, visualizing, and\n    styling LiDAR point cloud files (LAS, LAZ, COPC formats).\n\n    Args:\n        position: Control position ('top-left', 'top-right', 'bottom-left', 'bottom-right').\n        collapsed: Whether the panel starts collapsed.\n        title: Title displayed on the panel.\n        point_size: Point size in pixels.\n        opacity: Layer opacity (0-1).\n        color_scheme: Color scheme ('elevation', 'intensity', 'classification', 'rgb').\n        use_percentile: Use 2-98% percentile for color scaling.\n        point_budget: Maximum number of points to display.\n        pickable: Enable hover/click interactions.\n        auto_zoom: Auto-zoom to point cloud after loading.\n        copc_loading_mode: COPC loading mode ('full' or 'dynamic').\n        streaming_point_budget: Point budget for streaming mode.\n        **kwargs: Additional control options.\n\n    Example:\n        &gt;&gt;&gt; from anymap_ts import MapboxMap\n        &gt;&gt;&gt; m = MapboxMap(pitch=60)\n        &gt;&gt;&gt; m.add_lidar_control(color_scheme=\"classification\", pickable=True)\n    \"\"\"\n    self.call_js_method(\n        \"addLidarControl\",\n        position=position,\n        collapsed=collapsed,\n        title=title,\n        pointSize=point_size,\n        opacity=opacity,\n        colorScheme=color_scheme,\n        usePercentile=use_percentile,\n        pointBudget=point_budget,\n        pickable=pickable,\n        autoZoom=auto_zoom,\n        copcLoadingMode=copc_loading_mode,\n        streamingPointBudget=streaming_point_budget,\n        **kwargs,\n    )\n    self._controls = {\n        **self._controls,\n        \"lidar-control\": {\"position\": position, \"collapsed\": collapsed},\n    }\n</code></pre>"},{"location":"mapbox/#anymap_ts.mapbox.MapboxMap.add_lidar_layer","title":"<code>add_lidar_layer(self, source, name=None, color_scheme='elevation', point_size=2, opacity=1.0, pickable=True, auto_zoom=True, streaming_mode=True, point_budget=1000000, **kwargs)</code>","text":"<p>Load and display a LiDAR file from URL or local path.</p> <p>Supports LAS, LAZ, and COPC (Cloud-Optimized Point Cloud) formats. For local files, the file is read and sent as base64 to JavaScript. For URLs, the data is loaded directly via streaming when possible.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>Union[str, Path]</code> <p>URL or local file path to the LiDAR file.</p> required <code>name</code> <code>Optional[str]</code> <p>Layer identifier. If None, auto-generated.</p> <code>None</code> <code>color_scheme</code> <code>str</code> <p>Color scheme ('elevation', 'intensity', 'classification', 'rgb').</p> <code>'elevation'</code> <code>point_size</code> <code>float</code> <p>Point size in pixels.</p> <code>2</code> <code>opacity</code> <code>float</code> <p>Layer opacity (0-1).</p> <code>1.0</code> <code>pickable</code> <code>bool</code> <p>Enable hover/click interactions.</p> <code>True</code> <code>auto_zoom</code> <code>bool</code> <p>Auto-zoom to point cloud after loading.</p> <code>True</code> <code>streaming_mode</code> <code>bool</code> <p>Use streaming mode for large COPC files.</p> <code>True</code> <code>point_budget</code> <code>int</code> <p>Maximum number of points to display.</p> <code>1000000</code> <code>**kwargs</code> <p>Additional layer options.</p> <code>{}</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from anymap_ts import MapboxMap\n&gt;&gt;&gt; m = MapboxMap(center=[-123.07, 44.05], zoom=14, pitch=60)\n&gt;&gt;&gt; m.add_lidar_layer(\n...     source=\"https://s3.amazonaws.com/hobu-lidar/autzen-classified.copc.laz\",\n...     name=\"autzen\",\n...     color_scheme=\"classification\",\n... )\n</code></pre> Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def add_lidar_layer(\n    self,\n    source: Union[str, Path],\n    name: Optional[str] = None,\n    color_scheme: str = \"elevation\",\n    point_size: float = 2,\n    opacity: float = 1.0,\n    pickable: bool = True,\n    auto_zoom: bool = True,\n    streaming_mode: bool = True,\n    point_budget: int = 1000000,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Load and display a LiDAR file from URL or local path.\n\n    Supports LAS, LAZ, and COPC (Cloud-Optimized Point Cloud) formats.\n    For local files, the file is read and sent as base64 to JavaScript.\n    For URLs, the data is loaded directly via streaming when possible.\n\n    Args:\n        source: URL or local file path to the LiDAR file.\n        name: Layer identifier. If None, auto-generated.\n        color_scheme: Color scheme ('elevation', 'intensity', 'classification', 'rgb').\n        point_size: Point size in pixels.\n        opacity: Layer opacity (0-1).\n        pickable: Enable hover/click interactions.\n        auto_zoom: Auto-zoom to point cloud after loading.\n        streaming_mode: Use streaming mode for large COPC files.\n        point_budget: Maximum number of points to display.\n        **kwargs: Additional layer options.\n\n    Example:\n        &gt;&gt;&gt; from anymap_ts import MapboxMap\n        &gt;&gt;&gt; m = MapboxMap(center=[-123.07, 44.05], zoom=14, pitch=60)\n        &gt;&gt;&gt; m.add_lidar_layer(\n        ...     source=\"https://s3.amazonaws.com/hobu-lidar/autzen-classified.copc.laz\",\n        ...     name=\"autzen\",\n        ...     color_scheme=\"classification\",\n        ... )\n    \"\"\"\n    import base64\n\n    layer_id = name or f\"lidar-{len(self._layers)}\"\n\n    # Check if source is a local file\n    source_path = Path(source) if isinstance(source, (str, Path)) else None\n    is_local = source_path is not None and source_path.exists()\n\n    if is_local:\n        # Read local file and encode as base64\n        with open(source_path, \"rb\") as f:\n            file_data = f.read()\n        source_b64 = base64.b64encode(file_data).decode(\"utf-8\")\n\n        self.call_js_method(\n            \"addLidarLayer\",\n            source=source_b64,\n            name=layer_id,\n            isBase64=True,\n            filename=source_path.name,\n            colorScheme=color_scheme,\n            pointSize=point_size,\n            opacity=opacity,\n            pickable=pickable,\n            autoZoom=auto_zoom,\n            streamingMode=streaming_mode,\n            pointBudget=point_budget,\n            **kwargs,\n        )\n    else:\n        # Load from URL\n        self.call_js_method(\n            \"addLidarLayer\",\n            source=str(source),\n            name=layer_id,\n            isBase64=False,\n            colorScheme=color_scheme,\n            pointSize=point_size,\n            opacity=opacity,\n            pickable=pickable,\n            autoZoom=auto_zoom,\n            streamingMode=streaming_mode,\n            pointBudget=point_budget,\n            **kwargs,\n        )\n\n    self._layers = {\n        **self._layers,\n        layer_id: {\n            \"id\": layer_id,\n            \"type\": \"lidar\",\n            \"source\": str(source),\n        },\n    }\n</code></pre>"},{"location":"mapbox/#anymap_ts.mapbox.MapboxMap.add_line_layer","title":"<code>add_line_layer(self, data, name=None, get_source_position='sourcePosition', get_target_position='targetPosition', get_color=None, get_width=1, width_min_pixels=1, pickable=True, opacity=0.8, **kwargs)</code>","text":"<p>Add a line layer using deck.gl.</p> Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def add_line_layer(\n    self,\n    data: Any,\n    name: Optional[str] = None,\n    get_source_position: Union[str, Any] = \"sourcePosition\",\n    get_target_position: Union[str, Any] = \"targetPosition\",\n    get_color: Optional[Union[List[int], str]] = None,\n    get_width: Union[float, str] = 1,\n    width_min_pixels: float = 1,\n    pickable: bool = True,\n    opacity: float = 0.8,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a line layer using deck.gl.\"\"\"\n    layer_id = name or f\"line-{len(self._layers)}\"\n    processed_data = self._process_deck_data(data)\n\n    self.call_js_method(\n        \"addLineLayer\",\n        id=layer_id,\n        data=processed_data,\n        getSourcePosition=get_source_position,\n        getTargetPosition=get_target_position,\n        getColor=get_color or [51, 136, 255, 200],\n        getWidth=get_width,\n        widthMinPixels=width_min_pixels,\n        pickable=pickable,\n        opacity=opacity,\n        **kwargs,\n    )\n\n    self._layers = {**self._layers, layer_id: {\"id\": layer_id, \"type\": \"line\"}}\n    self._add_to_layer_dict(layer_id, \"Deck.gl\")\n</code></pre>"},{"location":"mapbox/#anymap_ts.mapbox.MapboxMap.add_marker","title":"<code>add_marker(self, lng, lat, popup=None, tooltip=None, color='#3388ff', draggable=False, scale=1.0, popup_max_width='240px', tooltip_max_width='240px', name=None, **kwargs)</code>","text":"<p>Add a single marker to the map.</p> Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def add_marker(\n    self,\n    lng: float,\n    lat: float,\n    popup: Optional[str] = None,\n    tooltip: Optional[str] = None,\n    color: str = \"#3388ff\",\n    draggable: bool = False,\n    scale: float = 1.0,\n    popup_max_width: str = \"240px\",\n    tooltip_max_width: str = \"240px\",\n    name: Optional[str] = None,\n    **kwargs,\n) -&gt; str:\n    \"\"\"Add a single marker to the map.\"\"\"\n    marker_id = name or f\"marker-{len(self._layers)}\"\n\n    self.call_js_method(\n        \"addMarker\",\n        lng,\n        lat,\n        id=marker_id,\n        popup=popup,\n        tooltip=tooltip,\n        color=color,\n        draggable=draggable,\n        scale=scale,\n        popupMaxWidth=popup_max_width,\n        tooltipMaxWidth=tooltip_max_width,\n        **kwargs,\n    )\n\n    self._layers = {\n        **self._layers,\n        marker_id: {\n            \"id\": marker_id,\n            \"type\": \"marker\",\n            \"lngLat\": [lng, lat],\n        },\n    }\n    self._add_to_layer_dict(marker_id, \"Markers\")\n    return marker_id\n</code></pre>"},{"location":"mapbox/#anymap_ts.mapbox.MapboxMap.add_markers","title":"<code>add_markers(self, data, lng_column=None, lat_column=None, popup_column=None, tooltip_column=None, color='#3388ff', scale=1.0, popup_max_width='240px', tooltip_max_width='240px', draggable=False, name=None, **kwargs)</code>","text":"<p>Add multiple markers from data.</p> Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def add_markers(\n    self,\n    data: Any,\n    lng_column: Optional[str] = None,\n    lat_column: Optional[str] = None,\n    popup_column: Optional[str] = None,\n    tooltip_column: Optional[str] = None,\n    color: str = \"#3388ff\",\n    scale: float = 1.0,\n    popup_max_width: str = \"240px\",\n    tooltip_max_width: str = \"240px\",\n    draggable: bool = False,\n    name: Optional[str] = None,\n    **kwargs,\n) -&gt; str:\n    \"\"\"Add multiple markers from data.\"\"\"\n    layer_id = name or f\"markers-{len(self._layers)}\"\n    markers = []\n\n    if hasattr(data, \"geometry\"):\n        for _, row in data.iterrows():\n            geom = row.geometry\n            if geom.geom_type == \"Point\":\n                marker = {\"lngLat\": [geom.x, geom.y]}\n                if popup_column and popup_column in row:\n                    marker[\"popup\"] = str(row[popup_column])\n                if tooltip_column and tooltip_column in row:\n                    marker[\"tooltip\"] = str(row[tooltip_column])\n                markers.append(marker)\n    elif isinstance(data, dict) and data.get(\"type\") == \"FeatureCollection\":\n        for feature in data.get(\"features\", []):\n            geom = feature.get(\"geometry\", {})\n            if geom.get(\"type\") == \"Point\":\n                coords = geom.get(\"coordinates\", [])\n                marker = {\"lngLat\": coords[:2]}\n                props = feature.get(\"properties\", {})\n                if popup_column and popup_column in props:\n                    marker[\"popup\"] = str(props[popup_column])\n                if tooltip_column and tooltip_column in props:\n                    marker[\"tooltip\"] = str(props[tooltip_column])\n                markers.append(marker)\n    elif isinstance(data, list):\n        lng_keys = [\"lng\", \"lon\", \"longitude\", \"x\"]\n        lat_keys = [\"lat\", \"latitude\", \"y\"]\n\n        for item in data:\n            if not isinstance(item, dict):\n                continue\n\n            lng_val = None\n            lat_val = None\n\n            if lng_column and lng_column in item:\n                lng_val = item[lng_column]\n            else:\n                for key in lng_keys:\n                    if key in item:\n                        lng_val = item[key]\n                        break\n\n            if lat_column and lat_column in item:\n                lat_val = item[lat_column]\n            else:\n                for key in lat_keys:\n                    if key in item:\n                        lat_val = item[key]\n                        break\n\n            if lng_val is not None and lat_val is not None:\n                marker = {\"lngLat\": [float(lng_val), float(lat_val)]}\n                if popup_column and popup_column in item:\n                    marker[\"popup\"] = str(item[popup_column])\n                if tooltip_column and tooltip_column in item:\n                    marker[\"tooltip\"] = str(item[tooltip_column])\n                markers.append(marker)\n\n    if not markers:\n        raise ValueError(\"No valid point data found in input\")\n\n    self.call_js_method(\n        \"addMarkers\",\n        id=layer_id,\n        markers=markers,\n        color=color,\n        scale=scale,\n        popupMaxWidth=popup_max_width,\n        tooltipMaxWidth=tooltip_max_width,\n        draggable=draggable,\n        **kwargs,\n    )\n\n    self._layers = {\n        **self._layers,\n        layer_id: {\n            \"id\": layer_id,\n            \"type\": \"markers\",\n            \"count\": len(markers),\n        },\n    }\n    self._add_to_layer_dict(layer_id, \"Markers\")\n    return layer_id\n</code></pre>"},{"location":"mapbox/#anymap_ts.mapbox.MapboxMap.add_measure_control","title":"<code>add_measure_control(self, position='top-right', collapsed=True, default_mode='distance', distance_unit='kilometers', area_unit='square-kilometers', line_color='#3b82f6', fill_color='rgba(59, 130, 246, 0.2)', **kwargs)</code>","text":"<p>Add a measurement control.</p> Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def add_measure_control(\n    self,\n    position: str = \"top-right\",\n    collapsed: bool = True,\n    default_mode: str = \"distance\",\n    distance_unit: str = \"kilometers\",\n    area_unit: str = \"square-kilometers\",\n    line_color: str = \"#3b82f6\",\n    fill_color: str = \"rgba(59, 130, 246, 0.2)\",\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a measurement control.\"\"\"\n    self._validate_position(position)\n    self.call_js_method(\n        \"addMeasureControl\",\n        position=position,\n        collapsed=collapsed,\n        defaultMode=default_mode,\n        distanceUnit=distance_unit,\n        areaUnit=area_unit,\n        lineColor=line_color,\n        fillColor=fill_color,\n        **kwargs,\n    )\n    self._controls = {\n        **self._controls,\n        \"measure-control\": {\n            \"type\": \"measure-control\",\n            \"position\": position,\n            \"collapsed\": collapsed,\n        },\n    }\n</code></pre>"},{"location":"mapbox/#anymap_ts.mapbox.MapboxMap.add_opacity_slider","title":"<code>add_opacity_slider(self, layer_id, position='top-right', label=None)</code>","text":"<p>Add a UI slider to control layer opacity.</p> Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def add_opacity_slider(\n    self,\n    layer_id: str,\n    position: str = \"top-right\",\n    label: Optional[str] = None,\n) -&gt; None:\n    \"\"\"Add a UI slider to control layer opacity.\"\"\"\n    self.call_js_method(\n        \"addOpacitySlider\",\n        layerId=layer_id,\n        position=position,\n        label=label or layer_id,\n    )\n</code></pre>"},{"location":"mapbox/#anymap_ts.mapbox.MapboxMap.add_path_layer","title":"<code>add_path_layer(self, data, name=None, get_path='path', get_color=None, get_width=1, width_scale=1, width_min_pixels=1, pickable=True, opacity=0.8, **kwargs)</code>","text":"<p>Add a path layer using deck.gl.</p> Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def add_path_layer(\n    self,\n    data: Any,\n    name: Optional[str] = None,\n    get_path: Union[str, Any] = \"path\",\n    get_color: Optional[Union[List[int], str]] = None,\n    get_width: Union[float, str] = 1,\n    width_scale: float = 1,\n    width_min_pixels: float = 1,\n    pickable: bool = True,\n    opacity: float = 0.8,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a path layer using deck.gl.\"\"\"\n    layer_id = name or f\"path-{len(self._layers)}\"\n    processed_data = self._process_deck_data(data)\n\n    self.call_js_method(\n        \"addPathLayer\",\n        id=layer_id,\n        data=processed_data,\n        getPath=get_path,\n        getColor=get_color or [51, 136, 255, 200],\n        getWidth=get_width,\n        widthScale=width_scale,\n        widthMinPixels=width_min_pixels,\n        pickable=pickable,\n        opacity=opacity,\n        **kwargs,\n    )\n\n    self._layers = {**self._layers, layer_id: {\"id\": layer_id, \"type\": \"path\"}}\n    self._add_to_layer_dict(layer_id, \"Deck.gl\")\n</code></pre>"},{"location":"mapbox/#anymap_ts.mapbox.MapboxMap.add_pmtiles_control","title":"<code>add_pmtiles_control(self, position='top-right', collapsed=True, default_url=None, load_default_url=False, default_opacity=1.0, default_fill_color='steelblue', default_line_color='#333', default_pickable=True, **kwargs)</code>","text":"<p>Add a PMTiles layer control.</p> Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def add_pmtiles_control(\n    self,\n    position: str = \"top-right\",\n    collapsed: bool = True,\n    default_url: Optional[str] = None,\n    load_default_url: bool = False,\n    default_opacity: float = 1.0,\n    default_fill_color: str = \"steelblue\",\n    default_line_color: str = \"#333\",\n    default_pickable: bool = True,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a PMTiles layer control.\"\"\"\n    self.call_js_method(\n        \"addPMTilesControl\",\n        position=position,\n        collapsed=collapsed,\n        defaultUrl=default_url or \"\",\n        loadDefaultUrl=load_default_url,\n        defaultOpacity=default_opacity,\n        defaultFillColor=default_fill_color,\n        defaultLineColor=default_line_color,\n        defaultPickable=default_pickable,\n        **kwargs,\n    )\n    self._controls = {\n        **self._controls,\n        \"pmtiles-control\": {\"position\": position, \"collapsed\": collapsed},\n    }\n</code></pre>"},{"location":"mapbox/#anymap_ts.mapbox.MapboxMap.add_pmtiles_layer","title":"<code>add_pmtiles_layer(self, url, layer_id=None, style=None, opacity=1.0, visible=True, fit_bounds=False, source_type='vector', **kwargs)</code>","text":"<p>Add a PMTiles layer for efficient vector or raster tile serving.</p> Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def add_pmtiles_layer(\n    self,\n    url: str,\n    layer_id: Optional[str] = None,\n    style: Optional[Dict[str, Any]] = None,\n    opacity: float = 1.0,\n    visible: bool = True,\n    fit_bounds: bool = False,\n    source_type: str = \"vector\",\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a PMTiles layer for efficient vector or raster tile serving.\"\"\"\n    layer_id = layer_id or f\"pmtiles-{len(self._layers)}\"\n\n    self.call_js_method(\n        \"addPMTilesLayer\",\n        url=url,\n        id=layer_id,\n        style=style or {},\n        opacity=opacity,\n        visible=visible,\n        fitBounds=fit_bounds,\n        sourceType=source_type,\n        name=layer_id,\n        **kwargs,\n    )\n\n    self._layers = {\n        **self._layers,\n        layer_id: {\n            \"id\": layer_id,\n            \"type\": \"pmtiles\",\n            \"url\": url,\n            \"source_type\": source_type,\n        },\n    }\n    category = \"Vector\" if source_type == \"vector\" else \"Raster\"\n    self._add_to_layer_dict(layer_id, category)\n</code></pre>"},{"location":"mapbox/#anymap_ts.mapbox.MapboxMap.add_point_cloud_layer","title":"<code>add_point_cloud_layer(self, data, name=None, get_position='position', get_color=None, get_normal=None, point_size=2, size_units='pixels', pickable=True, opacity=1.0, material=True, coordinate_system=None, coordinate_origin=None, **kwargs)</code>","text":"<p>Add a point cloud layer for 3D point visualization using deck.gl.</p> <p>Point cloud layers render large collections of 3D points, ideal for LiDAR data, photogrammetry outputs, or any 3D point dataset.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>Array of point data with positions. Each point should have x, y, z coordinates (or position array).</p> required <code>name</code> <code>Optional[str]</code> <p>Layer ID. If None, auto-generated.</p> <code>None</code> <code>get_position</code> <code>Union[str, Any]</code> <p>Accessor for point position [x, y, z]. Can be a string (property name) or a value.</p> <code>'position'</code> <code>get_color</code> <code>Optional[Union[List[int], str]]</code> <p>Accessor or value for point color [r, g, b, a]. Default: [255, 255, 255, 255] (white).</p> <code>None</code> <code>get_normal</code> <code>Optional[Union[str, Any]]</code> <p>Accessor for point normal [nx, ny, nz] for lighting. Default: [0, 0, 1] (pointing up).</p> <code>None</code> <code>point_size</code> <code>float</code> <p>Point size in pixels or meters (depends on size_units).</p> <code>2</code> <code>size_units</code> <code>str</code> <p>Size units: 'pixels', 'meters', or 'common'.</p> <code>'pixels'</code> <code>pickable</code> <code>bool</code> <p>Whether layer responds to hover/click events.</p> <code>True</code> <code>opacity</code> <code>float</code> <p>Layer opacity (0-1).</p> <code>1.0</code> <code>material</code> <code>bool</code> <p>Whether to enable lighting effects.</p> <code>True</code> <code>coordinate_system</code> <code>Optional[int]</code> <p>Coordinate system for positions.</p> <code>None</code> <code>coordinate_origin</code> <code>Optional[List[float]]</code> <p>Origin for coordinate system [x, y, z].</p> <code>None</code> <code>**kwargs</code> <p>Additional PointCloudLayer props.</p> <code>{}</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from anymap_ts import MapboxMap\n&gt;&gt;&gt; m = MapboxMap(pitch=45)\n&gt;&gt;&gt; points = [\n...     {\"position\": [-122.4, 37.8, 100], \"color\": [255, 0, 0, 255]},\n...     {\"position\": [-122.3, 37.7, 200], \"color\": [0, 255, 0, 255]},\n... ]\n&gt;&gt;&gt; m.add_point_cloud_layer(points, point_size=5)\n</code></pre> Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def add_point_cloud_layer(\n    self,\n    data: Any,\n    name: Optional[str] = None,\n    get_position: Union[str, Any] = \"position\",\n    get_color: Optional[Union[List[int], str]] = None,\n    get_normal: Optional[Union[str, Any]] = None,\n    point_size: float = 2,\n    size_units: str = \"pixels\",\n    pickable: bool = True,\n    opacity: float = 1.0,\n    material: bool = True,\n    coordinate_system: Optional[int] = None,\n    coordinate_origin: Optional[List[float]] = None,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a point cloud layer for 3D point visualization using deck.gl.\n\n    Point cloud layers render large collections of 3D points, ideal for\n    LiDAR data, photogrammetry outputs, or any 3D point dataset.\n\n    Args:\n        data: Array of point data with positions. Each point should have\n            x, y, z coordinates (or position array).\n        name: Layer ID. If None, auto-generated.\n        get_position: Accessor for point position [x, y, z].\n            Can be a string (property name) or a value.\n        get_color: Accessor or value for point color [r, g, b, a].\n            Default: [255, 255, 255, 255] (white).\n        get_normal: Accessor for point normal [nx, ny, nz] for lighting.\n            Default: [0, 0, 1] (pointing up).\n        point_size: Point size in pixels or meters (depends on size_units).\n        size_units: Size units: 'pixels', 'meters', or 'common'.\n        pickable: Whether layer responds to hover/click events.\n        opacity: Layer opacity (0-1).\n        material: Whether to enable lighting effects.\n        coordinate_system: Coordinate system for positions.\n        coordinate_origin: Origin for coordinate system [x, y, z].\n        **kwargs: Additional PointCloudLayer props.\n\n    Example:\n        &gt;&gt;&gt; from anymap_ts import MapboxMap\n        &gt;&gt;&gt; m = MapboxMap(pitch=45)\n        &gt;&gt;&gt; points = [\n        ...     {\"position\": [-122.4, 37.8, 100], \"color\": [255, 0, 0, 255]},\n        ...     {\"position\": [-122.3, 37.7, 200], \"color\": [0, 255, 0, 255]},\n        ... ]\n        &gt;&gt;&gt; m.add_point_cloud_layer(points, point_size=5)\n    \"\"\"\n    layer_id = name or f\"pointcloud-{len(self._layers)}\"\n    processed_data = self._process_deck_data(data)\n\n    self.call_js_method(\n        \"addPointCloudLayer\",\n        id=layer_id,\n        data=processed_data,\n        getPosition=get_position,\n        getColor=get_color or [255, 255, 255, 255],\n        getNormal=get_normal,\n        pointSize=point_size,\n        sizeUnits=size_units,\n        pickable=pickable,\n        opacity=opacity,\n        material=material,\n        coordinateSystem=coordinate_system,\n        coordinateOrigin=coordinate_origin,\n        **kwargs,\n    )\n\n    self._layers = {\n        **self._layers,\n        layer_id: {\n            \"id\": layer_id,\n            \"type\": \"pointcloud\",\n        },\n    }\n    self._add_to_layer_dict(layer_id, \"Deck.gl\")\n</code></pre>"},{"location":"mapbox/#anymap_ts.mapbox.MapboxMap.add_polygon_layer","title":"<code>add_polygon_layer(self, data, name=None, get_polygon='polygon', get_fill_color=None, get_line_color=None, get_line_width=1, get_elevation=0, extruded=False, wireframe=False, filled=True, stroked=True, line_width_min_pixels=1, pickable=True, opacity=0.5, **kwargs)</code>","text":"<p>Add a polygon layer using deck.gl.</p> Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def add_polygon_layer(\n    self,\n    data: Any,\n    name: Optional[str] = None,\n    get_polygon: Union[str, Any] = \"polygon\",\n    get_fill_color: Optional[Union[List[int], str]] = None,\n    get_line_color: Optional[Union[List[int], str]] = None,\n    get_line_width: Union[float, str] = 1,\n    get_elevation: Union[float, str] = 0,\n    extruded: bool = False,\n    wireframe: bool = False,\n    filled: bool = True,\n    stroked: bool = True,\n    line_width_min_pixels: float = 1,\n    pickable: bool = True,\n    opacity: float = 0.5,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a polygon layer using deck.gl.\"\"\"\n    layer_id = name or f\"polygon-{len(self._layers)}\"\n    processed_data = self._process_deck_data(data)\n\n    self.call_js_method(\n        \"addPolygonLayer\",\n        id=layer_id,\n        data=processed_data,\n        getPolygon=get_polygon,\n        getFillColor=get_fill_color or [51, 136, 255, 128],\n        getLineColor=get_line_color or [0, 0, 255, 255],\n        getLineWidth=get_line_width,\n        getElevation=get_elevation,\n        extruded=extruded,\n        wireframe=wireframe,\n        filled=filled,\n        stroked=stroked,\n        lineWidthMinPixels=line_width_min_pixels,\n        pickable=pickable,\n        opacity=opacity,\n        **kwargs,\n    )\n\n    self._layers = {**self._layers, layer_id: {\"id\": layer_id, \"type\": \"polygon\"}}\n    self._add_to_layer_dict(layer_id, \"Deck.gl\")\n</code></pre>"},{"location":"mapbox/#anymap_ts.mapbox.MapboxMap.add_popup","title":"<code>add_popup(self, layer_id, properties=None, template=None, **kwargs)</code>","text":"<p>Add popup on click for a layer.</p> Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def add_popup(\n    self,\n    layer_id: str,\n    properties: Optional[List[str]] = None,\n    template: Optional[str] = None,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add popup on click for a layer.\"\"\"\n    self.call_js_method(\n        \"addPopup\",\n        layerId=layer_id,\n        properties=properties,\n        template=template,\n        **kwargs,\n    )\n</code></pre>"},{"location":"mapbox/#anymap_ts.mapbox.MapboxMap.add_print_control","title":"<code>add_print_control(self, position='top-right', collapsed=True, format='png', filename='map-export', include_north_arrow=False, include_scale_bar=False, **kwargs)</code>","text":"<p>Add a print/export control.</p> Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def add_print_control(\n    self,\n    position: str = \"top-right\",\n    collapsed: bool = True,\n    format: str = \"png\",\n    filename: str = \"map-export\",\n    include_north_arrow: bool = False,\n    include_scale_bar: bool = False,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a print/export control.\"\"\"\n    self._validate_position(position)\n    self.call_js_method(\n        \"addPrintControl\",\n        position=position,\n        collapsed=collapsed,\n        format=format,\n        filename=filename,\n        includeNorthArrow=include_north_arrow,\n        includeScaleBar=include_scale_bar,\n        **kwargs,\n    )\n    self._controls = {\n        **self._controls,\n        \"print-control\": {\n            \"type\": \"print-control\",\n            \"position\": position,\n            \"collapsed\": collapsed,\n        },\n    }\n</code></pre>"},{"location":"mapbox/#anymap_ts.mapbox.MapboxMap.add_raster","title":"<code>add_raster(self, source, name=None, attribution='', indexes=None, colormap=None, vmin=None, vmax=None, nodata=None, fit_bounds=True, **kwargs)</code>","text":"<p>Add a raster layer from a local file using localtileserver.</p> Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def add_raster(\n    self,\n    source: str,\n    name: Optional[str] = None,\n    attribution: str = \"\",\n    indexes: Optional[List[int]] = None,\n    colormap: Optional[str] = None,\n    vmin: Optional[float] = None,\n    vmax: Optional[float] = None,\n    nodata: Optional[float] = None,\n    fit_bounds: bool = True,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a raster layer from a local file using localtileserver.\"\"\"\n    try:\n        from localtileserver import TileClient\n    except ImportError:\n        raise ImportError(\n            \"localtileserver is required for local raster support. \"\n            \"Install with: pip install anymap-ts[raster]\"\n        )\n\n    client = TileClient(source)\n\n    tile_params = {}\n    if indexes:\n        tile_params[\"indexes\"] = indexes\n    if colormap:\n        tile_params[\"colormap\"] = colormap\n    if vmin is not None or vmax is not None:\n        tile_params[\"vmin\"] = vmin if vmin is not None else client.min\n        tile_params[\"vmax\"] = vmax if vmax is not None else client.max\n    if nodata is not None:\n        tile_params[\"nodata\"] = nodata\n\n    tile_url = client.get_tile_url(**tile_params)\n\n    layer_name = name or Path(source).stem\n\n    self.add_tile_layer(\n        tile_url,\n        name=layer_name,\n        attribution=attribution,\n        **kwargs,\n    )\n\n    if fit_bounds:\n        bounds = client.bounds()\n        if bounds:\n            self.fit_bounds([bounds[0], bounds[1], bounds[2], bounds[3]])\n</code></pre>"},{"location":"mapbox/#anymap_ts.mapbox.MapboxMap.add_scatterplot_layer","title":"<code>add_scatterplot_layer(self, data, name=None, get_position='coordinates', get_radius=5, get_fill_color=None, get_line_color=None, radius_scale=1, radius_min_pixels=1, radius_max_pixels=100, line_width_min_pixels=1, stroked=True, filled=True, pickable=True, opacity=0.8, **kwargs)</code>","text":"<p>Add a scatterplot layer using deck.gl.</p> Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def add_scatterplot_layer(\n    self,\n    data: Any,\n    name: Optional[str] = None,\n    get_position: Union[str, Any] = \"coordinates\",\n    get_radius: Union[float, str] = 5,\n    get_fill_color: Optional[Union[List[int], str]] = None,\n    get_line_color: Optional[Union[List[int], str]] = None,\n    radius_scale: float = 1,\n    radius_min_pixels: float = 1,\n    radius_max_pixels: float = 100,\n    line_width_min_pixels: float = 1,\n    stroked: bool = True,\n    filled: bool = True,\n    pickable: bool = True,\n    opacity: float = 0.8,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a scatterplot layer using deck.gl.\"\"\"\n    layer_id = name or f\"scatterplot-{len(self._layers)}\"\n    processed_data = self._process_deck_data(data)\n\n    self.call_js_method(\n        \"addScatterplotLayer\",\n        id=layer_id,\n        data=processed_data,\n        getPosition=get_position,\n        getRadius=get_radius,\n        getFillColor=get_fill_color or [51, 136, 255, 200],\n        getLineColor=get_line_color or [255, 255, 255, 255],\n        radiusScale=radius_scale,\n        radiusMinPixels=radius_min_pixels,\n        radiusMaxPixels=radius_max_pixels,\n        lineWidthMinPixels=line_width_min_pixels,\n        stroked=stroked,\n        filled=filled,\n        pickable=pickable,\n        opacity=opacity,\n        **kwargs,\n    )\n\n    self._layers = {\n        **self._layers,\n        layer_id: {\"id\": layer_id, \"type\": \"scatterplot\"},\n    }\n    self._add_to_layer_dict(layer_id, \"Deck.gl\")\n</code></pre>"},{"location":"mapbox/#anymap_ts.mapbox.MapboxMap.add_screen_grid_layer","title":"<code>add_screen_grid_layer(self, data, name=None, get_position='coordinates', get_weight=1, cell_size_pixels=50, color_range=None, pickable=True, opacity=0.8, **kwargs)</code>","text":"<p>Add a screen grid layer using deck.gl.</p> Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def add_screen_grid_layer(\n    self,\n    data: Any,\n    name: Optional[str] = None,\n    get_position: Union[str, Any] = \"coordinates\",\n    get_weight: Union[float, str] = 1,\n    cell_size_pixels: float = 50,\n    color_range: Optional[List[List[int]]] = None,\n    pickable: bool = True,\n    opacity: float = 0.8,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a screen grid layer using deck.gl.\"\"\"\n    layer_id = name or f\"screengrid-{len(self._layers)}\"\n    processed_data = self._process_deck_data(data)\n\n    default_color_range = [\n        [255, 255, 178, 25],\n        [254, 217, 118, 85],\n        [254, 178, 76, 127],\n        [253, 141, 60, 170],\n        [240, 59, 32, 212],\n        [189, 0, 38, 255],\n    ]\n\n    self.call_js_method(\n        \"addScreenGridLayer\",\n        id=layer_id,\n        data=processed_data,\n        getPosition=get_position,\n        getWeight=get_weight,\n        cellSizePixels=cell_size_pixels,\n        colorRange=color_range or default_color_range,\n        pickable=pickable,\n        opacity=opacity,\n        **kwargs,\n    )\n\n    self._layers = {\n        **self._layers,\n        layer_id: {\"id\": layer_id, \"type\": \"screengrid\"},\n    }\n    self._add_to_layer_dict(layer_id, \"Deck.gl\")\n</code></pre>"},{"location":"mapbox/#anymap_ts.mapbox.MapboxMap.add_search_control","title":"<code>add_search_control(self, position='top-left', placeholder='Search places...', collapsed=True, fly_to_zoom=14, show_marker=True, marker_color='#4264fb', **kwargs)</code>","text":"<p>Add a search/geocoder control.</p> Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def add_search_control(\n    self,\n    position: str = \"top-left\",\n    placeholder: str = \"Search places...\",\n    collapsed: bool = True,\n    fly_to_zoom: int = 14,\n    show_marker: bool = True,\n    marker_color: str = \"#4264fb\",\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a search/geocoder control.\"\"\"\n    self._validate_position(position)\n    self.call_js_method(\n        \"addSearchControl\",\n        position=position,\n        placeholder=placeholder,\n        collapsed=collapsed,\n        flyToZoom=fly_to_zoom,\n        showMarker=show_marker,\n        markerColor=marker_color,\n        **kwargs,\n    )\n    self._controls = {\n        **self._controls,\n        \"search-control\": {\n            \"type\": \"search-control\",\n            \"position\": position,\n            \"collapsed\": collapsed,\n        },\n    }\n</code></pre>"},{"location":"mapbox/#anymap_ts.mapbox.MapboxMap.add_solid_polygon_layer","title":"<code>add_solid_polygon_layer(self, data, name=None, get_polygon='polygon', get_fill_color=None, get_line_color=None, get_elevation=0, filled=True, extruded=False, wireframe=False, elevation_scale=1, pickable=True, opacity=0.8, **kwargs)</code>","text":"<p>Add a solid polygon layer using deck.gl.</p> Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def add_solid_polygon_layer(\n    self,\n    data: Any,\n    name: Optional[str] = None,\n    get_polygon: Union[str, Any] = \"polygon\",\n    get_fill_color: Optional[Union[List[int], str]] = None,\n    get_line_color: Optional[Union[List[int], str]] = None,\n    get_elevation: Union[float, str] = 0,\n    filled: bool = True,\n    extruded: bool = False,\n    wireframe: bool = False,\n    elevation_scale: float = 1,\n    pickable: bool = True,\n    opacity: float = 0.8,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a solid polygon layer using deck.gl.\"\"\"\n    layer_id = name or f\"solidpolygon-{len(self._layers)}\"\n    processed_data = self._process_deck_data(data)\n\n    self.call_js_method(\n        \"addSolidPolygonLayer\",\n        id=layer_id,\n        data=processed_data,\n        getPolygon=get_polygon,\n        getFillColor=get_fill_color or [51, 136, 255, 128],\n        getLineColor=get_line_color or [0, 0, 0, 255],\n        getElevation=get_elevation,\n        filled=filled,\n        extruded=extruded,\n        wireframe=wireframe,\n        elevationScale=elevation_scale,\n        pickable=pickable,\n        opacity=opacity,\n        **kwargs,\n    )\n\n    self._layers = {\n        **self._layers,\n        layer_id: {\"id\": layer_id, \"type\": \"solidpolygon\"},\n    }\n    self._add_to_layer_dict(layer_id, \"Deck.gl\")\n</code></pre>"},{"location":"mapbox/#anymap_ts.mapbox.MapboxMap.add_split_map","title":"<code>add_split_map(self, left_layer, right_layer, position=50)</code>","text":"<p>Add a split map comparison view with a draggable divider.</p> Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def add_split_map(\n    self,\n    left_layer: str,\n    right_layer: str,\n    position: int = 50,\n) -&gt; None:\n    \"\"\"Add a split map comparison view with a draggable divider.\"\"\"\n    if not 0 &lt;= position &lt;= 100:\n        raise ValueError(f\"position must be between 0 and 100, got {position}\")\n\n    self.call_js_method(\n        \"addSplitMap\",\n        leftLayer=left_layer,\n        rightLayer=right_layer,\n        position=position,\n    )\n</code></pre>"},{"location":"mapbox/#anymap_ts.mapbox.MapboxMap.add_stac_layer","title":"<code>add_stac_layer(self, url=None, item=None, assets=None, colormap=None, rescale=None, opacity=1.0, layer_id=None, titiler_endpoint='https://titiler.xyz', attribution='STAC', fit_bounds=True, **kwargs)</code>","text":"<p>Add a STAC (SpatioTemporal Asset Catalog) layer to the map.</p> Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def add_stac_layer(\n    self,\n    url: Optional[str] = None,\n    item: Optional[Any] = None,\n    assets: Optional[List[str]] = None,\n    colormap: Optional[str] = None,\n    rescale: Optional[List[float]] = None,\n    opacity: float = 1.0,\n    layer_id: Optional[str] = None,\n    titiler_endpoint: str = \"https://titiler.xyz\",\n    attribution: str = \"STAC\",\n    fit_bounds: bool = True,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a STAC (SpatioTemporal Asset Catalog) layer to the map.\"\"\"\n    if url is None and item is None:\n        raise ValueError(\"Either 'url' or 'item' must be provided\")\n\n    if url is not None and item is not None:\n        raise ValueError(\"Provide either 'url' or 'item', not both\")\n\n    if item is not None:\n        try:\n            if hasattr(item, \"to_dict\") and hasattr(item, \"self_href\"):\n                stac_url = item.self_href\n                if not stac_url and hasattr(item, \"links\"):\n                    for link in item.links:\n                        if link.rel == \"self\":\n                            stac_url = link.href\n                            break\n                if not stac_url:\n                    raise ValueError(\"STAC item must have a self_href or self link\")\n            else:\n                raise ValueError(\n                    \"Item must be a pystac Item object with to_dict() and self_href\"\n                )\n        except Exception as e:\n            raise ValueError(f\"Invalid STAC item: {e}\")\n    else:\n        stac_url = url\n\n    tile_params = {\"url\": stac_url}\n    if assets:\n        tile_params[\"assets\"] = \",\".join(assets)\n    if colormap:\n        tile_params[\"colormap_name\"] = colormap\n    if rescale:\n        if len(rescale) == 2:\n            tile_params[\"rescale\"] = f\"{rescale[0]},{rescale[1]}\"\n        else:\n            raise ValueError(\"rescale must be a list of two values [min, max]\")\n\n    query_string = urlencode(tile_params)\n    tile_url = f\"{titiler_endpoint.rstrip('/')}/stac/tiles/{{z}}/{{x}}/{{y}}?{query_string}\"\n\n    layer_name = layer_id or f\"stac-{len(self._layers)}\"\n\n    self.add_tile_layer(\n        url=tile_url,\n        name=layer_name,\n        attribution=attribution,\n        **kwargs,\n    )\n\n    if fit_bounds and item is not None:\n        try:\n            bbox = item.bbox\n            if bbox and len(bbox) == 4:\n                self.fit_bounds([[bbox[0], bbox[1]], [bbox[2], bbox[3]]])\n        except Exception:\n            pass\n</code></pre>"},{"location":"mapbox/#anymap_ts.mapbox.MapboxMap.add_style_switcher","title":"<code>add_style_switcher(self, styles, position='top-right')</code>","text":"<p>Add a dropdown to switch between map styles.</p> Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def add_style_switcher(\n    self,\n    styles: Dict[str, str],\n    position: str = \"top-right\",\n) -&gt; None:\n    \"\"\"Add a dropdown to switch between map styles.\"\"\"\n    self.call_js_method(\n        \"addStyleSwitcher\",\n        styles=styles,\n        position=position,\n    )\n</code></pre>"},{"location":"mapbox/#anymap_ts.mapbox.MapboxMap.add_swipe_map","title":"<code>add_swipe_map(self, left_layer, right_layer)</code>","text":"<p>Add a drag-to-compare swipe control for two layers.</p> Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def add_swipe_map(self, left_layer: str, right_layer: str) -&gt; None:\n    \"\"\"Add a drag-to-compare swipe control for two layers.\"\"\"\n    self.call_js_method(\n        \"addSwipeMap\",\n        leftLayer=left_layer,\n        rightLayer=right_layer,\n    )\n</code></pre>"},{"location":"mapbox/#anymap_ts.mapbox.MapboxMap.add_terrain","title":"<code>add_terrain(self, exaggeration=1.0, source='mapbox-dem')</code>","text":"<p>Add 3D terrain to the map.</p> <p>Parameters:</p> Name Type Description Default <code>exaggeration</code> <code>float</code> <p>Terrain exaggeration factor.</p> <code>1.0</code> <code>source</code> <code>str</code> <p>Terrain source ID.</p> <code>'mapbox-dem'</code> Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def add_terrain(\n    self, exaggeration: float = 1.0, source: str = \"mapbox-dem\"\n) -&gt; None:\n    \"\"\"Add 3D terrain to the map.\n\n    Args:\n        exaggeration: Terrain exaggeration factor.\n        source: Terrain source ID.\n    \"\"\"\n    self.call_js_method(\"addTerrain\", source=source, exaggeration=exaggeration)\n</code></pre>"},{"location":"mapbox/#anymap_ts.mapbox.MapboxMap.add_text_layer","title":"<code>add_text_layer(self, data, name=None, get_position='coordinates', get_text='text', get_size=12, get_color=None, get_angle=0, text_anchor='middle', alignment_baseline='center', pickable=True, opacity=1, **kwargs)</code>","text":"<p>Add a text layer using deck.gl.</p> Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def add_text_layer(\n    self,\n    data: Any,\n    name: Optional[str] = None,\n    get_position: Union[str, Any] = \"coordinates\",\n    get_text: Union[str, Any] = \"text\",\n    get_size: Union[float, str] = 12,\n    get_color: Optional[Union[List[int], str]] = None,\n    get_angle: Union[float, str] = 0,\n    text_anchor: str = \"middle\",\n    alignment_baseline: str = \"center\",\n    pickable: bool = True,\n    opacity: float = 1,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a text layer using deck.gl.\"\"\"\n    layer_id = name or f\"text-{len(self._layers)}\"\n    processed_data = self._process_deck_data(data)\n\n    self.call_js_method(\n        \"addTextLayer\",\n        id=layer_id,\n        data=processed_data,\n        getPosition=get_position,\n        getText=get_text,\n        getSize=get_size,\n        getColor=get_color or [0, 0, 0, 255],\n        getAngle=get_angle,\n        getTextAnchor=text_anchor,\n        getAlignmentBaseline=alignment_baseline,\n        pickable=pickable,\n        opacity=opacity,\n        **kwargs,\n    )\n\n    self._layers = {**self._layers, layer_id: {\"id\": layer_id, \"type\": \"text\"}}\n    self._add_to_layer_dict(layer_id, \"Deck.gl\")\n</code></pre>"},{"location":"mapbox/#anymap_ts.mapbox.MapboxMap.add_tile_layer","title":"<code>add_tile_layer(self, url, name=None, attribution='', min_zoom=0, max_zoom=22, **kwargs)</code>","text":"<p>Add an XYZ tile layer.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>Tile URL template with {x}, {y}, {z} placeholders.</p> required <code>name</code> <code>Optional[str]</code> <p>Layer name.</p> <code>None</code> <code>attribution</code> <code>str</code> <p>Attribution text.</p> <code>''</code> <code>min_zoom</code> <code>int</code> <p>Minimum zoom level.</p> <code>0</code> <code>max_zoom</code> <code>int</code> <p>Maximum zoom level.</p> <code>22</code> <code>**kwargs</code> <p>Additional options.</p> <code>{}</code> Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def add_tile_layer(\n    self,\n    url: str,\n    name: Optional[str] = None,\n    attribution: str = \"\",\n    min_zoom: int = 0,\n    max_zoom: int = 22,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add an XYZ tile layer.\n\n    Args:\n        url: Tile URL template with {x}, {y}, {z} placeholders.\n        name: Layer name.\n        attribution: Attribution text.\n        min_zoom: Minimum zoom level.\n        max_zoom: Maximum zoom level.\n        **kwargs: Additional options.\n    \"\"\"\n    layer_id = name or f\"tiles-{len(self._layers)}\"\n\n    self.call_js_method(\n        \"addTileLayer\",\n        url,\n        name=layer_id,\n        attribution=attribution,\n        minZoom=min_zoom,\n        maxZoom=max_zoom,\n        **kwargs,\n    )\n\n    # Track layer\n    self._layers = {\n        **self._layers,\n        layer_id: {\n            \"id\": layer_id,\n            \"type\": \"raster\",\n            \"source\": f\"{layer_id}-source\",\n        },\n    }\n    self._add_to_layer_dict(layer_id, \"Raster\")\n</code></pre>"},{"location":"mapbox/#anymap_ts.mapbox.MapboxMap.add_time_slider","title":"<code>add_time_slider(self, layer_id, property, min_value=0, max_value=100, step=1, position='bottom-left', label='Time', auto_play=False, interval=500)</code>","text":"<p>Add a time slider to filter data by a temporal property.</p> Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def add_time_slider(\n    self,\n    layer_id: str,\n    property: str,\n    min_value: float = 0,\n    max_value: float = 100,\n    step: float = 1,\n    position: str = \"bottom-left\",\n    label: str = \"Time\",\n    auto_play: bool = False,\n    interval: int = 500,\n) -&gt; None:\n    \"\"\"Add a time slider to filter data by a temporal property.\"\"\"\n    self.call_js_method(\n        \"addTimeSlider\",\n        layerId=layer_id,\n        property=property,\n        min=min_value,\n        max=max_value,\n        step=step,\n        position=position,\n        label=label,\n        autoPlay=auto_play,\n        interval=interval,\n    )\n</code></pre>"},{"location":"mapbox/#anymap_ts.mapbox.MapboxMap.add_tooltip","title":"<code>add_tooltip(self, layer_id, template=None, properties=None)</code>","text":"<p>Add a tooltip that shows on feature hover.</p> Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def add_tooltip(\n    self,\n    layer_id: str,\n    template: Optional[str] = None,\n    properties: Optional[List[str]] = None,\n) -&gt; None:\n    \"\"\"Add a tooltip that shows on feature hover.\"\"\"\n    self.call_js_method(\n        \"addTooltip\",\n        layerId=layer_id,\n        template=template or \"\",\n        properties=properties,\n    )\n</code></pre>"},{"location":"mapbox/#anymap_ts.mapbox.MapboxMap.add_trips_layer","title":"<code>add_trips_layer(self, data, name=None, get_path='waypoints', get_timestamps='timestamps', get_color=None, width_min_pixels=2, trail_length=180, current_time=0, pickable=True, opacity=0.8, **kwargs)</code>","text":"<p>Add a trips layer using deck.gl.</p> Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def add_trips_layer(\n    self,\n    data: Any,\n    name: Optional[str] = None,\n    get_path: Union[str, Any] = \"waypoints\",\n    get_timestamps: Union[str, Any] = \"timestamps\",\n    get_color: Optional[Union[List[int], str]] = None,\n    width_min_pixels: float = 2,\n    trail_length: float = 180,\n    current_time: float = 0,\n    pickable: bool = True,\n    opacity: float = 0.8,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a trips layer using deck.gl.\"\"\"\n    layer_id = name or f\"trips-{len(self._layers)}\"\n    processed_data = self._process_deck_data(data)\n\n    self.call_js_method(\n        \"addTripsLayer\",\n        id=layer_id,\n        data=processed_data,\n        getPath=get_path,\n        getTimestamps=get_timestamps,\n        getColor=get_color or [253, 128, 93],\n        widthMinPixels=width_min_pixels,\n        trailLength=trail_length,\n        currentTime=current_time,\n        pickable=pickable,\n        opacity=opacity,\n        **kwargs,\n    )\n\n    self._layers = {**self._layers, layer_id: {\"id\": layer_id, \"type\": \"trips\"}}\n    self._add_to_layer_dict(layer_id, \"Deck.gl\")\n</code></pre>"},{"location":"mapbox/#anymap_ts.mapbox.MapboxMap.add_vector","title":"<code>add_vector(self, data, layer_type=None, paint=None, name=None, fit_bounds=True, **kwargs)</code>","text":"<p>Add vector data to the map.</p> <p>Supports GeoJSON, GeoDataFrame, or file paths to vector formats.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>GeoJSON dict, GeoDataFrame, or path to vector file.</p> required <code>layer_type</code> <code>Optional[str]</code> <p>Mapbox layer type ('circle', 'line', 'fill', 'symbol').</p> <code>None</code> <code>paint</code> <code>Optional[Dict]</code> <p>Mapbox paint properties.</p> <code>None</code> <code>name</code> <code>Optional[str]</code> <p>Layer name.</p> <code>None</code> <code>fit_bounds</code> <code>bool</code> <p>Whether to fit map to data bounds.</p> <code>True</code> <code>**kwargs</code> <p>Additional layer options.</p> <code>{}</code> Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def add_vector(\n    self,\n    data: Any,\n    layer_type: Optional[str] = None,\n    paint: Optional[Dict] = None,\n    name: Optional[str] = None,\n    fit_bounds: bool = True,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add vector data to the map.\n\n    Supports GeoJSON, GeoDataFrame, or file paths to vector formats.\n\n    Args:\n        data: GeoJSON dict, GeoDataFrame, or path to vector file.\n        layer_type: Mapbox layer type ('circle', 'line', 'fill', 'symbol').\n        paint: Mapbox paint properties.\n        name: Layer name.\n        fit_bounds: Whether to fit map to data bounds.\n        **kwargs: Additional layer options.\n    \"\"\"\n    geojson = to_geojson(data)\n\n    layer_id = name or f\"vector-{len(self._layers)}\"\n\n    # Handle URL data - fetch GeoJSON to get bounds and infer layer type\n    if geojson.get(\"type\") == \"url\":\n        url = geojson[\"url\"]\n        geojson = fetch_geojson(url)\n\n    # Infer layer type if not specified\n    if layer_type is None:\n        layer_type = infer_layer_type(geojson)\n\n    # Get default paint if not provided\n    if paint is None:\n        paint = get_default_paint(layer_type)\n\n    # Get bounds (use geojson dict, not original data which may be a URL)\n    bounds = get_bounds(geojson) if fit_bounds else None\n\n    # Call JavaScript\n    self.call_js_method(\n        \"addGeoJSON\",\n        data=geojson,\n        name=layer_id,\n        layerType=layer_type,\n        paint=paint,\n        fitBounds=fit_bounds,\n        bounds=bounds,\n        **kwargs,\n    )\n\n    # Track layer\n    self._layers = {\n        **self._layers,\n        layer_id: {\n            \"id\": layer_id,\n            \"type\": layer_type,\n            \"source\": f\"{layer_id}-source\",\n            \"paint\": paint,\n        },\n    }\n    self._add_to_layer_dict(layer_id, \"Vector\")\n</code></pre>"},{"location":"mapbox/#anymap_ts.mapbox.MapboxMap.add_vector_control","title":"<code>add_vector_control(self, position='top-right', collapsed=True, default_url=None, load_default_url=False, default_opacity=1.0, default_fill_color='#3388ff', default_stroke_color='#3388ff', fit_bounds=True, **kwargs)</code>","text":"<p>Add a vector layer control.</p> Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def add_vector_control(\n    self,\n    position: str = \"top-right\",\n    collapsed: bool = True,\n    default_url: Optional[str] = None,\n    load_default_url: bool = False,\n    default_opacity: float = 1.0,\n    default_fill_color: str = \"#3388ff\",\n    default_stroke_color: str = \"#3388ff\",\n    fit_bounds: bool = True,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a vector layer control.\"\"\"\n    self.call_js_method(\n        \"addVectorControl\",\n        position=position,\n        collapsed=collapsed,\n        defaultUrl=default_url or \"\",\n        loadDefaultUrl=load_default_url,\n        defaultOpacity=default_opacity,\n        defaultFillColor=default_fill_color,\n        defaultStrokeColor=default_stroke_color,\n        fitBounds=fit_bounds,\n        **kwargs,\n    )\n    self._controls = {\n        **self._controls,\n        \"vector-control\": {\"position\": position, \"collapsed\": collapsed},\n    }\n</code></pre>"},{"location":"mapbox/#anymap_ts.mapbox.MapboxMap.add_video_layer","title":"<code>add_video_layer(self, urls, coordinates, name=None, opacity=1.0, **kwargs)</code>","text":"<p>Add a georeferenced video overlay on the map.</p> Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def add_video_layer(\n    self,\n    urls: List[str],\n    coordinates: List[List[float]],\n    name: Optional[str] = None,\n    opacity: float = 1.0,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a georeferenced video overlay on the map.\"\"\"\n    self._validate_opacity(opacity)\n    layer_id = name or f\"video-{len(self._layers)}\"\n\n    if len(coordinates) != 4:\n        raise ValueError(\n            \"coordinates must have exactly 4 corner points \"\n            \"[top-left, top-right, bottom-right, bottom-left]\"\n        )\n\n    self.call_js_method(\n        \"addVideoLayer\",\n        id=layer_id,\n        urls=urls,\n        coordinates=coordinates,\n        opacity=opacity,\n        **kwargs,\n    )\n\n    self._layers = {\n        **self._layers,\n        layer_id: {\n            \"id\": layer_id,\n            \"type\": \"video\",\n            \"source\": f\"{layer_id}-source\",\n        },\n    }\n    self._add_to_layer_dict(layer_id, \"Raster\")\n</code></pre>"},{"location":"mapbox/#anymap_ts.mapbox.MapboxMap.add_zarr_control","title":"<code>add_zarr_control(self, position='top-right', collapsed=True, default_url=None, load_default_url=False, default_opacity=1.0, default_variable='', default_clim=None, **kwargs)</code>","text":"<p>Add a Zarr layer control.</p> Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def add_zarr_control(\n    self,\n    position: str = \"top-right\",\n    collapsed: bool = True,\n    default_url: Optional[str] = None,\n    load_default_url: bool = False,\n    default_opacity: float = 1.0,\n    default_variable: str = \"\",\n    default_clim: Optional[Tuple[float, float]] = None,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a Zarr layer control.\"\"\"\n    self.call_js_method(\n        \"addZarrControl\",\n        position=position,\n        collapsed=collapsed,\n        defaultUrl=default_url or \"\",\n        loadDefaultUrl=load_default_url,\n        defaultOpacity=default_opacity,\n        defaultVariable=default_variable,\n        defaultClim=list(default_clim) if default_clim else [0, 1],\n        **kwargs,\n    )\n    self._controls = {\n        **self._controls,\n        \"zarr-control\": {\"position\": position, \"collapsed\": collapsed},\n    }\n</code></pre>"},{"location":"mapbox/#anymap_ts.mapbox.MapboxMap.add_zarr_layer","title":"<code>add_zarr_layer(self, url, variable, name=None, colormap=None, clim=None, opacity=1.0, selector=None, minzoom=0, maxzoom=22, fill_value=None, spatial_dimensions=None, zarr_version=None, bounds=None, **kwargs)</code>","text":"<p>Add a Zarr dataset layer for visualizing multidimensional array data.</p> Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def add_zarr_layer(\n    self,\n    url: str,\n    variable: str,\n    name: Optional[str] = None,\n    colormap: Optional[List[str]] = None,\n    clim: Optional[Tuple[float, float]] = None,\n    opacity: float = 1.0,\n    selector: Optional[Dict[str, Any]] = None,\n    minzoom: int = 0,\n    maxzoom: int = 22,\n    fill_value: Optional[float] = None,\n    spatial_dimensions: Optional[Dict[str, str]] = None,\n    zarr_version: Optional[int] = None,\n    bounds: Optional[List[float]] = None,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a Zarr dataset layer for visualizing multidimensional array data.\"\"\"\n    layer_id = name or f\"zarr-{len(self._layers)}\"\n\n    self.call_js_method(\n        \"addZarrLayer\",\n        id=layer_id,\n        source=url,\n        variable=variable,\n        colormap=colormap or [\"#000000\", \"#ffffff\"],\n        clim=list(clim) if clim else [0, 100],\n        opacity=opacity,\n        selector=selector or {},\n        minzoom=minzoom,\n        maxzoom=maxzoom,\n        fillValue=fill_value,\n        spatialDimensions=spatial_dimensions,\n        zarrVersion=zarr_version,\n        bounds=bounds,\n        **kwargs,\n    )\n\n    self._layers = {\n        **self._layers,\n        layer_id: {\n            \"id\": layer_id,\n            \"type\": \"zarr\",\n            \"url\": url,\n            \"variable\": variable,\n        },\n    }\n    self._add_to_layer_dict(layer_id, \"Raster\")\n</code></pre>"},{"location":"mapbox/#anymap_ts.mapbox.MapboxMap.animate_along_route","title":"<code>animate_along_route(self, route, duration=10000, loop=True, marker_color='#3388ff', marker_size=1.0, show_trail=False, trail_color='#3388ff', trail_width=3, animation_id=None, **kwargs)</code>","text":"<p>Animate a marker along a route.</p> Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def animate_along_route(\n    self,\n    route: Any,\n    duration: int = 10000,\n    loop: bool = True,\n    marker_color: str = \"#3388ff\",\n    marker_size: float = 1.0,\n    show_trail: bool = False,\n    trail_color: str = \"#3388ff\",\n    trail_width: float = 3,\n    animation_id: Optional[str] = None,\n    **kwargs,\n) -&gt; str:\n    \"\"\"Animate a marker along a route.\"\"\"\n    anim_id = animation_id or f\"animation-{len(self._layers)}\"\n\n    if isinstance(route, list) and len(route) &gt; 0:\n        if isinstance(route[0], (list, tuple)):\n            coordinates = route\n        else:\n            raise ValueError(\"Route list must contain coordinate pairs\")\n    elif isinstance(route, dict):\n        if route.get(\"type\") == \"LineString\":\n            coordinates = route.get(\"coordinates\", [])\n        elif route.get(\"type\") == \"Feature\":\n            geometry = route.get(\"geometry\", {})\n            if geometry.get(\"type\") == \"LineString\":\n                coordinates = geometry.get(\"coordinates\", [])\n            else:\n                raise ValueError(\"Feature geometry must be LineString\")\n        elif route.get(\"type\") == \"FeatureCollection\":\n            features = route.get(\"features\", [])\n            if (\n                features\n                and features[0].get(\"geometry\", {}).get(\"type\") == \"LineString\"\n            ):\n                coordinates = features[0][\"geometry\"][\"coordinates\"]\n            else:\n                raise ValueError(\n                    \"FeatureCollection must contain LineString features\"\n                )\n        else:\n            raise ValueError(\n                \"GeoJSON must be LineString, Feature, or FeatureCollection\"\n            )\n    else:\n        geojson = to_geojson(route)\n        if geojson.get(\"type\") == \"url\":\n            geojson = fetch_geojson(geojson[\"url\"])\n        if geojson.get(\"type\") == \"FeatureCollection\":\n            features = geojson.get(\"features\", [])\n            if features:\n                coordinates = features[0].get(\"geometry\", {}).get(\"coordinates\", [])\n            else:\n                raise ValueError(\"No features found in data\")\n        elif geojson.get(\"type\") == \"Feature\":\n            coordinates = geojson.get(\"geometry\", {}).get(\"coordinates\", [])\n        else:\n            coordinates = geojson.get(\"coordinates\", [])\n\n    if len(coordinates) &lt; 2:\n        raise ValueError(\"Route must have at least 2 points\")\n\n    self.call_js_method(\n        \"animateAlongRoute\",\n        id=anim_id,\n        coordinates=coordinates,\n        duration=duration,\n        loop=loop,\n        markerColor=marker_color,\n        markerSize=marker_size,\n        showTrail=show_trail,\n        trailColor=trail_color,\n        trailWidth=trail_width,\n        **kwargs,\n    )\n\n    self._layers = {\n        **self._layers,\n        anim_id: {\n            \"id\": anim_id,\n            \"type\": \"animation\",\n        },\n    }\n    return anim_id\n</code></pre>"},{"location":"mapbox/#anymap_ts.mapbox.MapboxMap.clear_draw_data","title":"<code>clear_draw_data(self)</code>","text":"<p>Clear all drawn features.</p> Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def clear_draw_data(self) -&gt; None:\n    \"\"\"Clear all drawn features.\"\"\"\n    self._draw_data = {\"type\": \"FeatureCollection\", \"features\": []}\n    self.call_js_method(\"clearDrawData\")\n</code></pre>"},{"location":"mapbox/#anymap_ts.mapbox.MapboxMap.get_draw_data","title":"<code>get_draw_data(self)</code>","text":"<p>Get the current drawn features as GeoJSON.</p> Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def get_draw_data(self) -&gt; Dict:\n    \"\"\"Get the current drawn features as GeoJSON.\"\"\"\n    self.call_js_method(\"getDrawData\")\n    import time\n\n    time.sleep(0.1)\n    return self._draw_data or {\"type\": \"FeatureCollection\", \"features\": []}\n</code></pre>"},{"location":"mapbox/#anymap_ts.mapbox.MapboxMap.get_layer","title":"<code>get_layer(self, layer_id)</code>","text":"<p>Get layer configuration by ID.</p> Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def get_layer(self, layer_id: str) -&gt; Optional[Dict]:\n    \"\"\"Get layer configuration by ID.\"\"\"\n    return self._layers.get(layer_id)\n</code></pre>"},{"location":"mapbox/#anymap_ts.mapbox.MapboxMap.get_layer_ids","title":"<code>get_layer_ids(self)</code>","text":"<p>Get list of all layer IDs.</p> Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def get_layer_ids(self) -&gt; List[str]:\n    \"\"\"Get list of all layer IDs.\"\"\"\n    return list(self._layers.keys())\n</code></pre>"},{"location":"mapbox/#anymap_ts.mapbox.MapboxMap.get_visible_features","title":"<code>get_visible_features(self, layers=None)</code>","text":"<p>Get all features currently visible in the viewport.</p> Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def get_visible_features(\n    self,\n    layers: Optional[List[str]] = None,\n) -&gt; Optional[Dict]:\n    \"\"\"Get all features currently visible in the viewport.\"\"\"\n    if layers is not None:\n        self.call_js_method(\"getVisibleFeatures\", layers=layers)\n    features = self._queried_features\n    if features and \"data\" in features:\n        return features[\"data\"]\n    return None\n</code></pre>"},{"location":"mapbox/#anymap_ts.mapbox.MapboxMap.load_draw_data","title":"<code>load_draw_data(self, geojson)</code>","text":"<p>Load GeoJSON features into the drawing layer.</p> Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def load_draw_data(self, geojson: Dict) -&gt; None:\n    \"\"\"Load GeoJSON features into the drawing layer.\"\"\"\n    self._draw_data = geojson\n    self.call_js_method(\"loadDrawData\", geojson)\n</code></pre>"},{"location":"mapbox/#anymap_ts.mapbox.MapboxMap.move_layer","title":"<code>move_layer(self, layer_id, before_id=None)</code>","text":"<p>Move a layer in the layer stack.</p> Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def move_layer(self, layer_id: str, before_id: Optional[str] = None) -&gt; None:\n    \"\"\"Move a layer in the layer stack.\"\"\"\n    self.call_js_method(\"moveLayer\", layer_id, before_id)\n</code></pre>"},{"location":"mapbox/#anymap_ts.mapbox.MapboxMap.pause_animation","title":"<code>pause_animation(self, animation_id)</code>","text":"<p>Pause a running animation.</p> Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def pause_animation(self, animation_id: str) -&gt; None:\n    \"\"\"Pause a running animation.\"\"\"\n    self.call_js_method(\"pauseAnimation\", animation_id)\n</code></pre>"},{"location":"mapbox/#anymap_ts.mapbox.MapboxMap.pause_video","title":"<code>pause_video(self, name)</code>","text":"<p>Pause a video layer.</p> Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def pause_video(self, name: str) -&gt; None:\n    \"\"\"Pause a video layer.\"\"\"\n    self.call_js_method(\"pauseVideo\", id=name)\n</code></pre>"},{"location":"mapbox/#anymap_ts.mapbox.MapboxMap.play_video","title":"<code>play_video(self, name)</code>","text":"<p>Start playing a video layer.</p> Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def play_video(self, name: str) -&gt; None:\n    \"\"\"Start playing a video layer.\"\"\"\n    self.call_js_method(\"playVideo\", id=name)\n</code></pre>"},{"location":"mapbox/#anymap_ts.mapbox.MapboxMap.query_rendered_features","title":"<code>query_rendered_features(self, geometry=None, layers=None, filter_expression=None)</code>","text":"<p>Query features currently rendered on the map.</p> Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def query_rendered_features(\n    self,\n    geometry: Optional[Any] = None,\n    layers: Optional[List[str]] = None,\n    filter_expression: Optional[List] = None,\n) -&gt; Dict:\n    \"\"\"Query features currently rendered on the map.\"\"\"\n    kwargs: Dict[str, Any] = {}\n    if geometry is not None:\n        kwargs[\"geometry\"] = geometry\n    if layers is not None:\n        kwargs[\"layers\"] = layers\n    if filter_expression is not None:\n        kwargs[\"filter\"] = filter_expression\n\n    self.call_js_method(\"queryRenderedFeatures\", **kwargs)\n    return self._queried_features\n</code></pre>"},{"location":"mapbox/#anymap_ts.mapbox.MapboxMap.query_source_features","title":"<code>query_source_features(self, source_id, source_layer=None, filter_expression=None)</code>","text":"<p>Query features from a source.</p> Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def query_source_features(\n    self,\n    source_id: str,\n    source_layer: Optional[str] = None,\n    filter_expression: Optional[List] = None,\n) -&gt; Dict:\n    \"\"\"Query features from a source.\"\"\"\n    kwargs: Dict[str, Any] = {\"sourceId\": source_id}\n    if source_layer is not None:\n        kwargs[\"sourceLayer\"] = source_layer\n    if filter_expression is not None:\n        kwargs[\"filter\"] = filter_expression\n\n    self.call_js_method(\"querySourceFeatures\", **kwargs)\n    return self._queried_features\n</code></pre>"},{"location":"mapbox/#anymap_ts.mapbox.MapboxMap.remove_arc_layer","title":"<code>remove_arc_layer(self, layer_id)</code>","text":"<p>Remove an arc layer.</p> Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def remove_arc_layer(self, layer_id: str) -&gt; None:\n    \"\"\"Remove an arc layer.\"\"\"\n    self._remove_layer_internal(layer_id, \"removeArcLayer\")\n</code></pre>"},{"location":"mapbox/#anymap_ts.mapbox.MapboxMap.remove_cluster_layer","title":"<code>remove_cluster_layer(self, layer_id)</code>","text":"<p>Remove a cluster layer.</p> Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def remove_cluster_layer(self, layer_id: str) -&gt; None:\n    \"\"\"Remove a cluster layer.\"\"\"\n    self._remove_layer_internal(layer_id, \"removeClusterLayer\")\n</code></pre>"},{"location":"mapbox/#anymap_ts.mapbox.MapboxMap.remove_cog_layer","title":"<code>remove_cog_layer(self, layer_id)</code>","text":"<p>Remove a COG layer.</p> Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def remove_cog_layer(self, layer_id: str) -&gt; None:\n    \"\"\"Remove a COG layer.\"\"\"\n    self._remove_layer_internal(layer_id, \"removeCOGLayer\")\n</code></pre>"},{"location":"mapbox/#anymap_ts.mapbox.MapboxMap.remove_colorbar","title":"<code>remove_colorbar(self, colorbar_id=None)</code>","text":"<p>Remove a colorbar from the map.</p> Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def remove_colorbar(self, colorbar_id: Optional[str] = None) -&gt; None:\n    \"\"\"Remove a colorbar from the map.\"\"\"\n    if colorbar_id is None:\n        cbar_keys = [k for k in self._controls.keys() if k.startswith(\"colorbar\")]\n        for key in cbar_keys:\n            self.call_js_method(\"removeColorbar\", colorbarId=key)\n        self._controls = {\n            k: v for k, v in self._controls.items() if not k.startswith(\"colorbar\")\n        }\n    else:\n        self.call_js_method(\"removeColorbar\", colorbarId=colorbar_id)\n        if colorbar_id in self._controls:\n            controls = dict(self._controls)\n            del controls[colorbar_id]\n            self._controls = controls\n</code></pre>"},{"location":"mapbox/#anymap_ts.mapbox.MapboxMap.remove_control","title":"<code>remove_control(self, control_type)</code>","text":"<p>Remove a map control.</p> Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def remove_control(self, control_type: str) -&gt; None:\n    \"\"\"Remove a map control.\"\"\"\n    self.call_js_method(\"removeControl\", control_type)\n    if control_type in self._controls:\n        controls = dict(self._controls)\n        del controls[control_type]\n        self._controls = controls\n</code></pre>"},{"location":"mapbox/#anymap_ts.mapbox.MapboxMap.remove_coordinates_control","title":"<code>remove_coordinates_control(self)</code>","text":"<p>Remove the coordinates display control.</p> Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def remove_coordinates_control(self) -&gt; None:\n    \"\"\"Remove the coordinates display control.\"\"\"\n    self.call_js_method(\"removeCoordinatesControl\")\n</code></pre>"},{"location":"mapbox/#anymap_ts.mapbox.MapboxMap.remove_deck_layer","title":"<code>remove_deck_layer(self, layer_id)</code>","text":"<p>Remove a deck.gl layer from the map.</p> Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def remove_deck_layer(self, layer_id: str) -&gt; None:\n    \"\"\"Remove a deck.gl layer from the map.\"\"\"\n    self._remove_layer_internal(layer_id, \"removeDeckLayer\")\n</code></pre>"},{"location":"mapbox/#anymap_ts.mapbox.MapboxMap.remove_flatgeobuf","title":"<code>remove_flatgeobuf(self, name)</code>","text":"<p>Remove a FlatGeobuf layer from the map.</p> Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def remove_flatgeobuf(self, name: str) -&gt; None:\n    \"\"\"Remove a FlatGeobuf layer from the map.\"\"\"\n    if name in self._layers:\n        layers = dict(self._layers)\n        del layers[name]\n        self._layers = layers\n    self._remove_from_layer_dict(name)\n    self.call_js_method(\"removeFlatGeobuf\", name=name)\n</code></pre>"},{"location":"mapbox/#anymap_ts.mapbox.MapboxMap.remove_fog","title":"<code>remove_fog(self)</code>","text":"<p>Remove fog atmospheric effects from the map.</p> Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def remove_fog(self) -&gt; None:\n    \"\"\"Remove fog atmospheric effects from the map.\"\"\"\n    self.call_js_method(\"removeFog\")\n</code></pre>"},{"location":"mapbox/#anymap_ts.mapbox.MapboxMap.remove_layer","title":"<code>remove_layer(self, layer_id)</code>","text":"<p>Remove a layer from the map.</p> Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def remove_layer(self, layer_id: str) -&gt; None:\n    \"\"\"Remove a layer from the map.\"\"\"\n    if layer_id in self._layers:\n        layers = dict(self._layers)\n        del layers[layer_id]\n        self._layers = layers\n    self._remove_from_layer_dict(layer_id)\n    self.call_js_method(\"removeLayer\", layer_id)\n</code></pre>"},{"location":"mapbox/#anymap_ts.mapbox.MapboxMap.remove_legend","title":"<code>remove_legend(self, legend_id=None)</code>","text":"<p>Remove a legend control from the map.</p> Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def remove_legend(self, legend_id: Optional[str] = None) -&gt; None:\n    \"\"\"Remove a legend control from the map.\"\"\"\n    if legend_id is None:\n        legend_keys = [k for k in self._controls.keys() if k.startswith(\"legend\")]\n        for key in legend_keys:\n            self.call_js_method(\"removeLegend\", key)\n        self._controls = {\n            k: v for k, v in self._controls.items() if not k.startswith(\"legend\")\n        }\n    else:\n        self.call_js_method(\"removeLegend\", legend_id)\n        if legend_id in self._controls:\n            controls = dict(self._controls)\n            del controls[legend_id]\n            self._controls = controls\n</code></pre>"},{"location":"mapbox/#anymap_ts.mapbox.MapboxMap.remove_lidar_layer","title":"<code>remove_lidar_layer(self, layer_id=None)</code>","text":"<p>Remove a LiDAR layer.</p> <p>Parameters:</p> Name Type Description Default <code>layer_id</code> <code>Optional[str]</code> <p>Layer identifier to remove. If None, removes all LiDAR layers.</p> <code>None</code> Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def remove_lidar_layer(self, layer_id: Optional[str] = None) -&gt; None:\n    \"\"\"Remove a LiDAR layer.\n\n    Args:\n        layer_id: Layer identifier to remove. If None, removes all LiDAR layers.\n    \"\"\"\n    if layer_id:\n        if layer_id in self._layers:\n            layers = dict(self._layers)\n            del layers[layer_id]\n            self._layers = layers\n        self.call_js_method(\"removeLidarLayer\", id=layer_id)\n    else:\n        # Remove all lidar layers\n        layers = dict(self._layers)\n        self._layers = {k: v for k, v in layers.items() if v.get(\"type\") != \"lidar\"}\n        self.call_js_method(\"removeLidarLayer\")\n</code></pre>"},{"location":"mapbox/#anymap_ts.mapbox.MapboxMap.remove_marker","title":"<code>remove_marker(self, marker_id)</code>","text":"<p>Remove a marker from the map.</p> Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def remove_marker(self, marker_id: str) -&gt; None:\n    \"\"\"Remove a marker from the map.\"\"\"\n    self._remove_layer_internal(marker_id, \"removeMarker\")\n</code></pre>"},{"location":"mapbox/#anymap_ts.mapbox.MapboxMap.remove_measure_control","title":"<code>remove_measure_control(self)</code>","text":"<p>Remove the measurement control.</p> Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def remove_measure_control(self) -&gt; None:\n    \"\"\"Remove the measurement control.\"\"\"\n    self.call_js_method(\"removeMeasureControl\")\n    if \"measure-control\" in self._controls:\n        controls = dict(self._controls)\n        del controls[\"measure-control\"]\n        self._controls = controls\n</code></pre>"},{"location":"mapbox/#anymap_ts.mapbox.MapboxMap.remove_opacity_slider","title":"<code>remove_opacity_slider(self, layer_id)</code>","text":"<p>Remove the opacity slider for a layer.</p> Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def remove_opacity_slider(self, layer_id: str) -&gt; None:\n    \"\"\"Remove the opacity slider for a layer.\"\"\"\n    self.call_js_method(\"removeOpacitySlider\", layerId=layer_id)\n</code></pre>"},{"location":"mapbox/#anymap_ts.mapbox.MapboxMap.remove_pmtiles_layer","title":"<code>remove_pmtiles_layer(self, layer_id)</code>","text":"<p>Remove a PMTiles layer.</p> Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def remove_pmtiles_layer(self, layer_id: str) -&gt; None:\n    \"\"\"Remove a PMTiles layer.\"\"\"\n    self._remove_layer_internal(layer_id, \"removePMTilesLayer\")\n</code></pre>"},{"location":"mapbox/#anymap_ts.mapbox.MapboxMap.remove_point_cloud_layer","title":"<code>remove_point_cloud_layer(self, layer_id)</code>","text":"<p>Remove a point cloud layer.</p> Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def remove_point_cloud_layer(self, layer_id: str) -&gt; None:\n    \"\"\"Remove a point cloud layer.\"\"\"\n    self._remove_layer_internal(layer_id, \"removePointCloudLayer\")\n</code></pre>"},{"location":"mapbox/#anymap_ts.mapbox.MapboxMap.remove_print_control","title":"<code>remove_print_control(self)</code>","text":"<p>Remove the print/export control.</p> Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def remove_print_control(self) -&gt; None:\n    \"\"\"Remove the print/export control.\"\"\"\n    self.call_js_method(\"removePrintControl\")\n    if \"print-control\" in self._controls:\n        controls = dict(self._controls)\n        del controls[\"print-control\"]\n        self._controls = controls\n</code></pre>"},{"location":"mapbox/#anymap_ts.mapbox.MapboxMap.remove_search_control","title":"<code>remove_search_control(self)</code>","text":"<p>Remove the search/geocoder control.</p> Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def remove_search_control(self) -&gt; None:\n    \"\"\"Remove the search/geocoder control.\"\"\"\n    self.call_js_method(\"removeSearchControl\")\n    if \"search-control\" in self._controls:\n        controls = dict(self._controls)\n        del controls[\"search-control\"]\n        self._controls = controls\n</code></pre>"},{"location":"mapbox/#anymap_ts.mapbox.MapboxMap.remove_split_map","title":"<code>remove_split_map(self)</code>","text":"<p>Remove the split map comparison view.</p> Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def remove_split_map(self) -&gt; None:\n    \"\"\"Remove the split map comparison view.\"\"\"\n    self.call_js_method(\"removeSplitMap\")\n</code></pre>"},{"location":"mapbox/#anymap_ts.mapbox.MapboxMap.remove_style_switcher","title":"<code>remove_style_switcher(self)</code>","text":"<p>Remove the style switcher control.</p> Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def remove_style_switcher(self) -&gt; None:\n    \"\"\"Remove the style switcher control.\"\"\"\n    self.call_js_method(\"removeStyleSwitcher\")\n</code></pre>"},{"location":"mapbox/#anymap_ts.mapbox.MapboxMap.remove_swipe_map","title":"<code>remove_swipe_map(self)</code>","text":"<p>Remove the swipe map comparison control.</p> Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def remove_swipe_map(self) -&gt; None:\n    \"\"\"Remove the swipe map comparison control.\"\"\"\n    self.call_js_method(\"removeSwipeMap\")\n</code></pre>"},{"location":"mapbox/#anymap_ts.mapbox.MapboxMap.remove_terrain","title":"<code>remove_terrain(self)</code>","text":"<p>Remove 3D terrain from the map.</p> Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def remove_terrain(self) -&gt; None:\n    \"\"\"Remove 3D terrain from the map.\"\"\"\n    self.call_js_method(\"removeTerrain\")\n</code></pre>"},{"location":"mapbox/#anymap_ts.mapbox.MapboxMap.remove_time_slider","title":"<code>remove_time_slider(self)</code>","text":"<p>Remove the time slider control.</p> Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def remove_time_slider(self) -&gt; None:\n    \"\"\"Remove the time slider control.\"\"\"\n    self.call_js_method(\"removeTimeSlider\")\n</code></pre>"},{"location":"mapbox/#anymap_ts.mapbox.MapboxMap.remove_tooltip","title":"<code>remove_tooltip(self, layer_id)</code>","text":"<p>Remove tooltip from a layer.</p> Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def remove_tooltip(self, layer_id: str) -&gt; None:\n    \"\"\"Remove tooltip from a layer.\"\"\"\n    self.call_js_method(\"removeTooltip\", layerId=layer_id)\n</code></pre>"},{"location":"mapbox/#anymap_ts.mapbox.MapboxMap.remove_video_layer","title":"<code>remove_video_layer(self, name)</code>","text":"<p>Remove a video layer from the map.</p> Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def remove_video_layer(self, name: str) -&gt; None:\n    \"\"\"Remove a video layer from the map.\"\"\"\n    if name in self._layers:\n        layers = dict(self._layers)\n        del layers[name]\n        self._layers = layers\n    self._remove_from_layer_dict(name)\n    self.call_js_method(\"removeVideoLayer\", id=name)\n</code></pre>"},{"location":"mapbox/#anymap_ts.mapbox.MapboxMap.remove_zarr_layer","title":"<code>remove_zarr_layer(self, layer_id)</code>","text":"<p>Remove a Zarr layer.</p> Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def remove_zarr_layer(self, layer_id: str) -&gt; None:\n    \"\"\"Remove a Zarr layer.\"\"\"\n    self._remove_layer_internal(layer_id, \"removeZarrLayer\")\n</code></pre>"},{"location":"mapbox/#anymap_ts.mapbox.MapboxMap.resume_animation","title":"<code>resume_animation(self, animation_id)</code>","text":"<p>Resume a paused animation.</p> Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def resume_animation(self, animation_id: str) -&gt; None:\n    \"\"\"Resume a paused animation.\"\"\"\n    self.call_js_method(\"resumeAnimation\", animation_id)\n</code></pre>"},{"location":"mapbox/#anymap_ts.mapbox.MapboxMap.save_draw_data","title":"<code>save_draw_data(self, filepath, driver=None)</code>","text":"<p>Save drawn features to a file.</p> Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def save_draw_data(\n    self,\n    filepath: Union[str, Path],\n    driver: Optional[str] = None,\n) -&gt; None:\n    \"\"\"Save drawn features to a file.\"\"\"\n    try:\n        import geopandas as gpd\n    except ImportError:\n        raise ImportError(\n            \"geopandas is required to save draw data. \"\n            \"Install with: pip install anymap-ts[vector]\"\n        )\n\n    data = self.get_draw_data()\n    if not data.get(\"features\"):\n        print(\"No features to save\")\n        return\n\n    gdf = gpd.GeoDataFrame.from_features(data[\"features\"])\n    filepath = Path(filepath)\n\n    if driver is None:\n        ext = filepath.suffix.lower()\n        driver_map = {\n            \".geojson\": \"GeoJSON\",\n            \".json\": \"GeoJSON\",\n            \".shp\": \"ESRI Shapefile\",\n            \".gpkg\": \"GPKG\",\n        }\n        driver = driver_map.get(ext, \"GeoJSON\")\n\n    gdf.to_file(filepath, driver=driver)\n</code></pre>"},{"location":"mapbox/#anymap_ts.mapbox.MapboxMap.seek_video","title":"<code>seek_video(self, name, time)</code>","text":"<p>Seek to a specific time in a video layer.</p> Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def seek_video(self, name: str, time: float) -&gt; None:\n    \"\"\"Seek to a specific time in a video layer.\"\"\"\n    self.call_js_method(\"seekVideo\", id=name, time=time)\n</code></pre>"},{"location":"mapbox/#anymap_ts.mapbox.MapboxMap.set_access_token","title":"<code>set_access_token(self, token)</code>","text":"<p>Set the Mapbox access token.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>str</code> <p>Mapbox access token.</p> required Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def set_access_token(self, token: str) -&gt; None:\n    \"\"\"Set the Mapbox access token.\n\n    Args:\n        token: Mapbox access token.\n    \"\"\"\n    self.access_token = token\n</code></pre>"},{"location":"mapbox/#anymap_ts.mapbox.MapboxMap.set_animation_speed","title":"<code>set_animation_speed(self, animation_id, speed)</code>","text":"<p>Set animation speed multiplier.</p> Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def set_animation_speed(self, animation_id: str, speed: float) -&gt; None:\n    \"\"\"Set animation speed multiplier.\"\"\"\n    self.call_js_method(\"setAnimationSpeed\", animation_id, speed)\n</code></pre>"},{"location":"mapbox/#anymap_ts.mapbox.MapboxMap.set_filter","title":"<code>set_filter(self, layer_id, filter_expression=None)</code>","text":"<p>Set or clear a filter on a map layer.</p> Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def set_filter(\n    self,\n    layer_id: str,\n    filter_expression: Optional[List] = None,\n) -&gt; None:\n    \"\"\"Set or clear a filter on a map layer.\"\"\"\n    self.call_js_method(\n        \"setFilter\",\n        layerId=layer_id,\n        filter=filter_expression,\n    )\n</code></pre>"},{"location":"mapbox/#anymap_ts.mapbox.MapboxMap.set_fog","title":"<code>set_fog(self, color=None, high_color=None, low_color=None, horizon_blend=None, range=None, **kwargs)</code>","text":"<p>Set fog atmospheric effect (Mapbox uses map.setFog() API).</p> Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def set_fog(\n    self,\n    color: Optional[str] = None,\n    high_color: Optional[str] = None,\n    low_color: Optional[str] = None,\n    horizon_blend: Optional[float] = None,\n    range: Optional[List[float]] = None,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Set fog atmospheric effect (Mapbox uses map.setFog() API).\"\"\"\n    self.call_js_method(\n        \"setFog\",\n        color=color,\n        highColor=high_color,\n        lowColor=low_color,\n        horizonBlend=horizon_blend,\n        range=range,\n        **kwargs,\n    )\n</code></pre>"},{"location":"mapbox/#anymap_ts.mapbox.MapboxMap.set_layout_property","title":"<code>set_layout_property(self, layer_id, property_name, value)</code>","text":"<p>Set a layout property for a layer.</p> Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def set_layout_property(\n    self, layer_id: str, property_name: str, value: Any\n) -&gt; None:\n    \"\"\"Set a layout property for a layer.\"\"\"\n    self.call_js_method(\"setLayoutProperty\", layer_id, property_name, value)\n</code></pre>"},{"location":"mapbox/#anymap_ts.mapbox.MapboxMap.set_lidar_color_scheme","title":"<code>set_lidar_color_scheme(self, color_scheme)</code>","text":"<p>Set the LiDAR color scheme.</p> <p>Parameters:</p> Name Type Description Default <code>color_scheme</code> <code>str</code> <p>Color scheme ('elevation', 'intensity', 'classification', 'rgb').</p> required Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def set_lidar_color_scheme(self, color_scheme: str) -&gt; None:\n    \"\"\"Set the LiDAR color scheme.\n\n    Args:\n        color_scheme: Color scheme ('elevation', 'intensity', 'classification', 'rgb').\n    \"\"\"\n    self.call_js_method(\"setLidarColorScheme\", colorScheme=color_scheme)\n</code></pre>"},{"location":"mapbox/#anymap_ts.mapbox.MapboxMap.set_lidar_opacity","title":"<code>set_lidar_opacity(self, opacity)</code>","text":"<p>Set the LiDAR layer opacity.</p> <p>Parameters:</p> Name Type Description Default <code>opacity</code> <code>float</code> <p>Opacity value between 0 and 1.</p> required Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def set_lidar_opacity(self, opacity: float) -&gt; None:\n    \"\"\"Set the LiDAR layer opacity.\n\n    Args:\n        opacity: Opacity value between 0 and 1.\n    \"\"\"\n    self.call_js_method(\"setLidarOpacity\", opacity=opacity)\n</code></pre>"},{"location":"mapbox/#anymap_ts.mapbox.MapboxMap.set_lidar_point_size","title":"<code>set_lidar_point_size(self, point_size)</code>","text":"<p>Set the LiDAR point size.</p> <p>Parameters:</p> Name Type Description Default <code>point_size</code> <code>float</code> <p>Point size in pixels.</p> required Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def set_lidar_point_size(self, point_size: float) -&gt; None:\n    \"\"\"Set the LiDAR point size.\n\n    Args:\n        point_size: Point size in pixels.\n    \"\"\"\n    self.call_js_method(\"setLidarPointSize\", pointSize=point_size)\n</code></pre>"},{"location":"mapbox/#anymap_ts.mapbox.MapboxMap.set_opacity","title":"<code>set_opacity(self, layer_id, opacity)</code>","text":"<p>Set layer opacity.</p> Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def set_opacity(self, layer_id: str, opacity: float) -&gt; None:\n    \"\"\"Set layer opacity.\"\"\"\n    self._validate_opacity(opacity)\n    self.call_js_method(\"setOpacity\", layer_id, opacity)\n</code></pre>"},{"location":"mapbox/#anymap_ts.mapbox.MapboxMap.set_paint_property","title":"<code>set_paint_property(self, layer_id, property_name, value)</code>","text":"<p>Set a paint property for a layer.</p> Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def set_paint_property(self, layer_id: str, property_name: str, value: Any) -&gt; None:\n    \"\"\"Set a paint property for a layer.\"\"\"\n    self.call_js_method(\"setPaintProperty\", layer_id, property_name, value)\n</code></pre>"},{"location":"mapbox/#anymap_ts.mapbox.MapboxMap.set_projection","title":"<code>set_projection(self, projection='mercator')</code>","text":"<p>Set the map projection (Mapbox supports 'globe' and 'mercator').</p> Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def set_projection(self, projection: str = \"mercator\") -&gt; None:\n    \"\"\"Set the map projection (Mapbox supports 'globe' and 'mercator').\"\"\"\n    self.call_js_method(\"setProjection\", projection=projection)\n</code></pre>"},{"location":"mapbox/#anymap_ts.mapbox.MapboxMap.set_visibility","title":"<code>set_visibility(self, layer_id, visible)</code>","text":"<p>Set layer visibility.</p> <p>Parameters:</p> Name Type Description Default <code>layer_id</code> <code>str</code> <p>Layer identifier.</p> required <code>visible</code> <code>bool</code> <p>Whether layer should be visible.</p> required Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def set_visibility(self, layer_id: str, visible: bool) -&gt; None:\n    \"\"\"Set layer visibility.\n\n    Args:\n        layer_id: Layer identifier.\n        visible: Whether layer should be visible.\n    \"\"\"\n    self.call_js_method(\"setVisibility\", layer_id, visible)\n</code></pre>"},{"location":"mapbox/#anymap_ts.mapbox.MapboxMap.stop_animation","title":"<code>stop_animation(self, animation_id)</code>","text":"<p>Stop a running animation.</p> Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def stop_animation(self, animation_id: str) -&gt; None:\n    \"\"\"Stop a running animation.\"\"\"\n    self.call_js_method(\"stopAnimation\", animation_id)\n    if animation_id in self._layers:\n        layers = dict(self._layers)\n        del layers[animation_id]\n        self._layers = layers\n</code></pre>"},{"location":"mapbox/#anymap_ts.mapbox.MapboxMap.to_geojson","title":"<code>to_geojson(self, layer_id=None)</code>","text":"<p>Get layer data as GeoJSON.</p> Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def to_geojson(self, layer_id: Optional[str] = None) -&gt; Optional[Dict]:\n    \"\"\"Get layer data as GeoJSON.\"\"\"\n    if layer_id:\n        self.call_js_method(\"getLayerData\", sourceId=layer_id)\n    features = self._queried_features\n    if features and \"data\" in features:\n        return features[\"data\"]\n    return None\n</code></pre>"},{"location":"mapbox/#anymap_ts.mapbox.MapboxMap.to_geopandas","title":"<code>to_geopandas(self, layer_id=None)</code>","text":"<p>Get layer data as a GeoDataFrame.</p> Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def to_geopandas(self, layer_id: Optional[str] = None) -&gt; Any:\n    \"\"\"Get layer data as a GeoDataFrame.\"\"\"\n    geojson = self.to_geojson(layer_id)\n    if geojson is None:\n        return None\n    try:\n        import geopandas as gpd\n\n        return gpd.GeoDataFrame.from_features(geojson.get(\"features\", []))\n    except ImportError:\n        raise ImportError(\"geopandas is required for to_geopandas()\")\n</code></pre>"},{"location":"mapbox/#anymap_ts.mapbox.MapboxMap.update_colorbar","title":"<code>update_colorbar(self, colorbar_id=None, **kwargs)</code>","text":"<p>Update an existing colorbar's properties.</p> Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def update_colorbar(self, colorbar_id: Optional[str] = None, **kwargs) -&gt; None:\n    \"\"\"Update an existing colorbar's properties.\"\"\"\n    if colorbar_id is None:\n        cbar_keys = [k for k in self._controls.keys() if k.startswith(\"colorbar\")]\n        if not cbar_keys:\n            raise ValueError(\"No colorbar found to update\")\n        colorbar_id = cbar_keys[0]\n\n    if colorbar_id not in self._controls:\n        raise ValueError(f\"Colorbar '{colorbar_id}' not found\")\n\n    js_kwargs: Dict[str, Any] = {\"colorbarId\": colorbar_id}\n    key_map = {\"bar_thickness\": \"barThickness\", \"bar_length\": \"barLength\"}\n    for key, value in kwargs.items():\n        js_key = key_map.get(key, key)\n        js_kwargs[js_key] = value\n\n    self.call_js_method(\"updateColorbar\", **js_kwargs)\n</code></pre>"},{"location":"mapbox/#anymap_ts.mapbox.MapboxMap.update_geojson_source","title":"<code>update_geojson_source(self, source_id, data)</code>","text":"<p>Update the data of an existing GeoJSON source in place.</p> Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def update_geojson_source(self, source_id: str, data: Any) -&gt; None:\n    \"\"\"Update the data of an existing GeoJSON source in place.\"\"\"\n    processed_data = self._process_deck_data(data)\n    self.call_js_method(\n        \"updateGeoJSONSource\",\n        sourceId=source_id,\n        data=processed_data,\n    )\n</code></pre>"},{"location":"mapbox/#anymap_ts.mapbox.MapboxMap.update_legend","title":"<code>update_legend(self, legend_id, title=None, labels=None, colors=None, opacity=None, **kwargs)</code>","text":"<p>Update an existing legend's properties.</p> Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def update_legend(\n    self,\n    legend_id: str,\n    title: Optional[str] = None,\n    labels: Optional[List[str]] = None,\n    colors: Optional[List[str]] = None,\n    opacity: Optional[float] = None,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Update an existing legend's properties.\"\"\"\n    if legend_id not in self._controls:\n        raise ValueError(f\"Legend '{legend_id}' not found\")\n\n    update_params = {\"id\": legend_id}\n\n    if title is not None:\n        update_params[\"title\"] = title\n        self._controls[legend_id][\"title\"] = title\n\n    if labels is not None and colors is not None:\n        if len(labels) != len(colors):\n            raise ValueError(\"Number of labels must match number of colors\")\n\n        legend_items = [\n            {\"label\": label, \"color\": color} for label, color in zip(labels, colors)\n        ]\n        update_params[\"items\"] = legend_items\n        self._controls[legend_id][\"labels\"] = labels\n        self._controls[legend_id][\"colors\"] = colors\n\n    elif labels is not None or colors is not None:\n        raise ValueError(\"Both labels and colors must be provided together\")\n\n    if opacity is not None:\n        update_params[\"opacity\"] = opacity\n        self._controls[legend_id][\"opacity\"] = opacity\n\n    update_params.update(kwargs)\n    self.call_js_method(\"updateLegend\", **update_params)\n</code></pre>"},{"location":"mapbox/#anymap_ts.mapbox.MapboxMap.update_zarr_layer","title":"<code>update_zarr_layer(self, layer_id, selector=None, clim=None, colormap=None, opacity=None)</code>","text":"<p>Update a Zarr layer's properties dynamically.</p> Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def update_zarr_layer(\n    self,\n    layer_id: str,\n    selector: Optional[Dict[str, Any]] = None,\n    clim: Optional[Tuple[float, float]] = None,\n    colormap: Optional[List[str]] = None,\n    opacity: Optional[float] = None,\n) -&gt; None:\n    \"\"\"Update a Zarr layer's properties dynamically.\"\"\"\n    update_kwargs: Dict[str, Any] = {\"id\": layer_id}\n    if selector is not None:\n        update_kwargs[\"selector\"] = selector\n    if clim is not None:\n        update_kwargs[\"clim\"] = list(clim)\n    if colormap is not None:\n        update_kwargs[\"colormap\"] = colormap\n    if opacity is not None:\n        update_kwargs[\"opacity\"] = opacity\n    self.call_js_method(\"updateZarrLayer\", **update_kwargs)\n</code></pre>"},{"location":"mapbox/#anymap_ts.mapbox.get_mapbox_token","title":"<code>get_mapbox_token()</code>","text":"<p>Get Mapbox access token from environment variable.</p> <p>Returns:</p> Type Description <code>str</code> <p>Mapbox access token string, or empty string if not set.</p> Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def get_mapbox_token() -&gt; str:\n    \"\"\"Get Mapbox access token from environment variable.\n\n    Returns:\n        Mapbox access token string, or empty string if not set.\n    \"\"\"\n    return os.environ.get(\"MAPBOX_TOKEN\", \"\")\n</code></pre>"},{"location":"maplibre/","title":"maplibre module","text":"<p>MapLibre GL JS map widget implementation.</p>"},{"location":"maplibre/#anymap_ts.maplibre.MapLibreMap","title":"<code> MapLibreMap            (MapWidget)         </code>","text":"<p>Interactive map widget using MapLibre GL JS.</p> <p>This class provides a Python interface to MapLibre GL JS maps with full bidirectional communication through anywidget.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from anymap_ts import Map\n&gt;&gt;&gt; m = Map(center=[-122.4, 37.8], zoom=10)\n&gt;&gt;&gt; m.add_basemap(\"OpenStreetMap\")\n&gt;&gt;&gt; m\n</code></pre> Source code in <code>anymap_ts/maplibre.py</code> <pre><code>class MapLibreMap(MapWidget):\n    \"\"\"Interactive map widget using MapLibre GL JS.\n\n    This class provides a Python interface to MapLibre GL JS maps with\n    full bidirectional communication through anywidget.\n\n    Example:\n        &gt;&gt;&gt; from anymap_ts import Map\n        &gt;&gt;&gt; m = Map(center=[-122.4, 37.8], zoom=10)\n        &gt;&gt;&gt; m.add_basemap(\"OpenStreetMap\")\n        &gt;&gt;&gt; m\n    \"\"\"\n\n    # ESM module for frontend\n    _esm = STATIC_DIR / \"maplibre.js\"\n    _css = STATIC_DIR / \"maplibre.css\"\n\n    # MapLibre-specific traits\n    bearing = traitlets.Float(0.0).tag(sync=True)\n    pitch = traitlets.Float(0.0).tag(sync=True)\n    projection = traitlets.Unicode(\"mercator\").tag(sync=True)\n    antialias = traitlets.Bool(True).tag(sync=True)\n    double_click_zoom = traitlets.Bool(True).tag(sync=True)\n\n    # Layer tracking\n    _layer_dict = traitlets.Dict({}).tag(sync=True)\n\n    def __init__(\n        self,\n        center: Tuple[float, float] = (0.0, 0.0),\n        zoom: float = 2.0,\n        width: str = \"100%\",\n        height: str = \"700px\",\n        style: Union[\n            str, Dict\n        ] = \"https://basemaps.cartocdn.com/gl/positron-gl-style/style.json\",\n        bearing: float = 0.0,\n        pitch: float = 0.0,\n        max_pitch: float = 85.0,\n        projection: str = \"mercator\",\n        controls: Optional[Dict[str, Any]] = None,\n        **kwargs,\n    ):\n        \"\"\"Initialize a MapLibre map.\n\n        Args:\n            center: Map center as (longitude, latitude).\n            zoom: Initial zoom level.\n            width: Map width as CSS string.\n            height: Map height as CSS string. Default is \"700px\".\n            style: MapLibre style URL or style object. Default is \"https://basemaps.cartocdn.com/gl/positron-gl-style/style.json\".\n            bearing: Map bearing in degrees.\n            pitch: Map pitch in degrees.\n            max_pitch: Maximum pitch angle in degrees (default: 85).\n            projection: Map projection. Supported values: 'mercator', 'globe'.\n                Default is 'mercator'.\n            controls: Dict of controls to add. If None, defaults to\n                {\"layer-control\": True, \"control-grid\": True}.\n                Use {\"layer-control\": {\"collapsed\": True}} for custom options.\n            **kwargs: Additional widget arguments.\n        \"\"\"\n        # Handle style shortcuts\n        if isinstance(style, str) and not style.startswith(\"http\"):\n            try:\n                style = get_maplibre_style(style)\n            except ValueError:\n                pass  # Use as-is\n\n        super().__init__(\n            center=list(center),\n            zoom=zoom,\n            width=width,\n            height=height,\n            style=style,\n            bearing=bearing,\n            pitch=pitch,\n            max_pitch=max_pitch,\n            projection=projection,\n            **kwargs,\n        )\n\n        # Initialize layer dictionary\n        self._layer_dict = {\"Background\": []}\n\n        # Add default controls\n        if controls is None:\n            controls = {\n                \"layer-control\": True,\n                \"control-grid\": True,\n            }\n\n        for control_name, config in controls.items():\n            if config:\n                if control_name == \"layer-control\":\n                    self.add_layer_control(\n                        **(config if isinstance(config, dict) else {})\n                    )\n                elif control_name == \"control-grid\":\n                    self.add_control_grid(\n                        **(config if isinstance(config, dict) else {})\n                    )\n                else:\n                    self.add_control(\n                        control_name, **(config if isinstance(config, dict) else {})\n                    )\n\n    # -------------------------------------------------------------------------\n    # Layer Dict Helper\n    # -------------------------------------------------------------------------\n\n    def _add_to_layer_dict(self, layer_id: str, category: str = \"Overlays\") -&gt; None:\n        \"\"\"Add a layer to the layer dictionary for UI tracking.\n\n        Args:\n            layer_id: The layer identifier.\n            category: The category to add the layer to (e.g., \"Overlays\", \"Raster\").\n        \"\"\"\n        layers = self._layer_dict.get(category, [])\n        if layer_id not in layers:\n            self._layer_dict = {\n                **self._layer_dict,\n                category: layers + [layer_id],\n            }\n\n    def _remove_from_layer_dict(self, layer_id: str) -&gt; None:\n        \"\"\"Remove a layer from the layer dictionary.\n\n        Args:\n            layer_id: The layer identifier to remove.\n        \"\"\"\n        new_dict = {}\n        for category, layers in self._layer_dict.items():\n            if layer_id in layers:\n                new_layers = [lid for lid in layers if lid != layer_id]\n                if new_layers:  # Only keep category if it still has layers\n                    new_dict[category] = new_layers\n            else:\n                new_dict[category] = layers\n        self._layer_dict = new_dict\n\n    # -------------------------------------------------------------------------\n    # Validation Helpers\n    # -------------------------------------------------------------------------\n\n    def _validate_opacity(self, opacity: float, param_name: str = \"opacity\") -&gt; float:\n        \"\"\"Validate opacity value is between 0 and 1.\n\n        Args:\n            opacity: The opacity value to validate.\n            param_name: Name of the parameter for error messages.\n\n        Returns:\n            The validated opacity value.\n\n        Raises:\n            ValueError: If opacity is not between 0 and 1.\n        \"\"\"\n        if not 0 &lt;= opacity &lt;= 1:\n            raise ValueError(f\"{param_name} must be between 0 and 1, got {opacity}\")\n        return opacity\n\n    def _validate_position(self, position: str) -&gt; str:\n        \"\"\"Validate control position is valid.\n\n        Args:\n            position: The position string to validate.\n\n        Returns:\n            The validated position string.\n\n        Raises:\n            ValueError: If position is not valid.\n        \"\"\"\n        valid_positions = [\"top-left\", \"top-right\", \"bottom-left\", \"bottom-right\"]\n        if position not in valid_positions:\n            raise ValueError(\n                f\"Position must be one of: {', '.join(valid_positions)}, got '{position}'\"\n            )\n        return position\n\n    def _remove_layer_internal(self, layer_id: str, js_method: str) -&gt; None:\n        \"\"\"Internal helper to remove a layer.\n\n        Args:\n            layer_id: The layer identifier to remove.\n            js_method: The JavaScript method to call for removal.\n        \"\"\"\n        if layer_id in self._layers:\n            layers = dict(self._layers)\n            del layers[layer_id]\n            self._layers = layers\n        self._remove_from_layer_dict(layer_id)\n        self.call_js_method(js_method, layer_id)\n\n    # -------------------------------------------------------------------------\n    # Basemap Methods\n    # -------------------------------------------------------------------------\n\n    def add_basemap(\n        self,\n        basemap: str = \"OpenStreetMap\",\n        attribution: Optional[str] = None,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a basemap layer.\n\n        Args:\n            basemap: Name of basemap provider (e.g., \"OpenStreetMap\", \"CartoDB.Positron\")\n            attribution: Custom attribution text\n            **kwargs: Additional options\n        \"\"\"\n        url, default_attribution = get_basemap_url(basemap)\n        self.call_js_method(\n            \"addBasemap\",\n            url,\n            attribution=attribution or default_attribution,\n            name=basemap,\n            **kwargs,\n        )\n\n        # Track in layer dict\n        basemaps = self._layer_dict.get(\"Basemaps\", [])\n        if basemap not in basemaps:\n            self._layer_dict = {\n                **self._layer_dict,\n                \"Basemaps\": basemaps + [basemap],\n            }\n\n    # -------------------------------------------------------------------------\n    # Vector Data Methods\n    # -------------------------------------------------------------------------\n\n    def add_vector(\n        self,\n        data: Any,\n        layer_type: Optional[str] = None,\n        paint: Optional[Dict] = None,\n        name: Optional[str] = None,\n        fit_bounds: bool = True,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add vector data to the map.\n\n        Supports GeoJSON, GeoDataFrame, or file paths to vector formats.\n\n        Args:\n            data: GeoJSON dict, GeoDataFrame, or path to vector file\n            layer_type: MapLibre layer type ('circle', 'line', 'fill', 'symbol')\n            paint: MapLibre paint properties\n            name: Layer name\n            fit_bounds: Whether to fit map to data bounds\n            **kwargs: Additional layer options\n        \"\"\"\n        geojson = to_geojson(data)\n\n        layer_id = name or f\"vector-{len(self._layers)}\"\n\n        # Handle URL data - fetch GeoJSON to get bounds and infer layer type\n        if geojson.get(\"type\") == \"url\":\n            url = geojson[\"url\"]\n            # Fetch the actual GeoJSON data from URL\n            geojson = fetch_geojson(url)\n\n        # Infer layer type if not specified\n        if layer_type is None:\n            layer_type = infer_layer_type(geojson)\n\n        # Get default paint if not provided\n        if paint is None:\n            paint = get_default_paint(layer_type)\n\n        # Get bounds (use geojson dict, not original data which may be a URL)\n        bounds = get_bounds(geojson) if fit_bounds else None\n\n        # Call JavaScript\n        self.call_js_method(\n            \"addGeoJSON\",\n            data=geojson,\n            name=layer_id,\n            layerType=layer_type,\n            paint=paint,\n            fitBounds=fit_bounds,\n            bounds=bounds,\n            **kwargs,\n        )\n\n        # Track layer\n        self._layers = {\n            **self._layers,\n            layer_id: {\n                \"id\": layer_id,\n                \"type\": layer_type,\n                \"source\": f\"{layer_id}-source\",\n                \"paint\": paint,\n            },\n        }\n        self._add_to_layer_dict(layer_id, \"Vector\")\n\n    def add_geojson(\n        self,\n        data: Union[str, Dict],\n        layer_type: Optional[str] = None,\n        paint: Optional[Dict] = None,\n        name: Optional[str] = None,\n        fit_bounds: bool = True,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add GeoJSON data to the map.\n\n        Args:\n            data: GeoJSON dict or URL to GeoJSON file\n            layer_type: MapLibre layer type\n            paint: MapLibre paint properties\n            name: Layer name\n            fit_bounds: Whether to fit map to data bounds\n            **kwargs: Additional layer options\n        \"\"\"\n        self.add_vector(\n            data,\n            layer_type=layer_type,\n            paint=paint,\n            name=name,\n            fit_bounds=fit_bounds,\n            **kwargs,\n        )\n\n    # -------------------------------------------------------------------------\n    # Marker Methods\n    # -------------------------------------------------------------------------\n\n    def add_marker(\n        self,\n        lng: float,\n        lat: float,\n        popup: Optional[str] = None,\n        tooltip: Optional[str] = None,\n        color: str = \"#3388ff\",\n        draggable: bool = False,\n        scale: float = 1.0,\n        popup_max_width: str = \"240px\",\n        tooltip_max_width: str = \"240px\",\n        name: Optional[str] = None,\n        **kwargs,\n    ) -&gt; str:\n        \"\"\"Add a single marker to the map.\n\n        Args:\n            lng: Longitude of the marker.\n            lat: Latitude of the marker.\n            popup: Optional popup HTML content (shown on click).\n            tooltip: Optional tooltip HTML content (shown on hover).\n            color: Marker color as hex string.\n            draggable: Whether the marker can be dragged.\n            scale: Marker size multiplier (default 1.0, range 0.1 to 3.0).\n            popup_max_width: Maximum width of popup (CSS value, default \"240px\").\n            tooltip_max_width: Maximum width of tooltip (CSS value, default \"240px\").\n            name: Marker identifier. If None, auto-generated.\n            **kwargs: Additional marker options.\n\n        Returns:\n            The marker identifier.\n\n        Example:\n            &gt;&gt;&gt; from anymap_ts import Map\n            &gt;&gt;&gt; m = Map(center=[-122.4, 37.8], zoom=10)\n            &gt;&gt;&gt; m.add_marker(-122.4, 37.8, popup=\"San Francisco\", tooltip=\"Hover me!\")\n            &gt;&gt;&gt; m.add_marker(-122.5, 37.7, scale=1.5, color=\"#ff0000\")\n        \"\"\"\n        marker_id = name or f\"marker-{len(self._layers)}\"\n\n        self.call_js_method(\n            \"addMarker\",\n            lng,\n            lat,\n            id=marker_id,\n            popup=popup,\n            tooltip=tooltip,\n            color=color,\n            draggable=draggable,\n            scale=scale,\n            popupMaxWidth=popup_max_width,\n            tooltipMaxWidth=tooltip_max_width,\n            **kwargs,\n        )\n\n        self._layers = {\n            **self._layers,\n            marker_id: {\n                \"id\": marker_id,\n                \"type\": \"marker\",\n                \"lngLat\": [lng, lat],\n            },\n        }\n        self._add_to_layer_dict(marker_id, \"Markers\")\n        return marker_id\n\n    def add_markers(\n        self,\n        data: Any,\n        lng_column: Optional[str] = None,\n        lat_column: Optional[str] = None,\n        popup_column: Optional[str] = None,\n        tooltip_column: Optional[str] = None,\n        color: str = \"#3388ff\",\n        scale: float = 1.0,\n        popup_max_width: str = \"240px\",\n        tooltip_max_width: str = \"240px\",\n        draggable: bool = False,\n        name: Optional[str] = None,\n        **kwargs,\n    ) -&gt; str:\n        \"\"\"Add multiple markers from data.\n\n        Args:\n            data: Data source - can be:\n                - List of dicts with 'lng'/'lon'/'longitude' and 'lat'/'latitude' keys\n                - GeoDataFrame with Point geometries\n                - GeoJSON FeatureCollection with Point features\n            lng_column: Column name for longitude (auto-detected if None).\n            lat_column: Column name for latitude (auto-detected if None).\n            popup_column: Column name for popup content (shown on click).\n            tooltip_column: Column name for tooltip content (shown on hover).\n            color: Marker color as hex string.\n            scale: Marker size multiplier (default 1.0, range 0.1 to 3.0).\n            popup_max_width: Maximum width of popup (CSS value, default \"240px\").\n            tooltip_max_width: Maximum width of tooltip (CSS value, default \"240px\").\n            draggable: Whether markers can be dragged.\n            name: Layer identifier. If None, auto-generated.\n            **kwargs: Additional marker options.\n\n        Returns:\n            The layer identifier.\n\n        Example:\n            &gt;&gt;&gt; from anymap_ts import Map\n            &gt;&gt;&gt; m = Map()\n            &gt;&gt;&gt; cities = [\n            ...     {\"name\": \"SF\", \"info\": \"San Francisco\", \"lng\": -122.4, \"lat\": 37.8},\n            ...     {\"name\": \"NYC\", \"info\": \"New York City\", \"lng\": -74.0, \"lat\": 40.7},\n            ... ]\n            &gt;&gt;&gt; m.add_markers(cities, popup_column=\"name\", tooltip_column=\"info\", scale=1.5)\n        \"\"\"\n        layer_id = name or f\"markers-{len(self._layers)}\"\n        markers = []\n\n        # Handle GeoDataFrame\n        if hasattr(data, \"geometry\"):\n            for _, row in data.iterrows():\n                geom = row.geometry\n                if geom.geom_type == \"Point\":\n                    marker = {\"lngLat\": [geom.x, geom.y]}\n                    if popup_column and popup_column in row:\n                        marker[\"popup\"] = str(row[popup_column])\n                    if tooltip_column and tooltip_column in row:\n                        marker[\"tooltip\"] = str(row[tooltip_column])\n                    markers.append(marker)\n        # Handle GeoJSON\n        elif isinstance(data, dict) and data.get(\"type\") == \"FeatureCollection\":\n            for feature in data.get(\"features\", []):\n                geom = feature.get(\"geometry\", {})\n                if geom.get(\"type\") == \"Point\":\n                    coords = geom.get(\"coordinates\", [])\n                    marker = {\"lngLat\": coords[:2]}\n                    props = feature.get(\"properties\", {})\n                    if popup_column and popup_column in props:\n                        marker[\"popup\"] = str(props[popup_column])\n                    if tooltip_column and tooltip_column in props:\n                        marker[\"tooltip\"] = str(props[tooltip_column])\n                    markers.append(marker)\n        # Handle list of dicts\n        elif isinstance(data, list):\n            lng_keys = [\"lng\", \"lon\", \"longitude\", \"x\"]\n            lat_keys = [\"lat\", \"latitude\", \"y\"]\n\n            for item in data:\n                if not isinstance(item, dict):\n                    continue\n\n                # Find lng/lat values\n                lng_val = None\n                lat_val = None\n\n                if lng_column and lng_column in item:\n                    lng_val = item[lng_column]\n                else:\n                    for key in lng_keys:\n                        if key in item:\n                            lng_val = item[key]\n                            break\n\n                if lat_column and lat_column in item:\n                    lat_val = item[lat_column]\n                else:\n                    for key in lat_keys:\n                        if key in item:\n                            lat_val = item[key]\n                            break\n\n                if lng_val is not None and lat_val is not None:\n                    marker = {\"lngLat\": [float(lng_val), float(lat_val)]}\n                    if popup_column and popup_column in item:\n                        marker[\"popup\"] = str(item[popup_column])\n                    if tooltip_column and tooltip_column in item:\n                        marker[\"tooltip\"] = str(item[tooltip_column])\n                    markers.append(marker)\n\n        if not markers:\n            raise ValueError(\"No valid point data found in input\")\n\n        self.call_js_method(\n            \"addMarkers\",\n            id=layer_id,\n            markers=markers,\n            color=color,\n            scale=scale,\n            popupMaxWidth=popup_max_width,\n            tooltipMaxWidth=tooltip_max_width,\n            draggable=draggable,\n            **kwargs,\n        )\n\n        self._layers = {\n            **self._layers,\n            layer_id: {\n                \"id\": layer_id,\n                \"type\": \"markers\",\n                \"count\": len(markers),\n            },\n        }\n        self._add_to_layer_dict(layer_id, \"Markers\")\n        return layer_id\n\n    def remove_marker(self, marker_id: str) -&gt; None:\n        \"\"\"Remove a marker from the map.\n\n        Args:\n            marker_id: Marker identifier to remove.\n        \"\"\"\n        self._remove_layer_internal(marker_id, \"removeMarker\")\n\n    # -------------------------------------------------------------------------\n    # Heatmap Methods\n    # -------------------------------------------------------------------------\n\n    def add_heatmap(\n        self,\n        data: Any,\n        weight_property: Optional[str] = None,\n        radius: int = 20,\n        intensity: float = 1.0,\n        colormap: Optional[List] = None,\n        opacity: float = 0.8,\n        name: Optional[str] = None,\n        fit_bounds: bool = True,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a heatmap layer to the map.\n\n        Creates a heatmap visualization from point data using MapLibre's\n        native heatmap layer type.\n\n        Args:\n            data: Point data - can be GeoJSON, GeoDataFrame, or file path.\n            weight_property: Property name to use for point weights.\n                If None, all points have equal weight.\n            radius: Radius of influence for each point in pixels.\n            intensity: Intensity multiplier for the heatmap.\n            colormap: Color gradient as list of [stop, color] pairs.\n                Example: [[0, \"blue\"], [0.5, \"yellow\"], [1, \"red\"]]\n                Default: blue-yellow-red gradient.\n            opacity: Layer opacity (0-1).\n            name: Layer identifier. If None, auto-generated.\n            fit_bounds: Whether to fit map to data bounds.\n            **kwargs: Additional heatmap layer options.\n\n        Example:\n            &gt;&gt;&gt; from anymap_ts import Map\n            &gt;&gt;&gt; m = Map()\n            &gt;&gt;&gt; m.add_heatmap(\n            ...     \"earthquakes.geojson\",\n            ...     weight_property=\"magnitude\",\n            ...     radius=30,\n            ...     colormap=[[0, \"blue\"], [0.5, \"lime\"], [1, \"red\"]]\n            ... )\n        \"\"\"\n        self._validate_opacity(opacity)\n        layer_id = name or f\"heatmap-{len(self._layers)}\"\n\n        # Convert data to GeoJSON\n        geojson = to_geojson(data)\n\n        # Handle URL data - fetch GeoJSON\n        if geojson.get(\"type\") == \"url\":\n            url = geojson[\"url\"]\n            geojson = fetch_geojson(url)\n\n        # Default colormap\n        if colormap is None:\n            colormap = [\n                [0, \"rgba(33,102,172,0)\"],\n                [0.2, \"rgb(103,169,207)\"],\n                [0.4, \"rgb(209,229,240)\"],\n                [0.6, \"rgb(253,219,199)\"],\n                [0.8, \"rgb(239,138,98)\"],\n                [1, \"rgb(178,24,43)\"],\n            ]\n\n        # Build heatmap paint properties\n        paint = {\n            \"heatmap-radius\": radius,\n            \"heatmap-intensity\": intensity,\n            \"heatmap-opacity\": opacity,\n            \"heatmap-color\": [\n                \"interpolate\",\n                [\"linear\"],\n                [\"heatmap-density\"],\n            ],\n        }\n\n        # Add colormap stops\n        for stop, color in colormap:\n            paint[\"heatmap-color\"].extend([stop, color])\n\n        # Add weight if specified\n        if weight_property:\n            paint[\"heatmap-weight\"] = [\"get\", weight_property]\n\n        # Get bounds\n        bounds = get_bounds(geojson) if fit_bounds else None\n\n        self.call_js_method(\n            \"addGeoJSON\",\n            data=geojson,\n            name=layer_id,\n            layerType=\"heatmap\",\n            paint=paint,\n            fitBounds=fit_bounds,\n            bounds=bounds,\n            **kwargs,\n        )\n\n        self._layers = {\n            **self._layers,\n            layer_id: {\n                \"id\": layer_id,\n                \"type\": \"heatmap\",\n                \"source\": f\"{layer_id}-source\",\n                \"paint\": paint,\n            },\n        }\n        self._add_to_layer_dict(layer_id, \"Heatmap\")\n\n    # -------------------------------------------------------------------------\n    # Raster Data Methods\n    # -------------------------------------------------------------------------\n\n    def add_raster(\n        self,\n        source: str,\n        name: Optional[str] = None,\n        attribution: str = \"\",\n        indexes: Optional[List[int]] = None,\n        colormap: Optional[str] = None,\n        vmin: Optional[float] = None,\n        vmax: Optional[float] = None,\n        nodata: Optional[float] = None,\n        fit_bounds: bool = True,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a raster layer from a local file using localtileserver.\n\n        Args:\n            source: Path to local raster file\n            name: Layer name\n            attribution: Attribution text\n            indexes: Band indexes to use\n            colormap: Colormap name\n            vmin: Minimum value for colormap\n            vmax: Maximum value for colormap\n            nodata: NoData value\n            fit_bounds: Whether to fit map to raster bounds\n            **kwargs: Additional options\n        \"\"\"\n        try:\n            from localtileserver import TileClient\n        except ImportError:\n            raise ImportError(\n                \"localtileserver is required for local raster support. \"\n                \"Install with: pip install anymap-ts[raster]\"\n            )\n\n        client = TileClient(source)\n\n        # Build parameters dict and pass all at once\n        tile_params = {}\n        if indexes:\n            tile_params[\"indexes\"] = indexes\n        if colormap:\n            tile_params[\"colormap\"] = colormap\n        if vmin is not None or vmax is not None:\n            tile_params[\"vmin\"] = vmin if vmin is not None else client.min\n            tile_params[\"vmax\"] = vmax if vmax is not None else client.max\n        if nodata is not None:\n            tile_params[\"nodata\"] = nodata\n\n        tile_url = client.get_tile_url(**tile_params)\n\n        layer_name = name or Path(source).stem\n\n        self.add_tile_layer(\n            tile_url,\n            name=layer_name,\n            attribution=attribution,\n            **kwargs,\n        )\n\n        # Fit bounds if requested\n        if fit_bounds:\n            bounds = client.bounds()\n            if bounds:\n                self.fit_bounds([bounds[0], bounds[1], bounds[2], bounds[3]])\n\n    def add_tile_layer(\n        self,\n        url: str,\n        name: Optional[str] = None,\n        attribution: str = \"\",\n        min_zoom: int = 0,\n        max_zoom: int = 22,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add an XYZ tile layer.\n\n        Args:\n            url: Tile URL template with {x}, {y}, {z} placeholders\n            name: Layer name\n            attribution: Attribution text\n            min_zoom: Minimum zoom level\n            max_zoom: Maximum zoom level\n            **kwargs: Additional options\n        \"\"\"\n        layer_id = name or f\"tiles-{len(self._layers)}\"\n\n        self.call_js_method(\n            \"addTileLayer\",\n            url,\n            name=layer_id,\n            attribution=attribution,\n            minZoom=min_zoom,\n            maxZoom=max_zoom,\n            **kwargs,\n        )\n\n        # Track layer\n        self._layers = {\n            **self._layers,\n            layer_id: {\n                \"id\": layer_id,\n                \"type\": \"raster\",\n                \"source\": f\"{layer_id}-source\",\n            },\n        }\n        self._add_to_layer_dict(layer_id, \"Raster\")\n\n    def add_stac_layer(\n        self,\n        url: Optional[str] = None,\n        item: Optional[Any] = None,\n        assets: Optional[List[str]] = None,\n        colormap: Optional[str] = None,\n        rescale: Optional[List[float]] = None,\n        opacity: float = 1.0,\n        layer_id: Optional[str] = None,\n        titiler_endpoint: str = \"https://titiler.xyz\",\n        attribution: str = \"STAC\",\n        fit_bounds: bool = True,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a STAC (SpatioTemporal Asset Catalog) layer to the map.\n\n        Uses TiTiler to render STAC items as XYZ tiles on the map.\n        Supports both STAC item URLs and pystac Item objects.\n\n        Args:\n            url: URL to a STAC item JSON\n            item: A pystac Item object\n            assets: List of asset names/bands to visualize\n            colormap: Colormap name (e.g., 'viridis', 'plasma', 'inferno')\n            rescale: Min/max values for rescaling as [min, max]\n            opacity: Layer opacity (0-1)\n            layer_id: Custom layer identifier\n            titiler_endpoint: TiTiler server endpoint URL\n            attribution: Attribution text for the layer\n            fit_bounds: Whether to fit map to STAC item bounds\n            **kwargs: Additional tile layer options\n\n        Example:\n            &gt;&gt;&gt; from anymap_ts import Map\n            &gt;&gt;&gt; m = Map()\n            &gt;&gt;&gt; # From URL\n            &gt;&gt;&gt; m.add_stac_layer(\n            ...     url=\"https://planetarycomputer.microsoft.com/api/stac/v1/collections/sentinel-2-l2a/items/S2A_MSIL2A_20220101T181901_N0301_R027_T10TEM_20220101T201906\",\n            ...     assets=[\"red\", \"green\", \"blue\"],\n            ...     rescale=[0, 3000]\n            ... )\n            &gt;&gt;&gt; # From pystac Item\n            &gt;&gt;&gt; import pystac\n            &gt;&gt;&gt; item = pystac.Item.from_file(\"path/to/item.json\")\n            &gt;&gt;&gt; m.add_stac_layer(item=item, assets=[\"nir\", \"red\"], colormap=\"ndvi\")\n        \"\"\"\n        if url is None and item is None:\n            raise ValueError(\"Either 'url' or 'item' must be provided\")\n\n        if url is not None and item is not None:\n            raise ValueError(\"Provide either 'url' or 'item', not both\")\n\n        # Handle pystac Item object\n        if item is not None:\n            try:\n                # Check if it's a pystac Item\n                if hasattr(item, \"to_dict\") and hasattr(item, \"self_href\"):\n                    stac_url = item.self_href\n                    if not stac_url:\n                        # Try to get URL from item properties if no self_href\n                        if hasattr(item, \"links\"):\n                            for link in item.links:\n                                if link.rel == \"self\":\n                                    stac_url = link.href\n                                    break\n                        if not stac_url:\n                            raise ValueError(\n                                \"STAC item must have a self_href or self link for tile generation\"\n                            )\n                else:\n                    raise ValueError(\n                        \"Item must be a pystac Item object with to_dict() and self_href attributes\"\n                    )\n            except Exception as e:\n                raise ValueError(f\"Invalid STAC item: {e}\")\n        else:\n            stac_url = url\n\n        # Build TiTiler tile URL\n        tile_params = {\"url\": stac_url}\n\n        if assets:\n            tile_params[\"assets\"] = \",\".join(assets)\n        if colormap:\n            tile_params[\"colormap_name\"] = colormap\n        if rescale:\n            if len(rescale) == 2:\n                tile_params[\"rescale\"] = f\"{rescale[0]},{rescale[1]}\"\n            else:\n                raise ValueError(\"rescale must be a list of two values [min, max]\")\n\n        # Construct tile URL template\n        query_string = urlencode(tile_params)\n        tile_url = f\"{titiler_endpoint.rstrip('/')}/stac/tiles/{{z}}/{{x}}/{{y}}?{query_string}\"\n\n        layer_name = layer_id or f\"stac-{len(self._layers)}\"\n\n        # Add as tile layer\n        self.add_tile_layer(\n            url=tile_url,\n            name=layer_name,\n            attribution=attribution,\n            **kwargs,\n        )\n\n        # Update layer info to mark as STAC\n        if layer_name in self._layers:\n            self._layers[layer_name].update(\n                {\n                    \"stac_url\": stac_url,\n                    \"stac_assets\": assets,\n                    \"colormap\": colormap,\n                    \"rescale\": rescale,\n                }\n            )\n\n        # Try to fit bounds if requested and we have an item object\n        if fit_bounds and item is not None:\n            try:\n                bbox = item.bbox\n                if bbox and len(bbox) == 4:\n                    self.fit_bounds([[bbox[0], bbox[1]], [bbox[2], bbox[3]]])\n            except Exception:\n                pass  # Skip bounds fitting if bbox is not available\n\n    # -------------------------------------------------------------------------\n    # COG Layer (deck.gl)\n    # -------------------------------------------------------------------------\n\n    def add_cog_layer(\n        self,\n        url: str,\n        name: Optional[str] = None,\n        opacity: float = 1.0,\n        visible: bool = True,\n        debug: bool = False,\n        debug_opacity: float = 0.25,\n        max_error: float = 0.125,\n        fit_bounds: bool = True,\n        before_id: Optional[str] = None,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a Cloud Optimized GeoTIFF (COG) layer using @developmentseed/deck.gl-geotiff.\n\n        This method renders COG files directly in the browser using GPU-accelerated\n        deck.gl-geotiff rendering with automatic reprojection support.\n\n        Args:\n            url: URL to the Cloud Optimized GeoTIFF file.\n            name: Layer ID. If None, auto-generated.\n            opacity: Layer opacity (0-1).\n            visible: Whether layer is visible.\n            debug: Show reprojection mesh for debugging.\n            debug_opacity: Opacity of debug mesh (0-1).\n            max_error: Maximum reprojection error in pixels. Lower values\n                create denser mesh for better accuracy.\n            fit_bounds: Whether to fit map to COG bounds after loading.\n            before_id: ID of layer to insert before.\n            **kwargs: Additional COGLayer props.\n\n        Example:\n            &gt;&gt;&gt; from anymap_ts import Map\n            &gt;&gt;&gt; m = Map()\n            &gt;&gt;&gt; m.add_cog_layer(\n            ...     \"https://example.com/landcover.tif\",\n            ...     name=\"landcover\",\n            ...     opacity=0.8\n            ... )\n        \"\"\"\n        layer_id = name or f\"cog-{len(self._layers)}\"\n\n        self.call_js_method(\n            \"addCOGLayer\",\n            id=layer_id,\n            geotiff=url,\n            opacity=opacity,\n            visible=visible,\n            debug=debug,\n            debugOpacity=debug_opacity,\n            maxError=max_error,\n            fitBounds=fit_bounds,\n            beforeId=before_id,\n            **kwargs,\n        )\n\n        self._layers = {\n            **self._layers,\n            layer_id: {\n                \"id\": layer_id,\n                \"type\": \"cog\",\n                \"url\": url,\n            },\n        }\n        self._add_to_layer_dict(layer_id, \"Raster\")\n\n    def remove_cog_layer(self, layer_id: str) -&gt; None:\n        \"\"\"Remove a COG layer.\n\n        Args:\n            layer_id: Layer identifier to remove.\n        \"\"\"\n        self._remove_layer_internal(layer_id, \"removeCOGLayer\")\n\n    # -------------------------------------------------------------------------\n    # Zarr Layer (@carbonplan/zarr-layer)\n    # -------------------------------------------------------------------------\n\n    def add_zarr_layer(\n        self,\n        url: str,\n        variable: str,\n        name: Optional[str] = None,\n        colormap: Optional[List[str]] = None,\n        clim: Optional[Tuple[float, float]] = None,\n        opacity: float = 1.0,\n        selector: Optional[Dict[str, Any]] = None,\n        minzoom: int = 0,\n        maxzoom: int = 22,\n        fill_value: Optional[float] = None,\n        spatial_dimensions: Optional[Dict[str, str]] = None,\n        zarr_version: Optional[int] = None,\n        bounds: Optional[List[float]] = None,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a Zarr dataset layer for visualizing multidimensional array data.\n\n        This method renders Zarr pyramid datasets directly in the browser using\n        GPU-accelerated WebGL rendering via @carbonplan/zarr-layer.\n\n        Args:\n            url: URL to the Zarr store (pyramid format recommended).\n            variable: Variable name in the Zarr dataset to visualize.\n            name: Layer ID. If None, auto-generated.\n            colormap: List of hex color strings for visualization.\n                Example: ['#0000ff', '#ffff00', '#ff0000'] (blue-yellow-red).\n                Default: ['#000000', '#ffffff'] (black to white).\n            clim: Color range as (min, max) tuple.\n                Default: (0, 100).\n            opacity: Layer opacity (0-1).\n            selector: Dimension selector for multi-dimensional data.\n                Example: {\"month\": 4} to select 4th month.\n            minzoom: Minimum zoom level for rendering.\n            maxzoom: Maximum zoom level for rendering.\n            fill_value: No-data value (auto-detected from metadata if not set).\n            spatial_dimensions: Custom spatial dimension names.\n                Example: {\"lat\": \"y\", \"lon\": \"x\"} for non-standard names.\n            zarr_version: Zarr format version (2 or 3). Auto-detected if not set.\n            bounds: Explicit spatial bounds [xMin, yMin, xMax, yMax].\n                Units depend on CRS: degrees for EPSG:4326, meters for EPSG:3857.\n            **kwargs: Additional ZarrLayer props.\n\n        Example:\n            &gt;&gt;&gt; from anymap_ts import Map\n            &gt;&gt;&gt; m = Map()\n            &gt;&gt;&gt; m.add_zarr_layer(\n            ...     \"https://example.com/climate.zarr\",\n            ...     variable=\"temperature\",\n            ...     clim=(270, 310),\n            ...     colormap=['#0000ff', '#ffff00', '#ff0000'],\n            ...     selector={\"month\": 7}\n            ... )\n        \"\"\"\n        layer_id = name or f\"zarr-{len(self._layers)}\"\n\n        self.call_js_method(\n            \"addZarrLayer\",\n            id=layer_id,\n            source=url,\n            variable=variable,\n            colormap=colormap or [\"#000000\", \"#ffffff\"],\n            clim=list(clim) if clim else [0, 100],\n            opacity=opacity,\n            selector=selector or {},\n            minzoom=minzoom,\n            maxzoom=maxzoom,\n            fillValue=fill_value,\n            spatialDimensions=spatial_dimensions,\n            zarrVersion=zarr_version,\n            bounds=bounds,\n            **kwargs,\n        )\n\n        self._layers = {\n            **self._layers,\n            layer_id: {\n                \"id\": layer_id,\n                \"type\": \"zarr\",\n                \"url\": url,\n                \"variable\": variable,\n            },\n        }\n        self._add_to_layer_dict(layer_id, \"Raster\")\n\n    def remove_zarr_layer(self, layer_id: str) -&gt; None:\n        \"\"\"Remove a Zarr layer.\n\n        Args:\n            layer_id: Layer identifier to remove.\n        \"\"\"\n        self._remove_layer_internal(layer_id, \"removeZarrLayer\")\n\n    def update_zarr_layer(\n        self,\n        layer_id: str,\n        selector: Optional[Dict[str, Any]] = None,\n        clim: Optional[Tuple[float, float]] = None,\n        colormap: Optional[List[str]] = None,\n        opacity: Optional[float] = None,\n    ) -&gt; None:\n        \"\"\"Update a Zarr layer's properties dynamically.\n\n        Args:\n            layer_id: Layer identifier.\n            selector: New dimension selector.\n            clim: New color range.\n            colormap: New colormap.\n            opacity: New opacity value (0-1).\n        \"\"\"\n        update_kwargs: Dict[str, Any] = {\"id\": layer_id}\n        if selector is not None:\n            update_kwargs[\"selector\"] = selector\n        if clim is not None:\n            update_kwargs[\"clim\"] = list(clim)\n        if colormap is not None:\n            update_kwargs[\"colormap\"] = colormap\n        if opacity is not None:\n            update_kwargs[\"opacity\"] = opacity\n        self.call_js_method(\"updateZarrLayer\", **update_kwargs)\n\n    # -------------------------------------------------------------------------\n    # PMTiles Layer\n    # -------------------------------------------------------------------------\n\n    def add_pmtiles_layer(\n        self,\n        url: str,\n        layer_id: Optional[str] = None,\n        style: Optional[Dict[str, Any]] = None,\n        opacity: float = 1.0,\n        visible: bool = True,\n        fit_bounds: bool = False,\n        source_type: str = \"vector\",\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a PMTiles layer for efficient vector or raster tile serving.\n\n        PMTiles is a single-file archive format for pyramids of map tiles.\n        It enables efficient web-native map serving without requiring a\n        separate tile server infrastructure.\n\n        Args:\n            url: URL to the PMTiles file (e.g., \"https://example.com/data.pmtiles\").\n            layer_id: Layer identifier. If None, auto-generated.\n            style: Layer style configuration for vector tiles.\n                For vector PMTiles, can include:\n                - type: Layer type ('fill', 'line', 'circle', 'symbol')\n                - source-layer: Source layer name from vector tiles\n                - paint properties (e.g., 'fill-color', 'line-width')\n                - layout properties (e.g., 'visibility')\n                Example: {\"type\": \"line\", \"source-layer\": \"roads\", \"line-color\": \"#ff0000\"}\n            opacity: Layer opacity (0-1).\n            visible: Whether layer is initially visible.\n            fit_bounds: Whether to fit map to layer bounds after loading.\n            source_type: Source type - \"vector\" for vector PMTiles, \"raster\" for raster PMTiles.\n            **kwargs: Additional layer options.\n\n        Example:\n            &gt;&gt;&gt; from anymap_ts import Map\n            &gt;&gt;&gt; m = Map()\n            &gt;&gt;&gt; # Add vector PMTiles\n            &gt;&gt;&gt; m.add_pmtiles_layer(\n            ...     url=\"https://example.com/countries.pmtiles\",\n            ...     layer_id=\"countries\",\n            ...     style={\n            ...         \"type\": \"fill\",\n            ...         \"source-layer\": \"countries\",\n            ...         \"fill-color\": \"#3388ff\",\n            ...         \"fill-opacity\": 0.6\n            ...     }\n            ... )\n            &gt;&gt;&gt; # Add raster PMTiles\n            &gt;&gt;&gt; m.add_pmtiles_layer(\n            ...     url=\"https://example.com/satellite.pmtiles\",\n            ...     layer_id=\"satellite\",\n            ...     source_type=\"raster\",\n            ...     opacity=0.8\n            ... )\n        \"\"\"\n        layer_id = layer_id or f\"pmtiles-{len(self._layers)}\"\n\n        self.call_js_method(\n            \"addPMTilesLayer\",\n            url=url,\n            id=layer_id,\n            style=style or {},\n            opacity=opacity,\n            visible=visible,\n            fitBounds=fit_bounds,\n            sourceType=source_type,\n            name=layer_id,\n            **kwargs,\n        )\n\n        self._layers = {\n            **self._layers,\n            layer_id: {\n                \"id\": layer_id,\n                \"type\": \"pmtiles\",\n                \"url\": url,\n                \"source_type\": source_type,\n            },\n        }\n        category = \"Vector\" if source_type == \"vector\" else \"Raster\"\n        self._add_to_layer_dict(layer_id, category)\n\n    def remove_pmtiles_layer(self, layer_id: str) -&gt; None:\n        \"\"\"Remove a PMTiles layer.\n\n        Args:\n            layer_id: Layer identifier to remove.\n        \"\"\"\n        self._remove_layer_internal(layer_id, \"removePMTilesLayer\")\n\n    # -------------------------------------------------------------------------\n    # Arc Layer (deck.gl)\n    # -------------------------------------------------------------------------\n\n    def add_arc_layer(\n        self,\n        data: Any,\n        name: Optional[str] = None,\n        get_source_position: Union[str, Any] = \"source\",\n        get_target_position: Union[str, Any] = \"target\",\n        get_source_color: Optional[List[int]] = None,\n        get_target_color: Optional[List[int]] = None,\n        get_width: Union[float, str] = 1,\n        get_height: float = 1,\n        great_circle: bool = False,\n        pickable: bool = True,\n        opacity: float = 0.8,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add an arc layer for origin-destination visualization using deck.gl.\n\n        Arc layers are ideal for visualizing connections between locations,\n        such as flight routes, migration patterns, or network flows.\n\n        Args:\n            data: Array of data objects with source/target coordinates.\n                Each object should have source and target positions.\n            name: Layer ID. If None, auto-generated.\n            get_source_position: Accessor for source position [lng, lat].\n                Can be a string (property name) or a value.\n            get_target_position: Accessor for target position [lng, lat].\n                Can be a string (property name) or a value.\n            get_source_color: Source end color as [r, g, b, a].\n                Default: [51, 136, 255, 255] (blue).\n            get_target_color: Target end color as [r, g, b, a].\n                Default: [255, 136, 51, 255] (orange).\n            get_width: Arc width in pixels. Can be a number or accessor.\n            get_height: Arc height multiplier. Higher values create more curved arcs.\n            great_circle: Whether to draw arcs along great circles.\n            pickable: Whether layer responds to hover/click events.\n            opacity: Layer opacity (0-1).\n            **kwargs: Additional ArcLayer props.\n\n        Example:\n            &gt;&gt;&gt; from anymap_ts import MapLibreMap\n            &gt;&gt;&gt; m = MapLibreMap()\n            &gt;&gt;&gt; arcs = [\n            ...     {\"source\": [-122.4, 37.8], \"target\": [-73.9, 40.7]},\n            ...     {\"source\": [-122.4, 37.8], \"target\": [-0.1, 51.5]},\n            ... ]\n            &gt;&gt;&gt; m.add_arc_layer(arcs, name=\"flights\")\n        \"\"\"\n        layer_id = name or f\"arc-{len(self._layers)}\"\n        processed_data = self._process_deck_data(data)\n\n        self.call_js_method(\n            \"addArcLayer\",\n            id=layer_id,\n            data=processed_data,\n            getSourcePosition=get_source_position,\n            getTargetPosition=get_target_position,\n            getSourceColor=get_source_color or [51, 136, 255, 255],\n            getTargetColor=get_target_color or [255, 136, 51, 255],\n            getWidth=get_width,\n            getHeight=get_height,\n            greatCircle=great_circle,\n            pickable=pickable,\n            opacity=opacity,\n            **kwargs,\n        )\n\n        self._layers = {\n            **self._layers,\n            layer_id: {\n                \"id\": layer_id,\n                \"type\": \"arc\",\n            },\n        }\n        self._add_to_layer_dict(layer_id, \"Deck.gl\")\n\n    def remove_arc_layer(self, layer_id: str) -&gt; None:\n        \"\"\"Remove an arc layer.\n\n        Args:\n            layer_id: Layer identifier to remove.\n        \"\"\"\n        self._remove_layer_internal(layer_id, \"removeArcLayer\")\n\n    # -------------------------------------------------------------------------\n    # PointCloud Layer (deck.gl)\n    # -------------------------------------------------------------------------\n\n    def add_point_cloud_layer(\n        self,\n        data: Any,\n        name: Optional[str] = None,\n        get_position: Union[str, Any] = \"position\",\n        get_color: Optional[Union[List[int], str]] = None,\n        get_normal: Optional[Union[str, Any]] = None,\n        point_size: float = 2,\n        size_units: str = \"pixels\",\n        pickable: bool = True,\n        opacity: float = 1.0,\n        material: bool = True,\n        coordinate_system: Optional[int] = None,\n        coordinate_origin: Optional[List[float]] = None,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a point cloud layer for 3D point visualization using deck.gl.\n\n        Point cloud layers render large collections of 3D points, ideal for\n        LiDAR data, photogrammetry outputs, or any 3D point dataset.\n\n        Args:\n            data: Array of point data with positions. Each point should have\n                x, y, z coordinates (or position array).\n            name: Layer ID. If None, auto-generated.\n            get_position: Accessor for point position [x, y, z].\n                Can be a string (property name) or a value.\n            get_color: Accessor or value for point color [r, g, b, a].\n                Default: [255, 255, 255, 255] (white).\n            get_normal: Accessor for point normal [nx, ny, nz] for lighting.\n                Default: [0, 0, 1] (pointing up).\n            point_size: Point size in pixels or meters (depends on size_units).\n            size_units: Size units: 'pixels', 'meters', or 'common'.\n            pickable: Whether layer responds to hover/click events.\n            opacity: Layer opacity (0-1).\n            material: Whether to enable lighting effects.\n            coordinate_system: Coordinate system for positions.\n            coordinate_origin: Origin for coordinate system [x, y, z].\n            **kwargs: Additional PointCloudLayer props.\n\n        Example:\n            &gt;&gt;&gt; from anymap_ts import MapLibreMap\n            &gt;&gt;&gt; import numpy as np\n            &gt;&gt;&gt; m = MapLibreMap(pitch=45)\n            &gt;&gt;&gt; points = [\n            ...     {\"position\": [-122.4, 37.8, 100], \"color\": [255, 0, 0, 255]},\n            ...     {\"position\": [-122.3, 37.7, 200], \"color\": [0, 255, 0, 255]},\n            ... ]\n            &gt;&gt;&gt; m.add_point_cloud_layer(points, point_size=5)\n        \"\"\"\n        layer_id = name or f\"pointcloud-{len(self._layers)}\"\n        processed_data = self._process_deck_data(data)\n\n        self.call_js_method(\n            \"addPointCloudLayer\",\n            id=layer_id,\n            data=processed_data,\n            getPosition=get_position,\n            getColor=get_color or [255, 255, 255, 255],\n            getNormal=get_normal,\n            pointSize=point_size,\n            sizeUnits=size_units,\n            pickable=pickable,\n            opacity=opacity,\n            material=material,\n            coordinateSystem=coordinate_system,\n            coordinateOrigin=coordinate_origin,\n            **kwargs,\n        )\n\n        self._layers = {\n            **self._layers,\n            layer_id: {\n                \"id\": layer_id,\n                \"type\": \"pointcloud\",\n            },\n        }\n        self._add_to_layer_dict(layer_id, \"Deck.gl\")\n\n    def remove_point_cloud_layer(self, layer_id: str) -&gt; None:\n        \"\"\"Remove a point cloud layer.\n\n        Args:\n            layer_id: Layer identifier to remove.\n        \"\"\"\n        self._remove_layer_internal(layer_id, \"removePointCloudLayer\")\n\n    # -------------------------------------------------------------------------\n    # Scatterplot Layer (deck.gl)\n    # -------------------------------------------------------------------------\n\n    def add_scatterplot_layer(\n        self,\n        data: Any,\n        name: Optional[str] = None,\n        get_position: Union[str, Any] = \"coordinates\",\n        get_radius: Union[float, str] = 5,\n        get_fill_color: Optional[Union[List[int], str]] = None,\n        get_line_color: Optional[Union[List[int], str]] = None,\n        radius_scale: float = 1,\n        radius_min_pixels: float = 1,\n        radius_max_pixels: float = 100,\n        line_width_min_pixels: float = 1,\n        stroked: bool = True,\n        filled: bool = True,\n        pickable: bool = True,\n        opacity: float = 0.8,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a scatterplot layer for sized/colored point visualization using deck.gl.\n\n        Scatterplot layers render circles at given coordinates with configurable\n        radius and color, ideal for point datasets where size and color encode data.\n\n        Args:\n            data: Array of data objects or GeoJSON with point coordinates.\n            name: Layer ID. If None, auto-generated.\n            get_position: Accessor for point position [lng, lat].\n                Can be a string (property name) or a value.\n            get_radius: Accessor for point radius in meters.\n            get_fill_color: Accessor for fill color [r, g, b, a].\n                Default: [51, 136, 255, 200] (blue).\n            get_line_color: Accessor for stroke color [r, g, b, a].\n                Default: [255, 255, 255, 255] (white).\n            radius_scale: Global radius multiplier.\n            radius_min_pixels: Minimum radius in pixels.\n            radius_max_pixels: Maximum radius in pixels.\n            line_width_min_pixels: Minimum stroke width in pixels.\n            stroked: Whether to draw stroke around points.\n            filled: Whether to fill points.\n            pickable: Whether layer responds to hover/click events.\n            opacity: Layer opacity (0-1).\n            **kwargs: Additional ScatterplotLayer props.\n\n        Example:\n            &gt;&gt;&gt; from anymap_ts import MapLibreMap\n            &gt;&gt;&gt; m = MapLibreMap()\n            &gt;&gt;&gt; points = [\n            ...     {\"coordinates\": [-122.4, 37.8], \"size\": 100},\n            ...     {\"coordinates\": [-122.5, 37.7], \"size\": 200},\n            ... ]\n            &gt;&gt;&gt; m.add_scatterplot_layer(points, get_radius=\"size\")\n        \"\"\"\n        layer_id = name or f\"scatterplot-{len(self._layers)}\"\n        processed_data = self._process_deck_data(data)\n\n        self.call_js_method(\n            \"addScatterplotLayer\",\n            id=layer_id,\n            data=processed_data,\n            getPosition=get_position,\n            getRadius=get_radius,\n            getFillColor=get_fill_color or [51, 136, 255, 200],\n            getLineColor=get_line_color or [255, 255, 255, 255],\n            radiusScale=radius_scale,\n            radiusMinPixels=radius_min_pixels,\n            radiusMaxPixels=radius_max_pixels,\n            lineWidthMinPixels=line_width_min_pixels,\n            stroked=stroked,\n            filled=filled,\n            pickable=pickable,\n            opacity=opacity,\n            **kwargs,\n        )\n\n        self._layers = {\n            **self._layers,\n            layer_id: {\n                \"id\": layer_id,\n                \"type\": \"scatterplot\",\n            },\n        }\n        self._add_to_layer_dict(layer_id, \"Deck.gl\")\n\n    # -------------------------------------------------------------------------\n    # Path Layer (deck.gl)\n    # -------------------------------------------------------------------------\n\n    def add_path_layer(\n        self,\n        data: Any,\n        name: Optional[str] = None,\n        get_path: Union[str, Any] = \"path\",\n        get_color: Optional[Union[List[int], str]] = None,\n        get_width: Union[float, str] = 1,\n        width_scale: float = 1,\n        width_min_pixels: float = 1,\n        pickable: bool = True,\n        opacity: float = 0.8,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a path layer for route/trajectory rendering using deck.gl.\n\n        Path layers render polylines defined by arrays of coordinates,\n        ideal for visualizing routes, trajectories, or any line-based data.\n\n        Args:\n            data: Array of data objects with path coordinates.\n            name: Layer ID. If None, auto-generated.\n            get_path: Accessor for path coordinates [[lng, lat], ...].\n                Can be a string (property name) or a value.\n            get_color: Accessor for path color [r, g, b, a].\n                Default: [51, 136, 255, 200] (blue).\n            get_width: Accessor for path width in meters.\n            width_scale: Global width multiplier.\n            width_min_pixels: Minimum width in pixels.\n            pickable: Whether layer responds to hover/click events.\n            opacity: Layer opacity (0-1).\n            **kwargs: Additional PathLayer props.\n\n        Example:\n            &gt;&gt;&gt; from anymap_ts import MapLibreMap\n            &gt;&gt;&gt; m = MapLibreMap()\n            &gt;&gt;&gt; routes = [\n            ...     {\"path\": [[-122.4, 37.8], [-122.5, 37.7], [-122.6, 37.8]]},\n            ... ]\n            &gt;&gt;&gt; m.add_path_layer(routes, get_color=[255, 0, 0], get_width=3)\n        \"\"\"\n        layer_id = name or f\"path-{len(self._layers)}\"\n        processed_data = self._process_deck_data(data)\n\n        self.call_js_method(\n            \"addPathLayer\",\n            id=layer_id,\n            data=processed_data,\n            getPath=get_path,\n            getColor=get_color or [51, 136, 255, 200],\n            getWidth=get_width,\n            widthScale=width_scale,\n            widthMinPixels=width_min_pixels,\n            pickable=pickable,\n            opacity=opacity,\n            **kwargs,\n        )\n\n        self._layers = {\n            **self._layers,\n            layer_id: {\n                \"id\": layer_id,\n                \"type\": \"path\",\n            },\n        }\n        self._add_to_layer_dict(layer_id, \"Deck.gl\")\n\n    # -------------------------------------------------------------------------\n    # Polygon Layer (deck.gl)\n    # -------------------------------------------------------------------------\n\n    def add_polygon_layer(\n        self,\n        data: Any,\n        name: Optional[str] = None,\n        get_polygon: Union[str, Any] = \"polygon\",\n        get_fill_color: Optional[Union[List[int], str]] = None,\n        get_line_color: Optional[Union[List[int], str]] = None,\n        get_line_width: Union[float, str] = 1,\n        get_elevation: Union[float, str] = 0,\n        extruded: bool = False,\n        wireframe: bool = False,\n        filled: bool = True,\n        stroked: bool = True,\n        line_width_min_pixels: float = 1,\n        pickable: bool = True,\n        opacity: float = 0.5,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a polygon layer for filled polygon visualization using deck.gl.\n\n        Polygon layers render filled and/or stroked polygons with optional\n        3D extrusion, ideal for choropleth maps and area visualizations.\n\n        Args:\n            data: Array of data objects with polygon coordinates.\n            name: Layer ID. If None, auto-generated.\n            get_polygon: Accessor for polygon coordinates.\n                Can be a string (property name) or a value.\n            get_fill_color: Accessor for fill color [r, g, b, a].\n                Default: [51, 136, 255, 128].\n            get_line_color: Accessor for stroke color [r, g, b, a].\n                Default: [0, 0, 255, 255].\n            get_line_width: Accessor for stroke width.\n            get_elevation: Accessor for 3D extrusion height.\n            extruded: Whether to render as 3D polygons.\n            wireframe: Whether to render wireframe (extruded only).\n            filled: Whether to fill polygons.\n            stroked: Whether to draw stroke.\n            line_width_min_pixels: Minimum stroke width in pixels.\n            pickable: Whether layer responds to hover/click events.\n            opacity: Layer opacity (0-1).\n            **kwargs: Additional PolygonLayer props.\n\n        Example:\n            &gt;&gt;&gt; from anymap_ts import MapLibreMap\n            &gt;&gt;&gt; m = MapLibreMap(pitch=45)\n            &gt;&gt;&gt; polygons = [\n            ...     {\"polygon\": [[-122.4, 37.8], [-122.5, 37.7], [-122.3, 37.7]], \"height\": 1000},\n            ... ]\n            &gt;&gt;&gt; m.add_polygon_layer(polygons, extruded=True, get_elevation=\"height\")\n        \"\"\"\n        layer_id = name or f\"polygon-{len(self._layers)}\"\n        processed_data = self._process_deck_data(data)\n\n        self.call_js_method(\n            \"addPolygonLayer\",\n            id=layer_id,\n            data=processed_data,\n            getPolygon=get_polygon,\n            getFillColor=get_fill_color or [51, 136, 255, 128],\n            getLineColor=get_line_color or [0, 0, 255, 255],\n            getLineWidth=get_line_width,\n            getElevation=get_elevation,\n            extruded=extruded,\n            wireframe=wireframe,\n            filled=filled,\n            stroked=stroked,\n            lineWidthMinPixels=line_width_min_pixels,\n            pickable=pickable,\n            opacity=opacity,\n            **kwargs,\n        )\n\n        self._layers = {\n            **self._layers,\n            layer_id: {\n                \"id\": layer_id,\n                \"type\": \"polygon\",\n            },\n        }\n        self._add_to_layer_dict(layer_id, \"Deck.gl\")\n\n    # -------------------------------------------------------------------------\n    # Hexagon Layer (deck.gl)\n    # -------------------------------------------------------------------------\n\n    def add_hexagon_layer(\n        self,\n        data: Any,\n        name: Optional[str] = None,\n        get_position: Union[str, Any] = \"coordinates\",\n        radius: float = 1000,\n        elevation_scale: float = 4,\n        extruded: bool = True,\n        color_range: Optional[List[List[int]]] = None,\n        pickable: bool = True,\n        opacity: float = 0.8,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a hexagon layer for hexagonal binning/aggregation using deck.gl.\n\n        Hexagon layers aggregate points into hexagonal bins and render them\n        with height and color based on point density.\n\n        Args:\n            data: Array of data objects with position coordinates.\n            name: Layer ID. If None, auto-generated.\n            get_position: Accessor for point position [lng, lat].\n            radius: Hexagon radius in meters.\n            elevation_scale: Elevation multiplier for 3D hexagons.\n            extruded: Whether to render as 3D hexagons.\n            color_range: Color gradient for aggregation [[r, g, b], ...].\n            pickable: Whether layer responds to hover/click events.\n            opacity: Layer opacity (0-1).\n            **kwargs: Additional HexagonLayer props.\n\n        Example:\n            &gt;&gt;&gt; from anymap_ts import MapLibreMap\n            &gt;&gt;&gt; m = MapLibreMap(pitch=45)\n            &gt;&gt;&gt; points = [\n            ...     {\"coordinates\": [-122.4, 37.8]},\n            ...     {\"coordinates\": [-122.41, 37.81]},\n            ... ]\n            &gt;&gt;&gt; m.add_hexagon_layer(points, radius=500, elevation_scale=10)\n        \"\"\"\n        layer_id = name or f\"hexagon-{len(self._layers)}\"\n        processed_data = self._process_deck_data(data)\n\n        default_color_range = [\n            [1, 152, 189],\n            [73, 227, 206],\n            [216, 254, 181],\n            [254, 237, 177],\n            [254, 173, 84],\n            [209, 55, 78],\n        ]\n\n        self.call_js_method(\n            \"addHexagonLayer\",\n            id=layer_id,\n            data=processed_data,\n            getPosition=get_position,\n            radius=radius,\n            elevationScale=elevation_scale,\n            extruded=extruded,\n            colorRange=color_range or default_color_range,\n            pickable=pickable,\n            opacity=opacity,\n            **kwargs,\n        )\n\n        self._layers = {\n            **self._layers,\n            layer_id: {\n                \"id\": layer_id,\n                \"type\": \"hexagon\",\n            },\n        }\n        self._add_to_layer_dict(layer_id, \"Deck.gl\")\n\n    # -------------------------------------------------------------------------\n    # Deck.gl Heatmap Layer\n    # -------------------------------------------------------------------------\n\n    def add_deck_heatmap_layer(\n        self,\n        data: Any,\n        name: Optional[str] = None,\n        get_position: Union[str, Any] = \"coordinates\",\n        get_weight: Union[float, str] = 1,\n        radius_pixels: float = 30,\n        intensity: float = 1,\n        threshold: float = 0.05,\n        color_range: Optional[List[List[int]]] = None,\n        opacity: float = 1,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a GPU-accelerated heatmap layer using deck.gl.\n\n        This is an alternative to the native MapLibre heatmap layer, using\n        deck.gl's GPU-based rendering for better performance with large datasets.\n\n        Args:\n            data: Array of data objects with position coordinates.\n            name: Layer ID. If None, auto-generated.\n            get_position: Accessor for point position [lng, lat].\n            get_weight: Accessor for point weight value.\n            radius_pixels: Influence radius in pixels.\n            intensity: Intensity multiplier.\n            threshold: Minimum density threshold (0-1).\n            color_range: Color gradient [[r, g, b, a], ...].\n            opacity: Layer opacity (0-1).\n            **kwargs: Additional HeatmapLayer props.\n\n        Example:\n            &gt;&gt;&gt; from anymap_ts import MapLibreMap\n            &gt;&gt;&gt; m = MapLibreMap()\n            &gt;&gt;&gt; points = [\n            ...     {\"coordinates\": [-122.4, 37.8], \"weight\": 5},\n            ...     {\"coordinates\": [-122.5, 37.7], \"weight\": 10},\n            ... ]\n            &gt;&gt;&gt; m.add_deck_heatmap_layer(points, get_weight=\"weight\")\n        \"\"\"\n        layer_id = name or f\"deck-heatmap-{len(self._layers)}\"\n        processed_data = self._process_deck_data(data)\n\n        default_color_range = [\n            [255, 255, 178, 25],\n            [254, 217, 118, 85],\n            [254, 178, 76, 127],\n            [253, 141, 60, 170],\n            [240, 59, 32, 212],\n            [189, 0, 38, 255],\n        ]\n\n        self.call_js_method(\n            \"addHeatmapLayer\",\n            id=layer_id,\n            data=processed_data,\n            getPosition=get_position,\n            getWeight=get_weight,\n            radiusPixels=radius_pixels,\n            intensity=intensity,\n            threshold=threshold,\n            colorRange=color_range or default_color_range,\n            opacity=opacity,\n            **kwargs,\n        )\n\n        self._layers = {\n            **self._layers,\n            layer_id: {\n                \"id\": layer_id,\n                \"type\": \"deck-heatmap\",\n            },\n        }\n        self._add_to_layer_dict(layer_id, \"Deck.gl\")\n\n    # -------------------------------------------------------------------------\n    # Grid Layer (deck.gl)\n    # -------------------------------------------------------------------------\n\n    def add_grid_layer(\n        self,\n        data: Any,\n        name: Optional[str] = None,\n        get_position: Union[str, Any] = \"coordinates\",\n        cell_size: float = 200,\n        elevation_scale: float = 4,\n        extruded: bool = True,\n        color_range: Optional[List[List[int]]] = None,\n        pickable: bool = True,\n        opacity: float = 0.8,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a grid layer for square grid aggregation using deck.gl.\n\n        Grid layers aggregate points into square grid cells and render them\n        with height and color based on point density.\n\n        Args:\n            data: Array of data objects with position coordinates.\n            name: Layer ID. If None, auto-generated.\n            get_position: Accessor for point position [lng, lat].\n            cell_size: Grid cell size in meters.\n            elevation_scale: Elevation multiplier for 3D cells.\n            extruded: Whether to render as 3D cells.\n            color_range: Color gradient [[r, g, b], ...].\n            pickable: Whether layer responds to hover/click events.\n            opacity: Layer opacity (0-1).\n            **kwargs: Additional GridLayer props.\n\n        Example:\n            &gt;&gt;&gt; from anymap_ts import MapLibreMap\n            &gt;&gt;&gt; m = MapLibreMap(pitch=45)\n            &gt;&gt;&gt; points = [\n            ...     {\"coordinates\": [-122.4, 37.8]},\n            ...     {\"coordinates\": [-122.41, 37.81]},\n            ... ]\n            &gt;&gt;&gt; m.add_grid_layer(points, cell_size=500)\n        \"\"\"\n        layer_id = name or f\"grid-{len(self._layers)}\"\n        processed_data = self._process_deck_data(data)\n\n        default_color_range = [\n            [1, 152, 189],\n            [73, 227, 206],\n            [216, 254, 181],\n            [254, 237, 177],\n            [254, 173, 84],\n            [209, 55, 78],\n        ]\n\n        self.call_js_method(\n            \"addGridLayer\",\n            id=layer_id,\n            data=processed_data,\n            getPosition=get_position,\n            cellSize=cell_size,\n            elevationScale=elevation_scale,\n            extruded=extruded,\n            colorRange=color_range or default_color_range,\n            pickable=pickable,\n            opacity=opacity,\n            **kwargs,\n        )\n\n        self._layers = {\n            **self._layers,\n            layer_id: {\n                \"id\": layer_id,\n                \"type\": \"grid\",\n            },\n        }\n        self._add_to_layer_dict(layer_id, \"Deck.gl\")\n\n    # -------------------------------------------------------------------------\n    # Icon Layer (deck.gl)\n    # -------------------------------------------------------------------------\n\n    def add_icon_layer(\n        self,\n        data: Any,\n        name: Optional[str] = None,\n        get_position: Union[str, Any] = \"coordinates\",\n        get_icon: Union[str, Any] = \"icon\",\n        get_size: Union[float, str] = 20,\n        get_color: Optional[Union[List[int], str]] = None,\n        icon_atlas: Optional[str] = None,\n        icon_mapping: Optional[Dict] = None,\n        pickable: bool = True,\n        opacity: float = 1,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add an icon layer for custom icon markers at scale using deck.gl.\n\n        Icon layers render icons/images at specified positions, ideal for\n        rendering large numbers of custom markers efficiently.\n\n        Args:\n            data: Array of data objects with position coordinates.\n            name: Layer ID. If None, auto-generated.\n            get_position: Accessor for icon position [lng, lat].\n            get_icon: Accessor for icon name in icon_mapping.\n            get_size: Accessor for icon size in pixels.\n            get_color: Accessor for icon tint color [r, g, b, a].\n                Default: [255, 255, 255, 255] (white, no tint).\n            icon_atlas: URL to icon atlas image.\n            icon_mapping: Dict mapping icon names to atlas coordinates.\n            pickable: Whether layer responds to hover/click events.\n            opacity: Layer opacity (0-1).\n            **kwargs: Additional IconLayer props.\n\n        Example:\n            &gt;&gt;&gt; from anymap_ts import MapLibreMap\n            &gt;&gt;&gt; m = MapLibreMap()\n            &gt;&gt;&gt; markers = [\n            ...     {\"coordinates\": [-122.4, 37.8], \"icon\": \"marker\", \"size\": 30},\n            ... ]\n            &gt;&gt;&gt; m.add_icon_layer(markers, get_size=\"size\")\n        \"\"\"\n        layer_id = name or f\"icon-{len(self._layers)}\"\n        processed_data = self._process_deck_data(data)\n\n        self.call_js_method(\n            \"addIconLayer\",\n            id=layer_id,\n            data=processed_data,\n            getPosition=get_position,\n            getIcon=get_icon,\n            getSize=get_size,\n            getColor=get_color or [255, 255, 255, 255],\n            iconAtlas=icon_atlas,\n            iconMapping=icon_mapping,\n            pickable=pickable,\n            opacity=opacity,\n            **kwargs,\n        )\n\n        self._layers = {\n            **self._layers,\n            layer_id: {\n                \"id\": layer_id,\n                \"type\": \"icon\",\n            },\n        }\n        self._add_to_layer_dict(layer_id, \"Deck.gl\")\n\n    # -------------------------------------------------------------------------\n    # Text Layer (deck.gl)\n    # -------------------------------------------------------------------------\n\n    def add_text_layer(\n        self,\n        data: Any,\n        name: Optional[str] = None,\n        get_position: Union[str, Any] = \"coordinates\",\n        get_text: Union[str, Any] = \"text\",\n        get_size: Union[float, str] = 12,\n        get_color: Optional[Union[List[int], str]] = None,\n        get_angle: Union[float, str] = 0,\n        text_anchor: str = \"middle\",\n        alignment_baseline: str = \"center\",\n        pickable: bool = True,\n        opacity: float = 1,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a text layer for label placement using deck.gl.\n\n        Text layers render text labels at specified positions, ideal for\n        annotating map features or creating label layers.\n\n        Args:\n            data: Array of data objects with position and text.\n            name: Layer ID. If None, auto-generated.\n            get_position: Accessor for text position [lng, lat].\n            get_text: Accessor for text content string.\n            get_size: Accessor for text size in pixels.\n            get_color: Accessor for text color [r, g, b, a].\n                Default: [0, 0, 0, 255] (black).\n            get_angle: Accessor for text rotation in degrees.\n            text_anchor: Horizontal alignment ('start', 'middle', 'end').\n            alignment_baseline: Vertical alignment ('top', 'center', 'bottom').\n            pickable: Whether layer responds to hover/click events.\n            opacity: Layer opacity (0-1).\n            **kwargs: Additional TextLayer props.\n\n        Example:\n            &gt;&gt;&gt; from anymap_ts import MapLibreMap\n            &gt;&gt;&gt; m = MapLibreMap()\n            &gt;&gt;&gt; labels = [\n            ...     {\"coordinates\": [-122.4, 37.8], \"text\": \"San Francisco\"},\n            ...     {\"coordinates\": [-118.2, 34.1], \"text\": \"Los Angeles\"},\n            ... ]\n            &gt;&gt;&gt; m.add_text_layer(labels, get_size=16)\n        \"\"\"\n        layer_id = name or f\"text-{len(self._layers)}\"\n        processed_data = self._process_deck_data(data)\n\n        self.call_js_method(\n            \"addTextLayer\",\n            id=layer_id,\n            data=processed_data,\n            getPosition=get_position,\n            getText=get_text,\n            getSize=get_size,\n            getColor=get_color or [0, 0, 0, 255],\n            getAngle=get_angle,\n            getTextAnchor=text_anchor,\n            getAlignmentBaseline=alignment_baseline,\n            pickable=pickable,\n            opacity=opacity,\n            **kwargs,\n        )\n\n        self._layers = {\n            **self._layers,\n            layer_id: {\n                \"id\": layer_id,\n                \"type\": \"text\",\n            },\n        }\n        self._add_to_layer_dict(layer_id, \"Deck.gl\")\n\n    # -------------------------------------------------------------------------\n    # GeoJSON Layer (deck.gl)\n    # -------------------------------------------------------------------------\n\n    def add_geojson_layer(\n        self,\n        data: Any,\n        name: Optional[str] = None,\n        get_fill_color: Optional[Union[List[int], str]] = None,\n        get_line_color: Optional[Union[List[int], str]] = None,\n        get_line_width: Union[float, str] = 1,\n        get_point_radius: Union[float, str] = 5,\n        get_elevation: Union[float, str] = 0,\n        extruded: bool = False,\n        wireframe: bool = False,\n        filled: bool = True,\n        stroked: bool = True,\n        line_width_min_pixels: float = 1,\n        point_radius_min_pixels: float = 2,\n        pickable: bool = True,\n        opacity: float = 0.8,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a GeoJSON layer with auto-styling using deck.gl.\n\n        GeoJSON layers render GeoJSON features with automatic geometry type\n        detection and styling, supporting points, lines, and polygons.\n\n        Args:\n            data: GeoJSON object, URL, or file path.\n            name: Layer ID. If None, auto-generated.\n            get_fill_color: Accessor for fill color [r, g, b, a].\n                Default: [51, 136, 255, 128].\n            get_line_color: Accessor for stroke color [r, g, b, a].\n                Default: [0, 0, 0, 255].\n            get_line_width: Accessor for stroke width.\n            get_point_radius: Accessor for point radius.\n            get_elevation: Accessor for 3D extrusion height.\n            extruded: Whether to render as 3D features.\n            wireframe: Whether to render wireframe (extruded only).\n            filled: Whether to fill features.\n            stroked: Whether to draw stroke.\n            line_width_min_pixels: Minimum stroke width in pixels.\n            point_radius_min_pixels: Minimum point radius in pixels.\n            pickable: Whether layer responds to hover/click events.\n            opacity: Layer opacity (0-1).\n            **kwargs: Additional GeoJsonLayer props.\n\n        Example:\n            &gt;&gt;&gt; from anymap_ts import MapLibreMap\n            &gt;&gt;&gt; m = MapLibreMap()\n            &gt;&gt;&gt; m.add_geojson_layer(\n            ...     \"https://example.com/data.geojson\",\n            ...     get_fill_color=[255, 0, 0, 128],\n            ... )\n        \"\"\"\n        layer_id = name or f\"geojson-deck-{len(self._layers)}\"\n        processed_data = self._process_deck_data(data)\n\n        self.call_js_method(\n            \"addGeoJsonLayer\",\n            id=layer_id,\n            data=processed_data,\n            getFillColor=get_fill_color or [51, 136, 255, 128],\n            getLineColor=get_line_color or [0, 0, 0, 255],\n            getLineWidth=get_line_width,\n            getPointRadius=get_point_radius,\n            getElevation=get_elevation,\n            extruded=extruded,\n            wireframe=wireframe,\n            filled=filled,\n            stroked=stroked,\n            lineWidthMinPixels=line_width_min_pixels,\n            pointRadiusMinPixels=point_radius_min_pixels,\n            pickable=pickable,\n            opacity=opacity,\n            **kwargs,\n        )\n\n        self._layers = {\n            **self._layers,\n            layer_id: {\n                \"id\": layer_id,\n                \"type\": \"geojson-deck\",\n            },\n        }\n        self._add_to_layer_dict(layer_id, \"Deck.gl\")\n\n    # -------------------------------------------------------------------------\n    # Contour Layer (deck.gl)\n    # -------------------------------------------------------------------------\n\n    def add_contour_layer(\n        self,\n        data: Any,\n        name: Optional[str] = None,\n        get_position: Union[str, Any] = \"coordinates\",\n        get_weight: Union[float, str] = 1,\n        cell_size: float = 200,\n        contours: Optional[List[Dict]] = None,\n        pickable: bool = True,\n        opacity: float = 1,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a contour layer for isoline/isoband generation using deck.gl.\n\n        Contour layers aggregate point data and generate isolines or isobands,\n        ideal for density visualization and topographic-style maps.\n\n        Args:\n            data: Array of data objects with position coordinates.\n            name: Layer ID. If None, auto-generated.\n            get_position: Accessor for point position [lng, lat].\n            get_weight: Accessor for point weight value.\n            cell_size: Grid cell size for aggregation in meters.\n            contours: Contour definitions [{threshold, color, strokeWidth}, ...].\n            pickable: Whether layer responds to hover/click events.\n            opacity: Layer opacity (0-1).\n            **kwargs: Additional ContourLayer props.\n\n        Example:\n            &gt;&gt;&gt; from anymap_ts import MapLibreMap\n            &gt;&gt;&gt; m = MapLibreMap()\n            &gt;&gt;&gt; points = [\n            ...     {\"coordinates\": [-122.4, 37.8], \"weight\": 5},\n            ...     {\"coordinates\": [-122.41, 37.81], \"weight\": 10},\n            ... ]\n            &gt;&gt;&gt; m.add_contour_layer(points, contours=[\n            ...     {\"threshold\": 1, \"color\": [255, 255, 178], \"strokeWidth\": 1},\n            ...     {\"threshold\": 5, \"color\": [253, 141, 60], \"strokeWidth\": 2},\n            ... ])\n        \"\"\"\n        layer_id = name or f\"contour-{len(self._layers)}\"\n        processed_data = self._process_deck_data(data)\n\n        default_contours = [\n            {\"threshold\": 1, \"color\": [255, 255, 255], \"strokeWidth\": 1},\n            {\"threshold\": 5, \"color\": [51, 136, 255], \"strokeWidth\": 2},\n            {\"threshold\": 10, \"color\": [0, 0, 255], \"strokeWidth\": 3},\n        ]\n\n        self.call_js_method(\n            \"addContourLayer\",\n            id=layer_id,\n            data=processed_data,\n            getPosition=get_position,\n            getWeight=get_weight,\n            cellSize=cell_size,\n            contours=contours or default_contours,\n            pickable=pickable,\n            opacity=opacity,\n            **kwargs,\n        )\n\n        self._layers = {\n            **self._layers,\n            layer_id: {\n                \"id\": layer_id,\n                \"type\": \"contour\",\n            },\n        }\n        self._add_to_layer_dict(layer_id, \"Deck.gl\")\n\n    # -------------------------------------------------------------------------\n    # Screen Grid Layer (deck.gl)\n    # -------------------------------------------------------------------------\n\n    def add_screen_grid_layer(\n        self,\n        data: Any,\n        name: Optional[str] = None,\n        get_position: Union[str, Any] = \"coordinates\",\n        get_weight: Union[float, str] = 1,\n        cell_size_pixels: float = 50,\n        color_range: Optional[List[List[int]]] = None,\n        pickable: bool = True,\n        opacity: float = 0.8,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a screen grid layer for screen-space grid aggregation using deck.gl.\n\n        Screen grid layers aggregate points into a grid in screen space,\n        providing a fast overview of point density that updates on zoom/pan.\n\n        Args:\n            data: Array of data objects with position coordinates.\n            name: Layer ID. If None, auto-generated.\n            get_position: Accessor for point position [lng, lat].\n            get_weight: Accessor for point weight value.\n            cell_size_pixels: Grid cell size in screen pixels.\n            color_range: Color gradient [[r, g, b, a], ...].\n            pickable: Whether layer responds to hover/click events.\n            opacity: Layer opacity (0-1).\n            **kwargs: Additional ScreenGridLayer props.\n\n        Example:\n            &gt;&gt;&gt; from anymap_ts import MapLibreMap\n            &gt;&gt;&gt; m = MapLibreMap()\n            &gt;&gt;&gt; points = [\n            ...     {\"coordinates\": [-122.4, 37.8]},\n            ...     {\"coordinates\": [-122.41, 37.81]},\n            ... ]\n            &gt;&gt;&gt; m.add_screen_grid_layer(points, cell_size_pixels=30)\n        \"\"\"\n        layer_id = name or f\"screengrid-{len(self._layers)}\"\n        processed_data = self._process_deck_data(data)\n\n        default_color_range = [\n            [255, 255, 178, 25],\n            [254, 217, 118, 85],\n            [254, 178, 76, 127],\n            [253, 141, 60, 170],\n            [240, 59, 32, 212],\n            [189, 0, 38, 255],\n        ]\n\n        self.call_js_method(\n            \"addScreenGridLayer\",\n            id=layer_id,\n            data=processed_data,\n            getPosition=get_position,\n            getWeight=get_weight,\n            cellSizePixels=cell_size_pixels,\n            colorRange=color_range or default_color_range,\n            pickable=pickable,\n            opacity=opacity,\n            **kwargs,\n        )\n\n        self._layers = {\n            **self._layers,\n            layer_id: {\n                \"id\": layer_id,\n                \"type\": \"screengrid\",\n            },\n        }\n        self._add_to_layer_dict(layer_id, \"Deck.gl\")\n\n    # -------------------------------------------------------------------------\n    # Trips Layer (deck.gl)\n    # -------------------------------------------------------------------------\n\n    def add_trips_layer(\n        self,\n        data: Any,\n        name: Optional[str] = None,\n        get_path: Union[str, Any] = \"waypoints\",\n        get_timestamps: Union[str, Any] = \"timestamps\",\n        get_color: Optional[Union[List[int], str]] = None,\n        width_min_pixels: float = 2,\n        trail_length: float = 180,\n        current_time: float = 0,\n        pickable: bool = True,\n        opacity: float = 0.8,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a trips layer for animated trip/trajectory playback using deck.gl.\n\n        Trips layers render animated paths showing movement over time, ideal\n        for visualizing vehicle routes, migration patterns, or time-based data.\n\n        Args:\n            data: Array of trip objects with waypoints and timestamps.\n            name: Layer ID. If None, auto-generated.\n            get_path: Accessor for waypoint coordinates [[lng, lat], ...].\n            get_timestamps: Accessor for timestamps at each waypoint.\n            get_color: Accessor for trip color [r, g, b] or [r, g, b, a].\n                Default: [253, 128, 93].\n            width_min_pixels: Minimum trail width in pixels.\n            trail_length: Trail length in timestamp units.\n            current_time: Current animation time.\n            pickable: Whether layer responds to hover/click events.\n            opacity: Layer opacity (0-1).\n            **kwargs: Additional TripsLayer props.\n\n        Example:\n            &gt;&gt;&gt; from anymap_ts import MapLibreMap\n            &gt;&gt;&gt; m = MapLibreMap()\n            &gt;&gt;&gt; trips = [\n            ...     {\n            ...         \"waypoints\": [[-122.4, 37.8], [-122.5, 37.7]],\n            ...         \"timestamps\": [0, 100]\n            ...     }\n            ... ]\n            &gt;&gt;&gt; m.add_trips_layer(trips, trail_length=200, current_time=50)\n        \"\"\"\n        layer_id = name or f\"trips-{len(self._layers)}\"\n        processed_data = self._process_deck_data(data)\n\n        self.call_js_method(\n            \"addTripsLayer\",\n            id=layer_id,\n            data=processed_data,\n            getPath=get_path,\n            getTimestamps=get_timestamps,\n            getColor=get_color or [253, 128, 93],\n            widthMinPixels=width_min_pixels,\n            trailLength=trail_length,\n            currentTime=current_time,\n            pickable=pickable,\n            opacity=opacity,\n            **kwargs,\n        )\n\n        self._layers = {\n            **self._layers,\n            layer_id: {\n                \"id\": layer_id,\n                \"type\": \"trips\",\n            },\n        }\n        self._add_to_layer_dict(layer_id, \"Deck.gl\")\n\n    # -------------------------------------------------------------------------\n    # Line Layer (deck.gl)\n    # -------------------------------------------------------------------------\n\n    def add_line_layer(\n        self,\n        data: Any,\n        name: Optional[str] = None,\n        get_source_position: Union[str, Any] = \"sourcePosition\",\n        get_target_position: Union[str, Any] = \"targetPosition\",\n        get_color: Optional[Union[List[int], str]] = None,\n        get_width: Union[float, str] = 1,\n        width_min_pixels: float = 1,\n        pickable: bool = True,\n        opacity: float = 0.8,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a line layer for origin-destination line visualization using deck.gl.\n\n        Line layers render straight line segments between source and target\n        positions. Unlike arc layers, lines are drawn without curvature.\n\n        Args:\n            data: Array of line objects with source/target positions.\n            name: Layer ID. If None, auto-generated.\n            get_source_position: Accessor for source position [lng, lat].\n            get_target_position: Accessor for target position [lng, lat].\n            get_color: Accessor for line color [r, g, b] or [r, g, b, a].\n                Default: [51, 136, 255, 200] (blue).\n            get_width: Accessor for line width.\n            width_min_pixels: Minimum line width in pixels.\n            pickable: Whether layer responds to hover/click events.\n            opacity: Layer opacity (0-1).\n            **kwargs: Additional LineLayer props.\n\n        Example:\n            &gt;&gt;&gt; from anymap_ts import MapLibreMap\n            &gt;&gt;&gt; m = MapLibreMap()\n            &gt;&gt;&gt; lines = [\n            ...     {\"sourcePosition\": [-122.4, 37.8], \"targetPosition\": [-73.9, 40.7]},\n            ... ]\n            &gt;&gt;&gt; m.add_line_layer(lines, get_color=[0, 128, 255], get_width=2)\n        \"\"\"\n        layer_id = name or f\"line-{len(self._layers)}\"\n        processed_data = self._process_deck_data(data)\n\n        self.call_js_method(\n            \"addLineLayer\",\n            id=layer_id,\n            data=processed_data,\n            getSourcePosition=get_source_position,\n            getTargetPosition=get_target_position,\n            getColor=get_color or [51, 136, 255, 200],\n            getWidth=get_width,\n            widthMinPixels=width_min_pixels,\n            pickable=pickable,\n            opacity=opacity,\n            **kwargs,\n        )\n\n        self._layers = {\n            **self._layers,\n            layer_id: {\n                \"id\": layer_id,\n                \"type\": \"line\",\n            },\n        }\n        self._add_to_layer_dict(layer_id, \"Deck.gl\")\n\n    # -------------------------------------------------------------------------\n    # Generic Deck.gl Layer\n    # -------------------------------------------------------------------------\n\n    def add_deckgl_layer(\n        self,\n        layer_type: str,\n        data: Any,\n        name: Optional[str] = None,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a generic deck.gl layer to the map.\n\n        This method provides a flexible way to add any supported deck.gl layer\n        type using a single interface. For commonly used layers, prefer the\n        specific methods (e.g., add_scatterplot_layer) for better IDE support.\n\n        Args:\n            layer_type: The deck.gl layer type (e.g., 'ScatterplotLayer',\n                'ArcLayer', 'HexagonLayer').\n            data: Array of data objects or GeoJSON.\n            name: Layer ID. If None, auto-generated from layer_type.\n            **kwargs: Layer-specific properties passed directly to deck.gl.\n\n        Example:\n            &gt;&gt;&gt; from anymap_ts import MapLibreMap\n            &gt;&gt;&gt; m = MapLibreMap()\n            &gt;&gt;&gt; m.add_deckgl_layer(\n            ...     \"TripsLayer\",\n            ...     data=trips_data,\n            ...     getPath=\"waypoints\",\n            ...     getTimestamps=\"timestamps\",\n            ...     trailLength=180,\n            ... )\n        \"\"\"\n        layer_type_clean = layer_type.replace(\"Layer\", \"\")\n        prefix = layer_type_clean.lower()\n        layer_id = name or f\"{prefix}-{len(self._layers)}\"\n        processed_data = self._process_deck_data(data)\n\n        self.call_js_method(\n            \"addDeckGLLayer\",\n            layerType=layer_type,\n            id=layer_id,\n            data=processed_data,\n            **kwargs,\n        )\n\n        self._layers = {\n            **self._layers,\n            layer_id: {\n                \"id\": layer_id,\n                \"type\": layer_type,\n            },\n        }\n        self._add_to_layer_dict(layer_id, \"Deck.gl\")\n\n    def remove_deck_layer(self, layer_id: str) -&gt; None:\n        \"\"\"Remove a deck.gl layer from the map.\n\n        Args:\n            layer_id: Layer identifier to remove.\n        \"\"\"\n        self._remove_layer_internal(layer_id, \"removeDeckLayer\")\n\n    # -------------------------------------------------------------------------\n    # Column Layer (deck.gl)\n    # -------------------------------------------------------------------------\n\n    def add_column_layer(\n        self,\n        data: Any,\n        name: Optional[str] = None,\n        get_position: Union[str, Any] = \"coordinates\",\n        get_fill_color: Optional[Union[List[int], str]] = None,\n        get_line_color: Optional[Union[List[int], str]] = None,\n        get_elevation: Union[float, str] = 1000,\n        radius: float = 1000,\n        disk_resolution: int = 20,\n        elevation_scale: float = 1,\n        coverage: float = 1,\n        extruded: bool = True,\n        filled: bool = True,\n        stroked: bool = False,\n        wireframe: bool = False,\n        pickable: bool = True,\n        opacity: float = 0.8,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a column layer for 3D bar chart visualization using deck.gl.\n\n        Column layers render cylindrical columns at specified positions,\n        ideal for 3D bar charts on a map.\n\n        Args:\n            data: Array of data objects with position coordinates.\n            name: Layer ID. If None, auto-generated.\n            get_position: Accessor for column position [lng, lat].\n            get_fill_color: Accessor for fill color [r, g, b, a].\n            get_line_color: Accessor for stroke color [r, g, b, a].\n            get_elevation: Accessor for column height.\n            radius: Column radius in meters.\n            disk_resolution: Number of sides for column polygon.\n            elevation_scale: Elevation multiplier.\n            coverage: Column coverage (0-1).\n            extruded: Whether to extrude columns.\n            filled: Whether to fill columns.\n            stroked: Whether to stroke columns.\n            wireframe: Whether to render as wireframe.\n            pickable: Whether layer responds to hover/click events.\n            opacity: Layer opacity (0-1).\n            **kwargs: Additional ColumnLayer props.\n\n        Example:\n            &gt;&gt;&gt; from anymap_ts import MapLibreMap\n            &gt;&gt;&gt; m = MapLibreMap(pitch=45)\n            &gt;&gt;&gt; data = [\n            ...     {\"coordinates\": [-122.4, 37.8], \"value\": 500},\n            ...     {\"coordinates\": [-122.5, 37.7], \"value\": 1000},\n            ... ]\n            &gt;&gt;&gt; m.add_column_layer(data, get_elevation=\"value\", radius=500)\n        \"\"\"\n        layer_id = name or f\"column-{len(self._layers)}\"\n        processed_data = self._process_deck_data(data)\n\n        self.call_js_method(\n            \"addColumnLayer\",\n            id=layer_id,\n            data=processed_data,\n            getPosition=get_position,\n            getFillColor=get_fill_color or [255, 140, 0, 200],\n            getLineColor=get_line_color or [0, 0, 0, 255],\n            getElevation=get_elevation,\n            radius=radius,\n            diskResolution=disk_resolution,\n            elevationScale=elevation_scale,\n            coverage=coverage,\n            extruded=extruded,\n            filled=filled,\n            stroked=stroked,\n            wireframe=wireframe,\n            pickable=pickable,\n            opacity=opacity,\n            **kwargs,\n        )\n\n        self._layers = {\n            **self._layers,\n            layer_id: {\"id\": layer_id, \"type\": \"column\"},\n        }\n        self._add_to_layer_dict(layer_id, \"Deck.gl\")\n\n    # -------------------------------------------------------------------------\n    # Bitmap Layer (deck.gl)\n    # -------------------------------------------------------------------------\n\n    def add_bitmap_layer(\n        self,\n        image: str,\n        bounds: List[float],\n        name: Optional[str] = None,\n        opacity: float = 1.0,\n        visible: bool = True,\n        pickable: bool = False,\n        desaturate: float = 0,\n        transparent_color: Optional[List[int]] = None,\n        tint_color: Optional[List[int]] = None,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a bitmap layer for image overlay with GPU rendering using deck.gl.\n\n        Args:\n            image: URL or data URI of the image.\n            bounds: Bounding box [west, south, east, north].\n            name: Layer ID. If None, auto-generated.\n            opacity: Layer opacity (0-1).\n            visible: Whether layer is visible.\n            pickable: Whether layer responds to hover/click events.\n            desaturate: Desaturation amount (0-1).\n            transparent_color: Color to make transparent [r, g, b, a].\n            tint_color: Color to tint the image [r, g, b].\n            **kwargs: Additional BitmapLayer props.\n\n        Example:\n            &gt;&gt;&gt; from anymap_ts import MapLibreMap\n            &gt;&gt;&gt; m = MapLibreMap()\n            &gt;&gt;&gt; m.add_bitmap_layer(\n            ...     \"https://example.com/overlay.png\",\n            ...     bounds=[-122.5, 37.7, -122.3, 37.9],\n            ... )\n        \"\"\"\n        layer_id = name or f\"bitmap-{len(self._layers)}\"\n\n        self.call_js_method(\n            \"addBitmapLayer\",\n            id=layer_id,\n            image=image,\n            bounds=bounds,\n            opacity=opacity,\n            visible=visible,\n            pickable=pickable,\n            desaturate=desaturate,\n            transparentColor=transparent_color or [0, 0, 0, 0],\n            tintColor=tint_color or [255, 255, 255],\n            **kwargs,\n        )\n\n        self._layers = {\n            **self._layers,\n            layer_id: {\"id\": layer_id, \"type\": \"bitmap\"},\n        }\n        self._add_to_layer_dict(layer_id, \"Deck.gl\")\n\n    # -------------------------------------------------------------------------\n    # Solid Polygon Layer (deck.gl)\n    # -------------------------------------------------------------------------\n\n    def add_solid_polygon_layer(\n        self,\n        data: Any,\n        name: Optional[str] = None,\n        get_polygon: Union[str, Any] = \"polygon\",\n        get_fill_color: Optional[Union[List[int], str]] = None,\n        get_line_color: Optional[Union[List[int], str]] = None,\n        get_elevation: Union[float, str] = 0,\n        filled: bool = True,\n        extruded: bool = False,\n        wireframe: bool = False,\n        elevation_scale: float = 1,\n        pickable: bool = True,\n        opacity: float = 0.8,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a solid polygon layer for extruded 3D polygon visualization using deck.gl.\n\n        Args:\n            data: Array of data objects with polygon coordinates.\n            name: Layer ID. If None, auto-generated.\n            get_polygon: Accessor for polygon coordinates.\n            get_fill_color: Accessor for fill color [r, g, b, a].\n            get_line_color: Accessor for stroke color [r, g, b, a].\n            get_elevation: Accessor for 3D extrusion height.\n            filled: Whether to fill polygons.\n            extruded: Whether to render as 3D polygons.\n            wireframe: Whether to render wireframe.\n            elevation_scale: Elevation multiplier.\n            pickable: Whether layer responds to hover/click events.\n            opacity: Layer opacity (0-1).\n            **kwargs: Additional SolidPolygonLayer props.\n\n        Example:\n            &gt;&gt;&gt; from anymap_ts import MapLibreMap\n            &gt;&gt;&gt; m = MapLibreMap(pitch=45)\n            &gt;&gt;&gt; data = [\n            ...     {\"polygon\": [[-122.4, 37.8], [-122.5, 37.7], [-122.3, 37.7]], \"height\": 500},\n            ... ]\n            &gt;&gt;&gt; m.add_solid_polygon_layer(data, extruded=True, get_elevation=\"height\")\n        \"\"\"\n        layer_id = name or f\"solidpolygon-{len(self._layers)}\"\n        processed_data = self._process_deck_data(data)\n\n        self.call_js_method(\n            \"addSolidPolygonLayer\",\n            id=layer_id,\n            data=processed_data,\n            getPolygon=get_polygon,\n            getFillColor=get_fill_color or [51, 136, 255, 128],\n            getLineColor=get_line_color or [0, 0, 0, 255],\n            getElevation=get_elevation,\n            filled=filled,\n            extruded=extruded,\n            wireframe=wireframe,\n            elevationScale=elevation_scale,\n            pickable=pickable,\n            opacity=opacity,\n            **kwargs,\n        )\n\n        self._layers = {\n            **self._layers,\n            layer_id: {\"id\": layer_id, \"type\": \"solidpolygon\"},\n        }\n        self._add_to_layer_dict(layer_id, \"Deck.gl\")\n\n    # -------------------------------------------------------------------------\n    # Grid Cell Layer (deck.gl)\n    # -------------------------------------------------------------------------\n\n    def add_grid_cell_layer(\n        self,\n        data: Any,\n        name: Optional[str] = None,\n        get_position: Union[str, Any] = \"coordinates\",\n        get_color: Optional[Union[List[int], str]] = None,\n        get_elevation: Union[float, str] = 1000,\n        cell_size: float = 200,\n        coverage: float = 1,\n        elevation_scale: float = 1,\n        extruded: bool = True,\n        pickable: bool = True,\n        opacity: float = 0.8,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a grid cell layer for pre-aggregated grid visualization using deck.gl.\n\n        Args:\n            data: Array of data objects with position coordinates.\n            name: Layer ID. If None, auto-generated.\n            get_position: Accessor for cell position [lng, lat].\n            get_color: Accessor for cell color [r, g, b, a].\n            get_elevation: Accessor for cell height.\n            cell_size: Cell size in meters.\n            coverage: Cell coverage (0-1).\n            elevation_scale: Elevation multiplier.\n            extruded: Whether to extrude cells.\n            pickable: Whether layer responds to hover/click events.\n            opacity: Layer opacity (0-1).\n            **kwargs: Additional GridCellLayer props.\n\n        Example:\n            &gt;&gt;&gt; from anymap_ts import MapLibreMap\n            &gt;&gt;&gt; m = MapLibreMap(pitch=45)\n            &gt;&gt;&gt; data = [\n            ...     {\"coordinates\": [-122.4, 37.8], \"value\": 500},\n            ... ]\n            &gt;&gt;&gt; m.add_grid_cell_layer(data, get_elevation=\"value\")\n        \"\"\"\n        layer_id = name or f\"gridcell-{len(self._layers)}\"\n        processed_data = self._process_deck_data(data)\n\n        self.call_js_method(\n            \"addGridCellLayer\",\n            id=layer_id,\n            data=processed_data,\n            getPosition=get_position,\n            getColor=get_color or [255, 140, 0, 200],\n            getElevation=get_elevation,\n            cellSize=cell_size,\n            coverage=coverage,\n            elevationScale=elevation_scale,\n            extruded=extruded,\n            pickable=pickable,\n            opacity=opacity,\n            **kwargs,\n        )\n\n        self._layers = {\n            **self._layers,\n            layer_id: {\"id\": layer_id, \"type\": \"gridcell\"},\n        }\n        self._add_to_layer_dict(layer_id, \"Deck.gl\")\n\n    # -------------------------------------------------------------------------\n    # LiDAR Layers (maplibre-gl-lidar)\n    # -------------------------------------------------------------------------\n\n    def add_lidar_control(\n        self,\n        position: str = \"top-right\",\n        collapsed: bool = True,\n        title: str = \"LiDAR Viewer\",\n        point_size: float = 2,\n        opacity: float = 1.0,\n        color_scheme: str = \"elevation\",\n        use_percentile: bool = True,\n        point_budget: int = 1000000,\n        pickable: bool = False,\n        auto_zoom: bool = True,\n        copc_loading_mode: Optional[str] = None,\n        streaming_point_budget: int = 5000000,\n        panel_max_height: int = 600,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add an interactive LiDAR control panel.\n\n        The LiDAR control provides a UI panel for loading, visualizing, and\n        styling LiDAR point cloud files (LAS, LAZ, COPC formats).\n\n        Args:\n            position: Control position ('top-left', 'top-right', 'bottom-left', 'bottom-right').\n            collapsed: Whether the panel starts collapsed.\n            title: Title displayed on the panel.\n            point_size: Point size in pixels.\n            opacity: Layer opacity (0-1).\n            color_scheme: Color scheme ('elevation', 'intensity', 'classification', 'rgb').\n            use_percentile: Use 2-98% percentile for color scaling.\n            point_budget: Maximum number of points to display.\n            pickable: Enable hover/click interactions.\n            auto_zoom: Auto-zoom to point cloud after loading.\n            copc_loading_mode: COPC loading mode ('full' or 'dynamic').\n            streaming_point_budget: Point budget for streaming mode.\n            panel_max_height: Maximum height of the panel in pixels.\n            **kwargs: Additional control options.\n\n        Example:\n            &gt;&gt;&gt; from anymap_ts import MapLibreMap\n            &gt;&gt;&gt; m = MapLibreMap(pitch=60)\n            &gt;&gt;&gt; m.add_lidar_control(color_scheme=\"classification\", pickable=True)\n        \"\"\"\n        self.call_js_method(\n            \"addLidarControl\",\n            position=position,\n            collapsed=collapsed,\n            title=title,\n            pointSize=point_size,\n            opacity=opacity,\n            colorScheme=color_scheme,\n            usePercentile=use_percentile,\n            pointBudget=point_budget,\n            pickable=pickable,\n            autoZoom=auto_zoom,\n            copcLoadingMode=copc_loading_mode,\n            streamingPointBudget=streaming_point_budget,\n            panelMaxHeight=panel_max_height,\n            **kwargs,\n        )\n        self._controls = {\n            **self._controls,\n            \"lidar-control\": {\"position\": position, \"collapsed\": collapsed},\n        }\n\n    def add_lidar_layer(\n        self,\n        source: Union[str, Path],\n        name: Optional[str] = None,\n        color_scheme: str = \"elevation\",\n        point_size: float = 2,\n        opacity: float = 1.0,\n        pickable: bool = True,\n        auto_zoom: bool = True,\n        streaming_mode: bool = True,\n        point_budget: int = 1000000,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Load and display a LiDAR file from URL or local path.\n\n        Supports LAS, LAZ, and COPC (Cloud-Optimized Point Cloud) formats.\n        For local files, the file is read and sent as base64 to JavaScript.\n        For URLs, the data is loaded directly via streaming when possible.\n\n        Args:\n            source: URL or local file path to the LiDAR file.\n            name: Layer identifier. If None, auto-generated.\n            color_scheme: Color scheme ('elevation', 'intensity', 'classification', 'rgb').\n            point_size: Point size in pixels.\n            opacity: Layer opacity (0-1).\n            pickable: Enable hover/click interactions.\n            auto_zoom: Auto-zoom to point cloud after loading.\n            streaming_mode: Use streaming mode for large COPC files.\n            point_budget: Maximum number of points to display.\n            **kwargs: Additional layer options.\n\n        Example:\n            &gt;&gt;&gt; from anymap_ts import MapLibreMap\n            &gt;&gt;&gt; m = MapLibreMap(center=[-123.07, 44.05], zoom=14, pitch=60)\n            &gt;&gt;&gt; m.add_lidar_layer(\n            ...     source=\"https://s3.amazonaws.com/hobu-lidar/autzen-classified.copc.laz\",\n            ...     name=\"autzen\",\n            ...     color_scheme=\"classification\",\n            ... )\n        \"\"\"\n        layer_id = name or f\"lidar-{len(self._layers)}\"\n\n        # Check if source is a local file\n        source_path = Path(source) if isinstance(source, (str, Path)) else None\n        is_local = source_path is not None and source_path.exists()\n\n        if is_local:\n            # Read local file and encode as base64\n            import base64\n\n            with open(source_path, \"rb\") as f:\n                file_data = f.read()\n            source_b64 = base64.b64encode(file_data).decode(\"utf-8\")\n\n            self.call_js_method(\n                \"addLidarLayer\",\n                source=source_b64,\n                name=layer_id,\n                isBase64=True,\n                filename=source_path.name,\n                colorScheme=color_scheme,\n                pointSize=point_size,\n                opacity=opacity,\n                pickable=pickable,\n                autoZoom=auto_zoom,\n                streamingMode=streaming_mode,\n                pointBudget=point_budget,\n                **kwargs,\n            )\n        else:\n            # Load from URL\n            self.call_js_method(\n                \"addLidarLayer\",\n                source=str(source),\n                name=layer_id,\n                isBase64=False,\n                colorScheme=color_scheme,\n                pointSize=point_size,\n                opacity=opacity,\n                pickable=pickable,\n                autoZoom=auto_zoom,\n                streamingMode=streaming_mode,\n                pointBudget=point_budget,\n                **kwargs,\n            )\n\n        self._layers = {\n            **self._layers,\n            layer_id: {\n                \"id\": layer_id,\n                \"type\": \"lidar\",\n                \"source\": str(source),\n            },\n        }\n        self._add_to_layer_dict(layer_id, \"LiDAR\")\n\n    def remove_lidar_layer(self, layer_id: Optional[str] = None) -&gt; None:\n        \"\"\"Remove a LiDAR layer.\n\n        Args:\n            layer_id: Layer identifier to remove. If None, removes all LiDAR layers.\n        \"\"\"\n        if layer_id:\n            if layer_id in self._layers:\n                layers = dict(self._layers)\n                del layers[layer_id]\n                self._layers = layers\n            self.call_js_method(\"removeLidarLayer\", id=layer_id)\n        else:\n            # Remove all lidar layers\n            layers = dict(self._layers)\n            self._layers = {k: v for k, v in layers.items() if v.get(\"type\") != \"lidar\"}\n            self.call_js_method(\"removeLidarLayer\")\n\n    def set_lidar_color_scheme(self, color_scheme: str) -&gt; None:\n        \"\"\"Set the LiDAR color scheme.\n\n        Args:\n            color_scheme: Color scheme ('elevation', 'intensity', 'classification', 'rgb').\n        \"\"\"\n        self.call_js_method(\"setLidarColorScheme\", colorScheme=color_scheme)\n\n    def set_lidar_point_size(self, point_size: float) -&gt; None:\n        \"\"\"Set the LiDAR point size.\n\n        Args:\n            point_size: Point size in pixels.\n        \"\"\"\n        self.call_js_method(\"setLidarPointSize\", pointSize=point_size)\n\n    def set_lidar_opacity(self, opacity: float) -&gt; None:\n        \"\"\"Set the LiDAR layer opacity.\n\n        Args:\n            opacity: Opacity value between 0 and 1.\n        \"\"\"\n        self.call_js_method(\"setLidarOpacity\", opacity=opacity)\n\n    # -------------------------------------------------------------------------\n    # maplibre-gl-components UI Controls\n    # -------------------------------------------------------------------------\n\n    def add_pmtiles_control(\n        self,\n        position: str = \"top-right\",\n        collapsed: bool = True,\n        default_url: Optional[str] = None,\n        load_default_url: bool = False,\n        default_opacity: float = 1.0,\n        default_fill_color: str = \"steelblue\",\n        default_line_color: str = \"#333\",\n        default_pickable: bool = True,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a PMTiles layer control for loading PMTiles files via UI.\n\n        This provides an interactive panel for users to enter PMTiles URLs\n        and visualize vector or raster tile data.\n\n        Args:\n            position: Control position ('top-left', 'top-right', 'bottom-left', 'bottom-right').\n            collapsed: Whether the panel starts collapsed.\n            default_url: Default PMTiles URL to pre-fill.\n            load_default_url: Whether to auto-load the default URL.\n            default_opacity: Default layer opacity (0-1).\n            default_fill_color: Default fill color for vector polygons.\n            default_line_color: Default line color for vector lines.\n            default_pickable: Whether features are clickable by default.\n            **kwargs: Additional control options.\n\n        Example:\n            &gt;&gt;&gt; from anymap_ts import MapLibreMap\n            &gt;&gt;&gt; m = MapLibreMap()\n            &gt;&gt;&gt; m.add_pmtiles_control(\n            ...     default_url=\"https://pmtiles.io/protomaps(vector)ODbL_firenze.pmtiles\",\n            ...     load_default_url=True\n            ... )\n        \"\"\"\n        self.call_js_method(\n            \"addPMTilesControl\",\n            position=position,\n            collapsed=collapsed,\n            defaultUrl=default_url or \"\",\n            loadDefaultUrl=load_default_url,\n            defaultOpacity=default_opacity,\n            defaultFillColor=default_fill_color,\n            defaultLineColor=default_line_color,\n            defaultPickable=default_pickable,\n            **kwargs,\n        )\n        self._controls = {\n            **self._controls,\n            \"pmtiles-control\": {\"position\": position, \"collapsed\": collapsed},\n        }\n\n    def add_cog_control(\n        self,\n        position: str = \"top-right\",\n        collapsed: bool = True,\n        default_url: Optional[str] = None,\n        load_default_url: bool = False,\n        default_opacity: float = 1.0,\n        default_colormap: str = \"viridis\",\n        default_bands: str = \"1\",\n        default_rescale_min: float = 0,\n        default_rescale_max: float = 255,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a COG layer control for loading Cloud Optimized GeoTIFFs via UI.\n\n        This provides an interactive panel for users to enter COG URLs\n        and configure visualization parameters like colormap and rescaling.\n\n        Args:\n            position: Control position ('top-left', 'top-right', 'bottom-left', 'bottom-right').\n            collapsed: Whether the panel starts collapsed.\n            default_url: Default COG URL to pre-fill.\n            load_default_url: Whether to auto-load the default URL.\n            default_opacity: Default layer opacity (0-1).\n            default_colormap: Default colormap name.\n            default_bands: Default bands (e.g., '1' or '1,2,3').\n            default_rescale_min: Default minimum value for rescaling.\n            default_rescale_max: Default maximum value for rescaling.\n            **kwargs: Additional control options.\n\n        Example:\n            &gt;&gt;&gt; from anymap_ts import MapLibreMap\n            &gt;&gt;&gt; m = MapLibreMap()\n            &gt;&gt;&gt; m.add_cog_control(\n            ...     default_url=\"https://example.com/cog.tif\",\n            ...     default_colormap=\"terrain\"\n            ... )\n        \"\"\"\n        self.call_js_method(\n            \"addCogControl\",\n            position=position,\n            collapsed=collapsed,\n            defaultUrl=default_url or \"\",\n            loadDefaultUrl=load_default_url,\n            defaultOpacity=default_opacity,\n            defaultColormap=default_colormap,\n            defaultBands=default_bands,\n            defaultRescaleMin=default_rescale_min,\n            defaultRescaleMax=default_rescale_max,\n            **kwargs,\n        )\n        self._controls = {\n            **self._controls,\n            \"cog-control\": {\"position\": position, \"collapsed\": collapsed},\n        }\n\n    def add_zarr_control(\n        self,\n        position: str = \"top-right\",\n        collapsed: bool = True,\n        default_url: Optional[str] = None,\n        load_default_url: bool = False,\n        default_opacity: float = 1.0,\n        default_variable: str = \"\",\n        default_clim: Optional[Tuple[float, float]] = None,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a Zarr layer control for loading Zarr datasets via UI.\n\n        This provides an interactive panel for users to enter Zarr URLs\n        and configure visualization parameters.\n\n        Args:\n            position: Control position ('top-left', 'top-right', 'bottom-left', 'bottom-right').\n            collapsed: Whether the panel starts collapsed.\n            default_url: Default Zarr URL to pre-fill.\n            load_default_url: Whether to auto-load the default URL.\n            default_opacity: Default layer opacity (0-1).\n            default_variable: Default variable name.\n            default_clim: Default color limits (min, max).\n            **kwargs: Additional control options.\n\n        Example:\n            &gt;&gt;&gt; from anymap_ts import MapLibreMap\n            &gt;&gt;&gt; m = MapLibreMap()\n            &gt;&gt;&gt; m.add_zarr_control(\n            ...     default_url=\"https://example.com/data.zarr\",\n            ...     default_variable=\"temperature\"\n            ... )\n        \"\"\"\n        self.call_js_method(\n            \"addZarrControl\",\n            position=position,\n            collapsed=collapsed,\n            defaultUrl=default_url or \"\",\n            loadDefaultUrl=load_default_url,\n            defaultOpacity=default_opacity,\n            defaultVariable=default_variable,\n            defaultClim=list(default_clim) if default_clim else [0, 1],\n            **kwargs,\n        )\n        self._controls = {\n            **self._controls,\n            \"zarr-control\": {\"position\": position, \"collapsed\": collapsed},\n        }\n\n    def add_vector_control(\n        self,\n        position: str = \"top-right\",\n        collapsed: bool = True,\n        default_url: Optional[str] = None,\n        load_default_url: bool = False,\n        default_opacity: float = 1.0,\n        default_fill_color: str = \"#3388ff\",\n        default_stroke_color: str = \"#3388ff\",\n        fit_bounds: bool = True,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a vector layer control for loading vector datasets from URLs.\n\n        This provides an interactive panel for users to enter URLs to\n        GeoJSON, GeoParquet, or FlatGeobuf datasets.\n\n        Args:\n            position: Control position ('top-left', 'top-right', 'bottom-left', 'bottom-right').\n            collapsed: Whether the panel starts collapsed.\n            default_url: Default vector URL to pre-fill.\n            load_default_url: Whether to auto-load the default URL.\n            default_opacity: Default layer opacity (0-1).\n            default_fill_color: Default fill color for polygons.\n            default_stroke_color: Default stroke color for lines/outlines.\n            fit_bounds: Whether to fit map to loaded data bounds.\n            **kwargs: Additional control options.\n\n        Example:\n            &gt;&gt;&gt; from anymap_ts import MapLibreMap\n            &gt;&gt;&gt; m = MapLibreMap()\n            &gt;&gt;&gt; m.add_vector_control(\n            ...     default_url=\"https://example.com/data.geojson\",\n            ...     default_fill_color=\"#ff0000\"\n            ... )\n        \"\"\"\n        self.call_js_method(\n            \"addVectorControl\",\n            position=position,\n            collapsed=collapsed,\n            defaultUrl=default_url or \"\",\n            loadDefaultUrl=load_default_url,\n            defaultOpacity=default_opacity,\n            defaultFillColor=default_fill_color,\n            defaultStrokeColor=default_stroke_color,\n            fitBounds=fit_bounds,\n            **kwargs,\n        )\n        self._controls = {\n            **self._controls,\n            \"vector-control\": {\"position\": position, \"collapsed\": collapsed},\n        }\n\n    def add_control_grid(\n        self,\n        position: str = \"top-right\",\n        default_controls: Optional[List[str]] = None,\n        exclude: Optional[List[str]] = None,\n        rows: Optional[int] = None,\n        columns: Optional[int] = None,\n        collapsed: bool = True,\n        collapsible: bool = True,\n        title: str = \"\",\n        show_row_column_controls: bool = True,\n        gap: int = 2,\n        basemap_style_url: Optional[str] = None,\n        exclude_layers: Optional[List[str]] = None,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a ControlGrid with all default tools or a custom subset.\n\n        The ControlGrid provides a collapsible toolbar with up to 26 built-in\n        controls (search, basemap, terrain, measure, draw, etc.) in a\n        configurable grid layout.\n\n        Args:\n            position: Control position ('top-left', 'top-right', 'bottom-left',\n                'bottom-right').\n            default_controls: Explicit list of control names to include. If None,\n                all 26 default controls are used (minus any in ``exclude``).\n                Valid names: 'globe', 'fullscreen', 'north', 'terrain', 'search',\n                'viewState', 'inspect', 'vectorDataset', 'basemap', 'measure',\n                'geoEditor', 'bookmark', 'print', 'minimap', 'swipe',\n                'streetView', 'addVector', 'cogLayer', 'zarrLayer',\n                'pmtilesLayer', 'stacLayer', 'stacSearch', 'planetaryComputer',\n                'gaussianSplat', 'lidar', 'usgsLidar'.\n            exclude: Controls to remove from the default set. Ignored when\n                ``default_controls`` is provided.\n            rows: Number of grid rows (auto-calculated if None).\n            columns: Number of grid columns (auto-calculated if None).\n            collapsed: Whether the grid starts collapsed. Default True.\n            collapsible: Whether the grid can be collapsed. Default True.\n            title: Optional header title for the grid.\n            show_row_column_controls: Show row/column input fields. Default True.\n            gap: Gap between grid cells in pixels. Default 2.\n            basemap_style_url: Basemap style URL for SwipeControl layer grouping.\n                If None, the current map style is used automatically.\n            exclude_layers: Layer ID patterns to exclude from SwipeControl\n                (e.g., 'measure-*', 'gl-draw-*'). If None, sensible defaults\n                are applied.\n            **kwargs: Additional ControlGrid options.\n\n        Example:\n            &gt;&gt;&gt; from anymap_ts import MapLibreMap\n            &gt;&gt;&gt; m = MapLibreMap()\n            &gt;&gt;&gt; m.add_control_grid()  # All 26 controls\n            &gt;&gt;&gt; # Or with customization:\n            &gt;&gt;&gt; m.add_control_grid(\n            ...     exclude=[\"minimap\", \"streetView\"],\n            ...     collapsed=True,\n            ... )\n        \"\"\"\n        js_kwargs: Dict[str, Any] = {\n            \"position\": position,\n            \"collapsed\": collapsed,\n            \"collapsible\": collapsible,\n            \"showRowColumnControls\": show_row_column_controls,\n            \"gap\": gap,\n            **kwargs,\n        }\n        if default_controls is not None:\n            js_kwargs[\"defaultControls\"] = default_controls\n        if exclude is not None:\n            js_kwargs[\"exclude\"] = exclude\n        if rows is not None:\n            js_kwargs[\"rows\"] = rows\n        if columns is not None:\n            js_kwargs[\"columns\"] = columns\n        if title:\n            js_kwargs[\"title\"] = title\n        if basemap_style_url is not None:\n            js_kwargs[\"basemapStyleUrl\"] = basemap_style_url\n        if exclude_layers is not None:\n            js_kwargs[\"excludeLayers\"] = exclude_layers\n\n        self.call_js_method(\"addControlGrid\", **js_kwargs)\n        # Save full config for HTML export\n        control_config = {\n            \"position\": position,\n            \"collapsed\": collapsed,\n            \"collapsible\": collapsible,\n        }\n        if default_controls is not None:\n            control_config[\"defaultControls\"] = default_controls\n        if exclude is not None:\n            control_config[\"exclude\"] = exclude\n        if rows is not None:\n            control_config[\"rows\"] = rows\n        if columns is not None:\n            control_config[\"columns\"] = columns\n        self._controls = {\n            **self._controls,\n            \"control-grid\": control_config,\n        }\n\n    # -------------------------------------------------------------------------\n    # Colorbar\n    # -------------------------------------------------------------------------\n\n    def add_colorbar(\n        self,\n        colormap: str = \"viridis\",\n        vmin: float = 0,\n        vmax: float = 1,\n        label: str = \"\",\n        units: str = \"\",\n        orientation: str = \"horizontal\",\n        position: str = \"bottom-right\",\n        bar_thickness: Optional[int] = None,\n        bar_length: Optional[int] = None,\n        ticks: Optional[Dict] = None,\n        opacity: Optional[float] = None,\n        colorbar_id: Optional[str] = None,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a continuous gradient colorbar to the map.\n\n        Displays a color gradient legend with customizable colormaps,\n        tick marks, labels, and positioning using maplibre-gl-components.\n\n        Args:\n            colormap: Colormap name (e.g., 'viridis', 'plasma', 'inferno',\n                'magma', 'cividis', 'coolwarm', 'jet', 'terrain', etc.).\n            vmin: Minimum value for the colorbar scale.\n            vmax: Maximum value for the colorbar scale.\n            label: Title/label displayed above or beside the colorbar.\n            units: Unit string displayed after values (e.g., '\u00b0C', 'm').\n            orientation: Orientation of the colorbar ('horizontal' or 'vertical').\n            position: Control position ('top-left', 'top-right',\n                'bottom-left', 'bottom-right').\n            bar_thickness: Width/height of the gradient bar in pixels.\n            bar_length: Length of the colorbar in pixels.\n            ticks: Tick configuration dict (e.g., {'count': 5, 'precision': 2}).\n            opacity: Opacity of the colorbar container (0-1).\n            colorbar_id: Unique identifier. If None, auto-generated.\n            **kwargs: Additional Colorbar options.\n\n        Example:\n            &gt;&gt;&gt; m = Map()\n            &gt;&gt;&gt; m.add_cog_layer(\"https://example.com/dem.tif\")\n            &gt;&gt;&gt; m.add_colorbar(\n            ...     colormap=\"terrain\",\n            ...     vmin=0,\n            ...     vmax=4000,\n            ...     label=\"Elevation\",\n            ...     units=\"m\",\n            ... )\n        \"\"\"\n        self._validate_position(position)\n\n        cbar_id = (\n            colorbar_id\n            or f\"colorbar-{len([k for k in self._controls.keys() if k.startswith('colorbar')])}\"\n        )\n\n        js_kwargs: Dict[str, Any] = {\n            \"colormap\": colormap,\n            \"vmin\": vmin,\n            \"vmax\": vmax,\n            \"label\": label,\n            \"units\": units,\n            \"orientation\": orientation,\n            \"position\": position,\n            \"colorbarId\": cbar_id,\n            **kwargs,\n        }\n        if bar_thickness is not None:\n            js_kwargs[\"barThickness\"] = bar_thickness\n        if bar_length is not None:\n            js_kwargs[\"barLength\"] = bar_length\n        if ticks is not None:\n            js_kwargs[\"ticks\"] = ticks\n        if opacity is not None:\n            js_kwargs[\"opacity\"] = opacity\n\n        self.call_js_method(\"addColorbar\", **js_kwargs)\n\n        self._controls = {\n            **self._controls,\n            cbar_id: {\n                \"type\": \"colorbar\",\n                \"colormap\": colormap,\n                \"vmin\": vmin,\n                \"vmax\": vmax,\n                \"label\": label,\n                \"units\": units,\n                \"orientation\": orientation,\n                \"position\": position,\n            },\n        }\n\n    def remove_colorbar(self, colorbar_id: Optional[str] = None) -&gt; None:\n        \"\"\"Remove a colorbar from the map.\n\n        Args:\n            colorbar_id: Colorbar identifier to remove. If None, removes\n                all colorbars.\n        \"\"\"\n        if colorbar_id is None:\n            cbar_keys = [k for k in self._controls.keys() if k.startswith(\"colorbar\")]\n            for key in cbar_keys:\n                self.call_js_method(\"removeColorbar\", colorbarId=key)\n            self._controls = {\n                k: v for k, v in self._controls.items() if not k.startswith(\"colorbar\")\n            }\n        else:\n            self.call_js_method(\"removeColorbar\", colorbarId=colorbar_id)\n            if colorbar_id in self._controls:\n                controls = dict(self._controls)\n                del controls[colorbar_id]\n                self._controls = controls\n\n    def update_colorbar(self, colorbar_id: Optional[str] = None, **kwargs) -&gt; None:\n        \"\"\"Update an existing colorbar's properties.\n\n        Args:\n            colorbar_id: Colorbar identifier to update. If None, updates\n                the first colorbar found.\n            **kwargs: Properties to update (colormap, vmin, vmax, label,\n                units, orientation, bar_thickness, bar_length, ticks, opacity).\n        \"\"\"\n        if colorbar_id is None:\n            cbar_keys = [k for k in self._controls.keys() if k.startswith(\"colorbar\")]\n            if not cbar_keys:\n                raise ValueError(\"No colorbar found to update\")\n            colorbar_id = cbar_keys[0]\n\n        if colorbar_id not in self._controls:\n            raise ValueError(f\"Colorbar '{colorbar_id}' not found\")\n\n        js_kwargs: Dict[str, Any] = {\"colorbarId\": colorbar_id}\n        key_map = {\n            \"bar_thickness\": \"barThickness\",\n            \"bar_length\": \"barLength\",\n        }\n        for key, value in kwargs.items():\n            js_key = key_map.get(key, key)\n            js_kwargs[js_key] = value\n\n        self.call_js_method(\"updateColorbar\", **js_kwargs)\n\n        for key, value in kwargs.items():\n            if key in self._controls.get(colorbar_id, {}):\n                self._controls[colorbar_id][key] = value\n\n    # -------------------------------------------------------------------------\n    # Search / Geocoder Control\n    # -------------------------------------------------------------------------\n\n    def add_search_control(\n        self,\n        position: str = \"top-left\",\n        placeholder: str = \"Search places...\",\n        collapsed: bool = True,\n        fly_to_zoom: int = 14,\n        show_marker: bool = True,\n        marker_color: str = \"#4264fb\",\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a search/geocoder control using Nominatim.\n\n        Provides place search functionality with autocomplete results.\n        Results are geocoded via OpenStreetMap Nominatim service.\n\n        Args:\n            position: Control position ('top-left', 'top-right',\n                'bottom-left', 'bottom-right').\n            placeholder: Placeholder text for the search input.\n            collapsed: Whether the control starts collapsed (icon only).\n            fly_to_zoom: Zoom level to fly to when selecting a result.\n            show_marker: Whether to add a marker at the selected location.\n            marker_color: Color of the result marker.\n            **kwargs: Additional SearchControl options.\n\n        Example:\n            &gt;&gt;&gt; m = Map()\n            &gt;&gt;&gt; m.add_search_control(position=\"top-left\", fly_to_zoom=12)\n        \"\"\"\n        self._validate_position(position)\n        self.call_js_method(\n            \"addSearchControl\",\n            position=position,\n            placeholder=placeholder,\n            collapsed=collapsed,\n            flyToZoom=fly_to_zoom,\n            showMarker=show_marker,\n            markerColor=marker_color,\n            **kwargs,\n        )\n        self._controls = {\n            **self._controls,\n            \"search-control\": {\n                \"type\": \"search-control\",\n                \"position\": position,\n                \"collapsed\": collapsed,\n            },\n        }\n\n    def remove_search_control(self) -&gt; None:\n        \"\"\"Remove the search/geocoder control from the map.\"\"\"\n        self.call_js_method(\"removeSearchControl\")\n        if \"search-control\" in self._controls:\n            controls = dict(self._controls)\n            del controls[\"search-control\"]\n            self._controls = controls\n\n    # -------------------------------------------------------------------------\n    # Measurement Tools\n    # -------------------------------------------------------------------------\n\n    def add_measure_control(\n        self,\n        position: str = \"top-right\",\n        collapsed: bool = True,\n        default_mode: str = \"distance\",\n        distance_unit: str = \"kilometers\",\n        area_unit: str = \"square-kilometers\",\n        line_color: str = \"#3b82f6\",\n        fill_color: str = \"rgba(59, 130, 246, 0.2)\",\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a measurement control for distances and areas.\n\n        Provides tools for measuring distances (polylines) and areas\n        (polygons) interactively on the map.\n\n        Args:\n            position: Control position ('top-left', 'top-right',\n                'bottom-left', 'bottom-right').\n            collapsed: Whether the control starts collapsed.\n            default_mode: Default measurement mode ('distance' or 'area').\n            distance_unit: Distance unit ('kilometers', 'miles', 'meters',\n                'feet', 'nautical-miles').\n            area_unit: Area unit ('square-kilometers', 'square-miles',\n                'square-meters', 'hectares', 'acres').\n            line_color: Line color for distance measurements.\n            fill_color: Fill color for area measurements.\n            **kwargs: Additional MeasureControl options.\n\n        Example:\n            &gt;&gt;&gt; m = Map()\n            &gt;&gt;&gt; m.add_measure_control(\n            ...     default_mode=\"distance\",\n            ...     distance_unit=\"miles\",\n            ... )\n        \"\"\"\n        self._validate_position(position)\n        self.call_js_method(\n            \"addMeasureControl\",\n            position=position,\n            collapsed=collapsed,\n            defaultMode=default_mode,\n            distanceUnit=distance_unit,\n            areaUnit=area_unit,\n            lineColor=line_color,\n            fillColor=fill_color,\n            **kwargs,\n        )\n        self._controls = {\n            **self._controls,\n            \"measure-control\": {\n                \"type\": \"measure-control\",\n                \"position\": position,\n                \"collapsed\": collapsed,\n            },\n        }\n\n    def remove_measure_control(self) -&gt; None:\n        \"\"\"Remove the measurement control from the map.\"\"\"\n        self.call_js_method(\"removeMeasureControl\")\n        if \"measure-control\" in self._controls:\n            controls = dict(self._controls)\n            del controls[\"measure-control\"]\n            self._controls = controls\n\n    # -------------------------------------------------------------------------\n    # Print / Export Control\n    # -------------------------------------------------------------------------\n\n    def add_print_control(\n        self,\n        position: str = \"top-right\",\n        collapsed: bool = True,\n        format: str = \"png\",\n        filename: str = \"map-export\",\n        include_north_arrow: bool = False,\n        include_scale_bar: bool = False,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a print/export control for saving the map as an image.\n\n        Provides an interactive panel for exporting the current map view\n        as PNG, JPEG, or PDF files.\n\n        Args:\n            position: Control position ('top-left', 'top-right',\n                'bottom-left', 'bottom-right').\n            collapsed: Whether the control starts collapsed.\n            format: Default image format ('png', 'jpeg', 'pdf').\n            filename: Default filename (without extension).\n            include_north_arrow: Whether to include a north arrow by default.\n            include_scale_bar: Whether to include a scale bar by default.\n            **kwargs: Additional PrintControl options.\n\n        Example:\n            &gt;&gt;&gt; m = Map()\n            &gt;&gt;&gt; m.add_print_control(\n            ...     format=\"png\",\n            ...     filename=\"my-map\",\n            ...     include_scale_bar=True,\n            ... )\n        \"\"\"\n        self._validate_position(position)\n        self.call_js_method(\n            \"addPrintControl\",\n            position=position,\n            collapsed=collapsed,\n            format=format,\n            filename=filename,\n            includeNorthArrow=include_north_arrow,\n            includeScaleBar=include_scale_bar,\n            **kwargs,\n        )\n        self._controls = {\n            **self._controls,\n            \"print-control\": {\n                \"type\": \"print-control\",\n                \"position\": position,\n                \"collapsed\": collapsed,\n            },\n        }\n\n    def remove_print_control(self) -&gt; None:\n        \"\"\"Remove the print/export control from the map.\"\"\"\n        self.call_js_method(\"removePrintControl\")\n        if \"print-control\" in self._controls:\n            controls = dict(self._controls)\n            del controls[\"print-control\"]\n            self._controls = controls\n\n    # -------------------------------------------------------------------------\n    # FlatGeobuf Layer\n    # -------------------------------------------------------------------------\n\n    def add_flatgeobuf(\n        self,\n        url: str,\n        name: Optional[str] = None,\n        layer_type: Optional[str] = None,\n        paint: Optional[Dict] = None,\n        fit_bounds: bool = True,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a FlatGeobuf layer from a URL.\n\n        Streams and renders cloud-native FlatGeobuf vector data directly\n        in the browser without downloading the entire file.\n\n        Args:\n            url: URL to the FlatGeobuf file.\n            name: Layer name. If None, auto-generated.\n            layer_type: MapLibre layer type ('circle', 'line', 'fill').\n                If None, inferred from geometry type.\n            paint: MapLibre paint properties. If None, defaults are used.\n            fit_bounds: Whether to fit map to data bounds.\n            **kwargs: Additional layer options.\n\n        Example:\n            &gt;&gt;&gt; m = Map()\n            &gt;&gt;&gt; m.add_flatgeobuf(\n            ...     \"https://flatgeobuf.org/test/data/UScounties.fgb\",\n            ...     name=\"counties\",\n            ...     paint={\"fill-color\": \"#088\", \"fill-opacity\": 0.5},\n            ... )\n        \"\"\"\n        layer_id = name or f\"flatgeobuf-{len(self._layers)}\"\n\n        self.call_js_method(\n            \"addFlatGeobuf\",\n            url=url,\n            name=layer_id,\n            layerType=layer_type,\n            paint=paint,\n            fitBounds=fit_bounds,\n            **kwargs,\n        )\n\n        self._layers = {\n            **self._layers,\n            layer_id: {\n                \"id\": layer_id,\n                \"type\": \"flatgeobuf\",\n                \"url\": url,\n            },\n        }\n        self._add_to_layer_dict(layer_id, \"Vector\")\n\n    def remove_flatgeobuf(self, name: str) -&gt; None:\n        \"\"\"Remove a FlatGeobuf layer from the map.\n\n        Args:\n            name: The layer identifier to remove.\n        \"\"\"\n        if name in self._layers:\n            layers = dict(self._layers)\n            del layers[name]\n            self._layers = layers\n        self._remove_from_layer_dict(name)\n        self.call_js_method(\"removeFlatGeobuf\", name=name)\n\n    def _process_deck_data(self, data: Any) -&gt; Any:\n        \"\"\"Process data for deck.gl layers.\n\n        Handles GeoDataFrame, file paths, GeoJSON, and list of dicts.\n\n        Args:\n            data: Input data in various formats.\n\n        Returns:\n            Processed data suitable for deck.gl layers.\n        \"\"\"\n        # Handle GeoDataFrame\n        if hasattr(data, \"__geo_interface__\"):\n            return data.__geo_interface__\n\n        # Handle file paths\n        if isinstance(data, (str, Path)):\n            path = Path(data)\n            if path.exists():\n                try:\n                    import geopandas as gpd\n\n                    gdf = gpd.read_file(path)\n                    return gdf.__geo_interface__\n                except ImportError:\n                    pass\n\n        # Return as-is for lists, dicts, etc.\n        return data\n\n    # -------------------------------------------------------------------------\n    # Layer Management\n    # -------------------------------------------------------------------------\n\n    def add_layer(\n        self,\n        layer_id: str,\n        layer_type: str,\n        source: Union[str, Dict],\n        paint: Optional[Dict] = None,\n        layout: Optional[Dict] = None,\n        before_id: Optional[str] = None,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a generic layer to the map.\n\n        Args:\n            layer_id: Unique layer identifier\n            layer_type: MapLibre layer type\n            source: Source ID or source configuration dict\n            paint: Paint properties\n            layout: Layout properties\n            before_id: ID of layer to insert before\n            **kwargs: Additional layer options\n        \"\"\"\n        layer_config = {\n            \"id\": layer_id,\n            \"type\": layer_type,\n            \"paint\": paint or {},\n            \"layout\": layout or {},\n            **kwargs,\n        }\n\n        if isinstance(source, str):\n            layer_config[\"source\"] = source\n        else:\n            source_id = f\"{layer_id}-source\"\n            self._sources = {**self._sources, source_id: source}\n            self.call_js_method(\"addSource\", source_id, **source)\n            layer_config[\"source\"] = source_id\n\n        self._layers = {**self._layers, layer_id: layer_config}\n        self.call_js_method(\"addLayer\", beforeId=before_id, **layer_config)\n        # Determine category based on layer type\n        layer_type = layer_config.get(\"type\", \"\")\n        if layer_type == \"raster\":\n            self._add_to_layer_dict(layer_id, \"Raster\")\n        else:\n            self._add_to_layer_dict(layer_id, \"Vector\")\n\n    def remove_layer(self, layer_id: str) -&gt; None:\n        \"\"\"Remove a layer from the map.\n\n        Args:\n            layer_id: Layer identifier to remove\n        \"\"\"\n        if layer_id in self._layers:\n            layers = dict(self._layers)\n            del layers[layer_id]\n            self._layers = layers\n        self._remove_from_layer_dict(layer_id)\n        self.call_js_method(\"removeLayer\", layer_id)\n\n    def set_visibility(self, layer_id: str, visible: bool) -&gt; None:\n        \"\"\"Set layer visibility.\n\n        Args:\n            layer_id: Layer identifier\n            visible: Whether layer should be visible\n        \"\"\"\n        self.call_js_method(\"setVisibility\", layer_id, visible)\n\n    def set_opacity(self, layer_id: str, opacity: float) -&gt; None:\n        \"\"\"Set layer opacity.\n\n        Args:\n            layer_id: Layer identifier\n            opacity: Opacity value between 0 and 1\n        \"\"\"\n        self._validate_opacity(opacity)\n        self.call_js_method(\"setOpacity\", layer_id, opacity)\n\n    def set_paint_property(self, layer_id: str, property_name: str, value: Any) -&gt; None:\n        \"\"\"Set a paint property for a layer.\n\n        Args:\n            layer_id: Layer identifier.\n            property_name: Name of the paint property (e.g., 'fill-color').\n            value: New value for the property.\n\n        Example:\n            &gt;&gt;&gt; m.set_paint_property(\"my-layer\", \"fill-color\", \"#ff0000\")\n            &gt;&gt;&gt; m.set_paint_property(\"my-layer\", \"fill-opacity\", 0.5)\n        \"\"\"\n        self.call_js_method(\"setPaintProperty\", layer_id, property_name, value)\n\n    def set_layout_property(\n        self, layer_id: str, property_name: str, value: Any\n    ) -&gt; None:\n        \"\"\"Set a layout property for a layer.\n\n        Args:\n            layer_id: Layer identifier.\n            property_name: Name of the layout property (e.g., 'visibility').\n            value: New value for the property.\n\n        Example:\n            &gt;&gt;&gt; m.set_layout_property(\"my-layer\", \"visibility\", \"none\")\n        \"\"\"\n        self.call_js_method(\"setLayoutProperty\", layer_id, property_name, value)\n\n    def move_layer(self, layer_id: str, before_id: Optional[str] = None) -&gt; None:\n        \"\"\"Move a layer in the layer stack.\n\n        Args:\n            layer_id: Layer identifier to move.\n            before_id: ID of layer to move before. If None, moves to top.\n\n        Example:\n            &gt;&gt;&gt; m.move_layer(\"my-layer\", \"other-layer\")  # Move before other-layer\n            &gt;&gt;&gt; m.move_layer(\"my-layer\")  # Move to top\n        \"\"\"\n        self.call_js_method(\"moveLayer\", layer_id, before_id)\n\n    def get_layer(self, layer_id: str) -&gt; Optional[Dict]:\n        \"\"\"Get layer configuration by ID.\n\n        Args:\n            layer_id: Layer identifier.\n\n        Returns:\n            Layer configuration dict or None if not found.\n        \"\"\"\n        return self._layers.get(layer_id)\n\n    def get_layer_ids(self) -&gt; List[str]:\n        \"\"\"Get list of all layer IDs.\n\n        Returns:\n            List of layer identifiers.\n        \"\"\"\n        return list(self._layers.keys())\n\n    def add_popup(\n        self,\n        layer_id: str,\n        properties: Optional[List[str]] = None,\n        template: Optional[str] = None,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add popup on click for a layer.\n\n        Configures a layer to show a popup when features are clicked.\n\n        Args:\n            layer_id: Layer identifier to add popup to.\n            properties: List of property names to display. If None, shows all.\n            template: Custom HTML template for popup content. Use {property_name}\n                placeholders for values. If None, auto-generates table.\n            **kwargs: Additional popup options (maxWidth, closeButton, etc.).\n\n        Example:\n            &gt;&gt;&gt; m.add_vector(geojson, name=\"cities\")\n            &gt;&gt;&gt; m.add_popup(\"cities\", properties=[\"name\", \"population\"])\n            &gt;&gt;&gt; # Or with custom template:\n            &gt;&gt;&gt; m.add_popup(\"cities\", template=\"&lt;h3&gt;{name}&lt;/h3&gt;&lt;p&gt;Pop: {population}&lt;/p&gt;\")\n        \"\"\"\n        self.call_js_method(\n            \"addPopup\",\n            layerId=layer_id,\n            properties=properties,\n            template=template,\n            **kwargs,\n        )\n\n    # -------------------------------------------------------------------------\n    # Terrain and Image Overlay Methods\n    # -------------------------------------------------------------------------\n\n    def add_3d_terrain(\n        self,\n        source: str = \"terrarium\",\n        exaggeration: float = 1.0,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Enable 3D terrain visualization.\n\n        MapLibre GL JS supports 3D terrain rendering using elevation data\n        from various terrain tile sources.\n\n        Args:\n            source: Terrain source - 'terrarium' (AWS terrain tiles) or\n                'mapbox' (requires Mapbox token) or custom terrain URL.\n            exaggeration: Vertical exaggeration factor. Default 1.0.\n            **kwargs: Additional terrain options.\n\n        Example:\n            &gt;&gt;&gt; from anymap_ts import Map\n            &gt;&gt;&gt; m = Map(center=[-122.4, 37.8], zoom=12, pitch=60)\n            &gt;&gt;&gt; m.add_3d_terrain(exaggeration=1.5)\n        \"\"\"\n        # Define terrain sources\n        terrain_sources = {\n            \"terrarium\": {\n                \"url\": \"https://s3.amazonaws.com/elevation-tiles-prod/terrarium/{z}/{x}/{y}.png\",\n                \"encoding\": \"terrarium\",\n            },\n            \"mapbox\": {\n                \"url\": \"mapbox://mapbox.mapbox-terrain-dem-v1\",\n                \"encoding\": \"mapbox\",\n            },\n        }\n\n        if source in terrain_sources:\n            terrain_config = terrain_sources[source]\n        else:\n            # Assume it's a custom URL\n            terrain_config = {\"url\": source, \"encoding\": \"terrarium\"}\n\n        self.call_js_method(\n            \"addTerrain\",\n            source=terrain_config,\n            exaggeration=exaggeration,\n            **kwargs,\n        )\n\n    def add_image_layer(\n        self,\n        url: str,\n        coordinates: List[List[float]],\n        name: Optional[str] = None,\n        opacity: float = 1.0,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a georeferenced image overlay.\n\n        Overlays an image on the map at specified geographic coordinates.\n\n        Args:\n            url: URL to the image file.\n            coordinates: Four corner coordinates as [[lng, lat], ...] in order:\n                top-left, top-right, bottom-right, bottom-left.\n            name: Layer identifier. If None, auto-generated.\n            opacity: Layer opacity (0-1).\n            **kwargs: Additional layer options.\n\n        Example:\n            &gt;&gt;&gt; from anymap_ts import Map\n            &gt;&gt;&gt; m = Map()\n            &gt;&gt;&gt; m.add_image_layer(\n            ...     url=\"https://example.com/overlay.png\",\n            ...     coordinates=[\n            ...         [-80.425, 46.437],  # top-left\n            ...         [-71.516, 46.437],  # top-right\n            ...         [-71.516, 37.936],  # bottom-right\n            ...         [-80.425, 37.936],  # bottom-left\n            ...     ]\n            ... )\n        \"\"\"\n        self._validate_opacity(opacity)\n        layer_id = name or f\"image-{len(self._layers)}\"\n\n        if len(coordinates) != 4:\n            raise ValueError(\n                \"coordinates must have exactly 4 corner points \"\n                \"[top-left, top-right, bottom-right, bottom-left]\"\n            )\n\n        self.call_js_method(\n            \"addImageLayer\",\n            id=layer_id,\n            url=url,\n            coordinates=coordinates,\n            opacity=opacity,\n            **kwargs,\n        )\n\n        self._layers = {\n            **self._layers,\n            layer_id: {\n                \"id\": layer_id,\n                \"type\": \"image\",\n                \"url\": url,\n                \"coordinates\": coordinates,\n            },\n        }\n        self._add_to_layer_dict(layer_id, \"Raster\")\n\n    # -------------------------------------------------------------------------\n    # Controls\n    # -------------------------------------------------------------------------\n\n    def add_control(\n        self,\n        control_type: str,\n        position: str = \"top-right\",\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a map control.\n\n        Args:\n            control_type: Type of control ('navigation', 'scale', 'fullscreen', etc.)\n            position: Control position\n            **kwargs: Control-specific options\n        \"\"\"\n        self.call_js_method(\"addControl\", control_type, position=position, **kwargs)\n        self._controls = {\n            **self._controls,\n            control_type: {\"type\": control_type, \"position\": position, **kwargs},\n        }\n\n    def remove_control(self, control_type: str) -&gt; None:\n        \"\"\"Remove a map control.\n\n        Args:\n            control_type: Type of control to remove\n        \"\"\"\n        self.call_js_method(\"removeControl\", control_type)\n        if control_type in self._controls:\n            controls = dict(self._controls)\n            del controls[control_type]\n            self._controls = controls\n\n    def add_layer_control(\n        self,\n        layers: Optional[List[str]] = None,\n        position: str = \"top-right\",\n        collapsed: bool = True,\n    ) -&gt; None:\n        \"\"\"Add a layer visibility control.\n\n        Uses maplibre-gl-layer-control for layer toggling and opacity.\n\n        Args:\n            layers: List of layer IDs to include (None = all layers)\n            position: Control position\n            collapsed: Whether control starts collapsed\n        \"\"\"\n        if layers is None:\n            layers = list(self._layers.keys())\n\n        self.call_js_method(\n            \"addLayerControl\",\n            layers=layers,\n            position=position,\n            collapsed=collapsed,\n        )\n        self._controls = {\n            **self._controls,\n            \"layer-control\": {\n                \"layers\": layers,\n                \"position\": position,\n                \"collapsed\": collapsed,\n            },\n        }\n\n    def add_legend(\n        self,\n        title: str,\n        labels: List[str],\n        colors: List[str],\n        position: str = \"bottom-right\",\n        opacity: float = 1.0,\n        legend_id: Optional[str] = None,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a floating legend control to the map.\n\n        Creates a custom legend control with colored boxes and labels that\n        floats over the map in the specified position.\n\n        Args:\n            title: Legend title text\n            labels: List of label strings for each legend item\n            colors: List of hex color strings (e.g., ['#ff0000', '#00ff00', '#0000ff'])\n            position: Legend position ('top-left', 'top-right', 'bottom-left', 'bottom-right')\n            opacity: Legend background opacity (0-1)\n            legend_id: Custom legend identifier (auto-generated if None)\n            **kwargs: Additional legend styling options\n\n        Example:\n            &gt;&gt;&gt; from anymap_ts import Map\n            &gt;&gt;&gt; m = Map()\n            &gt;&gt;&gt; m.add_legend(\n            ...     title=\"Land Cover\",\n            ...     labels=[\"Forest\", \"Water\", \"Urban\"],\n            ...     colors=[\"#228B22\", \"#0000FF\", \"#808080\"],\n            ...     position=\"top-left\"\n            ... )\n        \"\"\"\n        if len(labels) != len(colors):\n            raise ValueError(\"Number of labels must match number of colors\")\n\n        # Validate position\n        self._validate_position(position)\n\n        # Validate colors (basic hex color check)\n        for i, color in enumerate(colors):\n            if not isinstance(color, str) or not color.startswith(\"#\"):\n                raise ValueError(\n                    f\"Color at index {i} must be a hex color string (e.g., '#ff0000')\"\n                )\n\n        legend_id = (\n            legend_id\n            or f\"legend-{len([k for k in self._controls.keys() if k.startswith('legend')])}\"\n        )\n\n        # Prepare legend data\n        legend_items = []\n        for label, color in zip(labels, colors):\n            legend_items.append(\n                {\n                    \"label\": label,\n                    \"color\": color,\n                }\n            )\n\n        # Call JavaScript method to add legend\n        self.call_js_method(\n            \"addLegend\",\n            id=legend_id,\n            title=title,\n            items=legend_items,\n            position=position,\n            opacity=opacity,\n            **kwargs,\n        )\n\n        # Track legend control\n        self._controls = {\n            **self._controls,\n            legend_id: {\n                \"type\": \"legend\",\n                \"title\": title,\n                \"labels\": labels,\n                \"colors\": colors,\n                \"position\": position,\n                \"opacity\": opacity,\n            },\n        }\n\n    def remove_legend(self, legend_id: Optional[str] = None) -&gt; None:\n        \"\"\"Remove a legend control from the map.\n\n        Args:\n            legend_id: Legend identifier to remove. If None, removes all legends.\n        \"\"\"\n        if legend_id is None:\n            # Remove all legends - create a copy of keys before iterating\n            legend_keys = [k for k in self._controls.keys() if k.startswith(\"legend\")]\n            for key in legend_keys:\n                self.call_js_method(\"removeLegend\", key)\n            # Rebuild controls dict without legend keys\n            self._controls = {\n                k: v for k, v in self._controls.items() if not k.startswith(\"legend\")\n            }\n        else:\n            self.call_js_method(\"removeLegend\", legend_id)\n            if legend_id in self._controls:\n                controls = dict(self._controls)\n                del controls[legend_id]\n                self._controls = controls\n\n    def update_legend(\n        self,\n        legend_id: str,\n        title: Optional[str] = None,\n        labels: Optional[List[str]] = None,\n        colors: Optional[List[str]] = None,\n        opacity: Optional[float] = None,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Update an existing legend's properties.\n\n        Args:\n            legend_id: Legend identifier to update\n            title: New title (if provided)\n            labels: New labels list (if provided)\n            colors: New colors list (if provided)\n            opacity: New opacity (if provided)\n            **kwargs: Additional properties to update\n        \"\"\"\n        if legend_id not in self._controls:\n            raise ValueError(f\"Legend '{legend_id}' not found\")\n\n        update_params = {\"id\": legend_id}\n\n        if title is not None:\n            update_params[\"title\"] = title\n            self._controls[legend_id][\"title\"] = title\n\n        if labels is not None and colors is not None:\n            if len(labels) != len(colors):\n                raise ValueError(\"Number of labels must match number of colors\")\n\n            legend_items = [\n                {\"label\": label, \"color\": color} for label, color in zip(labels, colors)\n            ]\n            update_params[\"items\"] = legend_items\n            self._controls[legend_id][\"labels\"] = labels\n            self._controls[legend_id][\"colors\"] = colors\n\n        elif labels is not None or colors is not None:\n            raise ValueError(\"Both labels and colors must be provided together\")\n\n        if opacity is not None:\n            update_params[\"opacity\"] = opacity\n            self._controls[legend_id][\"opacity\"] = opacity\n\n        update_params.update(kwargs)\n        self.call_js_method(\"updateLegend\", **update_params)\n\n    # -------------------------------------------------------------------------\n    # Drawing\n    # -------------------------------------------------------------------------\n\n    def add_draw_control(\n        self,\n        position: str = \"top-right\",\n        draw_modes: Optional[List[str]] = None,\n        edit_modes: Optional[List[str]] = None,\n        collapsed: bool = False,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a drawing control using maplibre-gl-geo-editor.\n\n        Args:\n            position: Control position\n            draw_modes: Drawing modes to enable (e.g., ['polygon', 'line', 'marker'])\n            edit_modes: Edit modes to enable (e.g., ['select', 'drag', 'delete'])\n            collapsed: Whether control starts collapsed\n            **kwargs: Additional geo-editor options\n        \"\"\"\n        if draw_modes is None:\n            draw_modes = [\"polygon\", \"line\", \"rectangle\", \"circle\", \"marker\"]\n        if edit_modes is None:\n            edit_modes = [\"select\", \"drag\", \"change\", \"rotate\", \"delete\"]\n\n        self.call_js_method(\n            \"addDrawControl\",\n            position=position,\n            drawModes=draw_modes,\n            editModes=edit_modes,\n            collapsed=collapsed,\n            **kwargs,\n        )\n        self._controls = {\n            **self._controls,\n            \"draw-control\": {\n                \"position\": position,\n                \"drawModes\": draw_modes,\n                \"editModes\": edit_modes,\n            },\n        }\n\n    def get_draw_data(self) -&gt; Dict:\n        \"\"\"Get the current drawn features as GeoJSON.\n\n        Returns:\n            GeoJSON FeatureCollection of drawn features\n        \"\"\"\n        self.call_js_method(\"getDrawData\")\n        # Small delay to allow JS to update the trait\n        import time\n\n        time.sleep(0.1)\n        return self._draw_data or {\"type\": \"FeatureCollection\", \"features\": []}\n\n    @property\n    def draw_data(self) -&gt; Dict:\n        \"\"\"Property to access current draw data.\"\"\"\n        return self._draw_data or {\"type\": \"FeatureCollection\", \"features\": []}\n\n    def load_draw_data(self, geojson: Dict) -&gt; None:\n        \"\"\"Load GeoJSON features into the drawing layer.\n\n        Args:\n            geojson: GeoJSON FeatureCollection to load\n        \"\"\"\n        self._draw_data = geojson\n        self.call_js_method(\"loadDrawData\", geojson)\n\n    def clear_draw_data(self) -&gt; None:\n        \"\"\"Clear all drawn features.\"\"\"\n        self._draw_data = {\"type\": \"FeatureCollection\", \"features\": []}\n        self.call_js_method(\"clearDrawData\")\n\n    def save_draw_data(\n        self,\n        filepath: Union[str, Path],\n        driver: Optional[str] = None,\n    ) -&gt; None:\n        \"\"\"Save drawn features to a file.\n\n        Args:\n            filepath: Path to save file\n            driver: Output driver (auto-detected from extension if not provided)\n\n        Raises:\n            ImportError: If geopandas is not installed\n        \"\"\"\n        try:\n            import geopandas as gpd\n        except ImportError:\n            raise ImportError(\n                \"geopandas is required to save draw data. \"\n                \"Install with: pip install anymap-ts[vector]\"\n            )\n\n        data = self.get_draw_data()\n        if not data.get(\"features\"):\n            print(\"No features to save\")\n            return\n\n        gdf = gpd.GeoDataFrame.from_features(data[\"features\"])\n        filepath = Path(filepath)\n\n        # Infer driver from extension\n        if driver is None:\n            ext = filepath.suffix.lower()\n            driver_map = {\n                \".geojson\": \"GeoJSON\",\n                \".json\": \"GeoJSON\",\n                \".shp\": \"ESRI Shapefile\",\n                \".gpkg\": \"GPKG\",\n            }\n            driver = driver_map.get(ext, \"GeoJSON\")\n\n        gdf.to_file(filepath, driver=driver)\n\n    # -------------------------------------------------------------------------\n    # GeoJSON Clustering\n    # -------------------------------------------------------------------------\n\n    def add_cluster_layer(\n        self,\n        data: Any,\n        cluster_radius: int = 50,\n        cluster_max_zoom: int = 14,\n        cluster_colors: Optional[List[str]] = None,\n        cluster_steps: Optional[List[int]] = None,\n        cluster_min_radius: int = 15,\n        cluster_max_radius: int = 30,\n        unclustered_color: str = \"#11b4da\",\n        unclustered_radius: int = 8,\n        show_cluster_count: bool = True,\n        name: Optional[str] = None,\n        zoom_on_click: bool = True,\n        fit_bounds: bool = True,\n        **kwargs,\n    ) -&gt; str:\n        \"\"\"Add a clustered point layer with automatic grouping.\n\n        Creates a point layer that automatically clusters nearby points at\n        lower zoom levels. Clicking on clusters zooms in to expand them.\n\n        Args:\n            data: Point data - GeoJSON, GeoDataFrame, file path, or URL.\n            cluster_radius: Radius of each cluster when grouping points (pixels).\n            cluster_max_zoom: Max zoom level to cluster points (above this, all\n                points are shown individually).\n            cluster_colors: List of colors for cluster circles by size.\n                Default: [\"#51bbd6\", \"#f1f075\", \"#f28cb1\"].\n            cluster_steps: Point count thresholds for color changes.\n                Default: [100, 750]. Must have len(cluster_colors) - 1 values.\n            cluster_min_radius: Minimum cluster circle radius in pixels.\n            cluster_max_radius: Maximum cluster circle radius in pixels.\n            unclustered_color: Color for individual (unclustered) points.\n            unclustered_radius: Radius for individual points in pixels.\n            show_cluster_count: Whether to show point count in clusters.\n            name: Layer identifier. If None, auto-generated.\n            zoom_on_click: Whether clicking clusters zooms in to expand them.\n            fit_bounds: Whether to fit map to data bounds.\n            **kwargs: Additional options.\n\n        Returns:\n            The layer identifier.\n\n        Example:\n            &gt;&gt;&gt; from anymap_ts import Map\n            &gt;&gt;&gt; m = Map()\n            &gt;&gt;&gt; m.add_cluster_layer(\n            ...     \"earthquakes.geojson\",\n            ...     cluster_radius=80,\n            ...     cluster_colors=[\"#00ff00\", \"#ffff00\", \"#ff0000\"],\n            ...     cluster_steps=[50, 500],\n            ... )\n        \"\"\"\n        layer_id = name or f\"cluster-{len(self._layers)}\"\n\n        # Default colors and steps\n        if cluster_colors is None:\n            cluster_colors = [\"#51bbd6\", \"#f1f075\", \"#f28cb1\"]\n        if cluster_steps is None:\n            cluster_steps = [100, 750]\n\n        # Validate steps vs colors\n        if len(cluster_steps) != len(cluster_colors) - 1:\n            raise ValueError(\n                f\"cluster_steps must have {len(cluster_colors) - 1} values \"\n                f\"(one less than cluster_colors), got {len(cluster_steps)}\"\n            )\n\n        # Convert data to GeoJSON\n        geojson = to_geojson(data)\n\n        # Handle URL data - fetch GeoJSON\n        if geojson.get(\"type\") == \"url\":\n            url = geojson[\"url\"]\n            geojson = fetch_geojson(url)\n\n        # Get bounds\n        bounds = get_bounds(geojson) if fit_bounds else None\n\n        self.call_js_method(\n            \"addClusterLayer\",\n            data=geojson,\n            name=layer_id,\n            clusterRadius=cluster_radius,\n            clusterMaxZoom=cluster_max_zoom,\n            clusterColors=cluster_colors,\n            clusterSteps=cluster_steps,\n            clusterMinRadius=cluster_min_radius,\n            clusterMaxRadius=cluster_max_radius,\n            unclusteredColor=unclustered_color,\n            unclusteredRadius=unclustered_radius,\n            showClusterCount=show_cluster_count,\n            zoomOnClick=zoom_on_click,\n            fitBounds=fit_bounds,\n            bounds=bounds,\n            **kwargs,\n        )\n\n        self._layers = {\n            **self._layers,\n            layer_id: {\n                \"id\": layer_id,\n                \"type\": \"cluster\",\n                \"source\": f\"{layer_id}-source\",\n            },\n        }\n        self._add_to_layer_dict(layer_id, \"Vector\")\n        return layer_id\n\n    def remove_cluster_layer(self, layer_id: str) -&gt; None:\n        \"\"\"Remove a cluster layer and all its sublayers.\n\n        Args:\n            layer_id: Layer identifier to remove.\n        \"\"\"\n        self._remove_layer_internal(layer_id, \"removeClusterLayer\")\n\n    # -------------------------------------------------------------------------\n    # Choropleth Maps\n    # -------------------------------------------------------------------------\n\n    def add_choropleth(\n        self,\n        data: Any,\n        column: str,\n        cmap: str = \"viridis\",\n        classification: str = \"quantile\",\n        k: int = 5,\n        breaks: Optional[List[float]] = None,\n        fill_opacity: float = 0.7,\n        line_color: str = \"#000000\",\n        line_width: float = 1,\n        legend: bool = True,\n        legend_title: Optional[str] = None,\n        hover: bool = True,\n        layer_id: Optional[str] = None,\n        fit_bounds: bool = True,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a choropleth (thematic) map layer with automatic classification.\n\n        Choropleth maps use color gradients to visualize data values across\n        geographic areas. This method automatically classifies data and applies\n        appropriate colors.\n\n        Args:\n            data: Polygon data - GeoJSON, GeoDataFrame, file path, or URL.\n            column: Property name to visualize (must be numeric).\n            cmap: Colormap name. Any matplotlib colormap is supported when\n                matplotlib is installed. Common options include:\n                - Sequential: 'viridis', 'plasma', 'inferno', 'magma', 'cividis',\n                  'Blues', 'Greens', 'Reds', 'Oranges', 'Purples', 'Greys'\n                - Diverging: 'RdBu', 'RdYlGn', 'RdYlBu', 'Spectral', 'coolwarm'\n                - Qualitative: 'Set1', 'Set2', 'Set3', 'Paired', 'tab10', 'tab20'\n                See: https://matplotlib.org/stable/gallery/color/colormap_reference.html\n            classification: Classification method:\n                - 'quantile': Equal number of features per class\n                - 'equal_interval': Equal value ranges\n                - 'natural_breaks': Jenks natural breaks (requires jenkspy)\n                - 'manual': Use custom breaks\n            k: Number of classes (ignored if classification='manual').\n            breaks: Custom break values for 'manual' classification.\n                Must have k+1 values defining class boundaries.\n            fill_opacity: Polygon fill opacity (0-1).\n            line_color: Polygon outline color.\n            line_width: Polygon outline width.\n            legend: Whether to add a legend.\n            legend_title: Legend title. Defaults to column name.\n            hover: Whether to enable hover highlight effect.\n            layer_id: Layer identifier. If None, auto-generated.\n            fit_bounds: Whether to fit map to data bounds.\n            **kwargs: Additional layer options.\n\n        Example:\n            &gt;&gt;&gt; from anymap_ts import Map\n            &gt;&gt;&gt; m = Map()\n            &gt;&gt;&gt; m.add_choropleth(\n            ...     \"us_states.geojson\",\n            ...     column=\"population\",\n            ...     cmap=\"YlOrRd\",\n            ...     classification=\"quantile\",\n            ...     k=5,\n            ...     legend_title=\"Population\"\n            ... )\n        \"\"\"\n        from .utils import (\n            get_choropleth_colors,\n            compute_breaks,\n            build_step_expression,\n        )\n\n        layer_name = layer_id or f\"choropleth-{len(self._layers)}\"\n\n        # Convert data to GeoJSON\n        geojson = to_geojson(data)\n\n        # Handle URL data - fetch GeoJSON\n        if geojson.get(\"type\") == \"url\":\n            url = geojson[\"url\"]\n            geojson = fetch_geojson(url)\n\n        # Extract values for classification\n        features = geojson.get(\"features\", [])\n        values = []\n        for feature in features:\n            props = feature.get(\"properties\", {})\n            val = props.get(column)\n            if val is not None:\n                try:\n                    values.append(float(val))\n                except (TypeError, ValueError):\n                    pass\n\n        if not values:\n            raise ValueError(f\"No valid numeric values found for column '{column}'\")\n\n        # Compute breaks\n        computed_breaks = compute_breaks(values, classification, k, breaks)\n\n        # Get colors\n        colors = get_choropleth_colors(cmap, k)\n\n        # Build step expression for MapLibre\n        step_expr = build_step_expression(column, computed_breaks, colors)\n\n        # Get bounds\n        bounds = get_bounds(geojson) if fit_bounds else None\n\n        self.call_js_method(\n            \"addChoropleth\",\n            data=geojson,\n            name=layer_name,\n            column=column,\n            stepExpression=step_expr,\n            fillOpacity=fill_opacity,\n            lineColor=line_color,\n            lineWidth=line_width,\n            hover=hover,\n            fitBounds=fit_bounds,\n            bounds=bounds,\n            **kwargs,\n        )\n\n        self._layers = {\n            **self._layers,\n            layer_name: {\n                \"id\": layer_name,\n                \"type\": \"choropleth\",\n                \"source\": f\"{layer_name}-source\",\n                \"column\": column,\n            },\n        }\n        self._add_to_layer_dict(layer_name, \"Vector\")\n\n        # Add legend\n        if legend:\n            title = legend_title or column\n            # Create labels from breaks\n            labels = []\n            for i in range(len(computed_breaks) - 1):\n                low = computed_breaks[i]\n                high = computed_breaks[i + 1]\n                if i == len(computed_breaks) - 2:\n                    labels.append(f\"{low:.1f} - {high:.1f}\")\n                else:\n                    labels.append(f\"{low:.1f} - {high:.1f}\")\n\n            self.add_legend(\n                title=title,\n                labels=labels,\n                colors=colors,\n                position=\"bottom-right\",\n            )\n\n    # -------------------------------------------------------------------------\n    # 3D Buildings\n    # -------------------------------------------------------------------------\n\n    def add_3d_buildings(\n        self,\n        source: str = \"openmaptiles\",\n        min_zoom: float = 14,\n        fill_extrusion_color: str = \"#aaa\",\n        fill_extrusion_opacity: float = 0.6,\n        height_property: str = \"render_height\",\n        base_property: str = \"render_min_height\",\n        layer_id: Optional[str] = None,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add 3D building extrusions from vector tiles.\n\n        Creates 3D building visualizations using fill-extrusion layers.\n        Works best with vector tile styles that include building data.\n\n        Note:\n            This feature requires a map style with vector tile building data.\n            Recommended styles:\n            - MapTiler styles (requires API key)\n            - OpenFreeMap: \"https://tiles.openfreemap.org/styles/liberty\"\n            - Protomaps styles\n\n            CartoDB raster styles (Positron, DarkMatter) do NOT have building\n            data. For those, the method will attempt to add OpenFreeMap tiles\n            as a source, but results may vary.\n\n        Args:\n            source: Building source identifier. Usually auto-detected from\n                the map style.\n            min_zoom: Minimum zoom level to show buildings (default: 14).\n            fill_extrusion_color: Building color as hex string.\n            fill_extrusion_opacity: Building opacity (0-1).\n            height_property: Property name for building height in the\n                vector tiles (default: 'render_height').\n            base_property: Property name for building base height\n                (default: 'render_min_height').\n            layer_id: Layer identifier. If None, uses '3d-buildings'.\n            **kwargs: Additional layer options.\n\n        Example:\n            &gt;&gt;&gt; from anymap_ts import Map\n            &gt;&gt;&gt; # Use a vector style with building data\n            &gt;&gt;&gt; m = Map(\n            ...     center=[-74.0060, 40.7128],\n            ...     zoom=15,\n            ...     pitch=60,\n            ...     style=\"https://tiles.openfreemap.org/styles/liberty\"\n            ... )\n            &gt;&gt;&gt; m.add_3d_buildings(\n            ...     fill_extrusion_color=\"#4682B4\",\n            ...     fill_extrusion_opacity=0.8\n            ... )\n        \"\"\"\n        layer_name = layer_id or \"3d-buildings\"\n\n        self.call_js_method(\n            \"add3DBuildings\",\n            source=source,\n            minZoom=min_zoom,\n            fillExtrusionColor=fill_extrusion_color,\n            fillExtrusionOpacity=fill_extrusion_opacity,\n            heightProperty=height_property,\n            baseProperty=base_property,\n            layerId=layer_name,\n            **kwargs,\n        )\n\n        self._layers = {\n            **self._layers,\n            layer_name: {\n                \"id\": layer_name,\n                \"type\": \"fill-extrusion\",\n            },\n        }\n        self._add_to_layer_dict(layer_name, \"Vector\")\n\n    # -------------------------------------------------------------------------\n    # Route Animation\n    # -------------------------------------------------------------------------\n\n    def animate_along_route(\n        self,\n        route: Any,\n        duration: int = 10000,\n        loop: bool = True,\n        marker_color: str = \"#3388ff\",\n        marker_size: float = 1.0,\n        show_trail: bool = False,\n        trail_color: str = \"#3388ff\",\n        trail_width: float = 3,\n        animation_id: Optional[str] = None,\n        **kwargs,\n    ) -&gt; str:\n        \"\"\"Animate a marker along a route.\n\n        Creates an animated marker that moves along the specified route line.\n\n        Args:\n            route: Route data - LineString GeoJSON, list of coordinates,\n                GeoDataFrame, or file path.\n            duration: Animation duration in milliseconds.\n            loop: Whether to loop the animation.\n            marker_color: Marker color.\n            marker_size: Marker size multiplier.\n            show_trail: Whether to show a trail behind the marker.\n            trail_color: Trail line color.\n            trail_width: Trail line width.\n            animation_id: Animation identifier. If None, auto-generated.\n            **kwargs: Additional animation options.\n\n        Returns:\n            The animation identifier.\n\n        Example:\n            &gt;&gt;&gt; from anymap_ts import Map\n            &gt;&gt;&gt; m = Map()\n            &gt;&gt;&gt; coords = [[-122.4, 37.8], [-122.3, 37.7], [-122.2, 37.8]]\n            &gt;&gt;&gt; anim_id = m.animate_along_route(coords, duration=5000, loop=True)\n        \"\"\"\n        anim_id = animation_id or f\"animation-{len(self._layers)}\"\n\n        # Convert route to coordinates list\n        if isinstance(route, list) and len(route) &gt; 0:\n            if isinstance(route[0], (list, tuple)):\n                # Already a list of coordinates\n                coordinates = route\n            else:\n                raise ValueError(\"Route list must contain coordinate pairs\")\n        elif isinstance(route, dict):\n            # GeoJSON\n            if route.get(\"type\") == \"LineString\":\n                coordinates = route.get(\"coordinates\", [])\n            elif route.get(\"type\") == \"Feature\":\n                geometry = route.get(\"geometry\", {})\n                if geometry.get(\"type\") == \"LineString\":\n                    coordinates = geometry.get(\"coordinates\", [])\n                else:\n                    raise ValueError(\"Feature geometry must be LineString\")\n            elif route.get(\"type\") == \"FeatureCollection\":\n                features = route.get(\"features\", [])\n                if (\n                    features\n                    and features[0].get(\"geometry\", {}).get(\"type\") == \"LineString\"\n                ):\n                    coordinates = features[0][\"geometry\"][\"coordinates\"]\n                else:\n                    raise ValueError(\n                        \"FeatureCollection must contain LineString features\"\n                    )\n            else:\n                raise ValueError(\n                    \"GeoJSON must be LineString, Feature, or FeatureCollection\"\n                )\n        else:\n            # Try to convert using to_geojson\n            geojson = to_geojson(route)\n            if geojson.get(\"type\") == \"url\":\n                geojson = fetch_geojson(geojson[\"url\"])\n            # Extract coordinates from the converted geojson\n            if geojson.get(\"type\") == \"FeatureCollection\":\n                features = geojson.get(\"features\", [])\n                if features:\n                    coordinates = features[0].get(\"geometry\", {}).get(\"coordinates\", [])\n                else:\n                    raise ValueError(\"No features found in data\")\n            elif geojson.get(\"type\") == \"Feature\":\n                coordinates = geojson.get(\"geometry\", {}).get(\"coordinates\", [])\n            else:\n                coordinates = geojson.get(\"coordinates\", [])\n\n        if len(coordinates) &lt; 2:\n            raise ValueError(\"Route must have at least 2 points\")\n\n        self.call_js_method(\n            \"animateAlongRoute\",\n            id=anim_id,\n            coordinates=coordinates,\n            duration=duration,\n            loop=loop,\n            markerColor=marker_color,\n            markerSize=marker_size,\n            showTrail=show_trail,\n            trailColor=trail_color,\n            trailWidth=trail_width,\n            **kwargs,\n        )\n\n        self._layers = {\n            **self._layers,\n            anim_id: {\n                \"id\": anim_id,\n                \"type\": \"animation\",\n            },\n        }\n        return anim_id\n\n    def stop_animation(self, animation_id: str) -&gt; None:\n        \"\"\"Stop a running animation.\n\n        Args:\n            animation_id: Animation identifier to stop.\n        \"\"\"\n        self.call_js_method(\"stopAnimation\", animation_id)\n        if animation_id in self._layers:\n            layers = dict(self._layers)\n            del layers[animation_id]\n            self._layers = layers\n\n    def pause_animation(self, animation_id: str) -&gt; None:\n        \"\"\"Pause a running animation.\n\n        Args:\n            animation_id: Animation identifier to pause.\n        \"\"\"\n        self.call_js_method(\"pauseAnimation\", animation_id)\n\n    def resume_animation(self, animation_id: str) -&gt; None:\n        \"\"\"Resume a paused animation.\n\n        Args:\n            animation_id: Animation identifier to resume.\n        \"\"\"\n        self.call_js_method(\"resumeAnimation\", animation_id)\n\n    def set_animation_speed(self, animation_id: str, speed: float) -&gt; None:\n        \"\"\"Set animation speed multiplier.\n\n        Args:\n            animation_id: Animation identifier.\n            speed: Speed multiplier (1.0 = normal, 2.0 = double speed, etc.).\n        \"\"\"\n        self.call_js_method(\"setAnimationSpeed\", animation_id, speed)\n\n    # -------------------------------------------------------------------------\n    # Feature Hover Effect\n    # -------------------------------------------------------------------------\n\n    def add_hover_effect(\n        self,\n        layer_id: str,\n        highlight_color: Optional[str] = None,\n        highlight_opacity: Optional[float] = None,\n        highlight_outline_width: float = 2,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add hover highlight effect to an existing layer.\n\n        When the mouse hovers over a feature, it will be highlighted with\n        the specified styles.\n\n        Args:\n            layer_id: Layer identifier to add hover effect to.\n            highlight_color: Override fill/line color on hover. If None,\n                the original color is kept but opacity/outline changes.\n            highlight_opacity: Override opacity on hover.\n            highlight_outline_width: Outline width on hover.\n            **kwargs: Additional hover effect options.\n\n        Example:\n            &gt;&gt;&gt; from anymap_ts import Map\n            &gt;&gt;&gt; m = Map()\n            &gt;&gt;&gt; m.add_geojson(\"states.geojson\", name=\"states\")\n            &gt;&gt;&gt; m.add_hover_effect(\"states\", highlight_opacity=0.9)\n        \"\"\"\n        self.call_js_method(\n            \"addHoverEffect\",\n            layerId=layer_id,\n            highlightColor=highlight_color,\n            highlightOpacity=highlight_opacity,\n            highlightOutlineWidth=highlight_outline_width,\n            **kwargs,\n        )\n\n    # -------------------------------------------------------------------------\n    # Sky &amp; Fog\n    # -------------------------------------------------------------------------\n\n    def set_sky(\n        self,\n        sky_color: str = \"#88C6FC\",\n        horizon_color: str = \"#F0E4D4\",\n        fog_color: str = \"#FFFFFF\",\n        sky_horizon_blend: float = 0.5,\n        horizon_fog_blend: float = 0.5,\n        fog_ground_blend: float = 0.5,\n        atmosphere_blend: float = 0.8,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Set sky and fog atmospheric effects for 3D terrain visualization.\n\n        MapLibre v5 unifies sky and fog into a single `map.setSky()` API.\n        Best used with 3D terrain enabled.\n\n        Args:\n            sky_color: Color of the sky. Default is \"#88C6FC\".\n            horizon_color: Color at the horizon. Default is \"#F0E4D4\".\n            fog_color: Color of the fog. Default is \"#FFFFFF\".\n            sky_horizon_blend: Blend between sky and horizon (0-1).\n                Default is 0.5.\n            horizon_fog_blend: Blend between horizon and fog (0-1).\n                Default is 0.5.\n            fog_ground_blend: Blend between fog and ground (0-1).\n                Default is 0.5.\n            atmosphere_blend: Intensity of the atmosphere effect (0-1).\n                Default is 0.8.\n            **kwargs: Additional sky options.\n\n        Example:\n            &gt;&gt;&gt; from anymap_ts import Map\n            &gt;&gt;&gt; m = Map(center=[-122.4, 37.8], zoom=12, pitch=60)\n            &gt;&gt;&gt; m.add_3d_terrain(exaggeration=1.5)\n            &gt;&gt;&gt; m.set_sky()\n        \"\"\"\n        self.call_js_method(\n            \"setSky\",\n            skyColor=sky_color,\n            horizonColor=horizon_color,\n            fogColor=fog_color,\n            skyHorizonBlend=sky_horizon_blend,\n            horizonFogBlend=horizon_fog_blend,\n            fogGroundBlend=fog_ground_blend,\n            atmosphereBlend=atmosphere_blend,\n            **kwargs,\n        )\n\n    def remove_sky(self) -&gt; None:\n        \"\"\"Remove sky and fog atmospheric effects from the map.\n\n        Example:\n            &gt;&gt;&gt; m.remove_sky()\n        \"\"\"\n        self.call_js_method(\"removeSky\")\n\n    # -------------------------------------------------------------------------\n    # Feature Query/Filter\n    # -------------------------------------------------------------------------\n\n    def set_filter(\n        self,\n        layer_id: str,\n        filter_expression: Optional[List] = None,\n    ) -&gt; None:\n        \"\"\"Set or clear a filter on a map layer.\n\n        Uses MapLibre GL JS filter expressions to show/hide features.\n\n        Args:\n            layer_id: The layer to apply the filter to.\n            filter_expression: A MapLibre filter expression (list).\n                Pass None to clear the filter.\n\n        Example:\n            &gt;&gt;&gt; m.set_filter(\"states-layer\", [\"&gt;=\", [\"get\", \"density\"], 100])\n            &gt;&gt;&gt; m.set_filter(\"states-layer\", None)  # Clear filter\n        \"\"\"\n        self.call_js_method(\n            \"setFilter\",\n            layerId=layer_id,\n            filter=filter_expression,\n        )\n\n    def query_rendered_features(\n        self,\n        geometry: Optional[Any] = None,\n        layers: Optional[List[str]] = None,\n        filter_expression: Optional[List] = None,\n    ) -&gt; Dict:\n        \"\"\"Query features currently rendered on the map.\n\n        Results are stored in the `queried_features` property.\n\n        Args:\n            geometry: Optional point {x, y} or bounding box [[x1, y1], [x2, y2]]\n                to limit the query area. If None, queries the entire viewport.\n            layers: Optional list of layer IDs to query. If None, queries all\n                layers.\n            filter_expression: Optional MapLibre filter expression to further\n                filter results.\n\n        Returns:\n            The current queried features dict (may not yet reflect this query\n            if called immediately; use the `queried_features` property).\n\n        Example:\n            &gt;&gt;&gt; m.query_rendered_features(layers=[\"states-layer\"])\n            &gt;&gt;&gt; features = m.queried_features\n        \"\"\"\n        kwargs: Dict[str, Any] = {}\n        if geometry is not None:\n            kwargs[\"geometry\"] = geometry\n        if layers is not None:\n            kwargs[\"layers\"] = layers\n        if filter_expression is not None:\n            kwargs[\"filter\"] = filter_expression\n\n        self.call_js_method(\"queryRenderedFeatures\", **kwargs)\n        return self._queried_features\n\n    def query_source_features(\n        self,\n        source_id: str,\n        source_layer: Optional[str] = None,\n        filter_expression: Optional[List] = None,\n    ) -&gt; Dict:\n        \"\"\"Query features from a source, including features not currently visible.\n\n        Results are stored in the `queried_features` property.\n\n        Args:\n            source_id: The source to query.\n            source_layer: Optional source layer for vector tile sources.\n            filter_expression: Optional MapLibre filter expression.\n\n        Returns:\n            The current queried features dict.\n\n        Example:\n            &gt;&gt;&gt; m.query_source_features(\"states-source\")\n            &gt;&gt;&gt; features = m.queried_features\n        \"\"\"\n        kwargs: Dict[str, Any] = {\"sourceId\": source_id}\n        if source_layer is not None:\n            kwargs[\"sourceLayer\"] = source_layer\n        if filter_expression is not None:\n            kwargs[\"filter\"] = filter_expression\n\n        self.call_js_method(\"querySourceFeatures\", **kwargs)\n        return self._queried_features\n\n    @property\n    def queried_features(self) -&gt; Dict:\n        \"\"\"Get the most recent query results.\n\n        Returns:\n            A GeoJSON FeatureCollection dict with queried features.\n        \"\"\"\n        return self._queried_features\n\n    # -------------------------------------------------------------------------\n    # Video Layer\n    # -------------------------------------------------------------------------\n\n    def add_video_layer(\n        self,\n        urls: List[str],\n        coordinates: List[List[float]],\n        name: Optional[str] = None,\n        opacity: float = 1.0,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a georeferenced video overlay on the map.\n\n        Args:\n            urls: List of video URLs (provide multiple formats for browser\n                compatibility, e.g., [\".mp4\", \".webm\"]).\n            coordinates: Four corner coordinates as [[lng, lat], ...] in order:\n                top-left, top-right, bottom-right, bottom-left.\n            name: Layer identifier. If None, auto-generated.\n            opacity: Layer opacity (0-1). Default is 1.0.\n            **kwargs: Additional layer options.\n\n        Example:\n            &gt;&gt;&gt; m.add_video_layer(\n            ...     urls=[\"https://example.com/video.mp4\"],\n            ...     coordinates=[\n            ...         [-122.51596391658498, 37.56238816766053],\n            ...         [-122.51467645489949, 37.56410183312965],\n            ...         [-122.51309394645498, 37.563391708549425],\n            ...         [-122.51423120498498, 37.56161849366671],\n            ...     ],\n            ... )\n        \"\"\"\n        self._validate_opacity(opacity)\n        layer_id = name or f\"video-{len(self._layers)}\"\n\n        if len(coordinates) != 4:\n            raise ValueError(\n                \"coordinates must have exactly 4 corner points \"\n                \"[top-left, top-right, bottom-right, bottom-left]\"\n            )\n\n        self.call_js_method(\n            \"addVideoLayer\",\n            id=layer_id,\n            urls=urls,\n            coordinates=coordinates,\n            opacity=opacity,\n            **kwargs,\n        )\n\n        self._layers = {\n            **self._layers,\n            layer_id: {\n                \"id\": layer_id,\n                \"type\": \"video\",\n                \"source\": f\"{layer_id}-source\",\n            },\n        }\n        self._add_to_layer_dict(layer_id, \"Raster\")\n\n    def remove_video_layer(self, name: str) -&gt; None:\n        \"\"\"Remove a video layer from the map.\n\n        Args:\n            name: The layer identifier to remove.\n        \"\"\"\n        if name in self._layers:\n            layers = dict(self._layers)\n            del layers[name]\n            self._layers = layers\n        self._remove_from_layer_dict(name)\n        self.call_js_method(\"removeVideoLayer\", id=name)\n\n    def play_video(self, name: str) -&gt; None:\n        \"\"\"Start playing a video layer.\n\n        Args:\n            name: The video layer identifier.\n        \"\"\"\n        self.call_js_method(\"playVideo\", id=name)\n\n    def pause_video(self, name: str) -&gt; None:\n        \"\"\"Pause a video layer.\n\n        Args:\n            name: The video layer identifier.\n        \"\"\"\n        self.call_js_method(\"pauseVideo\", id=name)\n\n    def seek_video(self, name: str, time: float) -&gt; None:\n        \"\"\"Seek to a specific time in a video layer.\n\n        Args:\n            name: The video layer identifier.\n            time: Time in seconds to seek to.\n        \"\"\"\n        self.call_js_method(\"seekVideo\", id=name, time=time)\n\n    # -------------------------------------------------------------------------\n    # Split Map (Swipe/Compare)\n    # -------------------------------------------------------------------------\n\n    def add_split_map(\n        self,\n        left_layer: str,\n        right_layer: str,\n        position: int = 50,\n    ) -&gt; None:\n        \"\"\"Add a split map comparison view with a draggable divider.\n\n        Creates a side-by-side comparison of two layers. The left side shows\n        the left layer and the right side shows the right layer, with a\n        draggable slider to adjust the split position.\n\n        Args:\n            left_layer: Layer ID for the left side.\n            right_layer: Layer ID for the right side.\n            position: Initial slider position as percentage (0-100).\n                Default is 50 (middle).\n\n        Note:\n            Both layers must exist on the map before calling this method.\n            Best suited for raster tile layers (e.g., satellite vs streets).\n\n        Example:\n            &gt;&gt;&gt; m.add_tile_layer(\n            ...     \"https://mt1.google.com/vt/lyrs=s&amp;x={x}&amp;y={y}&amp;z={z}\",\n            ...     name=\"satellite\",\n            ... )\n            &gt;&gt;&gt; m.add_tile_layer(\n            ...     \"https://tile.openstreetmap.org/{z}/{x}/{y}.png\",\n            ...     name=\"osm\",\n            ... )\n            &gt;&gt;&gt; m.add_split_map(\"satellite\", \"osm\")\n        \"\"\"\n        if not 0 &lt;= position &lt;= 100:\n            raise ValueError(f\"position must be between 0 and 100, got {position}\")\n\n        self.call_js_method(\n            \"addSplitMap\",\n            leftLayer=left_layer,\n            rightLayer=right_layer,\n            position=position,\n        )\n\n    def remove_split_map(self) -&gt; None:\n        \"\"\"Remove the split map comparison view.\n\n        Restores the map to normal single-view mode with all layers visible.\n        \"\"\"\n        self.call_js_method(\"removeSplitMap\")\n\n    # -------------------------------------------------------------------------\n    # Globe Projection (Section 3)\n    # -------------------------------------------------------------------------\n\n    def set_projection(self, projection: str = \"mercator\") -&gt; None:\n        \"\"\"Set the map projection.\n\n        MapLibre GL JS v4+ supports globe projection for a 3D globe view.\n\n        Args:\n            projection: Projection type. Supported values: 'mercator', 'globe'.\n\n        Example:\n            &gt;&gt;&gt; m = MapLibreMap()\n            &gt;&gt;&gt; m.set_projection(\"globe\")\n        \"\"\"\n        self.call_js_method(\"setProjection\", projection=projection)\n\n    # -------------------------------------------------------------------------\n    # Source Data Updates (Section 3)\n    # -------------------------------------------------------------------------\n\n    def update_geojson_source(self, source_id: str, data: Any) -&gt; None:\n        \"\"\"Update the data of an existing GeoJSON source in place.\n\n        This enables real-time/streaming data updates without removing\n        and re-adding layers. Critical for live dashboards.\n\n        Args:\n            source_id: The ID of the GeoJSON source to update.\n            data: New GeoJSON data (dict, GeoDataFrame, or URL string).\n\n        Example:\n            &gt;&gt;&gt; m = MapLibreMap()\n            &gt;&gt;&gt; m.add_geojson(\"initial.geojson\", name=\"points\")\n            &gt;&gt;&gt; # Later, update with new data\n            &gt;&gt;&gt; m.update_geojson_source(\"points\", new_geojson_data)\n        \"\"\"\n        processed_data = self._process_deck_data(data)\n        self.call_js_method(\n            \"updateGeoJSONSource\",\n            sourceId=source_id,\n            data=processed_data,\n        )\n\n    # -------------------------------------------------------------------------\n    # Custom Images &amp; Sprites (Section 3)\n    # -------------------------------------------------------------------------\n\n    def add_image(self, name: str, url: str) -&gt; None:\n        \"\"\"Load a custom icon image for use in symbol layers.\n\n        Args:\n            name: Name to reference this image in symbol layers.\n            url: URL to the image file (PNG, JPEG, etc.).\n\n        Example:\n            &gt;&gt;&gt; m = MapLibreMap()\n            &gt;&gt;&gt; m.add_image(\"custom-marker\", \"https://example.com/marker.png\")\n        \"\"\"\n        self.call_js_method(\"addMapImage\", name=name, url=url)\n\n    # -------------------------------------------------------------------------\n    # Tooltip on Hover (Section 3 / Section 6)\n    # -------------------------------------------------------------------------\n\n    def add_tooltip(\n        self,\n        layer_id: str,\n        template: Optional[str] = None,\n        properties: Optional[List[str]] = None,\n    ) -&gt; None:\n        \"\"\"Add a tooltip that shows on feature hover.\n\n        Shows formatted information when hovering over features in a layer.\n\n        Args:\n            layer_id: The ID of the layer to add tooltips to.\n            template: HTML template with {property} placeholders.\n                Example: \"Name: {name}&lt;br&gt;Population: {pop}\".\n            properties: List of property names to display. If None and no\n                template, all properties are shown.\n\n        Example:\n            &gt;&gt;&gt; m = MapLibreMap()\n            &gt;&gt;&gt; m.add_geojson(\"data.geojson\", name=\"cities\")\n            &gt;&gt;&gt; m.add_tooltip(\"cities\", template=\"&lt;b&gt;{name}&lt;/b&gt;&lt;br&gt;Pop: {population}\")\n        \"\"\"\n        self.call_js_method(\n            \"addTooltip\",\n            layerId=layer_id,\n            template=template or \"\",\n            properties=properties,\n        )\n\n    def remove_tooltip(self, layer_id: str) -&gt; None:\n        \"\"\"Remove tooltip from a layer.\n\n        Args:\n            layer_id: The layer identifier.\n        \"\"\"\n        self.call_js_method(\"removeTooltip\", layerId=layer_id)\n\n    # -------------------------------------------------------------------------\n    # Coordinates Display Control (Section 3)\n    # -------------------------------------------------------------------------\n\n    def add_coordinates_control(\n        self,\n        position: str = \"bottom-left\",\n        precision: int = 4,\n    ) -&gt; None:\n        \"\"\"Add a coordinates display showing cursor lat/lng.\n\n        Args:\n            position: Control position ('top-left', 'top-right',\n                'bottom-left', 'bottom-right').\n            precision: Number of decimal places for coordinates.\n\n        Example:\n            &gt;&gt;&gt; m = MapLibreMap()\n            &gt;&gt;&gt; m.add_coordinates_control(position=\"bottom-left\", precision=6)\n        \"\"\"\n        self.call_js_method(\n            \"addCoordinatesControl\",\n            position=position,\n            precision=precision,\n        )\n\n    def remove_coordinates_control(self) -&gt; None:\n        \"\"\"Remove the coordinates display control.\"\"\"\n        self.call_js_method(\"removeCoordinatesControl\")\n\n    # -------------------------------------------------------------------------\n    # Time Slider (Section 4)\n    # -------------------------------------------------------------------------\n\n    def add_time_slider(\n        self,\n        layer_id: str,\n        property: str,\n        min_value: float = 0,\n        max_value: float = 100,\n        step: float = 1,\n        position: str = \"bottom-left\",\n        label: str = \"Time\",\n        auto_play: bool = False,\n        interval: int = 500,\n    ) -&gt; None:\n        \"\"\"Add a time slider to filter data by a temporal property.\n\n        Creates a slider control that filters layer features based on a\n        numeric/temporal property, with optional auto-animation.\n\n        Args:\n            layer_id: Layer ID to filter.\n            property: Property name to filter on.\n            min_value: Minimum slider value.\n            max_value: Maximum slider value.\n            step: Step increment.\n            position: Control position.\n            label: Label text for the slider.\n            auto_play: Whether to auto-animate through values.\n            interval: Animation interval in milliseconds.\n\n        Example:\n            &gt;&gt;&gt; m = MapLibreMap()\n            &gt;&gt;&gt; m.add_geojson(\"events.geojson\", name=\"events\")\n            &gt;&gt;&gt; m.add_time_slider(\"events\", \"year\", min_value=2000, max_value=2024)\n        \"\"\"\n        self.call_js_method(\n            \"addTimeSlider\",\n            layerId=layer_id,\n            property=property,\n            min=min_value,\n            max=max_value,\n            step=step,\n            position=position,\n            label=label,\n            autoPlay=auto_play,\n            interval=interval,\n        )\n\n    def remove_time_slider(self) -&gt; None:\n        \"\"\"Remove the time slider control.\"\"\"\n        self.call_js_method(\"removeTimeSlider\")\n\n    # -------------------------------------------------------------------------\n    # Swipe Map Comparison (Section 6)\n    # -------------------------------------------------------------------------\n\n    def add_swipe_map(self, left_layer: str, right_layer: str) -&gt; None:\n        \"\"\"Add a drag-to-compare swipe control for two layers.\n\n        Unlike split map which is side-by-side, swipe map overlays both\n        layers and uses a draggable divider for before/after comparison.\n\n        Args:\n            left_layer: Layer ID for the left side.\n            right_layer: Layer ID for the right side.\n\n        Example:\n            &gt;&gt;&gt; m = MapLibreMap()\n            &gt;&gt;&gt; m.add_tile_layer(\"...\", name=\"before\")\n            &gt;&gt;&gt; m.add_tile_layer(\"...\", name=\"after\")\n            &gt;&gt;&gt; m.add_swipe_map(\"before\", \"after\")\n        \"\"\"\n        self.call_js_method(\n            \"addSwipeMap\",\n            leftLayer=left_layer,\n            rightLayer=right_layer,\n        )\n\n    def remove_swipe_map(self) -&gt; None:\n        \"\"\"Remove the swipe map comparison control.\"\"\"\n        self.call_js_method(\"removeSwipeMap\")\n\n    # -------------------------------------------------------------------------\n    # Opacity Slider (Section 6)\n    # -------------------------------------------------------------------------\n\n    def add_opacity_slider(\n        self,\n        layer_id: str,\n        position: str = \"top-right\",\n        label: Optional[str] = None,\n    ) -&gt; None:\n        \"\"\"Add a UI slider to control layer opacity.\n\n        Args:\n            layer_id: Layer ID to control opacity for.\n            position: Control position.\n            label: Label text. Defaults to layer_id.\n\n        Example:\n            &gt;&gt;&gt; m = MapLibreMap()\n            &gt;&gt;&gt; m.add_tile_layer(\"...\", name=\"satellite\")\n            &gt;&gt;&gt; m.add_opacity_slider(\"satellite\")\n        \"\"\"\n        self.call_js_method(\n            \"addOpacitySlider\",\n            layerId=layer_id,\n            position=position,\n            label=label or layer_id,\n        )\n\n    def remove_opacity_slider(self, layer_id: str) -&gt; None:\n        \"\"\"Remove the opacity slider for a layer.\n\n        Args:\n            layer_id: Layer identifier.\n        \"\"\"\n        self.call_js_method(\"removeOpacitySlider\", layerId=layer_id)\n\n    # -------------------------------------------------------------------------\n    # Style Switcher (Section 8)\n    # -------------------------------------------------------------------------\n\n    def add_style_switcher(\n        self,\n        styles: Dict[str, str],\n        position: str = \"top-right\",\n    ) -&gt; None:\n        \"\"\"Add a dropdown to switch between map styles.\n\n        Args:\n            styles: Dict mapping style names to style URLs.\n            position: Control position.\n\n        Example:\n            &gt;&gt;&gt; m = MapLibreMap()\n            &gt;&gt;&gt; m.add_style_switcher({\n            ...     \"Light\": \"https://basemaps.cartocdn.com/gl/positron-gl-style/style.json\",\n            ...     \"Dark\": \"https://basemaps.cartocdn.com/gl/dark-matter-gl-style/style.json\",\n            ...     \"Voyager\": \"https://basemaps.cartocdn.com/gl/voyager-gl-style/style.json\",\n            ... })\n        \"\"\"\n        self.call_js_method(\n            \"addStyleSwitcher\",\n            styles=styles,\n            position=position,\n        )\n\n    def remove_style_switcher(self) -&gt; None:\n        \"\"\"Remove the style switcher control.\"\"\"\n        self.call_js_method(\"removeStyleSwitcher\")\n\n    # -------------------------------------------------------------------------\n    # Data Export (Section 7)\n    # -------------------------------------------------------------------------\n\n    def get_visible_features(\n        self,\n        layers: Optional[List[str]] = None,\n    ) -&gt; Optional[Dict]:\n        \"\"\"Get all features currently visible in the viewport.\n\n        This triggers a query to the JavaScript side. The result is\n        returned asynchronously via the ``_queried_features`` trait.\n\n        On the first call, the query is sent and ``None`` is returned\n        because the JavaScript side has not yet responded. Run this\n        method in one notebook cell, then read the result in the next\n        cell (the event loop processes the response between cells).\n\n        Args:\n            layers: Optional list of layer IDs to query. If ``None``,\n                queries all visible layers.\n\n        Returns:\n            GeoJSON FeatureCollection dict if results are available from\n            a previous query, otherwise ``None``.\n\n        Example:\n            &gt;&gt;&gt; # Cell 1 \u2013 trigger the query\n            &gt;&gt;&gt; m.get_visible_features(layers=[\"my-layer\"])\n            &gt;&gt;&gt; # Cell 2 \u2013 read the result\n            &gt;&gt;&gt; m.get_visible_features()\n        \"\"\"\n        if layers is not None:\n            self.call_js_method(\"getVisibleFeatures\", layers=layers)\n        features = self._queried_features\n        if features and \"data\" in features:\n            return features[\"data\"]\n        return None\n\n    def to_geojson(self, layer_id: Optional[str] = None) -&gt; Optional[Dict]:\n        \"\"\"Get layer data as GeoJSON.\n\n        This triggers a query to the JavaScript side. The result is\n        returned asynchronously via the ``_queried_features`` trait.\n\n        On the first call with a ``layer_id``, the query is sent and\n        ``None`` is returned. Run this method in one notebook cell,\n        then call ``to_geojson()`` (without arguments) in the next cell\n        to read the result.\n\n        Args:\n            layer_id: Source/layer ID to export. If ``None``, returns\n                previously queried features.\n\n        Returns:\n            GeoJSON FeatureCollection dict, or ``None`` if not yet\n            available.\n\n        Example:\n            &gt;&gt;&gt; # Cell 1 \u2013 trigger the query\n            &gt;&gt;&gt; m.to_geojson(\"my-data\")\n            &gt;&gt;&gt; # Cell 2 \u2013 read the result\n            &gt;&gt;&gt; result = m.to_geojson()\n        \"\"\"\n        if layer_id:\n            self.call_js_method(\"getLayerData\", sourceId=layer_id)\n        features = self._queried_features\n        if features and \"data\" in features:\n            return features[\"data\"]\n        return None\n\n    def to_geopandas(self, layer_id: Optional[str] = None) -&gt; Any:\n        \"\"\"Get layer data as a GeoDataFrame.\n\n        Requires geopandas to be installed. Works the same as\n        :meth:`to_geojson` \u2013 trigger with a ``layer_id`` in one cell,\n        then call ``to_geopandas()`` in the next cell.\n\n        Args:\n            layer_id: Source/layer ID to export. If ``None``, returns\n                previously queried features.\n\n        Returns:\n            GeoDataFrame, or ``None`` if data not available.\n\n        Example:\n            &gt;&gt;&gt; # Cell 1 \u2013 trigger the query\n            &gt;&gt;&gt; m.to_geojson(\"my-data\")\n            &gt;&gt;&gt; # Cell 2 \u2013 read the result\n            &gt;&gt;&gt; gdf = m.to_geopandas()\n        \"\"\"\n        geojson = self.to_geojson(layer_id)\n        if geojson is None:\n            return None\n        try:\n            import geopandas as gpd\n\n            return gpd.GeoDataFrame.from_features(geojson.get(\"features\", []))\n        except ImportError:\n            raise ImportError(\"geopandas is required for to_geopandas()\")\n\n    # -------------------------------------------------------------------------\n    # HTML Export\n    # -------------------------------------------------------------------------\n\n    def _generate_html_template(self) -&gt; str:\n        \"\"\"Generate standalone HTML for the map.\"\"\"\n        template_path = Path(__file__).parent / \"templates\" / \"maplibre.html\"\n\n        if not template_path.exists():\n            raise FileNotFoundError(\n                f\"HTML template not found at {template_path}. \"\n                \"Please ensure the templates directory is included in the package.\"\n            )\n\n        template = template_path.read_text(encoding=\"utf-8\")\n\n        # Serialize state\n        state = {\n            \"center\": self.center,\n            \"zoom\": self.zoom,\n            \"style\": self.style,\n            \"bearing\": self.bearing,\n            \"pitch\": self.pitch,\n            \"width\": self.width,\n            \"height\": self.height,\n            \"layers\": self._layers,\n            \"sources\": self._sources,\n            \"controls\": self._controls,\n            \"js_calls\": self._js_calls,\n        }\n\n        template = template.replace(\"{{state}}\", json.dumps(state, indent=2))\n        return template\n</code></pre>"},{"location":"maplibre/#anymap_ts.maplibre.MapLibreMap.draw_data","title":"<code>draw_data: Dict</code>  <code>property</code> <code>readonly</code>","text":"<p>Property to access current draw data.</p>"},{"location":"maplibre/#anymap_ts.maplibre.MapLibreMap.queried_features","title":"<code>queried_features: Dict</code>  <code>property</code> <code>readonly</code>","text":"<p>Get the most recent query results.</p> <p>Returns:</p> Type Description <code>Dict</code> <p>A GeoJSON FeatureCollection dict with queried features.</p>"},{"location":"maplibre/#anymap_ts.maplibre.MapLibreMap.__init__","title":"<code>__init__(self, center=(0.0, 0.0), zoom=2.0, width='100%', height='700px', style='https://basemaps.cartocdn.com/gl/positron-gl-style/style.json', bearing=0.0, pitch=0.0, max_pitch=85.0, projection='mercator', controls=None, **kwargs)</code>  <code>special</code>","text":"<p>Initialize a MapLibre map.</p> <p>Parameters:</p> Name Type Description Default <code>center</code> <code>Tuple[float, float]</code> <p>Map center as (longitude, latitude).</p> <code>(0.0, 0.0)</code> <code>zoom</code> <code>float</code> <p>Initial zoom level.</p> <code>2.0</code> <code>width</code> <code>str</code> <p>Map width as CSS string.</p> <code>'100%'</code> <code>height</code> <code>str</code> <p>Map height as CSS string. Default is \"700px\".</p> <code>'700px'</code> <code>style</code> <code>Union[str, Dict]</code> <p>MapLibre style URL or style object. Default is \"https://basemaps.cartocdn.com/gl/positron-gl-style/style.json\".</p> <code>'https://basemaps.cartocdn.com/gl/positron-gl-style/style.json'</code> <code>bearing</code> <code>float</code> <p>Map bearing in degrees.</p> <code>0.0</code> <code>pitch</code> <code>float</code> <p>Map pitch in degrees.</p> <code>0.0</code> <code>max_pitch</code> <code>float</code> <p>Maximum pitch angle in degrees (default: 85).</p> <code>85.0</code> <code>projection</code> <code>str</code> <p>Map projection. Supported values: 'mercator', 'globe'. Default is 'mercator'.</p> <code>'mercator'</code> <code>controls</code> <code>Optional[Dict[str, Any]]</code> <p>Dict of controls to add. If None, defaults to {\"layer-control\": True, \"control-grid\": True}. Use {\"layer-control\": {\"collapsed\": True}} for custom options.</p> <code>None</code> <code>**kwargs</code> <p>Additional widget arguments.</p> <code>{}</code> Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def __init__(\n    self,\n    center: Tuple[float, float] = (0.0, 0.0),\n    zoom: float = 2.0,\n    width: str = \"100%\",\n    height: str = \"700px\",\n    style: Union[\n        str, Dict\n    ] = \"https://basemaps.cartocdn.com/gl/positron-gl-style/style.json\",\n    bearing: float = 0.0,\n    pitch: float = 0.0,\n    max_pitch: float = 85.0,\n    projection: str = \"mercator\",\n    controls: Optional[Dict[str, Any]] = None,\n    **kwargs,\n):\n    \"\"\"Initialize a MapLibre map.\n\n    Args:\n        center: Map center as (longitude, latitude).\n        zoom: Initial zoom level.\n        width: Map width as CSS string.\n        height: Map height as CSS string. Default is \"700px\".\n        style: MapLibre style URL or style object. Default is \"https://basemaps.cartocdn.com/gl/positron-gl-style/style.json\".\n        bearing: Map bearing in degrees.\n        pitch: Map pitch in degrees.\n        max_pitch: Maximum pitch angle in degrees (default: 85).\n        projection: Map projection. Supported values: 'mercator', 'globe'.\n            Default is 'mercator'.\n        controls: Dict of controls to add. If None, defaults to\n            {\"layer-control\": True, \"control-grid\": True}.\n            Use {\"layer-control\": {\"collapsed\": True}} for custom options.\n        **kwargs: Additional widget arguments.\n    \"\"\"\n    # Handle style shortcuts\n    if isinstance(style, str) and not style.startswith(\"http\"):\n        try:\n            style = get_maplibre_style(style)\n        except ValueError:\n            pass  # Use as-is\n\n    super().__init__(\n        center=list(center),\n        zoom=zoom,\n        width=width,\n        height=height,\n        style=style,\n        bearing=bearing,\n        pitch=pitch,\n        max_pitch=max_pitch,\n        projection=projection,\n        **kwargs,\n    )\n\n    # Initialize layer dictionary\n    self._layer_dict = {\"Background\": []}\n\n    # Add default controls\n    if controls is None:\n        controls = {\n            \"layer-control\": True,\n            \"control-grid\": True,\n        }\n\n    for control_name, config in controls.items():\n        if config:\n            if control_name == \"layer-control\":\n                self.add_layer_control(\n                    **(config if isinstance(config, dict) else {})\n                )\n            elif control_name == \"control-grid\":\n                self.add_control_grid(\n                    **(config if isinstance(config, dict) else {})\n                )\n            else:\n                self.add_control(\n                    control_name, **(config if isinstance(config, dict) else {})\n                )\n</code></pre>"},{"location":"maplibre/#anymap_ts.maplibre.MapLibreMap.add_3d_buildings","title":"<code>add_3d_buildings(self, source='openmaptiles', min_zoom=14, fill_extrusion_color='#aaa', fill_extrusion_opacity=0.6, height_property='render_height', base_property='render_min_height', layer_id=None, **kwargs)</code>","text":"<p>Add 3D building extrusions from vector tiles.</p> <p>Creates 3D building visualizations using fill-extrusion layers. Works best with vector tile styles that include building data.</p> <p>Note</p> <p>This feature requires a map style with vector tile building data. Recommended styles: - MapTiler styles (requires API key) - OpenFreeMap: \"https://tiles.openfreemap.org/styles/liberty\" - Protomaps styles</p> <p>CartoDB raster styles (Positron, DarkMatter) do NOT have building data. For those, the method will attempt to add OpenFreeMap tiles as a source, but results may vary.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>str</code> <p>Building source identifier. Usually auto-detected from the map style.</p> <code>'openmaptiles'</code> <code>min_zoom</code> <code>float</code> <p>Minimum zoom level to show buildings (default: 14).</p> <code>14</code> <code>fill_extrusion_color</code> <code>str</code> <p>Building color as hex string.</p> <code>'#aaa'</code> <code>fill_extrusion_opacity</code> <code>float</code> <p>Building opacity (0-1).</p> <code>0.6</code> <code>height_property</code> <code>str</code> <p>Property name for building height in the vector tiles (default: 'render_height').</p> <code>'render_height'</code> <code>base_property</code> <code>str</code> <p>Property name for building base height (default: 'render_min_height').</p> <code>'render_min_height'</code> <code>layer_id</code> <code>Optional[str]</code> <p>Layer identifier. If None, uses '3d-buildings'.</p> <code>None</code> <code>**kwargs</code> <p>Additional layer options.</p> <code>{}</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from anymap_ts import Map\n&gt;&gt;&gt; # Use a vector style with building data\n&gt;&gt;&gt; m = Map(\n...     center=[-74.0060, 40.7128],\n...     zoom=15,\n...     pitch=60,\n...     style=\"https://tiles.openfreemap.org/styles/liberty\"\n... )\n&gt;&gt;&gt; m.add_3d_buildings(\n...     fill_extrusion_color=\"#4682B4\",\n...     fill_extrusion_opacity=0.8\n... )\n</code></pre> Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def add_3d_buildings(\n    self,\n    source: str = \"openmaptiles\",\n    min_zoom: float = 14,\n    fill_extrusion_color: str = \"#aaa\",\n    fill_extrusion_opacity: float = 0.6,\n    height_property: str = \"render_height\",\n    base_property: str = \"render_min_height\",\n    layer_id: Optional[str] = None,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add 3D building extrusions from vector tiles.\n\n    Creates 3D building visualizations using fill-extrusion layers.\n    Works best with vector tile styles that include building data.\n\n    Note:\n        This feature requires a map style with vector tile building data.\n        Recommended styles:\n        - MapTiler styles (requires API key)\n        - OpenFreeMap: \"https://tiles.openfreemap.org/styles/liberty\"\n        - Protomaps styles\n\n        CartoDB raster styles (Positron, DarkMatter) do NOT have building\n        data. For those, the method will attempt to add OpenFreeMap tiles\n        as a source, but results may vary.\n\n    Args:\n        source: Building source identifier. Usually auto-detected from\n            the map style.\n        min_zoom: Minimum zoom level to show buildings (default: 14).\n        fill_extrusion_color: Building color as hex string.\n        fill_extrusion_opacity: Building opacity (0-1).\n        height_property: Property name for building height in the\n            vector tiles (default: 'render_height').\n        base_property: Property name for building base height\n            (default: 'render_min_height').\n        layer_id: Layer identifier. If None, uses '3d-buildings'.\n        **kwargs: Additional layer options.\n\n    Example:\n        &gt;&gt;&gt; from anymap_ts import Map\n        &gt;&gt;&gt; # Use a vector style with building data\n        &gt;&gt;&gt; m = Map(\n        ...     center=[-74.0060, 40.7128],\n        ...     zoom=15,\n        ...     pitch=60,\n        ...     style=\"https://tiles.openfreemap.org/styles/liberty\"\n        ... )\n        &gt;&gt;&gt; m.add_3d_buildings(\n        ...     fill_extrusion_color=\"#4682B4\",\n        ...     fill_extrusion_opacity=0.8\n        ... )\n    \"\"\"\n    layer_name = layer_id or \"3d-buildings\"\n\n    self.call_js_method(\n        \"add3DBuildings\",\n        source=source,\n        minZoom=min_zoom,\n        fillExtrusionColor=fill_extrusion_color,\n        fillExtrusionOpacity=fill_extrusion_opacity,\n        heightProperty=height_property,\n        baseProperty=base_property,\n        layerId=layer_name,\n        **kwargs,\n    )\n\n    self._layers = {\n        **self._layers,\n        layer_name: {\n            \"id\": layer_name,\n            \"type\": \"fill-extrusion\",\n        },\n    }\n    self._add_to_layer_dict(layer_name, \"Vector\")\n</code></pre>"},{"location":"maplibre/#anymap_ts.maplibre.MapLibreMap.add_3d_terrain","title":"<code>add_3d_terrain(self, source='terrarium', exaggeration=1.0, **kwargs)</code>","text":"<p>Enable 3D terrain visualization.</p> <p>MapLibre GL JS supports 3D terrain rendering using elevation data from various terrain tile sources.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>str</code> <p>Terrain source - 'terrarium' (AWS terrain tiles) or 'mapbox' (requires Mapbox token) or custom terrain URL.</p> <code>'terrarium'</code> <code>exaggeration</code> <code>float</code> <p>Vertical exaggeration factor. Default 1.0.</p> <code>1.0</code> <code>**kwargs</code> <p>Additional terrain options.</p> <code>{}</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from anymap_ts import Map\n&gt;&gt;&gt; m = Map(center=[-122.4, 37.8], zoom=12, pitch=60)\n&gt;&gt;&gt; m.add_3d_terrain(exaggeration=1.5)\n</code></pre> Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def add_3d_terrain(\n    self,\n    source: str = \"terrarium\",\n    exaggeration: float = 1.0,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Enable 3D terrain visualization.\n\n    MapLibre GL JS supports 3D terrain rendering using elevation data\n    from various terrain tile sources.\n\n    Args:\n        source: Terrain source - 'terrarium' (AWS terrain tiles) or\n            'mapbox' (requires Mapbox token) or custom terrain URL.\n        exaggeration: Vertical exaggeration factor. Default 1.0.\n        **kwargs: Additional terrain options.\n\n    Example:\n        &gt;&gt;&gt; from anymap_ts import Map\n        &gt;&gt;&gt; m = Map(center=[-122.4, 37.8], zoom=12, pitch=60)\n        &gt;&gt;&gt; m.add_3d_terrain(exaggeration=1.5)\n    \"\"\"\n    # Define terrain sources\n    terrain_sources = {\n        \"terrarium\": {\n            \"url\": \"https://s3.amazonaws.com/elevation-tiles-prod/terrarium/{z}/{x}/{y}.png\",\n            \"encoding\": \"terrarium\",\n        },\n        \"mapbox\": {\n            \"url\": \"mapbox://mapbox.mapbox-terrain-dem-v1\",\n            \"encoding\": \"mapbox\",\n        },\n    }\n\n    if source in terrain_sources:\n        terrain_config = terrain_sources[source]\n    else:\n        # Assume it's a custom URL\n        terrain_config = {\"url\": source, \"encoding\": \"terrarium\"}\n\n    self.call_js_method(\n        \"addTerrain\",\n        source=terrain_config,\n        exaggeration=exaggeration,\n        **kwargs,\n    )\n</code></pre>"},{"location":"maplibre/#anymap_ts.maplibre.MapLibreMap.add_arc_layer","title":"<code>add_arc_layer(self, data, name=None, get_source_position='source', get_target_position='target', get_source_color=None, get_target_color=None, get_width=1, get_height=1, great_circle=False, pickable=True, opacity=0.8, **kwargs)</code>","text":"<p>Add an arc layer for origin-destination visualization using deck.gl.</p> <p>Arc layers are ideal for visualizing connections between locations, such as flight routes, migration patterns, or network flows.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>Array of data objects with source/target coordinates. Each object should have source and target positions.</p> required <code>name</code> <code>Optional[str]</code> <p>Layer ID. If None, auto-generated.</p> <code>None</code> <code>get_source_position</code> <code>Union[str, Any]</code> <p>Accessor for source position [lng, lat]. Can be a string (property name) or a value.</p> <code>'source'</code> <code>get_target_position</code> <code>Union[str, Any]</code> <p>Accessor for target position [lng, lat]. Can be a string (property name) or a value.</p> <code>'target'</code> <code>get_source_color</code> <code>Optional[List[int]]</code> <p>Source end color as [r, g, b, a]. Default: [51, 136, 255, 255] (blue).</p> <code>None</code> <code>get_target_color</code> <code>Optional[List[int]]</code> <p>Target end color as [r, g, b, a]. Default: [255, 136, 51, 255] (orange).</p> <code>None</code> <code>get_width</code> <code>Union[float, str]</code> <p>Arc width in pixels. Can be a number or accessor.</p> <code>1</code> <code>get_height</code> <code>float</code> <p>Arc height multiplier. Higher values create more curved arcs.</p> <code>1</code> <code>great_circle</code> <code>bool</code> <p>Whether to draw arcs along great circles.</p> <code>False</code> <code>pickable</code> <code>bool</code> <p>Whether layer responds to hover/click events.</p> <code>True</code> <code>opacity</code> <code>float</code> <p>Layer opacity (0-1).</p> <code>0.8</code> <code>**kwargs</code> <p>Additional ArcLayer props.</p> <code>{}</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from anymap_ts import MapLibreMap\n&gt;&gt;&gt; m = MapLibreMap()\n&gt;&gt;&gt; arcs = [\n...     {\"source\": [-122.4, 37.8], \"target\": [-73.9, 40.7]},\n...     {\"source\": [-122.4, 37.8], \"target\": [-0.1, 51.5]},\n... ]\n&gt;&gt;&gt; m.add_arc_layer(arcs, name=\"flights\")\n</code></pre> Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def add_arc_layer(\n    self,\n    data: Any,\n    name: Optional[str] = None,\n    get_source_position: Union[str, Any] = \"source\",\n    get_target_position: Union[str, Any] = \"target\",\n    get_source_color: Optional[List[int]] = None,\n    get_target_color: Optional[List[int]] = None,\n    get_width: Union[float, str] = 1,\n    get_height: float = 1,\n    great_circle: bool = False,\n    pickable: bool = True,\n    opacity: float = 0.8,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add an arc layer for origin-destination visualization using deck.gl.\n\n    Arc layers are ideal for visualizing connections between locations,\n    such as flight routes, migration patterns, or network flows.\n\n    Args:\n        data: Array of data objects with source/target coordinates.\n            Each object should have source and target positions.\n        name: Layer ID. If None, auto-generated.\n        get_source_position: Accessor for source position [lng, lat].\n            Can be a string (property name) or a value.\n        get_target_position: Accessor for target position [lng, lat].\n            Can be a string (property name) or a value.\n        get_source_color: Source end color as [r, g, b, a].\n            Default: [51, 136, 255, 255] (blue).\n        get_target_color: Target end color as [r, g, b, a].\n            Default: [255, 136, 51, 255] (orange).\n        get_width: Arc width in pixels. Can be a number or accessor.\n        get_height: Arc height multiplier. Higher values create more curved arcs.\n        great_circle: Whether to draw arcs along great circles.\n        pickable: Whether layer responds to hover/click events.\n        opacity: Layer opacity (0-1).\n        **kwargs: Additional ArcLayer props.\n\n    Example:\n        &gt;&gt;&gt; from anymap_ts import MapLibreMap\n        &gt;&gt;&gt; m = MapLibreMap()\n        &gt;&gt;&gt; arcs = [\n        ...     {\"source\": [-122.4, 37.8], \"target\": [-73.9, 40.7]},\n        ...     {\"source\": [-122.4, 37.8], \"target\": [-0.1, 51.5]},\n        ... ]\n        &gt;&gt;&gt; m.add_arc_layer(arcs, name=\"flights\")\n    \"\"\"\n    layer_id = name or f\"arc-{len(self._layers)}\"\n    processed_data = self._process_deck_data(data)\n\n    self.call_js_method(\n        \"addArcLayer\",\n        id=layer_id,\n        data=processed_data,\n        getSourcePosition=get_source_position,\n        getTargetPosition=get_target_position,\n        getSourceColor=get_source_color or [51, 136, 255, 255],\n        getTargetColor=get_target_color or [255, 136, 51, 255],\n        getWidth=get_width,\n        getHeight=get_height,\n        greatCircle=great_circle,\n        pickable=pickable,\n        opacity=opacity,\n        **kwargs,\n    )\n\n    self._layers = {\n        **self._layers,\n        layer_id: {\n            \"id\": layer_id,\n            \"type\": \"arc\",\n        },\n    }\n    self._add_to_layer_dict(layer_id, \"Deck.gl\")\n</code></pre>"},{"location":"maplibre/#anymap_ts.maplibre.MapLibreMap.add_basemap","title":"<code>add_basemap(self, basemap='OpenStreetMap', attribution=None, **kwargs)</code>","text":"<p>Add a basemap layer.</p> <p>Parameters:</p> Name Type Description Default <code>basemap</code> <code>str</code> <p>Name of basemap provider (e.g., \"OpenStreetMap\", \"CartoDB.Positron\")</p> <code>'OpenStreetMap'</code> <code>attribution</code> <code>Optional[str]</code> <p>Custom attribution text</p> <code>None</code> <code>**kwargs</code> <p>Additional options</p> <code>{}</code> Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def add_basemap(\n    self,\n    basemap: str = \"OpenStreetMap\",\n    attribution: Optional[str] = None,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a basemap layer.\n\n    Args:\n        basemap: Name of basemap provider (e.g., \"OpenStreetMap\", \"CartoDB.Positron\")\n        attribution: Custom attribution text\n        **kwargs: Additional options\n    \"\"\"\n    url, default_attribution = get_basemap_url(basemap)\n    self.call_js_method(\n        \"addBasemap\",\n        url,\n        attribution=attribution or default_attribution,\n        name=basemap,\n        **kwargs,\n    )\n\n    # Track in layer dict\n    basemaps = self._layer_dict.get(\"Basemaps\", [])\n    if basemap not in basemaps:\n        self._layer_dict = {\n            **self._layer_dict,\n            \"Basemaps\": basemaps + [basemap],\n        }\n</code></pre>"},{"location":"maplibre/#anymap_ts.maplibre.MapLibreMap.add_bitmap_layer","title":"<code>add_bitmap_layer(self, image, bounds, name=None, opacity=1.0, visible=True, pickable=False, desaturate=0, transparent_color=None, tint_color=None, **kwargs)</code>","text":"<p>Add a bitmap layer for image overlay with GPU rendering using deck.gl.</p> <p>Parameters:</p> Name Type Description Default <code>image</code> <code>str</code> <p>URL or data URI of the image.</p> required <code>bounds</code> <code>List[float]</code> <p>Bounding box [west, south, east, north].</p> required <code>name</code> <code>Optional[str]</code> <p>Layer ID. If None, auto-generated.</p> <code>None</code> <code>opacity</code> <code>float</code> <p>Layer opacity (0-1).</p> <code>1.0</code> <code>visible</code> <code>bool</code> <p>Whether layer is visible.</p> <code>True</code> <code>pickable</code> <code>bool</code> <p>Whether layer responds to hover/click events.</p> <code>False</code> <code>desaturate</code> <code>float</code> <p>Desaturation amount (0-1).</p> <code>0</code> <code>transparent_color</code> <code>Optional[List[int]]</code> <p>Color to make transparent [r, g, b, a].</p> <code>None</code> <code>tint_color</code> <code>Optional[List[int]]</code> <p>Color to tint the image [r, g, b].</p> <code>None</code> <code>**kwargs</code> <p>Additional BitmapLayer props.</p> <code>{}</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from anymap_ts import MapLibreMap\n&gt;&gt;&gt; m = MapLibreMap()\n&gt;&gt;&gt; m.add_bitmap_layer(\n...     \"https://example.com/overlay.png\",\n...     bounds=[-122.5, 37.7, -122.3, 37.9],\n... )\n</code></pre> Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def add_bitmap_layer(\n    self,\n    image: str,\n    bounds: List[float],\n    name: Optional[str] = None,\n    opacity: float = 1.0,\n    visible: bool = True,\n    pickable: bool = False,\n    desaturate: float = 0,\n    transparent_color: Optional[List[int]] = None,\n    tint_color: Optional[List[int]] = None,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a bitmap layer for image overlay with GPU rendering using deck.gl.\n\n    Args:\n        image: URL or data URI of the image.\n        bounds: Bounding box [west, south, east, north].\n        name: Layer ID. If None, auto-generated.\n        opacity: Layer opacity (0-1).\n        visible: Whether layer is visible.\n        pickable: Whether layer responds to hover/click events.\n        desaturate: Desaturation amount (0-1).\n        transparent_color: Color to make transparent [r, g, b, a].\n        tint_color: Color to tint the image [r, g, b].\n        **kwargs: Additional BitmapLayer props.\n\n    Example:\n        &gt;&gt;&gt; from anymap_ts import MapLibreMap\n        &gt;&gt;&gt; m = MapLibreMap()\n        &gt;&gt;&gt; m.add_bitmap_layer(\n        ...     \"https://example.com/overlay.png\",\n        ...     bounds=[-122.5, 37.7, -122.3, 37.9],\n        ... )\n    \"\"\"\n    layer_id = name or f\"bitmap-{len(self._layers)}\"\n\n    self.call_js_method(\n        \"addBitmapLayer\",\n        id=layer_id,\n        image=image,\n        bounds=bounds,\n        opacity=opacity,\n        visible=visible,\n        pickable=pickable,\n        desaturate=desaturate,\n        transparentColor=transparent_color or [0, 0, 0, 0],\n        tintColor=tint_color or [255, 255, 255],\n        **kwargs,\n    )\n\n    self._layers = {\n        **self._layers,\n        layer_id: {\"id\": layer_id, \"type\": \"bitmap\"},\n    }\n    self._add_to_layer_dict(layer_id, \"Deck.gl\")\n</code></pre>"},{"location":"maplibre/#anymap_ts.maplibre.MapLibreMap.add_choropleth","title":"<code>add_choropleth(self, data, column, cmap='viridis', classification='quantile', k=5, breaks=None, fill_opacity=0.7, line_color='#000000', line_width=1, legend=True, legend_title=None, hover=True, layer_id=None, fit_bounds=True, **kwargs)</code>","text":"<p>Add a choropleth (thematic) map layer with automatic classification.</p> <p>Choropleth maps use color gradients to visualize data values across geographic areas. This method automatically classifies data and applies appropriate colors.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>Polygon data - GeoJSON, GeoDataFrame, file path, or URL.</p> required <code>column</code> <code>str</code> <p>Property name to visualize (must be numeric).</p> required <code>cmap</code> <code>str</code> <p>Colormap name. Any matplotlib colormap is supported when matplotlib is installed. Common options include: - Sequential: 'viridis', 'plasma', 'inferno', 'magma', 'cividis',   'Blues', 'Greens', 'Reds', 'Oranges', 'Purples', 'Greys' - Diverging: 'RdBu', 'RdYlGn', 'RdYlBu', 'Spectral', 'coolwarm' - Qualitative: 'Set1', 'Set2', 'Set3', 'Paired', 'tab10', 'tab20' See: https://matplotlib.org/stable/gallery/color/colormap_reference.html</p> <code>'viridis'</code> <code>classification</code> <code>str</code> <p>Classification method: - 'quantile': Equal number of features per class - 'equal_interval': Equal value ranges - 'natural_breaks': Jenks natural breaks (requires jenkspy) - 'manual': Use custom breaks</p> <code>'quantile'</code> <code>k</code> <code>int</code> <p>Number of classes (ignored if classification='manual').</p> <code>5</code> <code>breaks</code> <code>Optional[List[float]]</code> <p>Custom break values for 'manual' classification. Must have k+1 values defining class boundaries.</p> <code>None</code> <code>fill_opacity</code> <code>float</code> <p>Polygon fill opacity (0-1).</p> <code>0.7</code> <code>line_color</code> <code>str</code> <p>Polygon outline color.</p> <code>'#000000'</code> <code>line_width</code> <code>float</code> <p>Polygon outline width.</p> <code>1</code> <code>legend</code> <code>bool</code> <p>Whether to add a legend.</p> <code>True</code> <code>legend_title</code> <code>Optional[str]</code> <p>Legend title. Defaults to column name.</p> <code>None</code> <code>hover</code> <code>bool</code> <p>Whether to enable hover highlight effect.</p> <code>True</code> <code>layer_id</code> <code>Optional[str]</code> <p>Layer identifier. If None, auto-generated.</p> <code>None</code> <code>fit_bounds</code> <code>bool</code> <p>Whether to fit map to data bounds.</p> <code>True</code> <code>**kwargs</code> <p>Additional layer options.</p> <code>{}</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from anymap_ts import Map\n&gt;&gt;&gt; m = Map()\n&gt;&gt;&gt; m.add_choropleth(\n...     \"us_states.geojson\",\n...     column=\"population\",\n...     cmap=\"YlOrRd\",\n...     classification=\"quantile\",\n...     k=5,\n...     legend_title=\"Population\"\n... )\n</code></pre> Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def add_choropleth(\n    self,\n    data: Any,\n    column: str,\n    cmap: str = \"viridis\",\n    classification: str = \"quantile\",\n    k: int = 5,\n    breaks: Optional[List[float]] = None,\n    fill_opacity: float = 0.7,\n    line_color: str = \"#000000\",\n    line_width: float = 1,\n    legend: bool = True,\n    legend_title: Optional[str] = None,\n    hover: bool = True,\n    layer_id: Optional[str] = None,\n    fit_bounds: bool = True,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a choropleth (thematic) map layer with automatic classification.\n\n    Choropleth maps use color gradients to visualize data values across\n    geographic areas. This method automatically classifies data and applies\n    appropriate colors.\n\n    Args:\n        data: Polygon data - GeoJSON, GeoDataFrame, file path, or URL.\n        column: Property name to visualize (must be numeric).\n        cmap: Colormap name. Any matplotlib colormap is supported when\n            matplotlib is installed. Common options include:\n            - Sequential: 'viridis', 'plasma', 'inferno', 'magma', 'cividis',\n              'Blues', 'Greens', 'Reds', 'Oranges', 'Purples', 'Greys'\n            - Diverging: 'RdBu', 'RdYlGn', 'RdYlBu', 'Spectral', 'coolwarm'\n            - Qualitative: 'Set1', 'Set2', 'Set3', 'Paired', 'tab10', 'tab20'\n            See: https://matplotlib.org/stable/gallery/color/colormap_reference.html\n        classification: Classification method:\n            - 'quantile': Equal number of features per class\n            - 'equal_interval': Equal value ranges\n            - 'natural_breaks': Jenks natural breaks (requires jenkspy)\n            - 'manual': Use custom breaks\n        k: Number of classes (ignored if classification='manual').\n        breaks: Custom break values for 'manual' classification.\n            Must have k+1 values defining class boundaries.\n        fill_opacity: Polygon fill opacity (0-1).\n        line_color: Polygon outline color.\n        line_width: Polygon outline width.\n        legend: Whether to add a legend.\n        legend_title: Legend title. Defaults to column name.\n        hover: Whether to enable hover highlight effect.\n        layer_id: Layer identifier. If None, auto-generated.\n        fit_bounds: Whether to fit map to data bounds.\n        **kwargs: Additional layer options.\n\n    Example:\n        &gt;&gt;&gt; from anymap_ts import Map\n        &gt;&gt;&gt; m = Map()\n        &gt;&gt;&gt; m.add_choropleth(\n        ...     \"us_states.geojson\",\n        ...     column=\"population\",\n        ...     cmap=\"YlOrRd\",\n        ...     classification=\"quantile\",\n        ...     k=5,\n        ...     legend_title=\"Population\"\n        ... )\n    \"\"\"\n    from .utils import (\n        get_choropleth_colors,\n        compute_breaks,\n        build_step_expression,\n    )\n\n    layer_name = layer_id or f\"choropleth-{len(self._layers)}\"\n\n    # Convert data to GeoJSON\n    geojson = to_geojson(data)\n\n    # Handle URL data - fetch GeoJSON\n    if geojson.get(\"type\") == \"url\":\n        url = geojson[\"url\"]\n        geojson = fetch_geojson(url)\n\n    # Extract values for classification\n    features = geojson.get(\"features\", [])\n    values = []\n    for feature in features:\n        props = feature.get(\"properties\", {})\n        val = props.get(column)\n        if val is not None:\n            try:\n                values.append(float(val))\n            except (TypeError, ValueError):\n                pass\n\n    if not values:\n        raise ValueError(f\"No valid numeric values found for column '{column}'\")\n\n    # Compute breaks\n    computed_breaks = compute_breaks(values, classification, k, breaks)\n\n    # Get colors\n    colors = get_choropleth_colors(cmap, k)\n\n    # Build step expression for MapLibre\n    step_expr = build_step_expression(column, computed_breaks, colors)\n\n    # Get bounds\n    bounds = get_bounds(geojson) if fit_bounds else None\n\n    self.call_js_method(\n        \"addChoropleth\",\n        data=geojson,\n        name=layer_name,\n        column=column,\n        stepExpression=step_expr,\n        fillOpacity=fill_opacity,\n        lineColor=line_color,\n        lineWidth=line_width,\n        hover=hover,\n        fitBounds=fit_bounds,\n        bounds=bounds,\n        **kwargs,\n    )\n\n    self._layers = {\n        **self._layers,\n        layer_name: {\n            \"id\": layer_name,\n            \"type\": \"choropleth\",\n            \"source\": f\"{layer_name}-source\",\n            \"column\": column,\n        },\n    }\n    self._add_to_layer_dict(layer_name, \"Vector\")\n\n    # Add legend\n    if legend:\n        title = legend_title or column\n        # Create labels from breaks\n        labels = []\n        for i in range(len(computed_breaks) - 1):\n            low = computed_breaks[i]\n            high = computed_breaks[i + 1]\n            if i == len(computed_breaks) - 2:\n                labels.append(f\"{low:.1f} - {high:.1f}\")\n            else:\n                labels.append(f\"{low:.1f} - {high:.1f}\")\n\n        self.add_legend(\n            title=title,\n            labels=labels,\n            colors=colors,\n            position=\"bottom-right\",\n        )\n</code></pre>"},{"location":"maplibre/#anymap_ts.maplibre.MapLibreMap.add_cluster_layer","title":"<code>add_cluster_layer(self, data, cluster_radius=50, cluster_max_zoom=14, cluster_colors=None, cluster_steps=None, cluster_min_radius=15, cluster_max_radius=30, unclustered_color='#11b4da', unclustered_radius=8, show_cluster_count=True, name=None, zoom_on_click=True, fit_bounds=True, **kwargs)</code>","text":"<p>Add a clustered point layer with automatic grouping.</p> <p>Creates a point layer that automatically clusters nearby points at lower zoom levels. Clicking on clusters zooms in to expand them.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>Point data - GeoJSON, GeoDataFrame, file path, or URL.</p> required <code>cluster_radius</code> <code>int</code> <p>Radius of each cluster when grouping points (pixels).</p> <code>50</code> <code>cluster_max_zoom</code> <code>int</code> <p>Max zoom level to cluster points (above this, all points are shown individually).</p> <code>14</code> <code>cluster_colors</code> <code>Optional[List[str]]</code> <p>List of colors for cluster circles by size. Default: [\"#51bbd6\", \"#f1f075\", \"#f28cb1\"].</p> <code>None</code> <code>cluster_steps</code> <code>Optional[List[int]]</code> <p>Point count thresholds for color changes. Default: [100, 750]. Must have len(cluster_colors) - 1 values.</p> <code>None</code> <code>cluster_min_radius</code> <code>int</code> <p>Minimum cluster circle radius in pixels.</p> <code>15</code> <code>cluster_max_radius</code> <code>int</code> <p>Maximum cluster circle radius in pixels.</p> <code>30</code> <code>unclustered_color</code> <code>str</code> <p>Color for individual (unclustered) points.</p> <code>'#11b4da'</code> <code>unclustered_radius</code> <code>int</code> <p>Radius for individual points in pixels.</p> <code>8</code> <code>show_cluster_count</code> <code>bool</code> <p>Whether to show point count in clusters.</p> <code>True</code> <code>name</code> <code>Optional[str]</code> <p>Layer identifier. If None, auto-generated.</p> <code>None</code> <code>zoom_on_click</code> <code>bool</code> <p>Whether clicking clusters zooms in to expand them.</p> <code>True</code> <code>fit_bounds</code> <code>bool</code> <p>Whether to fit map to data bounds.</p> <code>True</code> <code>**kwargs</code> <p>Additional options.</p> <code>{}</code> <p>Returns:</p> Type Description <code>str</code> <p>The layer identifier.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from anymap_ts import Map\n&gt;&gt;&gt; m = Map()\n&gt;&gt;&gt; m.add_cluster_layer(\n...     \"earthquakes.geojson\",\n...     cluster_radius=80,\n...     cluster_colors=[\"#00ff00\", \"#ffff00\", \"#ff0000\"],\n...     cluster_steps=[50, 500],\n... )\n</code></pre> Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def add_cluster_layer(\n    self,\n    data: Any,\n    cluster_radius: int = 50,\n    cluster_max_zoom: int = 14,\n    cluster_colors: Optional[List[str]] = None,\n    cluster_steps: Optional[List[int]] = None,\n    cluster_min_radius: int = 15,\n    cluster_max_radius: int = 30,\n    unclustered_color: str = \"#11b4da\",\n    unclustered_radius: int = 8,\n    show_cluster_count: bool = True,\n    name: Optional[str] = None,\n    zoom_on_click: bool = True,\n    fit_bounds: bool = True,\n    **kwargs,\n) -&gt; str:\n    \"\"\"Add a clustered point layer with automatic grouping.\n\n    Creates a point layer that automatically clusters nearby points at\n    lower zoom levels. Clicking on clusters zooms in to expand them.\n\n    Args:\n        data: Point data - GeoJSON, GeoDataFrame, file path, or URL.\n        cluster_radius: Radius of each cluster when grouping points (pixels).\n        cluster_max_zoom: Max zoom level to cluster points (above this, all\n            points are shown individually).\n        cluster_colors: List of colors for cluster circles by size.\n            Default: [\"#51bbd6\", \"#f1f075\", \"#f28cb1\"].\n        cluster_steps: Point count thresholds for color changes.\n            Default: [100, 750]. Must have len(cluster_colors) - 1 values.\n        cluster_min_radius: Minimum cluster circle radius in pixels.\n        cluster_max_radius: Maximum cluster circle radius in pixels.\n        unclustered_color: Color for individual (unclustered) points.\n        unclustered_radius: Radius for individual points in pixels.\n        show_cluster_count: Whether to show point count in clusters.\n        name: Layer identifier. If None, auto-generated.\n        zoom_on_click: Whether clicking clusters zooms in to expand them.\n        fit_bounds: Whether to fit map to data bounds.\n        **kwargs: Additional options.\n\n    Returns:\n        The layer identifier.\n\n    Example:\n        &gt;&gt;&gt; from anymap_ts import Map\n        &gt;&gt;&gt; m = Map()\n        &gt;&gt;&gt; m.add_cluster_layer(\n        ...     \"earthquakes.geojson\",\n        ...     cluster_radius=80,\n        ...     cluster_colors=[\"#00ff00\", \"#ffff00\", \"#ff0000\"],\n        ...     cluster_steps=[50, 500],\n        ... )\n    \"\"\"\n    layer_id = name or f\"cluster-{len(self._layers)}\"\n\n    # Default colors and steps\n    if cluster_colors is None:\n        cluster_colors = [\"#51bbd6\", \"#f1f075\", \"#f28cb1\"]\n    if cluster_steps is None:\n        cluster_steps = [100, 750]\n\n    # Validate steps vs colors\n    if len(cluster_steps) != len(cluster_colors) - 1:\n        raise ValueError(\n            f\"cluster_steps must have {len(cluster_colors) - 1} values \"\n            f\"(one less than cluster_colors), got {len(cluster_steps)}\"\n        )\n\n    # Convert data to GeoJSON\n    geojson = to_geojson(data)\n\n    # Handle URL data - fetch GeoJSON\n    if geojson.get(\"type\") == \"url\":\n        url = geojson[\"url\"]\n        geojson = fetch_geojson(url)\n\n    # Get bounds\n    bounds = get_bounds(geojson) if fit_bounds else None\n\n    self.call_js_method(\n        \"addClusterLayer\",\n        data=geojson,\n        name=layer_id,\n        clusterRadius=cluster_radius,\n        clusterMaxZoom=cluster_max_zoom,\n        clusterColors=cluster_colors,\n        clusterSteps=cluster_steps,\n        clusterMinRadius=cluster_min_radius,\n        clusterMaxRadius=cluster_max_radius,\n        unclusteredColor=unclustered_color,\n        unclusteredRadius=unclustered_radius,\n        showClusterCount=show_cluster_count,\n        zoomOnClick=zoom_on_click,\n        fitBounds=fit_bounds,\n        bounds=bounds,\n        **kwargs,\n    )\n\n    self._layers = {\n        **self._layers,\n        layer_id: {\n            \"id\": layer_id,\n            \"type\": \"cluster\",\n            \"source\": f\"{layer_id}-source\",\n        },\n    }\n    self._add_to_layer_dict(layer_id, \"Vector\")\n    return layer_id\n</code></pre>"},{"location":"maplibre/#anymap_ts.maplibre.MapLibreMap.add_cog_control","title":"<code>add_cog_control(self, position='top-right', collapsed=True, default_url=None, load_default_url=False, default_opacity=1.0, default_colormap='viridis', default_bands='1', default_rescale_min=0, default_rescale_max=255, **kwargs)</code>","text":"<p>Add a COG layer control for loading Cloud Optimized GeoTIFFs via UI.</p> <p>This provides an interactive panel for users to enter COG URLs and configure visualization parameters like colormap and rescaling.</p> <p>Parameters:</p> Name Type Description Default <code>position</code> <code>str</code> <p>Control position ('top-left', 'top-right', 'bottom-left', 'bottom-right').</p> <code>'top-right'</code> <code>collapsed</code> <code>bool</code> <p>Whether the panel starts collapsed.</p> <code>True</code> <code>default_url</code> <code>Optional[str]</code> <p>Default COG URL to pre-fill.</p> <code>None</code> <code>load_default_url</code> <code>bool</code> <p>Whether to auto-load the default URL.</p> <code>False</code> <code>default_opacity</code> <code>float</code> <p>Default layer opacity (0-1).</p> <code>1.0</code> <code>default_colormap</code> <code>str</code> <p>Default colormap name.</p> <code>'viridis'</code> <code>default_bands</code> <code>str</code> <p>Default bands (e.g., '1' or '1,2,3').</p> <code>'1'</code> <code>default_rescale_min</code> <code>float</code> <p>Default minimum value for rescaling.</p> <code>0</code> <code>default_rescale_max</code> <code>float</code> <p>Default maximum value for rescaling.</p> <code>255</code> <code>**kwargs</code> <p>Additional control options.</p> <code>{}</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from anymap_ts import MapLibreMap\n&gt;&gt;&gt; m = MapLibreMap()\n&gt;&gt;&gt; m.add_cog_control(\n...     default_url=\"https://example.com/cog.tif\",\n...     default_colormap=\"terrain\"\n... )\n</code></pre> Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def add_cog_control(\n    self,\n    position: str = \"top-right\",\n    collapsed: bool = True,\n    default_url: Optional[str] = None,\n    load_default_url: bool = False,\n    default_opacity: float = 1.0,\n    default_colormap: str = \"viridis\",\n    default_bands: str = \"1\",\n    default_rescale_min: float = 0,\n    default_rescale_max: float = 255,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a COG layer control for loading Cloud Optimized GeoTIFFs via UI.\n\n    This provides an interactive panel for users to enter COG URLs\n    and configure visualization parameters like colormap and rescaling.\n\n    Args:\n        position: Control position ('top-left', 'top-right', 'bottom-left', 'bottom-right').\n        collapsed: Whether the panel starts collapsed.\n        default_url: Default COG URL to pre-fill.\n        load_default_url: Whether to auto-load the default URL.\n        default_opacity: Default layer opacity (0-1).\n        default_colormap: Default colormap name.\n        default_bands: Default bands (e.g., '1' or '1,2,3').\n        default_rescale_min: Default minimum value for rescaling.\n        default_rescale_max: Default maximum value for rescaling.\n        **kwargs: Additional control options.\n\n    Example:\n        &gt;&gt;&gt; from anymap_ts import MapLibreMap\n        &gt;&gt;&gt; m = MapLibreMap()\n        &gt;&gt;&gt; m.add_cog_control(\n        ...     default_url=\"https://example.com/cog.tif\",\n        ...     default_colormap=\"terrain\"\n        ... )\n    \"\"\"\n    self.call_js_method(\n        \"addCogControl\",\n        position=position,\n        collapsed=collapsed,\n        defaultUrl=default_url or \"\",\n        loadDefaultUrl=load_default_url,\n        defaultOpacity=default_opacity,\n        defaultColormap=default_colormap,\n        defaultBands=default_bands,\n        defaultRescaleMin=default_rescale_min,\n        defaultRescaleMax=default_rescale_max,\n        **kwargs,\n    )\n    self._controls = {\n        **self._controls,\n        \"cog-control\": {\"position\": position, \"collapsed\": collapsed},\n    }\n</code></pre>"},{"location":"maplibre/#anymap_ts.maplibre.MapLibreMap.add_cog_layer","title":"<code>add_cog_layer(self, url, name=None, opacity=1.0, visible=True, debug=False, debug_opacity=0.25, max_error=0.125, fit_bounds=True, before_id=None, **kwargs)</code>","text":"<p>Add a Cloud Optimized GeoTIFF (COG) layer using @developmentseed/deck.gl-geotiff.</p> <p>This method renders COG files directly in the browser using GPU-accelerated deck.gl-geotiff rendering with automatic reprojection support.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>URL to the Cloud Optimized GeoTIFF file.</p> required <code>name</code> <code>Optional[str]</code> <p>Layer ID. If None, auto-generated.</p> <code>None</code> <code>opacity</code> <code>float</code> <p>Layer opacity (0-1).</p> <code>1.0</code> <code>visible</code> <code>bool</code> <p>Whether layer is visible.</p> <code>True</code> <code>debug</code> <code>bool</code> <p>Show reprojection mesh for debugging.</p> <code>False</code> <code>debug_opacity</code> <code>float</code> <p>Opacity of debug mesh (0-1).</p> <code>0.25</code> <code>max_error</code> <code>float</code> <p>Maximum reprojection error in pixels. Lower values create denser mesh for better accuracy.</p> <code>0.125</code> <code>fit_bounds</code> <code>bool</code> <p>Whether to fit map to COG bounds after loading.</p> <code>True</code> <code>before_id</code> <code>Optional[str]</code> <p>ID of layer to insert before.</p> <code>None</code> <code>**kwargs</code> <p>Additional COGLayer props.</p> <code>{}</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from anymap_ts import Map\n&gt;&gt;&gt; m = Map()\n&gt;&gt;&gt; m.add_cog_layer(\n...     \"https://example.com/landcover.tif\",\n...     name=\"landcover\",\n...     opacity=0.8\n... )\n</code></pre> Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def add_cog_layer(\n    self,\n    url: str,\n    name: Optional[str] = None,\n    opacity: float = 1.0,\n    visible: bool = True,\n    debug: bool = False,\n    debug_opacity: float = 0.25,\n    max_error: float = 0.125,\n    fit_bounds: bool = True,\n    before_id: Optional[str] = None,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a Cloud Optimized GeoTIFF (COG) layer using @developmentseed/deck.gl-geotiff.\n\n    This method renders COG files directly in the browser using GPU-accelerated\n    deck.gl-geotiff rendering with automatic reprojection support.\n\n    Args:\n        url: URL to the Cloud Optimized GeoTIFF file.\n        name: Layer ID. If None, auto-generated.\n        opacity: Layer opacity (0-1).\n        visible: Whether layer is visible.\n        debug: Show reprojection mesh for debugging.\n        debug_opacity: Opacity of debug mesh (0-1).\n        max_error: Maximum reprojection error in pixels. Lower values\n            create denser mesh for better accuracy.\n        fit_bounds: Whether to fit map to COG bounds after loading.\n        before_id: ID of layer to insert before.\n        **kwargs: Additional COGLayer props.\n\n    Example:\n        &gt;&gt;&gt; from anymap_ts import Map\n        &gt;&gt;&gt; m = Map()\n        &gt;&gt;&gt; m.add_cog_layer(\n        ...     \"https://example.com/landcover.tif\",\n        ...     name=\"landcover\",\n        ...     opacity=0.8\n        ... )\n    \"\"\"\n    layer_id = name or f\"cog-{len(self._layers)}\"\n\n    self.call_js_method(\n        \"addCOGLayer\",\n        id=layer_id,\n        geotiff=url,\n        opacity=opacity,\n        visible=visible,\n        debug=debug,\n        debugOpacity=debug_opacity,\n        maxError=max_error,\n        fitBounds=fit_bounds,\n        beforeId=before_id,\n        **kwargs,\n    )\n\n    self._layers = {\n        **self._layers,\n        layer_id: {\n            \"id\": layer_id,\n            \"type\": \"cog\",\n            \"url\": url,\n        },\n    }\n    self._add_to_layer_dict(layer_id, \"Raster\")\n</code></pre>"},{"location":"maplibre/#anymap_ts.maplibre.MapLibreMap.add_colorbar","title":"<code>add_colorbar(self, colormap='viridis', vmin=0, vmax=1, label='', units='', orientation='horizontal', position='bottom-right', bar_thickness=None, bar_length=None, ticks=None, opacity=None, colorbar_id=None, **kwargs)</code>","text":"<p>Add a continuous gradient colorbar to the map.</p> <p>Displays a color gradient legend with customizable colormaps, tick marks, labels, and positioning using maplibre-gl-components.</p> <p>Parameters:</p> Name Type Description Default <code>colormap</code> <code>str</code> <p>Colormap name (e.g., 'viridis', 'plasma', 'inferno', 'magma', 'cividis', 'coolwarm', 'jet', 'terrain', etc.).</p> <code>'viridis'</code> <code>vmin</code> <code>float</code> <p>Minimum value for the colorbar scale.</p> <code>0</code> <code>vmax</code> <code>float</code> <p>Maximum value for the colorbar scale.</p> <code>1</code> <code>label</code> <code>str</code> <p>Title/label displayed above or beside the colorbar.</p> <code>''</code> <code>units</code> <code>str</code> <p>Unit string displayed after values (e.g., '\u00b0C', 'm').</p> <code>''</code> <code>orientation</code> <code>str</code> <p>Orientation of the colorbar ('horizontal' or 'vertical').</p> <code>'horizontal'</code> <code>position</code> <code>str</code> <p>Control position ('top-left', 'top-right', 'bottom-left', 'bottom-right').</p> <code>'bottom-right'</code> <code>bar_thickness</code> <code>Optional[int]</code> <p>Width/height of the gradient bar in pixels.</p> <code>None</code> <code>bar_length</code> <code>Optional[int]</code> <p>Length of the colorbar in pixels.</p> <code>None</code> <code>ticks</code> <code>Optional[Dict]</code> <p>Tick configuration dict (e.g., {'count': 5, 'precision': 2}).</p> <code>None</code> <code>opacity</code> <code>Optional[float]</code> <p>Opacity of the colorbar container (0-1).</p> <code>None</code> <code>colorbar_id</code> <code>Optional[str]</code> <p>Unique identifier. If None, auto-generated.</p> <code>None</code> <code>**kwargs</code> <p>Additional Colorbar options.</p> <code>{}</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; m = Map()\n&gt;&gt;&gt; m.add_cog_layer(\"https://example.com/dem.tif\")\n&gt;&gt;&gt; m.add_colorbar(\n...     colormap=\"terrain\",\n...     vmin=0,\n...     vmax=4000,\n...     label=\"Elevation\",\n...     units=\"m\",\n... )\n</code></pre> Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def add_colorbar(\n    self,\n    colormap: str = \"viridis\",\n    vmin: float = 0,\n    vmax: float = 1,\n    label: str = \"\",\n    units: str = \"\",\n    orientation: str = \"horizontal\",\n    position: str = \"bottom-right\",\n    bar_thickness: Optional[int] = None,\n    bar_length: Optional[int] = None,\n    ticks: Optional[Dict] = None,\n    opacity: Optional[float] = None,\n    colorbar_id: Optional[str] = None,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a continuous gradient colorbar to the map.\n\n    Displays a color gradient legend with customizable colormaps,\n    tick marks, labels, and positioning using maplibre-gl-components.\n\n    Args:\n        colormap: Colormap name (e.g., 'viridis', 'plasma', 'inferno',\n            'magma', 'cividis', 'coolwarm', 'jet', 'terrain', etc.).\n        vmin: Minimum value for the colorbar scale.\n        vmax: Maximum value for the colorbar scale.\n        label: Title/label displayed above or beside the colorbar.\n        units: Unit string displayed after values (e.g., '\u00b0C', 'm').\n        orientation: Orientation of the colorbar ('horizontal' or 'vertical').\n        position: Control position ('top-left', 'top-right',\n            'bottom-left', 'bottom-right').\n        bar_thickness: Width/height of the gradient bar in pixels.\n        bar_length: Length of the colorbar in pixels.\n        ticks: Tick configuration dict (e.g., {'count': 5, 'precision': 2}).\n        opacity: Opacity of the colorbar container (0-1).\n        colorbar_id: Unique identifier. If None, auto-generated.\n        **kwargs: Additional Colorbar options.\n\n    Example:\n        &gt;&gt;&gt; m = Map()\n        &gt;&gt;&gt; m.add_cog_layer(\"https://example.com/dem.tif\")\n        &gt;&gt;&gt; m.add_colorbar(\n        ...     colormap=\"terrain\",\n        ...     vmin=0,\n        ...     vmax=4000,\n        ...     label=\"Elevation\",\n        ...     units=\"m\",\n        ... )\n    \"\"\"\n    self._validate_position(position)\n\n    cbar_id = (\n        colorbar_id\n        or f\"colorbar-{len([k for k in self._controls.keys() if k.startswith('colorbar')])}\"\n    )\n\n    js_kwargs: Dict[str, Any] = {\n        \"colormap\": colormap,\n        \"vmin\": vmin,\n        \"vmax\": vmax,\n        \"label\": label,\n        \"units\": units,\n        \"orientation\": orientation,\n        \"position\": position,\n        \"colorbarId\": cbar_id,\n        **kwargs,\n    }\n    if bar_thickness is not None:\n        js_kwargs[\"barThickness\"] = bar_thickness\n    if bar_length is not None:\n        js_kwargs[\"barLength\"] = bar_length\n    if ticks is not None:\n        js_kwargs[\"ticks\"] = ticks\n    if opacity is not None:\n        js_kwargs[\"opacity\"] = opacity\n\n    self.call_js_method(\"addColorbar\", **js_kwargs)\n\n    self._controls = {\n        **self._controls,\n        cbar_id: {\n            \"type\": \"colorbar\",\n            \"colormap\": colormap,\n            \"vmin\": vmin,\n            \"vmax\": vmax,\n            \"label\": label,\n            \"units\": units,\n            \"orientation\": orientation,\n            \"position\": position,\n        },\n    }\n</code></pre>"},{"location":"maplibre/#anymap_ts.maplibre.MapLibreMap.add_column_layer","title":"<code>add_column_layer(self, data, name=None, get_position='coordinates', get_fill_color=None, get_line_color=None, get_elevation=1000, radius=1000, disk_resolution=20, elevation_scale=1, coverage=1, extruded=True, filled=True, stroked=False, wireframe=False, pickable=True, opacity=0.8, **kwargs)</code>","text":"<p>Add a column layer for 3D bar chart visualization using deck.gl.</p> <p>Column layers render cylindrical columns at specified positions, ideal for 3D bar charts on a map.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>Array of data objects with position coordinates.</p> required <code>name</code> <code>Optional[str]</code> <p>Layer ID. If None, auto-generated.</p> <code>None</code> <code>get_position</code> <code>Union[str, Any]</code> <p>Accessor for column position [lng, lat].</p> <code>'coordinates'</code> <code>get_fill_color</code> <code>Optional[Union[List[int], str]]</code> <p>Accessor for fill color [r, g, b, a].</p> <code>None</code> <code>get_line_color</code> <code>Optional[Union[List[int], str]]</code> <p>Accessor for stroke color [r, g, b, a].</p> <code>None</code> <code>get_elevation</code> <code>Union[float, str]</code> <p>Accessor for column height.</p> <code>1000</code> <code>radius</code> <code>float</code> <p>Column radius in meters.</p> <code>1000</code> <code>disk_resolution</code> <code>int</code> <p>Number of sides for column polygon.</p> <code>20</code> <code>elevation_scale</code> <code>float</code> <p>Elevation multiplier.</p> <code>1</code> <code>coverage</code> <code>float</code> <p>Column coverage (0-1).</p> <code>1</code> <code>extruded</code> <code>bool</code> <p>Whether to extrude columns.</p> <code>True</code> <code>filled</code> <code>bool</code> <p>Whether to fill columns.</p> <code>True</code> <code>stroked</code> <code>bool</code> <p>Whether to stroke columns.</p> <code>False</code> <code>wireframe</code> <code>bool</code> <p>Whether to render as wireframe.</p> <code>False</code> <code>pickable</code> <code>bool</code> <p>Whether layer responds to hover/click events.</p> <code>True</code> <code>opacity</code> <code>float</code> <p>Layer opacity (0-1).</p> <code>0.8</code> <code>**kwargs</code> <p>Additional ColumnLayer props.</p> <code>{}</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from anymap_ts import MapLibreMap\n&gt;&gt;&gt; m = MapLibreMap(pitch=45)\n&gt;&gt;&gt; data = [\n...     {\"coordinates\": [-122.4, 37.8], \"value\": 500},\n...     {\"coordinates\": [-122.5, 37.7], \"value\": 1000},\n... ]\n&gt;&gt;&gt; m.add_column_layer(data, get_elevation=\"value\", radius=500)\n</code></pre> Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def add_column_layer(\n    self,\n    data: Any,\n    name: Optional[str] = None,\n    get_position: Union[str, Any] = \"coordinates\",\n    get_fill_color: Optional[Union[List[int], str]] = None,\n    get_line_color: Optional[Union[List[int], str]] = None,\n    get_elevation: Union[float, str] = 1000,\n    radius: float = 1000,\n    disk_resolution: int = 20,\n    elevation_scale: float = 1,\n    coverage: float = 1,\n    extruded: bool = True,\n    filled: bool = True,\n    stroked: bool = False,\n    wireframe: bool = False,\n    pickable: bool = True,\n    opacity: float = 0.8,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a column layer for 3D bar chart visualization using deck.gl.\n\n    Column layers render cylindrical columns at specified positions,\n    ideal for 3D bar charts on a map.\n\n    Args:\n        data: Array of data objects with position coordinates.\n        name: Layer ID. If None, auto-generated.\n        get_position: Accessor for column position [lng, lat].\n        get_fill_color: Accessor for fill color [r, g, b, a].\n        get_line_color: Accessor for stroke color [r, g, b, a].\n        get_elevation: Accessor for column height.\n        radius: Column radius in meters.\n        disk_resolution: Number of sides for column polygon.\n        elevation_scale: Elevation multiplier.\n        coverage: Column coverage (0-1).\n        extruded: Whether to extrude columns.\n        filled: Whether to fill columns.\n        stroked: Whether to stroke columns.\n        wireframe: Whether to render as wireframe.\n        pickable: Whether layer responds to hover/click events.\n        opacity: Layer opacity (0-1).\n        **kwargs: Additional ColumnLayer props.\n\n    Example:\n        &gt;&gt;&gt; from anymap_ts import MapLibreMap\n        &gt;&gt;&gt; m = MapLibreMap(pitch=45)\n        &gt;&gt;&gt; data = [\n        ...     {\"coordinates\": [-122.4, 37.8], \"value\": 500},\n        ...     {\"coordinates\": [-122.5, 37.7], \"value\": 1000},\n        ... ]\n        &gt;&gt;&gt; m.add_column_layer(data, get_elevation=\"value\", radius=500)\n    \"\"\"\n    layer_id = name or f\"column-{len(self._layers)}\"\n    processed_data = self._process_deck_data(data)\n\n    self.call_js_method(\n        \"addColumnLayer\",\n        id=layer_id,\n        data=processed_data,\n        getPosition=get_position,\n        getFillColor=get_fill_color or [255, 140, 0, 200],\n        getLineColor=get_line_color or [0, 0, 0, 255],\n        getElevation=get_elevation,\n        radius=radius,\n        diskResolution=disk_resolution,\n        elevationScale=elevation_scale,\n        coverage=coverage,\n        extruded=extruded,\n        filled=filled,\n        stroked=stroked,\n        wireframe=wireframe,\n        pickable=pickable,\n        opacity=opacity,\n        **kwargs,\n    )\n\n    self._layers = {\n        **self._layers,\n        layer_id: {\"id\": layer_id, \"type\": \"column\"},\n    }\n    self._add_to_layer_dict(layer_id, \"Deck.gl\")\n</code></pre>"},{"location":"maplibre/#anymap_ts.maplibre.MapLibreMap.add_contour_layer","title":"<code>add_contour_layer(self, data, name=None, get_position='coordinates', get_weight=1, cell_size=200, contours=None, pickable=True, opacity=1, **kwargs)</code>","text":"<p>Add a contour layer for isoline/isoband generation using deck.gl.</p> <p>Contour layers aggregate point data and generate isolines or isobands, ideal for density visualization and topographic-style maps.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>Array of data objects with position coordinates.</p> required <code>name</code> <code>Optional[str]</code> <p>Layer ID. If None, auto-generated.</p> <code>None</code> <code>get_position</code> <code>Union[str, Any]</code> <p>Accessor for point position [lng, lat].</p> <code>'coordinates'</code> <code>get_weight</code> <code>Union[float, str]</code> <p>Accessor for point weight value.</p> <code>1</code> <code>cell_size</code> <code>float</code> <p>Grid cell size for aggregation in meters.</p> <code>200</code> <code>contours</code> <code>Optional[List[Dict]]</code> <p>Contour definitions [{threshold, color, strokeWidth}, ...].</p> <code>None</code> <code>pickable</code> <code>bool</code> <p>Whether layer responds to hover/click events.</p> <code>True</code> <code>opacity</code> <code>float</code> <p>Layer opacity (0-1).</p> <code>1</code> <code>**kwargs</code> <p>Additional ContourLayer props.</p> <code>{}</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from anymap_ts import MapLibreMap\n&gt;&gt;&gt; m = MapLibreMap()\n&gt;&gt;&gt; points = [\n...     {\"coordinates\": [-122.4, 37.8], \"weight\": 5},\n...     {\"coordinates\": [-122.41, 37.81], \"weight\": 10},\n... ]\n&gt;&gt;&gt; m.add_contour_layer(points, contours=[\n...     {\"threshold\": 1, \"color\": [255, 255, 178], \"strokeWidth\": 1},\n...     {\"threshold\": 5, \"color\": [253, 141, 60], \"strokeWidth\": 2},\n... ])\n</code></pre> Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def add_contour_layer(\n    self,\n    data: Any,\n    name: Optional[str] = None,\n    get_position: Union[str, Any] = \"coordinates\",\n    get_weight: Union[float, str] = 1,\n    cell_size: float = 200,\n    contours: Optional[List[Dict]] = None,\n    pickable: bool = True,\n    opacity: float = 1,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a contour layer for isoline/isoband generation using deck.gl.\n\n    Contour layers aggregate point data and generate isolines or isobands,\n    ideal for density visualization and topographic-style maps.\n\n    Args:\n        data: Array of data objects with position coordinates.\n        name: Layer ID. If None, auto-generated.\n        get_position: Accessor for point position [lng, lat].\n        get_weight: Accessor for point weight value.\n        cell_size: Grid cell size for aggregation in meters.\n        contours: Contour definitions [{threshold, color, strokeWidth}, ...].\n        pickable: Whether layer responds to hover/click events.\n        opacity: Layer opacity (0-1).\n        **kwargs: Additional ContourLayer props.\n\n    Example:\n        &gt;&gt;&gt; from anymap_ts import MapLibreMap\n        &gt;&gt;&gt; m = MapLibreMap()\n        &gt;&gt;&gt; points = [\n        ...     {\"coordinates\": [-122.4, 37.8], \"weight\": 5},\n        ...     {\"coordinates\": [-122.41, 37.81], \"weight\": 10},\n        ... ]\n        &gt;&gt;&gt; m.add_contour_layer(points, contours=[\n        ...     {\"threshold\": 1, \"color\": [255, 255, 178], \"strokeWidth\": 1},\n        ...     {\"threshold\": 5, \"color\": [253, 141, 60], \"strokeWidth\": 2},\n        ... ])\n    \"\"\"\n    layer_id = name or f\"contour-{len(self._layers)}\"\n    processed_data = self._process_deck_data(data)\n\n    default_contours = [\n        {\"threshold\": 1, \"color\": [255, 255, 255], \"strokeWidth\": 1},\n        {\"threshold\": 5, \"color\": [51, 136, 255], \"strokeWidth\": 2},\n        {\"threshold\": 10, \"color\": [0, 0, 255], \"strokeWidth\": 3},\n    ]\n\n    self.call_js_method(\n        \"addContourLayer\",\n        id=layer_id,\n        data=processed_data,\n        getPosition=get_position,\n        getWeight=get_weight,\n        cellSize=cell_size,\n        contours=contours or default_contours,\n        pickable=pickable,\n        opacity=opacity,\n        **kwargs,\n    )\n\n    self._layers = {\n        **self._layers,\n        layer_id: {\n            \"id\": layer_id,\n            \"type\": \"contour\",\n        },\n    }\n    self._add_to_layer_dict(layer_id, \"Deck.gl\")\n</code></pre>"},{"location":"maplibre/#anymap_ts.maplibre.MapLibreMap.add_control","title":"<code>add_control(self, control_type, position='top-right', **kwargs)</code>","text":"<p>Add a map control.</p> <p>Parameters:</p> Name Type Description Default <code>control_type</code> <code>str</code> <p>Type of control ('navigation', 'scale', 'fullscreen', etc.)</p> required <code>position</code> <code>str</code> <p>Control position</p> <code>'top-right'</code> <code>**kwargs</code> <p>Control-specific options</p> <code>{}</code> Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def add_control(\n    self,\n    control_type: str,\n    position: str = \"top-right\",\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a map control.\n\n    Args:\n        control_type: Type of control ('navigation', 'scale', 'fullscreen', etc.)\n        position: Control position\n        **kwargs: Control-specific options\n    \"\"\"\n    self.call_js_method(\"addControl\", control_type, position=position, **kwargs)\n    self._controls = {\n        **self._controls,\n        control_type: {\"type\": control_type, \"position\": position, **kwargs},\n    }\n</code></pre>"},{"location":"maplibre/#anymap_ts.maplibre.MapLibreMap.add_control_grid","title":"<code>add_control_grid(self, position='top-right', default_controls=None, exclude=None, rows=None, columns=None, collapsed=True, collapsible=True, title='', show_row_column_controls=True, gap=2, basemap_style_url=None, exclude_layers=None, **kwargs)</code>","text":"<p>Add a ControlGrid with all default tools or a custom subset.</p> <p>The ControlGrid provides a collapsible toolbar with up to 26 built-in controls (search, basemap, terrain, measure, draw, etc.) in a configurable grid layout.</p> <p>Parameters:</p> Name Type Description Default <code>position</code> <code>str</code> <p>Control position ('top-left', 'top-right', 'bottom-left', 'bottom-right').</p> <code>'top-right'</code> <code>default_controls</code> <code>Optional[List[str]]</code> <p>Explicit list of control names to include. If None, all 26 default controls are used (minus any in <code>exclude</code>). Valid names: 'globe', 'fullscreen', 'north', 'terrain', 'search', 'viewState', 'inspect', 'vectorDataset', 'basemap', 'measure', 'geoEditor', 'bookmark', 'print', 'minimap', 'swipe', 'streetView', 'addVector', 'cogLayer', 'zarrLayer', 'pmtilesLayer', 'stacLayer', 'stacSearch', 'planetaryComputer', 'gaussianSplat', 'lidar', 'usgsLidar'.</p> <code>None</code> <code>exclude</code> <code>Optional[List[str]]</code> <p>Controls to remove from the default set. Ignored when <code>default_controls</code> is provided.</p> <code>None</code> <code>rows</code> <code>Optional[int]</code> <p>Number of grid rows (auto-calculated if None).</p> <code>None</code> <code>columns</code> <code>Optional[int]</code> <p>Number of grid columns (auto-calculated if None).</p> <code>None</code> <code>collapsed</code> <code>bool</code> <p>Whether the grid starts collapsed. Default True.</p> <code>True</code> <code>collapsible</code> <code>bool</code> <p>Whether the grid can be collapsed. Default True.</p> <code>True</code> <code>title</code> <code>str</code> <p>Optional header title for the grid.</p> <code>''</code> <code>show_row_column_controls</code> <code>bool</code> <p>Show row/column input fields. Default True.</p> <code>True</code> <code>gap</code> <code>int</code> <p>Gap between grid cells in pixels. Default 2.</p> <code>2</code> <code>basemap_style_url</code> <code>Optional[str]</code> <p>Basemap style URL for SwipeControl layer grouping. If None, the current map style is used automatically.</p> <code>None</code> <code>exclude_layers</code> <code>Optional[List[str]]</code> <p>Layer ID patterns to exclude from SwipeControl (e.g., 'measure-', 'gl-draw-'). If None, sensible defaults are applied.</p> <code>None</code> <code>**kwargs</code> <p>Additional ControlGrid options.</p> <code>{}</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from anymap_ts import MapLibreMap\n&gt;&gt;&gt; m = MapLibreMap()\n&gt;&gt;&gt; m.add_control_grid()  # All 26 controls\n&gt;&gt;&gt; # Or with customization:\n&gt;&gt;&gt; m.add_control_grid(\n...     exclude=[\"minimap\", \"streetView\"],\n...     collapsed=True,\n... )\n</code></pre> Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def add_control_grid(\n    self,\n    position: str = \"top-right\",\n    default_controls: Optional[List[str]] = None,\n    exclude: Optional[List[str]] = None,\n    rows: Optional[int] = None,\n    columns: Optional[int] = None,\n    collapsed: bool = True,\n    collapsible: bool = True,\n    title: str = \"\",\n    show_row_column_controls: bool = True,\n    gap: int = 2,\n    basemap_style_url: Optional[str] = None,\n    exclude_layers: Optional[List[str]] = None,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a ControlGrid with all default tools or a custom subset.\n\n    The ControlGrid provides a collapsible toolbar with up to 26 built-in\n    controls (search, basemap, terrain, measure, draw, etc.) in a\n    configurable grid layout.\n\n    Args:\n        position: Control position ('top-left', 'top-right', 'bottom-left',\n            'bottom-right').\n        default_controls: Explicit list of control names to include. If None,\n            all 26 default controls are used (minus any in ``exclude``).\n            Valid names: 'globe', 'fullscreen', 'north', 'terrain', 'search',\n            'viewState', 'inspect', 'vectorDataset', 'basemap', 'measure',\n            'geoEditor', 'bookmark', 'print', 'minimap', 'swipe',\n            'streetView', 'addVector', 'cogLayer', 'zarrLayer',\n            'pmtilesLayer', 'stacLayer', 'stacSearch', 'planetaryComputer',\n            'gaussianSplat', 'lidar', 'usgsLidar'.\n        exclude: Controls to remove from the default set. Ignored when\n            ``default_controls`` is provided.\n        rows: Number of grid rows (auto-calculated if None).\n        columns: Number of grid columns (auto-calculated if None).\n        collapsed: Whether the grid starts collapsed. Default True.\n        collapsible: Whether the grid can be collapsed. Default True.\n        title: Optional header title for the grid.\n        show_row_column_controls: Show row/column input fields. Default True.\n        gap: Gap between grid cells in pixels. Default 2.\n        basemap_style_url: Basemap style URL for SwipeControl layer grouping.\n            If None, the current map style is used automatically.\n        exclude_layers: Layer ID patterns to exclude from SwipeControl\n            (e.g., 'measure-*', 'gl-draw-*'). If None, sensible defaults\n            are applied.\n        **kwargs: Additional ControlGrid options.\n\n    Example:\n        &gt;&gt;&gt; from anymap_ts import MapLibreMap\n        &gt;&gt;&gt; m = MapLibreMap()\n        &gt;&gt;&gt; m.add_control_grid()  # All 26 controls\n        &gt;&gt;&gt; # Or with customization:\n        &gt;&gt;&gt; m.add_control_grid(\n        ...     exclude=[\"minimap\", \"streetView\"],\n        ...     collapsed=True,\n        ... )\n    \"\"\"\n    js_kwargs: Dict[str, Any] = {\n        \"position\": position,\n        \"collapsed\": collapsed,\n        \"collapsible\": collapsible,\n        \"showRowColumnControls\": show_row_column_controls,\n        \"gap\": gap,\n        **kwargs,\n    }\n    if default_controls is not None:\n        js_kwargs[\"defaultControls\"] = default_controls\n    if exclude is not None:\n        js_kwargs[\"exclude\"] = exclude\n    if rows is not None:\n        js_kwargs[\"rows\"] = rows\n    if columns is not None:\n        js_kwargs[\"columns\"] = columns\n    if title:\n        js_kwargs[\"title\"] = title\n    if basemap_style_url is not None:\n        js_kwargs[\"basemapStyleUrl\"] = basemap_style_url\n    if exclude_layers is not None:\n        js_kwargs[\"excludeLayers\"] = exclude_layers\n\n    self.call_js_method(\"addControlGrid\", **js_kwargs)\n    # Save full config for HTML export\n    control_config = {\n        \"position\": position,\n        \"collapsed\": collapsed,\n        \"collapsible\": collapsible,\n    }\n    if default_controls is not None:\n        control_config[\"defaultControls\"] = default_controls\n    if exclude is not None:\n        control_config[\"exclude\"] = exclude\n    if rows is not None:\n        control_config[\"rows\"] = rows\n    if columns is not None:\n        control_config[\"columns\"] = columns\n    self._controls = {\n        **self._controls,\n        \"control-grid\": control_config,\n    }\n</code></pre>"},{"location":"maplibre/#anymap_ts.maplibre.MapLibreMap.add_coordinates_control","title":"<code>add_coordinates_control(self, position='bottom-left', precision=4)</code>","text":"<p>Add a coordinates display showing cursor lat/lng.</p> <p>Parameters:</p> Name Type Description Default <code>position</code> <code>str</code> <p>Control position ('top-left', 'top-right', 'bottom-left', 'bottom-right').</p> <code>'bottom-left'</code> <code>precision</code> <code>int</code> <p>Number of decimal places for coordinates.</p> <code>4</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; m = MapLibreMap()\n&gt;&gt;&gt; m.add_coordinates_control(position=\"bottom-left\", precision=6)\n</code></pre> Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def add_coordinates_control(\n    self,\n    position: str = \"bottom-left\",\n    precision: int = 4,\n) -&gt; None:\n    \"\"\"Add a coordinates display showing cursor lat/lng.\n\n    Args:\n        position: Control position ('top-left', 'top-right',\n            'bottom-left', 'bottom-right').\n        precision: Number of decimal places for coordinates.\n\n    Example:\n        &gt;&gt;&gt; m = MapLibreMap()\n        &gt;&gt;&gt; m.add_coordinates_control(position=\"bottom-left\", precision=6)\n    \"\"\"\n    self.call_js_method(\n        \"addCoordinatesControl\",\n        position=position,\n        precision=precision,\n    )\n</code></pre>"},{"location":"maplibre/#anymap_ts.maplibre.MapLibreMap.add_deck_heatmap_layer","title":"<code>add_deck_heatmap_layer(self, data, name=None, get_position='coordinates', get_weight=1, radius_pixels=30, intensity=1, threshold=0.05, color_range=None, opacity=1, **kwargs)</code>","text":"<p>Add a GPU-accelerated heatmap layer using deck.gl.</p> <p>This is an alternative to the native MapLibre heatmap layer, using deck.gl's GPU-based rendering for better performance with large datasets.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>Array of data objects with position coordinates.</p> required <code>name</code> <code>Optional[str]</code> <p>Layer ID. If None, auto-generated.</p> <code>None</code> <code>get_position</code> <code>Union[str, Any]</code> <p>Accessor for point position [lng, lat].</p> <code>'coordinates'</code> <code>get_weight</code> <code>Union[float, str]</code> <p>Accessor for point weight value.</p> <code>1</code> <code>radius_pixels</code> <code>float</code> <p>Influence radius in pixels.</p> <code>30</code> <code>intensity</code> <code>float</code> <p>Intensity multiplier.</p> <code>1</code> <code>threshold</code> <code>float</code> <p>Minimum density threshold (0-1).</p> <code>0.05</code> <code>color_range</code> <code>Optional[List[List[int]]]</code> <p>Color gradient [[r, g, b, a], ...].</p> <code>None</code> <code>opacity</code> <code>float</code> <p>Layer opacity (0-1).</p> <code>1</code> <code>**kwargs</code> <p>Additional HeatmapLayer props.</p> <code>{}</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from anymap_ts import MapLibreMap\n&gt;&gt;&gt; m = MapLibreMap()\n&gt;&gt;&gt; points = [\n...     {\"coordinates\": [-122.4, 37.8], \"weight\": 5},\n...     {\"coordinates\": [-122.5, 37.7], \"weight\": 10},\n... ]\n&gt;&gt;&gt; m.add_deck_heatmap_layer(points, get_weight=\"weight\")\n</code></pre> Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def add_deck_heatmap_layer(\n    self,\n    data: Any,\n    name: Optional[str] = None,\n    get_position: Union[str, Any] = \"coordinates\",\n    get_weight: Union[float, str] = 1,\n    radius_pixels: float = 30,\n    intensity: float = 1,\n    threshold: float = 0.05,\n    color_range: Optional[List[List[int]]] = None,\n    opacity: float = 1,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a GPU-accelerated heatmap layer using deck.gl.\n\n    This is an alternative to the native MapLibre heatmap layer, using\n    deck.gl's GPU-based rendering for better performance with large datasets.\n\n    Args:\n        data: Array of data objects with position coordinates.\n        name: Layer ID. If None, auto-generated.\n        get_position: Accessor for point position [lng, lat].\n        get_weight: Accessor for point weight value.\n        radius_pixels: Influence radius in pixels.\n        intensity: Intensity multiplier.\n        threshold: Minimum density threshold (0-1).\n        color_range: Color gradient [[r, g, b, a], ...].\n        opacity: Layer opacity (0-1).\n        **kwargs: Additional HeatmapLayer props.\n\n    Example:\n        &gt;&gt;&gt; from anymap_ts import MapLibreMap\n        &gt;&gt;&gt; m = MapLibreMap()\n        &gt;&gt;&gt; points = [\n        ...     {\"coordinates\": [-122.4, 37.8], \"weight\": 5},\n        ...     {\"coordinates\": [-122.5, 37.7], \"weight\": 10},\n        ... ]\n        &gt;&gt;&gt; m.add_deck_heatmap_layer(points, get_weight=\"weight\")\n    \"\"\"\n    layer_id = name or f\"deck-heatmap-{len(self._layers)}\"\n    processed_data = self._process_deck_data(data)\n\n    default_color_range = [\n        [255, 255, 178, 25],\n        [254, 217, 118, 85],\n        [254, 178, 76, 127],\n        [253, 141, 60, 170],\n        [240, 59, 32, 212],\n        [189, 0, 38, 255],\n    ]\n\n    self.call_js_method(\n        \"addHeatmapLayer\",\n        id=layer_id,\n        data=processed_data,\n        getPosition=get_position,\n        getWeight=get_weight,\n        radiusPixels=radius_pixels,\n        intensity=intensity,\n        threshold=threshold,\n        colorRange=color_range or default_color_range,\n        opacity=opacity,\n        **kwargs,\n    )\n\n    self._layers = {\n        **self._layers,\n        layer_id: {\n            \"id\": layer_id,\n            \"type\": \"deck-heatmap\",\n        },\n    }\n    self._add_to_layer_dict(layer_id, \"Deck.gl\")\n</code></pre>"},{"location":"maplibre/#anymap_ts.maplibre.MapLibreMap.add_deckgl_layer","title":"<code>add_deckgl_layer(self, layer_type, data, name=None, **kwargs)</code>","text":"<p>Add a generic deck.gl layer to the map.</p> <p>This method provides a flexible way to add any supported deck.gl layer type using a single interface. For commonly used layers, prefer the specific methods (e.g., add_scatterplot_layer) for better IDE support.</p> <p>Parameters:</p> Name Type Description Default <code>layer_type</code> <code>str</code> <p>The deck.gl layer type (e.g., 'ScatterplotLayer', 'ArcLayer', 'HexagonLayer').</p> required <code>data</code> <code>Any</code> <p>Array of data objects or GeoJSON.</p> required <code>name</code> <code>Optional[str]</code> <p>Layer ID. If None, auto-generated from layer_type.</p> <code>None</code> <code>**kwargs</code> <p>Layer-specific properties passed directly to deck.gl.</p> <code>{}</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from anymap_ts import MapLibreMap\n&gt;&gt;&gt; m = MapLibreMap()\n&gt;&gt;&gt; m.add_deckgl_layer(\n...     \"TripsLayer\",\n...     data=trips_data,\n...     getPath=\"waypoints\",\n...     getTimestamps=\"timestamps\",\n...     trailLength=180,\n... )\n</code></pre> Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def add_deckgl_layer(\n    self,\n    layer_type: str,\n    data: Any,\n    name: Optional[str] = None,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a generic deck.gl layer to the map.\n\n    This method provides a flexible way to add any supported deck.gl layer\n    type using a single interface. For commonly used layers, prefer the\n    specific methods (e.g., add_scatterplot_layer) for better IDE support.\n\n    Args:\n        layer_type: The deck.gl layer type (e.g., 'ScatterplotLayer',\n            'ArcLayer', 'HexagonLayer').\n        data: Array of data objects or GeoJSON.\n        name: Layer ID. If None, auto-generated from layer_type.\n        **kwargs: Layer-specific properties passed directly to deck.gl.\n\n    Example:\n        &gt;&gt;&gt; from anymap_ts import MapLibreMap\n        &gt;&gt;&gt; m = MapLibreMap()\n        &gt;&gt;&gt; m.add_deckgl_layer(\n        ...     \"TripsLayer\",\n        ...     data=trips_data,\n        ...     getPath=\"waypoints\",\n        ...     getTimestamps=\"timestamps\",\n        ...     trailLength=180,\n        ... )\n    \"\"\"\n    layer_type_clean = layer_type.replace(\"Layer\", \"\")\n    prefix = layer_type_clean.lower()\n    layer_id = name or f\"{prefix}-{len(self._layers)}\"\n    processed_data = self._process_deck_data(data)\n\n    self.call_js_method(\n        \"addDeckGLLayer\",\n        layerType=layer_type,\n        id=layer_id,\n        data=processed_data,\n        **kwargs,\n    )\n\n    self._layers = {\n        **self._layers,\n        layer_id: {\n            \"id\": layer_id,\n            \"type\": layer_type,\n        },\n    }\n    self._add_to_layer_dict(layer_id, \"Deck.gl\")\n</code></pre>"},{"location":"maplibre/#anymap_ts.maplibre.MapLibreMap.add_draw_control","title":"<code>add_draw_control(self, position='top-right', draw_modes=None, edit_modes=None, collapsed=False, **kwargs)</code>","text":"<p>Add a drawing control using maplibre-gl-geo-editor.</p> <p>Parameters:</p> Name Type Description Default <code>position</code> <code>str</code> <p>Control position</p> <code>'top-right'</code> <code>draw_modes</code> <code>Optional[List[str]]</code> <p>Drawing modes to enable (e.g., ['polygon', 'line', 'marker'])</p> <code>None</code> <code>edit_modes</code> <code>Optional[List[str]]</code> <p>Edit modes to enable (e.g., ['select', 'drag', 'delete'])</p> <code>None</code> <code>collapsed</code> <code>bool</code> <p>Whether control starts collapsed</p> <code>False</code> <code>**kwargs</code> <p>Additional geo-editor options</p> <code>{}</code> Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def add_draw_control(\n    self,\n    position: str = \"top-right\",\n    draw_modes: Optional[List[str]] = None,\n    edit_modes: Optional[List[str]] = None,\n    collapsed: bool = False,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a drawing control using maplibre-gl-geo-editor.\n\n    Args:\n        position: Control position\n        draw_modes: Drawing modes to enable (e.g., ['polygon', 'line', 'marker'])\n        edit_modes: Edit modes to enable (e.g., ['select', 'drag', 'delete'])\n        collapsed: Whether control starts collapsed\n        **kwargs: Additional geo-editor options\n    \"\"\"\n    if draw_modes is None:\n        draw_modes = [\"polygon\", \"line\", \"rectangle\", \"circle\", \"marker\"]\n    if edit_modes is None:\n        edit_modes = [\"select\", \"drag\", \"change\", \"rotate\", \"delete\"]\n\n    self.call_js_method(\n        \"addDrawControl\",\n        position=position,\n        drawModes=draw_modes,\n        editModes=edit_modes,\n        collapsed=collapsed,\n        **kwargs,\n    )\n    self._controls = {\n        **self._controls,\n        \"draw-control\": {\n            \"position\": position,\n            \"drawModes\": draw_modes,\n            \"editModes\": edit_modes,\n        },\n    }\n</code></pre>"},{"location":"maplibre/#anymap_ts.maplibre.MapLibreMap.add_flatgeobuf","title":"<code>add_flatgeobuf(self, url, name=None, layer_type=None, paint=None, fit_bounds=True, **kwargs)</code>","text":"<p>Add a FlatGeobuf layer from a URL.</p> <p>Streams and renders cloud-native FlatGeobuf vector data directly in the browser without downloading the entire file.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>URL to the FlatGeobuf file.</p> required <code>name</code> <code>Optional[str]</code> <p>Layer name. If None, auto-generated.</p> <code>None</code> <code>layer_type</code> <code>Optional[str]</code> <p>MapLibre layer type ('circle', 'line', 'fill'). If None, inferred from geometry type.</p> <code>None</code> <code>paint</code> <code>Optional[Dict]</code> <p>MapLibre paint properties. If None, defaults are used.</p> <code>None</code> <code>fit_bounds</code> <code>bool</code> <p>Whether to fit map to data bounds.</p> <code>True</code> <code>**kwargs</code> <p>Additional layer options.</p> <code>{}</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; m = Map()\n&gt;&gt;&gt; m.add_flatgeobuf(\n...     \"https://flatgeobuf.org/test/data/UScounties.fgb\",\n...     name=\"counties\",\n...     paint={\"fill-color\": \"#088\", \"fill-opacity\": 0.5},\n... )\n</code></pre> Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def add_flatgeobuf(\n    self,\n    url: str,\n    name: Optional[str] = None,\n    layer_type: Optional[str] = None,\n    paint: Optional[Dict] = None,\n    fit_bounds: bool = True,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a FlatGeobuf layer from a URL.\n\n    Streams and renders cloud-native FlatGeobuf vector data directly\n    in the browser without downloading the entire file.\n\n    Args:\n        url: URL to the FlatGeobuf file.\n        name: Layer name. If None, auto-generated.\n        layer_type: MapLibre layer type ('circle', 'line', 'fill').\n            If None, inferred from geometry type.\n        paint: MapLibre paint properties. If None, defaults are used.\n        fit_bounds: Whether to fit map to data bounds.\n        **kwargs: Additional layer options.\n\n    Example:\n        &gt;&gt;&gt; m = Map()\n        &gt;&gt;&gt; m.add_flatgeobuf(\n        ...     \"https://flatgeobuf.org/test/data/UScounties.fgb\",\n        ...     name=\"counties\",\n        ...     paint={\"fill-color\": \"#088\", \"fill-opacity\": 0.5},\n        ... )\n    \"\"\"\n    layer_id = name or f\"flatgeobuf-{len(self._layers)}\"\n\n    self.call_js_method(\n        \"addFlatGeobuf\",\n        url=url,\n        name=layer_id,\n        layerType=layer_type,\n        paint=paint,\n        fitBounds=fit_bounds,\n        **kwargs,\n    )\n\n    self._layers = {\n        **self._layers,\n        layer_id: {\n            \"id\": layer_id,\n            \"type\": \"flatgeobuf\",\n            \"url\": url,\n        },\n    }\n    self._add_to_layer_dict(layer_id, \"Vector\")\n</code></pre>"},{"location":"maplibre/#anymap_ts.maplibre.MapLibreMap.add_geojson","title":"<code>add_geojson(self, data, layer_type=None, paint=None, name=None, fit_bounds=True, **kwargs)</code>","text":"<p>Add GeoJSON data to the map.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Union[str, Dict]</code> <p>GeoJSON dict or URL to GeoJSON file</p> required <code>layer_type</code> <code>Optional[str]</code> <p>MapLibre layer type</p> <code>None</code> <code>paint</code> <code>Optional[Dict]</code> <p>MapLibre paint properties</p> <code>None</code> <code>name</code> <code>Optional[str]</code> <p>Layer name</p> <code>None</code> <code>fit_bounds</code> <code>bool</code> <p>Whether to fit map to data bounds</p> <code>True</code> <code>**kwargs</code> <p>Additional layer options</p> <code>{}</code> Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def add_geojson(\n    self,\n    data: Union[str, Dict],\n    layer_type: Optional[str] = None,\n    paint: Optional[Dict] = None,\n    name: Optional[str] = None,\n    fit_bounds: bool = True,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add GeoJSON data to the map.\n\n    Args:\n        data: GeoJSON dict or URL to GeoJSON file\n        layer_type: MapLibre layer type\n        paint: MapLibre paint properties\n        name: Layer name\n        fit_bounds: Whether to fit map to data bounds\n        **kwargs: Additional layer options\n    \"\"\"\n    self.add_vector(\n        data,\n        layer_type=layer_type,\n        paint=paint,\n        name=name,\n        fit_bounds=fit_bounds,\n        **kwargs,\n    )\n</code></pre>"},{"location":"maplibre/#anymap_ts.maplibre.MapLibreMap.add_geojson_layer","title":"<code>add_geojson_layer(self, data, name=None, get_fill_color=None, get_line_color=None, get_line_width=1, get_point_radius=5, get_elevation=0, extruded=False, wireframe=False, filled=True, stroked=True, line_width_min_pixels=1, point_radius_min_pixels=2, pickable=True, opacity=0.8, **kwargs)</code>","text":"<p>Add a GeoJSON layer with auto-styling using deck.gl.</p> <p>GeoJSON layers render GeoJSON features with automatic geometry type detection and styling, supporting points, lines, and polygons.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>GeoJSON object, URL, or file path.</p> required <code>name</code> <code>Optional[str]</code> <p>Layer ID. If None, auto-generated.</p> <code>None</code> <code>get_fill_color</code> <code>Optional[Union[List[int], str]]</code> <p>Accessor for fill color [r, g, b, a]. Default: [51, 136, 255, 128].</p> <code>None</code> <code>get_line_color</code> <code>Optional[Union[List[int], str]]</code> <p>Accessor for stroke color [r, g, b, a]. Default: [0, 0, 0, 255].</p> <code>None</code> <code>get_line_width</code> <code>Union[float, str]</code> <p>Accessor for stroke width.</p> <code>1</code> <code>get_point_radius</code> <code>Union[float, str]</code> <p>Accessor for point radius.</p> <code>5</code> <code>get_elevation</code> <code>Union[float, str]</code> <p>Accessor for 3D extrusion height.</p> <code>0</code> <code>extruded</code> <code>bool</code> <p>Whether to render as 3D features.</p> <code>False</code> <code>wireframe</code> <code>bool</code> <p>Whether to render wireframe (extruded only).</p> <code>False</code> <code>filled</code> <code>bool</code> <p>Whether to fill features.</p> <code>True</code> <code>stroked</code> <code>bool</code> <p>Whether to draw stroke.</p> <code>True</code> <code>line_width_min_pixels</code> <code>float</code> <p>Minimum stroke width in pixels.</p> <code>1</code> <code>point_radius_min_pixels</code> <code>float</code> <p>Minimum point radius in pixels.</p> <code>2</code> <code>pickable</code> <code>bool</code> <p>Whether layer responds to hover/click events.</p> <code>True</code> <code>opacity</code> <code>float</code> <p>Layer opacity (0-1).</p> <code>0.8</code> <code>**kwargs</code> <p>Additional GeoJsonLayer props.</p> <code>{}</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from anymap_ts import MapLibreMap\n&gt;&gt;&gt; m = MapLibreMap()\n&gt;&gt;&gt; m.add_geojson_layer(\n...     \"https://example.com/data.geojson\",\n...     get_fill_color=[255, 0, 0, 128],\n... )\n</code></pre> Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def add_geojson_layer(\n    self,\n    data: Any,\n    name: Optional[str] = None,\n    get_fill_color: Optional[Union[List[int], str]] = None,\n    get_line_color: Optional[Union[List[int], str]] = None,\n    get_line_width: Union[float, str] = 1,\n    get_point_radius: Union[float, str] = 5,\n    get_elevation: Union[float, str] = 0,\n    extruded: bool = False,\n    wireframe: bool = False,\n    filled: bool = True,\n    stroked: bool = True,\n    line_width_min_pixels: float = 1,\n    point_radius_min_pixels: float = 2,\n    pickable: bool = True,\n    opacity: float = 0.8,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a GeoJSON layer with auto-styling using deck.gl.\n\n    GeoJSON layers render GeoJSON features with automatic geometry type\n    detection and styling, supporting points, lines, and polygons.\n\n    Args:\n        data: GeoJSON object, URL, or file path.\n        name: Layer ID. If None, auto-generated.\n        get_fill_color: Accessor for fill color [r, g, b, a].\n            Default: [51, 136, 255, 128].\n        get_line_color: Accessor for stroke color [r, g, b, a].\n            Default: [0, 0, 0, 255].\n        get_line_width: Accessor for stroke width.\n        get_point_radius: Accessor for point radius.\n        get_elevation: Accessor for 3D extrusion height.\n        extruded: Whether to render as 3D features.\n        wireframe: Whether to render wireframe (extruded only).\n        filled: Whether to fill features.\n        stroked: Whether to draw stroke.\n        line_width_min_pixels: Minimum stroke width in pixels.\n        point_radius_min_pixels: Minimum point radius in pixels.\n        pickable: Whether layer responds to hover/click events.\n        opacity: Layer opacity (0-1).\n        **kwargs: Additional GeoJsonLayer props.\n\n    Example:\n        &gt;&gt;&gt; from anymap_ts import MapLibreMap\n        &gt;&gt;&gt; m = MapLibreMap()\n        &gt;&gt;&gt; m.add_geojson_layer(\n        ...     \"https://example.com/data.geojson\",\n        ...     get_fill_color=[255, 0, 0, 128],\n        ... )\n    \"\"\"\n    layer_id = name or f\"geojson-deck-{len(self._layers)}\"\n    processed_data = self._process_deck_data(data)\n\n    self.call_js_method(\n        \"addGeoJsonLayer\",\n        id=layer_id,\n        data=processed_data,\n        getFillColor=get_fill_color or [51, 136, 255, 128],\n        getLineColor=get_line_color or [0, 0, 0, 255],\n        getLineWidth=get_line_width,\n        getPointRadius=get_point_radius,\n        getElevation=get_elevation,\n        extruded=extruded,\n        wireframe=wireframe,\n        filled=filled,\n        stroked=stroked,\n        lineWidthMinPixels=line_width_min_pixels,\n        pointRadiusMinPixels=point_radius_min_pixels,\n        pickable=pickable,\n        opacity=opacity,\n        **kwargs,\n    )\n\n    self._layers = {\n        **self._layers,\n        layer_id: {\n            \"id\": layer_id,\n            \"type\": \"geojson-deck\",\n        },\n    }\n    self._add_to_layer_dict(layer_id, \"Deck.gl\")\n</code></pre>"},{"location":"maplibre/#anymap_ts.maplibre.MapLibreMap.add_grid_cell_layer","title":"<code>add_grid_cell_layer(self, data, name=None, get_position='coordinates', get_color=None, get_elevation=1000, cell_size=200, coverage=1, elevation_scale=1, extruded=True, pickable=True, opacity=0.8, **kwargs)</code>","text":"<p>Add a grid cell layer for pre-aggregated grid visualization using deck.gl.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>Array of data objects with position coordinates.</p> required <code>name</code> <code>Optional[str]</code> <p>Layer ID. If None, auto-generated.</p> <code>None</code> <code>get_position</code> <code>Union[str, Any]</code> <p>Accessor for cell position [lng, lat].</p> <code>'coordinates'</code> <code>get_color</code> <code>Optional[Union[List[int], str]]</code> <p>Accessor for cell color [r, g, b, a].</p> <code>None</code> <code>get_elevation</code> <code>Union[float, str]</code> <p>Accessor for cell height.</p> <code>1000</code> <code>cell_size</code> <code>float</code> <p>Cell size in meters.</p> <code>200</code> <code>coverage</code> <code>float</code> <p>Cell coverage (0-1).</p> <code>1</code> <code>elevation_scale</code> <code>float</code> <p>Elevation multiplier.</p> <code>1</code> <code>extruded</code> <code>bool</code> <p>Whether to extrude cells.</p> <code>True</code> <code>pickable</code> <code>bool</code> <p>Whether layer responds to hover/click events.</p> <code>True</code> <code>opacity</code> <code>float</code> <p>Layer opacity (0-1).</p> <code>0.8</code> <code>**kwargs</code> <p>Additional GridCellLayer props.</p> <code>{}</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from anymap_ts import MapLibreMap\n&gt;&gt;&gt; m = MapLibreMap(pitch=45)\n&gt;&gt;&gt; data = [\n...     {\"coordinates\": [-122.4, 37.8], \"value\": 500},\n... ]\n&gt;&gt;&gt; m.add_grid_cell_layer(data, get_elevation=\"value\")\n</code></pre> Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def add_grid_cell_layer(\n    self,\n    data: Any,\n    name: Optional[str] = None,\n    get_position: Union[str, Any] = \"coordinates\",\n    get_color: Optional[Union[List[int], str]] = None,\n    get_elevation: Union[float, str] = 1000,\n    cell_size: float = 200,\n    coverage: float = 1,\n    elevation_scale: float = 1,\n    extruded: bool = True,\n    pickable: bool = True,\n    opacity: float = 0.8,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a grid cell layer for pre-aggregated grid visualization using deck.gl.\n\n    Args:\n        data: Array of data objects with position coordinates.\n        name: Layer ID. If None, auto-generated.\n        get_position: Accessor for cell position [lng, lat].\n        get_color: Accessor for cell color [r, g, b, a].\n        get_elevation: Accessor for cell height.\n        cell_size: Cell size in meters.\n        coverage: Cell coverage (0-1).\n        elevation_scale: Elevation multiplier.\n        extruded: Whether to extrude cells.\n        pickable: Whether layer responds to hover/click events.\n        opacity: Layer opacity (0-1).\n        **kwargs: Additional GridCellLayer props.\n\n    Example:\n        &gt;&gt;&gt; from anymap_ts import MapLibreMap\n        &gt;&gt;&gt; m = MapLibreMap(pitch=45)\n        &gt;&gt;&gt; data = [\n        ...     {\"coordinates\": [-122.4, 37.8], \"value\": 500},\n        ... ]\n        &gt;&gt;&gt; m.add_grid_cell_layer(data, get_elevation=\"value\")\n    \"\"\"\n    layer_id = name or f\"gridcell-{len(self._layers)}\"\n    processed_data = self._process_deck_data(data)\n\n    self.call_js_method(\n        \"addGridCellLayer\",\n        id=layer_id,\n        data=processed_data,\n        getPosition=get_position,\n        getColor=get_color or [255, 140, 0, 200],\n        getElevation=get_elevation,\n        cellSize=cell_size,\n        coverage=coverage,\n        elevationScale=elevation_scale,\n        extruded=extruded,\n        pickable=pickable,\n        opacity=opacity,\n        **kwargs,\n    )\n\n    self._layers = {\n        **self._layers,\n        layer_id: {\"id\": layer_id, \"type\": \"gridcell\"},\n    }\n    self._add_to_layer_dict(layer_id, \"Deck.gl\")\n</code></pre>"},{"location":"maplibre/#anymap_ts.maplibre.MapLibreMap.add_grid_layer","title":"<code>add_grid_layer(self, data, name=None, get_position='coordinates', cell_size=200, elevation_scale=4, extruded=True, color_range=None, pickable=True, opacity=0.8, **kwargs)</code>","text":"<p>Add a grid layer for square grid aggregation using deck.gl.</p> <p>Grid layers aggregate points into square grid cells and render them with height and color based on point density.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>Array of data objects with position coordinates.</p> required <code>name</code> <code>Optional[str]</code> <p>Layer ID. If None, auto-generated.</p> <code>None</code> <code>get_position</code> <code>Union[str, Any]</code> <p>Accessor for point position [lng, lat].</p> <code>'coordinates'</code> <code>cell_size</code> <code>float</code> <p>Grid cell size in meters.</p> <code>200</code> <code>elevation_scale</code> <code>float</code> <p>Elevation multiplier for 3D cells.</p> <code>4</code> <code>extruded</code> <code>bool</code> <p>Whether to render as 3D cells.</p> <code>True</code> <code>color_range</code> <code>Optional[List[List[int]]]</code> <p>Color gradient [[r, g, b], ...].</p> <code>None</code> <code>pickable</code> <code>bool</code> <p>Whether layer responds to hover/click events.</p> <code>True</code> <code>opacity</code> <code>float</code> <p>Layer opacity (0-1).</p> <code>0.8</code> <code>**kwargs</code> <p>Additional GridLayer props.</p> <code>{}</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from anymap_ts import MapLibreMap\n&gt;&gt;&gt; m = MapLibreMap(pitch=45)\n&gt;&gt;&gt; points = [\n...     {\"coordinates\": [-122.4, 37.8]},\n...     {\"coordinates\": [-122.41, 37.81]},\n... ]\n&gt;&gt;&gt; m.add_grid_layer(points, cell_size=500)\n</code></pre> Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def add_grid_layer(\n    self,\n    data: Any,\n    name: Optional[str] = None,\n    get_position: Union[str, Any] = \"coordinates\",\n    cell_size: float = 200,\n    elevation_scale: float = 4,\n    extruded: bool = True,\n    color_range: Optional[List[List[int]]] = None,\n    pickable: bool = True,\n    opacity: float = 0.8,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a grid layer for square grid aggregation using deck.gl.\n\n    Grid layers aggregate points into square grid cells and render them\n    with height and color based on point density.\n\n    Args:\n        data: Array of data objects with position coordinates.\n        name: Layer ID. If None, auto-generated.\n        get_position: Accessor for point position [lng, lat].\n        cell_size: Grid cell size in meters.\n        elevation_scale: Elevation multiplier for 3D cells.\n        extruded: Whether to render as 3D cells.\n        color_range: Color gradient [[r, g, b], ...].\n        pickable: Whether layer responds to hover/click events.\n        opacity: Layer opacity (0-1).\n        **kwargs: Additional GridLayer props.\n\n    Example:\n        &gt;&gt;&gt; from anymap_ts import MapLibreMap\n        &gt;&gt;&gt; m = MapLibreMap(pitch=45)\n        &gt;&gt;&gt; points = [\n        ...     {\"coordinates\": [-122.4, 37.8]},\n        ...     {\"coordinates\": [-122.41, 37.81]},\n        ... ]\n        &gt;&gt;&gt; m.add_grid_layer(points, cell_size=500)\n    \"\"\"\n    layer_id = name or f\"grid-{len(self._layers)}\"\n    processed_data = self._process_deck_data(data)\n\n    default_color_range = [\n        [1, 152, 189],\n        [73, 227, 206],\n        [216, 254, 181],\n        [254, 237, 177],\n        [254, 173, 84],\n        [209, 55, 78],\n    ]\n\n    self.call_js_method(\n        \"addGridLayer\",\n        id=layer_id,\n        data=processed_data,\n        getPosition=get_position,\n        cellSize=cell_size,\n        elevationScale=elevation_scale,\n        extruded=extruded,\n        colorRange=color_range or default_color_range,\n        pickable=pickable,\n        opacity=opacity,\n        **kwargs,\n    )\n\n    self._layers = {\n        **self._layers,\n        layer_id: {\n            \"id\": layer_id,\n            \"type\": \"grid\",\n        },\n    }\n    self._add_to_layer_dict(layer_id, \"Deck.gl\")\n</code></pre>"},{"location":"maplibre/#anymap_ts.maplibre.MapLibreMap.add_heatmap","title":"<code>add_heatmap(self, data, weight_property=None, radius=20, intensity=1.0, colormap=None, opacity=0.8, name=None, fit_bounds=True, **kwargs)</code>","text":"<p>Add a heatmap layer to the map.</p> <p>Creates a heatmap visualization from point data using MapLibre's native heatmap layer type.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>Point data - can be GeoJSON, GeoDataFrame, or file path.</p> required <code>weight_property</code> <code>Optional[str]</code> <p>Property name to use for point weights. If None, all points have equal weight.</p> <code>None</code> <code>radius</code> <code>int</code> <p>Radius of influence for each point in pixels.</p> <code>20</code> <code>intensity</code> <code>float</code> <p>Intensity multiplier for the heatmap.</p> <code>1.0</code> <code>colormap</code> <code>Optional[List]</code> <p>Color gradient as list of [stop, color] pairs. Example: [[0, \"blue\"], [0.5, \"yellow\"], [1, \"red\"]] Default: blue-yellow-red gradient.</p> <code>None</code> <code>opacity</code> <code>float</code> <p>Layer opacity (0-1).</p> <code>0.8</code> <code>name</code> <code>Optional[str]</code> <p>Layer identifier. If None, auto-generated.</p> <code>None</code> <code>fit_bounds</code> <code>bool</code> <p>Whether to fit map to data bounds.</p> <code>True</code> <code>**kwargs</code> <p>Additional heatmap layer options.</p> <code>{}</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from anymap_ts import Map\n&gt;&gt;&gt; m = Map()\n&gt;&gt;&gt; m.add_heatmap(\n...     \"earthquakes.geojson\",\n...     weight_property=\"magnitude\",\n...     radius=30,\n...     colormap=[[0, \"blue\"], [0.5, \"lime\"], [1, \"red\"]]\n... )\n</code></pre> Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def add_heatmap(\n    self,\n    data: Any,\n    weight_property: Optional[str] = None,\n    radius: int = 20,\n    intensity: float = 1.0,\n    colormap: Optional[List] = None,\n    opacity: float = 0.8,\n    name: Optional[str] = None,\n    fit_bounds: bool = True,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a heatmap layer to the map.\n\n    Creates a heatmap visualization from point data using MapLibre's\n    native heatmap layer type.\n\n    Args:\n        data: Point data - can be GeoJSON, GeoDataFrame, or file path.\n        weight_property: Property name to use for point weights.\n            If None, all points have equal weight.\n        radius: Radius of influence for each point in pixels.\n        intensity: Intensity multiplier for the heatmap.\n        colormap: Color gradient as list of [stop, color] pairs.\n            Example: [[0, \"blue\"], [0.5, \"yellow\"], [1, \"red\"]]\n            Default: blue-yellow-red gradient.\n        opacity: Layer opacity (0-1).\n        name: Layer identifier. If None, auto-generated.\n        fit_bounds: Whether to fit map to data bounds.\n        **kwargs: Additional heatmap layer options.\n\n    Example:\n        &gt;&gt;&gt; from anymap_ts import Map\n        &gt;&gt;&gt; m = Map()\n        &gt;&gt;&gt; m.add_heatmap(\n        ...     \"earthquakes.geojson\",\n        ...     weight_property=\"magnitude\",\n        ...     radius=30,\n        ...     colormap=[[0, \"blue\"], [0.5, \"lime\"], [1, \"red\"]]\n        ... )\n    \"\"\"\n    self._validate_opacity(opacity)\n    layer_id = name or f\"heatmap-{len(self._layers)}\"\n\n    # Convert data to GeoJSON\n    geojson = to_geojson(data)\n\n    # Handle URL data - fetch GeoJSON\n    if geojson.get(\"type\") == \"url\":\n        url = geojson[\"url\"]\n        geojson = fetch_geojson(url)\n\n    # Default colormap\n    if colormap is None:\n        colormap = [\n            [0, \"rgba(33,102,172,0)\"],\n            [0.2, \"rgb(103,169,207)\"],\n            [0.4, \"rgb(209,229,240)\"],\n            [0.6, \"rgb(253,219,199)\"],\n            [0.8, \"rgb(239,138,98)\"],\n            [1, \"rgb(178,24,43)\"],\n        ]\n\n    # Build heatmap paint properties\n    paint = {\n        \"heatmap-radius\": radius,\n        \"heatmap-intensity\": intensity,\n        \"heatmap-opacity\": opacity,\n        \"heatmap-color\": [\n            \"interpolate\",\n            [\"linear\"],\n            [\"heatmap-density\"],\n        ],\n    }\n\n    # Add colormap stops\n    for stop, color in colormap:\n        paint[\"heatmap-color\"].extend([stop, color])\n\n    # Add weight if specified\n    if weight_property:\n        paint[\"heatmap-weight\"] = [\"get\", weight_property]\n\n    # Get bounds\n    bounds = get_bounds(geojson) if fit_bounds else None\n\n    self.call_js_method(\n        \"addGeoJSON\",\n        data=geojson,\n        name=layer_id,\n        layerType=\"heatmap\",\n        paint=paint,\n        fitBounds=fit_bounds,\n        bounds=bounds,\n        **kwargs,\n    )\n\n    self._layers = {\n        **self._layers,\n        layer_id: {\n            \"id\": layer_id,\n            \"type\": \"heatmap\",\n            \"source\": f\"{layer_id}-source\",\n            \"paint\": paint,\n        },\n    }\n    self._add_to_layer_dict(layer_id, \"Heatmap\")\n</code></pre>"},{"location":"maplibre/#anymap_ts.maplibre.MapLibreMap.add_hexagon_layer","title":"<code>add_hexagon_layer(self, data, name=None, get_position='coordinates', radius=1000, elevation_scale=4, extruded=True, color_range=None, pickable=True, opacity=0.8, **kwargs)</code>","text":"<p>Add a hexagon layer for hexagonal binning/aggregation using deck.gl.</p> <p>Hexagon layers aggregate points into hexagonal bins and render them with height and color based on point density.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>Array of data objects with position coordinates.</p> required <code>name</code> <code>Optional[str]</code> <p>Layer ID. If None, auto-generated.</p> <code>None</code> <code>get_position</code> <code>Union[str, Any]</code> <p>Accessor for point position [lng, lat].</p> <code>'coordinates'</code> <code>radius</code> <code>float</code> <p>Hexagon radius in meters.</p> <code>1000</code> <code>elevation_scale</code> <code>float</code> <p>Elevation multiplier for 3D hexagons.</p> <code>4</code> <code>extruded</code> <code>bool</code> <p>Whether to render as 3D hexagons.</p> <code>True</code> <code>color_range</code> <code>Optional[List[List[int]]]</code> <p>Color gradient for aggregation [[r, g, b], ...].</p> <code>None</code> <code>pickable</code> <code>bool</code> <p>Whether layer responds to hover/click events.</p> <code>True</code> <code>opacity</code> <code>float</code> <p>Layer opacity (0-1).</p> <code>0.8</code> <code>**kwargs</code> <p>Additional HexagonLayer props.</p> <code>{}</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from anymap_ts import MapLibreMap\n&gt;&gt;&gt; m = MapLibreMap(pitch=45)\n&gt;&gt;&gt; points = [\n...     {\"coordinates\": [-122.4, 37.8]},\n...     {\"coordinates\": [-122.41, 37.81]},\n... ]\n&gt;&gt;&gt; m.add_hexagon_layer(points, radius=500, elevation_scale=10)\n</code></pre> Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def add_hexagon_layer(\n    self,\n    data: Any,\n    name: Optional[str] = None,\n    get_position: Union[str, Any] = \"coordinates\",\n    radius: float = 1000,\n    elevation_scale: float = 4,\n    extruded: bool = True,\n    color_range: Optional[List[List[int]]] = None,\n    pickable: bool = True,\n    opacity: float = 0.8,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a hexagon layer for hexagonal binning/aggregation using deck.gl.\n\n    Hexagon layers aggregate points into hexagonal bins and render them\n    with height and color based on point density.\n\n    Args:\n        data: Array of data objects with position coordinates.\n        name: Layer ID. If None, auto-generated.\n        get_position: Accessor for point position [lng, lat].\n        radius: Hexagon radius in meters.\n        elevation_scale: Elevation multiplier for 3D hexagons.\n        extruded: Whether to render as 3D hexagons.\n        color_range: Color gradient for aggregation [[r, g, b], ...].\n        pickable: Whether layer responds to hover/click events.\n        opacity: Layer opacity (0-1).\n        **kwargs: Additional HexagonLayer props.\n\n    Example:\n        &gt;&gt;&gt; from anymap_ts import MapLibreMap\n        &gt;&gt;&gt; m = MapLibreMap(pitch=45)\n        &gt;&gt;&gt; points = [\n        ...     {\"coordinates\": [-122.4, 37.8]},\n        ...     {\"coordinates\": [-122.41, 37.81]},\n        ... ]\n        &gt;&gt;&gt; m.add_hexagon_layer(points, radius=500, elevation_scale=10)\n    \"\"\"\n    layer_id = name or f\"hexagon-{len(self._layers)}\"\n    processed_data = self._process_deck_data(data)\n\n    default_color_range = [\n        [1, 152, 189],\n        [73, 227, 206],\n        [216, 254, 181],\n        [254, 237, 177],\n        [254, 173, 84],\n        [209, 55, 78],\n    ]\n\n    self.call_js_method(\n        \"addHexagonLayer\",\n        id=layer_id,\n        data=processed_data,\n        getPosition=get_position,\n        radius=radius,\n        elevationScale=elevation_scale,\n        extruded=extruded,\n        colorRange=color_range or default_color_range,\n        pickable=pickable,\n        opacity=opacity,\n        **kwargs,\n    )\n\n    self._layers = {\n        **self._layers,\n        layer_id: {\n            \"id\": layer_id,\n            \"type\": \"hexagon\",\n        },\n    }\n    self._add_to_layer_dict(layer_id, \"Deck.gl\")\n</code></pre>"},{"location":"maplibre/#anymap_ts.maplibre.MapLibreMap.add_hover_effect","title":"<code>add_hover_effect(self, layer_id, highlight_color=None, highlight_opacity=None, highlight_outline_width=2, **kwargs)</code>","text":"<p>Add hover highlight effect to an existing layer.</p> <p>When the mouse hovers over a feature, it will be highlighted with the specified styles.</p> <p>Parameters:</p> Name Type Description Default <code>layer_id</code> <code>str</code> <p>Layer identifier to add hover effect to.</p> required <code>highlight_color</code> <code>Optional[str]</code> <p>Override fill/line color on hover. If None, the original color is kept but opacity/outline changes.</p> <code>None</code> <code>highlight_opacity</code> <code>Optional[float]</code> <p>Override opacity on hover.</p> <code>None</code> <code>highlight_outline_width</code> <code>float</code> <p>Outline width on hover.</p> <code>2</code> <code>**kwargs</code> <p>Additional hover effect options.</p> <code>{}</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from anymap_ts import Map\n&gt;&gt;&gt; m = Map()\n&gt;&gt;&gt; m.add_geojson(\"states.geojson\", name=\"states\")\n&gt;&gt;&gt; m.add_hover_effect(\"states\", highlight_opacity=0.9)\n</code></pre> Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def add_hover_effect(\n    self,\n    layer_id: str,\n    highlight_color: Optional[str] = None,\n    highlight_opacity: Optional[float] = None,\n    highlight_outline_width: float = 2,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add hover highlight effect to an existing layer.\n\n    When the mouse hovers over a feature, it will be highlighted with\n    the specified styles.\n\n    Args:\n        layer_id: Layer identifier to add hover effect to.\n        highlight_color: Override fill/line color on hover. If None,\n            the original color is kept but opacity/outline changes.\n        highlight_opacity: Override opacity on hover.\n        highlight_outline_width: Outline width on hover.\n        **kwargs: Additional hover effect options.\n\n    Example:\n        &gt;&gt;&gt; from anymap_ts import Map\n        &gt;&gt;&gt; m = Map()\n        &gt;&gt;&gt; m.add_geojson(\"states.geojson\", name=\"states\")\n        &gt;&gt;&gt; m.add_hover_effect(\"states\", highlight_opacity=0.9)\n    \"\"\"\n    self.call_js_method(\n        \"addHoverEffect\",\n        layerId=layer_id,\n        highlightColor=highlight_color,\n        highlightOpacity=highlight_opacity,\n        highlightOutlineWidth=highlight_outline_width,\n        **kwargs,\n    )\n</code></pre>"},{"location":"maplibre/#anymap_ts.maplibre.MapLibreMap.add_icon_layer","title":"<code>add_icon_layer(self, data, name=None, get_position='coordinates', get_icon='icon', get_size=20, get_color=None, icon_atlas=None, icon_mapping=None, pickable=True, opacity=1, **kwargs)</code>","text":"<p>Add an icon layer for custom icon markers at scale using deck.gl.</p> <p>Icon layers render icons/images at specified positions, ideal for rendering large numbers of custom markers efficiently.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>Array of data objects with position coordinates.</p> required <code>name</code> <code>Optional[str]</code> <p>Layer ID. If None, auto-generated.</p> <code>None</code> <code>get_position</code> <code>Union[str, Any]</code> <p>Accessor for icon position [lng, lat].</p> <code>'coordinates'</code> <code>get_icon</code> <code>Union[str, Any]</code> <p>Accessor for icon name in icon_mapping.</p> <code>'icon'</code> <code>get_size</code> <code>Union[float, str]</code> <p>Accessor for icon size in pixels.</p> <code>20</code> <code>get_color</code> <code>Optional[Union[List[int], str]]</code> <p>Accessor for icon tint color [r, g, b, a]. Default: [255, 255, 255, 255] (white, no tint).</p> <code>None</code> <code>icon_atlas</code> <code>Optional[str]</code> <p>URL to icon atlas image.</p> <code>None</code> <code>icon_mapping</code> <code>Optional[Dict]</code> <p>Dict mapping icon names to atlas coordinates.</p> <code>None</code> <code>pickable</code> <code>bool</code> <p>Whether layer responds to hover/click events.</p> <code>True</code> <code>opacity</code> <code>float</code> <p>Layer opacity (0-1).</p> <code>1</code> <code>**kwargs</code> <p>Additional IconLayer props.</p> <code>{}</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from anymap_ts import MapLibreMap\n&gt;&gt;&gt; m = MapLibreMap()\n&gt;&gt;&gt; markers = [\n...     {\"coordinates\": [-122.4, 37.8], \"icon\": \"marker\", \"size\": 30},\n... ]\n&gt;&gt;&gt; m.add_icon_layer(markers, get_size=\"size\")\n</code></pre> Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def add_icon_layer(\n    self,\n    data: Any,\n    name: Optional[str] = None,\n    get_position: Union[str, Any] = \"coordinates\",\n    get_icon: Union[str, Any] = \"icon\",\n    get_size: Union[float, str] = 20,\n    get_color: Optional[Union[List[int], str]] = None,\n    icon_atlas: Optional[str] = None,\n    icon_mapping: Optional[Dict] = None,\n    pickable: bool = True,\n    opacity: float = 1,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add an icon layer for custom icon markers at scale using deck.gl.\n\n    Icon layers render icons/images at specified positions, ideal for\n    rendering large numbers of custom markers efficiently.\n\n    Args:\n        data: Array of data objects with position coordinates.\n        name: Layer ID. If None, auto-generated.\n        get_position: Accessor for icon position [lng, lat].\n        get_icon: Accessor for icon name in icon_mapping.\n        get_size: Accessor for icon size in pixels.\n        get_color: Accessor for icon tint color [r, g, b, a].\n            Default: [255, 255, 255, 255] (white, no tint).\n        icon_atlas: URL to icon atlas image.\n        icon_mapping: Dict mapping icon names to atlas coordinates.\n        pickable: Whether layer responds to hover/click events.\n        opacity: Layer opacity (0-1).\n        **kwargs: Additional IconLayer props.\n\n    Example:\n        &gt;&gt;&gt; from anymap_ts import MapLibreMap\n        &gt;&gt;&gt; m = MapLibreMap()\n        &gt;&gt;&gt; markers = [\n        ...     {\"coordinates\": [-122.4, 37.8], \"icon\": \"marker\", \"size\": 30},\n        ... ]\n        &gt;&gt;&gt; m.add_icon_layer(markers, get_size=\"size\")\n    \"\"\"\n    layer_id = name or f\"icon-{len(self._layers)}\"\n    processed_data = self._process_deck_data(data)\n\n    self.call_js_method(\n        \"addIconLayer\",\n        id=layer_id,\n        data=processed_data,\n        getPosition=get_position,\n        getIcon=get_icon,\n        getSize=get_size,\n        getColor=get_color or [255, 255, 255, 255],\n        iconAtlas=icon_atlas,\n        iconMapping=icon_mapping,\n        pickable=pickable,\n        opacity=opacity,\n        **kwargs,\n    )\n\n    self._layers = {\n        **self._layers,\n        layer_id: {\n            \"id\": layer_id,\n            \"type\": \"icon\",\n        },\n    }\n    self._add_to_layer_dict(layer_id, \"Deck.gl\")\n</code></pre>"},{"location":"maplibre/#anymap_ts.maplibre.MapLibreMap.add_image","title":"<code>add_image(self, name, url)</code>","text":"<p>Load a custom icon image for use in symbol layers.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name to reference this image in symbol layers.</p> required <code>url</code> <code>str</code> <p>URL to the image file (PNG, JPEG, etc.).</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; m = MapLibreMap()\n&gt;&gt;&gt; m.add_image(\"custom-marker\", \"https://example.com/marker.png\")\n</code></pre> Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def add_image(self, name: str, url: str) -&gt; None:\n    \"\"\"Load a custom icon image for use in symbol layers.\n\n    Args:\n        name: Name to reference this image in symbol layers.\n        url: URL to the image file (PNG, JPEG, etc.).\n\n    Example:\n        &gt;&gt;&gt; m = MapLibreMap()\n        &gt;&gt;&gt; m.add_image(\"custom-marker\", \"https://example.com/marker.png\")\n    \"\"\"\n    self.call_js_method(\"addMapImage\", name=name, url=url)\n</code></pre>"},{"location":"maplibre/#anymap_ts.maplibre.MapLibreMap.add_image_layer","title":"<code>add_image_layer(self, url, coordinates, name=None, opacity=1.0, **kwargs)</code>","text":"<p>Add a georeferenced image overlay.</p> <p>Overlays an image on the map at specified geographic coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>URL to the image file.</p> required <code>coordinates</code> <code>List[List[float]]</code> <p>Four corner coordinates as [[lng, lat], ...] in order: top-left, top-right, bottom-right, bottom-left.</p> required <code>name</code> <code>Optional[str]</code> <p>Layer identifier. If None, auto-generated.</p> <code>None</code> <code>opacity</code> <code>float</code> <p>Layer opacity (0-1).</p> <code>1.0</code> <code>**kwargs</code> <p>Additional layer options.</p> <code>{}</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from anymap_ts import Map\n&gt;&gt;&gt; m = Map()\n&gt;&gt;&gt; m.add_image_layer(\n...     url=\"https://example.com/overlay.png\",\n...     coordinates=[\n...         [-80.425, 46.437],  # top-left\n...         [-71.516, 46.437],  # top-right\n...         [-71.516, 37.936],  # bottom-right\n...         [-80.425, 37.936],  # bottom-left\n...     ]\n... )\n</code></pre> Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def add_image_layer(\n    self,\n    url: str,\n    coordinates: List[List[float]],\n    name: Optional[str] = None,\n    opacity: float = 1.0,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a georeferenced image overlay.\n\n    Overlays an image on the map at specified geographic coordinates.\n\n    Args:\n        url: URL to the image file.\n        coordinates: Four corner coordinates as [[lng, lat], ...] in order:\n            top-left, top-right, bottom-right, bottom-left.\n        name: Layer identifier. If None, auto-generated.\n        opacity: Layer opacity (0-1).\n        **kwargs: Additional layer options.\n\n    Example:\n        &gt;&gt;&gt; from anymap_ts import Map\n        &gt;&gt;&gt; m = Map()\n        &gt;&gt;&gt; m.add_image_layer(\n        ...     url=\"https://example.com/overlay.png\",\n        ...     coordinates=[\n        ...         [-80.425, 46.437],  # top-left\n        ...         [-71.516, 46.437],  # top-right\n        ...         [-71.516, 37.936],  # bottom-right\n        ...         [-80.425, 37.936],  # bottom-left\n        ...     ]\n        ... )\n    \"\"\"\n    self._validate_opacity(opacity)\n    layer_id = name or f\"image-{len(self._layers)}\"\n\n    if len(coordinates) != 4:\n        raise ValueError(\n            \"coordinates must have exactly 4 corner points \"\n            \"[top-left, top-right, bottom-right, bottom-left]\"\n        )\n\n    self.call_js_method(\n        \"addImageLayer\",\n        id=layer_id,\n        url=url,\n        coordinates=coordinates,\n        opacity=opacity,\n        **kwargs,\n    )\n\n    self._layers = {\n        **self._layers,\n        layer_id: {\n            \"id\": layer_id,\n            \"type\": \"image\",\n            \"url\": url,\n            \"coordinates\": coordinates,\n        },\n    }\n    self._add_to_layer_dict(layer_id, \"Raster\")\n</code></pre>"},{"location":"maplibre/#anymap_ts.maplibre.MapLibreMap.add_layer","title":"<code>add_layer(self, layer_id, layer_type, source, paint=None, layout=None, before_id=None, **kwargs)</code>","text":"<p>Add a generic layer to the map.</p> <p>Parameters:</p> Name Type Description Default <code>layer_id</code> <code>str</code> <p>Unique layer identifier</p> required <code>layer_type</code> <code>str</code> <p>MapLibre layer type</p> required <code>source</code> <code>Union[str, Dict]</code> <p>Source ID or source configuration dict</p> required <code>paint</code> <code>Optional[Dict]</code> <p>Paint properties</p> <code>None</code> <code>layout</code> <code>Optional[Dict]</code> <p>Layout properties</p> <code>None</code> <code>before_id</code> <code>Optional[str]</code> <p>ID of layer to insert before</p> <code>None</code> <code>**kwargs</code> <p>Additional layer options</p> <code>{}</code> Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def add_layer(\n    self,\n    layer_id: str,\n    layer_type: str,\n    source: Union[str, Dict],\n    paint: Optional[Dict] = None,\n    layout: Optional[Dict] = None,\n    before_id: Optional[str] = None,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a generic layer to the map.\n\n    Args:\n        layer_id: Unique layer identifier\n        layer_type: MapLibre layer type\n        source: Source ID or source configuration dict\n        paint: Paint properties\n        layout: Layout properties\n        before_id: ID of layer to insert before\n        **kwargs: Additional layer options\n    \"\"\"\n    layer_config = {\n        \"id\": layer_id,\n        \"type\": layer_type,\n        \"paint\": paint or {},\n        \"layout\": layout or {},\n        **kwargs,\n    }\n\n    if isinstance(source, str):\n        layer_config[\"source\"] = source\n    else:\n        source_id = f\"{layer_id}-source\"\n        self._sources = {**self._sources, source_id: source}\n        self.call_js_method(\"addSource\", source_id, **source)\n        layer_config[\"source\"] = source_id\n\n    self._layers = {**self._layers, layer_id: layer_config}\n    self.call_js_method(\"addLayer\", beforeId=before_id, **layer_config)\n    # Determine category based on layer type\n    layer_type = layer_config.get(\"type\", \"\")\n    if layer_type == \"raster\":\n        self._add_to_layer_dict(layer_id, \"Raster\")\n    else:\n        self._add_to_layer_dict(layer_id, \"Vector\")\n</code></pre>"},{"location":"maplibre/#anymap_ts.maplibre.MapLibreMap.add_layer_control","title":"<code>add_layer_control(self, layers=None, position='top-right', collapsed=True)</code>","text":"<p>Add a layer visibility control.</p> <p>Uses maplibre-gl-layer-control for layer toggling and opacity.</p> <p>Parameters:</p> Name Type Description Default <code>layers</code> <code>Optional[List[str]]</code> <p>List of layer IDs to include (None = all layers)</p> <code>None</code> <code>position</code> <code>str</code> <p>Control position</p> <code>'top-right'</code> <code>collapsed</code> <code>bool</code> <p>Whether control starts collapsed</p> <code>True</code> Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def add_layer_control(\n    self,\n    layers: Optional[List[str]] = None,\n    position: str = \"top-right\",\n    collapsed: bool = True,\n) -&gt; None:\n    \"\"\"Add a layer visibility control.\n\n    Uses maplibre-gl-layer-control for layer toggling and opacity.\n\n    Args:\n        layers: List of layer IDs to include (None = all layers)\n        position: Control position\n        collapsed: Whether control starts collapsed\n    \"\"\"\n    if layers is None:\n        layers = list(self._layers.keys())\n\n    self.call_js_method(\n        \"addLayerControl\",\n        layers=layers,\n        position=position,\n        collapsed=collapsed,\n    )\n    self._controls = {\n        **self._controls,\n        \"layer-control\": {\n            \"layers\": layers,\n            \"position\": position,\n            \"collapsed\": collapsed,\n        },\n    }\n</code></pre>"},{"location":"maplibre/#anymap_ts.maplibre.MapLibreMap.add_legend","title":"<code>add_legend(self, title, labels, colors, position='bottom-right', opacity=1.0, legend_id=None, **kwargs)</code>","text":"<p>Add a floating legend control to the map.</p> <p>Creates a custom legend control with colored boxes and labels that floats over the map in the specified position.</p> <p>Parameters:</p> Name Type Description Default <code>title</code> <code>str</code> <p>Legend title text</p> required <code>labels</code> <code>List[str]</code> <p>List of label strings for each legend item</p> required <code>colors</code> <code>List[str]</code> <p>List of hex color strings (e.g., ['#ff0000', '#00ff00', '#0000ff'])</p> required <code>position</code> <code>str</code> <p>Legend position ('top-left', 'top-right', 'bottom-left', 'bottom-right')</p> <code>'bottom-right'</code> <code>opacity</code> <code>float</code> <p>Legend background opacity (0-1)</p> <code>1.0</code> <code>legend_id</code> <code>Optional[str]</code> <p>Custom legend identifier (auto-generated if None)</p> <code>None</code> <code>**kwargs</code> <p>Additional legend styling options</p> <code>{}</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from anymap_ts import Map\n&gt;&gt;&gt; m = Map()\n&gt;&gt;&gt; m.add_legend(\n...     title=\"Land Cover\",\n...     labels=[\"Forest\", \"Water\", \"Urban\"],\n...     colors=[\"#228B22\", \"#0000FF\", \"#808080\"],\n...     position=\"top-left\"\n... )\n</code></pre> Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def add_legend(\n    self,\n    title: str,\n    labels: List[str],\n    colors: List[str],\n    position: str = \"bottom-right\",\n    opacity: float = 1.0,\n    legend_id: Optional[str] = None,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a floating legend control to the map.\n\n    Creates a custom legend control with colored boxes and labels that\n    floats over the map in the specified position.\n\n    Args:\n        title: Legend title text\n        labels: List of label strings for each legend item\n        colors: List of hex color strings (e.g., ['#ff0000', '#00ff00', '#0000ff'])\n        position: Legend position ('top-left', 'top-right', 'bottom-left', 'bottom-right')\n        opacity: Legend background opacity (0-1)\n        legend_id: Custom legend identifier (auto-generated if None)\n        **kwargs: Additional legend styling options\n\n    Example:\n        &gt;&gt;&gt; from anymap_ts import Map\n        &gt;&gt;&gt; m = Map()\n        &gt;&gt;&gt; m.add_legend(\n        ...     title=\"Land Cover\",\n        ...     labels=[\"Forest\", \"Water\", \"Urban\"],\n        ...     colors=[\"#228B22\", \"#0000FF\", \"#808080\"],\n        ...     position=\"top-left\"\n        ... )\n    \"\"\"\n    if len(labels) != len(colors):\n        raise ValueError(\"Number of labels must match number of colors\")\n\n    # Validate position\n    self._validate_position(position)\n\n    # Validate colors (basic hex color check)\n    for i, color in enumerate(colors):\n        if not isinstance(color, str) or not color.startswith(\"#\"):\n            raise ValueError(\n                f\"Color at index {i} must be a hex color string (e.g., '#ff0000')\"\n            )\n\n    legend_id = (\n        legend_id\n        or f\"legend-{len([k for k in self._controls.keys() if k.startswith('legend')])}\"\n    )\n\n    # Prepare legend data\n    legend_items = []\n    for label, color in zip(labels, colors):\n        legend_items.append(\n            {\n                \"label\": label,\n                \"color\": color,\n            }\n        )\n\n    # Call JavaScript method to add legend\n    self.call_js_method(\n        \"addLegend\",\n        id=legend_id,\n        title=title,\n        items=legend_items,\n        position=position,\n        opacity=opacity,\n        **kwargs,\n    )\n\n    # Track legend control\n    self._controls = {\n        **self._controls,\n        legend_id: {\n            \"type\": \"legend\",\n            \"title\": title,\n            \"labels\": labels,\n            \"colors\": colors,\n            \"position\": position,\n            \"opacity\": opacity,\n        },\n    }\n</code></pre>"},{"location":"maplibre/#anymap_ts.maplibre.MapLibreMap.add_lidar_control","title":"<code>add_lidar_control(self, position='top-right', collapsed=True, title='LiDAR Viewer', point_size=2, opacity=1.0, color_scheme='elevation', use_percentile=True, point_budget=1000000, pickable=False, auto_zoom=True, copc_loading_mode=None, streaming_point_budget=5000000, panel_max_height=600, **kwargs)</code>","text":"<p>Add an interactive LiDAR control panel.</p> <p>The LiDAR control provides a UI panel for loading, visualizing, and styling LiDAR point cloud files (LAS, LAZ, COPC formats).</p> <p>Parameters:</p> Name Type Description Default <code>position</code> <code>str</code> <p>Control position ('top-left', 'top-right', 'bottom-left', 'bottom-right').</p> <code>'top-right'</code> <code>collapsed</code> <code>bool</code> <p>Whether the panel starts collapsed.</p> <code>True</code> <code>title</code> <code>str</code> <p>Title displayed on the panel.</p> <code>'LiDAR Viewer'</code> <code>point_size</code> <code>float</code> <p>Point size in pixels.</p> <code>2</code> <code>opacity</code> <code>float</code> <p>Layer opacity (0-1).</p> <code>1.0</code> <code>color_scheme</code> <code>str</code> <p>Color scheme ('elevation', 'intensity', 'classification', 'rgb').</p> <code>'elevation'</code> <code>use_percentile</code> <code>bool</code> <p>Use 2-98% percentile for color scaling.</p> <code>True</code> <code>point_budget</code> <code>int</code> <p>Maximum number of points to display.</p> <code>1000000</code> <code>pickable</code> <code>bool</code> <p>Enable hover/click interactions.</p> <code>False</code> <code>auto_zoom</code> <code>bool</code> <p>Auto-zoom to point cloud after loading.</p> <code>True</code> <code>copc_loading_mode</code> <code>Optional[str]</code> <p>COPC loading mode ('full' or 'dynamic').</p> <code>None</code> <code>streaming_point_budget</code> <code>int</code> <p>Point budget for streaming mode.</p> <code>5000000</code> <code>panel_max_height</code> <code>int</code> <p>Maximum height of the panel in pixels.</p> <code>600</code> <code>**kwargs</code> <p>Additional control options.</p> <code>{}</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from anymap_ts import MapLibreMap\n&gt;&gt;&gt; m = MapLibreMap(pitch=60)\n&gt;&gt;&gt; m.add_lidar_control(color_scheme=\"classification\", pickable=True)\n</code></pre> Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def add_lidar_control(\n    self,\n    position: str = \"top-right\",\n    collapsed: bool = True,\n    title: str = \"LiDAR Viewer\",\n    point_size: float = 2,\n    opacity: float = 1.0,\n    color_scheme: str = \"elevation\",\n    use_percentile: bool = True,\n    point_budget: int = 1000000,\n    pickable: bool = False,\n    auto_zoom: bool = True,\n    copc_loading_mode: Optional[str] = None,\n    streaming_point_budget: int = 5000000,\n    panel_max_height: int = 600,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add an interactive LiDAR control panel.\n\n    The LiDAR control provides a UI panel for loading, visualizing, and\n    styling LiDAR point cloud files (LAS, LAZ, COPC formats).\n\n    Args:\n        position: Control position ('top-left', 'top-right', 'bottom-left', 'bottom-right').\n        collapsed: Whether the panel starts collapsed.\n        title: Title displayed on the panel.\n        point_size: Point size in pixels.\n        opacity: Layer opacity (0-1).\n        color_scheme: Color scheme ('elevation', 'intensity', 'classification', 'rgb').\n        use_percentile: Use 2-98% percentile for color scaling.\n        point_budget: Maximum number of points to display.\n        pickable: Enable hover/click interactions.\n        auto_zoom: Auto-zoom to point cloud after loading.\n        copc_loading_mode: COPC loading mode ('full' or 'dynamic').\n        streaming_point_budget: Point budget for streaming mode.\n        panel_max_height: Maximum height of the panel in pixels.\n        **kwargs: Additional control options.\n\n    Example:\n        &gt;&gt;&gt; from anymap_ts import MapLibreMap\n        &gt;&gt;&gt; m = MapLibreMap(pitch=60)\n        &gt;&gt;&gt; m.add_lidar_control(color_scheme=\"classification\", pickable=True)\n    \"\"\"\n    self.call_js_method(\n        \"addLidarControl\",\n        position=position,\n        collapsed=collapsed,\n        title=title,\n        pointSize=point_size,\n        opacity=opacity,\n        colorScheme=color_scheme,\n        usePercentile=use_percentile,\n        pointBudget=point_budget,\n        pickable=pickable,\n        autoZoom=auto_zoom,\n        copcLoadingMode=copc_loading_mode,\n        streamingPointBudget=streaming_point_budget,\n        panelMaxHeight=panel_max_height,\n        **kwargs,\n    )\n    self._controls = {\n        **self._controls,\n        \"lidar-control\": {\"position\": position, \"collapsed\": collapsed},\n    }\n</code></pre>"},{"location":"maplibre/#anymap_ts.maplibre.MapLibreMap.add_lidar_layer","title":"<code>add_lidar_layer(self, source, name=None, color_scheme='elevation', point_size=2, opacity=1.0, pickable=True, auto_zoom=True, streaming_mode=True, point_budget=1000000, **kwargs)</code>","text":"<p>Load and display a LiDAR file from URL or local path.</p> <p>Supports LAS, LAZ, and COPC (Cloud-Optimized Point Cloud) formats. For local files, the file is read and sent as base64 to JavaScript. For URLs, the data is loaded directly via streaming when possible.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>Union[str, Path]</code> <p>URL or local file path to the LiDAR file.</p> required <code>name</code> <code>Optional[str]</code> <p>Layer identifier. If None, auto-generated.</p> <code>None</code> <code>color_scheme</code> <code>str</code> <p>Color scheme ('elevation', 'intensity', 'classification', 'rgb').</p> <code>'elevation'</code> <code>point_size</code> <code>float</code> <p>Point size in pixels.</p> <code>2</code> <code>opacity</code> <code>float</code> <p>Layer opacity (0-1).</p> <code>1.0</code> <code>pickable</code> <code>bool</code> <p>Enable hover/click interactions.</p> <code>True</code> <code>auto_zoom</code> <code>bool</code> <p>Auto-zoom to point cloud after loading.</p> <code>True</code> <code>streaming_mode</code> <code>bool</code> <p>Use streaming mode for large COPC files.</p> <code>True</code> <code>point_budget</code> <code>int</code> <p>Maximum number of points to display.</p> <code>1000000</code> <code>**kwargs</code> <p>Additional layer options.</p> <code>{}</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from anymap_ts import MapLibreMap\n&gt;&gt;&gt; m = MapLibreMap(center=[-123.07, 44.05], zoom=14, pitch=60)\n&gt;&gt;&gt; m.add_lidar_layer(\n...     source=\"https://s3.amazonaws.com/hobu-lidar/autzen-classified.copc.laz\",\n...     name=\"autzen\",\n...     color_scheme=\"classification\",\n... )\n</code></pre> Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def add_lidar_layer(\n    self,\n    source: Union[str, Path],\n    name: Optional[str] = None,\n    color_scheme: str = \"elevation\",\n    point_size: float = 2,\n    opacity: float = 1.0,\n    pickable: bool = True,\n    auto_zoom: bool = True,\n    streaming_mode: bool = True,\n    point_budget: int = 1000000,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Load and display a LiDAR file from URL or local path.\n\n    Supports LAS, LAZ, and COPC (Cloud-Optimized Point Cloud) formats.\n    For local files, the file is read and sent as base64 to JavaScript.\n    For URLs, the data is loaded directly via streaming when possible.\n\n    Args:\n        source: URL or local file path to the LiDAR file.\n        name: Layer identifier. If None, auto-generated.\n        color_scheme: Color scheme ('elevation', 'intensity', 'classification', 'rgb').\n        point_size: Point size in pixels.\n        opacity: Layer opacity (0-1).\n        pickable: Enable hover/click interactions.\n        auto_zoom: Auto-zoom to point cloud after loading.\n        streaming_mode: Use streaming mode for large COPC files.\n        point_budget: Maximum number of points to display.\n        **kwargs: Additional layer options.\n\n    Example:\n        &gt;&gt;&gt; from anymap_ts import MapLibreMap\n        &gt;&gt;&gt; m = MapLibreMap(center=[-123.07, 44.05], zoom=14, pitch=60)\n        &gt;&gt;&gt; m.add_lidar_layer(\n        ...     source=\"https://s3.amazonaws.com/hobu-lidar/autzen-classified.copc.laz\",\n        ...     name=\"autzen\",\n        ...     color_scheme=\"classification\",\n        ... )\n    \"\"\"\n    layer_id = name or f\"lidar-{len(self._layers)}\"\n\n    # Check if source is a local file\n    source_path = Path(source) if isinstance(source, (str, Path)) else None\n    is_local = source_path is not None and source_path.exists()\n\n    if is_local:\n        # Read local file and encode as base64\n        import base64\n\n        with open(source_path, \"rb\") as f:\n            file_data = f.read()\n        source_b64 = base64.b64encode(file_data).decode(\"utf-8\")\n\n        self.call_js_method(\n            \"addLidarLayer\",\n            source=source_b64,\n            name=layer_id,\n            isBase64=True,\n            filename=source_path.name,\n            colorScheme=color_scheme,\n            pointSize=point_size,\n            opacity=opacity,\n            pickable=pickable,\n            autoZoom=auto_zoom,\n            streamingMode=streaming_mode,\n            pointBudget=point_budget,\n            **kwargs,\n        )\n    else:\n        # Load from URL\n        self.call_js_method(\n            \"addLidarLayer\",\n            source=str(source),\n            name=layer_id,\n            isBase64=False,\n            colorScheme=color_scheme,\n            pointSize=point_size,\n            opacity=opacity,\n            pickable=pickable,\n            autoZoom=auto_zoom,\n            streamingMode=streaming_mode,\n            pointBudget=point_budget,\n            **kwargs,\n        )\n\n    self._layers = {\n        **self._layers,\n        layer_id: {\n            \"id\": layer_id,\n            \"type\": \"lidar\",\n            \"source\": str(source),\n        },\n    }\n    self._add_to_layer_dict(layer_id, \"LiDAR\")\n</code></pre>"},{"location":"maplibre/#anymap_ts.maplibre.MapLibreMap.add_line_layer","title":"<code>add_line_layer(self, data, name=None, get_source_position='sourcePosition', get_target_position='targetPosition', get_color=None, get_width=1, width_min_pixels=1, pickable=True, opacity=0.8, **kwargs)</code>","text":"<p>Add a line layer for origin-destination line visualization using deck.gl.</p> <p>Line layers render straight line segments between source and target positions. Unlike arc layers, lines are drawn without curvature.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>Array of line objects with source/target positions.</p> required <code>name</code> <code>Optional[str]</code> <p>Layer ID. If None, auto-generated.</p> <code>None</code> <code>get_source_position</code> <code>Union[str, Any]</code> <p>Accessor for source position [lng, lat].</p> <code>'sourcePosition'</code> <code>get_target_position</code> <code>Union[str, Any]</code> <p>Accessor for target position [lng, lat].</p> <code>'targetPosition'</code> <code>get_color</code> <code>Optional[Union[List[int], str]]</code> <p>Accessor for line color [r, g, b] or [r, g, b, a]. Default: [51, 136, 255, 200] (blue).</p> <code>None</code> <code>get_width</code> <code>Union[float, str]</code> <p>Accessor for line width.</p> <code>1</code> <code>width_min_pixels</code> <code>float</code> <p>Minimum line width in pixels.</p> <code>1</code> <code>pickable</code> <code>bool</code> <p>Whether layer responds to hover/click events.</p> <code>True</code> <code>opacity</code> <code>float</code> <p>Layer opacity (0-1).</p> <code>0.8</code> <code>**kwargs</code> <p>Additional LineLayer props.</p> <code>{}</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from anymap_ts import MapLibreMap\n&gt;&gt;&gt; m = MapLibreMap()\n&gt;&gt;&gt; lines = [\n...     {\"sourcePosition\": [-122.4, 37.8], \"targetPosition\": [-73.9, 40.7]},\n... ]\n&gt;&gt;&gt; m.add_line_layer(lines, get_color=[0, 128, 255], get_width=2)\n</code></pre> Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def add_line_layer(\n    self,\n    data: Any,\n    name: Optional[str] = None,\n    get_source_position: Union[str, Any] = \"sourcePosition\",\n    get_target_position: Union[str, Any] = \"targetPosition\",\n    get_color: Optional[Union[List[int], str]] = None,\n    get_width: Union[float, str] = 1,\n    width_min_pixels: float = 1,\n    pickable: bool = True,\n    opacity: float = 0.8,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a line layer for origin-destination line visualization using deck.gl.\n\n    Line layers render straight line segments between source and target\n    positions. Unlike arc layers, lines are drawn without curvature.\n\n    Args:\n        data: Array of line objects with source/target positions.\n        name: Layer ID. If None, auto-generated.\n        get_source_position: Accessor for source position [lng, lat].\n        get_target_position: Accessor for target position [lng, lat].\n        get_color: Accessor for line color [r, g, b] or [r, g, b, a].\n            Default: [51, 136, 255, 200] (blue).\n        get_width: Accessor for line width.\n        width_min_pixels: Minimum line width in pixels.\n        pickable: Whether layer responds to hover/click events.\n        opacity: Layer opacity (0-1).\n        **kwargs: Additional LineLayer props.\n\n    Example:\n        &gt;&gt;&gt; from anymap_ts import MapLibreMap\n        &gt;&gt;&gt; m = MapLibreMap()\n        &gt;&gt;&gt; lines = [\n        ...     {\"sourcePosition\": [-122.4, 37.8], \"targetPosition\": [-73.9, 40.7]},\n        ... ]\n        &gt;&gt;&gt; m.add_line_layer(lines, get_color=[0, 128, 255], get_width=2)\n    \"\"\"\n    layer_id = name or f\"line-{len(self._layers)}\"\n    processed_data = self._process_deck_data(data)\n\n    self.call_js_method(\n        \"addLineLayer\",\n        id=layer_id,\n        data=processed_data,\n        getSourcePosition=get_source_position,\n        getTargetPosition=get_target_position,\n        getColor=get_color or [51, 136, 255, 200],\n        getWidth=get_width,\n        widthMinPixels=width_min_pixels,\n        pickable=pickable,\n        opacity=opacity,\n        **kwargs,\n    )\n\n    self._layers = {\n        **self._layers,\n        layer_id: {\n            \"id\": layer_id,\n            \"type\": \"line\",\n        },\n    }\n    self._add_to_layer_dict(layer_id, \"Deck.gl\")\n</code></pre>"},{"location":"maplibre/#anymap_ts.maplibre.MapLibreMap.add_marker","title":"<code>add_marker(self, lng, lat, popup=None, tooltip=None, color='#3388ff', draggable=False, scale=1.0, popup_max_width='240px', tooltip_max_width='240px', name=None, **kwargs)</code>","text":"<p>Add a single marker to the map.</p> <p>Parameters:</p> Name Type Description Default <code>lng</code> <code>float</code> <p>Longitude of the marker.</p> required <code>lat</code> <code>float</code> <p>Latitude of the marker.</p> required <code>popup</code> <code>Optional[str]</code> <p>Optional popup HTML content (shown on click).</p> <code>None</code> <code>tooltip</code> <code>Optional[str]</code> <p>Optional tooltip HTML content (shown on hover).</p> <code>None</code> <code>color</code> <code>str</code> <p>Marker color as hex string.</p> <code>'#3388ff'</code> <code>draggable</code> <code>bool</code> <p>Whether the marker can be dragged.</p> <code>False</code> <code>scale</code> <code>float</code> <p>Marker size multiplier (default 1.0, range 0.1 to 3.0).</p> <code>1.0</code> <code>popup_max_width</code> <code>str</code> <p>Maximum width of popup (CSS value, default \"240px\").</p> <code>'240px'</code> <code>tooltip_max_width</code> <code>str</code> <p>Maximum width of tooltip (CSS value, default \"240px\").</p> <code>'240px'</code> <code>name</code> <code>Optional[str]</code> <p>Marker identifier. If None, auto-generated.</p> <code>None</code> <code>**kwargs</code> <p>Additional marker options.</p> <code>{}</code> <p>Returns:</p> Type Description <code>str</code> <p>The marker identifier.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from anymap_ts import Map\n&gt;&gt;&gt; m = Map(center=[-122.4, 37.8], zoom=10)\n&gt;&gt;&gt; m.add_marker(-122.4, 37.8, popup=\"San Francisco\", tooltip=\"Hover me!\")\n&gt;&gt;&gt; m.add_marker(-122.5, 37.7, scale=1.5, color=\"#ff0000\")\n</code></pre> Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def add_marker(\n    self,\n    lng: float,\n    lat: float,\n    popup: Optional[str] = None,\n    tooltip: Optional[str] = None,\n    color: str = \"#3388ff\",\n    draggable: bool = False,\n    scale: float = 1.0,\n    popup_max_width: str = \"240px\",\n    tooltip_max_width: str = \"240px\",\n    name: Optional[str] = None,\n    **kwargs,\n) -&gt; str:\n    \"\"\"Add a single marker to the map.\n\n    Args:\n        lng: Longitude of the marker.\n        lat: Latitude of the marker.\n        popup: Optional popup HTML content (shown on click).\n        tooltip: Optional tooltip HTML content (shown on hover).\n        color: Marker color as hex string.\n        draggable: Whether the marker can be dragged.\n        scale: Marker size multiplier (default 1.0, range 0.1 to 3.0).\n        popup_max_width: Maximum width of popup (CSS value, default \"240px\").\n        tooltip_max_width: Maximum width of tooltip (CSS value, default \"240px\").\n        name: Marker identifier. If None, auto-generated.\n        **kwargs: Additional marker options.\n\n    Returns:\n        The marker identifier.\n\n    Example:\n        &gt;&gt;&gt; from anymap_ts import Map\n        &gt;&gt;&gt; m = Map(center=[-122.4, 37.8], zoom=10)\n        &gt;&gt;&gt; m.add_marker(-122.4, 37.8, popup=\"San Francisco\", tooltip=\"Hover me!\")\n        &gt;&gt;&gt; m.add_marker(-122.5, 37.7, scale=1.5, color=\"#ff0000\")\n    \"\"\"\n    marker_id = name or f\"marker-{len(self._layers)}\"\n\n    self.call_js_method(\n        \"addMarker\",\n        lng,\n        lat,\n        id=marker_id,\n        popup=popup,\n        tooltip=tooltip,\n        color=color,\n        draggable=draggable,\n        scale=scale,\n        popupMaxWidth=popup_max_width,\n        tooltipMaxWidth=tooltip_max_width,\n        **kwargs,\n    )\n\n    self._layers = {\n        **self._layers,\n        marker_id: {\n            \"id\": marker_id,\n            \"type\": \"marker\",\n            \"lngLat\": [lng, lat],\n        },\n    }\n    self._add_to_layer_dict(marker_id, \"Markers\")\n    return marker_id\n</code></pre>"},{"location":"maplibre/#anymap_ts.maplibre.MapLibreMap.add_markers","title":"<code>add_markers(self, data, lng_column=None, lat_column=None, popup_column=None, tooltip_column=None, color='#3388ff', scale=1.0, popup_max_width='240px', tooltip_max_width='240px', draggable=False, name=None, **kwargs)</code>","text":"<p>Add multiple markers from data.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>Data source - can be: - List of dicts with 'lng'/'lon'/'longitude' and 'lat'/'latitude' keys - GeoDataFrame with Point geometries - GeoJSON FeatureCollection with Point features</p> required <code>lng_column</code> <code>Optional[str]</code> <p>Column name for longitude (auto-detected if None).</p> <code>None</code> <code>lat_column</code> <code>Optional[str]</code> <p>Column name for latitude (auto-detected if None).</p> <code>None</code> <code>popup_column</code> <code>Optional[str]</code> <p>Column name for popup content (shown on click).</p> <code>None</code> <code>tooltip_column</code> <code>Optional[str]</code> <p>Column name for tooltip content (shown on hover).</p> <code>None</code> <code>color</code> <code>str</code> <p>Marker color as hex string.</p> <code>'#3388ff'</code> <code>scale</code> <code>float</code> <p>Marker size multiplier (default 1.0, range 0.1 to 3.0).</p> <code>1.0</code> <code>popup_max_width</code> <code>str</code> <p>Maximum width of popup (CSS value, default \"240px\").</p> <code>'240px'</code> <code>tooltip_max_width</code> <code>str</code> <p>Maximum width of tooltip (CSS value, default \"240px\").</p> <code>'240px'</code> <code>draggable</code> <code>bool</code> <p>Whether markers can be dragged.</p> <code>False</code> <code>name</code> <code>Optional[str]</code> <p>Layer identifier. If None, auto-generated.</p> <code>None</code> <code>**kwargs</code> <p>Additional marker options.</p> <code>{}</code> <p>Returns:</p> Type Description <code>str</code> <p>The layer identifier.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from anymap_ts import Map\n&gt;&gt;&gt; m = Map()\n&gt;&gt;&gt; cities = [\n...     {\"name\": \"SF\", \"info\": \"San Francisco\", \"lng\": -122.4, \"lat\": 37.8},\n...     {\"name\": \"NYC\", \"info\": \"New York City\", \"lng\": -74.0, \"lat\": 40.7},\n... ]\n&gt;&gt;&gt; m.add_markers(cities, popup_column=\"name\", tooltip_column=\"info\", scale=1.5)\n</code></pre> Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def add_markers(\n    self,\n    data: Any,\n    lng_column: Optional[str] = None,\n    lat_column: Optional[str] = None,\n    popup_column: Optional[str] = None,\n    tooltip_column: Optional[str] = None,\n    color: str = \"#3388ff\",\n    scale: float = 1.0,\n    popup_max_width: str = \"240px\",\n    tooltip_max_width: str = \"240px\",\n    draggable: bool = False,\n    name: Optional[str] = None,\n    **kwargs,\n) -&gt; str:\n    \"\"\"Add multiple markers from data.\n\n    Args:\n        data: Data source - can be:\n            - List of dicts with 'lng'/'lon'/'longitude' and 'lat'/'latitude' keys\n            - GeoDataFrame with Point geometries\n            - GeoJSON FeatureCollection with Point features\n        lng_column: Column name for longitude (auto-detected if None).\n        lat_column: Column name for latitude (auto-detected if None).\n        popup_column: Column name for popup content (shown on click).\n        tooltip_column: Column name for tooltip content (shown on hover).\n        color: Marker color as hex string.\n        scale: Marker size multiplier (default 1.0, range 0.1 to 3.0).\n        popup_max_width: Maximum width of popup (CSS value, default \"240px\").\n        tooltip_max_width: Maximum width of tooltip (CSS value, default \"240px\").\n        draggable: Whether markers can be dragged.\n        name: Layer identifier. If None, auto-generated.\n        **kwargs: Additional marker options.\n\n    Returns:\n        The layer identifier.\n\n    Example:\n        &gt;&gt;&gt; from anymap_ts import Map\n        &gt;&gt;&gt; m = Map()\n        &gt;&gt;&gt; cities = [\n        ...     {\"name\": \"SF\", \"info\": \"San Francisco\", \"lng\": -122.4, \"lat\": 37.8},\n        ...     {\"name\": \"NYC\", \"info\": \"New York City\", \"lng\": -74.0, \"lat\": 40.7},\n        ... ]\n        &gt;&gt;&gt; m.add_markers(cities, popup_column=\"name\", tooltip_column=\"info\", scale=1.5)\n    \"\"\"\n    layer_id = name or f\"markers-{len(self._layers)}\"\n    markers = []\n\n    # Handle GeoDataFrame\n    if hasattr(data, \"geometry\"):\n        for _, row in data.iterrows():\n            geom = row.geometry\n            if geom.geom_type == \"Point\":\n                marker = {\"lngLat\": [geom.x, geom.y]}\n                if popup_column and popup_column in row:\n                    marker[\"popup\"] = str(row[popup_column])\n                if tooltip_column and tooltip_column in row:\n                    marker[\"tooltip\"] = str(row[tooltip_column])\n                markers.append(marker)\n    # Handle GeoJSON\n    elif isinstance(data, dict) and data.get(\"type\") == \"FeatureCollection\":\n        for feature in data.get(\"features\", []):\n            geom = feature.get(\"geometry\", {})\n            if geom.get(\"type\") == \"Point\":\n                coords = geom.get(\"coordinates\", [])\n                marker = {\"lngLat\": coords[:2]}\n                props = feature.get(\"properties\", {})\n                if popup_column and popup_column in props:\n                    marker[\"popup\"] = str(props[popup_column])\n                if tooltip_column and tooltip_column in props:\n                    marker[\"tooltip\"] = str(props[tooltip_column])\n                markers.append(marker)\n    # Handle list of dicts\n    elif isinstance(data, list):\n        lng_keys = [\"lng\", \"lon\", \"longitude\", \"x\"]\n        lat_keys = [\"lat\", \"latitude\", \"y\"]\n\n        for item in data:\n            if not isinstance(item, dict):\n                continue\n\n            # Find lng/lat values\n            lng_val = None\n            lat_val = None\n\n            if lng_column and lng_column in item:\n                lng_val = item[lng_column]\n            else:\n                for key in lng_keys:\n                    if key in item:\n                        lng_val = item[key]\n                        break\n\n            if lat_column and lat_column in item:\n                lat_val = item[lat_column]\n            else:\n                for key in lat_keys:\n                    if key in item:\n                        lat_val = item[key]\n                        break\n\n            if lng_val is not None and lat_val is not None:\n                marker = {\"lngLat\": [float(lng_val), float(lat_val)]}\n                if popup_column and popup_column in item:\n                    marker[\"popup\"] = str(item[popup_column])\n                if tooltip_column and tooltip_column in item:\n                    marker[\"tooltip\"] = str(item[tooltip_column])\n                markers.append(marker)\n\n    if not markers:\n        raise ValueError(\"No valid point data found in input\")\n\n    self.call_js_method(\n        \"addMarkers\",\n        id=layer_id,\n        markers=markers,\n        color=color,\n        scale=scale,\n        popupMaxWidth=popup_max_width,\n        tooltipMaxWidth=tooltip_max_width,\n        draggable=draggable,\n        **kwargs,\n    )\n\n    self._layers = {\n        **self._layers,\n        layer_id: {\n            \"id\": layer_id,\n            \"type\": \"markers\",\n            \"count\": len(markers),\n        },\n    }\n    self._add_to_layer_dict(layer_id, \"Markers\")\n    return layer_id\n</code></pre>"},{"location":"maplibre/#anymap_ts.maplibre.MapLibreMap.add_measure_control","title":"<code>add_measure_control(self, position='top-right', collapsed=True, default_mode='distance', distance_unit='kilometers', area_unit='square-kilometers', line_color='#3b82f6', fill_color='rgba(59, 130, 246, 0.2)', **kwargs)</code>","text":"<p>Add a measurement control for distances and areas.</p> <p>Provides tools for measuring distances (polylines) and areas (polygons) interactively on the map.</p> <p>Parameters:</p> Name Type Description Default <code>position</code> <code>str</code> <p>Control position ('top-left', 'top-right', 'bottom-left', 'bottom-right').</p> <code>'top-right'</code> <code>collapsed</code> <code>bool</code> <p>Whether the control starts collapsed.</p> <code>True</code> <code>default_mode</code> <code>str</code> <p>Default measurement mode ('distance' or 'area').</p> <code>'distance'</code> <code>distance_unit</code> <code>str</code> <p>Distance unit ('kilometers', 'miles', 'meters', 'feet', 'nautical-miles').</p> <code>'kilometers'</code> <code>area_unit</code> <code>str</code> <p>Area unit ('square-kilometers', 'square-miles', 'square-meters', 'hectares', 'acres').</p> <code>'square-kilometers'</code> <code>line_color</code> <code>str</code> <p>Line color for distance measurements.</p> <code>'#3b82f6'</code> <code>fill_color</code> <code>str</code> <p>Fill color for area measurements.</p> <code>'rgba(59, 130, 246, 0.2)'</code> <code>**kwargs</code> <p>Additional MeasureControl options.</p> <code>{}</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; m = Map()\n&gt;&gt;&gt; m.add_measure_control(\n...     default_mode=\"distance\",\n...     distance_unit=\"miles\",\n... )\n</code></pre> Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def add_measure_control(\n    self,\n    position: str = \"top-right\",\n    collapsed: bool = True,\n    default_mode: str = \"distance\",\n    distance_unit: str = \"kilometers\",\n    area_unit: str = \"square-kilometers\",\n    line_color: str = \"#3b82f6\",\n    fill_color: str = \"rgba(59, 130, 246, 0.2)\",\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a measurement control for distances and areas.\n\n    Provides tools for measuring distances (polylines) and areas\n    (polygons) interactively on the map.\n\n    Args:\n        position: Control position ('top-left', 'top-right',\n            'bottom-left', 'bottom-right').\n        collapsed: Whether the control starts collapsed.\n        default_mode: Default measurement mode ('distance' or 'area').\n        distance_unit: Distance unit ('kilometers', 'miles', 'meters',\n            'feet', 'nautical-miles').\n        area_unit: Area unit ('square-kilometers', 'square-miles',\n            'square-meters', 'hectares', 'acres').\n        line_color: Line color for distance measurements.\n        fill_color: Fill color for area measurements.\n        **kwargs: Additional MeasureControl options.\n\n    Example:\n        &gt;&gt;&gt; m = Map()\n        &gt;&gt;&gt; m.add_measure_control(\n        ...     default_mode=\"distance\",\n        ...     distance_unit=\"miles\",\n        ... )\n    \"\"\"\n    self._validate_position(position)\n    self.call_js_method(\n        \"addMeasureControl\",\n        position=position,\n        collapsed=collapsed,\n        defaultMode=default_mode,\n        distanceUnit=distance_unit,\n        areaUnit=area_unit,\n        lineColor=line_color,\n        fillColor=fill_color,\n        **kwargs,\n    )\n    self._controls = {\n        **self._controls,\n        \"measure-control\": {\n            \"type\": \"measure-control\",\n            \"position\": position,\n            \"collapsed\": collapsed,\n        },\n    }\n</code></pre>"},{"location":"maplibre/#anymap_ts.maplibre.MapLibreMap.add_opacity_slider","title":"<code>add_opacity_slider(self, layer_id, position='top-right', label=None)</code>","text":"<p>Add a UI slider to control layer opacity.</p> <p>Parameters:</p> Name Type Description Default <code>layer_id</code> <code>str</code> <p>Layer ID to control opacity for.</p> required <code>position</code> <code>str</code> <p>Control position.</p> <code>'top-right'</code> <code>label</code> <code>Optional[str]</code> <p>Label text. Defaults to layer_id.</p> <code>None</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; m = MapLibreMap()\n&gt;&gt;&gt; m.add_tile_layer(\"...\", name=\"satellite\")\n&gt;&gt;&gt; m.add_opacity_slider(\"satellite\")\n</code></pre> Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def add_opacity_slider(\n    self,\n    layer_id: str,\n    position: str = \"top-right\",\n    label: Optional[str] = None,\n) -&gt; None:\n    \"\"\"Add a UI slider to control layer opacity.\n\n    Args:\n        layer_id: Layer ID to control opacity for.\n        position: Control position.\n        label: Label text. Defaults to layer_id.\n\n    Example:\n        &gt;&gt;&gt; m = MapLibreMap()\n        &gt;&gt;&gt; m.add_tile_layer(\"...\", name=\"satellite\")\n        &gt;&gt;&gt; m.add_opacity_slider(\"satellite\")\n    \"\"\"\n    self.call_js_method(\n        \"addOpacitySlider\",\n        layerId=layer_id,\n        position=position,\n        label=label or layer_id,\n    )\n</code></pre>"},{"location":"maplibre/#anymap_ts.maplibre.MapLibreMap.add_path_layer","title":"<code>add_path_layer(self, data, name=None, get_path='path', get_color=None, get_width=1, width_scale=1, width_min_pixels=1, pickable=True, opacity=0.8, **kwargs)</code>","text":"<p>Add a path layer for route/trajectory rendering using deck.gl.</p> <p>Path layers render polylines defined by arrays of coordinates, ideal for visualizing routes, trajectories, or any line-based data.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>Array of data objects with path coordinates.</p> required <code>name</code> <code>Optional[str]</code> <p>Layer ID. If None, auto-generated.</p> <code>None</code> <code>get_path</code> <code>Union[str, Any]</code> <p>Accessor for path coordinates [[lng, lat], ...]. Can be a string (property name) or a value.</p> <code>'path'</code> <code>get_color</code> <code>Optional[Union[List[int], str]]</code> <p>Accessor for path color [r, g, b, a]. Default: [51, 136, 255, 200] (blue).</p> <code>None</code> <code>get_width</code> <code>Union[float, str]</code> <p>Accessor for path width in meters.</p> <code>1</code> <code>width_scale</code> <code>float</code> <p>Global width multiplier.</p> <code>1</code> <code>width_min_pixels</code> <code>float</code> <p>Minimum width in pixels.</p> <code>1</code> <code>pickable</code> <code>bool</code> <p>Whether layer responds to hover/click events.</p> <code>True</code> <code>opacity</code> <code>float</code> <p>Layer opacity (0-1).</p> <code>0.8</code> <code>**kwargs</code> <p>Additional PathLayer props.</p> <code>{}</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from anymap_ts import MapLibreMap\n&gt;&gt;&gt; m = MapLibreMap()\n&gt;&gt;&gt; routes = [\n...     {\"path\": [[-122.4, 37.8], [-122.5, 37.7], [-122.6, 37.8]]},\n... ]\n&gt;&gt;&gt; m.add_path_layer(routes, get_color=[255, 0, 0], get_width=3)\n</code></pre> Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def add_path_layer(\n    self,\n    data: Any,\n    name: Optional[str] = None,\n    get_path: Union[str, Any] = \"path\",\n    get_color: Optional[Union[List[int], str]] = None,\n    get_width: Union[float, str] = 1,\n    width_scale: float = 1,\n    width_min_pixels: float = 1,\n    pickable: bool = True,\n    opacity: float = 0.8,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a path layer for route/trajectory rendering using deck.gl.\n\n    Path layers render polylines defined by arrays of coordinates,\n    ideal for visualizing routes, trajectories, or any line-based data.\n\n    Args:\n        data: Array of data objects with path coordinates.\n        name: Layer ID. If None, auto-generated.\n        get_path: Accessor for path coordinates [[lng, lat], ...].\n            Can be a string (property name) or a value.\n        get_color: Accessor for path color [r, g, b, a].\n            Default: [51, 136, 255, 200] (blue).\n        get_width: Accessor for path width in meters.\n        width_scale: Global width multiplier.\n        width_min_pixels: Minimum width in pixels.\n        pickable: Whether layer responds to hover/click events.\n        opacity: Layer opacity (0-1).\n        **kwargs: Additional PathLayer props.\n\n    Example:\n        &gt;&gt;&gt; from anymap_ts import MapLibreMap\n        &gt;&gt;&gt; m = MapLibreMap()\n        &gt;&gt;&gt; routes = [\n        ...     {\"path\": [[-122.4, 37.8], [-122.5, 37.7], [-122.6, 37.8]]},\n        ... ]\n        &gt;&gt;&gt; m.add_path_layer(routes, get_color=[255, 0, 0], get_width=3)\n    \"\"\"\n    layer_id = name or f\"path-{len(self._layers)}\"\n    processed_data = self._process_deck_data(data)\n\n    self.call_js_method(\n        \"addPathLayer\",\n        id=layer_id,\n        data=processed_data,\n        getPath=get_path,\n        getColor=get_color or [51, 136, 255, 200],\n        getWidth=get_width,\n        widthScale=width_scale,\n        widthMinPixels=width_min_pixels,\n        pickable=pickable,\n        opacity=opacity,\n        **kwargs,\n    )\n\n    self._layers = {\n        **self._layers,\n        layer_id: {\n            \"id\": layer_id,\n            \"type\": \"path\",\n        },\n    }\n    self._add_to_layer_dict(layer_id, \"Deck.gl\")\n</code></pre>"},{"location":"maplibre/#anymap_ts.maplibre.MapLibreMap.add_pmtiles_control","title":"<code>add_pmtiles_control(self, position='top-right', collapsed=True, default_url=None, load_default_url=False, default_opacity=1.0, default_fill_color='steelblue', default_line_color='#333', default_pickable=True, **kwargs)</code>","text":"<p>Add a PMTiles layer control for loading PMTiles files via UI.</p> <p>This provides an interactive panel for users to enter PMTiles URLs and visualize vector or raster tile data.</p> <p>Parameters:</p> Name Type Description Default <code>position</code> <code>str</code> <p>Control position ('top-left', 'top-right', 'bottom-left', 'bottom-right').</p> <code>'top-right'</code> <code>collapsed</code> <code>bool</code> <p>Whether the panel starts collapsed.</p> <code>True</code> <code>default_url</code> <code>Optional[str]</code> <p>Default PMTiles URL to pre-fill.</p> <code>None</code> <code>load_default_url</code> <code>bool</code> <p>Whether to auto-load the default URL.</p> <code>False</code> <code>default_opacity</code> <code>float</code> <p>Default layer opacity (0-1).</p> <code>1.0</code> <code>default_fill_color</code> <code>str</code> <p>Default fill color for vector polygons.</p> <code>'steelblue'</code> <code>default_line_color</code> <code>str</code> <p>Default line color for vector lines.</p> <code>'#333'</code> <code>default_pickable</code> <code>bool</code> <p>Whether features are clickable by default.</p> <code>True</code> <code>**kwargs</code> <p>Additional control options.</p> <code>{}</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from anymap_ts import MapLibreMap\n&gt;&gt;&gt; m = MapLibreMap()\n&gt;&gt;&gt; m.add_pmtiles_control(\n...     default_url=\"https://pmtiles.io/protomaps(vector)ODbL_firenze.pmtiles\",\n...     load_default_url=True\n... )\n</code></pre> Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def add_pmtiles_control(\n    self,\n    position: str = \"top-right\",\n    collapsed: bool = True,\n    default_url: Optional[str] = None,\n    load_default_url: bool = False,\n    default_opacity: float = 1.0,\n    default_fill_color: str = \"steelblue\",\n    default_line_color: str = \"#333\",\n    default_pickable: bool = True,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a PMTiles layer control for loading PMTiles files via UI.\n\n    This provides an interactive panel for users to enter PMTiles URLs\n    and visualize vector or raster tile data.\n\n    Args:\n        position: Control position ('top-left', 'top-right', 'bottom-left', 'bottom-right').\n        collapsed: Whether the panel starts collapsed.\n        default_url: Default PMTiles URL to pre-fill.\n        load_default_url: Whether to auto-load the default URL.\n        default_opacity: Default layer opacity (0-1).\n        default_fill_color: Default fill color for vector polygons.\n        default_line_color: Default line color for vector lines.\n        default_pickable: Whether features are clickable by default.\n        **kwargs: Additional control options.\n\n    Example:\n        &gt;&gt;&gt; from anymap_ts import MapLibreMap\n        &gt;&gt;&gt; m = MapLibreMap()\n        &gt;&gt;&gt; m.add_pmtiles_control(\n        ...     default_url=\"https://pmtiles.io/protomaps(vector)ODbL_firenze.pmtiles\",\n        ...     load_default_url=True\n        ... )\n    \"\"\"\n    self.call_js_method(\n        \"addPMTilesControl\",\n        position=position,\n        collapsed=collapsed,\n        defaultUrl=default_url or \"\",\n        loadDefaultUrl=load_default_url,\n        defaultOpacity=default_opacity,\n        defaultFillColor=default_fill_color,\n        defaultLineColor=default_line_color,\n        defaultPickable=default_pickable,\n        **kwargs,\n    )\n    self._controls = {\n        **self._controls,\n        \"pmtiles-control\": {\"position\": position, \"collapsed\": collapsed},\n    }\n</code></pre>"},{"location":"maplibre/#anymap_ts.maplibre.MapLibreMap.add_pmtiles_layer","title":"<code>add_pmtiles_layer(self, url, layer_id=None, style=None, opacity=1.0, visible=True, fit_bounds=False, source_type='vector', **kwargs)</code>","text":"<p>Add a PMTiles layer for efficient vector or raster tile serving.</p> <p>PMTiles is a single-file archive format for pyramids of map tiles. It enables efficient web-native map serving without requiring a separate tile server infrastructure.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>URL to the PMTiles file (e.g., \"https://example.com/data.pmtiles\").</p> required <code>layer_id</code> <code>Optional[str]</code> <p>Layer identifier. If None, auto-generated.</p> <code>None</code> <code>style</code> <code>Optional[Dict[str, Any]]</code> <p>Layer style configuration for vector tiles. For vector PMTiles, can include: - type: Layer type ('fill', 'line', 'circle', 'symbol') - source-layer: Source layer name from vector tiles - paint properties (e.g., 'fill-color', 'line-width') - layout properties (e.g., 'visibility') Example: {\"type\": \"line\", \"source-layer\": \"roads\", \"line-color\": \"#ff0000\"}</p> <code>None</code> <code>opacity</code> <code>float</code> <p>Layer opacity (0-1).</p> <code>1.0</code> <code>visible</code> <code>bool</code> <p>Whether layer is initially visible.</p> <code>True</code> <code>fit_bounds</code> <code>bool</code> <p>Whether to fit map to layer bounds after loading.</p> <code>False</code> <code>source_type</code> <code>str</code> <p>Source type - \"vector\" for vector PMTiles, \"raster\" for raster PMTiles.</p> <code>'vector'</code> <code>**kwargs</code> <p>Additional layer options.</p> <code>{}</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from anymap_ts import Map\n&gt;&gt;&gt; m = Map()\n&gt;&gt;&gt; # Add vector PMTiles\n&gt;&gt;&gt; m.add_pmtiles_layer(\n...     url=\"https://example.com/countries.pmtiles\",\n...     layer_id=\"countries\",\n...     style={\n...         \"type\": \"fill\",\n...         \"source-layer\": \"countries\",\n...         \"fill-color\": \"#3388ff\",\n...         \"fill-opacity\": 0.6\n...     }\n... )\n&gt;&gt;&gt; # Add raster PMTiles\n&gt;&gt;&gt; m.add_pmtiles_layer(\n...     url=\"https://example.com/satellite.pmtiles\",\n...     layer_id=\"satellite\",\n...     source_type=\"raster\",\n...     opacity=0.8\n... )\n</code></pre> Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def add_pmtiles_layer(\n    self,\n    url: str,\n    layer_id: Optional[str] = None,\n    style: Optional[Dict[str, Any]] = None,\n    opacity: float = 1.0,\n    visible: bool = True,\n    fit_bounds: bool = False,\n    source_type: str = \"vector\",\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a PMTiles layer for efficient vector or raster tile serving.\n\n    PMTiles is a single-file archive format for pyramids of map tiles.\n    It enables efficient web-native map serving without requiring a\n    separate tile server infrastructure.\n\n    Args:\n        url: URL to the PMTiles file (e.g., \"https://example.com/data.pmtiles\").\n        layer_id: Layer identifier. If None, auto-generated.\n        style: Layer style configuration for vector tiles.\n            For vector PMTiles, can include:\n            - type: Layer type ('fill', 'line', 'circle', 'symbol')\n            - source-layer: Source layer name from vector tiles\n            - paint properties (e.g., 'fill-color', 'line-width')\n            - layout properties (e.g., 'visibility')\n            Example: {\"type\": \"line\", \"source-layer\": \"roads\", \"line-color\": \"#ff0000\"}\n        opacity: Layer opacity (0-1).\n        visible: Whether layer is initially visible.\n        fit_bounds: Whether to fit map to layer bounds after loading.\n        source_type: Source type - \"vector\" for vector PMTiles, \"raster\" for raster PMTiles.\n        **kwargs: Additional layer options.\n\n    Example:\n        &gt;&gt;&gt; from anymap_ts import Map\n        &gt;&gt;&gt; m = Map()\n        &gt;&gt;&gt; # Add vector PMTiles\n        &gt;&gt;&gt; m.add_pmtiles_layer(\n        ...     url=\"https://example.com/countries.pmtiles\",\n        ...     layer_id=\"countries\",\n        ...     style={\n        ...         \"type\": \"fill\",\n        ...         \"source-layer\": \"countries\",\n        ...         \"fill-color\": \"#3388ff\",\n        ...         \"fill-opacity\": 0.6\n        ...     }\n        ... )\n        &gt;&gt;&gt; # Add raster PMTiles\n        &gt;&gt;&gt; m.add_pmtiles_layer(\n        ...     url=\"https://example.com/satellite.pmtiles\",\n        ...     layer_id=\"satellite\",\n        ...     source_type=\"raster\",\n        ...     opacity=0.8\n        ... )\n    \"\"\"\n    layer_id = layer_id or f\"pmtiles-{len(self._layers)}\"\n\n    self.call_js_method(\n        \"addPMTilesLayer\",\n        url=url,\n        id=layer_id,\n        style=style or {},\n        opacity=opacity,\n        visible=visible,\n        fitBounds=fit_bounds,\n        sourceType=source_type,\n        name=layer_id,\n        **kwargs,\n    )\n\n    self._layers = {\n        **self._layers,\n        layer_id: {\n            \"id\": layer_id,\n            \"type\": \"pmtiles\",\n            \"url\": url,\n            \"source_type\": source_type,\n        },\n    }\n    category = \"Vector\" if source_type == \"vector\" else \"Raster\"\n    self._add_to_layer_dict(layer_id, category)\n</code></pre>"},{"location":"maplibre/#anymap_ts.maplibre.MapLibreMap.add_point_cloud_layer","title":"<code>add_point_cloud_layer(self, data, name=None, get_position='position', get_color=None, get_normal=None, point_size=2, size_units='pixels', pickable=True, opacity=1.0, material=True, coordinate_system=None, coordinate_origin=None, **kwargs)</code>","text":"<p>Add a point cloud layer for 3D point visualization using deck.gl.</p> <p>Point cloud layers render large collections of 3D points, ideal for LiDAR data, photogrammetry outputs, or any 3D point dataset.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>Array of point data with positions. Each point should have x, y, z coordinates (or position array).</p> required <code>name</code> <code>Optional[str]</code> <p>Layer ID. If None, auto-generated.</p> <code>None</code> <code>get_position</code> <code>Union[str, Any]</code> <p>Accessor for point position [x, y, z]. Can be a string (property name) or a value.</p> <code>'position'</code> <code>get_color</code> <code>Optional[Union[List[int], str]]</code> <p>Accessor or value for point color [r, g, b, a]. Default: [255, 255, 255, 255] (white).</p> <code>None</code> <code>get_normal</code> <code>Optional[Union[str, Any]]</code> <p>Accessor for point normal [nx, ny, nz] for lighting. Default: [0, 0, 1] (pointing up).</p> <code>None</code> <code>point_size</code> <code>float</code> <p>Point size in pixels or meters (depends on size_units).</p> <code>2</code> <code>size_units</code> <code>str</code> <p>Size units: 'pixels', 'meters', or 'common'.</p> <code>'pixels'</code> <code>pickable</code> <code>bool</code> <p>Whether layer responds to hover/click events.</p> <code>True</code> <code>opacity</code> <code>float</code> <p>Layer opacity (0-1).</p> <code>1.0</code> <code>material</code> <code>bool</code> <p>Whether to enable lighting effects.</p> <code>True</code> <code>coordinate_system</code> <code>Optional[int]</code> <p>Coordinate system for positions.</p> <code>None</code> <code>coordinate_origin</code> <code>Optional[List[float]]</code> <p>Origin for coordinate system [x, y, z].</p> <code>None</code> <code>**kwargs</code> <p>Additional PointCloudLayer props.</p> <code>{}</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from anymap_ts import MapLibreMap\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; m = MapLibreMap(pitch=45)\n&gt;&gt;&gt; points = [\n...     {\"position\": [-122.4, 37.8, 100], \"color\": [255, 0, 0, 255]},\n...     {\"position\": [-122.3, 37.7, 200], \"color\": [0, 255, 0, 255]},\n... ]\n&gt;&gt;&gt; m.add_point_cloud_layer(points, point_size=5)\n</code></pre> Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def add_point_cloud_layer(\n    self,\n    data: Any,\n    name: Optional[str] = None,\n    get_position: Union[str, Any] = \"position\",\n    get_color: Optional[Union[List[int], str]] = None,\n    get_normal: Optional[Union[str, Any]] = None,\n    point_size: float = 2,\n    size_units: str = \"pixels\",\n    pickable: bool = True,\n    opacity: float = 1.0,\n    material: bool = True,\n    coordinate_system: Optional[int] = None,\n    coordinate_origin: Optional[List[float]] = None,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a point cloud layer for 3D point visualization using deck.gl.\n\n    Point cloud layers render large collections of 3D points, ideal for\n    LiDAR data, photogrammetry outputs, or any 3D point dataset.\n\n    Args:\n        data: Array of point data with positions. Each point should have\n            x, y, z coordinates (or position array).\n        name: Layer ID. If None, auto-generated.\n        get_position: Accessor for point position [x, y, z].\n            Can be a string (property name) or a value.\n        get_color: Accessor or value for point color [r, g, b, a].\n            Default: [255, 255, 255, 255] (white).\n        get_normal: Accessor for point normal [nx, ny, nz] for lighting.\n            Default: [0, 0, 1] (pointing up).\n        point_size: Point size in pixels or meters (depends on size_units).\n        size_units: Size units: 'pixels', 'meters', or 'common'.\n        pickable: Whether layer responds to hover/click events.\n        opacity: Layer opacity (0-1).\n        material: Whether to enable lighting effects.\n        coordinate_system: Coordinate system for positions.\n        coordinate_origin: Origin for coordinate system [x, y, z].\n        **kwargs: Additional PointCloudLayer props.\n\n    Example:\n        &gt;&gt;&gt; from anymap_ts import MapLibreMap\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; m = MapLibreMap(pitch=45)\n        &gt;&gt;&gt; points = [\n        ...     {\"position\": [-122.4, 37.8, 100], \"color\": [255, 0, 0, 255]},\n        ...     {\"position\": [-122.3, 37.7, 200], \"color\": [0, 255, 0, 255]},\n        ... ]\n        &gt;&gt;&gt; m.add_point_cloud_layer(points, point_size=5)\n    \"\"\"\n    layer_id = name or f\"pointcloud-{len(self._layers)}\"\n    processed_data = self._process_deck_data(data)\n\n    self.call_js_method(\n        \"addPointCloudLayer\",\n        id=layer_id,\n        data=processed_data,\n        getPosition=get_position,\n        getColor=get_color or [255, 255, 255, 255],\n        getNormal=get_normal,\n        pointSize=point_size,\n        sizeUnits=size_units,\n        pickable=pickable,\n        opacity=opacity,\n        material=material,\n        coordinateSystem=coordinate_system,\n        coordinateOrigin=coordinate_origin,\n        **kwargs,\n    )\n\n    self._layers = {\n        **self._layers,\n        layer_id: {\n            \"id\": layer_id,\n            \"type\": \"pointcloud\",\n        },\n    }\n    self._add_to_layer_dict(layer_id, \"Deck.gl\")\n</code></pre>"},{"location":"maplibre/#anymap_ts.maplibre.MapLibreMap.add_polygon_layer","title":"<code>add_polygon_layer(self, data, name=None, get_polygon='polygon', get_fill_color=None, get_line_color=None, get_line_width=1, get_elevation=0, extruded=False, wireframe=False, filled=True, stroked=True, line_width_min_pixels=1, pickable=True, opacity=0.5, **kwargs)</code>","text":"<p>Add a polygon layer for filled polygon visualization using deck.gl.</p> <p>Polygon layers render filled and/or stroked polygons with optional 3D extrusion, ideal for choropleth maps and area visualizations.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>Array of data objects with polygon coordinates.</p> required <code>name</code> <code>Optional[str]</code> <p>Layer ID. If None, auto-generated.</p> <code>None</code> <code>get_polygon</code> <code>Union[str, Any]</code> <p>Accessor for polygon coordinates. Can be a string (property name) or a value.</p> <code>'polygon'</code> <code>get_fill_color</code> <code>Optional[Union[List[int], str]]</code> <p>Accessor for fill color [r, g, b, a]. Default: [51, 136, 255, 128].</p> <code>None</code> <code>get_line_color</code> <code>Optional[Union[List[int], str]]</code> <p>Accessor for stroke color [r, g, b, a]. Default: [0, 0, 255, 255].</p> <code>None</code> <code>get_line_width</code> <code>Union[float, str]</code> <p>Accessor for stroke width.</p> <code>1</code> <code>get_elevation</code> <code>Union[float, str]</code> <p>Accessor for 3D extrusion height.</p> <code>0</code> <code>extruded</code> <code>bool</code> <p>Whether to render as 3D polygons.</p> <code>False</code> <code>wireframe</code> <code>bool</code> <p>Whether to render wireframe (extruded only).</p> <code>False</code> <code>filled</code> <code>bool</code> <p>Whether to fill polygons.</p> <code>True</code> <code>stroked</code> <code>bool</code> <p>Whether to draw stroke.</p> <code>True</code> <code>line_width_min_pixels</code> <code>float</code> <p>Minimum stroke width in pixels.</p> <code>1</code> <code>pickable</code> <code>bool</code> <p>Whether layer responds to hover/click events.</p> <code>True</code> <code>opacity</code> <code>float</code> <p>Layer opacity (0-1).</p> <code>0.5</code> <code>**kwargs</code> <p>Additional PolygonLayer props.</p> <code>{}</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from anymap_ts import MapLibreMap\n&gt;&gt;&gt; m = MapLibreMap(pitch=45)\n&gt;&gt;&gt; polygons = [\n...     {\"polygon\": [[-122.4, 37.8], [-122.5, 37.7], [-122.3, 37.7]], \"height\": 1000},\n... ]\n&gt;&gt;&gt; m.add_polygon_layer(polygons, extruded=True, get_elevation=\"height\")\n</code></pre> Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def add_polygon_layer(\n    self,\n    data: Any,\n    name: Optional[str] = None,\n    get_polygon: Union[str, Any] = \"polygon\",\n    get_fill_color: Optional[Union[List[int], str]] = None,\n    get_line_color: Optional[Union[List[int], str]] = None,\n    get_line_width: Union[float, str] = 1,\n    get_elevation: Union[float, str] = 0,\n    extruded: bool = False,\n    wireframe: bool = False,\n    filled: bool = True,\n    stroked: bool = True,\n    line_width_min_pixels: float = 1,\n    pickable: bool = True,\n    opacity: float = 0.5,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a polygon layer for filled polygon visualization using deck.gl.\n\n    Polygon layers render filled and/or stroked polygons with optional\n    3D extrusion, ideal for choropleth maps and area visualizations.\n\n    Args:\n        data: Array of data objects with polygon coordinates.\n        name: Layer ID. If None, auto-generated.\n        get_polygon: Accessor for polygon coordinates.\n            Can be a string (property name) or a value.\n        get_fill_color: Accessor for fill color [r, g, b, a].\n            Default: [51, 136, 255, 128].\n        get_line_color: Accessor for stroke color [r, g, b, a].\n            Default: [0, 0, 255, 255].\n        get_line_width: Accessor for stroke width.\n        get_elevation: Accessor for 3D extrusion height.\n        extruded: Whether to render as 3D polygons.\n        wireframe: Whether to render wireframe (extruded only).\n        filled: Whether to fill polygons.\n        stroked: Whether to draw stroke.\n        line_width_min_pixels: Minimum stroke width in pixels.\n        pickable: Whether layer responds to hover/click events.\n        opacity: Layer opacity (0-1).\n        **kwargs: Additional PolygonLayer props.\n\n    Example:\n        &gt;&gt;&gt; from anymap_ts import MapLibreMap\n        &gt;&gt;&gt; m = MapLibreMap(pitch=45)\n        &gt;&gt;&gt; polygons = [\n        ...     {\"polygon\": [[-122.4, 37.8], [-122.5, 37.7], [-122.3, 37.7]], \"height\": 1000},\n        ... ]\n        &gt;&gt;&gt; m.add_polygon_layer(polygons, extruded=True, get_elevation=\"height\")\n    \"\"\"\n    layer_id = name or f\"polygon-{len(self._layers)}\"\n    processed_data = self._process_deck_data(data)\n\n    self.call_js_method(\n        \"addPolygonLayer\",\n        id=layer_id,\n        data=processed_data,\n        getPolygon=get_polygon,\n        getFillColor=get_fill_color or [51, 136, 255, 128],\n        getLineColor=get_line_color or [0, 0, 255, 255],\n        getLineWidth=get_line_width,\n        getElevation=get_elevation,\n        extruded=extruded,\n        wireframe=wireframe,\n        filled=filled,\n        stroked=stroked,\n        lineWidthMinPixels=line_width_min_pixels,\n        pickable=pickable,\n        opacity=opacity,\n        **kwargs,\n    )\n\n    self._layers = {\n        **self._layers,\n        layer_id: {\n            \"id\": layer_id,\n            \"type\": \"polygon\",\n        },\n    }\n    self._add_to_layer_dict(layer_id, \"Deck.gl\")\n</code></pre>"},{"location":"maplibre/#anymap_ts.maplibre.MapLibreMap.add_popup","title":"<code>add_popup(self, layer_id, properties=None, template=None, **kwargs)</code>","text":"<p>Add popup on click for a layer.</p> <p>Configures a layer to show a popup when features are clicked.</p> <p>Parameters:</p> Name Type Description Default <code>layer_id</code> <code>str</code> <p>Layer identifier to add popup to.</p> required <code>properties</code> <code>Optional[List[str]]</code> <p>List of property names to display. If None, shows all.</p> <code>None</code> <code>template</code> <code>Optional[str]</code> <p>Custom HTML template for popup content. Use {property_name} placeholders for values. If None, auto-generates table.</p> <code>None</code> <code>**kwargs</code> <p>Additional popup options (maxWidth, closeButton, etc.).</p> <code>{}</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; m.add_vector(geojson, name=\"cities\")\n&gt;&gt;&gt; m.add_popup(\"cities\", properties=[\"name\", \"population\"])\n&gt;&gt;&gt; # Or with custom template:\n&gt;&gt;&gt; m.add_popup(\"cities\", template=\"&lt;h3&gt;{name}&lt;/h3&gt;&lt;p&gt;Pop: {population}&lt;/p&gt;\")\n</code></pre> Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def add_popup(\n    self,\n    layer_id: str,\n    properties: Optional[List[str]] = None,\n    template: Optional[str] = None,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add popup on click for a layer.\n\n    Configures a layer to show a popup when features are clicked.\n\n    Args:\n        layer_id: Layer identifier to add popup to.\n        properties: List of property names to display. If None, shows all.\n        template: Custom HTML template for popup content. Use {property_name}\n            placeholders for values. If None, auto-generates table.\n        **kwargs: Additional popup options (maxWidth, closeButton, etc.).\n\n    Example:\n        &gt;&gt;&gt; m.add_vector(geojson, name=\"cities\")\n        &gt;&gt;&gt; m.add_popup(\"cities\", properties=[\"name\", \"population\"])\n        &gt;&gt;&gt; # Or with custom template:\n        &gt;&gt;&gt; m.add_popup(\"cities\", template=\"&lt;h3&gt;{name}&lt;/h3&gt;&lt;p&gt;Pop: {population}&lt;/p&gt;\")\n    \"\"\"\n    self.call_js_method(\n        \"addPopup\",\n        layerId=layer_id,\n        properties=properties,\n        template=template,\n        **kwargs,\n    )\n</code></pre>"},{"location":"maplibre/#anymap_ts.maplibre.MapLibreMap.add_print_control","title":"<code>add_print_control(self, position='top-right', collapsed=True, format='png', filename='map-export', include_north_arrow=False, include_scale_bar=False, **kwargs)</code>","text":"<p>Add a print/export control for saving the map as an image.</p> <p>Provides an interactive panel for exporting the current map view as PNG, JPEG, or PDF files.</p> <p>Parameters:</p> Name Type Description Default <code>position</code> <code>str</code> <p>Control position ('top-left', 'top-right', 'bottom-left', 'bottom-right').</p> <code>'top-right'</code> <code>collapsed</code> <code>bool</code> <p>Whether the control starts collapsed.</p> <code>True</code> <code>format</code> <code>str</code> <p>Default image format ('png', 'jpeg', 'pdf').</p> <code>'png'</code> <code>filename</code> <code>str</code> <p>Default filename (without extension).</p> <code>'map-export'</code> <code>include_north_arrow</code> <code>bool</code> <p>Whether to include a north arrow by default.</p> <code>False</code> <code>include_scale_bar</code> <code>bool</code> <p>Whether to include a scale bar by default.</p> <code>False</code> <code>**kwargs</code> <p>Additional PrintControl options.</p> <code>{}</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; m = Map()\n&gt;&gt;&gt; m.add_print_control(\n...     format=\"png\",\n...     filename=\"my-map\",\n...     include_scale_bar=True,\n... )\n</code></pre> Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def add_print_control(\n    self,\n    position: str = \"top-right\",\n    collapsed: bool = True,\n    format: str = \"png\",\n    filename: str = \"map-export\",\n    include_north_arrow: bool = False,\n    include_scale_bar: bool = False,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a print/export control for saving the map as an image.\n\n    Provides an interactive panel for exporting the current map view\n    as PNG, JPEG, or PDF files.\n\n    Args:\n        position: Control position ('top-left', 'top-right',\n            'bottom-left', 'bottom-right').\n        collapsed: Whether the control starts collapsed.\n        format: Default image format ('png', 'jpeg', 'pdf').\n        filename: Default filename (without extension).\n        include_north_arrow: Whether to include a north arrow by default.\n        include_scale_bar: Whether to include a scale bar by default.\n        **kwargs: Additional PrintControl options.\n\n    Example:\n        &gt;&gt;&gt; m = Map()\n        &gt;&gt;&gt; m.add_print_control(\n        ...     format=\"png\",\n        ...     filename=\"my-map\",\n        ...     include_scale_bar=True,\n        ... )\n    \"\"\"\n    self._validate_position(position)\n    self.call_js_method(\n        \"addPrintControl\",\n        position=position,\n        collapsed=collapsed,\n        format=format,\n        filename=filename,\n        includeNorthArrow=include_north_arrow,\n        includeScaleBar=include_scale_bar,\n        **kwargs,\n    )\n    self._controls = {\n        **self._controls,\n        \"print-control\": {\n            \"type\": \"print-control\",\n            \"position\": position,\n            \"collapsed\": collapsed,\n        },\n    }\n</code></pre>"},{"location":"maplibre/#anymap_ts.maplibre.MapLibreMap.add_raster","title":"<code>add_raster(self, source, name=None, attribution='', indexes=None, colormap=None, vmin=None, vmax=None, nodata=None, fit_bounds=True, **kwargs)</code>","text":"<p>Add a raster layer from a local file using localtileserver.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>str</code> <p>Path to local raster file</p> required <code>name</code> <code>Optional[str]</code> <p>Layer name</p> <code>None</code> <code>attribution</code> <code>str</code> <p>Attribution text</p> <code>''</code> <code>indexes</code> <code>Optional[List[int]]</code> <p>Band indexes to use</p> <code>None</code> <code>colormap</code> <code>Optional[str]</code> <p>Colormap name</p> <code>None</code> <code>vmin</code> <code>Optional[float]</code> <p>Minimum value for colormap</p> <code>None</code> <code>vmax</code> <code>Optional[float]</code> <p>Maximum value for colormap</p> <code>None</code> <code>nodata</code> <code>Optional[float]</code> <p>NoData value</p> <code>None</code> <code>fit_bounds</code> <code>bool</code> <p>Whether to fit map to raster bounds</p> <code>True</code> <code>**kwargs</code> <p>Additional options</p> <code>{}</code> Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def add_raster(\n    self,\n    source: str,\n    name: Optional[str] = None,\n    attribution: str = \"\",\n    indexes: Optional[List[int]] = None,\n    colormap: Optional[str] = None,\n    vmin: Optional[float] = None,\n    vmax: Optional[float] = None,\n    nodata: Optional[float] = None,\n    fit_bounds: bool = True,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a raster layer from a local file using localtileserver.\n\n    Args:\n        source: Path to local raster file\n        name: Layer name\n        attribution: Attribution text\n        indexes: Band indexes to use\n        colormap: Colormap name\n        vmin: Minimum value for colormap\n        vmax: Maximum value for colormap\n        nodata: NoData value\n        fit_bounds: Whether to fit map to raster bounds\n        **kwargs: Additional options\n    \"\"\"\n    try:\n        from localtileserver import TileClient\n    except ImportError:\n        raise ImportError(\n            \"localtileserver is required for local raster support. \"\n            \"Install with: pip install anymap-ts[raster]\"\n        )\n\n    client = TileClient(source)\n\n    # Build parameters dict and pass all at once\n    tile_params = {}\n    if indexes:\n        tile_params[\"indexes\"] = indexes\n    if colormap:\n        tile_params[\"colormap\"] = colormap\n    if vmin is not None or vmax is not None:\n        tile_params[\"vmin\"] = vmin if vmin is not None else client.min\n        tile_params[\"vmax\"] = vmax if vmax is not None else client.max\n    if nodata is not None:\n        tile_params[\"nodata\"] = nodata\n\n    tile_url = client.get_tile_url(**tile_params)\n\n    layer_name = name or Path(source).stem\n\n    self.add_tile_layer(\n        tile_url,\n        name=layer_name,\n        attribution=attribution,\n        **kwargs,\n    )\n\n    # Fit bounds if requested\n    if fit_bounds:\n        bounds = client.bounds()\n        if bounds:\n            self.fit_bounds([bounds[0], bounds[1], bounds[2], bounds[3]])\n</code></pre>"},{"location":"maplibre/#anymap_ts.maplibre.MapLibreMap.add_scatterplot_layer","title":"<code>add_scatterplot_layer(self, data, name=None, get_position='coordinates', get_radius=5, get_fill_color=None, get_line_color=None, radius_scale=1, radius_min_pixels=1, radius_max_pixels=100, line_width_min_pixels=1, stroked=True, filled=True, pickable=True, opacity=0.8, **kwargs)</code>","text":"<p>Add a scatterplot layer for sized/colored point visualization using deck.gl.</p> <p>Scatterplot layers render circles at given coordinates with configurable radius and color, ideal for point datasets where size and color encode data.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>Array of data objects or GeoJSON with point coordinates.</p> required <code>name</code> <code>Optional[str]</code> <p>Layer ID. If None, auto-generated.</p> <code>None</code> <code>get_position</code> <code>Union[str, Any]</code> <p>Accessor for point position [lng, lat]. Can be a string (property name) or a value.</p> <code>'coordinates'</code> <code>get_radius</code> <code>Union[float, str]</code> <p>Accessor for point radius in meters.</p> <code>5</code> <code>get_fill_color</code> <code>Optional[Union[List[int], str]]</code> <p>Accessor for fill color [r, g, b, a]. Default: [51, 136, 255, 200] (blue).</p> <code>None</code> <code>get_line_color</code> <code>Optional[Union[List[int], str]]</code> <p>Accessor for stroke color [r, g, b, a]. Default: [255, 255, 255, 255] (white).</p> <code>None</code> <code>radius_scale</code> <code>float</code> <p>Global radius multiplier.</p> <code>1</code> <code>radius_min_pixels</code> <code>float</code> <p>Minimum radius in pixels.</p> <code>1</code> <code>radius_max_pixels</code> <code>float</code> <p>Maximum radius in pixels.</p> <code>100</code> <code>line_width_min_pixels</code> <code>float</code> <p>Minimum stroke width in pixels.</p> <code>1</code> <code>stroked</code> <code>bool</code> <p>Whether to draw stroke around points.</p> <code>True</code> <code>filled</code> <code>bool</code> <p>Whether to fill points.</p> <code>True</code> <code>pickable</code> <code>bool</code> <p>Whether layer responds to hover/click events.</p> <code>True</code> <code>opacity</code> <code>float</code> <p>Layer opacity (0-1).</p> <code>0.8</code> <code>**kwargs</code> <p>Additional ScatterplotLayer props.</p> <code>{}</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from anymap_ts import MapLibreMap\n&gt;&gt;&gt; m = MapLibreMap()\n&gt;&gt;&gt; points = [\n...     {\"coordinates\": [-122.4, 37.8], \"size\": 100},\n...     {\"coordinates\": [-122.5, 37.7], \"size\": 200},\n... ]\n&gt;&gt;&gt; m.add_scatterplot_layer(points, get_radius=\"size\")\n</code></pre> Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def add_scatterplot_layer(\n    self,\n    data: Any,\n    name: Optional[str] = None,\n    get_position: Union[str, Any] = \"coordinates\",\n    get_radius: Union[float, str] = 5,\n    get_fill_color: Optional[Union[List[int], str]] = None,\n    get_line_color: Optional[Union[List[int], str]] = None,\n    radius_scale: float = 1,\n    radius_min_pixels: float = 1,\n    radius_max_pixels: float = 100,\n    line_width_min_pixels: float = 1,\n    stroked: bool = True,\n    filled: bool = True,\n    pickable: bool = True,\n    opacity: float = 0.8,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a scatterplot layer for sized/colored point visualization using deck.gl.\n\n    Scatterplot layers render circles at given coordinates with configurable\n    radius and color, ideal for point datasets where size and color encode data.\n\n    Args:\n        data: Array of data objects or GeoJSON with point coordinates.\n        name: Layer ID. If None, auto-generated.\n        get_position: Accessor for point position [lng, lat].\n            Can be a string (property name) or a value.\n        get_radius: Accessor for point radius in meters.\n        get_fill_color: Accessor for fill color [r, g, b, a].\n            Default: [51, 136, 255, 200] (blue).\n        get_line_color: Accessor for stroke color [r, g, b, a].\n            Default: [255, 255, 255, 255] (white).\n        radius_scale: Global radius multiplier.\n        radius_min_pixels: Minimum radius in pixels.\n        radius_max_pixels: Maximum radius in pixels.\n        line_width_min_pixels: Minimum stroke width in pixels.\n        stroked: Whether to draw stroke around points.\n        filled: Whether to fill points.\n        pickable: Whether layer responds to hover/click events.\n        opacity: Layer opacity (0-1).\n        **kwargs: Additional ScatterplotLayer props.\n\n    Example:\n        &gt;&gt;&gt; from anymap_ts import MapLibreMap\n        &gt;&gt;&gt; m = MapLibreMap()\n        &gt;&gt;&gt; points = [\n        ...     {\"coordinates\": [-122.4, 37.8], \"size\": 100},\n        ...     {\"coordinates\": [-122.5, 37.7], \"size\": 200},\n        ... ]\n        &gt;&gt;&gt; m.add_scatterplot_layer(points, get_radius=\"size\")\n    \"\"\"\n    layer_id = name or f\"scatterplot-{len(self._layers)}\"\n    processed_data = self._process_deck_data(data)\n\n    self.call_js_method(\n        \"addScatterplotLayer\",\n        id=layer_id,\n        data=processed_data,\n        getPosition=get_position,\n        getRadius=get_radius,\n        getFillColor=get_fill_color or [51, 136, 255, 200],\n        getLineColor=get_line_color or [255, 255, 255, 255],\n        radiusScale=radius_scale,\n        radiusMinPixels=radius_min_pixels,\n        radiusMaxPixels=radius_max_pixels,\n        lineWidthMinPixels=line_width_min_pixels,\n        stroked=stroked,\n        filled=filled,\n        pickable=pickable,\n        opacity=opacity,\n        **kwargs,\n    )\n\n    self._layers = {\n        **self._layers,\n        layer_id: {\n            \"id\": layer_id,\n            \"type\": \"scatterplot\",\n        },\n    }\n    self._add_to_layer_dict(layer_id, \"Deck.gl\")\n</code></pre>"},{"location":"maplibre/#anymap_ts.maplibre.MapLibreMap.add_screen_grid_layer","title":"<code>add_screen_grid_layer(self, data, name=None, get_position='coordinates', get_weight=1, cell_size_pixels=50, color_range=None, pickable=True, opacity=0.8, **kwargs)</code>","text":"<p>Add a screen grid layer for screen-space grid aggregation using deck.gl.</p> <p>Screen grid layers aggregate points into a grid in screen space, providing a fast overview of point density that updates on zoom/pan.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>Array of data objects with position coordinates.</p> required <code>name</code> <code>Optional[str]</code> <p>Layer ID. If None, auto-generated.</p> <code>None</code> <code>get_position</code> <code>Union[str, Any]</code> <p>Accessor for point position [lng, lat].</p> <code>'coordinates'</code> <code>get_weight</code> <code>Union[float, str]</code> <p>Accessor for point weight value.</p> <code>1</code> <code>cell_size_pixels</code> <code>float</code> <p>Grid cell size in screen pixels.</p> <code>50</code> <code>color_range</code> <code>Optional[List[List[int]]]</code> <p>Color gradient [[r, g, b, a], ...].</p> <code>None</code> <code>pickable</code> <code>bool</code> <p>Whether layer responds to hover/click events.</p> <code>True</code> <code>opacity</code> <code>float</code> <p>Layer opacity (0-1).</p> <code>0.8</code> <code>**kwargs</code> <p>Additional ScreenGridLayer props.</p> <code>{}</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from anymap_ts import MapLibreMap\n&gt;&gt;&gt; m = MapLibreMap()\n&gt;&gt;&gt; points = [\n...     {\"coordinates\": [-122.4, 37.8]},\n...     {\"coordinates\": [-122.41, 37.81]},\n... ]\n&gt;&gt;&gt; m.add_screen_grid_layer(points, cell_size_pixels=30)\n</code></pre> Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def add_screen_grid_layer(\n    self,\n    data: Any,\n    name: Optional[str] = None,\n    get_position: Union[str, Any] = \"coordinates\",\n    get_weight: Union[float, str] = 1,\n    cell_size_pixels: float = 50,\n    color_range: Optional[List[List[int]]] = None,\n    pickable: bool = True,\n    opacity: float = 0.8,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a screen grid layer for screen-space grid aggregation using deck.gl.\n\n    Screen grid layers aggregate points into a grid in screen space,\n    providing a fast overview of point density that updates on zoom/pan.\n\n    Args:\n        data: Array of data objects with position coordinates.\n        name: Layer ID. If None, auto-generated.\n        get_position: Accessor for point position [lng, lat].\n        get_weight: Accessor for point weight value.\n        cell_size_pixels: Grid cell size in screen pixels.\n        color_range: Color gradient [[r, g, b, a], ...].\n        pickable: Whether layer responds to hover/click events.\n        opacity: Layer opacity (0-1).\n        **kwargs: Additional ScreenGridLayer props.\n\n    Example:\n        &gt;&gt;&gt; from anymap_ts import MapLibreMap\n        &gt;&gt;&gt; m = MapLibreMap()\n        &gt;&gt;&gt; points = [\n        ...     {\"coordinates\": [-122.4, 37.8]},\n        ...     {\"coordinates\": [-122.41, 37.81]},\n        ... ]\n        &gt;&gt;&gt; m.add_screen_grid_layer(points, cell_size_pixels=30)\n    \"\"\"\n    layer_id = name or f\"screengrid-{len(self._layers)}\"\n    processed_data = self._process_deck_data(data)\n\n    default_color_range = [\n        [255, 255, 178, 25],\n        [254, 217, 118, 85],\n        [254, 178, 76, 127],\n        [253, 141, 60, 170],\n        [240, 59, 32, 212],\n        [189, 0, 38, 255],\n    ]\n\n    self.call_js_method(\n        \"addScreenGridLayer\",\n        id=layer_id,\n        data=processed_data,\n        getPosition=get_position,\n        getWeight=get_weight,\n        cellSizePixels=cell_size_pixels,\n        colorRange=color_range or default_color_range,\n        pickable=pickable,\n        opacity=opacity,\n        **kwargs,\n    )\n\n    self._layers = {\n        **self._layers,\n        layer_id: {\n            \"id\": layer_id,\n            \"type\": \"screengrid\",\n        },\n    }\n    self._add_to_layer_dict(layer_id, \"Deck.gl\")\n</code></pre>"},{"location":"maplibre/#anymap_ts.maplibre.MapLibreMap.add_search_control","title":"<code>add_search_control(self, position='top-left', placeholder='Search places...', collapsed=True, fly_to_zoom=14, show_marker=True, marker_color='#4264fb', **kwargs)</code>","text":"<p>Add a search/geocoder control using Nominatim.</p> <p>Provides place search functionality with autocomplete results. Results are geocoded via OpenStreetMap Nominatim service.</p> <p>Parameters:</p> Name Type Description Default <code>position</code> <code>str</code> <p>Control position ('top-left', 'top-right', 'bottom-left', 'bottom-right').</p> <code>'top-left'</code> <code>placeholder</code> <code>str</code> <p>Placeholder text for the search input.</p> <code>'Search places...'</code> <code>collapsed</code> <code>bool</code> <p>Whether the control starts collapsed (icon only).</p> <code>True</code> <code>fly_to_zoom</code> <code>int</code> <p>Zoom level to fly to when selecting a result.</p> <code>14</code> <code>show_marker</code> <code>bool</code> <p>Whether to add a marker at the selected location.</p> <code>True</code> <code>marker_color</code> <code>str</code> <p>Color of the result marker.</p> <code>'#4264fb'</code> <code>**kwargs</code> <p>Additional SearchControl options.</p> <code>{}</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; m = Map()\n&gt;&gt;&gt; m.add_search_control(position=\"top-left\", fly_to_zoom=12)\n</code></pre> Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def add_search_control(\n    self,\n    position: str = \"top-left\",\n    placeholder: str = \"Search places...\",\n    collapsed: bool = True,\n    fly_to_zoom: int = 14,\n    show_marker: bool = True,\n    marker_color: str = \"#4264fb\",\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a search/geocoder control using Nominatim.\n\n    Provides place search functionality with autocomplete results.\n    Results are geocoded via OpenStreetMap Nominatim service.\n\n    Args:\n        position: Control position ('top-left', 'top-right',\n            'bottom-left', 'bottom-right').\n        placeholder: Placeholder text for the search input.\n        collapsed: Whether the control starts collapsed (icon only).\n        fly_to_zoom: Zoom level to fly to when selecting a result.\n        show_marker: Whether to add a marker at the selected location.\n        marker_color: Color of the result marker.\n        **kwargs: Additional SearchControl options.\n\n    Example:\n        &gt;&gt;&gt; m = Map()\n        &gt;&gt;&gt; m.add_search_control(position=\"top-left\", fly_to_zoom=12)\n    \"\"\"\n    self._validate_position(position)\n    self.call_js_method(\n        \"addSearchControl\",\n        position=position,\n        placeholder=placeholder,\n        collapsed=collapsed,\n        flyToZoom=fly_to_zoom,\n        showMarker=show_marker,\n        markerColor=marker_color,\n        **kwargs,\n    )\n    self._controls = {\n        **self._controls,\n        \"search-control\": {\n            \"type\": \"search-control\",\n            \"position\": position,\n            \"collapsed\": collapsed,\n        },\n    }\n</code></pre>"},{"location":"maplibre/#anymap_ts.maplibre.MapLibreMap.add_solid_polygon_layer","title":"<code>add_solid_polygon_layer(self, data, name=None, get_polygon='polygon', get_fill_color=None, get_line_color=None, get_elevation=0, filled=True, extruded=False, wireframe=False, elevation_scale=1, pickable=True, opacity=0.8, **kwargs)</code>","text":"<p>Add a solid polygon layer for extruded 3D polygon visualization using deck.gl.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>Array of data objects with polygon coordinates.</p> required <code>name</code> <code>Optional[str]</code> <p>Layer ID. If None, auto-generated.</p> <code>None</code> <code>get_polygon</code> <code>Union[str, Any]</code> <p>Accessor for polygon coordinates.</p> <code>'polygon'</code> <code>get_fill_color</code> <code>Optional[Union[List[int], str]]</code> <p>Accessor for fill color [r, g, b, a].</p> <code>None</code> <code>get_line_color</code> <code>Optional[Union[List[int], str]]</code> <p>Accessor for stroke color [r, g, b, a].</p> <code>None</code> <code>get_elevation</code> <code>Union[float, str]</code> <p>Accessor for 3D extrusion height.</p> <code>0</code> <code>filled</code> <code>bool</code> <p>Whether to fill polygons.</p> <code>True</code> <code>extruded</code> <code>bool</code> <p>Whether to render as 3D polygons.</p> <code>False</code> <code>wireframe</code> <code>bool</code> <p>Whether to render wireframe.</p> <code>False</code> <code>elevation_scale</code> <code>float</code> <p>Elevation multiplier.</p> <code>1</code> <code>pickable</code> <code>bool</code> <p>Whether layer responds to hover/click events.</p> <code>True</code> <code>opacity</code> <code>float</code> <p>Layer opacity (0-1).</p> <code>0.8</code> <code>**kwargs</code> <p>Additional SolidPolygonLayer props.</p> <code>{}</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from anymap_ts import MapLibreMap\n&gt;&gt;&gt; m = MapLibreMap(pitch=45)\n&gt;&gt;&gt; data = [\n...     {\"polygon\": [[-122.4, 37.8], [-122.5, 37.7], [-122.3, 37.7]], \"height\": 500},\n... ]\n&gt;&gt;&gt; m.add_solid_polygon_layer(data, extruded=True, get_elevation=\"height\")\n</code></pre> Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def add_solid_polygon_layer(\n    self,\n    data: Any,\n    name: Optional[str] = None,\n    get_polygon: Union[str, Any] = \"polygon\",\n    get_fill_color: Optional[Union[List[int], str]] = None,\n    get_line_color: Optional[Union[List[int], str]] = None,\n    get_elevation: Union[float, str] = 0,\n    filled: bool = True,\n    extruded: bool = False,\n    wireframe: bool = False,\n    elevation_scale: float = 1,\n    pickable: bool = True,\n    opacity: float = 0.8,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a solid polygon layer for extruded 3D polygon visualization using deck.gl.\n\n    Args:\n        data: Array of data objects with polygon coordinates.\n        name: Layer ID. If None, auto-generated.\n        get_polygon: Accessor for polygon coordinates.\n        get_fill_color: Accessor for fill color [r, g, b, a].\n        get_line_color: Accessor for stroke color [r, g, b, a].\n        get_elevation: Accessor for 3D extrusion height.\n        filled: Whether to fill polygons.\n        extruded: Whether to render as 3D polygons.\n        wireframe: Whether to render wireframe.\n        elevation_scale: Elevation multiplier.\n        pickable: Whether layer responds to hover/click events.\n        opacity: Layer opacity (0-1).\n        **kwargs: Additional SolidPolygonLayer props.\n\n    Example:\n        &gt;&gt;&gt; from anymap_ts import MapLibreMap\n        &gt;&gt;&gt; m = MapLibreMap(pitch=45)\n        &gt;&gt;&gt; data = [\n        ...     {\"polygon\": [[-122.4, 37.8], [-122.5, 37.7], [-122.3, 37.7]], \"height\": 500},\n        ... ]\n        &gt;&gt;&gt; m.add_solid_polygon_layer(data, extruded=True, get_elevation=\"height\")\n    \"\"\"\n    layer_id = name or f\"solidpolygon-{len(self._layers)}\"\n    processed_data = self._process_deck_data(data)\n\n    self.call_js_method(\n        \"addSolidPolygonLayer\",\n        id=layer_id,\n        data=processed_data,\n        getPolygon=get_polygon,\n        getFillColor=get_fill_color or [51, 136, 255, 128],\n        getLineColor=get_line_color or [0, 0, 0, 255],\n        getElevation=get_elevation,\n        filled=filled,\n        extruded=extruded,\n        wireframe=wireframe,\n        elevationScale=elevation_scale,\n        pickable=pickable,\n        opacity=opacity,\n        **kwargs,\n    )\n\n    self._layers = {\n        **self._layers,\n        layer_id: {\"id\": layer_id, \"type\": \"solidpolygon\"},\n    }\n    self._add_to_layer_dict(layer_id, \"Deck.gl\")\n</code></pre>"},{"location":"maplibre/#anymap_ts.maplibre.MapLibreMap.add_split_map","title":"<code>add_split_map(self, left_layer, right_layer, position=50)</code>","text":"<p>Add a split map comparison view with a draggable divider.</p> <p>Creates a side-by-side comparison of two layers. The left side shows the left layer and the right side shows the right layer, with a draggable slider to adjust the split position.</p> <p>Parameters:</p> Name Type Description Default <code>left_layer</code> <code>str</code> <p>Layer ID for the left side.</p> required <code>right_layer</code> <code>str</code> <p>Layer ID for the right side.</p> required <code>position</code> <code>int</code> <p>Initial slider position as percentage (0-100). Default is 50 (middle).</p> <code>50</code> <p>Note</p> <p>Both layers must exist on the map before calling this method. Best suited for raster tile layers (e.g., satellite vs streets).</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; m.add_tile_layer(\n...     \"https://mt1.google.com/vt/lyrs=s&amp;x={x}&amp;y={y}&amp;z={z}\",\n...     name=\"satellite\",\n... )\n&gt;&gt;&gt; m.add_tile_layer(\n...     \"https://tile.openstreetmap.org/{z}/{x}/{y}.png\",\n...     name=\"osm\",\n... )\n&gt;&gt;&gt; m.add_split_map(\"satellite\", \"osm\")\n</code></pre> Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def add_split_map(\n    self,\n    left_layer: str,\n    right_layer: str,\n    position: int = 50,\n) -&gt; None:\n    \"\"\"Add a split map comparison view with a draggable divider.\n\n    Creates a side-by-side comparison of two layers. The left side shows\n    the left layer and the right side shows the right layer, with a\n    draggable slider to adjust the split position.\n\n    Args:\n        left_layer: Layer ID for the left side.\n        right_layer: Layer ID for the right side.\n        position: Initial slider position as percentage (0-100).\n            Default is 50 (middle).\n\n    Note:\n        Both layers must exist on the map before calling this method.\n        Best suited for raster tile layers (e.g., satellite vs streets).\n\n    Example:\n        &gt;&gt;&gt; m.add_tile_layer(\n        ...     \"https://mt1.google.com/vt/lyrs=s&amp;x={x}&amp;y={y}&amp;z={z}\",\n        ...     name=\"satellite\",\n        ... )\n        &gt;&gt;&gt; m.add_tile_layer(\n        ...     \"https://tile.openstreetmap.org/{z}/{x}/{y}.png\",\n        ...     name=\"osm\",\n        ... )\n        &gt;&gt;&gt; m.add_split_map(\"satellite\", \"osm\")\n    \"\"\"\n    if not 0 &lt;= position &lt;= 100:\n        raise ValueError(f\"position must be between 0 and 100, got {position}\")\n\n    self.call_js_method(\n        \"addSplitMap\",\n        leftLayer=left_layer,\n        rightLayer=right_layer,\n        position=position,\n    )\n</code></pre>"},{"location":"maplibre/#anymap_ts.maplibre.MapLibreMap.add_stac_layer","title":"<code>add_stac_layer(self, url=None, item=None, assets=None, colormap=None, rescale=None, opacity=1.0, layer_id=None, titiler_endpoint='https://titiler.xyz', attribution='STAC', fit_bounds=True, **kwargs)</code>","text":"<p>Add a STAC (SpatioTemporal Asset Catalog) layer to the map.</p> <p>Uses TiTiler to render STAC items as XYZ tiles on the map. Supports both STAC item URLs and pystac Item objects.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>Optional[str]</code> <p>URL to a STAC item JSON</p> <code>None</code> <code>item</code> <code>Optional[Any]</code> <p>A pystac Item object</p> <code>None</code> <code>assets</code> <code>Optional[List[str]]</code> <p>List of asset names/bands to visualize</p> <code>None</code> <code>colormap</code> <code>Optional[str]</code> <p>Colormap name (e.g., 'viridis', 'plasma', 'inferno')</p> <code>None</code> <code>rescale</code> <code>Optional[List[float]]</code> <p>Min/max values for rescaling as [min, max]</p> <code>None</code> <code>opacity</code> <code>float</code> <p>Layer opacity (0-1)</p> <code>1.0</code> <code>layer_id</code> <code>Optional[str]</code> <p>Custom layer identifier</p> <code>None</code> <code>titiler_endpoint</code> <code>str</code> <p>TiTiler server endpoint URL</p> <code>'https://titiler.xyz'</code> <code>attribution</code> <code>str</code> <p>Attribution text for the layer</p> <code>'STAC'</code> <code>fit_bounds</code> <code>bool</code> <p>Whether to fit map to STAC item bounds</p> <code>True</code> <code>**kwargs</code> <p>Additional tile layer options</p> <code>{}</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from anymap_ts import Map\n&gt;&gt;&gt; m = Map()\n&gt;&gt;&gt; # From URL\n&gt;&gt;&gt; m.add_stac_layer(\n...     url=\"https://planetarycomputer.microsoft.com/api/stac/v1/collections/sentinel-2-l2a/items/S2A_MSIL2A_20220101T181901_N0301_R027_T10TEM_20220101T201906\",\n...     assets=[\"red\", \"green\", \"blue\"],\n...     rescale=[0, 3000]\n... )\n&gt;&gt;&gt; # From pystac Item\n&gt;&gt;&gt; import pystac\n&gt;&gt;&gt; item = pystac.Item.from_file(\"path/to/item.json\")\n&gt;&gt;&gt; m.add_stac_layer(item=item, assets=[\"nir\", \"red\"], colormap=\"ndvi\")\n</code></pre> Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def add_stac_layer(\n    self,\n    url: Optional[str] = None,\n    item: Optional[Any] = None,\n    assets: Optional[List[str]] = None,\n    colormap: Optional[str] = None,\n    rescale: Optional[List[float]] = None,\n    opacity: float = 1.0,\n    layer_id: Optional[str] = None,\n    titiler_endpoint: str = \"https://titiler.xyz\",\n    attribution: str = \"STAC\",\n    fit_bounds: bool = True,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a STAC (SpatioTemporal Asset Catalog) layer to the map.\n\n    Uses TiTiler to render STAC items as XYZ tiles on the map.\n    Supports both STAC item URLs and pystac Item objects.\n\n    Args:\n        url: URL to a STAC item JSON\n        item: A pystac Item object\n        assets: List of asset names/bands to visualize\n        colormap: Colormap name (e.g., 'viridis', 'plasma', 'inferno')\n        rescale: Min/max values for rescaling as [min, max]\n        opacity: Layer opacity (0-1)\n        layer_id: Custom layer identifier\n        titiler_endpoint: TiTiler server endpoint URL\n        attribution: Attribution text for the layer\n        fit_bounds: Whether to fit map to STAC item bounds\n        **kwargs: Additional tile layer options\n\n    Example:\n        &gt;&gt;&gt; from anymap_ts import Map\n        &gt;&gt;&gt; m = Map()\n        &gt;&gt;&gt; # From URL\n        &gt;&gt;&gt; m.add_stac_layer(\n        ...     url=\"https://planetarycomputer.microsoft.com/api/stac/v1/collections/sentinel-2-l2a/items/S2A_MSIL2A_20220101T181901_N0301_R027_T10TEM_20220101T201906\",\n        ...     assets=[\"red\", \"green\", \"blue\"],\n        ...     rescale=[0, 3000]\n        ... )\n        &gt;&gt;&gt; # From pystac Item\n        &gt;&gt;&gt; import pystac\n        &gt;&gt;&gt; item = pystac.Item.from_file(\"path/to/item.json\")\n        &gt;&gt;&gt; m.add_stac_layer(item=item, assets=[\"nir\", \"red\"], colormap=\"ndvi\")\n    \"\"\"\n    if url is None and item is None:\n        raise ValueError(\"Either 'url' or 'item' must be provided\")\n\n    if url is not None and item is not None:\n        raise ValueError(\"Provide either 'url' or 'item', not both\")\n\n    # Handle pystac Item object\n    if item is not None:\n        try:\n            # Check if it's a pystac Item\n            if hasattr(item, \"to_dict\") and hasattr(item, \"self_href\"):\n                stac_url = item.self_href\n                if not stac_url:\n                    # Try to get URL from item properties if no self_href\n                    if hasattr(item, \"links\"):\n                        for link in item.links:\n                            if link.rel == \"self\":\n                                stac_url = link.href\n                                break\n                    if not stac_url:\n                        raise ValueError(\n                            \"STAC item must have a self_href or self link for tile generation\"\n                        )\n            else:\n                raise ValueError(\n                    \"Item must be a pystac Item object with to_dict() and self_href attributes\"\n                )\n        except Exception as e:\n            raise ValueError(f\"Invalid STAC item: {e}\")\n    else:\n        stac_url = url\n\n    # Build TiTiler tile URL\n    tile_params = {\"url\": stac_url}\n\n    if assets:\n        tile_params[\"assets\"] = \",\".join(assets)\n    if colormap:\n        tile_params[\"colormap_name\"] = colormap\n    if rescale:\n        if len(rescale) == 2:\n            tile_params[\"rescale\"] = f\"{rescale[0]},{rescale[1]}\"\n        else:\n            raise ValueError(\"rescale must be a list of two values [min, max]\")\n\n    # Construct tile URL template\n    query_string = urlencode(tile_params)\n    tile_url = f\"{titiler_endpoint.rstrip('/')}/stac/tiles/{{z}}/{{x}}/{{y}}?{query_string}\"\n\n    layer_name = layer_id or f\"stac-{len(self._layers)}\"\n\n    # Add as tile layer\n    self.add_tile_layer(\n        url=tile_url,\n        name=layer_name,\n        attribution=attribution,\n        **kwargs,\n    )\n\n    # Update layer info to mark as STAC\n    if layer_name in self._layers:\n        self._layers[layer_name].update(\n            {\n                \"stac_url\": stac_url,\n                \"stac_assets\": assets,\n                \"colormap\": colormap,\n                \"rescale\": rescale,\n            }\n        )\n\n    # Try to fit bounds if requested and we have an item object\n    if fit_bounds and item is not None:\n        try:\n            bbox = item.bbox\n            if bbox and len(bbox) == 4:\n                self.fit_bounds([[bbox[0], bbox[1]], [bbox[2], bbox[3]]])\n        except Exception:\n            pass  # Skip bounds fitting if bbox is not available\n</code></pre>"},{"location":"maplibre/#anymap_ts.maplibre.MapLibreMap.add_style_switcher","title":"<code>add_style_switcher(self, styles, position='top-right')</code>","text":"<p>Add a dropdown to switch between map styles.</p> <p>Parameters:</p> Name Type Description Default <code>styles</code> <code>Dict[str, str]</code> <p>Dict mapping style names to style URLs.</p> required <code>position</code> <code>str</code> <p>Control position.</p> <code>'top-right'</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; m = MapLibreMap()\n&gt;&gt;&gt; m.add_style_switcher({\n...     \"Light\": \"https://basemaps.cartocdn.com/gl/positron-gl-style/style.json\",\n...     \"Dark\": \"https://basemaps.cartocdn.com/gl/dark-matter-gl-style/style.json\",\n...     \"Voyager\": \"https://basemaps.cartocdn.com/gl/voyager-gl-style/style.json\",\n... })\n</code></pre> Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def add_style_switcher(\n    self,\n    styles: Dict[str, str],\n    position: str = \"top-right\",\n) -&gt; None:\n    \"\"\"Add a dropdown to switch between map styles.\n\n    Args:\n        styles: Dict mapping style names to style URLs.\n        position: Control position.\n\n    Example:\n        &gt;&gt;&gt; m = MapLibreMap()\n        &gt;&gt;&gt; m.add_style_switcher({\n        ...     \"Light\": \"https://basemaps.cartocdn.com/gl/positron-gl-style/style.json\",\n        ...     \"Dark\": \"https://basemaps.cartocdn.com/gl/dark-matter-gl-style/style.json\",\n        ...     \"Voyager\": \"https://basemaps.cartocdn.com/gl/voyager-gl-style/style.json\",\n        ... })\n    \"\"\"\n    self.call_js_method(\n        \"addStyleSwitcher\",\n        styles=styles,\n        position=position,\n    )\n</code></pre>"},{"location":"maplibre/#anymap_ts.maplibre.MapLibreMap.add_swipe_map","title":"<code>add_swipe_map(self, left_layer, right_layer)</code>","text":"<p>Add a drag-to-compare swipe control for two layers.</p> <p>Unlike split map which is side-by-side, swipe map overlays both layers and uses a draggable divider for before/after comparison.</p> <p>Parameters:</p> Name Type Description Default <code>left_layer</code> <code>str</code> <p>Layer ID for the left side.</p> required <code>right_layer</code> <code>str</code> <p>Layer ID for the right side.</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; m = MapLibreMap()\n&gt;&gt;&gt; m.add_tile_layer(\"...\", name=\"before\")\n&gt;&gt;&gt; m.add_tile_layer(\"...\", name=\"after\")\n&gt;&gt;&gt; m.add_swipe_map(\"before\", \"after\")\n</code></pre> Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def add_swipe_map(self, left_layer: str, right_layer: str) -&gt; None:\n    \"\"\"Add a drag-to-compare swipe control for two layers.\n\n    Unlike split map which is side-by-side, swipe map overlays both\n    layers and uses a draggable divider for before/after comparison.\n\n    Args:\n        left_layer: Layer ID for the left side.\n        right_layer: Layer ID for the right side.\n\n    Example:\n        &gt;&gt;&gt; m = MapLibreMap()\n        &gt;&gt;&gt; m.add_tile_layer(\"...\", name=\"before\")\n        &gt;&gt;&gt; m.add_tile_layer(\"...\", name=\"after\")\n        &gt;&gt;&gt; m.add_swipe_map(\"before\", \"after\")\n    \"\"\"\n    self.call_js_method(\n        \"addSwipeMap\",\n        leftLayer=left_layer,\n        rightLayer=right_layer,\n    )\n</code></pre>"},{"location":"maplibre/#anymap_ts.maplibre.MapLibreMap.add_text_layer","title":"<code>add_text_layer(self, data, name=None, get_position='coordinates', get_text='text', get_size=12, get_color=None, get_angle=0, text_anchor='middle', alignment_baseline='center', pickable=True, opacity=1, **kwargs)</code>","text":"<p>Add a text layer for label placement using deck.gl.</p> <p>Text layers render text labels at specified positions, ideal for annotating map features or creating label layers.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>Array of data objects with position and text.</p> required <code>name</code> <code>Optional[str]</code> <p>Layer ID. If None, auto-generated.</p> <code>None</code> <code>get_position</code> <code>Union[str, Any]</code> <p>Accessor for text position [lng, lat].</p> <code>'coordinates'</code> <code>get_text</code> <code>Union[str, Any]</code> <p>Accessor for text content string.</p> <code>'text'</code> <code>get_size</code> <code>Union[float, str]</code> <p>Accessor for text size in pixels.</p> <code>12</code> <code>get_color</code> <code>Optional[Union[List[int], str]]</code> <p>Accessor for text color [r, g, b, a]. Default: [0, 0, 0, 255] (black).</p> <code>None</code> <code>get_angle</code> <code>Union[float, str]</code> <p>Accessor for text rotation in degrees.</p> <code>0</code> <code>text_anchor</code> <code>str</code> <p>Horizontal alignment ('start', 'middle', 'end').</p> <code>'middle'</code> <code>alignment_baseline</code> <code>str</code> <p>Vertical alignment ('top', 'center', 'bottom').</p> <code>'center'</code> <code>pickable</code> <code>bool</code> <p>Whether layer responds to hover/click events.</p> <code>True</code> <code>opacity</code> <code>float</code> <p>Layer opacity (0-1).</p> <code>1</code> <code>**kwargs</code> <p>Additional TextLayer props.</p> <code>{}</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from anymap_ts import MapLibreMap\n&gt;&gt;&gt; m = MapLibreMap()\n&gt;&gt;&gt; labels = [\n...     {\"coordinates\": [-122.4, 37.8], \"text\": \"San Francisco\"},\n...     {\"coordinates\": [-118.2, 34.1], \"text\": \"Los Angeles\"},\n... ]\n&gt;&gt;&gt; m.add_text_layer(labels, get_size=16)\n</code></pre> Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def add_text_layer(\n    self,\n    data: Any,\n    name: Optional[str] = None,\n    get_position: Union[str, Any] = \"coordinates\",\n    get_text: Union[str, Any] = \"text\",\n    get_size: Union[float, str] = 12,\n    get_color: Optional[Union[List[int], str]] = None,\n    get_angle: Union[float, str] = 0,\n    text_anchor: str = \"middle\",\n    alignment_baseline: str = \"center\",\n    pickable: bool = True,\n    opacity: float = 1,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a text layer for label placement using deck.gl.\n\n    Text layers render text labels at specified positions, ideal for\n    annotating map features or creating label layers.\n\n    Args:\n        data: Array of data objects with position and text.\n        name: Layer ID. If None, auto-generated.\n        get_position: Accessor for text position [lng, lat].\n        get_text: Accessor for text content string.\n        get_size: Accessor for text size in pixels.\n        get_color: Accessor for text color [r, g, b, a].\n            Default: [0, 0, 0, 255] (black).\n        get_angle: Accessor for text rotation in degrees.\n        text_anchor: Horizontal alignment ('start', 'middle', 'end').\n        alignment_baseline: Vertical alignment ('top', 'center', 'bottom').\n        pickable: Whether layer responds to hover/click events.\n        opacity: Layer opacity (0-1).\n        **kwargs: Additional TextLayer props.\n\n    Example:\n        &gt;&gt;&gt; from anymap_ts import MapLibreMap\n        &gt;&gt;&gt; m = MapLibreMap()\n        &gt;&gt;&gt; labels = [\n        ...     {\"coordinates\": [-122.4, 37.8], \"text\": \"San Francisco\"},\n        ...     {\"coordinates\": [-118.2, 34.1], \"text\": \"Los Angeles\"},\n        ... ]\n        &gt;&gt;&gt; m.add_text_layer(labels, get_size=16)\n    \"\"\"\n    layer_id = name or f\"text-{len(self._layers)}\"\n    processed_data = self._process_deck_data(data)\n\n    self.call_js_method(\n        \"addTextLayer\",\n        id=layer_id,\n        data=processed_data,\n        getPosition=get_position,\n        getText=get_text,\n        getSize=get_size,\n        getColor=get_color or [0, 0, 0, 255],\n        getAngle=get_angle,\n        getTextAnchor=text_anchor,\n        getAlignmentBaseline=alignment_baseline,\n        pickable=pickable,\n        opacity=opacity,\n        **kwargs,\n    )\n\n    self._layers = {\n        **self._layers,\n        layer_id: {\n            \"id\": layer_id,\n            \"type\": \"text\",\n        },\n    }\n    self._add_to_layer_dict(layer_id, \"Deck.gl\")\n</code></pre>"},{"location":"maplibre/#anymap_ts.maplibre.MapLibreMap.add_tile_layer","title":"<code>add_tile_layer(self, url, name=None, attribution='', min_zoom=0, max_zoom=22, **kwargs)</code>","text":"<p>Add an XYZ tile layer.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>Tile URL template with {x}, {y}, {z} placeholders</p> required <code>name</code> <code>Optional[str]</code> <p>Layer name</p> <code>None</code> <code>attribution</code> <code>str</code> <p>Attribution text</p> <code>''</code> <code>min_zoom</code> <code>int</code> <p>Minimum zoom level</p> <code>0</code> <code>max_zoom</code> <code>int</code> <p>Maximum zoom level</p> <code>22</code> <code>**kwargs</code> <p>Additional options</p> <code>{}</code> Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def add_tile_layer(\n    self,\n    url: str,\n    name: Optional[str] = None,\n    attribution: str = \"\",\n    min_zoom: int = 0,\n    max_zoom: int = 22,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add an XYZ tile layer.\n\n    Args:\n        url: Tile URL template with {x}, {y}, {z} placeholders\n        name: Layer name\n        attribution: Attribution text\n        min_zoom: Minimum zoom level\n        max_zoom: Maximum zoom level\n        **kwargs: Additional options\n    \"\"\"\n    layer_id = name or f\"tiles-{len(self._layers)}\"\n\n    self.call_js_method(\n        \"addTileLayer\",\n        url,\n        name=layer_id,\n        attribution=attribution,\n        minZoom=min_zoom,\n        maxZoom=max_zoom,\n        **kwargs,\n    )\n\n    # Track layer\n    self._layers = {\n        **self._layers,\n        layer_id: {\n            \"id\": layer_id,\n            \"type\": \"raster\",\n            \"source\": f\"{layer_id}-source\",\n        },\n    }\n    self._add_to_layer_dict(layer_id, \"Raster\")\n</code></pre>"},{"location":"maplibre/#anymap_ts.maplibre.MapLibreMap.add_time_slider","title":"<code>add_time_slider(self, layer_id, property, min_value=0, max_value=100, step=1, position='bottom-left', label='Time', auto_play=False, interval=500)</code>","text":"<p>Add a time slider to filter data by a temporal property.</p> <p>Creates a slider control that filters layer features based on a numeric/temporal property, with optional auto-animation.</p> <p>Parameters:</p> Name Type Description Default <code>layer_id</code> <code>str</code> <p>Layer ID to filter.</p> required <code>property</code> <code>str</code> <p>Property name to filter on.</p> required <code>min_value</code> <code>float</code> <p>Minimum slider value.</p> <code>0</code> <code>max_value</code> <code>float</code> <p>Maximum slider value.</p> <code>100</code> <code>step</code> <code>float</code> <p>Step increment.</p> <code>1</code> <code>position</code> <code>str</code> <p>Control position.</p> <code>'bottom-left'</code> <code>label</code> <code>str</code> <p>Label text for the slider.</p> <code>'Time'</code> <code>auto_play</code> <code>bool</code> <p>Whether to auto-animate through values.</p> <code>False</code> <code>interval</code> <code>int</code> <p>Animation interval in milliseconds.</p> <code>500</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; m = MapLibreMap()\n&gt;&gt;&gt; m.add_geojson(\"events.geojson\", name=\"events\")\n&gt;&gt;&gt; m.add_time_slider(\"events\", \"year\", min_value=2000, max_value=2024)\n</code></pre> Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def add_time_slider(\n    self,\n    layer_id: str,\n    property: str,\n    min_value: float = 0,\n    max_value: float = 100,\n    step: float = 1,\n    position: str = \"bottom-left\",\n    label: str = \"Time\",\n    auto_play: bool = False,\n    interval: int = 500,\n) -&gt; None:\n    \"\"\"Add a time slider to filter data by a temporal property.\n\n    Creates a slider control that filters layer features based on a\n    numeric/temporal property, with optional auto-animation.\n\n    Args:\n        layer_id: Layer ID to filter.\n        property: Property name to filter on.\n        min_value: Minimum slider value.\n        max_value: Maximum slider value.\n        step: Step increment.\n        position: Control position.\n        label: Label text for the slider.\n        auto_play: Whether to auto-animate through values.\n        interval: Animation interval in milliseconds.\n\n    Example:\n        &gt;&gt;&gt; m = MapLibreMap()\n        &gt;&gt;&gt; m.add_geojson(\"events.geojson\", name=\"events\")\n        &gt;&gt;&gt; m.add_time_slider(\"events\", \"year\", min_value=2000, max_value=2024)\n    \"\"\"\n    self.call_js_method(\n        \"addTimeSlider\",\n        layerId=layer_id,\n        property=property,\n        min=min_value,\n        max=max_value,\n        step=step,\n        position=position,\n        label=label,\n        autoPlay=auto_play,\n        interval=interval,\n    )\n</code></pre>"},{"location":"maplibre/#anymap_ts.maplibre.MapLibreMap.add_tooltip","title":"<code>add_tooltip(self, layer_id, template=None, properties=None)</code>","text":"<p>Add a tooltip that shows on feature hover.</p> <p>Shows formatted information when hovering over features in a layer.</p> <p>Parameters:</p> Name Type Description Default <code>layer_id</code> <code>str</code> <p>The ID of the layer to add tooltips to.</p> required <code>template</code> <code>Optional[str]</code> <p>HTML template with {property} placeholders. Example: \"Name: {name}Population: {pop}\".</p> <code>None</code> <code>properties</code> <code>Optional[List[str]]</code> <p>List of property names to display. If None and no template, all properties are shown.</p> <code>None</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; m = MapLibreMap()\n&gt;&gt;&gt; m.add_geojson(\"data.geojson\", name=\"cities\")\n&gt;&gt;&gt; m.add_tooltip(\"cities\", template=\"&lt;b&gt;{name}&lt;/b&gt;&lt;br&gt;Pop: {population}\")\n</code></pre> Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def add_tooltip(\n    self,\n    layer_id: str,\n    template: Optional[str] = None,\n    properties: Optional[List[str]] = None,\n) -&gt; None:\n    \"\"\"Add a tooltip that shows on feature hover.\n\n    Shows formatted information when hovering over features in a layer.\n\n    Args:\n        layer_id: The ID of the layer to add tooltips to.\n        template: HTML template with {property} placeholders.\n            Example: \"Name: {name}&lt;br&gt;Population: {pop}\".\n        properties: List of property names to display. If None and no\n            template, all properties are shown.\n\n    Example:\n        &gt;&gt;&gt; m = MapLibreMap()\n        &gt;&gt;&gt; m.add_geojson(\"data.geojson\", name=\"cities\")\n        &gt;&gt;&gt; m.add_tooltip(\"cities\", template=\"&lt;b&gt;{name}&lt;/b&gt;&lt;br&gt;Pop: {population}\")\n    \"\"\"\n    self.call_js_method(\n        \"addTooltip\",\n        layerId=layer_id,\n        template=template or \"\",\n        properties=properties,\n    )\n</code></pre>"},{"location":"maplibre/#anymap_ts.maplibre.MapLibreMap.add_trips_layer","title":"<code>add_trips_layer(self, data, name=None, get_path='waypoints', get_timestamps='timestamps', get_color=None, width_min_pixels=2, trail_length=180, current_time=0, pickable=True, opacity=0.8, **kwargs)</code>","text":"<p>Add a trips layer for animated trip/trajectory playback using deck.gl.</p> <p>Trips layers render animated paths showing movement over time, ideal for visualizing vehicle routes, migration patterns, or time-based data.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>Array of trip objects with waypoints and timestamps.</p> required <code>name</code> <code>Optional[str]</code> <p>Layer ID. If None, auto-generated.</p> <code>None</code> <code>get_path</code> <code>Union[str, Any]</code> <p>Accessor for waypoint coordinates [[lng, lat], ...].</p> <code>'waypoints'</code> <code>get_timestamps</code> <code>Union[str, Any]</code> <p>Accessor for timestamps at each waypoint.</p> <code>'timestamps'</code> <code>get_color</code> <code>Optional[Union[List[int], str]]</code> <p>Accessor for trip color [r, g, b] or [r, g, b, a]. Default: [253, 128, 93].</p> <code>None</code> <code>width_min_pixels</code> <code>float</code> <p>Minimum trail width in pixels.</p> <code>2</code> <code>trail_length</code> <code>float</code> <p>Trail length in timestamp units.</p> <code>180</code> <code>current_time</code> <code>float</code> <p>Current animation time.</p> <code>0</code> <code>pickable</code> <code>bool</code> <p>Whether layer responds to hover/click events.</p> <code>True</code> <code>opacity</code> <code>float</code> <p>Layer opacity (0-1).</p> <code>0.8</code> <code>**kwargs</code> <p>Additional TripsLayer props.</p> <code>{}</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from anymap_ts import MapLibreMap\n&gt;&gt;&gt; m = MapLibreMap()\n&gt;&gt;&gt; trips = [\n...     {\n...         \"waypoints\": [[-122.4, 37.8], [-122.5, 37.7]],\n...         \"timestamps\": [0, 100]\n...     }\n... ]\n&gt;&gt;&gt; m.add_trips_layer(trips, trail_length=200, current_time=50)\n</code></pre> Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def add_trips_layer(\n    self,\n    data: Any,\n    name: Optional[str] = None,\n    get_path: Union[str, Any] = \"waypoints\",\n    get_timestamps: Union[str, Any] = \"timestamps\",\n    get_color: Optional[Union[List[int], str]] = None,\n    width_min_pixels: float = 2,\n    trail_length: float = 180,\n    current_time: float = 0,\n    pickable: bool = True,\n    opacity: float = 0.8,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a trips layer for animated trip/trajectory playback using deck.gl.\n\n    Trips layers render animated paths showing movement over time, ideal\n    for visualizing vehicle routes, migration patterns, or time-based data.\n\n    Args:\n        data: Array of trip objects with waypoints and timestamps.\n        name: Layer ID. If None, auto-generated.\n        get_path: Accessor for waypoint coordinates [[lng, lat], ...].\n        get_timestamps: Accessor for timestamps at each waypoint.\n        get_color: Accessor for trip color [r, g, b] or [r, g, b, a].\n            Default: [253, 128, 93].\n        width_min_pixels: Minimum trail width in pixels.\n        trail_length: Trail length in timestamp units.\n        current_time: Current animation time.\n        pickable: Whether layer responds to hover/click events.\n        opacity: Layer opacity (0-1).\n        **kwargs: Additional TripsLayer props.\n\n    Example:\n        &gt;&gt;&gt; from anymap_ts import MapLibreMap\n        &gt;&gt;&gt; m = MapLibreMap()\n        &gt;&gt;&gt; trips = [\n        ...     {\n        ...         \"waypoints\": [[-122.4, 37.8], [-122.5, 37.7]],\n        ...         \"timestamps\": [0, 100]\n        ...     }\n        ... ]\n        &gt;&gt;&gt; m.add_trips_layer(trips, trail_length=200, current_time=50)\n    \"\"\"\n    layer_id = name or f\"trips-{len(self._layers)}\"\n    processed_data = self._process_deck_data(data)\n\n    self.call_js_method(\n        \"addTripsLayer\",\n        id=layer_id,\n        data=processed_data,\n        getPath=get_path,\n        getTimestamps=get_timestamps,\n        getColor=get_color or [253, 128, 93],\n        widthMinPixels=width_min_pixels,\n        trailLength=trail_length,\n        currentTime=current_time,\n        pickable=pickable,\n        opacity=opacity,\n        **kwargs,\n    )\n\n    self._layers = {\n        **self._layers,\n        layer_id: {\n            \"id\": layer_id,\n            \"type\": \"trips\",\n        },\n    }\n    self._add_to_layer_dict(layer_id, \"Deck.gl\")\n</code></pre>"},{"location":"maplibre/#anymap_ts.maplibre.MapLibreMap.add_vector","title":"<code>add_vector(self, data, layer_type=None, paint=None, name=None, fit_bounds=True, **kwargs)</code>","text":"<p>Add vector data to the map.</p> <p>Supports GeoJSON, GeoDataFrame, or file paths to vector formats.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>GeoJSON dict, GeoDataFrame, or path to vector file</p> required <code>layer_type</code> <code>Optional[str]</code> <p>MapLibre layer type ('circle', 'line', 'fill', 'symbol')</p> <code>None</code> <code>paint</code> <code>Optional[Dict]</code> <p>MapLibre paint properties</p> <code>None</code> <code>name</code> <code>Optional[str]</code> <p>Layer name</p> <code>None</code> <code>fit_bounds</code> <code>bool</code> <p>Whether to fit map to data bounds</p> <code>True</code> <code>**kwargs</code> <p>Additional layer options</p> <code>{}</code> Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def add_vector(\n    self,\n    data: Any,\n    layer_type: Optional[str] = None,\n    paint: Optional[Dict] = None,\n    name: Optional[str] = None,\n    fit_bounds: bool = True,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add vector data to the map.\n\n    Supports GeoJSON, GeoDataFrame, or file paths to vector formats.\n\n    Args:\n        data: GeoJSON dict, GeoDataFrame, or path to vector file\n        layer_type: MapLibre layer type ('circle', 'line', 'fill', 'symbol')\n        paint: MapLibre paint properties\n        name: Layer name\n        fit_bounds: Whether to fit map to data bounds\n        **kwargs: Additional layer options\n    \"\"\"\n    geojson = to_geojson(data)\n\n    layer_id = name or f\"vector-{len(self._layers)}\"\n\n    # Handle URL data - fetch GeoJSON to get bounds and infer layer type\n    if geojson.get(\"type\") == \"url\":\n        url = geojson[\"url\"]\n        # Fetch the actual GeoJSON data from URL\n        geojson = fetch_geojson(url)\n\n    # Infer layer type if not specified\n    if layer_type is None:\n        layer_type = infer_layer_type(geojson)\n\n    # Get default paint if not provided\n    if paint is None:\n        paint = get_default_paint(layer_type)\n\n    # Get bounds (use geojson dict, not original data which may be a URL)\n    bounds = get_bounds(geojson) if fit_bounds else None\n\n    # Call JavaScript\n    self.call_js_method(\n        \"addGeoJSON\",\n        data=geojson,\n        name=layer_id,\n        layerType=layer_type,\n        paint=paint,\n        fitBounds=fit_bounds,\n        bounds=bounds,\n        **kwargs,\n    )\n\n    # Track layer\n    self._layers = {\n        **self._layers,\n        layer_id: {\n            \"id\": layer_id,\n            \"type\": layer_type,\n            \"source\": f\"{layer_id}-source\",\n            \"paint\": paint,\n        },\n    }\n    self._add_to_layer_dict(layer_id, \"Vector\")\n</code></pre>"},{"location":"maplibre/#anymap_ts.maplibre.MapLibreMap.add_vector_control","title":"<code>add_vector_control(self, position='top-right', collapsed=True, default_url=None, load_default_url=False, default_opacity=1.0, default_fill_color='#3388ff', default_stroke_color='#3388ff', fit_bounds=True, **kwargs)</code>","text":"<p>Add a vector layer control for loading vector datasets from URLs.</p> <p>This provides an interactive panel for users to enter URLs to GeoJSON, GeoParquet, or FlatGeobuf datasets.</p> <p>Parameters:</p> Name Type Description Default <code>position</code> <code>str</code> <p>Control position ('top-left', 'top-right', 'bottom-left', 'bottom-right').</p> <code>'top-right'</code> <code>collapsed</code> <code>bool</code> <p>Whether the panel starts collapsed.</p> <code>True</code> <code>default_url</code> <code>Optional[str]</code> <p>Default vector URL to pre-fill.</p> <code>None</code> <code>load_default_url</code> <code>bool</code> <p>Whether to auto-load the default URL.</p> <code>False</code> <code>default_opacity</code> <code>float</code> <p>Default layer opacity (0-1).</p> <code>1.0</code> <code>default_fill_color</code> <code>str</code> <p>Default fill color for polygons.</p> <code>'#3388ff'</code> <code>default_stroke_color</code> <code>str</code> <p>Default stroke color for lines/outlines.</p> <code>'#3388ff'</code> <code>fit_bounds</code> <code>bool</code> <p>Whether to fit map to loaded data bounds.</p> <code>True</code> <code>**kwargs</code> <p>Additional control options.</p> <code>{}</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from anymap_ts import MapLibreMap\n&gt;&gt;&gt; m = MapLibreMap()\n&gt;&gt;&gt; m.add_vector_control(\n...     default_url=\"https://example.com/data.geojson\",\n...     default_fill_color=\"#ff0000\"\n... )\n</code></pre> Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def add_vector_control(\n    self,\n    position: str = \"top-right\",\n    collapsed: bool = True,\n    default_url: Optional[str] = None,\n    load_default_url: bool = False,\n    default_opacity: float = 1.0,\n    default_fill_color: str = \"#3388ff\",\n    default_stroke_color: str = \"#3388ff\",\n    fit_bounds: bool = True,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a vector layer control for loading vector datasets from URLs.\n\n    This provides an interactive panel for users to enter URLs to\n    GeoJSON, GeoParquet, or FlatGeobuf datasets.\n\n    Args:\n        position: Control position ('top-left', 'top-right', 'bottom-left', 'bottom-right').\n        collapsed: Whether the panel starts collapsed.\n        default_url: Default vector URL to pre-fill.\n        load_default_url: Whether to auto-load the default URL.\n        default_opacity: Default layer opacity (0-1).\n        default_fill_color: Default fill color for polygons.\n        default_stroke_color: Default stroke color for lines/outlines.\n        fit_bounds: Whether to fit map to loaded data bounds.\n        **kwargs: Additional control options.\n\n    Example:\n        &gt;&gt;&gt; from anymap_ts import MapLibreMap\n        &gt;&gt;&gt; m = MapLibreMap()\n        &gt;&gt;&gt; m.add_vector_control(\n        ...     default_url=\"https://example.com/data.geojson\",\n        ...     default_fill_color=\"#ff0000\"\n        ... )\n    \"\"\"\n    self.call_js_method(\n        \"addVectorControl\",\n        position=position,\n        collapsed=collapsed,\n        defaultUrl=default_url or \"\",\n        loadDefaultUrl=load_default_url,\n        defaultOpacity=default_opacity,\n        defaultFillColor=default_fill_color,\n        defaultStrokeColor=default_stroke_color,\n        fitBounds=fit_bounds,\n        **kwargs,\n    )\n    self._controls = {\n        **self._controls,\n        \"vector-control\": {\"position\": position, \"collapsed\": collapsed},\n    }\n</code></pre>"},{"location":"maplibre/#anymap_ts.maplibre.MapLibreMap.add_video_layer","title":"<code>add_video_layer(self, urls, coordinates, name=None, opacity=1.0, **kwargs)</code>","text":"<p>Add a georeferenced video overlay on the map.</p> <p>Parameters:</p> Name Type Description Default <code>urls</code> <code>List[str]</code> <p>List of video URLs (provide multiple formats for browser compatibility, e.g., [\".mp4\", \".webm\"]).</p> required <code>coordinates</code> <code>List[List[float]]</code> <p>Four corner coordinates as [[lng, lat], ...] in order: top-left, top-right, bottom-right, bottom-left.</p> required <code>name</code> <code>Optional[str]</code> <p>Layer identifier. If None, auto-generated.</p> <code>None</code> <code>opacity</code> <code>float</code> <p>Layer opacity (0-1). Default is 1.0.</p> <code>1.0</code> <code>**kwargs</code> <p>Additional layer options.</p> <code>{}</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; m.add_video_layer(\n...     urls=[\"https://example.com/video.mp4\"],\n...     coordinates=[\n...         [-122.51596391658498, 37.56238816766053],\n...         [-122.51467645489949, 37.56410183312965],\n...         [-122.51309394645498, 37.563391708549425],\n...         [-122.51423120498498, 37.56161849366671],\n...     ],\n... )\n</code></pre> Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def add_video_layer(\n    self,\n    urls: List[str],\n    coordinates: List[List[float]],\n    name: Optional[str] = None,\n    opacity: float = 1.0,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a georeferenced video overlay on the map.\n\n    Args:\n        urls: List of video URLs (provide multiple formats for browser\n            compatibility, e.g., [\".mp4\", \".webm\"]).\n        coordinates: Four corner coordinates as [[lng, lat], ...] in order:\n            top-left, top-right, bottom-right, bottom-left.\n        name: Layer identifier. If None, auto-generated.\n        opacity: Layer opacity (0-1). Default is 1.0.\n        **kwargs: Additional layer options.\n\n    Example:\n        &gt;&gt;&gt; m.add_video_layer(\n        ...     urls=[\"https://example.com/video.mp4\"],\n        ...     coordinates=[\n        ...         [-122.51596391658498, 37.56238816766053],\n        ...         [-122.51467645489949, 37.56410183312965],\n        ...         [-122.51309394645498, 37.563391708549425],\n        ...         [-122.51423120498498, 37.56161849366671],\n        ...     ],\n        ... )\n    \"\"\"\n    self._validate_opacity(opacity)\n    layer_id = name or f\"video-{len(self._layers)}\"\n\n    if len(coordinates) != 4:\n        raise ValueError(\n            \"coordinates must have exactly 4 corner points \"\n            \"[top-left, top-right, bottom-right, bottom-left]\"\n        )\n\n    self.call_js_method(\n        \"addVideoLayer\",\n        id=layer_id,\n        urls=urls,\n        coordinates=coordinates,\n        opacity=opacity,\n        **kwargs,\n    )\n\n    self._layers = {\n        **self._layers,\n        layer_id: {\n            \"id\": layer_id,\n            \"type\": \"video\",\n            \"source\": f\"{layer_id}-source\",\n        },\n    }\n    self._add_to_layer_dict(layer_id, \"Raster\")\n</code></pre>"},{"location":"maplibre/#anymap_ts.maplibre.MapLibreMap.add_zarr_control","title":"<code>add_zarr_control(self, position='top-right', collapsed=True, default_url=None, load_default_url=False, default_opacity=1.0, default_variable='', default_clim=None, **kwargs)</code>","text":"<p>Add a Zarr layer control for loading Zarr datasets via UI.</p> <p>This provides an interactive panel for users to enter Zarr URLs and configure visualization parameters.</p> <p>Parameters:</p> Name Type Description Default <code>position</code> <code>str</code> <p>Control position ('top-left', 'top-right', 'bottom-left', 'bottom-right').</p> <code>'top-right'</code> <code>collapsed</code> <code>bool</code> <p>Whether the panel starts collapsed.</p> <code>True</code> <code>default_url</code> <code>Optional[str]</code> <p>Default Zarr URL to pre-fill.</p> <code>None</code> <code>load_default_url</code> <code>bool</code> <p>Whether to auto-load the default URL.</p> <code>False</code> <code>default_opacity</code> <code>float</code> <p>Default layer opacity (0-1).</p> <code>1.0</code> <code>default_variable</code> <code>str</code> <p>Default variable name.</p> <code>''</code> <code>default_clim</code> <code>Optional[Tuple[float, float]]</code> <p>Default color limits (min, max).</p> <code>None</code> <code>**kwargs</code> <p>Additional control options.</p> <code>{}</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from anymap_ts import MapLibreMap\n&gt;&gt;&gt; m = MapLibreMap()\n&gt;&gt;&gt; m.add_zarr_control(\n...     default_url=\"https://example.com/data.zarr\",\n...     default_variable=\"temperature\"\n... )\n</code></pre> Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def add_zarr_control(\n    self,\n    position: str = \"top-right\",\n    collapsed: bool = True,\n    default_url: Optional[str] = None,\n    load_default_url: bool = False,\n    default_opacity: float = 1.0,\n    default_variable: str = \"\",\n    default_clim: Optional[Tuple[float, float]] = None,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a Zarr layer control for loading Zarr datasets via UI.\n\n    This provides an interactive panel for users to enter Zarr URLs\n    and configure visualization parameters.\n\n    Args:\n        position: Control position ('top-left', 'top-right', 'bottom-left', 'bottom-right').\n        collapsed: Whether the panel starts collapsed.\n        default_url: Default Zarr URL to pre-fill.\n        load_default_url: Whether to auto-load the default URL.\n        default_opacity: Default layer opacity (0-1).\n        default_variable: Default variable name.\n        default_clim: Default color limits (min, max).\n        **kwargs: Additional control options.\n\n    Example:\n        &gt;&gt;&gt; from anymap_ts import MapLibreMap\n        &gt;&gt;&gt; m = MapLibreMap()\n        &gt;&gt;&gt; m.add_zarr_control(\n        ...     default_url=\"https://example.com/data.zarr\",\n        ...     default_variable=\"temperature\"\n        ... )\n    \"\"\"\n    self.call_js_method(\n        \"addZarrControl\",\n        position=position,\n        collapsed=collapsed,\n        defaultUrl=default_url or \"\",\n        loadDefaultUrl=load_default_url,\n        defaultOpacity=default_opacity,\n        defaultVariable=default_variable,\n        defaultClim=list(default_clim) if default_clim else [0, 1],\n        **kwargs,\n    )\n    self._controls = {\n        **self._controls,\n        \"zarr-control\": {\"position\": position, \"collapsed\": collapsed},\n    }\n</code></pre>"},{"location":"maplibre/#anymap_ts.maplibre.MapLibreMap.add_zarr_layer","title":"<code>add_zarr_layer(self, url, variable, name=None, colormap=None, clim=None, opacity=1.0, selector=None, minzoom=0, maxzoom=22, fill_value=None, spatial_dimensions=None, zarr_version=None, bounds=None, **kwargs)</code>","text":"<p>Add a Zarr dataset layer for visualizing multidimensional array data.</p> <p>This method renders Zarr pyramid datasets directly in the browser using GPU-accelerated WebGL rendering via @carbonplan/zarr-layer.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>URL to the Zarr store (pyramid format recommended).</p> required <code>variable</code> <code>str</code> <p>Variable name in the Zarr dataset to visualize.</p> required <code>name</code> <code>Optional[str]</code> <p>Layer ID. If None, auto-generated.</p> <code>None</code> <code>colormap</code> <code>Optional[List[str]]</code> <p>List of hex color strings for visualization. Example: ['#0000ff', '#ffff00', '#ff0000'] (blue-yellow-red). Default: ['#000000', '#ffffff'] (black to white).</p> <code>None</code> <code>clim</code> <code>Optional[Tuple[float, float]]</code> <p>Color range as (min, max) tuple. Default: (0, 100).</p> <code>None</code> <code>opacity</code> <code>float</code> <p>Layer opacity (0-1).</p> <code>1.0</code> <code>selector</code> <code>Optional[Dict[str, Any]]</code> <p>Dimension selector for multi-dimensional data. Example: {\"month\": 4} to select 4th month.</p> <code>None</code> <code>minzoom</code> <code>int</code> <p>Minimum zoom level for rendering.</p> <code>0</code> <code>maxzoom</code> <code>int</code> <p>Maximum zoom level for rendering.</p> <code>22</code> <code>fill_value</code> <code>Optional[float]</code> <p>No-data value (auto-detected from metadata if not set).</p> <code>None</code> <code>spatial_dimensions</code> <code>Optional[Dict[str, str]]</code> <p>Custom spatial dimension names. Example: {\"lat\": \"y\", \"lon\": \"x\"} for non-standard names.</p> <code>None</code> <code>zarr_version</code> <code>Optional[int]</code> <p>Zarr format version (2 or 3). Auto-detected if not set.</p> <code>None</code> <code>bounds</code> <code>Optional[List[float]]</code> <p>Explicit spatial bounds [xMin, yMin, xMax, yMax]. Units depend on CRS: degrees for EPSG:4326, meters for EPSG:3857.</p> <code>None</code> <code>**kwargs</code> <p>Additional ZarrLayer props.</p> <code>{}</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from anymap_ts import Map\n&gt;&gt;&gt; m = Map()\n&gt;&gt;&gt; m.add_zarr_layer(\n...     \"https://example.com/climate.zarr\",\n...     variable=\"temperature\",\n...     clim=(270, 310),\n...     colormap=['#0000ff', '#ffff00', '#ff0000'],\n...     selector={\"month\": 7}\n... )\n</code></pre> Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def add_zarr_layer(\n    self,\n    url: str,\n    variable: str,\n    name: Optional[str] = None,\n    colormap: Optional[List[str]] = None,\n    clim: Optional[Tuple[float, float]] = None,\n    opacity: float = 1.0,\n    selector: Optional[Dict[str, Any]] = None,\n    minzoom: int = 0,\n    maxzoom: int = 22,\n    fill_value: Optional[float] = None,\n    spatial_dimensions: Optional[Dict[str, str]] = None,\n    zarr_version: Optional[int] = None,\n    bounds: Optional[List[float]] = None,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a Zarr dataset layer for visualizing multidimensional array data.\n\n    This method renders Zarr pyramid datasets directly in the browser using\n    GPU-accelerated WebGL rendering via @carbonplan/zarr-layer.\n\n    Args:\n        url: URL to the Zarr store (pyramid format recommended).\n        variable: Variable name in the Zarr dataset to visualize.\n        name: Layer ID. If None, auto-generated.\n        colormap: List of hex color strings for visualization.\n            Example: ['#0000ff', '#ffff00', '#ff0000'] (blue-yellow-red).\n            Default: ['#000000', '#ffffff'] (black to white).\n        clim: Color range as (min, max) tuple.\n            Default: (0, 100).\n        opacity: Layer opacity (0-1).\n        selector: Dimension selector for multi-dimensional data.\n            Example: {\"month\": 4} to select 4th month.\n        minzoom: Minimum zoom level for rendering.\n        maxzoom: Maximum zoom level for rendering.\n        fill_value: No-data value (auto-detected from metadata if not set).\n        spatial_dimensions: Custom spatial dimension names.\n            Example: {\"lat\": \"y\", \"lon\": \"x\"} for non-standard names.\n        zarr_version: Zarr format version (2 or 3). Auto-detected if not set.\n        bounds: Explicit spatial bounds [xMin, yMin, xMax, yMax].\n            Units depend on CRS: degrees for EPSG:4326, meters for EPSG:3857.\n        **kwargs: Additional ZarrLayer props.\n\n    Example:\n        &gt;&gt;&gt; from anymap_ts import Map\n        &gt;&gt;&gt; m = Map()\n        &gt;&gt;&gt; m.add_zarr_layer(\n        ...     \"https://example.com/climate.zarr\",\n        ...     variable=\"temperature\",\n        ...     clim=(270, 310),\n        ...     colormap=['#0000ff', '#ffff00', '#ff0000'],\n        ...     selector={\"month\": 7}\n        ... )\n    \"\"\"\n    layer_id = name or f\"zarr-{len(self._layers)}\"\n\n    self.call_js_method(\n        \"addZarrLayer\",\n        id=layer_id,\n        source=url,\n        variable=variable,\n        colormap=colormap or [\"#000000\", \"#ffffff\"],\n        clim=list(clim) if clim else [0, 100],\n        opacity=opacity,\n        selector=selector or {},\n        minzoom=minzoom,\n        maxzoom=maxzoom,\n        fillValue=fill_value,\n        spatialDimensions=spatial_dimensions,\n        zarrVersion=zarr_version,\n        bounds=bounds,\n        **kwargs,\n    )\n\n    self._layers = {\n        **self._layers,\n        layer_id: {\n            \"id\": layer_id,\n            \"type\": \"zarr\",\n            \"url\": url,\n            \"variable\": variable,\n        },\n    }\n    self._add_to_layer_dict(layer_id, \"Raster\")\n</code></pre>"},{"location":"maplibre/#anymap_ts.maplibre.MapLibreMap.animate_along_route","title":"<code>animate_along_route(self, route, duration=10000, loop=True, marker_color='#3388ff', marker_size=1.0, show_trail=False, trail_color='#3388ff', trail_width=3, animation_id=None, **kwargs)</code>","text":"<p>Animate a marker along a route.</p> <p>Creates an animated marker that moves along the specified route line.</p> <p>Parameters:</p> Name Type Description Default <code>route</code> <code>Any</code> <p>Route data - LineString GeoJSON, list of coordinates, GeoDataFrame, or file path.</p> required <code>duration</code> <code>int</code> <p>Animation duration in milliseconds.</p> <code>10000</code> <code>loop</code> <code>bool</code> <p>Whether to loop the animation.</p> <code>True</code> <code>marker_color</code> <code>str</code> <p>Marker color.</p> <code>'#3388ff'</code> <code>marker_size</code> <code>float</code> <p>Marker size multiplier.</p> <code>1.0</code> <code>show_trail</code> <code>bool</code> <p>Whether to show a trail behind the marker.</p> <code>False</code> <code>trail_color</code> <code>str</code> <p>Trail line color.</p> <code>'#3388ff'</code> <code>trail_width</code> <code>float</code> <p>Trail line width.</p> <code>3</code> <code>animation_id</code> <code>Optional[str]</code> <p>Animation identifier. If None, auto-generated.</p> <code>None</code> <code>**kwargs</code> <p>Additional animation options.</p> <code>{}</code> <p>Returns:</p> Type Description <code>str</code> <p>The animation identifier.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from anymap_ts import Map\n&gt;&gt;&gt; m = Map()\n&gt;&gt;&gt; coords = [[-122.4, 37.8], [-122.3, 37.7], [-122.2, 37.8]]\n&gt;&gt;&gt; anim_id = m.animate_along_route(coords, duration=5000, loop=True)\n</code></pre> Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def animate_along_route(\n    self,\n    route: Any,\n    duration: int = 10000,\n    loop: bool = True,\n    marker_color: str = \"#3388ff\",\n    marker_size: float = 1.0,\n    show_trail: bool = False,\n    trail_color: str = \"#3388ff\",\n    trail_width: float = 3,\n    animation_id: Optional[str] = None,\n    **kwargs,\n) -&gt; str:\n    \"\"\"Animate a marker along a route.\n\n    Creates an animated marker that moves along the specified route line.\n\n    Args:\n        route: Route data - LineString GeoJSON, list of coordinates,\n            GeoDataFrame, or file path.\n        duration: Animation duration in milliseconds.\n        loop: Whether to loop the animation.\n        marker_color: Marker color.\n        marker_size: Marker size multiplier.\n        show_trail: Whether to show a trail behind the marker.\n        trail_color: Trail line color.\n        trail_width: Trail line width.\n        animation_id: Animation identifier. If None, auto-generated.\n        **kwargs: Additional animation options.\n\n    Returns:\n        The animation identifier.\n\n    Example:\n        &gt;&gt;&gt; from anymap_ts import Map\n        &gt;&gt;&gt; m = Map()\n        &gt;&gt;&gt; coords = [[-122.4, 37.8], [-122.3, 37.7], [-122.2, 37.8]]\n        &gt;&gt;&gt; anim_id = m.animate_along_route(coords, duration=5000, loop=True)\n    \"\"\"\n    anim_id = animation_id or f\"animation-{len(self._layers)}\"\n\n    # Convert route to coordinates list\n    if isinstance(route, list) and len(route) &gt; 0:\n        if isinstance(route[0], (list, tuple)):\n            # Already a list of coordinates\n            coordinates = route\n        else:\n            raise ValueError(\"Route list must contain coordinate pairs\")\n    elif isinstance(route, dict):\n        # GeoJSON\n        if route.get(\"type\") == \"LineString\":\n            coordinates = route.get(\"coordinates\", [])\n        elif route.get(\"type\") == \"Feature\":\n            geometry = route.get(\"geometry\", {})\n            if geometry.get(\"type\") == \"LineString\":\n                coordinates = geometry.get(\"coordinates\", [])\n            else:\n                raise ValueError(\"Feature geometry must be LineString\")\n        elif route.get(\"type\") == \"FeatureCollection\":\n            features = route.get(\"features\", [])\n            if (\n                features\n                and features[0].get(\"geometry\", {}).get(\"type\") == \"LineString\"\n            ):\n                coordinates = features[0][\"geometry\"][\"coordinates\"]\n            else:\n                raise ValueError(\n                    \"FeatureCollection must contain LineString features\"\n                )\n        else:\n            raise ValueError(\n                \"GeoJSON must be LineString, Feature, or FeatureCollection\"\n            )\n    else:\n        # Try to convert using to_geojson\n        geojson = to_geojson(route)\n        if geojson.get(\"type\") == \"url\":\n            geojson = fetch_geojson(geojson[\"url\"])\n        # Extract coordinates from the converted geojson\n        if geojson.get(\"type\") == \"FeatureCollection\":\n            features = geojson.get(\"features\", [])\n            if features:\n                coordinates = features[0].get(\"geometry\", {}).get(\"coordinates\", [])\n            else:\n                raise ValueError(\"No features found in data\")\n        elif geojson.get(\"type\") == \"Feature\":\n            coordinates = geojson.get(\"geometry\", {}).get(\"coordinates\", [])\n        else:\n            coordinates = geojson.get(\"coordinates\", [])\n\n    if len(coordinates) &lt; 2:\n        raise ValueError(\"Route must have at least 2 points\")\n\n    self.call_js_method(\n        \"animateAlongRoute\",\n        id=anim_id,\n        coordinates=coordinates,\n        duration=duration,\n        loop=loop,\n        markerColor=marker_color,\n        markerSize=marker_size,\n        showTrail=show_trail,\n        trailColor=trail_color,\n        trailWidth=trail_width,\n        **kwargs,\n    )\n\n    self._layers = {\n        **self._layers,\n        anim_id: {\n            \"id\": anim_id,\n            \"type\": \"animation\",\n        },\n    }\n    return anim_id\n</code></pre>"},{"location":"maplibre/#anymap_ts.maplibre.MapLibreMap.clear_draw_data","title":"<code>clear_draw_data(self)</code>","text":"<p>Clear all drawn features.</p> Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def clear_draw_data(self) -&gt; None:\n    \"\"\"Clear all drawn features.\"\"\"\n    self._draw_data = {\"type\": \"FeatureCollection\", \"features\": []}\n    self.call_js_method(\"clearDrawData\")\n</code></pre>"},{"location":"maplibre/#anymap_ts.maplibre.MapLibreMap.get_draw_data","title":"<code>get_draw_data(self)</code>","text":"<p>Get the current drawn features as GeoJSON.</p> <p>Returns:</p> Type Description <code>Dict</code> <p>GeoJSON FeatureCollection of drawn features</p> Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def get_draw_data(self) -&gt; Dict:\n    \"\"\"Get the current drawn features as GeoJSON.\n\n    Returns:\n        GeoJSON FeatureCollection of drawn features\n    \"\"\"\n    self.call_js_method(\"getDrawData\")\n    # Small delay to allow JS to update the trait\n    import time\n\n    time.sleep(0.1)\n    return self._draw_data or {\"type\": \"FeatureCollection\", \"features\": []}\n</code></pre>"},{"location":"maplibre/#anymap_ts.maplibre.MapLibreMap.get_layer","title":"<code>get_layer(self, layer_id)</code>","text":"<p>Get layer configuration by ID.</p> <p>Parameters:</p> Name Type Description Default <code>layer_id</code> <code>str</code> <p>Layer identifier.</p> required <p>Returns:</p> Type Description <code>Optional[Dict]</code> <p>Layer configuration dict or None if not found.</p> Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def get_layer(self, layer_id: str) -&gt; Optional[Dict]:\n    \"\"\"Get layer configuration by ID.\n\n    Args:\n        layer_id: Layer identifier.\n\n    Returns:\n        Layer configuration dict or None if not found.\n    \"\"\"\n    return self._layers.get(layer_id)\n</code></pre>"},{"location":"maplibre/#anymap_ts.maplibre.MapLibreMap.get_layer_ids","title":"<code>get_layer_ids(self)</code>","text":"<p>Get list of all layer IDs.</p> <p>Returns:</p> Type Description <code>List[str]</code> <p>List of layer identifiers.</p> Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def get_layer_ids(self) -&gt; List[str]:\n    \"\"\"Get list of all layer IDs.\n\n    Returns:\n        List of layer identifiers.\n    \"\"\"\n    return list(self._layers.keys())\n</code></pre>"},{"location":"maplibre/#anymap_ts.maplibre.MapLibreMap.get_visible_features","title":"<code>get_visible_features(self, layers=None)</code>","text":"<p>Get all features currently visible in the viewport.</p> <p>This triggers a query to the JavaScript side. The result is returned asynchronously via the <code>_queried_features</code> trait.</p> <p>On the first call, the query is sent and <code>None</code> is returned because the JavaScript side has not yet responded. Run this method in one notebook cell, then read the result in the next cell (the event loop processes the response between cells).</p> <p>Parameters:</p> Name Type Description Default <code>layers</code> <code>Optional[List[str]]</code> <p>Optional list of layer IDs to query. If <code>None</code>, queries all visible layers.</p> <code>None</code> <p>Returns:</p> Type Description <code>Optional[Dict]</code> <p>GeoJSON FeatureCollection dict if results are available from a previous query, otherwise <code>None</code>.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; # Cell 1 \u2013 trigger the query\n&gt;&gt;&gt; m.get_visible_features(layers=[\"my-layer\"])\n&gt;&gt;&gt; # Cell 2 \u2013 read the result\n&gt;&gt;&gt; m.get_visible_features()\n</code></pre> Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def get_visible_features(\n    self,\n    layers: Optional[List[str]] = None,\n) -&gt; Optional[Dict]:\n    \"\"\"Get all features currently visible in the viewport.\n\n    This triggers a query to the JavaScript side. The result is\n    returned asynchronously via the ``_queried_features`` trait.\n\n    On the first call, the query is sent and ``None`` is returned\n    because the JavaScript side has not yet responded. Run this\n    method in one notebook cell, then read the result in the next\n    cell (the event loop processes the response between cells).\n\n    Args:\n        layers: Optional list of layer IDs to query. If ``None``,\n            queries all visible layers.\n\n    Returns:\n        GeoJSON FeatureCollection dict if results are available from\n        a previous query, otherwise ``None``.\n\n    Example:\n        &gt;&gt;&gt; # Cell 1 \u2013 trigger the query\n        &gt;&gt;&gt; m.get_visible_features(layers=[\"my-layer\"])\n        &gt;&gt;&gt; # Cell 2 \u2013 read the result\n        &gt;&gt;&gt; m.get_visible_features()\n    \"\"\"\n    if layers is not None:\n        self.call_js_method(\"getVisibleFeatures\", layers=layers)\n    features = self._queried_features\n    if features and \"data\" in features:\n        return features[\"data\"]\n    return None\n</code></pre>"},{"location":"maplibre/#anymap_ts.maplibre.MapLibreMap.load_draw_data","title":"<code>load_draw_data(self, geojson)</code>","text":"<p>Load GeoJSON features into the drawing layer.</p> <p>Parameters:</p> Name Type Description Default <code>geojson</code> <code>Dict</code> <p>GeoJSON FeatureCollection to load</p> required Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def load_draw_data(self, geojson: Dict) -&gt; None:\n    \"\"\"Load GeoJSON features into the drawing layer.\n\n    Args:\n        geojson: GeoJSON FeatureCollection to load\n    \"\"\"\n    self._draw_data = geojson\n    self.call_js_method(\"loadDrawData\", geojson)\n</code></pre>"},{"location":"maplibre/#anymap_ts.maplibre.MapLibreMap.move_layer","title":"<code>move_layer(self, layer_id, before_id=None)</code>","text":"<p>Move a layer in the layer stack.</p> <p>Parameters:</p> Name Type Description Default <code>layer_id</code> <code>str</code> <p>Layer identifier to move.</p> required <code>before_id</code> <code>Optional[str]</code> <p>ID of layer to move before. If None, moves to top.</p> <code>None</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; m.move_layer(\"my-layer\", \"other-layer\")  # Move before other-layer\n&gt;&gt;&gt; m.move_layer(\"my-layer\")  # Move to top\n</code></pre> Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def move_layer(self, layer_id: str, before_id: Optional[str] = None) -&gt; None:\n    \"\"\"Move a layer in the layer stack.\n\n    Args:\n        layer_id: Layer identifier to move.\n        before_id: ID of layer to move before. If None, moves to top.\n\n    Example:\n        &gt;&gt;&gt; m.move_layer(\"my-layer\", \"other-layer\")  # Move before other-layer\n        &gt;&gt;&gt; m.move_layer(\"my-layer\")  # Move to top\n    \"\"\"\n    self.call_js_method(\"moveLayer\", layer_id, before_id)\n</code></pre>"},{"location":"maplibre/#anymap_ts.maplibre.MapLibreMap.pause_animation","title":"<code>pause_animation(self, animation_id)</code>","text":"<p>Pause a running animation.</p> <p>Parameters:</p> Name Type Description Default <code>animation_id</code> <code>str</code> <p>Animation identifier to pause.</p> required Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def pause_animation(self, animation_id: str) -&gt; None:\n    \"\"\"Pause a running animation.\n\n    Args:\n        animation_id: Animation identifier to pause.\n    \"\"\"\n    self.call_js_method(\"pauseAnimation\", animation_id)\n</code></pre>"},{"location":"maplibre/#anymap_ts.maplibre.MapLibreMap.pause_video","title":"<code>pause_video(self, name)</code>","text":"<p>Pause a video layer.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The video layer identifier.</p> required Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def pause_video(self, name: str) -&gt; None:\n    \"\"\"Pause a video layer.\n\n    Args:\n        name: The video layer identifier.\n    \"\"\"\n    self.call_js_method(\"pauseVideo\", id=name)\n</code></pre>"},{"location":"maplibre/#anymap_ts.maplibre.MapLibreMap.play_video","title":"<code>play_video(self, name)</code>","text":"<p>Start playing a video layer.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The video layer identifier.</p> required Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def play_video(self, name: str) -&gt; None:\n    \"\"\"Start playing a video layer.\n\n    Args:\n        name: The video layer identifier.\n    \"\"\"\n    self.call_js_method(\"playVideo\", id=name)\n</code></pre>"},{"location":"maplibre/#anymap_ts.maplibre.MapLibreMap.query_rendered_features","title":"<code>query_rendered_features(self, geometry=None, layers=None, filter_expression=None)</code>","text":"<p>Query features currently rendered on the map.</p> <p>Results are stored in the <code>queried_features</code> property.</p> <p>Parameters:</p> Name Type Description Default <code>geometry</code> <code>Optional[Any]</code> <p>Optional point {x, y} or bounding box [[x1, y1], [x2, y2]] to limit the query area. If None, queries the entire viewport.</p> <code>None</code> <code>layers</code> <code>Optional[List[str]]</code> <p>Optional list of layer IDs to query. If None, queries all layers.</p> <code>None</code> <code>filter_expression</code> <code>Optional[List]</code> <p>Optional MapLibre filter expression to further filter results.</p> <code>None</code> <p>Returns:</p> Type Description <code>Dict</code> <p>The current queried features dict (may not yet reflect this query if called immediately; use the <code>queried_features</code> property).</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; m.query_rendered_features(layers=[\"states-layer\"])\n&gt;&gt;&gt; features = m.queried_features\n</code></pre> Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def query_rendered_features(\n    self,\n    geometry: Optional[Any] = None,\n    layers: Optional[List[str]] = None,\n    filter_expression: Optional[List] = None,\n) -&gt; Dict:\n    \"\"\"Query features currently rendered on the map.\n\n    Results are stored in the `queried_features` property.\n\n    Args:\n        geometry: Optional point {x, y} or bounding box [[x1, y1], [x2, y2]]\n            to limit the query area. If None, queries the entire viewport.\n        layers: Optional list of layer IDs to query. If None, queries all\n            layers.\n        filter_expression: Optional MapLibre filter expression to further\n            filter results.\n\n    Returns:\n        The current queried features dict (may not yet reflect this query\n        if called immediately; use the `queried_features` property).\n\n    Example:\n        &gt;&gt;&gt; m.query_rendered_features(layers=[\"states-layer\"])\n        &gt;&gt;&gt; features = m.queried_features\n    \"\"\"\n    kwargs: Dict[str, Any] = {}\n    if geometry is not None:\n        kwargs[\"geometry\"] = geometry\n    if layers is not None:\n        kwargs[\"layers\"] = layers\n    if filter_expression is not None:\n        kwargs[\"filter\"] = filter_expression\n\n    self.call_js_method(\"queryRenderedFeatures\", **kwargs)\n    return self._queried_features\n</code></pre>"},{"location":"maplibre/#anymap_ts.maplibre.MapLibreMap.query_source_features","title":"<code>query_source_features(self, source_id, source_layer=None, filter_expression=None)</code>","text":"<p>Query features from a source, including features not currently visible.</p> <p>Results are stored in the <code>queried_features</code> property.</p> <p>Parameters:</p> Name Type Description Default <code>source_id</code> <code>str</code> <p>The source to query.</p> required <code>source_layer</code> <code>Optional[str]</code> <p>Optional source layer for vector tile sources.</p> <code>None</code> <code>filter_expression</code> <code>Optional[List]</code> <p>Optional MapLibre filter expression.</p> <code>None</code> <p>Returns:</p> Type Description <code>Dict</code> <p>The current queried features dict.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; m.query_source_features(\"states-source\")\n&gt;&gt;&gt; features = m.queried_features\n</code></pre> Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def query_source_features(\n    self,\n    source_id: str,\n    source_layer: Optional[str] = None,\n    filter_expression: Optional[List] = None,\n) -&gt; Dict:\n    \"\"\"Query features from a source, including features not currently visible.\n\n    Results are stored in the `queried_features` property.\n\n    Args:\n        source_id: The source to query.\n        source_layer: Optional source layer for vector tile sources.\n        filter_expression: Optional MapLibre filter expression.\n\n    Returns:\n        The current queried features dict.\n\n    Example:\n        &gt;&gt;&gt; m.query_source_features(\"states-source\")\n        &gt;&gt;&gt; features = m.queried_features\n    \"\"\"\n    kwargs: Dict[str, Any] = {\"sourceId\": source_id}\n    if source_layer is not None:\n        kwargs[\"sourceLayer\"] = source_layer\n    if filter_expression is not None:\n        kwargs[\"filter\"] = filter_expression\n\n    self.call_js_method(\"querySourceFeatures\", **kwargs)\n    return self._queried_features\n</code></pre>"},{"location":"maplibre/#anymap_ts.maplibre.MapLibreMap.remove_arc_layer","title":"<code>remove_arc_layer(self, layer_id)</code>","text":"<p>Remove an arc layer.</p> <p>Parameters:</p> Name Type Description Default <code>layer_id</code> <code>str</code> <p>Layer identifier to remove.</p> required Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def remove_arc_layer(self, layer_id: str) -&gt; None:\n    \"\"\"Remove an arc layer.\n\n    Args:\n        layer_id: Layer identifier to remove.\n    \"\"\"\n    self._remove_layer_internal(layer_id, \"removeArcLayer\")\n</code></pre>"},{"location":"maplibre/#anymap_ts.maplibre.MapLibreMap.remove_cluster_layer","title":"<code>remove_cluster_layer(self, layer_id)</code>","text":"<p>Remove a cluster layer and all its sublayers.</p> <p>Parameters:</p> Name Type Description Default <code>layer_id</code> <code>str</code> <p>Layer identifier to remove.</p> required Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def remove_cluster_layer(self, layer_id: str) -&gt; None:\n    \"\"\"Remove a cluster layer and all its sublayers.\n\n    Args:\n        layer_id: Layer identifier to remove.\n    \"\"\"\n    self._remove_layer_internal(layer_id, \"removeClusterLayer\")\n</code></pre>"},{"location":"maplibre/#anymap_ts.maplibre.MapLibreMap.remove_cog_layer","title":"<code>remove_cog_layer(self, layer_id)</code>","text":"<p>Remove a COG layer.</p> <p>Parameters:</p> Name Type Description Default <code>layer_id</code> <code>str</code> <p>Layer identifier to remove.</p> required Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def remove_cog_layer(self, layer_id: str) -&gt; None:\n    \"\"\"Remove a COG layer.\n\n    Args:\n        layer_id: Layer identifier to remove.\n    \"\"\"\n    self._remove_layer_internal(layer_id, \"removeCOGLayer\")\n</code></pre>"},{"location":"maplibre/#anymap_ts.maplibre.MapLibreMap.remove_colorbar","title":"<code>remove_colorbar(self, colorbar_id=None)</code>","text":"<p>Remove a colorbar from the map.</p> <p>Parameters:</p> Name Type Description Default <code>colorbar_id</code> <code>Optional[str]</code> <p>Colorbar identifier to remove. If None, removes all colorbars.</p> <code>None</code> Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def remove_colorbar(self, colorbar_id: Optional[str] = None) -&gt; None:\n    \"\"\"Remove a colorbar from the map.\n\n    Args:\n        colorbar_id: Colorbar identifier to remove. If None, removes\n            all colorbars.\n    \"\"\"\n    if colorbar_id is None:\n        cbar_keys = [k for k in self._controls.keys() if k.startswith(\"colorbar\")]\n        for key in cbar_keys:\n            self.call_js_method(\"removeColorbar\", colorbarId=key)\n        self._controls = {\n            k: v for k, v in self._controls.items() if not k.startswith(\"colorbar\")\n        }\n    else:\n        self.call_js_method(\"removeColorbar\", colorbarId=colorbar_id)\n        if colorbar_id in self._controls:\n            controls = dict(self._controls)\n            del controls[colorbar_id]\n            self._controls = controls\n</code></pre>"},{"location":"maplibre/#anymap_ts.maplibre.MapLibreMap.remove_control","title":"<code>remove_control(self, control_type)</code>","text":"<p>Remove a map control.</p> <p>Parameters:</p> Name Type Description Default <code>control_type</code> <code>str</code> <p>Type of control to remove</p> required Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def remove_control(self, control_type: str) -&gt; None:\n    \"\"\"Remove a map control.\n\n    Args:\n        control_type: Type of control to remove\n    \"\"\"\n    self.call_js_method(\"removeControl\", control_type)\n    if control_type in self._controls:\n        controls = dict(self._controls)\n        del controls[control_type]\n        self._controls = controls\n</code></pre>"},{"location":"maplibre/#anymap_ts.maplibre.MapLibreMap.remove_coordinates_control","title":"<code>remove_coordinates_control(self)</code>","text":"<p>Remove the coordinates display control.</p> Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def remove_coordinates_control(self) -&gt; None:\n    \"\"\"Remove the coordinates display control.\"\"\"\n    self.call_js_method(\"removeCoordinatesControl\")\n</code></pre>"},{"location":"maplibre/#anymap_ts.maplibre.MapLibreMap.remove_deck_layer","title":"<code>remove_deck_layer(self, layer_id)</code>","text":"<p>Remove a deck.gl layer from the map.</p> <p>Parameters:</p> Name Type Description Default <code>layer_id</code> <code>str</code> <p>Layer identifier to remove.</p> required Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def remove_deck_layer(self, layer_id: str) -&gt; None:\n    \"\"\"Remove a deck.gl layer from the map.\n\n    Args:\n        layer_id: Layer identifier to remove.\n    \"\"\"\n    self._remove_layer_internal(layer_id, \"removeDeckLayer\")\n</code></pre>"},{"location":"maplibre/#anymap_ts.maplibre.MapLibreMap.remove_flatgeobuf","title":"<code>remove_flatgeobuf(self, name)</code>","text":"<p>Remove a FlatGeobuf layer from the map.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The layer identifier to remove.</p> required Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def remove_flatgeobuf(self, name: str) -&gt; None:\n    \"\"\"Remove a FlatGeobuf layer from the map.\n\n    Args:\n        name: The layer identifier to remove.\n    \"\"\"\n    if name in self._layers:\n        layers = dict(self._layers)\n        del layers[name]\n        self._layers = layers\n    self._remove_from_layer_dict(name)\n    self.call_js_method(\"removeFlatGeobuf\", name=name)\n</code></pre>"},{"location":"maplibre/#anymap_ts.maplibre.MapLibreMap.remove_layer","title":"<code>remove_layer(self, layer_id)</code>","text":"<p>Remove a layer from the map.</p> <p>Parameters:</p> Name Type Description Default <code>layer_id</code> <code>str</code> <p>Layer identifier to remove</p> required Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def remove_layer(self, layer_id: str) -&gt; None:\n    \"\"\"Remove a layer from the map.\n\n    Args:\n        layer_id: Layer identifier to remove\n    \"\"\"\n    if layer_id in self._layers:\n        layers = dict(self._layers)\n        del layers[layer_id]\n        self._layers = layers\n    self._remove_from_layer_dict(layer_id)\n    self.call_js_method(\"removeLayer\", layer_id)\n</code></pre>"},{"location":"maplibre/#anymap_ts.maplibre.MapLibreMap.remove_legend","title":"<code>remove_legend(self, legend_id=None)</code>","text":"<p>Remove a legend control from the map.</p> <p>Parameters:</p> Name Type Description Default <code>legend_id</code> <code>Optional[str]</code> <p>Legend identifier to remove. If None, removes all legends.</p> <code>None</code> Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def remove_legend(self, legend_id: Optional[str] = None) -&gt; None:\n    \"\"\"Remove a legend control from the map.\n\n    Args:\n        legend_id: Legend identifier to remove. If None, removes all legends.\n    \"\"\"\n    if legend_id is None:\n        # Remove all legends - create a copy of keys before iterating\n        legend_keys = [k for k in self._controls.keys() if k.startswith(\"legend\")]\n        for key in legend_keys:\n            self.call_js_method(\"removeLegend\", key)\n        # Rebuild controls dict without legend keys\n        self._controls = {\n            k: v for k, v in self._controls.items() if not k.startswith(\"legend\")\n        }\n    else:\n        self.call_js_method(\"removeLegend\", legend_id)\n        if legend_id in self._controls:\n            controls = dict(self._controls)\n            del controls[legend_id]\n            self._controls = controls\n</code></pre>"},{"location":"maplibre/#anymap_ts.maplibre.MapLibreMap.remove_lidar_layer","title":"<code>remove_lidar_layer(self, layer_id=None)</code>","text":"<p>Remove a LiDAR layer.</p> <p>Parameters:</p> Name Type Description Default <code>layer_id</code> <code>Optional[str]</code> <p>Layer identifier to remove. If None, removes all LiDAR layers.</p> <code>None</code> Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def remove_lidar_layer(self, layer_id: Optional[str] = None) -&gt; None:\n    \"\"\"Remove a LiDAR layer.\n\n    Args:\n        layer_id: Layer identifier to remove. If None, removes all LiDAR layers.\n    \"\"\"\n    if layer_id:\n        if layer_id in self._layers:\n            layers = dict(self._layers)\n            del layers[layer_id]\n            self._layers = layers\n        self.call_js_method(\"removeLidarLayer\", id=layer_id)\n    else:\n        # Remove all lidar layers\n        layers = dict(self._layers)\n        self._layers = {k: v for k, v in layers.items() if v.get(\"type\") != \"lidar\"}\n        self.call_js_method(\"removeLidarLayer\")\n</code></pre>"},{"location":"maplibre/#anymap_ts.maplibre.MapLibreMap.remove_marker","title":"<code>remove_marker(self, marker_id)</code>","text":"<p>Remove a marker from the map.</p> <p>Parameters:</p> Name Type Description Default <code>marker_id</code> <code>str</code> <p>Marker identifier to remove.</p> required Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def remove_marker(self, marker_id: str) -&gt; None:\n    \"\"\"Remove a marker from the map.\n\n    Args:\n        marker_id: Marker identifier to remove.\n    \"\"\"\n    self._remove_layer_internal(marker_id, \"removeMarker\")\n</code></pre>"},{"location":"maplibre/#anymap_ts.maplibre.MapLibreMap.remove_measure_control","title":"<code>remove_measure_control(self)</code>","text":"<p>Remove the measurement control from the map.</p> Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def remove_measure_control(self) -&gt; None:\n    \"\"\"Remove the measurement control from the map.\"\"\"\n    self.call_js_method(\"removeMeasureControl\")\n    if \"measure-control\" in self._controls:\n        controls = dict(self._controls)\n        del controls[\"measure-control\"]\n        self._controls = controls\n</code></pre>"},{"location":"maplibre/#anymap_ts.maplibre.MapLibreMap.remove_opacity_slider","title":"<code>remove_opacity_slider(self, layer_id)</code>","text":"<p>Remove the opacity slider for a layer.</p> <p>Parameters:</p> Name Type Description Default <code>layer_id</code> <code>str</code> <p>Layer identifier.</p> required Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def remove_opacity_slider(self, layer_id: str) -&gt; None:\n    \"\"\"Remove the opacity slider for a layer.\n\n    Args:\n        layer_id: Layer identifier.\n    \"\"\"\n    self.call_js_method(\"removeOpacitySlider\", layerId=layer_id)\n</code></pre>"},{"location":"maplibre/#anymap_ts.maplibre.MapLibreMap.remove_pmtiles_layer","title":"<code>remove_pmtiles_layer(self, layer_id)</code>","text":"<p>Remove a PMTiles layer.</p> <p>Parameters:</p> Name Type Description Default <code>layer_id</code> <code>str</code> <p>Layer identifier to remove.</p> required Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def remove_pmtiles_layer(self, layer_id: str) -&gt; None:\n    \"\"\"Remove a PMTiles layer.\n\n    Args:\n        layer_id: Layer identifier to remove.\n    \"\"\"\n    self._remove_layer_internal(layer_id, \"removePMTilesLayer\")\n</code></pre>"},{"location":"maplibre/#anymap_ts.maplibre.MapLibreMap.remove_point_cloud_layer","title":"<code>remove_point_cloud_layer(self, layer_id)</code>","text":"<p>Remove a point cloud layer.</p> <p>Parameters:</p> Name Type Description Default <code>layer_id</code> <code>str</code> <p>Layer identifier to remove.</p> required Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def remove_point_cloud_layer(self, layer_id: str) -&gt; None:\n    \"\"\"Remove a point cloud layer.\n\n    Args:\n        layer_id: Layer identifier to remove.\n    \"\"\"\n    self._remove_layer_internal(layer_id, \"removePointCloudLayer\")\n</code></pre>"},{"location":"maplibre/#anymap_ts.maplibre.MapLibreMap.remove_print_control","title":"<code>remove_print_control(self)</code>","text":"<p>Remove the print/export control from the map.</p> Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def remove_print_control(self) -&gt; None:\n    \"\"\"Remove the print/export control from the map.\"\"\"\n    self.call_js_method(\"removePrintControl\")\n    if \"print-control\" in self._controls:\n        controls = dict(self._controls)\n        del controls[\"print-control\"]\n        self._controls = controls\n</code></pre>"},{"location":"maplibre/#anymap_ts.maplibre.MapLibreMap.remove_search_control","title":"<code>remove_search_control(self)</code>","text":"<p>Remove the search/geocoder control from the map.</p> Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def remove_search_control(self) -&gt; None:\n    \"\"\"Remove the search/geocoder control from the map.\"\"\"\n    self.call_js_method(\"removeSearchControl\")\n    if \"search-control\" in self._controls:\n        controls = dict(self._controls)\n        del controls[\"search-control\"]\n        self._controls = controls\n</code></pre>"},{"location":"maplibre/#anymap_ts.maplibre.MapLibreMap.remove_sky","title":"<code>remove_sky(self)</code>","text":"<p>Remove sky and fog atmospheric effects from the map.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; m.remove_sky()\n</code></pre> Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def remove_sky(self) -&gt; None:\n    \"\"\"Remove sky and fog atmospheric effects from the map.\n\n    Example:\n        &gt;&gt;&gt; m.remove_sky()\n    \"\"\"\n    self.call_js_method(\"removeSky\")\n</code></pre>"},{"location":"maplibre/#anymap_ts.maplibre.MapLibreMap.remove_split_map","title":"<code>remove_split_map(self)</code>","text":"<p>Remove the split map comparison view.</p> <p>Restores the map to normal single-view mode with all layers visible.</p> Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def remove_split_map(self) -&gt; None:\n    \"\"\"Remove the split map comparison view.\n\n    Restores the map to normal single-view mode with all layers visible.\n    \"\"\"\n    self.call_js_method(\"removeSplitMap\")\n</code></pre>"},{"location":"maplibre/#anymap_ts.maplibre.MapLibreMap.remove_style_switcher","title":"<code>remove_style_switcher(self)</code>","text":"<p>Remove the style switcher control.</p> Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def remove_style_switcher(self) -&gt; None:\n    \"\"\"Remove the style switcher control.\"\"\"\n    self.call_js_method(\"removeStyleSwitcher\")\n</code></pre>"},{"location":"maplibre/#anymap_ts.maplibre.MapLibreMap.remove_swipe_map","title":"<code>remove_swipe_map(self)</code>","text":"<p>Remove the swipe map comparison control.</p> Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def remove_swipe_map(self) -&gt; None:\n    \"\"\"Remove the swipe map comparison control.\"\"\"\n    self.call_js_method(\"removeSwipeMap\")\n</code></pre>"},{"location":"maplibre/#anymap_ts.maplibre.MapLibreMap.remove_time_slider","title":"<code>remove_time_slider(self)</code>","text":"<p>Remove the time slider control.</p> Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def remove_time_slider(self) -&gt; None:\n    \"\"\"Remove the time slider control.\"\"\"\n    self.call_js_method(\"removeTimeSlider\")\n</code></pre>"},{"location":"maplibre/#anymap_ts.maplibre.MapLibreMap.remove_tooltip","title":"<code>remove_tooltip(self, layer_id)</code>","text":"<p>Remove tooltip from a layer.</p> <p>Parameters:</p> Name Type Description Default <code>layer_id</code> <code>str</code> <p>The layer identifier.</p> required Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def remove_tooltip(self, layer_id: str) -&gt; None:\n    \"\"\"Remove tooltip from a layer.\n\n    Args:\n        layer_id: The layer identifier.\n    \"\"\"\n    self.call_js_method(\"removeTooltip\", layerId=layer_id)\n</code></pre>"},{"location":"maplibre/#anymap_ts.maplibre.MapLibreMap.remove_video_layer","title":"<code>remove_video_layer(self, name)</code>","text":"<p>Remove a video layer from the map.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The layer identifier to remove.</p> required Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def remove_video_layer(self, name: str) -&gt; None:\n    \"\"\"Remove a video layer from the map.\n\n    Args:\n        name: The layer identifier to remove.\n    \"\"\"\n    if name in self._layers:\n        layers = dict(self._layers)\n        del layers[name]\n        self._layers = layers\n    self._remove_from_layer_dict(name)\n    self.call_js_method(\"removeVideoLayer\", id=name)\n</code></pre>"},{"location":"maplibre/#anymap_ts.maplibre.MapLibreMap.remove_zarr_layer","title":"<code>remove_zarr_layer(self, layer_id)</code>","text":"<p>Remove a Zarr layer.</p> <p>Parameters:</p> Name Type Description Default <code>layer_id</code> <code>str</code> <p>Layer identifier to remove.</p> required Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def remove_zarr_layer(self, layer_id: str) -&gt; None:\n    \"\"\"Remove a Zarr layer.\n\n    Args:\n        layer_id: Layer identifier to remove.\n    \"\"\"\n    self._remove_layer_internal(layer_id, \"removeZarrLayer\")\n</code></pre>"},{"location":"maplibre/#anymap_ts.maplibre.MapLibreMap.resume_animation","title":"<code>resume_animation(self, animation_id)</code>","text":"<p>Resume a paused animation.</p> <p>Parameters:</p> Name Type Description Default <code>animation_id</code> <code>str</code> <p>Animation identifier to resume.</p> required Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def resume_animation(self, animation_id: str) -&gt; None:\n    \"\"\"Resume a paused animation.\n\n    Args:\n        animation_id: Animation identifier to resume.\n    \"\"\"\n    self.call_js_method(\"resumeAnimation\", animation_id)\n</code></pre>"},{"location":"maplibre/#anymap_ts.maplibre.MapLibreMap.save_draw_data","title":"<code>save_draw_data(self, filepath, driver=None)</code>","text":"<p>Save drawn features to a file.</p> <p>Parameters:</p> Name Type Description Default <code>filepath</code> <code>Union[str, Path]</code> <p>Path to save file</p> required <code>driver</code> <code>Optional[str]</code> <p>Output driver (auto-detected from extension if not provided)</p> <code>None</code> <p>Exceptions:</p> Type Description <code>ImportError</code> <p>If geopandas is not installed</p> Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def save_draw_data(\n    self,\n    filepath: Union[str, Path],\n    driver: Optional[str] = None,\n) -&gt; None:\n    \"\"\"Save drawn features to a file.\n\n    Args:\n        filepath: Path to save file\n        driver: Output driver (auto-detected from extension if not provided)\n\n    Raises:\n        ImportError: If geopandas is not installed\n    \"\"\"\n    try:\n        import geopandas as gpd\n    except ImportError:\n        raise ImportError(\n            \"geopandas is required to save draw data. \"\n            \"Install with: pip install anymap-ts[vector]\"\n        )\n\n    data = self.get_draw_data()\n    if not data.get(\"features\"):\n        print(\"No features to save\")\n        return\n\n    gdf = gpd.GeoDataFrame.from_features(data[\"features\"])\n    filepath = Path(filepath)\n\n    # Infer driver from extension\n    if driver is None:\n        ext = filepath.suffix.lower()\n        driver_map = {\n            \".geojson\": \"GeoJSON\",\n            \".json\": \"GeoJSON\",\n            \".shp\": \"ESRI Shapefile\",\n            \".gpkg\": \"GPKG\",\n        }\n        driver = driver_map.get(ext, \"GeoJSON\")\n\n    gdf.to_file(filepath, driver=driver)\n</code></pre>"},{"location":"maplibre/#anymap_ts.maplibre.MapLibreMap.seek_video","title":"<code>seek_video(self, name, time)</code>","text":"<p>Seek to a specific time in a video layer.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The video layer identifier.</p> required <code>time</code> <code>float</code> <p>Time in seconds to seek to.</p> required Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def seek_video(self, name: str, time: float) -&gt; None:\n    \"\"\"Seek to a specific time in a video layer.\n\n    Args:\n        name: The video layer identifier.\n        time: Time in seconds to seek to.\n    \"\"\"\n    self.call_js_method(\"seekVideo\", id=name, time=time)\n</code></pre>"},{"location":"maplibre/#anymap_ts.maplibre.MapLibreMap.set_animation_speed","title":"<code>set_animation_speed(self, animation_id, speed)</code>","text":"<p>Set animation speed multiplier.</p> <p>Parameters:</p> Name Type Description Default <code>animation_id</code> <code>str</code> <p>Animation identifier.</p> required <code>speed</code> <code>float</code> <p>Speed multiplier (1.0 = normal, 2.0 = double speed, etc.).</p> required Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def set_animation_speed(self, animation_id: str, speed: float) -&gt; None:\n    \"\"\"Set animation speed multiplier.\n\n    Args:\n        animation_id: Animation identifier.\n        speed: Speed multiplier (1.0 = normal, 2.0 = double speed, etc.).\n    \"\"\"\n    self.call_js_method(\"setAnimationSpeed\", animation_id, speed)\n</code></pre>"},{"location":"maplibre/#anymap_ts.maplibre.MapLibreMap.set_filter","title":"<code>set_filter(self, layer_id, filter_expression=None)</code>","text":"<p>Set or clear a filter on a map layer.</p> <p>Uses MapLibre GL JS filter expressions to show/hide features.</p> <p>Parameters:</p> Name Type Description Default <code>layer_id</code> <code>str</code> <p>The layer to apply the filter to.</p> required <code>filter_expression</code> <code>Optional[List]</code> <p>A MapLibre filter expression (list). Pass None to clear the filter.</p> <code>None</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; m.set_filter(\"states-layer\", [\"&gt;=\", [\"get\", \"density\"], 100])\n&gt;&gt;&gt; m.set_filter(\"states-layer\", None)  # Clear filter\n</code></pre> Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def set_filter(\n    self,\n    layer_id: str,\n    filter_expression: Optional[List] = None,\n) -&gt; None:\n    \"\"\"Set or clear a filter on a map layer.\n\n    Uses MapLibre GL JS filter expressions to show/hide features.\n\n    Args:\n        layer_id: The layer to apply the filter to.\n        filter_expression: A MapLibre filter expression (list).\n            Pass None to clear the filter.\n\n    Example:\n        &gt;&gt;&gt; m.set_filter(\"states-layer\", [\"&gt;=\", [\"get\", \"density\"], 100])\n        &gt;&gt;&gt; m.set_filter(\"states-layer\", None)  # Clear filter\n    \"\"\"\n    self.call_js_method(\n        \"setFilter\",\n        layerId=layer_id,\n        filter=filter_expression,\n    )\n</code></pre>"},{"location":"maplibre/#anymap_ts.maplibre.MapLibreMap.set_layout_property","title":"<code>set_layout_property(self, layer_id, property_name, value)</code>","text":"<p>Set a layout property for a layer.</p> <p>Parameters:</p> Name Type Description Default <code>layer_id</code> <code>str</code> <p>Layer identifier.</p> required <code>property_name</code> <code>str</code> <p>Name of the layout property (e.g., 'visibility').</p> required <code>value</code> <code>Any</code> <p>New value for the property.</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; m.set_layout_property(\"my-layer\", \"visibility\", \"none\")\n</code></pre> Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def set_layout_property(\n    self, layer_id: str, property_name: str, value: Any\n) -&gt; None:\n    \"\"\"Set a layout property for a layer.\n\n    Args:\n        layer_id: Layer identifier.\n        property_name: Name of the layout property (e.g., 'visibility').\n        value: New value for the property.\n\n    Example:\n        &gt;&gt;&gt; m.set_layout_property(\"my-layer\", \"visibility\", \"none\")\n    \"\"\"\n    self.call_js_method(\"setLayoutProperty\", layer_id, property_name, value)\n</code></pre>"},{"location":"maplibre/#anymap_ts.maplibre.MapLibreMap.set_lidar_color_scheme","title":"<code>set_lidar_color_scheme(self, color_scheme)</code>","text":"<p>Set the LiDAR color scheme.</p> <p>Parameters:</p> Name Type Description Default <code>color_scheme</code> <code>str</code> <p>Color scheme ('elevation', 'intensity', 'classification', 'rgb').</p> required Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def set_lidar_color_scheme(self, color_scheme: str) -&gt; None:\n    \"\"\"Set the LiDAR color scheme.\n\n    Args:\n        color_scheme: Color scheme ('elevation', 'intensity', 'classification', 'rgb').\n    \"\"\"\n    self.call_js_method(\"setLidarColorScheme\", colorScheme=color_scheme)\n</code></pre>"},{"location":"maplibre/#anymap_ts.maplibre.MapLibreMap.set_lidar_opacity","title":"<code>set_lidar_opacity(self, opacity)</code>","text":"<p>Set the LiDAR layer opacity.</p> <p>Parameters:</p> Name Type Description Default <code>opacity</code> <code>float</code> <p>Opacity value between 0 and 1.</p> required Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def set_lidar_opacity(self, opacity: float) -&gt; None:\n    \"\"\"Set the LiDAR layer opacity.\n\n    Args:\n        opacity: Opacity value between 0 and 1.\n    \"\"\"\n    self.call_js_method(\"setLidarOpacity\", opacity=opacity)\n</code></pre>"},{"location":"maplibre/#anymap_ts.maplibre.MapLibreMap.set_lidar_point_size","title":"<code>set_lidar_point_size(self, point_size)</code>","text":"<p>Set the LiDAR point size.</p> <p>Parameters:</p> Name Type Description Default <code>point_size</code> <code>float</code> <p>Point size in pixels.</p> required Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def set_lidar_point_size(self, point_size: float) -&gt; None:\n    \"\"\"Set the LiDAR point size.\n\n    Args:\n        point_size: Point size in pixels.\n    \"\"\"\n    self.call_js_method(\"setLidarPointSize\", pointSize=point_size)\n</code></pre>"},{"location":"maplibre/#anymap_ts.maplibre.MapLibreMap.set_opacity","title":"<code>set_opacity(self, layer_id, opacity)</code>","text":"<p>Set layer opacity.</p> <p>Parameters:</p> Name Type Description Default <code>layer_id</code> <code>str</code> <p>Layer identifier</p> required <code>opacity</code> <code>float</code> <p>Opacity value between 0 and 1</p> required Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def set_opacity(self, layer_id: str, opacity: float) -&gt; None:\n    \"\"\"Set layer opacity.\n\n    Args:\n        layer_id: Layer identifier\n        opacity: Opacity value between 0 and 1\n    \"\"\"\n    self._validate_opacity(opacity)\n    self.call_js_method(\"setOpacity\", layer_id, opacity)\n</code></pre>"},{"location":"maplibre/#anymap_ts.maplibre.MapLibreMap.set_paint_property","title":"<code>set_paint_property(self, layer_id, property_name, value)</code>","text":"<p>Set a paint property for a layer.</p> <p>Parameters:</p> Name Type Description Default <code>layer_id</code> <code>str</code> <p>Layer identifier.</p> required <code>property_name</code> <code>str</code> <p>Name of the paint property (e.g., 'fill-color').</p> required <code>value</code> <code>Any</code> <p>New value for the property.</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; m.set_paint_property(\"my-layer\", \"fill-color\", \"#ff0000\")\n&gt;&gt;&gt; m.set_paint_property(\"my-layer\", \"fill-opacity\", 0.5)\n</code></pre> Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def set_paint_property(self, layer_id: str, property_name: str, value: Any) -&gt; None:\n    \"\"\"Set a paint property for a layer.\n\n    Args:\n        layer_id: Layer identifier.\n        property_name: Name of the paint property (e.g., 'fill-color').\n        value: New value for the property.\n\n    Example:\n        &gt;&gt;&gt; m.set_paint_property(\"my-layer\", \"fill-color\", \"#ff0000\")\n        &gt;&gt;&gt; m.set_paint_property(\"my-layer\", \"fill-opacity\", 0.5)\n    \"\"\"\n    self.call_js_method(\"setPaintProperty\", layer_id, property_name, value)\n</code></pre>"},{"location":"maplibre/#anymap_ts.maplibre.MapLibreMap.set_projection","title":"<code>set_projection(self, projection='mercator')</code>","text":"<p>Set the map projection.</p> <p>MapLibre GL JS v4+ supports globe projection for a 3D globe view.</p> <p>Parameters:</p> Name Type Description Default <code>projection</code> <code>str</code> <p>Projection type. Supported values: 'mercator', 'globe'.</p> <code>'mercator'</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; m = MapLibreMap()\n&gt;&gt;&gt; m.set_projection(\"globe\")\n</code></pre> Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def set_projection(self, projection: str = \"mercator\") -&gt; None:\n    \"\"\"Set the map projection.\n\n    MapLibre GL JS v4+ supports globe projection for a 3D globe view.\n\n    Args:\n        projection: Projection type. Supported values: 'mercator', 'globe'.\n\n    Example:\n        &gt;&gt;&gt; m = MapLibreMap()\n        &gt;&gt;&gt; m.set_projection(\"globe\")\n    \"\"\"\n    self.call_js_method(\"setProjection\", projection=projection)\n</code></pre>"},{"location":"maplibre/#anymap_ts.maplibre.MapLibreMap.set_sky","title":"<code>set_sky(self, sky_color='#88C6FC', horizon_color='#F0E4D4', fog_color='#FFFFFF', sky_horizon_blend=0.5, horizon_fog_blend=0.5, fog_ground_blend=0.5, atmosphere_blend=0.8, **kwargs)</code>","text":"<p>Set sky and fog atmospheric effects for 3D terrain visualization.</p> <p>MapLibre v5 unifies sky and fog into a single <code>map.setSky()</code> API. Best used with 3D terrain enabled.</p> <p>Parameters:</p> Name Type Description Default <code>sky_color</code> <code>str</code> <p>Color of the sky. Default is \"#88C6FC\".</p> <code>'#88C6FC'</code> <code>horizon_color</code> <code>str</code> <p>Color at the horizon. Default is \"#F0E4D4\".</p> <code>'#F0E4D4'</code> <code>fog_color</code> <code>str</code> <p>Color of the fog. Default is \"#FFFFFF\".</p> <code>'#FFFFFF'</code> <code>sky_horizon_blend</code> <code>float</code> <p>Blend between sky and horizon (0-1). Default is 0.5.</p> <code>0.5</code> <code>horizon_fog_blend</code> <code>float</code> <p>Blend between horizon and fog (0-1). Default is 0.5.</p> <code>0.5</code> <code>fog_ground_blend</code> <code>float</code> <p>Blend between fog and ground (0-1). Default is 0.5.</p> <code>0.5</code> <code>atmosphere_blend</code> <code>float</code> <p>Intensity of the atmosphere effect (0-1). Default is 0.8.</p> <code>0.8</code> <code>**kwargs</code> <p>Additional sky options.</p> <code>{}</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from anymap_ts import Map\n&gt;&gt;&gt; m = Map(center=[-122.4, 37.8], zoom=12, pitch=60)\n&gt;&gt;&gt; m.add_3d_terrain(exaggeration=1.5)\n&gt;&gt;&gt; m.set_sky()\n</code></pre> Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def set_sky(\n    self,\n    sky_color: str = \"#88C6FC\",\n    horizon_color: str = \"#F0E4D4\",\n    fog_color: str = \"#FFFFFF\",\n    sky_horizon_blend: float = 0.5,\n    horizon_fog_blend: float = 0.5,\n    fog_ground_blend: float = 0.5,\n    atmosphere_blend: float = 0.8,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Set sky and fog atmospheric effects for 3D terrain visualization.\n\n    MapLibre v5 unifies sky and fog into a single `map.setSky()` API.\n    Best used with 3D terrain enabled.\n\n    Args:\n        sky_color: Color of the sky. Default is \"#88C6FC\".\n        horizon_color: Color at the horizon. Default is \"#F0E4D4\".\n        fog_color: Color of the fog. Default is \"#FFFFFF\".\n        sky_horizon_blend: Blend between sky and horizon (0-1).\n            Default is 0.5.\n        horizon_fog_blend: Blend between horizon and fog (0-1).\n            Default is 0.5.\n        fog_ground_blend: Blend between fog and ground (0-1).\n            Default is 0.5.\n        atmosphere_blend: Intensity of the atmosphere effect (0-1).\n            Default is 0.8.\n        **kwargs: Additional sky options.\n\n    Example:\n        &gt;&gt;&gt; from anymap_ts import Map\n        &gt;&gt;&gt; m = Map(center=[-122.4, 37.8], zoom=12, pitch=60)\n        &gt;&gt;&gt; m.add_3d_terrain(exaggeration=1.5)\n        &gt;&gt;&gt; m.set_sky()\n    \"\"\"\n    self.call_js_method(\n        \"setSky\",\n        skyColor=sky_color,\n        horizonColor=horizon_color,\n        fogColor=fog_color,\n        skyHorizonBlend=sky_horizon_blend,\n        horizonFogBlend=horizon_fog_blend,\n        fogGroundBlend=fog_ground_blend,\n        atmosphereBlend=atmosphere_blend,\n        **kwargs,\n    )\n</code></pre>"},{"location":"maplibre/#anymap_ts.maplibre.MapLibreMap.set_visibility","title":"<code>set_visibility(self, layer_id, visible)</code>","text":"<p>Set layer visibility.</p> <p>Parameters:</p> Name Type Description Default <code>layer_id</code> <code>str</code> <p>Layer identifier</p> required <code>visible</code> <code>bool</code> <p>Whether layer should be visible</p> required Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def set_visibility(self, layer_id: str, visible: bool) -&gt; None:\n    \"\"\"Set layer visibility.\n\n    Args:\n        layer_id: Layer identifier\n        visible: Whether layer should be visible\n    \"\"\"\n    self.call_js_method(\"setVisibility\", layer_id, visible)\n</code></pre>"},{"location":"maplibre/#anymap_ts.maplibre.MapLibreMap.stop_animation","title":"<code>stop_animation(self, animation_id)</code>","text":"<p>Stop a running animation.</p> <p>Parameters:</p> Name Type Description Default <code>animation_id</code> <code>str</code> <p>Animation identifier to stop.</p> required Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def stop_animation(self, animation_id: str) -&gt; None:\n    \"\"\"Stop a running animation.\n\n    Args:\n        animation_id: Animation identifier to stop.\n    \"\"\"\n    self.call_js_method(\"stopAnimation\", animation_id)\n    if animation_id in self._layers:\n        layers = dict(self._layers)\n        del layers[animation_id]\n        self._layers = layers\n</code></pre>"},{"location":"maplibre/#anymap_ts.maplibre.MapLibreMap.to_geojson","title":"<code>to_geojson(self, layer_id=None)</code>","text":"<p>Get layer data as GeoJSON.</p> <p>This triggers a query to the JavaScript side. The result is returned asynchronously via the <code>_queried_features</code> trait.</p> <p>On the first call with a <code>layer_id</code>, the query is sent and <code>None</code> is returned. Run this method in one notebook cell, then call <code>to_geojson()</code> (without arguments) in the next cell to read the result.</p> <p>Parameters:</p> Name Type Description Default <code>layer_id</code> <code>Optional[str]</code> <p>Source/layer ID to export. If <code>None</code>, returns previously queried features.</p> <code>None</code> <p>Returns:</p> Type Description <code>Optional[Dict]</code> <p>GeoJSON FeatureCollection dict, or <code>None</code> if not yet available.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; # Cell 1 \u2013 trigger the query\n&gt;&gt;&gt; m.to_geojson(\"my-data\")\n&gt;&gt;&gt; # Cell 2 \u2013 read the result\n&gt;&gt;&gt; result = m.to_geojson()\n</code></pre> Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def to_geojson(self, layer_id: Optional[str] = None) -&gt; Optional[Dict]:\n    \"\"\"Get layer data as GeoJSON.\n\n    This triggers a query to the JavaScript side. The result is\n    returned asynchronously via the ``_queried_features`` trait.\n\n    On the first call with a ``layer_id``, the query is sent and\n    ``None`` is returned. Run this method in one notebook cell,\n    then call ``to_geojson()`` (without arguments) in the next cell\n    to read the result.\n\n    Args:\n        layer_id: Source/layer ID to export. If ``None``, returns\n            previously queried features.\n\n    Returns:\n        GeoJSON FeatureCollection dict, or ``None`` if not yet\n        available.\n\n    Example:\n        &gt;&gt;&gt; # Cell 1 \u2013 trigger the query\n        &gt;&gt;&gt; m.to_geojson(\"my-data\")\n        &gt;&gt;&gt; # Cell 2 \u2013 read the result\n        &gt;&gt;&gt; result = m.to_geojson()\n    \"\"\"\n    if layer_id:\n        self.call_js_method(\"getLayerData\", sourceId=layer_id)\n    features = self._queried_features\n    if features and \"data\" in features:\n        return features[\"data\"]\n    return None\n</code></pre>"},{"location":"maplibre/#anymap_ts.maplibre.MapLibreMap.to_geopandas","title":"<code>to_geopandas(self, layer_id=None)</code>","text":"<p>Get layer data as a GeoDataFrame.</p> <p>Requires geopandas to be installed. Works the same as :meth:<code>to_geojson</code> \u2013 trigger with a <code>layer_id</code> in one cell, then call <code>to_geopandas()</code> in the next cell.</p> <p>Parameters:</p> Name Type Description Default <code>layer_id</code> <code>Optional[str]</code> <p>Source/layer ID to export. If <code>None</code>, returns previously queried features.</p> <code>None</code> <p>Returns:</p> Type Description <code>Any</code> <p>GeoDataFrame, or <code>None</code> if data not available.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; # Cell 1 \u2013 trigger the query\n&gt;&gt;&gt; m.to_geojson(\"my-data\")\n&gt;&gt;&gt; # Cell 2 \u2013 read the result\n&gt;&gt;&gt; gdf = m.to_geopandas()\n</code></pre> Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def to_geopandas(self, layer_id: Optional[str] = None) -&gt; Any:\n    \"\"\"Get layer data as a GeoDataFrame.\n\n    Requires geopandas to be installed. Works the same as\n    :meth:`to_geojson` \u2013 trigger with a ``layer_id`` in one cell,\n    then call ``to_geopandas()`` in the next cell.\n\n    Args:\n        layer_id: Source/layer ID to export. If ``None``, returns\n            previously queried features.\n\n    Returns:\n        GeoDataFrame, or ``None`` if data not available.\n\n    Example:\n        &gt;&gt;&gt; # Cell 1 \u2013 trigger the query\n        &gt;&gt;&gt; m.to_geojson(\"my-data\")\n        &gt;&gt;&gt; # Cell 2 \u2013 read the result\n        &gt;&gt;&gt; gdf = m.to_geopandas()\n    \"\"\"\n    geojson = self.to_geojson(layer_id)\n    if geojson is None:\n        return None\n    try:\n        import geopandas as gpd\n\n        return gpd.GeoDataFrame.from_features(geojson.get(\"features\", []))\n    except ImportError:\n        raise ImportError(\"geopandas is required for to_geopandas()\")\n</code></pre>"},{"location":"maplibre/#anymap_ts.maplibre.MapLibreMap.update_colorbar","title":"<code>update_colorbar(self, colorbar_id=None, **kwargs)</code>","text":"<p>Update an existing colorbar's properties.</p> <p>Parameters:</p> Name Type Description Default <code>colorbar_id</code> <code>Optional[str]</code> <p>Colorbar identifier to update. If None, updates the first colorbar found.</p> <code>None</code> <code>**kwargs</code> <p>Properties to update (colormap, vmin, vmax, label, units, orientation, bar_thickness, bar_length, ticks, opacity).</p> <code>{}</code> Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def update_colorbar(self, colorbar_id: Optional[str] = None, **kwargs) -&gt; None:\n    \"\"\"Update an existing colorbar's properties.\n\n    Args:\n        colorbar_id: Colorbar identifier to update. If None, updates\n            the first colorbar found.\n        **kwargs: Properties to update (colormap, vmin, vmax, label,\n            units, orientation, bar_thickness, bar_length, ticks, opacity).\n    \"\"\"\n    if colorbar_id is None:\n        cbar_keys = [k for k in self._controls.keys() if k.startswith(\"colorbar\")]\n        if not cbar_keys:\n            raise ValueError(\"No colorbar found to update\")\n        colorbar_id = cbar_keys[0]\n\n    if colorbar_id not in self._controls:\n        raise ValueError(f\"Colorbar '{colorbar_id}' not found\")\n\n    js_kwargs: Dict[str, Any] = {\"colorbarId\": colorbar_id}\n    key_map = {\n        \"bar_thickness\": \"barThickness\",\n        \"bar_length\": \"barLength\",\n    }\n    for key, value in kwargs.items():\n        js_key = key_map.get(key, key)\n        js_kwargs[js_key] = value\n\n    self.call_js_method(\"updateColorbar\", **js_kwargs)\n\n    for key, value in kwargs.items():\n        if key in self._controls.get(colorbar_id, {}):\n            self._controls[colorbar_id][key] = value\n</code></pre>"},{"location":"maplibre/#anymap_ts.maplibre.MapLibreMap.update_geojson_source","title":"<code>update_geojson_source(self, source_id, data)</code>","text":"<p>Update the data of an existing GeoJSON source in place.</p> <p>This enables real-time/streaming data updates without removing and re-adding layers. Critical for live dashboards.</p> <p>Parameters:</p> Name Type Description Default <code>source_id</code> <code>str</code> <p>The ID of the GeoJSON source to update.</p> required <code>data</code> <code>Any</code> <p>New GeoJSON data (dict, GeoDataFrame, or URL string).</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; m = MapLibreMap()\n&gt;&gt;&gt; m.add_geojson(\"initial.geojson\", name=\"points\")\n&gt;&gt;&gt; # Later, update with new data\n&gt;&gt;&gt; m.update_geojson_source(\"points\", new_geojson_data)\n</code></pre> Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def update_geojson_source(self, source_id: str, data: Any) -&gt; None:\n    \"\"\"Update the data of an existing GeoJSON source in place.\n\n    This enables real-time/streaming data updates without removing\n    and re-adding layers. Critical for live dashboards.\n\n    Args:\n        source_id: The ID of the GeoJSON source to update.\n        data: New GeoJSON data (dict, GeoDataFrame, or URL string).\n\n    Example:\n        &gt;&gt;&gt; m = MapLibreMap()\n        &gt;&gt;&gt; m.add_geojson(\"initial.geojson\", name=\"points\")\n        &gt;&gt;&gt; # Later, update with new data\n        &gt;&gt;&gt; m.update_geojson_source(\"points\", new_geojson_data)\n    \"\"\"\n    processed_data = self._process_deck_data(data)\n    self.call_js_method(\n        \"updateGeoJSONSource\",\n        sourceId=source_id,\n        data=processed_data,\n    )\n</code></pre>"},{"location":"maplibre/#anymap_ts.maplibre.MapLibreMap.update_legend","title":"<code>update_legend(self, legend_id, title=None, labels=None, colors=None, opacity=None, **kwargs)</code>","text":"<p>Update an existing legend's properties.</p> <p>Parameters:</p> Name Type Description Default <code>legend_id</code> <code>str</code> <p>Legend identifier to update</p> required <code>title</code> <code>Optional[str]</code> <p>New title (if provided)</p> <code>None</code> <code>labels</code> <code>Optional[List[str]]</code> <p>New labels list (if provided)</p> <code>None</code> <code>colors</code> <code>Optional[List[str]]</code> <p>New colors list (if provided)</p> <code>None</code> <code>opacity</code> <code>Optional[float]</code> <p>New opacity (if provided)</p> <code>None</code> <code>**kwargs</code> <p>Additional properties to update</p> <code>{}</code> Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def update_legend(\n    self,\n    legend_id: str,\n    title: Optional[str] = None,\n    labels: Optional[List[str]] = None,\n    colors: Optional[List[str]] = None,\n    opacity: Optional[float] = None,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Update an existing legend's properties.\n\n    Args:\n        legend_id: Legend identifier to update\n        title: New title (if provided)\n        labels: New labels list (if provided)\n        colors: New colors list (if provided)\n        opacity: New opacity (if provided)\n        **kwargs: Additional properties to update\n    \"\"\"\n    if legend_id not in self._controls:\n        raise ValueError(f\"Legend '{legend_id}' not found\")\n\n    update_params = {\"id\": legend_id}\n\n    if title is not None:\n        update_params[\"title\"] = title\n        self._controls[legend_id][\"title\"] = title\n\n    if labels is not None and colors is not None:\n        if len(labels) != len(colors):\n            raise ValueError(\"Number of labels must match number of colors\")\n\n        legend_items = [\n            {\"label\": label, \"color\": color} for label, color in zip(labels, colors)\n        ]\n        update_params[\"items\"] = legend_items\n        self._controls[legend_id][\"labels\"] = labels\n        self._controls[legend_id][\"colors\"] = colors\n\n    elif labels is not None or colors is not None:\n        raise ValueError(\"Both labels and colors must be provided together\")\n\n    if opacity is not None:\n        update_params[\"opacity\"] = opacity\n        self._controls[legend_id][\"opacity\"] = opacity\n\n    update_params.update(kwargs)\n    self.call_js_method(\"updateLegend\", **update_params)\n</code></pre>"},{"location":"maplibre/#anymap_ts.maplibre.MapLibreMap.update_zarr_layer","title":"<code>update_zarr_layer(self, layer_id, selector=None, clim=None, colormap=None, opacity=None)</code>","text":"<p>Update a Zarr layer's properties dynamically.</p> <p>Parameters:</p> Name Type Description Default <code>layer_id</code> <code>str</code> <p>Layer identifier.</p> required <code>selector</code> <code>Optional[Dict[str, Any]]</code> <p>New dimension selector.</p> <code>None</code> <code>clim</code> <code>Optional[Tuple[float, float]]</code> <p>New color range.</p> <code>None</code> <code>colormap</code> <code>Optional[List[str]]</code> <p>New colormap.</p> <code>None</code> <code>opacity</code> <code>Optional[float]</code> <p>New opacity value (0-1).</p> <code>None</code> Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def update_zarr_layer(\n    self,\n    layer_id: str,\n    selector: Optional[Dict[str, Any]] = None,\n    clim: Optional[Tuple[float, float]] = None,\n    colormap: Optional[List[str]] = None,\n    opacity: Optional[float] = None,\n) -&gt; None:\n    \"\"\"Update a Zarr layer's properties dynamically.\n\n    Args:\n        layer_id: Layer identifier.\n        selector: New dimension selector.\n        clim: New color range.\n        colormap: New colormap.\n        opacity: New opacity value (0-1).\n    \"\"\"\n    update_kwargs: Dict[str, Any] = {\"id\": layer_id}\n    if selector is not None:\n        update_kwargs[\"selector\"] = selector\n    if clim is not None:\n        update_kwargs[\"clim\"] = list(clim)\n    if colormap is not None:\n        update_kwargs[\"colormap\"] = colormap\n    if opacity is not None:\n        update_kwargs[\"opacity\"] = opacity\n    self.call_js_method(\"updateZarrLayer\", **update_kwargs)\n</code></pre>"},{"location":"openlayers/","title":"openlayers module","text":"<p>OpenLayers map widget implementation.</p>"},{"location":"openlayers/#anymap_ts.openlayers.OpenLayersMap","title":"<code> OpenLayersMap            (MapWidget)         </code>","text":"<p>Interactive map widget using OpenLayers.</p> <p>This class provides a Python interface to OpenLayers maps with full bidirectional communication through anywidget. OpenLayers excels at WMS/WMTS support and projection handling.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from anymap_ts import OpenLayersMap\n&gt;&gt;&gt; m = OpenLayersMap(center=[-122.4, 37.8], zoom=10)\n&gt;&gt;&gt; m.add_basemap(\"OpenStreetMap\")\n&gt;&gt;&gt; m.add_wms_layer(\n...     url=\"https://example.com/wms\",\n...     layers=\"layer_name\",\n...     name=\"WMS Layer\"\n... )\n&gt;&gt;&gt; m\n</code></pre> Source code in <code>anymap_ts/openlayers.py</code> <pre><code>class OpenLayersMap(MapWidget):\n    \"\"\"Interactive map widget using OpenLayers.\n\n    This class provides a Python interface to OpenLayers maps with\n    full bidirectional communication through anywidget. OpenLayers\n    excels at WMS/WMTS support and projection handling.\n\n    Example:\n        &gt;&gt;&gt; from anymap_ts import OpenLayersMap\n        &gt;&gt;&gt; m = OpenLayersMap(center=[-122.4, 37.8], zoom=10)\n        &gt;&gt;&gt; m.add_basemap(\"OpenStreetMap\")\n        &gt;&gt;&gt; m.add_wms_layer(\n        ...     url=\"https://example.com/wms\",\n        ...     layers=\"layer_name\",\n        ...     name=\"WMS Layer\"\n        ... )\n        &gt;&gt;&gt; m\n    \"\"\"\n\n    # ESM module and CSS for frontend\n    _esm = STATIC_DIR / \"openlayers.js\"\n    _css = STATIC_DIR / \"openlayers.css\"\n\n    # OpenLayers-specific traits\n    projection = traitlets.Unicode(\"EPSG:3857\").tag(sync=True)\n    rotation = traitlets.Float(0.0).tag(sync=True)\n\n    # Layer tracking\n    _layer_dict = traitlets.Dict({}).tag(sync=True)\n\n    def __init__(\n        self,\n        center: Tuple[float, float] = (0.0, 0.0),\n        zoom: float = 2.0,\n        width: str = \"100%\",\n        height: str = \"600px\",\n        projection: str = \"EPSG:3857\",\n        rotation: float = 0.0,\n        controls: Optional[Dict[str, Any]] = None,\n        **kwargs,\n    ):\n        \"\"\"Initialize an OpenLayers map.\n\n        Args:\n            center: Map center as (longitude, latitude).\n            zoom: Initial zoom level.\n            width: Map width as CSS string.\n            height: Map height as CSS string.\n            projection: Map projection (default EPSG:3857).\n            rotation: Map rotation in radians.\n            controls: Dict of controls to add.\n            **kwargs: Additional widget arguments.\n        \"\"\"\n        super().__init__(\n            center=list(center),\n            zoom=zoom,\n            width=width,\n            height=height,\n            projection=projection,\n            rotation=rotation,\n            **kwargs,\n        )\n\n        # Initialize layer dictionary\n        self._layer_dict = {\"Background\": []}\n\n        # Add default controls\n        if controls is None:\n            controls = {\"zoom\": True, \"attribution\": True}\n\n        for control_name, config in controls.items():\n            if config:\n                self.add_control(\n                    control_name, **(config if isinstance(config, dict) else {})\n                )\n\n    # -------------------------------------------------------------------------\n    # Basemap Methods\n    # -------------------------------------------------------------------------\n\n    def add_basemap(\n        self,\n        basemap: str = \"OpenStreetMap\",\n        attribution: Optional[str] = None,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a basemap layer.\n\n        Args:\n            basemap: Name of basemap provider (e.g., \"OpenStreetMap\", \"CartoDB.Positron\").\n            attribution: Custom attribution text.\n            **kwargs: Additional options.\n        \"\"\"\n        url, default_attribution = get_basemap_url(basemap)\n        self.call_js_method(\n            \"addBasemap\",\n            url,\n            attribution=attribution or default_attribution,\n            name=basemap,\n            **kwargs,\n        )\n\n        basemaps = self._layer_dict.get(\"Basemaps\", [])\n        if basemap not in basemaps:\n            self._layer_dict = {\n                **self._layer_dict,\n                \"Basemaps\": basemaps + [basemap],\n            }\n\n    # -------------------------------------------------------------------------\n    # Tile Layer Methods\n    # -------------------------------------------------------------------------\n\n    def add_tile_layer(\n        self,\n        url: str,\n        name: Optional[str] = None,\n        attribution: str = \"\",\n        min_zoom: int = 0,\n        max_zoom: int = 22,\n        opacity: float = 1.0,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add an XYZ tile layer.\n\n        Args:\n            url: Tile URL template with {x}, {y}, {z} placeholders.\n            name: Layer name.\n            attribution: Attribution text.\n            min_zoom: Minimum zoom level.\n            max_zoom: Maximum zoom level.\n            opacity: Layer opacity.\n            **kwargs: Additional options.\n        \"\"\"\n        layer_id = name or f\"tiles-{len(self._layers)}\"\n\n        self.call_js_method(\n            \"addTileLayer\",\n            url,\n            name=layer_id,\n            attribution=attribution,\n            minZoom=min_zoom,\n            maxZoom=max_zoom,\n            opacity=opacity,\n            **kwargs,\n        )\n\n        self._layers = {\n            **self._layers,\n            layer_id: {\"id\": layer_id, \"type\": \"tile\"},\n        }\n\n    # -------------------------------------------------------------------------\n    # Vector Data Methods\n    # -------------------------------------------------------------------------\n\n    def add_vector(\n        self,\n        data: Any,\n        name: Optional[str] = None,\n        style: Optional[Dict] = None,\n        fit_bounds: bool = True,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add vector data to the map.\n\n        Args:\n            data: GeoJSON dict, GeoDataFrame, or path to vector file.\n            name: Layer name.\n            style: Style configuration dict.\n            fit_bounds: Whether to fit map to data bounds.\n            **kwargs: Additional layer options.\n        \"\"\"\n        geojson = to_geojson(data)\n        layer_id = name or f\"vector-{len(self._layers)}\"\n\n        if style is None:\n            style = self._get_default_style(geojson)\n\n        self.call_js_method(\n            \"addGeoJSON\",\n            data=geojson,\n            name=layer_id,\n            style=style,\n            fitBounds=fit_bounds,\n            **kwargs,\n        )\n\n        self._layers = {\n            **self._layers,\n            layer_id: {\"id\": layer_id, \"type\": \"vector\"},\n        }\n\n    def add_geojson(\n        self,\n        data: Union[str, Dict],\n        name: Optional[str] = None,\n        style: Optional[Dict] = None,\n        fit_bounds: bool = True,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add GeoJSON data to the map.\n\n        Args:\n            data: GeoJSON dict or URL to GeoJSON file.\n            name: Layer name.\n            style: Style configuration dict.\n            fit_bounds: Whether to fit map to data bounds.\n            **kwargs: Additional layer options.\n        \"\"\"\n        self.add_vector(\n            data,\n            name=name,\n            style=style,\n            fit_bounds=fit_bounds,\n            **kwargs,\n        )\n\n    def _get_default_style(self, geojson: Dict) -&gt; Dict:\n        \"\"\"Get default style based on geometry type.\n\n        Args:\n            geojson: GeoJSON data.\n\n        Returns:\n            Style configuration dict.\n        \"\"\"\n        geom_type = self._infer_geom_type(geojson)\n\n        if geom_type in [\"Point\", \"MultiPoint\"]:\n            return {\n                \"fillColor\": \"rgba(51, 136, 255, 0.8)\",\n                \"strokeColor\": \"#ffffff\",\n                \"strokeWidth\": 2,\n                \"radius\": 6,\n            }\n        elif geom_type in [\"LineString\", \"MultiLineString\"]:\n            return {\n                \"strokeColor\": \"#3388ff\",\n                \"strokeWidth\": 3,\n            }\n        else:  # Polygon, MultiPolygon\n            return {\n                \"fillColor\": \"rgba(51, 136, 255, 0.5)\",\n                \"strokeColor\": \"#3388ff\",\n                \"strokeWidth\": 2,\n            }\n\n    def _infer_geom_type(self, geojson: Dict) -&gt; str:\n        \"\"\"Infer geometry type from GeoJSON.\n\n        Args:\n            geojson: GeoJSON data.\n\n        Returns:\n            Geometry type string.\n        \"\"\"\n        if geojson.get(\"type\") == \"FeatureCollection\":\n            features = geojson.get(\"features\", [])\n            if features:\n                return features[0].get(\"geometry\", {}).get(\"type\", \"Point\")\n        elif geojson.get(\"type\") == \"Feature\":\n            return geojson.get(\"geometry\", {}).get(\"type\", \"Point\")\n        return \"Point\"\n\n    # -------------------------------------------------------------------------\n    # WMS/WMTS Methods\n    # -------------------------------------------------------------------------\n\n    def add_wms_layer(\n        self,\n        url: str,\n        layers: str,\n        name: Optional[str] = None,\n        format: str = \"image/png\",\n        transparent: bool = True,\n        server_type: Optional[str] = None,\n        attribution: str = \"\",\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a WMS tile layer.\n\n        Args:\n            url: WMS service URL.\n            layers: Comma-separated layer names.\n            name: Layer name for the map.\n            format: Image format (default: image/png).\n            transparent: Whether to request transparent images.\n            server_type: Server type ('mapserver', 'geoserver', 'qgis').\n            attribution: Attribution text.\n            **kwargs: Additional WMS parameters.\n        \"\"\"\n        layer_id = name or f\"wms-{len(self._layers)}\"\n\n        self.call_js_method(\n            \"addWMSLayer\",\n            url=url,\n            layers=layers,\n            name=layer_id,\n            format=format,\n            transparent=transparent,\n            serverType=server_type,\n            attribution=attribution,\n            **kwargs,\n        )\n\n        self._layers = {\n            **self._layers,\n            layer_id: {\"id\": layer_id, \"type\": \"wms\"},\n        }\n\n    def add_image_wms_layer(\n        self,\n        url: str,\n        layers: str,\n        name: Optional[str] = None,\n        format: str = \"image/png\",\n        transparent: bool = True,\n        server_type: Optional[str] = None,\n        attribution: str = \"\",\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a single-image WMS layer (not tiled).\n\n        Args:\n            url: WMS service URL.\n            layers: Comma-separated layer names.\n            name: Layer name for the map.\n            format: Image format (default: image/png).\n            transparent: Whether to request transparent images.\n            server_type: Server type ('mapserver', 'geoserver', 'qgis').\n            attribution: Attribution text.\n            **kwargs: Additional WMS parameters.\n        \"\"\"\n        layer_id = name or f\"imagewms-{len(self._layers)}\"\n\n        self.call_js_method(\n            \"addImageWMSLayer\",\n            url=url,\n            layers=layers,\n            name=layer_id,\n            format=format,\n            transparent=transparent,\n            serverType=server_type,\n            attribution=attribution,\n            **kwargs,\n        )\n\n        self._layers = {\n            **self._layers,\n            layer_id: {\"id\": layer_id, \"type\": \"imagewms\"},\n        }\n\n    # -------------------------------------------------------------------------\n    # Layer Management\n    # -------------------------------------------------------------------------\n\n    def remove_layer(self, layer_id: str) -&gt; None:\n        \"\"\"Remove a layer from the map.\n\n        Args:\n            layer_id: Layer identifier to remove.\n        \"\"\"\n        if layer_id in self._layers:\n            layers = dict(self._layers)\n            del layers[layer_id]\n            self._layers = layers\n        self.call_js_method(\"removeLayer\", layer_id)\n\n    def set_visibility(self, layer_id: str, visible: bool) -&gt; None:\n        \"\"\"Set layer visibility.\n\n        Args:\n            layer_id: Layer identifier.\n            visible: Whether layer should be visible.\n        \"\"\"\n        self.call_js_method(\"setVisibility\", layer_id, visible)\n\n    def set_opacity(self, layer_id: str, opacity: float) -&gt; None:\n        \"\"\"Set layer opacity.\n\n        Args:\n            layer_id: Layer identifier.\n            opacity: Opacity value between 0 and 1.\n        \"\"\"\n        self.call_js_method(\"setOpacity\", layer_id, opacity)\n\n    # -------------------------------------------------------------------------\n    # Controls\n    # -------------------------------------------------------------------------\n\n    def add_control(\n        self,\n        control_type: str,\n        position: str = \"top-right\",\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a map control.\n\n        Args:\n            control_type: Type of control ('zoom', 'scale', 'fullscreen', etc.).\n            position: Control position.\n            **kwargs: Control-specific options.\n        \"\"\"\n        self.call_js_method(\"addControl\", control_type, position=position, **kwargs)\n        self._controls = {\n            **self._controls,\n            control_type: {\"type\": control_type, \"position\": position, **kwargs},\n        }\n\n    def remove_control(self, control_type: str) -&gt; None:\n        \"\"\"Remove a map control.\n\n        Args:\n            control_type: Type of control to remove.\n        \"\"\"\n        self.call_js_method(\"removeControl\", control_type)\n        if control_type in self._controls:\n            controls = dict(self._controls)\n            del controls[control_type]\n            self._controls = controls\n\n    # -------------------------------------------------------------------------\n    # Navigation\n    # -------------------------------------------------------------------------\n\n    def set_center(self, lng: float, lat: float) -&gt; None:\n        \"\"\"Set the map center.\n\n        Args:\n            lng: Longitude.\n            lat: Latitude.\n        \"\"\"\n        self.center = [lng, lat]\n        self.call_js_method(\"setCenter\", lng, lat)\n\n    def set_zoom(self, zoom: float) -&gt; None:\n        \"\"\"Set the map zoom level.\n\n        Args:\n            zoom: Zoom level.\n        \"\"\"\n        self.zoom = zoom\n        self.call_js_method(\"setZoom\", zoom)\n\n    def fly_to(\n        self,\n        lng: float,\n        lat: float,\n        zoom: Optional[float] = None,\n        duration: int = 2000,\n    ) -&gt; None:\n        \"\"\"Animate to a new location.\n\n        Args:\n            lng: Target longitude.\n            lat: Target latitude.\n            zoom: Target zoom level (optional).\n            duration: Animation duration in milliseconds.\n        \"\"\"\n        self.call_js_method(\n            \"flyTo\", lng, lat, zoom=zoom or self.zoom, duration=duration\n        )\n\n    def fit_bounds(\n        self,\n        bounds: List[float],\n        padding: int = 50,\n        duration: int = 1000,\n    ) -&gt; None:\n        \"\"\"Fit the map to bounds.\n\n        Args:\n            bounds: Bounds as [minLng, minLat, maxLng, maxLat].\n            padding: Padding in pixels.\n            duration: Animation duration in milliseconds.\n        \"\"\"\n        self.call_js_method(\"fitBounds\", bounds, padding=padding, duration=duration)\n\n    def fit_extent(\n        self,\n        extent: List[float],\n        padding: int = 50,\n        duration: int = 1000,\n    ) -&gt; None:\n        \"\"\"Fit the map to an extent (in map projection).\n\n        Args:\n            extent: Extent as [minX, minY, maxX, maxY] in map projection.\n            padding: Padding in pixels.\n            duration: Animation duration in milliseconds.\n        \"\"\"\n        self.call_js_method(\"fitExtent\", extent, padding=padding, duration=duration)\n\n    # -------------------------------------------------------------------------\n    # Markers\n    # -------------------------------------------------------------------------\n\n    def add_marker(\n        self,\n        lng: float,\n        lat: float,\n        popup: Optional[str] = None,\n        color: str = \"#3388ff\",\n        name: Optional[str] = None,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a marker to the map.\n\n        Args:\n            lng: Marker longitude.\n            lat: Marker latitude.\n            popup: Popup content (HTML string).\n            color: Marker color.\n            name: Marker identifier.\n            **kwargs: Additional options.\n        \"\"\"\n        marker_id = name or f\"marker-{len(self._layers)}\"\n        self.call_js_method(\n            \"addMarker\",\n            lng,\n            lat,\n            popup=popup,\n            color=color,\n            id=marker_id,\n            **kwargs,\n        )\n\n    # -------------------------------------------------------------------------\n    # HTML Export\n    # -------------------------------------------------------------------------\n\n    def _generate_html_template(self) -&gt; str:\n        \"\"\"Generate standalone HTML for the map.\"\"\"\n        template_path = Path(__file__).parent / \"templates\" / \"openlayers.html\"\n\n        if template_path.exists():\n            template = template_path.read_text(encoding=\"utf-8\")\n        else:\n            template = self._get_default_template()\n\n        state = {\n            \"center\": self.center,\n            \"zoom\": self.zoom,\n            \"projection\": self.projection,\n            \"rotation\": self.rotation,\n            \"width\": self.width,\n            \"height\": self.height,\n            \"layers\": self._layers,\n            \"controls\": self._controls,\n            \"js_calls\": self._js_calls,\n        }\n\n        template = template.replace(\"{{state}}\", json.dumps(state, indent=2))\n        return template\n\n    def _get_default_template(self) -&gt; str:\n        \"\"\"Get default HTML template.\"\"\"\n        return \"\"\"&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n    &lt;meta charset=\"utf-8\"&gt;\n    &lt;title&gt;OpenLayers Map&lt;/title&gt;\n    &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"&gt;\n    &lt;link rel=\"stylesheet\" href=\"https://cdn.jsdelivr.net/npm/ol@v10.0.0/ol.css\"&gt;\n    &lt;script src=\"https://cdn.jsdelivr.net/npm/ol@v10.0.0/dist/ol.js\"&gt;&lt;/script&gt;\n    &lt;style&gt;\n        * { margin: 0; padding: 0; box-sizing: border-box; }\n        html, body { height: 100%; }\n        #map { position: absolute; top: 0; bottom: 0; width: 100%; }\n    &lt;/style&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;div id=\"map\"&gt;&lt;/div&gt;\n    &lt;script&gt;\n        const state = {{state}};\n\n        const map = new ol.Map({\n            target: 'map',\n            view: new ol.View({\n                center: ol.proj.fromLonLat(state.center),\n                zoom: state.zoom\n            })\n        });\n\n        for (const call of state.js_calls || []) {\n            executeMethod(call.method, call.args, call.kwargs);\n        }\n\n        function executeMethod(method, args, kwargs) {\n            console.log('Executing:', method, args, kwargs);\n        }\n    &lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\"\"\"\n</code></pre>"},{"location":"openlayers/#anymap_ts.openlayers.OpenLayersMap.__init__","title":"<code>__init__(self, center=(0.0, 0.0), zoom=2.0, width='100%', height='600px', projection='EPSG:3857', rotation=0.0, controls=None, **kwargs)</code>  <code>special</code>","text":"<p>Initialize an OpenLayers map.</p> <p>Parameters:</p> Name Type Description Default <code>center</code> <code>Tuple[float, float]</code> <p>Map center as (longitude, latitude).</p> <code>(0.0, 0.0)</code> <code>zoom</code> <code>float</code> <p>Initial zoom level.</p> <code>2.0</code> <code>width</code> <code>str</code> <p>Map width as CSS string.</p> <code>'100%'</code> <code>height</code> <code>str</code> <p>Map height as CSS string.</p> <code>'600px'</code> <code>projection</code> <code>str</code> <p>Map projection (default EPSG:3857).</p> <code>'EPSG:3857'</code> <code>rotation</code> <code>float</code> <p>Map rotation in radians.</p> <code>0.0</code> <code>controls</code> <code>Optional[Dict[str, Any]]</code> <p>Dict of controls to add.</p> <code>None</code> <code>**kwargs</code> <p>Additional widget arguments.</p> <code>{}</code> Source code in <code>anymap_ts/openlayers.py</code> <pre><code>def __init__(\n    self,\n    center: Tuple[float, float] = (0.0, 0.0),\n    zoom: float = 2.0,\n    width: str = \"100%\",\n    height: str = \"600px\",\n    projection: str = \"EPSG:3857\",\n    rotation: float = 0.0,\n    controls: Optional[Dict[str, Any]] = None,\n    **kwargs,\n):\n    \"\"\"Initialize an OpenLayers map.\n\n    Args:\n        center: Map center as (longitude, latitude).\n        zoom: Initial zoom level.\n        width: Map width as CSS string.\n        height: Map height as CSS string.\n        projection: Map projection (default EPSG:3857).\n        rotation: Map rotation in radians.\n        controls: Dict of controls to add.\n        **kwargs: Additional widget arguments.\n    \"\"\"\n    super().__init__(\n        center=list(center),\n        zoom=zoom,\n        width=width,\n        height=height,\n        projection=projection,\n        rotation=rotation,\n        **kwargs,\n    )\n\n    # Initialize layer dictionary\n    self._layer_dict = {\"Background\": []}\n\n    # Add default controls\n    if controls is None:\n        controls = {\"zoom\": True, \"attribution\": True}\n\n    for control_name, config in controls.items():\n        if config:\n            self.add_control(\n                control_name, **(config if isinstance(config, dict) else {})\n            )\n</code></pre>"},{"location":"openlayers/#anymap_ts.openlayers.OpenLayersMap.add_basemap","title":"<code>add_basemap(self, basemap='OpenStreetMap', attribution=None, **kwargs)</code>","text":"<p>Add a basemap layer.</p> <p>Parameters:</p> Name Type Description Default <code>basemap</code> <code>str</code> <p>Name of basemap provider (e.g., \"OpenStreetMap\", \"CartoDB.Positron\").</p> <code>'OpenStreetMap'</code> <code>attribution</code> <code>Optional[str]</code> <p>Custom attribution text.</p> <code>None</code> <code>**kwargs</code> <p>Additional options.</p> <code>{}</code> Source code in <code>anymap_ts/openlayers.py</code> <pre><code>def add_basemap(\n    self,\n    basemap: str = \"OpenStreetMap\",\n    attribution: Optional[str] = None,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a basemap layer.\n\n    Args:\n        basemap: Name of basemap provider (e.g., \"OpenStreetMap\", \"CartoDB.Positron\").\n        attribution: Custom attribution text.\n        **kwargs: Additional options.\n    \"\"\"\n    url, default_attribution = get_basemap_url(basemap)\n    self.call_js_method(\n        \"addBasemap\",\n        url,\n        attribution=attribution or default_attribution,\n        name=basemap,\n        **kwargs,\n    )\n\n    basemaps = self._layer_dict.get(\"Basemaps\", [])\n    if basemap not in basemaps:\n        self._layer_dict = {\n            **self._layer_dict,\n            \"Basemaps\": basemaps + [basemap],\n        }\n</code></pre>"},{"location":"openlayers/#anymap_ts.openlayers.OpenLayersMap.add_control","title":"<code>add_control(self, control_type, position='top-right', **kwargs)</code>","text":"<p>Add a map control.</p> <p>Parameters:</p> Name Type Description Default <code>control_type</code> <code>str</code> <p>Type of control ('zoom', 'scale', 'fullscreen', etc.).</p> required <code>position</code> <code>str</code> <p>Control position.</p> <code>'top-right'</code> <code>**kwargs</code> <p>Control-specific options.</p> <code>{}</code> Source code in <code>anymap_ts/openlayers.py</code> <pre><code>def add_control(\n    self,\n    control_type: str,\n    position: str = \"top-right\",\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a map control.\n\n    Args:\n        control_type: Type of control ('zoom', 'scale', 'fullscreen', etc.).\n        position: Control position.\n        **kwargs: Control-specific options.\n    \"\"\"\n    self.call_js_method(\"addControl\", control_type, position=position, **kwargs)\n    self._controls = {\n        **self._controls,\n        control_type: {\"type\": control_type, \"position\": position, **kwargs},\n    }\n</code></pre>"},{"location":"openlayers/#anymap_ts.openlayers.OpenLayersMap.add_geojson","title":"<code>add_geojson(self, data, name=None, style=None, fit_bounds=True, **kwargs)</code>","text":"<p>Add GeoJSON data to the map.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Union[str, Dict]</code> <p>GeoJSON dict or URL to GeoJSON file.</p> required <code>name</code> <code>Optional[str]</code> <p>Layer name.</p> <code>None</code> <code>style</code> <code>Optional[Dict]</code> <p>Style configuration dict.</p> <code>None</code> <code>fit_bounds</code> <code>bool</code> <p>Whether to fit map to data bounds.</p> <code>True</code> <code>**kwargs</code> <p>Additional layer options.</p> <code>{}</code> Source code in <code>anymap_ts/openlayers.py</code> <pre><code>def add_geojson(\n    self,\n    data: Union[str, Dict],\n    name: Optional[str] = None,\n    style: Optional[Dict] = None,\n    fit_bounds: bool = True,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add GeoJSON data to the map.\n\n    Args:\n        data: GeoJSON dict or URL to GeoJSON file.\n        name: Layer name.\n        style: Style configuration dict.\n        fit_bounds: Whether to fit map to data bounds.\n        **kwargs: Additional layer options.\n    \"\"\"\n    self.add_vector(\n        data,\n        name=name,\n        style=style,\n        fit_bounds=fit_bounds,\n        **kwargs,\n    )\n</code></pre>"},{"location":"openlayers/#anymap_ts.openlayers.OpenLayersMap.add_image_wms_layer","title":"<code>add_image_wms_layer(self, url, layers, name=None, format='image/png', transparent=True, server_type=None, attribution='', **kwargs)</code>","text":"<p>Add a single-image WMS layer (not tiled).</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>WMS service URL.</p> required <code>layers</code> <code>str</code> <p>Comma-separated layer names.</p> required <code>name</code> <code>Optional[str]</code> <p>Layer name for the map.</p> <code>None</code> <code>format</code> <code>str</code> <p>Image format (default: image/png).</p> <code>'image/png'</code> <code>transparent</code> <code>bool</code> <p>Whether to request transparent images.</p> <code>True</code> <code>server_type</code> <code>Optional[str]</code> <p>Server type ('mapserver', 'geoserver', 'qgis').</p> <code>None</code> <code>attribution</code> <code>str</code> <p>Attribution text.</p> <code>''</code> <code>**kwargs</code> <p>Additional WMS parameters.</p> <code>{}</code> Source code in <code>anymap_ts/openlayers.py</code> <pre><code>def add_image_wms_layer(\n    self,\n    url: str,\n    layers: str,\n    name: Optional[str] = None,\n    format: str = \"image/png\",\n    transparent: bool = True,\n    server_type: Optional[str] = None,\n    attribution: str = \"\",\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a single-image WMS layer (not tiled).\n\n    Args:\n        url: WMS service URL.\n        layers: Comma-separated layer names.\n        name: Layer name for the map.\n        format: Image format (default: image/png).\n        transparent: Whether to request transparent images.\n        server_type: Server type ('mapserver', 'geoserver', 'qgis').\n        attribution: Attribution text.\n        **kwargs: Additional WMS parameters.\n    \"\"\"\n    layer_id = name or f\"imagewms-{len(self._layers)}\"\n\n    self.call_js_method(\n        \"addImageWMSLayer\",\n        url=url,\n        layers=layers,\n        name=layer_id,\n        format=format,\n        transparent=transparent,\n        serverType=server_type,\n        attribution=attribution,\n        **kwargs,\n    )\n\n    self._layers = {\n        **self._layers,\n        layer_id: {\"id\": layer_id, \"type\": \"imagewms\"},\n    }\n</code></pre>"},{"location":"openlayers/#anymap_ts.openlayers.OpenLayersMap.add_marker","title":"<code>add_marker(self, lng, lat, popup=None, color='#3388ff', name=None, **kwargs)</code>","text":"<p>Add a marker to the map.</p> <p>Parameters:</p> Name Type Description Default <code>lng</code> <code>float</code> <p>Marker longitude.</p> required <code>lat</code> <code>float</code> <p>Marker latitude.</p> required <code>popup</code> <code>Optional[str]</code> <p>Popup content (HTML string).</p> <code>None</code> <code>color</code> <code>str</code> <p>Marker color.</p> <code>'#3388ff'</code> <code>name</code> <code>Optional[str]</code> <p>Marker identifier.</p> <code>None</code> <code>**kwargs</code> <p>Additional options.</p> <code>{}</code> Source code in <code>anymap_ts/openlayers.py</code> <pre><code>def add_marker(\n    self,\n    lng: float,\n    lat: float,\n    popup: Optional[str] = None,\n    color: str = \"#3388ff\",\n    name: Optional[str] = None,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a marker to the map.\n\n    Args:\n        lng: Marker longitude.\n        lat: Marker latitude.\n        popup: Popup content (HTML string).\n        color: Marker color.\n        name: Marker identifier.\n        **kwargs: Additional options.\n    \"\"\"\n    marker_id = name or f\"marker-{len(self._layers)}\"\n    self.call_js_method(\n        \"addMarker\",\n        lng,\n        lat,\n        popup=popup,\n        color=color,\n        id=marker_id,\n        **kwargs,\n    )\n</code></pre>"},{"location":"openlayers/#anymap_ts.openlayers.OpenLayersMap.add_tile_layer","title":"<code>add_tile_layer(self, url, name=None, attribution='', min_zoom=0, max_zoom=22, opacity=1.0, **kwargs)</code>","text":"<p>Add an XYZ tile layer.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>Tile URL template with {x}, {y}, {z} placeholders.</p> required <code>name</code> <code>Optional[str]</code> <p>Layer name.</p> <code>None</code> <code>attribution</code> <code>str</code> <p>Attribution text.</p> <code>''</code> <code>min_zoom</code> <code>int</code> <p>Minimum zoom level.</p> <code>0</code> <code>max_zoom</code> <code>int</code> <p>Maximum zoom level.</p> <code>22</code> <code>opacity</code> <code>float</code> <p>Layer opacity.</p> <code>1.0</code> <code>**kwargs</code> <p>Additional options.</p> <code>{}</code> Source code in <code>anymap_ts/openlayers.py</code> <pre><code>def add_tile_layer(\n    self,\n    url: str,\n    name: Optional[str] = None,\n    attribution: str = \"\",\n    min_zoom: int = 0,\n    max_zoom: int = 22,\n    opacity: float = 1.0,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add an XYZ tile layer.\n\n    Args:\n        url: Tile URL template with {x}, {y}, {z} placeholders.\n        name: Layer name.\n        attribution: Attribution text.\n        min_zoom: Minimum zoom level.\n        max_zoom: Maximum zoom level.\n        opacity: Layer opacity.\n        **kwargs: Additional options.\n    \"\"\"\n    layer_id = name or f\"tiles-{len(self._layers)}\"\n\n    self.call_js_method(\n        \"addTileLayer\",\n        url,\n        name=layer_id,\n        attribution=attribution,\n        minZoom=min_zoom,\n        maxZoom=max_zoom,\n        opacity=opacity,\n        **kwargs,\n    )\n\n    self._layers = {\n        **self._layers,\n        layer_id: {\"id\": layer_id, \"type\": \"tile\"},\n    }\n</code></pre>"},{"location":"openlayers/#anymap_ts.openlayers.OpenLayersMap.add_vector","title":"<code>add_vector(self, data, name=None, style=None, fit_bounds=True, **kwargs)</code>","text":"<p>Add vector data to the map.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>GeoJSON dict, GeoDataFrame, or path to vector file.</p> required <code>name</code> <code>Optional[str]</code> <p>Layer name.</p> <code>None</code> <code>style</code> <code>Optional[Dict]</code> <p>Style configuration dict.</p> <code>None</code> <code>fit_bounds</code> <code>bool</code> <p>Whether to fit map to data bounds.</p> <code>True</code> <code>**kwargs</code> <p>Additional layer options.</p> <code>{}</code> Source code in <code>anymap_ts/openlayers.py</code> <pre><code>def add_vector(\n    self,\n    data: Any,\n    name: Optional[str] = None,\n    style: Optional[Dict] = None,\n    fit_bounds: bool = True,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add vector data to the map.\n\n    Args:\n        data: GeoJSON dict, GeoDataFrame, or path to vector file.\n        name: Layer name.\n        style: Style configuration dict.\n        fit_bounds: Whether to fit map to data bounds.\n        **kwargs: Additional layer options.\n    \"\"\"\n    geojson = to_geojson(data)\n    layer_id = name or f\"vector-{len(self._layers)}\"\n\n    if style is None:\n        style = self._get_default_style(geojson)\n\n    self.call_js_method(\n        \"addGeoJSON\",\n        data=geojson,\n        name=layer_id,\n        style=style,\n        fitBounds=fit_bounds,\n        **kwargs,\n    )\n\n    self._layers = {\n        **self._layers,\n        layer_id: {\"id\": layer_id, \"type\": \"vector\"},\n    }\n</code></pre>"},{"location":"openlayers/#anymap_ts.openlayers.OpenLayersMap.add_wms_layer","title":"<code>add_wms_layer(self, url, layers, name=None, format='image/png', transparent=True, server_type=None, attribution='', **kwargs)</code>","text":"<p>Add a WMS tile layer.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>WMS service URL.</p> required <code>layers</code> <code>str</code> <p>Comma-separated layer names.</p> required <code>name</code> <code>Optional[str]</code> <p>Layer name for the map.</p> <code>None</code> <code>format</code> <code>str</code> <p>Image format (default: image/png).</p> <code>'image/png'</code> <code>transparent</code> <code>bool</code> <p>Whether to request transparent images.</p> <code>True</code> <code>server_type</code> <code>Optional[str]</code> <p>Server type ('mapserver', 'geoserver', 'qgis').</p> <code>None</code> <code>attribution</code> <code>str</code> <p>Attribution text.</p> <code>''</code> <code>**kwargs</code> <p>Additional WMS parameters.</p> <code>{}</code> Source code in <code>anymap_ts/openlayers.py</code> <pre><code>def add_wms_layer(\n    self,\n    url: str,\n    layers: str,\n    name: Optional[str] = None,\n    format: str = \"image/png\",\n    transparent: bool = True,\n    server_type: Optional[str] = None,\n    attribution: str = \"\",\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a WMS tile layer.\n\n    Args:\n        url: WMS service URL.\n        layers: Comma-separated layer names.\n        name: Layer name for the map.\n        format: Image format (default: image/png).\n        transparent: Whether to request transparent images.\n        server_type: Server type ('mapserver', 'geoserver', 'qgis').\n        attribution: Attribution text.\n        **kwargs: Additional WMS parameters.\n    \"\"\"\n    layer_id = name or f\"wms-{len(self._layers)}\"\n\n    self.call_js_method(\n        \"addWMSLayer\",\n        url=url,\n        layers=layers,\n        name=layer_id,\n        format=format,\n        transparent=transparent,\n        serverType=server_type,\n        attribution=attribution,\n        **kwargs,\n    )\n\n    self._layers = {\n        **self._layers,\n        layer_id: {\"id\": layer_id, \"type\": \"wms\"},\n    }\n</code></pre>"},{"location":"openlayers/#anymap_ts.openlayers.OpenLayersMap.fit_bounds","title":"<code>fit_bounds(self, bounds, padding=50, duration=1000)</code>","text":"<p>Fit the map to bounds.</p> <p>Parameters:</p> Name Type Description Default <code>bounds</code> <code>List[float]</code> <p>Bounds as [minLng, minLat, maxLng, maxLat].</p> required <code>padding</code> <code>int</code> <p>Padding in pixels.</p> <code>50</code> <code>duration</code> <code>int</code> <p>Animation duration in milliseconds.</p> <code>1000</code> Source code in <code>anymap_ts/openlayers.py</code> <pre><code>def fit_bounds(\n    self,\n    bounds: List[float],\n    padding: int = 50,\n    duration: int = 1000,\n) -&gt; None:\n    \"\"\"Fit the map to bounds.\n\n    Args:\n        bounds: Bounds as [minLng, minLat, maxLng, maxLat].\n        padding: Padding in pixels.\n        duration: Animation duration in milliseconds.\n    \"\"\"\n    self.call_js_method(\"fitBounds\", bounds, padding=padding, duration=duration)\n</code></pre>"},{"location":"openlayers/#anymap_ts.openlayers.OpenLayersMap.fit_extent","title":"<code>fit_extent(self, extent, padding=50, duration=1000)</code>","text":"<p>Fit the map to an extent (in map projection).</p> <p>Parameters:</p> Name Type Description Default <code>extent</code> <code>List[float]</code> <p>Extent as [minX, minY, maxX, maxY] in map projection.</p> required <code>padding</code> <code>int</code> <p>Padding in pixels.</p> <code>50</code> <code>duration</code> <code>int</code> <p>Animation duration in milliseconds.</p> <code>1000</code> Source code in <code>anymap_ts/openlayers.py</code> <pre><code>def fit_extent(\n    self,\n    extent: List[float],\n    padding: int = 50,\n    duration: int = 1000,\n) -&gt; None:\n    \"\"\"Fit the map to an extent (in map projection).\n\n    Args:\n        extent: Extent as [minX, minY, maxX, maxY] in map projection.\n        padding: Padding in pixels.\n        duration: Animation duration in milliseconds.\n    \"\"\"\n    self.call_js_method(\"fitExtent\", extent, padding=padding, duration=duration)\n</code></pre>"},{"location":"openlayers/#anymap_ts.openlayers.OpenLayersMap.fly_to","title":"<code>fly_to(self, lng, lat, zoom=None, duration=2000)</code>","text":"<p>Animate to a new location.</p> <p>Parameters:</p> Name Type Description Default <code>lng</code> <code>float</code> <p>Target longitude.</p> required <code>lat</code> <code>float</code> <p>Target latitude.</p> required <code>zoom</code> <code>Optional[float]</code> <p>Target zoom level (optional).</p> <code>None</code> <code>duration</code> <code>int</code> <p>Animation duration in milliseconds.</p> <code>2000</code> Source code in <code>anymap_ts/openlayers.py</code> <pre><code>def fly_to(\n    self,\n    lng: float,\n    lat: float,\n    zoom: Optional[float] = None,\n    duration: int = 2000,\n) -&gt; None:\n    \"\"\"Animate to a new location.\n\n    Args:\n        lng: Target longitude.\n        lat: Target latitude.\n        zoom: Target zoom level (optional).\n        duration: Animation duration in milliseconds.\n    \"\"\"\n    self.call_js_method(\n        \"flyTo\", lng, lat, zoom=zoom or self.zoom, duration=duration\n    )\n</code></pre>"},{"location":"openlayers/#anymap_ts.openlayers.OpenLayersMap.remove_control","title":"<code>remove_control(self, control_type)</code>","text":"<p>Remove a map control.</p> <p>Parameters:</p> Name Type Description Default <code>control_type</code> <code>str</code> <p>Type of control to remove.</p> required Source code in <code>anymap_ts/openlayers.py</code> <pre><code>def remove_control(self, control_type: str) -&gt; None:\n    \"\"\"Remove a map control.\n\n    Args:\n        control_type: Type of control to remove.\n    \"\"\"\n    self.call_js_method(\"removeControl\", control_type)\n    if control_type in self._controls:\n        controls = dict(self._controls)\n        del controls[control_type]\n        self._controls = controls\n</code></pre>"},{"location":"openlayers/#anymap_ts.openlayers.OpenLayersMap.remove_layer","title":"<code>remove_layer(self, layer_id)</code>","text":"<p>Remove a layer from the map.</p> <p>Parameters:</p> Name Type Description Default <code>layer_id</code> <code>str</code> <p>Layer identifier to remove.</p> required Source code in <code>anymap_ts/openlayers.py</code> <pre><code>def remove_layer(self, layer_id: str) -&gt; None:\n    \"\"\"Remove a layer from the map.\n\n    Args:\n        layer_id: Layer identifier to remove.\n    \"\"\"\n    if layer_id in self._layers:\n        layers = dict(self._layers)\n        del layers[layer_id]\n        self._layers = layers\n    self.call_js_method(\"removeLayer\", layer_id)\n</code></pre>"},{"location":"openlayers/#anymap_ts.openlayers.OpenLayersMap.set_center","title":"<code>set_center(self, lng, lat)</code>","text":"<p>Set the map center.</p> <p>Parameters:</p> Name Type Description Default <code>lng</code> <code>float</code> <p>Longitude.</p> required <code>lat</code> <code>float</code> <p>Latitude.</p> required Source code in <code>anymap_ts/openlayers.py</code> <pre><code>def set_center(self, lng: float, lat: float) -&gt; None:\n    \"\"\"Set the map center.\n\n    Args:\n        lng: Longitude.\n        lat: Latitude.\n    \"\"\"\n    self.center = [lng, lat]\n    self.call_js_method(\"setCenter\", lng, lat)\n</code></pre>"},{"location":"openlayers/#anymap_ts.openlayers.OpenLayersMap.set_opacity","title":"<code>set_opacity(self, layer_id, opacity)</code>","text":"<p>Set layer opacity.</p> <p>Parameters:</p> Name Type Description Default <code>layer_id</code> <code>str</code> <p>Layer identifier.</p> required <code>opacity</code> <code>float</code> <p>Opacity value between 0 and 1.</p> required Source code in <code>anymap_ts/openlayers.py</code> <pre><code>def set_opacity(self, layer_id: str, opacity: float) -&gt; None:\n    \"\"\"Set layer opacity.\n\n    Args:\n        layer_id: Layer identifier.\n        opacity: Opacity value between 0 and 1.\n    \"\"\"\n    self.call_js_method(\"setOpacity\", layer_id, opacity)\n</code></pre>"},{"location":"openlayers/#anymap_ts.openlayers.OpenLayersMap.set_visibility","title":"<code>set_visibility(self, layer_id, visible)</code>","text":"<p>Set layer visibility.</p> <p>Parameters:</p> Name Type Description Default <code>layer_id</code> <code>str</code> <p>Layer identifier.</p> required <code>visible</code> <code>bool</code> <p>Whether layer should be visible.</p> required Source code in <code>anymap_ts/openlayers.py</code> <pre><code>def set_visibility(self, layer_id: str, visible: bool) -&gt; None:\n    \"\"\"Set layer visibility.\n\n    Args:\n        layer_id: Layer identifier.\n        visible: Whether layer should be visible.\n    \"\"\"\n    self.call_js_method(\"setVisibility\", layer_id, visible)\n</code></pre>"},{"location":"openlayers/#anymap_ts.openlayers.OpenLayersMap.set_zoom","title":"<code>set_zoom(self, zoom)</code>","text":"<p>Set the map zoom level.</p> <p>Parameters:</p> Name Type Description Default <code>zoom</code> <code>float</code> <p>Zoom level.</p> required Source code in <code>anymap_ts/openlayers.py</code> <pre><code>def set_zoom(self, zoom: float) -&gt; None:\n    \"\"\"Set the map zoom level.\n\n    Args:\n        zoom: Zoom level.\n    \"\"\"\n    self.zoom = zoom\n    self.call_js_method(\"setZoom\", zoom)\n</code></pre>"},{"location":"potree/","title":"potree module","text":"<p>Potree point cloud viewer widget implementation.</p> <p>Potree is loaded via CDN since it's a complex Three.js-based viewer. This implementation provides a Python wrapper for point cloud visualization.</p>"},{"location":"potree/#anymap_ts.potree.PotreeViewer","title":"<code> PotreeViewer            (MapWidget)         </code>","text":"<p>Interactive point cloud viewer using Potree.</p> <p>Potree is a WebGL-based point cloud renderer for large-scale LiDAR datasets. This class provides a Python interface for loading and visualizing point clouds.</p> <p>Note: Potree is loaded from CDN due to its complex Three.js dependencies.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from anymap_ts import PotreeViewer\n&gt;&gt;&gt; viewer = PotreeViewer()\n&gt;&gt;&gt; viewer.load_point_cloud(\"path/to/pointcloud/cloud.js\")\n&gt;&gt;&gt; viewer\n</code></pre> Source code in <code>anymap_ts/potree.py</code> <pre><code>class PotreeViewer(MapWidget):\n    \"\"\"Interactive point cloud viewer using Potree.\n\n    Potree is a WebGL-based point cloud renderer for large-scale LiDAR\n    datasets. This class provides a Python interface for loading and\n    visualizing point clouds.\n\n    Note: Potree is loaded from CDN due to its complex Three.js dependencies.\n\n    Example:\n        &gt;&gt;&gt; from anymap_ts import PotreeViewer\n        &gt;&gt;&gt; viewer = PotreeViewer()\n        &gt;&gt;&gt; viewer.load_point_cloud(\"path/to/pointcloud/cloud.js\")\n        &gt;&gt;&gt; viewer\n    \"\"\"\n\n    # ESM module for frontend\n    _esm = STATIC_DIR / \"potree.js\"\n\n    # Potree-specific traits\n    point_budget = traitlets.Int(1000000).tag(sync=True)\n    point_size = traitlets.Float(1.0).tag(sync=True)\n    fov = traitlets.Float(60.0).tag(sync=True)\n    background = traitlets.Unicode(\"#000000\").tag(sync=True)\n\n    # EDL (Eye Dome Lighting) settings\n    edl_enabled = traitlets.Bool(True).tag(sync=True)\n    edl_radius = traitlets.Float(1.4).tag(sync=True)\n    edl_strength = traitlets.Float(0.4).tag(sync=True)\n\n    # Point clouds\n    point_clouds = traitlets.Dict({}).tag(sync=True)\n\n    # Camera\n    camera_position = traitlets.List([0, 0, 100]).tag(sync=True)\n    camera_target = traitlets.List([0, 0, 0]).tag(sync=True)\n\n    def __init__(\n        self,\n        width: str = \"100%\",\n        height: str = \"600px\",\n        point_budget: int = 1000000,\n        point_size: float = 1.0,\n        fov: float = 60.0,\n        background: str = \"#000000\",\n        edl_enabled: bool = True,\n        **kwargs,\n    ):\n        \"\"\"Initialize a Potree viewer.\n\n        Args:\n            width: Widget width as CSS string.\n            height: Widget height as CSS string.\n            point_budget: Maximum number of points to render.\n            point_size: Default point size.\n            fov: Field of view in degrees.\n            background: Background color (hex string).\n            edl_enabled: Enable Eye Dome Lighting.\n            **kwargs: Additional widget arguments.\n        \"\"\"\n        # Potree doesn't use center/zoom like maps\n        super().__init__(\n            center=[0, 0],\n            zoom=1,\n            width=width,\n            height=height,\n            point_budget=point_budget,\n            point_size=point_size,\n            fov=fov,\n            background=background,\n            edl_enabled=edl_enabled,\n            **kwargs,\n        )\n        self.point_clouds = {}\n\n    # -------------------------------------------------------------------------\n    # Point Cloud Methods\n    # -------------------------------------------------------------------------\n\n    def load_point_cloud(\n        self,\n        url: str,\n        name: Optional[str] = None,\n        visible: bool = True,\n        point_size: Optional[float] = None,\n        point_size_type: str = \"adaptive\",\n        shape: str = \"circle\",\n        color: Optional[str] = None,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Load a point cloud.\n\n        Args:\n            url: URL to point cloud (Potree format or LAZ/LAS via Entwine).\n            name: Point cloud name.\n            visible: Whether point cloud is visible.\n            point_size: Point size (overrides default).\n            point_size_type: 'fixed', 'attenuated', or 'adaptive'.\n            shape: Point shape ('square', 'circle', 'paraboloid').\n            color: Point color (hex string or None for native colors).\n            **kwargs: Additional material options.\n        \"\"\"\n        cloud_id = name or f\"pointcloud_{len(self.point_clouds)}\"\n\n        self.point_clouds = {\n            **self.point_clouds,\n            cloud_id: {\n                \"url\": url,\n                \"name\": cloud_id,\n                \"visible\": visible,\n                \"material\": {\n                    \"size\": point_size or self.point_size,\n                    \"pointSizeType\": point_size_type,\n                    \"shape\": shape,\n                    \"color\": color,\n                    **kwargs,\n                },\n            },\n        }\n\n        self.call_js_method(\n            \"loadPointCloud\",\n            url=url,\n            name=cloud_id,\n            visible=visible,\n            material={\n                \"size\": point_size or self.point_size,\n                \"pointSizeType\": point_size_type,\n                \"shape\": shape,\n                \"color\": color,\n                **kwargs,\n            },\n        )\n\n    def remove_point_cloud(self, name: str) -&gt; None:\n        \"\"\"Remove a point cloud.\n\n        Args:\n            name: Point cloud name to remove.\n        \"\"\"\n        if name in self.point_clouds:\n            clouds = dict(self.point_clouds)\n            del clouds[name]\n            self.point_clouds = clouds\n        self.call_js_method(\"removePointCloud\", name=name)\n\n    def set_point_cloud_visibility(self, name: str, visible: bool) -&gt; None:\n        \"\"\"Set point cloud visibility.\n\n        Args:\n            name: Point cloud name.\n            visible: Whether to show the point cloud.\n        \"\"\"\n        self.call_js_method(\"setPointCloudVisibility\", name=name, visible=visible)\n\n    # -------------------------------------------------------------------------\n    # Camera Methods\n    # -------------------------------------------------------------------------\n\n    def set_camera_position(\n        self,\n        x: float,\n        y: float,\n        z: float,\n    ) -&gt; None:\n        \"\"\"Set camera position.\n\n        Args:\n            x: X coordinate.\n            y: Y coordinate.\n            z: Z coordinate.\n        \"\"\"\n        self.camera_position = [x, y, z]\n        self.call_js_method(\"setCameraPosition\", x=x, y=y, z=z)\n\n    def set_camera_target(\n        self,\n        x: float,\n        y: float,\n        z: float,\n    ) -&gt; None:\n        \"\"\"Set camera target (look-at point).\n\n        Args:\n            x: X coordinate.\n            y: Y coordinate.\n            z: Z coordinate.\n        \"\"\"\n        self.camera_target = [x, y, z]\n        self.call_js_method(\"setCameraTarget\", x=x, y=y, z=z)\n\n    def fly_to_point_cloud(self, name: Optional[str] = None) -&gt; None:\n        \"\"\"Fly to a point cloud or all point clouds.\n\n        Args:\n            name: Point cloud name (None for all).\n        \"\"\"\n        self.call_js_method(\"flyToPointCloud\", name=name)\n\n    def reset_camera(self) -&gt; None:\n        \"\"\"Reset camera to default view.\"\"\"\n        self.call_js_method(\"resetCamera\")\n\n    # -------------------------------------------------------------------------\n    # Visualization Settings\n    # -------------------------------------------------------------------------\n\n    def set_point_budget(self, budget: int) -&gt; None:\n        \"\"\"Set the point budget (max points to render).\n\n        Args:\n            budget: Maximum number of points.\n        \"\"\"\n        self.point_budget = budget\n        self.call_js_method(\"setPointBudget\", budget=budget)\n\n    def set_point_size(self, size: float) -&gt; None:\n        \"\"\"Set default point size.\n\n        Args:\n            size: Point size.\n        \"\"\"\n        self.point_size = size\n        self.call_js_method(\"setPointSize\", size=size)\n\n    def set_fov(self, fov: float) -&gt; None:\n        \"\"\"Set field of view.\n\n        Args:\n            fov: Field of view in degrees.\n        \"\"\"\n        self.fov = fov\n        self.call_js_method(\"setFOV\", fov=fov)\n\n    def set_background(self, color: str) -&gt; None:\n        \"\"\"Set background color.\n\n        Args:\n            color: Background color (hex string).\n        \"\"\"\n        self.background = color\n        self.call_js_method(\"setBackground\", color=color)\n\n    def set_edl(\n        self,\n        enabled: bool = True,\n        radius: float = 1.4,\n        strength: float = 0.4,\n    ) -&gt; None:\n        \"\"\"Configure Eye Dome Lighting.\n\n        Args:\n            enabled: Whether to enable EDL.\n            radius: EDL radius.\n            strength: EDL strength.\n        \"\"\"\n        self.edl_enabled = enabled\n        self.edl_radius = radius\n        self.edl_strength = strength\n        self.call_js_method(\n            \"setEDL\",\n            enabled=enabled,\n            radius=radius,\n            strength=strength,\n        )\n\n    # -------------------------------------------------------------------------\n    # Measurement Tools\n    # -------------------------------------------------------------------------\n\n    def add_measurement_tool(self, tool_type: str = \"distance\") -&gt; None:\n        \"\"\"Add a measurement tool.\n\n        Args:\n            tool_type: Type of measurement ('point', 'distance', 'area', 'angle', 'height', 'profile').\n        \"\"\"\n        self.call_js_method(\"addMeasurementTool\", type=tool_type)\n\n    def clear_measurements(self) -&gt; None:\n        \"\"\"Clear all measurements.\"\"\"\n        self.call_js_method(\"clearMeasurements\")\n\n    # -------------------------------------------------------------------------\n    # Clipping\n    # -------------------------------------------------------------------------\n\n    def add_clipping_volume(\n        self,\n        volume_type: str = \"box\",\n        position: Optional[Tuple[float, float, float]] = None,\n        scale: Optional[Tuple[float, float, float]] = None,\n    ) -&gt; None:\n        \"\"\"Add a clipping volume.\n\n        Args:\n            volume_type: Type of volume ('box', 'polygon', 'plane').\n            position: Volume position (x, y, z).\n            scale: Volume scale (x, y, z).\n        \"\"\"\n        self.call_js_method(\n            \"addClippingVolume\",\n            type=volume_type,\n            position=list(position) if position else None,\n            scale=list(scale) if scale else None,\n        )\n\n    def clear_clipping_volumes(self) -&gt; None:\n        \"\"\"Clear all clipping volumes.\"\"\"\n        self.call_js_method(\"clearClippingVolumes\")\n\n    # -------------------------------------------------------------------------\n    # Annotations\n    # -------------------------------------------------------------------------\n\n    def add_annotation(\n        self,\n        position: Tuple[float, float, float],\n        title: str,\n        description: str = \"\",\n        camera_position: Optional[Tuple[float, float, float]] = None,\n        camera_target: Optional[Tuple[float, float, float]] = None,\n    ) -&gt; None:\n        \"\"\"Add an annotation.\n\n        Args:\n            position: Annotation position (x, y, z).\n            title: Annotation title.\n            description: Annotation description.\n            camera_position: Camera position when focused.\n            camera_target: Camera target when focused.\n        \"\"\"\n        self.call_js_method(\n            \"addAnnotation\",\n            position=list(position),\n            title=title,\n            description=description,\n            cameraPosition=list(camera_position) if camera_position else None,\n            cameraTarget=list(camera_target) if camera_target else None,\n        )\n\n    def clear_annotations(self) -&gt; None:\n        \"\"\"Clear all annotations.\"\"\"\n        self.call_js_method(\"clearAnnotations\")\n\n    # -------------------------------------------------------------------------\n    # HTML Export\n    # -------------------------------------------------------------------------\n\n    def _generate_html_template(self) -&gt; str:\n        \"\"\"Generate standalone HTML for Potree viewer.\"\"\"\n        template_path = Path(__file__).parent / \"templates\" / \"potree.html\"\n\n        if template_path.exists():\n            template = template_path.read_text(encoding=\"utf-8\")\n        else:\n            template = self._get_default_template()\n\n        state = {\n            \"point_budget\": self.point_budget,\n            \"point_size\": self.point_size,\n            \"fov\": self.fov,\n            \"background\": self.background,\n            \"edl_enabled\": self.edl_enabled,\n            \"edl_radius\": self.edl_radius,\n            \"edl_strength\": self.edl_strength,\n            \"point_clouds\": self.point_clouds,\n            \"camera_position\": self.camera_position,\n            \"camera_target\": self.camera_target,\n            \"width\": self.width,\n            \"height\": self.height,\n            \"js_calls\": self._js_calls,\n        }\n\n        template = template.replace(\"{{state}}\", json.dumps(state, indent=2))\n        return template\n\n    def _get_default_template(self) -&gt; str:\n        \"\"\"Get default HTML template.\"\"\"\n        return \"\"\"&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n    &lt;meta charset=\"utf-8\"&gt;\n    &lt;title&gt;Potree Viewer&lt;/title&gt;\n    &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"&gt;\n    &lt;style&gt;\n        * { margin: 0; padding: 0; box-sizing: border-box; }\n        html, body { height: 100%; overflow: hidden; }\n        #potree_render_area { position: absolute; top: 0; bottom: 0; width: 100%; }\n    &lt;/style&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;div id=\"potree_render_area\"&gt;&lt;/div&gt;\n    &lt;script&gt;\n        const state = {{state}};\n        document.getElementById('potree_render_area').innerHTML = '&lt;p style=\"color: white; padding: 20px;\"&gt;Potree viewer requires Potree library. Point clouds: ' + Object.keys(state.point_clouds || {}).length + '&lt;/p&gt;';\n    &lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\"\"\"\n</code></pre>"},{"location":"potree/#anymap_ts.potree.PotreeViewer.__init__","title":"<code>__init__(self, width='100%', height='600px', point_budget=1000000, point_size=1.0, fov=60.0, background='#000000', edl_enabled=True, **kwargs)</code>  <code>special</code>","text":"<p>Initialize a Potree viewer.</p> <p>Parameters:</p> Name Type Description Default <code>width</code> <code>str</code> <p>Widget width as CSS string.</p> <code>'100%'</code> <code>height</code> <code>str</code> <p>Widget height as CSS string.</p> <code>'600px'</code> <code>point_budget</code> <code>int</code> <p>Maximum number of points to render.</p> <code>1000000</code> <code>point_size</code> <code>float</code> <p>Default point size.</p> <code>1.0</code> <code>fov</code> <code>float</code> <p>Field of view in degrees.</p> <code>60.0</code> <code>background</code> <code>str</code> <p>Background color (hex string).</p> <code>'#000000'</code> <code>edl_enabled</code> <code>bool</code> <p>Enable Eye Dome Lighting.</p> <code>True</code> <code>**kwargs</code> <p>Additional widget arguments.</p> <code>{}</code> Source code in <code>anymap_ts/potree.py</code> <pre><code>def __init__(\n    self,\n    width: str = \"100%\",\n    height: str = \"600px\",\n    point_budget: int = 1000000,\n    point_size: float = 1.0,\n    fov: float = 60.0,\n    background: str = \"#000000\",\n    edl_enabled: bool = True,\n    **kwargs,\n):\n    \"\"\"Initialize a Potree viewer.\n\n    Args:\n        width: Widget width as CSS string.\n        height: Widget height as CSS string.\n        point_budget: Maximum number of points to render.\n        point_size: Default point size.\n        fov: Field of view in degrees.\n        background: Background color (hex string).\n        edl_enabled: Enable Eye Dome Lighting.\n        **kwargs: Additional widget arguments.\n    \"\"\"\n    # Potree doesn't use center/zoom like maps\n    super().__init__(\n        center=[0, 0],\n        zoom=1,\n        width=width,\n        height=height,\n        point_budget=point_budget,\n        point_size=point_size,\n        fov=fov,\n        background=background,\n        edl_enabled=edl_enabled,\n        **kwargs,\n    )\n    self.point_clouds = {}\n</code></pre>"},{"location":"potree/#anymap_ts.potree.PotreeViewer.add_annotation","title":"<code>add_annotation(self, position, title, description='', camera_position=None, camera_target=None)</code>","text":"<p>Add an annotation.</p> <p>Parameters:</p> Name Type Description Default <code>position</code> <code>Tuple[float, float, float]</code> <p>Annotation position (x, y, z).</p> required <code>title</code> <code>str</code> <p>Annotation title.</p> required <code>description</code> <code>str</code> <p>Annotation description.</p> <code>''</code> <code>camera_position</code> <code>Optional[Tuple[float, float, float]]</code> <p>Camera position when focused.</p> <code>None</code> <code>camera_target</code> <code>Optional[Tuple[float, float, float]]</code> <p>Camera target when focused.</p> <code>None</code> Source code in <code>anymap_ts/potree.py</code> <pre><code>def add_annotation(\n    self,\n    position: Tuple[float, float, float],\n    title: str,\n    description: str = \"\",\n    camera_position: Optional[Tuple[float, float, float]] = None,\n    camera_target: Optional[Tuple[float, float, float]] = None,\n) -&gt; None:\n    \"\"\"Add an annotation.\n\n    Args:\n        position: Annotation position (x, y, z).\n        title: Annotation title.\n        description: Annotation description.\n        camera_position: Camera position when focused.\n        camera_target: Camera target when focused.\n    \"\"\"\n    self.call_js_method(\n        \"addAnnotation\",\n        position=list(position),\n        title=title,\n        description=description,\n        cameraPosition=list(camera_position) if camera_position else None,\n        cameraTarget=list(camera_target) if camera_target else None,\n    )\n</code></pre>"},{"location":"potree/#anymap_ts.potree.PotreeViewer.add_clipping_volume","title":"<code>add_clipping_volume(self, volume_type='box', position=None, scale=None)</code>","text":"<p>Add a clipping volume.</p> <p>Parameters:</p> Name Type Description Default <code>volume_type</code> <code>str</code> <p>Type of volume ('box', 'polygon', 'plane').</p> <code>'box'</code> <code>position</code> <code>Optional[Tuple[float, float, float]]</code> <p>Volume position (x, y, z).</p> <code>None</code> <code>scale</code> <code>Optional[Tuple[float, float, float]]</code> <p>Volume scale (x, y, z).</p> <code>None</code> Source code in <code>anymap_ts/potree.py</code> <pre><code>def add_clipping_volume(\n    self,\n    volume_type: str = \"box\",\n    position: Optional[Tuple[float, float, float]] = None,\n    scale: Optional[Tuple[float, float, float]] = None,\n) -&gt; None:\n    \"\"\"Add a clipping volume.\n\n    Args:\n        volume_type: Type of volume ('box', 'polygon', 'plane').\n        position: Volume position (x, y, z).\n        scale: Volume scale (x, y, z).\n    \"\"\"\n    self.call_js_method(\n        \"addClippingVolume\",\n        type=volume_type,\n        position=list(position) if position else None,\n        scale=list(scale) if scale else None,\n    )\n</code></pre>"},{"location":"potree/#anymap_ts.potree.PotreeViewer.add_measurement_tool","title":"<code>add_measurement_tool(self, tool_type='distance')</code>","text":"<p>Add a measurement tool.</p> <p>Parameters:</p> Name Type Description Default <code>tool_type</code> <code>str</code> <p>Type of measurement ('point', 'distance', 'area', 'angle', 'height', 'profile').</p> <code>'distance'</code> Source code in <code>anymap_ts/potree.py</code> <pre><code>def add_measurement_tool(self, tool_type: str = \"distance\") -&gt; None:\n    \"\"\"Add a measurement tool.\n\n    Args:\n        tool_type: Type of measurement ('point', 'distance', 'area', 'angle', 'height', 'profile').\n    \"\"\"\n    self.call_js_method(\"addMeasurementTool\", type=tool_type)\n</code></pre>"},{"location":"potree/#anymap_ts.potree.PotreeViewer.clear_annotations","title":"<code>clear_annotations(self)</code>","text":"<p>Clear all annotations.</p> Source code in <code>anymap_ts/potree.py</code> <pre><code>def clear_annotations(self) -&gt; None:\n    \"\"\"Clear all annotations.\"\"\"\n    self.call_js_method(\"clearAnnotations\")\n</code></pre>"},{"location":"potree/#anymap_ts.potree.PotreeViewer.clear_clipping_volumes","title":"<code>clear_clipping_volumes(self)</code>","text":"<p>Clear all clipping volumes.</p> Source code in <code>anymap_ts/potree.py</code> <pre><code>def clear_clipping_volumes(self) -&gt; None:\n    \"\"\"Clear all clipping volumes.\"\"\"\n    self.call_js_method(\"clearClippingVolumes\")\n</code></pre>"},{"location":"potree/#anymap_ts.potree.PotreeViewer.clear_measurements","title":"<code>clear_measurements(self)</code>","text":"<p>Clear all measurements.</p> Source code in <code>anymap_ts/potree.py</code> <pre><code>def clear_measurements(self) -&gt; None:\n    \"\"\"Clear all measurements.\"\"\"\n    self.call_js_method(\"clearMeasurements\")\n</code></pre>"},{"location":"potree/#anymap_ts.potree.PotreeViewer.fly_to_point_cloud","title":"<code>fly_to_point_cloud(self, name=None)</code>","text":"<p>Fly to a point cloud or all point clouds.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>Optional[str]</code> <p>Point cloud name (None for all).</p> <code>None</code> Source code in <code>anymap_ts/potree.py</code> <pre><code>def fly_to_point_cloud(self, name: Optional[str] = None) -&gt; None:\n    \"\"\"Fly to a point cloud or all point clouds.\n\n    Args:\n        name: Point cloud name (None for all).\n    \"\"\"\n    self.call_js_method(\"flyToPointCloud\", name=name)\n</code></pre>"},{"location":"potree/#anymap_ts.potree.PotreeViewer.load_point_cloud","title":"<code>load_point_cloud(self, url, name=None, visible=True, point_size=None, point_size_type='adaptive', shape='circle', color=None, **kwargs)</code>","text":"<p>Load a point cloud.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>URL to point cloud (Potree format or LAZ/LAS via Entwine).</p> required <code>name</code> <code>Optional[str]</code> <p>Point cloud name.</p> <code>None</code> <code>visible</code> <code>bool</code> <p>Whether point cloud is visible.</p> <code>True</code> <code>point_size</code> <code>Optional[float]</code> <p>Point size (overrides default).</p> <code>None</code> <code>point_size_type</code> <code>str</code> <p>'fixed', 'attenuated', or 'adaptive'.</p> <code>'adaptive'</code> <code>shape</code> <code>str</code> <p>Point shape ('square', 'circle', 'paraboloid').</p> <code>'circle'</code> <code>color</code> <code>Optional[str]</code> <p>Point color (hex string or None for native colors).</p> <code>None</code> <code>**kwargs</code> <p>Additional material options.</p> <code>{}</code> Source code in <code>anymap_ts/potree.py</code> <pre><code>def load_point_cloud(\n    self,\n    url: str,\n    name: Optional[str] = None,\n    visible: bool = True,\n    point_size: Optional[float] = None,\n    point_size_type: str = \"adaptive\",\n    shape: str = \"circle\",\n    color: Optional[str] = None,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Load a point cloud.\n\n    Args:\n        url: URL to point cloud (Potree format or LAZ/LAS via Entwine).\n        name: Point cloud name.\n        visible: Whether point cloud is visible.\n        point_size: Point size (overrides default).\n        point_size_type: 'fixed', 'attenuated', or 'adaptive'.\n        shape: Point shape ('square', 'circle', 'paraboloid').\n        color: Point color (hex string or None for native colors).\n        **kwargs: Additional material options.\n    \"\"\"\n    cloud_id = name or f\"pointcloud_{len(self.point_clouds)}\"\n\n    self.point_clouds = {\n        **self.point_clouds,\n        cloud_id: {\n            \"url\": url,\n            \"name\": cloud_id,\n            \"visible\": visible,\n            \"material\": {\n                \"size\": point_size or self.point_size,\n                \"pointSizeType\": point_size_type,\n                \"shape\": shape,\n                \"color\": color,\n                **kwargs,\n            },\n        },\n    }\n\n    self.call_js_method(\n        \"loadPointCloud\",\n        url=url,\n        name=cloud_id,\n        visible=visible,\n        material={\n            \"size\": point_size or self.point_size,\n            \"pointSizeType\": point_size_type,\n            \"shape\": shape,\n            \"color\": color,\n            **kwargs,\n        },\n    )\n</code></pre>"},{"location":"potree/#anymap_ts.potree.PotreeViewer.remove_point_cloud","title":"<code>remove_point_cloud(self, name)</code>","text":"<p>Remove a point cloud.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Point cloud name to remove.</p> required Source code in <code>anymap_ts/potree.py</code> <pre><code>def remove_point_cloud(self, name: str) -&gt; None:\n    \"\"\"Remove a point cloud.\n\n    Args:\n        name: Point cloud name to remove.\n    \"\"\"\n    if name in self.point_clouds:\n        clouds = dict(self.point_clouds)\n        del clouds[name]\n        self.point_clouds = clouds\n    self.call_js_method(\"removePointCloud\", name=name)\n</code></pre>"},{"location":"potree/#anymap_ts.potree.PotreeViewer.reset_camera","title":"<code>reset_camera(self)</code>","text":"<p>Reset camera to default view.</p> Source code in <code>anymap_ts/potree.py</code> <pre><code>def reset_camera(self) -&gt; None:\n    \"\"\"Reset camera to default view.\"\"\"\n    self.call_js_method(\"resetCamera\")\n</code></pre>"},{"location":"potree/#anymap_ts.potree.PotreeViewer.set_background","title":"<code>set_background(self, color)</code>","text":"<p>Set background color.</p> <p>Parameters:</p> Name Type Description Default <code>color</code> <code>str</code> <p>Background color (hex string).</p> required Source code in <code>anymap_ts/potree.py</code> <pre><code>def set_background(self, color: str) -&gt; None:\n    \"\"\"Set background color.\n\n    Args:\n        color: Background color (hex string).\n    \"\"\"\n    self.background = color\n    self.call_js_method(\"setBackground\", color=color)\n</code></pre>"},{"location":"potree/#anymap_ts.potree.PotreeViewer.set_camera_position","title":"<code>set_camera_position(self, x, y, z)</code>","text":"<p>Set camera position.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>float</code> <p>X coordinate.</p> required <code>y</code> <code>float</code> <p>Y coordinate.</p> required <code>z</code> <code>float</code> <p>Z coordinate.</p> required Source code in <code>anymap_ts/potree.py</code> <pre><code>def set_camera_position(\n    self,\n    x: float,\n    y: float,\n    z: float,\n) -&gt; None:\n    \"\"\"Set camera position.\n\n    Args:\n        x: X coordinate.\n        y: Y coordinate.\n        z: Z coordinate.\n    \"\"\"\n    self.camera_position = [x, y, z]\n    self.call_js_method(\"setCameraPosition\", x=x, y=y, z=z)\n</code></pre>"},{"location":"potree/#anymap_ts.potree.PotreeViewer.set_camera_target","title":"<code>set_camera_target(self, x, y, z)</code>","text":"<p>Set camera target (look-at point).</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>float</code> <p>X coordinate.</p> required <code>y</code> <code>float</code> <p>Y coordinate.</p> required <code>z</code> <code>float</code> <p>Z coordinate.</p> required Source code in <code>anymap_ts/potree.py</code> <pre><code>def set_camera_target(\n    self,\n    x: float,\n    y: float,\n    z: float,\n) -&gt; None:\n    \"\"\"Set camera target (look-at point).\n\n    Args:\n        x: X coordinate.\n        y: Y coordinate.\n        z: Z coordinate.\n    \"\"\"\n    self.camera_target = [x, y, z]\n    self.call_js_method(\"setCameraTarget\", x=x, y=y, z=z)\n</code></pre>"},{"location":"potree/#anymap_ts.potree.PotreeViewer.set_edl","title":"<code>set_edl(self, enabled=True, radius=1.4, strength=0.4)</code>","text":"<p>Configure Eye Dome Lighting.</p> <p>Parameters:</p> Name Type Description Default <code>enabled</code> <code>bool</code> <p>Whether to enable EDL.</p> <code>True</code> <code>radius</code> <code>float</code> <p>EDL radius.</p> <code>1.4</code> <code>strength</code> <code>float</code> <p>EDL strength.</p> <code>0.4</code> Source code in <code>anymap_ts/potree.py</code> <pre><code>def set_edl(\n    self,\n    enabled: bool = True,\n    radius: float = 1.4,\n    strength: float = 0.4,\n) -&gt; None:\n    \"\"\"Configure Eye Dome Lighting.\n\n    Args:\n        enabled: Whether to enable EDL.\n        radius: EDL radius.\n        strength: EDL strength.\n    \"\"\"\n    self.edl_enabled = enabled\n    self.edl_radius = radius\n    self.edl_strength = strength\n    self.call_js_method(\n        \"setEDL\",\n        enabled=enabled,\n        radius=radius,\n        strength=strength,\n    )\n</code></pre>"},{"location":"potree/#anymap_ts.potree.PotreeViewer.set_fov","title":"<code>set_fov(self, fov)</code>","text":"<p>Set field of view.</p> <p>Parameters:</p> Name Type Description Default <code>fov</code> <code>float</code> <p>Field of view in degrees.</p> required Source code in <code>anymap_ts/potree.py</code> <pre><code>def set_fov(self, fov: float) -&gt; None:\n    \"\"\"Set field of view.\n\n    Args:\n        fov: Field of view in degrees.\n    \"\"\"\n    self.fov = fov\n    self.call_js_method(\"setFOV\", fov=fov)\n</code></pre>"},{"location":"potree/#anymap_ts.potree.PotreeViewer.set_point_budget","title":"<code>set_point_budget(self, budget)</code>","text":"<p>Set the point budget (max points to render).</p> <p>Parameters:</p> Name Type Description Default <code>budget</code> <code>int</code> <p>Maximum number of points.</p> required Source code in <code>anymap_ts/potree.py</code> <pre><code>def set_point_budget(self, budget: int) -&gt; None:\n    \"\"\"Set the point budget (max points to render).\n\n    Args:\n        budget: Maximum number of points.\n    \"\"\"\n    self.point_budget = budget\n    self.call_js_method(\"setPointBudget\", budget=budget)\n</code></pre>"},{"location":"potree/#anymap_ts.potree.PotreeViewer.set_point_cloud_visibility","title":"<code>set_point_cloud_visibility(self, name, visible)</code>","text":"<p>Set point cloud visibility.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Point cloud name.</p> required <code>visible</code> <code>bool</code> <p>Whether to show the point cloud.</p> required Source code in <code>anymap_ts/potree.py</code> <pre><code>def set_point_cloud_visibility(self, name: str, visible: bool) -&gt; None:\n    \"\"\"Set point cloud visibility.\n\n    Args:\n        name: Point cloud name.\n        visible: Whether to show the point cloud.\n    \"\"\"\n    self.call_js_method(\"setPointCloudVisibility\", name=name, visible=visible)\n</code></pre>"},{"location":"potree/#anymap_ts.potree.PotreeViewer.set_point_size","title":"<code>set_point_size(self, size)</code>","text":"<p>Set default point size.</p> <p>Parameters:</p> Name Type Description Default <code>size</code> <code>float</code> <p>Point size.</p> required Source code in <code>anymap_ts/potree.py</code> <pre><code>def set_point_size(self, size: float) -&gt; None:\n    \"\"\"Set default point size.\n\n    Args:\n        size: Point size.\n    \"\"\"\n    self.point_size = size\n    self.call_js_method(\"setPointSize\", size=size)\n</code></pre>"},{"location":"usage/","title":"Usage","text":""},{"location":"usage/#map-classes","title":"Map Classes","text":"Class Base Library Key Features <code>Map</code> / <code>MapLibreMap</code> MapLibre GL JS Vector tiles, drawing, layer control <code>MapboxMap</code> Mapbox GL JS 3D terrain, Mapbox styles <code>LeafletMap</code> Leaflet Lightweight, plugins <code>OpenLayersMap</code> OpenLayers WMS/WMTS, projections <code>DeckGLMap</code> DeckGL + MapLibre GPU layers, aggregations <code>CesiumMap</code> Cesium 3D globe, terrain, 3D Tiles <code>KeplerGLMap</code> KeplerGL Data exploration UI <code>PotreeViewer</code> Potree Point cloud visualization"},{"location":"usage/#maplibre-gl-js-default","title":"MapLibre GL JS (Default)","text":"<pre><code>from anymap_ts import Map\n\n# Create a map centered on a location\nm = Map(center=[-122.4, 37.8], zoom=10)\nm.add_basemap(\"OpenStreetMap\")\nm.add_draw_control()\nm\n</code></pre>"},{"location":"usage/#mapbox-gl-js","title":"Mapbox GL JS","text":"<pre><code>import os\nfrom anymap_ts import MapboxMap\n\n# Set your Mapbox token (or use MAPBOX_TOKEN env var)\nm = MapboxMap(center=[-122.4, 37.8], zoom=10)\nm.add_basemap(\"OpenStreetMap\")\nm\n</code></pre>"},{"location":"usage/#leaflet","title":"Leaflet","text":"<pre><code>from anymap_ts import LeafletMap\n\nm = LeafletMap(center=[-122.4, 37.8], zoom=10)\nm.add_basemap(\"OpenStreetMap\")\nm.add_marker(-122.4194, 37.7749, popup=\"San Francisco\")\nm\n</code></pre>"},{"location":"usage/#openlayers","title":"OpenLayers","text":"<pre><code>from anymap_ts import OpenLayersMap\n\nm = OpenLayersMap(center=[-122.4, 37.8], zoom=10)\nm.add_basemap(\"OpenStreetMap\")\n\n# Add WMS layer\nm.add_wms_layer(\n    url=\"https://example.com/wms\",\n    layers=\"layer_name\",\n    name=\"WMS Layer\"\n)\nm\n</code></pre>"},{"location":"usage/#deckgl","title":"DeckGL","text":"<pre><code>from anymap_ts import DeckGLMap\n\nm = DeckGLMap(center=[-122.4, 37.8], zoom=10)\nm.add_basemap(\"CartoDB.DarkMatter\")\n\n# Add scatterplot layer\npoints = [{\"coordinates\": [-122.4, 37.8], \"value\": 100}]\nm.add_scatterplot_layer(data=points, get_radius=100)\n\n# Add hexagon aggregation\nm.add_hexagon_layer(data=points, radius=500, extruded=True)\nm\n</code></pre>"},{"location":"usage/#cesium-3d-globe","title":"Cesium (3D Globe)","text":"<pre><code>from anymap_ts import CesiumMap\n\n# Set CESIUM_TOKEN env var for terrain/3D Tiles\nm = CesiumMap(center=[-122.4, 37.8], zoom=10)\nm.add_basemap(\"OpenStreetMap\")\nm.set_terrain()  # Enable Cesium World Terrain\nm.fly_to(-122.4194, 37.7749, height=50000, heading=45, pitch=-45)\nm\n</code></pre>"},{"location":"usage/#keplergl","title":"KeplerGL","text":"<pre><code>from anymap_ts import KeplerGLMap\nimport pandas as pd\n\nm = KeplerGLMap(center=[-122.4, 37.8], zoom=10)\n\n# Add DataFrame data\ndf = pd.DataFrame({\n    'latitude': [37.7749, 37.8044],\n    'longitude': [-122.4194, -122.2712],\n    'value': [100, 200]\n})\nm.add_data(df, name='points')\nm\n</code></pre>"},{"location":"usage/#potree-point-clouds","title":"Potree (Point Clouds)","text":"<pre><code>from anymap_ts import PotreeViewer\n\nviewer = PotreeViewer(\n    point_budget=1000000,\n    edl_enabled=True\n)\nviewer.load_point_cloud(\"path/to/pointcloud/cloud.js\", name=\"lidar\")\nviewer\n</code></pre>"},{"location":"usage/#common-methods","title":"Common Methods","text":"Method Description <code>add_basemap(name)</code> Add a basemap layer <code>add_vector(data, name)</code> Add vector data (GeoJSON/GeoDataFrame) <code>add_geojson(data, name)</code> Add GeoJSON data <code>add_tile_layer(url, name)</code> Add XYZ tile layer <code>fly_to(lng, lat, zoom)</code> Fly to location <code>fit_bounds(bounds)</code> Fit map to bounds <code>set_visibility(layer, visible)</code> Set layer visibility <code>set_opacity(layer, opacity)</code> Set layer opacity <code>to_html(filepath)</code> Export to HTML"},{"location":"usage/#add-vector-data","title":"Add Vector Data","text":"<pre><code>geojson = {\n    \"type\": \"FeatureCollection\",\n    \"features\": [\n        {\n            \"type\": \"Feature\",\n            \"geometry\": {\"type\": \"Point\", \"coordinates\": [-122.4, 37.8]},\n            \"properties\": {\"name\": \"San Francisco\"}\n        }\n    ]\n}\n\n# Works with MapLibre, Mapbox, Leaflet, OpenLayers\nm.add_vector(geojson, name=\"points\")\n\n# Or with GeoDataFrame (requires geopandas)\nimport geopandas as gpd\ngdf = gpd.read_file(\"path/to/data.geojson\")\nm.add_vector(gdf, name=\"polygons\")\n</code></pre>"},{"location":"usage/#map-navigation","title":"Map Navigation","text":"<pre><code># Fly to location with animation\nm.fly_to(-122.4, 37.8, zoom=14)\n\n# Fit to bounds [west, south, east, north]\nm.fit_bounds([-123, 37, -122, 38])\n</code></pre>"},{"location":"usage/#export-to-html","title":"Export to HTML","text":"<pre><code># All map types support HTML export\nm.to_html(\"map.html\", title=\"My Map\")\n</code></pre>"},{"location":"utils/","title":"utils module","text":"<p>Utility functions for anymap-ts.</p>"},{"location":"utils/#anymap_ts.utils.build_step_expression","title":"<code>build_step_expression(column, breaks, colors)</code>","text":"<p>Build a MapLibre step expression for choropleth styling.</p> <p>Parameters:</p> Name Type Description Default <code>column</code> <code>str</code> <p>Property name to style by.</p> required <code>breaks</code> <code>List[float]</code> <p>Break values (k+1 values for k classes).</p> required <code>colors</code> <code>List[str]</code> <p>List of k colors for each class.</p> required <p>Returns:</p> Type Description <code>List</code> <p>MapLibre step expression as a list.</p> Source code in <code>anymap_ts/utils.py</code> <pre><code>def build_step_expression(column: str, breaks: List[float], colors: List[str]) -&gt; List:\n    \"\"\"Build a MapLibre step expression for choropleth styling.\n\n    Args:\n        column: Property name to style by.\n        breaks: Break values (k+1 values for k classes).\n        colors: List of k colors for each class.\n\n    Returns:\n        MapLibre step expression as a list.\n    \"\"\"\n    # MapLibre step expression format:\n    # [\"step\", [\"get\", \"property\"], color0, break1, color1, break2, color2, ...]\n    expr = [\"step\", [\"get\", column], colors[0]]\n\n    # Add breaks and colors (skip the first break which is the minimum)\n    for i in range(1, len(breaks) - 1):\n        expr.append(breaks[i])\n        expr.append(colors[i])\n\n    # Handle the last class\n    if len(colors) &gt; len(breaks) - 1:\n        expr.append(breaks[-1])\n        expr.append(colors[-1])\n\n    return expr\n</code></pre>"},{"location":"utils/#anymap_ts.utils.compute_breaks","title":"<code>compute_breaks(values, classification, k, manual_breaks=None)</code>","text":"<p>Compute classification breaks for choropleth maps.</p> <p>Parameters:</p> Name Type Description Default <code>values</code> <code>List[float]</code> <p>List of numeric values to classify.</p> required <code>classification</code> <code>str</code> <p>Classification method ('quantile', 'equal_interval', 'natural_breaks', 'manual').</p> required <code>k</code> <code>int</code> <p>Number of classes.</p> required <code>manual_breaks</code> <code>Optional[List[float]]</code> <p>Custom break values for 'manual' classification.</p> <code>None</code> <p>Returns:</p> Type Description <code>List[float]</code> <p>List of break values (k+1 values defining class boundaries).</p> <p>Exceptions:</p> Type Description <code>ValueError</code> <p>If classification method is invalid or breaks are incorrect.</p> Source code in <code>anymap_ts/utils.py</code> <pre><code>def compute_breaks(\n    values: List[float],\n    classification: str,\n    k: int,\n    manual_breaks: Optional[List[float]] = None,\n) -&gt; List[float]:\n    \"\"\"Compute classification breaks for choropleth maps.\n\n    Args:\n        values: List of numeric values to classify.\n        classification: Classification method ('quantile', 'equal_interval',\n            'natural_breaks', 'manual').\n        k: Number of classes.\n        manual_breaks: Custom break values for 'manual' classification.\n\n    Returns:\n        List of break values (k+1 values defining class boundaries).\n\n    Raises:\n        ValueError: If classification method is invalid or breaks are incorrect.\n    \"\"\"\n    if classification == \"manual\":\n        if manual_breaks is None:\n            raise ValueError(\"manual_breaks required for 'manual' classification\")\n        if len(manual_breaks) != k + 1:\n            raise ValueError(f\"manual_breaks must have {k + 1} values for {k} classes\")\n        return manual_breaks\n\n    sorted_values = sorted(values)\n    min_val = sorted_values[0]\n    max_val = sorted_values[-1]\n\n    if classification == \"quantile\":\n        # Equal number of features per class\n        breaks = [min_val]\n        for i in range(1, k):\n            idx = int(len(sorted_values) * i / k)\n            breaks.append(sorted_values[idx])\n        breaks.append(max_val)\n        return breaks\n\n    elif classification == \"equal_interval\":\n        # Equal value ranges\n        interval = (max_val - min_val) / k\n        breaks = [min_val + i * interval for i in range(k + 1)]\n        return breaks\n\n    elif classification == \"natural_breaks\":\n        # Jenks natural breaks - requires jenkspy\n        try:\n            import jenkspy\n\n            breaks = jenkspy.jenks_breaks(values, n_classes=k)\n            return breaks\n        except ImportError:\n            raise ImportError(\n                \"jenkspy is required for natural_breaks classification. \"\n                \"Install with: pip install jenkspy\"\n            )\n\n    else:\n        raise ValueError(\n            f\"Unknown classification method '{classification}'. \"\n            \"Options: 'quantile', 'equal_interval', 'natural_breaks', 'manual'\"\n        )\n</code></pre>"},{"location":"utils/#anymap_ts.utils.fetch_geojson","title":"<code>fetch_geojson(url)</code>","text":"<p>Fetch GeoJSON data from a URL.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>URL to fetch GeoJSON from</p> required <p>Returns:</p> Type Description <code>Dict</code> <p>GeoJSON dict</p> <p>Exceptions:</p> Type Description <code>ValueError</code> <p>If the URL cannot be fetched or parsed</p> Source code in <code>anymap_ts/utils.py</code> <pre><code>def fetch_geojson(url: str) -&gt; Dict:\n    \"\"\"Fetch GeoJSON data from a URL.\n\n    Args:\n        url: URL to fetch GeoJSON from\n\n    Returns:\n        GeoJSON dict\n\n    Raises:\n        ValueError: If the URL cannot be fetched or parsed\n    \"\"\"\n    try:\n        with urlopen(url, timeout=30) as response:\n            charset = response.headers.get_content_charset() or \"utf-8\"\n            data = response.read().decode(charset)\n            return json.loads(data)\n    except URLError as e:\n        raise ValueError(f\"Failed to fetch GeoJSON from URL: {e}\") from e\n    except UnicodeDecodeError as e:\n        raise ValueError(f\"Failed to decode response as UTF-8: {e}\") from e\n    except json.JSONDecodeError as e:\n        raise ValueError(f\"Invalid JSON at URL: {e}\") from e\n</code></pre>"},{"location":"utils/#anymap_ts.utils.get_bounds","title":"<code>get_bounds(data)</code>","text":"<p>Calculate bounds from GeoJSON or GeoDataFrame.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>GeoJSON dict or GeoDataFrame</p> required <p>Returns:</p> Type Description <code>Optional[List[float]]</code> <p>[west, south, east, north] bounds or None</p> Source code in <code>anymap_ts/utils.py</code> <pre><code>def get_bounds(data: Any) -&gt; Optional[List[float]]:\n    \"\"\"Calculate bounds from GeoJSON or GeoDataFrame.\n\n    Args:\n        data: GeoJSON dict or GeoDataFrame\n\n    Returns:\n        [west, south, east, north] bounds or None\n    \"\"\"\n    if HAS_GEOPANDAS and isinstance(data, gpd.GeoDataFrame):\n        bounds = data.total_bounds\n        return [bounds[0], bounds[1], bounds[2], bounds[3]]\n\n    if isinstance(data, dict):\n        if HAS_SHAPELY:\n            return _get_geojson_bounds_shapely(data)\n        return _get_geojson_bounds_simple(data)\n\n    return None\n</code></pre>"},{"location":"utils/#anymap_ts.utils.get_choropleth_colors","title":"<code>get_choropleth_colors(cmap, k)</code>","text":"<p>Get colors for a choropleth map using matplotlib colormaps.</p> <p>Uses matplotlib colormaps when available, falling back to a small set of built-in colormaps if matplotlib is not installed.</p> <p>Parameters:</p> Name Type Description Default <code>cmap</code> <code>str</code> <p>Colormap name. Any matplotlib colormap is supported when matplotlib is installed. Common options include: - Sequential: 'viridis', 'plasma', 'inferno', 'magma', 'cividis',   'Blues', 'Greens', 'Reds', 'Oranges', 'Purples', 'Greys' - Diverging: 'RdBu', 'RdYlGn', 'RdYlBu', 'Spectral', 'coolwarm',   'bwr', 'seismic' - Qualitative: 'Set1', 'Set2', 'Set3', 'Paired', 'tab10', 'tab20' - Perceptually uniform: 'viridis', 'plasma', 'inferno', 'magma'</p> required <code>k</code> <code>int</code> <p>Number of classes/colors to generate.</p> required <p>Returns:</p> Type Description <code>List[str]</code> <p>List of k hex color strings.</p> <p>Exceptions:</p> Type Description <code>ValueError</code> <p>If colormap is not found.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; colors = get_choropleth_colors('viridis', 5)\n&gt;&gt;&gt; colors\n['#440154', '#3b528b', '#21918c', '#5ec962', '#fde725']\n</code></pre> Source code in <code>anymap_ts/utils.py</code> <pre><code>def get_choropleth_colors(cmap: str, k: int) -&gt; List[str]:\n    \"\"\"Get colors for a choropleth map using matplotlib colormaps.\n\n    Uses matplotlib colormaps when available, falling back to a small\n    set of built-in colormaps if matplotlib is not installed.\n\n    Args:\n        cmap: Colormap name. Any matplotlib colormap is supported when\n            matplotlib is installed. Common options include:\n            - Sequential: 'viridis', 'plasma', 'inferno', 'magma', 'cividis',\n              'Blues', 'Greens', 'Reds', 'Oranges', 'Purples', 'Greys'\n            - Diverging: 'RdBu', 'RdYlGn', 'RdYlBu', 'Spectral', 'coolwarm',\n              'bwr', 'seismic'\n            - Qualitative: 'Set1', 'Set2', 'Set3', 'Paired', 'tab10', 'tab20'\n            - Perceptually uniform: 'viridis', 'plasma', 'inferno', 'magma'\n        k: Number of classes/colors to generate.\n\n    Returns:\n        List of k hex color strings.\n\n    Raises:\n        ValueError: If colormap is not found.\n\n    Example:\n        &gt;&gt;&gt; colors = get_choropleth_colors('viridis', 5)\n        &gt;&gt;&gt; colors\n        ['#440154', '#3b528b', '#21918c', '#5ec962', '#fde725']\n    \"\"\"\n    if HAS_MATPLOTLIB:\n        try:\n            # Get the colormap from matplotlib\n            colormap = plt.get_cmap(cmap)\n\n            # Sample k colors evenly from the colormap\n            colors = []\n            for i in range(k):\n                # Sample at evenly spaced points\n                position = i / (k - 1) if k &gt; 1 else 0.5\n                rgba = colormap(position)\n                colors.append(_rgb_to_hex(rgba))\n\n            return colors\n\n        except ValueError:\n            raise ValueError(\n                f\"Unknown colormap '{cmap}'. See matplotlib colormap documentation \"\n                \"for available options: https://matplotlib.org/stable/gallery/color/colormap_reference.html\"\n            )\n    else:\n        # Fallback to built-in colormaps\n        if cmap not in _FALLBACK_COLORMAPS:\n            available = \", \".join(sorted(_FALLBACK_COLORMAPS.keys()))\n            raise ValueError(\n                f\"Colormap '{cmap}' not available. Without matplotlib, only these \"\n                f\"colormaps are available: {available}. \"\n                \"Install matplotlib for full colormap support: pip install matplotlib\"\n            )\n\n        full_colors = _FALLBACK_COLORMAPS[cmap]\n\n        if k &lt;= len(full_colors):\n            # Sample evenly from the colormap\n            step = len(full_colors) / k\n            indices = [int(i * step) for i in range(k)]\n            return [full_colors[i] for i in indices]\n        else:\n            # Interpolate if we need more colors than available\n            # For simplicity, just repeat the last colors\n            colors = full_colors[:]\n            while len(colors) &lt; k:\n                colors.append(colors[-1])\n            return colors[:k]\n</code></pre>"},{"location":"utils/#anymap_ts.utils.get_default_paint","title":"<code>get_default_paint(layer_type)</code>","text":"<p>Get default paint properties for a layer type.</p> <p>Parameters:</p> Name Type Description Default <code>layer_type</code> <code>str</code> <p>MapLibre layer type</p> required <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Paint properties dict</p> Source code in <code>anymap_ts/utils.py</code> <pre><code>def get_default_paint(layer_type: str) -&gt; Dict[str, Any]:\n    \"\"\"Get default paint properties for a layer type.\n\n    Args:\n        layer_type: MapLibre layer type\n\n    Returns:\n        Paint properties dict\n    \"\"\"\n    defaults = {\n        \"circle\": {\n            \"circle-radius\": 5,\n            \"circle-color\": \"#3388ff\",\n            \"circle-opacity\": 0.8,\n            \"circle-stroke-width\": 1,\n            \"circle-stroke-color\": \"#ffffff\",\n        },\n        \"line\": {\n            \"line-color\": \"#3388ff\",\n            \"line-width\": 2,\n            \"line-opacity\": 0.8,\n        },\n        \"fill\": {\n            \"fill-color\": \"#3388ff\",\n            \"fill-opacity\": 0.5,\n            \"fill-outline-color\": \"#0000ff\",\n        },\n        \"fill-extrusion\": {\n            \"fill-extrusion-color\": \"#3388ff\",\n            \"fill-extrusion-opacity\": 0.6,\n            \"fill-extrusion-height\": 100,\n        },\n        \"raster\": {\n            \"raster-opacity\": 1,\n        },\n        \"heatmap\": {\n            \"heatmap-opacity\": 0.8,\n        },\n    }\n    return defaults.get(layer_type, {})\n</code></pre>"},{"location":"utils/#anymap_ts.utils.infer_layer_type","title":"<code>infer_layer_type(geojson)</code>","text":"<p>Infer MapLibre layer type from GeoJSON geometry.</p> <p>Parameters:</p> Name Type Description Default <code>geojson</code> <code>Dict</code> <p>GeoJSON dict</p> required <p>Returns:</p> Type Description <code>str</code> <p>Layer type ('circle', 'line', 'fill')</p> Source code in <code>anymap_ts/utils.py</code> <pre><code>def infer_layer_type(geojson: Dict) -&gt; str:\n    \"\"\"Infer MapLibre layer type from GeoJSON geometry.\n\n    Args:\n        geojson: GeoJSON dict\n\n    Returns:\n        Layer type ('circle', 'line', 'fill')\n    \"\"\"\n    geometry_type = None\n\n    if geojson.get(\"type\") == \"FeatureCollection\":\n        features = geojson.get(\"features\", [])\n        if features:\n            geometry_type = features[0].get(\"geometry\", {}).get(\"type\")\n    elif geojson.get(\"type\") == \"Feature\":\n        geometry_type = geojson.get(\"geometry\", {}).get(\"type\")\n    else:\n        geometry_type = geojson.get(\"type\")\n\n    type_map = {\n        \"Point\": \"circle\",\n        \"MultiPoint\": \"circle\",\n        \"LineString\": \"line\",\n        \"MultiLineString\": \"line\",\n        \"Polygon\": \"fill\",\n        \"MultiPolygon\": \"fill\",\n        \"GeometryCollection\": \"fill\",\n    }\n\n    return type_map.get(geometry_type, \"circle\")\n</code></pre>"},{"location":"utils/#anymap_ts.utils.to_geojson","title":"<code>to_geojson(data)</code>","text":"<p>Convert various data formats to GeoJSON.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>GeoJSON dict, GeoDataFrame, file path, or URL</p> required <p>Returns:</p> Type Description <code>Dict</code> <p>GeoJSON dict</p> <p>Exceptions:</p> Type Description <code>ValueError</code> <p>If data cannot be converted</p> <code>ImportError</code> <p>If geopandas is required but not installed</p> Source code in <code>anymap_ts/utils.py</code> <pre><code>def to_geojson(data: Any) -&gt; Dict:\n    \"\"\"Convert various data formats to GeoJSON.\n\n    Args:\n        data: GeoJSON dict, GeoDataFrame, file path, or URL\n\n    Returns:\n        GeoJSON dict\n\n    Raises:\n        ValueError: If data cannot be converted\n        ImportError: If geopandas is required but not installed\n    \"\"\"\n    # Already a dict (GeoJSON)\n    if isinstance(data, dict):\n        return data\n\n    # GeoDataFrame\n    if HAS_GEOPANDAS and isinstance(data, gpd.GeoDataFrame):\n        return json.loads(data.to_json())\n\n    # File path or URL\n    if isinstance(data, (str, Path)):\n        path_str = str(data)\n\n        # If it's a URL, return as-is (will be handled by JS)\n        if path_str.startswith((\"http://\", \"https://\")):\n            return {\"type\": \"url\", \"url\": path_str}\n\n        # Read file with geopandas\n        if not HAS_GEOPANDAS:\n            raise ImportError(\n                \"geopandas is required to read vector files. \"\n                \"Install with: pip install anymap-ts[vector]\"\n            )\n\n        gdf = gpd.read_file(path_str)\n        return json.loads(gdf.to_json())\n\n    # Has __geo_interface__ (shapely geometry, etc.)\n    if hasattr(data, \"__geo_interface__\"):\n        geo = data.__geo_interface__\n        if geo.get(\"type\") in (\n            \"Point\",\n            \"LineString\",\n            \"Polygon\",\n            \"MultiPoint\",\n            \"MultiLineString\",\n            \"MultiPolygon\",\n            \"GeometryCollection\",\n        ):\n            return {\"type\": \"Feature\", \"geometry\": geo, \"properties\": {}}\n        return geo\n\n    raise ValueError(f\"Cannot convert {type(data)} to GeoJSON\")\n</code></pre>"},{"location":"cesium/cesium/","title":"Cesium","text":"In\u00a0[\u00a0]: Copied! <pre># %pip install -U anymap-ts\n</pre> # %pip install -U anymap-ts In\u00a0[\u00a0]: Copied! <pre>from anymap_ts import CesiumMap\n\n# Create a Cesium globe (uses CESIUM_TOKEN env var)\nm = CesiumMap(center=[-122.4, 37.8], zoom=10)\nm.add_basemap(\"OpenStreetMap\")\nm\n</pre> from anymap_ts import CesiumMap  # Create a Cesium globe (uses CESIUM_TOKEN env var) m = CesiumMap(center=[-122.4, 37.8], zoom=10) m.add_basemap(\"OpenStreetMap\") m In\u00a0[\u00a0]: Copied! <pre># Enable terrain (requires Cesium Ion token)\n# m.set_terrain()\n</pre> # Enable terrain (requires Cesium Ion token) # m.set_terrain() In\u00a0[\u00a0]: Copied! <pre># Add GeoJSON\ngeojson = {\n    \"type\": \"FeatureCollection\",\n    \"features\": [\n        {\n            \"type\": \"Feature\",\n            \"geometry\": {\"type\": \"Point\", \"coordinates\": [-122.4194, 37.7749]},\n            \"properties\": {\"name\": \"San Francisco\"},\n        },\n        {\n            \"type\": \"Feature\",\n            \"geometry\": {\n                \"type\": \"Polygon\",\n                \"coordinates\": [\n                    [\n                        [-122.5, 37.7],\n                        [-122.3, 37.7],\n                        [-122.3, 37.9],\n                        [-122.5, 37.9],\n                        [-122.5, 37.7],\n                    ]\n                ],\n            },\n            \"properties\": {\"name\": \"Area\"},\n        },\n    ],\n}\n\nm.add_geojson(geojson, name=\"features\", stroke=\"#ff0000\", fill=\"rgba(255,0,0,0.3)\")\n</pre> # Add GeoJSON geojson = {     \"type\": \"FeatureCollection\",     \"features\": [         {             \"type\": \"Feature\",             \"geometry\": {\"type\": \"Point\", \"coordinates\": [-122.4194, 37.7749]},             \"properties\": {\"name\": \"San Francisco\"},         },         {             \"type\": \"Feature\",             \"geometry\": {                 \"type\": \"Polygon\",                 \"coordinates\": [                     [                         [-122.5, 37.7],                         [-122.3, 37.7],                         [-122.3, 37.9],                         [-122.5, 37.9],                         [-122.5, 37.7],                     ]                 ],             },             \"properties\": {\"name\": \"Area\"},         },     ], }  m.add_geojson(geojson, name=\"features\", stroke=\"#ff0000\", fill=\"rgba(255,0,0,0.3)\") In\u00a0[\u00a0]: Copied! <pre># Fly to a location with camera orientation\nm.fly_to(-122.4194, 37.7749, height=50000, heading=45, pitch=-45)\n</pre> # Fly to a location with camera orientation m.fly_to(-122.4194, 37.7749, height=50000, heading=45, pitch=-45) In\u00a0[\u00a0]: Copied! <pre># Reset to home view\nm.reset_view()\n</pre> # Reset to home view m.reset_view() In\u00a0[\u00a0]: Copied! <pre># Add 3D Tileset (requires Cesium Ion token and asset ID)\n# m.add_3d_tileset(url=\"your_ion_asset_id\", name=\"buildings\")\n</pre> # Add 3D Tileset (requires Cesium Ion token and asset ID) # m.add_3d_tileset(url=\"your_ion_asset_id\", name=\"buildings\") In\u00a0[\u00a0]: Copied! <pre># Export to HTML\nm.to_html(\"cesium_example.html\")\n</pre> # Export to HTML m.to_html(\"cesium_example.html\")"},{"location":"cesium/cesium/#cesium-example","title":"Cesium Example\u00b6","text":"<p>This notebook demonstrates the Cesium integration in anymap-ts.</p> <p>Cesium is a powerful 3D globe visualization library with terrain and 3D Tiles support.</p> <p>Note: Some features like Cesium World Terrain require a Cesium Ion access token. Set the <code>CESIUM_TOKEN</code> environment variable.</p>"},{"location":"deckgl/bitmap_layer/","title":"Bitmap layer","text":"In\u00a0[\u00a0]: Copied! <pre># %pip install -U anymap-ts\n</pre> # %pip install -U anymap-ts In\u00a0[\u00a0]: Copied! <pre>from anymap_ts import DeckGLMap\n</pre> from anymap_ts import DeckGLMap In\u00a0[\u00a0]: Copied! <pre>m = DeckGLMap(center=[-122.4, 37.8], zoom=10)\nm.add_basemap(\"CartoDB.DarkMatter\")\n\n# Add a bitmap layer with a sample image\nm.add_bitmap_layer(\n    image=\"https://tile.openstreetmap.org/10/163/395.png\",\n    bounds=[-122.6, 37.6, -122.2, 38.0],\n    opacity=0.8,\n)\nm\n</pre> m = DeckGLMap(center=[-122.4, 37.8], zoom=10) m.add_basemap(\"CartoDB.DarkMatter\")  # Add a bitmap layer with a sample image m.add_bitmap_layer(     image=\"https://tile.openstreetmap.org/10/163/395.png\",     bounds=[-122.6, 37.6, -122.2, 38.0],     opacity=0.8, ) m In\u00a0[\u00a0]: Copied! <pre>m.to_html(\"bitmap_layer_example.html\")\n</pre> m.to_html(\"bitmap_layer_example.html\")"},{"location":"deckgl/bitmap_layer/#bitmap-layer-example","title":"Bitmap Layer Example\u00b6","text":"<p>Display raster images as map overlays using deck.gl BitmapLayer.</p>"},{"location":"deckgl/bitmap_layer/#create-a-map-with-a-bitmap-overlay","title":"Create a map with a bitmap overlay\u00b6","text":""},{"location":"deckgl/bitmap_layer/#export-to-html","title":"Export to HTML\u00b6","text":""},{"location":"deckgl/column_layer/","title":"Column layer","text":"In\u00a0[\u00a0]: Copied! <pre># %pip install -U anymap-ts\n</pre> # %pip install -U anymap-ts In\u00a0[\u00a0]: Copied! <pre>import random\nfrom anymap_ts import DeckGLMap\n</pre> import random from anymap_ts import DeckGLMap In\u00a0[\u00a0]: Copied! <pre># Generate random column data around San Francisco\ncolumns = [\n    {\n        \"coordinates\": [\n            -122.4 + (random.random() - 0.5) * 0.3,\n            37.8 + (random.random() - 0.5) * 0.3,\n        ],\n        \"value\": random.randint(500, 5000),\n    }\n    for _ in range(100)\n]\n</pre> # Generate random column data around San Francisco columns = [     {         \"coordinates\": [             -122.4 + (random.random() - 0.5) * 0.3,             37.8 + (random.random() - 0.5) * 0.3,         ],         \"value\": random.randint(500, 5000),     }     for _ in range(100) ] In\u00a0[\u00a0]: Copied! <pre>m = DeckGLMap(center=[-122.4, 37.8], zoom=11, pitch=45, bearing=-17)\nm.add_basemap(\"CartoDB.DarkMatter\")\n\nm.add_column_layer(\n    data=columns,\n    get_position=\"coordinates\",\n    get_elevation=\"value\",\n    radius=200,\n    elevation_scale=1,\n    extruded=True,\n    get_fill_color=[255, 140, 0, 200],\n    opacity=0.8,\n)\nm\n</pre> m = DeckGLMap(center=[-122.4, 37.8], zoom=11, pitch=45, bearing=-17) m.add_basemap(\"CartoDB.DarkMatter\")  m.add_column_layer(     data=columns,     get_position=\"coordinates\",     get_elevation=\"value\",     radius=200,     elevation_scale=1,     extruded=True,     get_fill_color=[255, 140, 0, 200],     opacity=0.8, ) m In\u00a0[\u00a0]: Copied! <pre>m.to_html(\"column_layer_example.html\")\n</pre> m.to_html(\"column_layer_example.html\")"},{"location":"deckgl/column_layer/#column-layer-example","title":"Column Layer Example\u00b6","text":"<p>3D column/bar visualization using deck.gl ColumnLayer.</p>"},{"location":"deckgl/column_layer/#generate-sample-data","title":"Generate sample data\u00b6","text":""},{"location":"deckgl/column_layer/#create-map-with-column-layer","title":"Create map with column layer\u00b6","text":""},{"location":"deckgl/column_layer/#export-to-html","title":"Export to HTML\u00b6","text":""},{"location":"deckgl/contour_layer/","title":"Contour layer","text":"In\u00a0[\u00a0]: Copied! <pre># %pip install -U anymap-ts\n</pre> # %pip install -U anymap-ts In\u00a0[\u00a0]: Copied! <pre>import random\nfrom anymap_ts import DeckGLMap\n\n\n# Generate clustered points around San Francisco for density visualization\ndef generate_clustered_points(count=1000):\n    clusters = [\n        {\"center\": [-122.4194, 37.7749], \"spread\": 0.02, \"weight\": 1.5},  # Downtown SF\n        {\"center\": [-122.2711, 37.8044], \"spread\": 0.015, \"weight\": 1.2},  # Oakland\n        {\"center\": [-122.2727, 37.8716], \"spread\": 0.01, \"weight\": 1.0},  # Berkeley\n        {\n            \"center\": [-122.4098, 37.7855],\n            \"spread\": 0.008,\n            \"weight\": 2.0,\n        },  # Union Square\n    ]\n\n    points = []\n    for _ in range(count):\n        cluster = random.choice(clusters)\n        import math\n\n        angle = random.random() * math.pi * 2\n        radius = random.random() * cluster[\"spread\"]\n        lng = cluster[\"center\"][0] + math.cos(angle) * radius\n        lat = cluster[\"center\"][1] + math.sin(angle) * radius\n        points.append(\n            {\n                \"coordinates\": [lng, lat],\n                \"weight\": random.random() * cluster[\"weight\"] + 0.5,\n            }\n        )\n    return points\n\n\npoints = generate_clustered_points()\n\n# Basic contour thresholds\ncontours = [\n    {\"threshold\": 1, \"color\": [255, 255, 178], \"strokeWidth\": 1},\n    {\"threshold\": 5, \"color\": [254, 178, 76], \"strokeWidth\": 2},\n    {\"threshold\": 10, \"color\": [240, 59, 32], \"strokeWidth\": 3},\n]\n\nm = DeckGLMap(center=[-122.35, 37.8], zoom=11)\nm.add_basemap(\"CartoDB.DarkMatter\")\nm.add_contour_layer(\n    data=points,\n    name=\"contour-basic\",\n    get_position=\"coordinates\",\n    contours=contours,\n    cell_size=200,\n)\nm\n</pre> import random from anymap_ts import DeckGLMap   # Generate clustered points around San Francisco for density visualization def generate_clustered_points(count=1000):     clusters = [         {\"center\": [-122.4194, 37.7749], \"spread\": 0.02, \"weight\": 1.5},  # Downtown SF         {\"center\": [-122.2711, 37.8044], \"spread\": 0.015, \"weight\": 1.2},  # Oakland         {\"center\": [-122.2727, 37.8716], \"spread\": 0.01, \"weight\": 1.0},  # Berkeley         {             \"center\": [-122.4098, 37.7855],             \"spread\": 0.008,             \"weight\": 2.0,         },  # Union Square     ]      points = []     for _ in range(count):         cluster = random.choice(clusters)         import math          angle = random.random() * math.pi * 2         radius = random.random() * cluster[\"spread\"]         lng = cluster[\"center\"][0] + math.cos(angle) * radius         lat = cluster[\"center\"][1] + math.sin(angle) * radius         points.append(             {                 \"coordinates\": [lng, lat],                 \"weight\": random.random() * cluster[\"weight\"] + 0.5,             }         )     return points   points = generate_clustered_points()  # Basic contour thresholds contours = [     {\"threshold\": 1, \"color\": [255, 255, 178], \"strokeWidth\": 1},     {\"threshold\": 5, \"color\": [254, 178, 76], \"strokeWidth\": 2},     {\"threshold\": 10, \"color\": [240, 59, 32], \"strokeWidth\": 3}, ]  m = DeckGLMap(center=[-122.35, 37.8], zoom=11) m.add_basemap(\"CartoDB.DarkMatter\") m.add_contour_layer(     data=points,     name=\"contour-basic\",     get_position=\"coordinates\",     contours=contours,     cell_size=200, ) m In\u00a0[\u00a0]: Copied! <pre># More detailed contour thresholds (yellow to red gradient)\ndetailed_contours = [\n    {\"threshold\": 1, \"color\": [255, 255, 178], \"strokeWidth\": 1},\n    {\"threshold\": 5, \"color\": [254, 217, 118], \"strokeWidth\": 1},\n    {\"threshold\": 10, \"color\": [254, 178, 76], \"strokeWidth\": 2},\n    {\"threshold\": 20, \"color\": [253, 141, 60], \"strokeWidth\": 2},\n    {\"threshold\": 40, \"color\": [252, 78, 42], \"strokeWidth\": 3},\n    {\"threshold\": 60, \"color\": [227, 26, 28], \"strokeWidth\": 3},\n    {\"threshold\": 80, \"color\": [189, 0, 38], \"strokeWidth\": 4},\n]\n\nm2 = DeckGLMap(center=[-122.35, 37.8], zoom=11)\nm2.add_basemap(\"CartoDB.DarkMatter\")\nm2.add_contour_layer(\n    data=points,\n    name=\"contour-detailed\",\n    get_position=\"coordinates\",\n    contours=detailed_contours,\n    cell_size=200,\n)\nm2\n</pre> # More detailed contour thresholds (yellow to red gradient) detailed_contours = [     {\"threshold\": 1, \"color\": [255, 255, 178], \"strokeWidth\": 1},     {\"threshold\": 5, \"color\": [254, 217, 118], \"strokeWidth\": 1},     {\"threshold\": 10, \"color\": [254, 178, 76], \"strokeWidth\": 2},     {\"threshold\": 20, \"color\": [253, 141, 60], \"strokeWidth\": 2},     {\"threshold\": 40, \"color\": [252, 78, 42], \"strokeWidth\": 3},     {\"threshold\": 60, \"color\": [227, 26, 28], \"strokeWidth\": 3},     {\"threshold\": 80, \"color\": [189, 0, 38], \"strokeWidth\": 4}, ]  m2 = DeckGLMap(center=[-122.35, 37.8], zoom=11) m2.add_basemap(\"CartoDB.DarkMatter\") m2.add_contour_layer(     data=points,     name=\"contour-detailed\",     get_position=\"coordinates\",     contours=detailed_contours,     cell_size=200, ) m2 In\u00a0[\u00a0]: Copied! <pre>m3 = DeckGLMap(center=[-122.35, 37.8], zoom=11)\nm3.add_basemap(\"CartoDB.DarkMatter\")\nm3.add_contour_layer(\n    data=points,\n    name=\"contour-weighted\",\n    get_position=\"coordinates\",\n    get_weight=\"weight\",\n    contours=detailed_contours,\n    cell_size=200,\n    aggregation=\"SUM\",\n)\nm3\n</pre> m3 = DeckGLMap(center=[-122.35, 37.8], zoom=11) m3.add_basemap(\"CartoDB.DarkMatter\") m3.add_contour_layer(     data=points,     name=\"contour-weighted\",     get_position=\"coordinates\",     get_weight=\"weight\",     contours=detailed_contours,     cell_size=200,     aggregation=\"SUM\", ) m3 In\u00a0[\u00a0]: Copied! <pre># Blue contours for comparison\nblue_contours = [\n    {\"threshold\": 1, \"color\": [200, 220, 255], \"strokeWidth\": 1},\n    {\"threshold\": 5, \"color\": [150, 180, 255], \"strokeWidth\": 1},\n    {\"threshold\": 10, \"color\": [100, 140, 255], \"strokeWidth\": 2},\n    {\"threshold\": 20, \"color\": [50, 100, 255], \"strokeWidth\": 2},\n    {\"threshold\": 40, \"color\": [0, 60, 200], \"strokeWidth\": 3},\n]\n\nm4 = DeckGLMap(center=[-122.35, 37.8], zoom=11)\nm4.add_basemap(\"CartoDB.DarkMatter\")\n\nm4.add_contour_layer(\n    data=points,\n    name=\"contour-heat\",\n    get_position=\"coordinates\",\n    get_weight=\"weight\",\n    contours=detailed_contours,\n    cell_size=200,\n)\n\nm4.add_contour_layer(\n    data=points,\n    name=\"contour-cool\",\n    get_position=\"coordinates\",\n    get_weight=\"weight\",\n    contours=blue_contours,\n    cell_size=300,\n    visible=False,\n)\n\nm4.add_layer_control()\nm4\n</pre> # Blue contours for comparison blue_contours = [     {\"threshold\": 1, \"color\": [200, 220, 255], \"strokeWidth\": 1},     {\"threshold\": 5, \"color\": [150, 180, 255], \"strokeWidth\": 1},     {\"threshold\": 10, \"color\": [100, 140, 255], \"strokeWidth\": 2},     {\"threshold\": 20, \"color\": [50, 100, 255], \"strokeWidth\": 2},     {\"threshold\": 40, \"color\": [0, 60, 200], \"strokeWidth\": 3}, ]  m4 = DeckGLMap(center=[-122.35, 37.8], zoom=11) m4.add_basemap(\"CartoDB.DarkMatter\")  m4.add_contour_layer(     data=points,     name=\"contour-heat\",     get_position=\"coordinates\",     get_weight=\"weight\",     contours=detailed_contours,     cell_size=200, )  m4.add_contour_layer(     data=points,     name=\"contour-cool\",     get_position=\"coordinates\",     get_weight=\"weight\",     contours=blue_contours,     cell_size=300,     visible=False, )  m4.add_layer_control() m4 In\u00a0[\u00a0]: Copied! <pre>m5 = DeckGLMap(center=[-122.35, 37.8], zoom=11)\nm5.add_basemap(\"CartoDB.DarkMatter\")\n\nm5.add_deckgl_layer(\n    layer_type=\"ContourLayer\",\n    data=points,\n    name=\"contour-generic\",\n    getPosition=\"coordinates\",\n    getWeight=\"weight\",\n    contours=detailed_contours,\n    cellSize=200,\n    aggregation=\"SUM\",\n    pickable=True,\n)\nm5\n</pre> m5 = DeckGLMap(center=[-122.35, 37.8], zoom=11) m5.add_basemap(\"CartoDB.DarkMatter\")  m5.add_deckgl_layer(     layer_type=\"ContourLayer\",     data=points,     name=\"contour-generic\",     getPosition=\"coordinates\",     getWeight=\"weight\",     contours=detailed_contours,     cellSize=200,     aggregation=\"SUM\",     pickable=True, ) m5 In\u00a0[\u00a0]: Copied! <pre>m2.to_html(\"contour_layer_example.html\")\n</pre> m2.to_html(\"contour_layer_example.html\")"},{"location":"deckgl/contour_layer/#contour-layer-example","title":"Contour Layer Example\u00b6","text":"<p>This notebook demonstrates the DeckGL ContourLayer for visualizing density isolines from point data.</p>"},{"location":"deckgl/contour_layer/#basic-contour-layer","title":"Basic Contour Layer\u00b6","text":""},{"location":"deckgl/contour_layer/#contour-with-custom-thresholds-and-colors","title":"Contour with Custom Thresholds and Colors\u00b6","text":""},{"location":"deckgl/contour_layer/#contour-with-weighted-data","title":"Contour with Weighted Data\u00b6","text":""},{"location":"deckgl/contour_layer/#contour-layer-with-layer-control","title":"Contour Layer with Layer Control\u00b6","text":""},{"location":"deckgl/contour_layer/#using-the-generic-add_deckgl_layer-method","title":"Using the Generic add_deckgl_layer Method\u00b6","text":""},{"location":"deckgl/contour_layer/#export-to-html","title":"Export to HTML\u00b6","text":""},{"location":"deckgl/deckgl/","title":"Deckgl","text":"In\u00a0[\u00a0]: Copied! <pre># %pip install -U anymap-ts\n</pre> # %pip install -U anymap-ts In\u00a0[\u00a0]: Copied! <pre>from anymap_ts import DeckGLMap\n\n# Create a DeckGL map\nm = DeckGLMap(center=[-122.4, 37.8], zoom=10)\nm.add_basemap(\"CartoDB.DarkMatter\")\nm\n</pre> from anymap_ts import DeckGLMap  # Create a DeckGL map m = DeckGLMap(center=[-122.4, 37.8], zoom=10) m.add_basemap(\"CartoDB.DarkMatter\") m In\u00a0[\u00a0]: Copied! <pre># Generate sample point data\nimport random\n\npoints = [\n    {\n        \"coordinates\": [\n            -122.4 + random.uniform(-0.2, 0.2),\n            37.8 + random.uniform(-0.2, 0.2),\n        ],\n        \"value\": random.randint(1, 100),\n    }\n    for _ in range(1000)\n]\n\n# Add scatterplot layer\nm.add_scatterplot_layer(\n    data=points, name=\"scatterplot\", get_radius=100, get_fill_color=[255, 140, 0, 200]\n)\n</pre> # Generate sample point data import random  points = [     {         \"coordinates\": [             -122.4 + random.uniform(-0.2, 0.2),             37.8 + random.uniform(-0.2, 0.2),         ],         \"value\": random.randint(1, 100),     }     for _ in range(1000) ]  # Add scatterplot layer m.add_scatterplot_layer(     data=points, name=\"scatterplot\", get_radius=100, get_fill_color=[255, 140, 0, 200] ) In\u00a0[\u00a0]: Copied! <pre># Add hexagon aggregation layer\nm.add_hexagon_layer(\n    data=points, name=\"hexagons\", radius=500, elevation_scale=10, extruded=True\n)\n</pre> # Add hexagon aggregation layer m.add_hexagon_layer(     data=points, name=\"hexagons\", radius=500, elevation_scale=10, extruded=True ) In\u00a0[\u00a0]: Copied! <pre># Add heatmap layer\nm2 = DeckGLMap(center=[-122.4, 37.8], zoom=11)\nm2.add_basemap(\"CartoDB.DarkMatter\")\nm2.add_heatmap_layer(data=points, name=\"heatmap\", radius_pixels=50, intensity=1)\nm2\n</pre> # Add heatmap layer m2 = DeckGLMap(center=[-122.4, 37.8], zoom=11) m2.add_basemap(\"CartoDB.DarkMatter\") m2.add_heatmap_layer(data=points, name=\"heatmap\", radius_pixels=50, intensity=1) m2 In\u00a0[\u00a0]: Copied! <pre># Add arc layer for connections\narcs = [\n    {\"source\": [-122.4194, 37.7749], \"target\": [-122.2712, 37.8044]},\n    {\"source\": [-122.4194, 37.7749], \"target\": [-122.0308, 37.3382]},\n    {\"source\": [-122.2712, 37.8044], \"target\": [-121.8853, 37.3387]},\n]\n\nm3 = DeckGLMap(center=[-122.2, 37.6], zoom=9)\nm3.add_basemap(\"CartoDB.DarkMatter\")\nm3.add_arc_layer(\n    data=arcs,\n    name=\"connections\",\n    get_source_color=[0, 128, 255],\n    get_target_color=[255, 0, 128],\n)\nm3\n</pre> # Add arc layer for connections arcs = [     {\"source\": [-122.4194, 37.7749], \"target\": [-122.2712, 37.8044]},     {\"source\": [-122.4194, 37.7749], \"target\": [-122.0308, 37.3382]},     {\"source\": [-122.2712, 37.8044], \"target\": [-121.8853, 37.3387]}, ]  m3 = DeckGLMap(center=[-122.2, 37.6], zoom=9) m3.add_basemap(\"CartoDB.DarkMatter\") m3.add_arc_layer(     data=arcs,     name=\"connections\",     get_source_color=[0, 128, 255],     get_target_color=[255, 0, 128], ) m3 In\u00a0[\u00a0]: Copied! <pre># Export to HTML\nm.to_html(\"deckgl_example.html\")\n</pre> # Export to HTML m.to_html(\"deckgl_example.html\")"},{"location":"deckgl/deckgl/#deckgl-example","title":"DeckGL Example\u00b6","text":"<p>This notebook demonstrates the DeckGL integration in anymap-ts.</p> <p>DeckGL provides GPU-accelerated visualization layers on top of MapLibre GL JS.</p>"},{"location":"deckgl/geohash_layer/","title":"Geohash layer","text":"In\u00a0[\u00a0]: Copied! <pre># %pip install -U anymap-ts\n</pre> # %pip install -U anymap-ts In\u00a0[\u00a0]: Copied! <pre>from anymap_ts import DeckGLMap\n</pre> from anymap_ts import DeckGLMap In\u00a0[\u00a0]: Copied! <pre># Sample geohash data (around San Francisco area, precision 5)\ngeohash_data = [\n    {\"geohash\": \"9q8yy\", \"value\": 150},\n    {\"geohash\": \"9q8yz\", \"value\": 200},\n    {\"geohash\": \"9q8yv\", \"value\": 180},\n    {\"geohash\": \"9q8yw\", \"value\": 250},\n    {\"geohash\": \"9q8yx\", \"value\": 300},\n    {\"geohash\": \"9q8yu\", \"value\": 220},\n    {\"geohash\": \"9q8yt\", \"value\": 190},\n    {\"geohash\": \"9q8ys\", \"value\": 280},\n    {\"geohash\": \"9q8yr\", \"value\": 170},\n    {\"geohash\": \"9q8yq\", \"value\": 230},\n]\n</pre> # Sample geohash data (around San Francisco area, precision 5) geohash_data = [     {\"geohash\": \"9q8yy\", \"value\": 150},     {\"geohash\": \"9q8yz\", \"value\": 200},     {\"geohash\": \"9q8yv\", \"value\": 180},     {\"geohash\": \"9q8yw\", \"value\": 250},     {\"geohash\": \"9q8yx\", \"value\": 300},     {\"geohash\": \"9q8yu\", \"value\": 220},     {\"geohash\": \"9q8yt\", \"value\": 190},     {\"geohash\": \"9q8ys\", \"value\": 280},     {\"geohash\": \"9q8yr\", \"value\": 170},     {\"geohash\": \"9q8yq\", \"value\": 230}, ] In\u00a0[\u00a0]: Copied! <pre>m = DeckGLMap(center=[-122.4, 37.75], zoom=10, pitch=45)\nm.add_basemap(\"CartoDB.DarkMatter\")\n\nm.add_geohash_layer(\n    data=geohash_data,\n    get_geohash=\"geohash\",\n    get_fill_color=[100, 200, 100, 180],\n    get_elevation=\"value\",\n    extruded=True,\n    elevation_scale=100,\n    pickable=True,\n)\nm\n</pre> m = DeckGLMap(center=[-122.4, 37.75], zoom=10, pitch=45) m.add_basemap(\"CartoDB.DarkMatter\")  m.add_geohash_layer(     data=geohash_data,     get_geohash=\"geohash\",     get_fill_color=[100, 200, 100, 180],     get_elevation=\"value\",     extruded=True,     elevation_scale=100,     pickable=True, ) m In\u00a0[\u00a0]: Copied! <pre>m.to_html(\"geohash_layer_example.html\")\n</pre> m.to_html(\"geohash_layer_example.html\")"},{"location":"deckgl/geohash_layer/#geohash-layer-example","title":"Geohash Layer Example\u00b6","text":"<p>Geohash spatial indexing visualization using deck.gl GeohashLayer.</p>"},{"location":"deckgl/geohash_layer/#define-geohash-data","title":"Define geohash data\u00b6","text":""},{"location":"deckgl/geohash_layer/#create-map-with-geohash-layer","title":"Create map with geohash layer\u00b6","text":""},{"location":"deckgl/geohash_layer/#export-to-html","title":"Export to HTML\u00b6","text":""},{"location":"deckgl/geojson_layer/","title":"Geojson layer","text":"In\u00a0[\u00a0]: Copied! <pre># %pip install -U anymap-ts\n</pre> # %pip install -U anymap-ts In\u00a0[\u00a0]: Copied! <pre>from anymap_ts import DeckGLMap\n\n# GeoJSON FeatureCollection with mixed geometry types\ngeojson_data = {\n    \"type\": \"FeatureCollection\",\n    \"features\": [\n        # Points - Landmarks\n        {\n            \"type\": \"Feature\",\n            \"geometry\": {\"type\": \"Point\", \"coordinates\": [-122.4194, 37.7749]},\n            \"properties\": {\"name\": \"San Francisco City Hall\", \"type\": \"landmark\"},\n        },\n        {\n            \"type\": \"Feature\",\n            \"geometry\": {\"type\": \"Point\", \"coordinates\": [-122.4862, 37.8199]},\n            \"properties\": {\"name\": \"Golden Gate Bridge\", \"type\": \"landmark\"},\n        },\n        # LineStrings - Routes\n        {\n            \"type\": \"Feature\",\n            \"geometry\": {\n                \"type\": \"LineString\",\n                \"coordinates\": [\n                    [-122.4194, 37.7749],\n                    [-122.4100, 37.7855],\n                    [-122.3894, 37.7866],\n                ],\n            },\n            \"properties\": {\"name\": \"Market Street Route\", \"type\": \"route\"},\n        },\n        # Polygons - Neighborhoods\n        {\n            \"type\": \"Feature\",\n            \"geometry\": {\n                \"type\": \"Polygon\",\n                \"coordinates\": [\n                    [\n                        [-122.415, 37.795],\n                        [-122.395, 37.795],\n                        [-122.395, 37.780],\n                        [-122.415, 37.780],\n                        [-122.415, 37.795],\n                    ]\n                ],\n            },\n            \"properties\": {\n                \"name\": \"Downtown\",\n                \"type\": \"neighborhood\",\n                \"elevation\": 500,\n            },\n        },\n    ],\n}\n\nm = DeckGLMap(center=[-122.42, 37.79], zoom=12)\nm.add_basemap(\"CartoDB.DarkMatter\")\nm.add_geojson_layer(\n    data=geojson_data,\n    name=\"geojson-basic\",\n    get_fill_color=[100, 150, 255, 150],\n    get_line_color=[255, 255, 255, 200],\n    point_radius_min_pixels=5,\n)\nm\n</pre> from anymap_ts import DeckGLMap  # GeoJSON FeatureCollection with mixed geometry types geojson_data = {     \"type\": \"FeatureCollection\",     \"features\": [         # Points - Landmarks         {             \"type\": \"Feature\",             \"geometry\": {\"type\": \"Point\", \"coordinates\": [-122.4194, 37.7749]},             \"properties\": {\"name\": \"San Francisco City Hall\", \"type\": \"landmark\"},         },         {             \"type\": \"Feature\",             \"geometry\": {\"type\": \"Point\", \"coordinates\": [-122.4862, 37.8199]},             \"properties\": {\"name\": \"Golden Gate Bridge\", \"type\": \"landmark\"},         },         # LineStrings - Routes         {             \"type\": \"Feature\",             \"geometry\": {                 \"type\": \"LineString\",                 \"coordinates\": [                     [-122.4194, 37.7749],                     [-122.4100, 37.7855],                     [-122.3894, 37.7866],                 ],             },             \"properties\": {\"name\": \"Market Street Route\", \"type\": \"route\"},         },         # Polygons - Neighborhoods         {             \"type\": \"Feature\",             \"geometry\": {                 \"type\": \"Polygon\",                 \"coordinates\": [                     [                         [-122.415, 37.795],                         [-122.395, 37.795],                         [-122.395, 37.780],                         [-122.415, 37.780],                         [-122.415, 37.795],                     ]                 ],             },             \"properties\": {                 \"name\": \"Downtown\",                 \"type\": \"neighborhood\",                 \"elevation\": 500,             },         },     ], }  m = DeckGLMap(center=[-122.42, 37.79], zoom=12) m.add_basemap(\"CartoDB.DarkMatter\") m.add_geojson_layer(     data=geojson_data,     name=\"geojson-basic\",     get_fill_color=[100, 150, 255, 150],     get_line_color=[255, 255, 255, 200],     point_radius_min_pixels=5, ) m In\u00a0[\u00a0]: Copied! <pre># More detailed GeoJSON with elevation data\ngeojson_3d = {\n    \"type\": \"FeatureCollection\",\n    \"features\": [\n        {\n            \"type\": \"Feature\",\n            \"geometry\": {\n                \"type\": \"Polygon\",\n                \"coordinates\": [\n                    [\n                        [-122.415, 37.795],\n                        [-122.395, 37.795],\n                        [-122.395, 37.780],\n                        [-122.415, 37.780],\n                        [-122.415, 37.795],\n                    ]\n                ],\n            },\n            \"properties\": {\"name\": \"Downtown\", \"elevation\": 500},\n        },\n        {\n            \"type\": \"Feature\",\n            \"geometry\": {\n                \"type\": \"Polygon\",\n                \"coordinates\": [\n                    [\n                        [-122.430, 37.780],\n                        [-122.415, 37.780],\n                        [-122.415, 37.765],\n                        [-122.430, 37.765],\n                        [-122.430, 37.780],\n                    ]\n                ],\n            },\n            \"properties\": {\"name\": \"Mission\", \"elevation\": 400},\n        },\n        {\n            \"type\": \"Feature\",\n            \"geometry\": {\n                \"type\": \"Polygon\",\n                \"coordinates\": [\n                    [\n                        [-122.420, 37.810],\n                        [-122.405, 37.810],\n                        [-122.405, 37.798],\n                        [-122.420, 37.798],\n                        [-122.420, 37.810],\n                    ]\n                ],\n            },\n            \"properties\": {\"name\": \"North Beach\", \"elevation\": 300},\n        },\n    ],\n}\n\nm2 = DeckGLMap(center=[-122.42, 37.79], zoom=12, pitch=45, bearing=-17)\nm2.add_basemap(\"CartoDB.DarkMatter\")\nm2.add_geojson_layer(\n    data=geojson_3d,\n    name=\"geojson-3d\",\n    get_fill_color=[255, 100, 100, 180],\n    extruded=True,\n    get_elevation=\"elevation\",\n)\nm2\n</pre> # More detailed GeoJSON with elevation data geojson_3d = {     \"type\": \"FeatureCollection\",     \"features\": [         {             \"type\": \"Feature\",             \"geometry\": {                 \"type\": \"Polygon\",                 \"coordinates\": [                     [                         [-122.415, 37.795],                         [-122.395, 37.795],                         [-122.395, 37.780],                         [-122.415, 37.780],                         [-122.415, 37.795],                     ]                 ],             },             \"properties\": {\"name\": \"Downtown\", \"elevation\": 500},         },         {             \"type\": \"Feature\",             \"geometry\": {                 \"type\": \"Polygon\",                 \"coordinates\": [                     [                         [-122.430, 37.780],                         [-122.415, 37.780],                         [-122.415, 37.765],                         [-122.430, 37.765],                         [-122.430, 37.780],                     ]                 ],             },             \"properties\": {\"name\": \"Mission\", \"elevation\": 400},         },         {             \"type\": \"Feature\",             \"geometry\": {                 \"type\": \"Polygon\",                 \"coordinates\": [                     [                         [-122.420, 37.810],                         [-122.405, 37.810],                         [-122.405, 37.798],                         [-122.420, 37.798],                         [-122.420, 37.810],                     ]                 ],             },             \"properties\": {\"name\": \"North Beach\", \"elevation\": 300},         },     ], }  m2 = DeckGLMap(center=[-122.42, 37.79], zoom=12, pitch=45, bearing=-17) m2.add_basemap(\"CartoDB.DarkMatter\") m2.add_geojson_layer(     data=geojson_3d,     name=\"geojson-3d\",     get_fill_color=[255, 100, 100, 180],     extruded=True,     get_elevation=\"elevation\", ) m2 In\u00a0[\u00a0]: Copied! <pre># Separate GeoJSON for points and polygons\npoints_geojson = {\n    \"type\": \"FeatureCollection\",\n    \"features\": [\n        {\n            \"type\": \"Feature\",\n            \"geometry\": {\"type\": \"Point\", \"coordinates\": [-122.4194, 37.7749]},\n            \"properties\": {\"name\": \"City Hall\"},\n        },\n        {\n            \"type\": \"Feature\",\n            \"geometry\": {\"type\": \"Point\", \"coordinates\": [-122.4862, 37.8199]},\n            \"properties\": {\"name\": \"Golden Gate\"},\n        },\n        {\n            \"type\": \"Feature\",\n            \"geometry\": {\"type\": \"Point\", \"coordinates\": [-122.4534, 37.8083]},\n            \"properties\": {\"name\": \"Alcatraz\"},\n        },\n    ],\n}\n\nlines_geojson = {\n    \"type\": \"FeatureCollection\",\n    \"features\": [\n        {\n            \"type\": \"Feature\",\n            \"geometry\": {\n                \"type\": \"LineString\",\n                \"coordinates\": [\n                    [-122.4194, 37.7749],\n                    [-122.4100, 37.7855],\n                    [-122.3894, 37.7866],\n                ],\n            },\n            \"properties\": {\"name\": \"Route 1\"},\n        },\n        {\n            \"type\": \"Feature\",\n            \"geometry\": {\n                \"type\": \"LineString\",\n                \"coordinates\": [\n                    [-122.4862, 37.8199],\n                    [-122.4700, 37.8080],\n                    [-122.4534, 37.8083],\n                ],\n            },\n            \"properties\": {\"name\": \"Route 2\"},\n        },\n    ],\n}\n\nm3 = DeckGLMap(center=[-122.42, 37.79], zoom=12)\nm3.add_basemap(\"CartoDB.DarkMatter\")\n\nm3.add_geojson_layer(\n    data=points_geojson,\n    name=\"geojson-points\",\n    get_fill_color=[255, 100, 100, 255],\n    point_radius_min_pixels=8,\n)\n\nm3.add_geojson_layer(\n    data=lines_geojson,\n    name=\"geojson-lines\",\n    get_line_color=[100, 200, 255, 255],\n    line_width_min_pixels=3,\n)\n\nm3.add_geojson_layer(\n    data=geojson_3d,\n    name=\"geojson-polygons\",\n    get_fill_color=[100, 255, 150, 150],\n)\n\nm3.add_layer_control()\nm3\n</pre> # Separate GeoJSON for points and polygons points_geojson = {     \"type\": \"FeatureCollection\",     \"features\": [         {             \"type\": \"Feature\",             \"geometry\": {\"type\": \"Point\", \"coordinates\": [-122.4194, 37.7749]},             \"properties\": {\"name\": \"City Hall\"},         },         {             \"type\": \"Feature\",             \"geometry\": {\"type\": \"Point\", \"coordinates\": [-122.4862, 37.8199]},             \"properties\": {\"name\": \"Golden Gate\"},         },         {             \"type\": \"Feature\",             \"geometry\": {\"type\": \"Point\", \"coordinates\": [-122.4534, 37.8083]},             \"properties\": {\"name\": \"Alcatraz\"},         },     ], }  lines_geojson = {     \"type\": \"FeatureCollection\",     \"features\": [         {             \"type\": \"Feature\",             \"geometry\": {                 \"type\": \"LineString\",                 \"coordinates\": [                     [-122.4194, 37.7749],                     [-122.4100, 37.7855],                     [-122.3894, 37.7866],                 ],             },             \"properties\": {\"name\": \"Route 1\"},         },         {             \"type\": \"Feature\",             \"geometry\": {                 \"type\": \"LineString\",                 \"coordinates\": [                     [-122.4862, 37.8199],                     [-122.4700, 37.8080],                     [-122.4534, 37.8083],                 ],             },             \"properties\": {\"name\": \"Route 2\"},         },     ], }  m3 = DeckGLMap(center=[-122.42, 37.79], zoom=12) m3.add_basemap(\"CartoDB.DarkMatter\")  m3.add_geojson_layer(     data=points_geojson,     name=\"geojson-points\",     get_fill_color=[255, 100, 100, 255],     point_radius_min_pixels=8, )  m3.add_geojson_layer(     data=lines_geojson,     name=\"geojson-lines\",     get_line_color=[100, 200, 255, 255],     line_width_min_pixels=3, )  m3.add_geojson_layer(     data=geojson_3d,     name=\"geojson-polygons\",     get_fill_color=[100, 255, 150, 150], )  m3.add_layer_control() m3 In\u00a0[\u00a0]: Copied! <pre>m4 = DeckGLMap(center=[-122.42, 37.79], zoom=12, pitch=30)\nm4.add_basemap(\"CartoDB.DarkMatter\")\n\nm4.add_deckgl_layer(\n    layer_type=\"GeoJsonLayer\",\n    data=geojson_data,\n    name=\"geojson-generic\",\n    getFillColor=[138, 43, 226, 180],\n    getLineColor=[255, 255, 255, 200],\n    pointRadiusMinPixels=5,\n    lineWidthMinPixels=2,\n    stroked=True,\n    filled=True,\n    pickable=True,\n)\nm4\n</pre> m4 = DeckGLMap(center=[-122.42, 37.79], zoom=12, pitch=30) m4.add_basemap(\"CartoDB.DarkMatter\")  m4.add_deckgl_layer(     layer_type=\"GeoJsonLayer\",     data=geojson_data,     name=\"geojson-generic\",     getFillColor=[138, 43, 226, 180],     getLineColor=[255, 255, 255, 200],     pointRadiusMinPixels=5,     lineWidthMinPixels=2,     stroked=True,     filled=True,     pickable=True, ) m4 In\u00a0[\u00a0]: Copied! <pre>m3.to_html(\"geojson_layer_example.html\")\n</pre> m3.to_html(\"geojson_layer_example.html\")"},{"location":"deckgl/geojson_layer/#geojson-layer-example","title":"GeoJSON Layer Example\u00b6","text":"<p>This notebook demonstrates the DeckGL GeoJsonLayer for rendering GeoJSON features with mixed geometry types (Points, LineStrings, Polygons).</p>"},{"location":"deckgl/geojson_layer/#basic-geojson-layer","title":"Basic GeoJSON Layer\u00b6","text":""},{"location":"deckgl/geojson_layer/#geojson-with-3d-extrusion","title":"GeoJSON with 3D Extrusion\u00b6","text":""},{"location":"deckgl/geojson_layer/#multiple-geojson-layers-with-layer-control","title":"Multiple GeoJSON Layers with Layer Control\u00b6","text":""},{"location":"deckgl/geojson_layer/#using-the-generic-add_deckgl_layer-method","title":"Using the Generic add_deckgl_layer Method\u00b6","text":""},{"location":"deckgl/geojson_layer/#export-to-html","title":"Export to HTML\u00b6","text":""},{"location":"deckgl/great_circle_layer/","title":"Great circle layer","text":"In\u00a0[\u00a0]: Copied! <pre># %pip install -U anymap-ts\n</pre> # %pip install -U anymap-ts In\u00a0[\u00a0]: Copied! <pre>from anymap_ts import DeckGLMap\n</pre> from anymap_ts import DeckGLMap In\u00a0[\u00a0]: Copied! <pre># Flight routes from San Francisco to major cities\nflight_routes = [\n    {\"source\": [-122.4, 37.8], \"target\": [-0.1, 51.5], \"name\": \"SFO -&gt; London\"},\n    {\"source\": [-122.4, 37.8], \"target\": [139.7, 35.7], \"name\": \"SFO -&gt; Tokyo\"},\n    {\"source\": [-122.4, 37.8], \"target\": [2.3, 48.9], \"name\": \"SFO -&gt; Paris\"},\n    {\"source\": [-122.4, 37.8], \"target\": [114.2, 22.3], \"name\": \"SFO -&gt; Hong Kong\"},\n    {\"source\": [-122.4, 37.8], \"target\": [151.2, -33.9], \"name\": \"SFO -&gt; Sydney\"},\n    {\"source\": [-122.4, 37.8], \"target\": [-43.2, -22.9], \"name\": \"SFO -&gt; Rio\"},\n    {\"source\": [-122.4, 37.8], \"target\": [37.6, 55.8], \"name\": \"SFO -&gt; Moscow\"},\n    {\"source\": [-122.4, 37.8], \"target\": [28.0, -26.2], \"name\": \"SFO -&gt; Johannesburg\"},\n]\n</pre> # Flight routes from San Francisco to major cities flight_routes = [     {\"source\": [-122.4, 37.8], \"target\": [-0.1, 51.5], \"name\": \"SFO -&gt; London\"},     {\"source\": [-122.4, 37.8], \"target\": [139.7, 35.7], \"name\": \"SFO -&gt; Tokyo\"},     {\"source\": [-122.4, 37.8], \"target\": [2.3, 48.9], \"name\": \"SFO -&gt; Paris\"},     {\"source\": [-122.4, 37.8], \"target\": [114.2, 22.3], \"name\": \"SFO -&gt; Hong Kong\"},     {\"source\": [-122.4, 37.8], \"target\": [151.2, -33.9], \"name\": \"SFO -&gt; Sydney\"},     {\"source\": [-122.4, 37.8], \"target\": [-43.2, -22.9], \"name\": \"SFO -&gt; Rio\"},     {\"source\": [-122.4, 37.8], \"target\": [37.6, 55.8], \"name\": \"SFO -&gt; Moscow\"},     {\"source\": [-122.4, 37.8], \"target\": [28.0, -26.2], \"name\": \"SFO -&gt; Johannesburg\"}, ] In\u00a0[\u00a0]: Copied! <pre>m = DeckGLMap(center=[-30, 30], zoom=1.5)\nm.add_basemap(\"CartoDB.DarkMatter\")\n\nm.add_great_circle_layer(\n    data=flight_routes,\n    get_source_position=\"source\",\n    get_target_position=\"target\",\n    get_source_color=[0, 200, 255, 255],\n    get_target_color=[255, 100, 100, 255],\n    get_width=2,\n    width_min_pixels=2,\n    opacity=0.8,\n)\nm\n</pre> m = DeckGLMap(center=[-30, 30], zoom=1.5) m.add_basemap(\"CartoDB.DarkMatter\")  m.add_great_circle_layer(     data=flight_routes,     get_source_position=\"source\",     get_target_position=\"target\",     get_source_color=[0, 200, 255, 255],     get_target_color=[255, 100, 100, 255],     get_width=2,     width_min_pixels=2,     opacity=0.8, ) m In\u00a0[\u00a0]: Copied! <pre>m.to_html(\"great_circle_layer_example.html\")\n</pre> m.to_html(\"great_circle_layer_example.html\")"},{"location":"deckgl/great_circle_layer/#great-circle-layer-example","title":"Great Circle Layer Example\u00b6","text":"<p>Geodesic arcs connecting locations using deck.gl GreatCircleLayer.</p>"},{"location":"deckgl/great_circle_layer/#define-flight-routes","title":"Define flight routes\u00b6","text":""},{"location":"deckgl/great_circle_layer/#create-map-with-great-circle-layer","title":"Create map with great circle layer\u00b6","text":""},{"location":"deckgl/great_circle_layer/#export-to-html","title":"Export to HTML\u00b6","text":""},{"location":"deckgl/gridcell_layer/","title":"Gridcell layer","text":"In\u00a0[\u00a0]: Copied! <pre># %pip install -U anymap-ts\n</pre> # %pip install -U anymap-ts In\u00a0[\u00a0]: Copied! <pre>import random\nfrom anymap_ts import DeckGLMap\n</pre> import random from anymap_ts import DeckGLMap In\u00a0[\u00a0]: Copied! <pre># Generate a grid of cells\ngrid_cells = []\ncenter_lng, center_lat = -122.4, 37.8\ngrid_size = 10\n\nfor i in range(grid_size):\n    for j in range(grid_size):\n        grid_cells.append(\n            {\n                \"position\": [\n                    center_lng + (i - grid_size / 2) * 0.003,\n                    center_lat + (j - grid_size / 2) * 0.003,\n                ],\n                \"elevation\": random.randint(100, 1000),\n                \"color\": [\n                    random.randint(100, 255),\n                    random.randint(100, 255),\n                    255,\n                    200,\n                ],\n            }\n        )\n</pre> # Generate a grid of cells grid_cells = [] center_lng, center_lat = -122.4, 37.8 grid_size = 10  for i in range(grid_size):     for j in range(grid_size):         grid_cells.append(             {                 \"position\": [                     center_lng + (i - grid_size / 2) * 0.003,                     center_lat + (j - grid_size / 2) * 0.003,                 ],                 \"elevation\": random.randint(100, 1000),                 \"color\": [                     random.randint(100, 255),                     random.randint(100, 255),                     255,                     200,                 ],             }         ) In\u00a0[\u00a0]: Copied! <pre>m = DeckGLMap(center=[-122.4, 37.8], zoom=12, pitch=45, bearing=-17)\nm.add_basemap(\"CartoDB.DarkMatter\")\n\nm.add_grid_cell_layer(\n    data=grid_cells,\n    get_position=\"position\",\n    get_elevation=\"elevation\",\n    get_fill_color=\"color\",\n    cell_size=200,\n    extruded=True,\n    elevation_scale=1,\n    pickable=True,\n)\nm\n</pre> m = DeckGLMap(center=[-122.4, 37.8], zoom=12, pitch=45, bearing=-17) m.add_basemap(\"CartoDB.DarkMatter\")  m.add_grid_cell_layer(     data=grid_cells,     get_position=\"position\",     get_elevation=\"elevation\",     get_fill_color=\"color\",     cell_size=200,     extruded=True,     elevation_scale=1,     pickable=True, ) m In\u00a0[\u00a0]: Copied! <pre>m.to_html(\"gridcell_layer_example.html\")\n</pre> m.to_html(\"gridcell_layer_example.html\")"},{"location":"deckgl/gridcell_layer/#grid-cell-layer-example","title":"Grid Cell Layer Example\u00b6","text":"<p>Regular grid cell visualization using deck.gl GridCellLayer.</p>"},{"location":"deckgl/gridcell_layer/#generate-grid-cell-data","title":"Generate grid cell data\u00b6","text":""},{"location":"deckgl/gridcell_layer/#create-map-with-grid-cell-layer","title":"Create map with grid cell layer\u00b6","text":""},{"location":"deckgl/gridcell_layer/#export-to-html","title":"Export to HTML\u00b6","text":""},{"location":"deckgl/h3_cluster_layer/","title":"H3 cluster layer","text":"In\u00a0[\u00a0]: Copied! <pre># %pip install -U anymap-ts\n</pre> # %pip install -U anymap-ts In\u00a0[\u00a0]: Copied! <pre>from anymap_ts import DeckGLMap\n</pre> from anymap_ts import DeckGLMap In\u00a0[\u00a0]: Copied! <pre># Sample H3 cluster data (groups of H3 hexagons)\nh3_cluster_data = [\n    {\n        \"hexIds\": [\"852830827ffffff\", \"85283082fffffff\", \"852830877ffffff\"],\n        \"value\": 150,\n    },\n    {\n        \"hexIds\": [\"8528308a7ffffff\", \"8528308afffffff\", \"8528308b7ffffff\"],\n        \"value\": 200,\n    },\n    {\n        \"hexIds\": [\"852830957ffffff\", \"85283095fffffff\", \"852830967ffffff\"],\n        \"value\": 250,\n    },\n    {\n        \"hexIds\": [\"8528309c7ffffff\", \"8528309cfffffff\", \"8528309d7ffffff\"],\n        \"value\": 180,\n    },\n]\n</pre> # Sample H3 cluster data (groups of H3 hexagons) h3_cluster_data = [     {         \"hexIds\": [\"852830827ffffff\", \"85283082fffffff\", \"852830877ffffff\"],         \"value\": 150,     },     {         \"hexIds\": [\"8528308a7ffffff\", \"8528308afffffff\", \"8528308b7ffffff\"],         \"value\": 200,     },     {         \"hexIds\": [\"852830957ffffff\", \"85283095fffffff\", \"852830967ffffff\"],         \"value\": 250,     },     {         \"hexIds\": [\"8528309c7ffffff\", \"8528309cfffffff\", \"8528309d7ffffff\"],         \"value\": 180,     }, ] In\u00a0[\u00a0]: Copied! <pre>m = DeckGLMap(center=[-122.4, 37.75], zoom=9, pitch=45)\nm.add_basemap(\"CartoDB.DarkMatter\")\n\nm.add_h3_cluster_layer(\n    data=h3_cluster_data,\n    get_hexagons=\"hexIds\",\n    get_fill_color=[255, 100, 100, 180],\n    get_elevation=\"value\",\n    extruded=True,\n    elevation_scale=20,\n    pickable=True,\n)\nm\n</pre> m = DeckGLMap(center=[-122.4, 37.75], zoom=9, pitch=45) m.add_basemap(\"CartoDB.DarkMatter\")  m.add_h3_cluster_layer(     data=h3_cluster_data,     get_hexagons=\"hexIds\",     get_fill_color=[255, 100, 100, 180],     get_elevation=\"value\",     extruded=True,     elevation_scale=20,     pickable=True, ) m In\u00a0[\u00a0]: Copied! <pre>m.to_html(\"h3_cluster_layer_example.html\")\n</pre> m.to_html(\"h3_cluster_layer_example.html\")"},{"location":"deckgl/h3_cluster_layer/#h3-cluster-layer-example","title":"H3 Cluster Layer Example\u00b6","text":"<p>H3 hexagon clustering visualization using deck.gl H3ClusterLayer.</p>"},{"location":"deckgl/h3_cluster_layer/#define-h3-cluster-data","title":"Define H3 cluster data\u00b6","text":""},{"location":"deckgl/h3_cluster_layer/#create-map-with-h3-cluster-layer","title":"Create map with H3 cluster layer\u00b6","text":""},{"location":"deckgl/h3_cluster_layer/#export-to-html","title":"Export to HTML\u00b6","text":""},{"location":"deckgl/h3_hexagon_layer/","title":"H3 hexagon layer","text":"In\u00a0[\u00a0]: Copied! <pre># %pip install -U anymap-ts\n</pre> # %pip install -U anymap-ts In\u00a0[\u00a0]: Copied! <pre>from anymap_ts import DeckGLMap\n</pre> from anymap_ts import DeckGLMap In\u00a0[\u00a0]: Copied! <pre># Sample H3 hexagon data around San Francisco (resolution 7)\nh3_data = [\n    {\"hexagon\": \"872830828ffffff\", \"value\": 100},\n    {\"hexagon\": \"87283082affffff\", \"value\": 200},\n    {\"hexagon\": \"87283082bffffff\", \"value\": 150},\n    {\"hexagon\": \"872830829ffffff\", \"value\": 300},\n    {\"hexagon\": \"87283095affffff\", \"value\": 250},\n    {\"hexagon\": \"87283095bffffff\", \"value\": 180},\n    {\"hexagon\": \"872830958ffffff\", \"value\": 220},\n    {\"hexagon\": \"872830959ffffff\", \"value\": 270},\n    {\"hexagon\": \"8728309caffffff\", \"value\": 190},\n    {\"hexagon\": \"8728309cbffffff\", \"value\": 240},\n    {\"hexagon\": \"8728309c8ffffff\", \"value\": 160},\n    {\"hexagon\": \"8728309c9ffffff\", \"value\": 310},\n]\n</pre> # Sample H3 hexagon data around San Francisco (resolution 7) h3_data = [     {\"hexagon\": \"872830828ffffff\", \"value\": 100},     {\"hexagon\": \"87283082affffff\", \"value\": 200},     {\"hexagon\": \"87283082bffffff\", \"value\": 150},     {\"hexagon\": \"872830829ffffff\", \"value\": 300},     {\"hexagon\": \"87283095affffff\", \"value\": 250},     {\"hexagon\": \"87283095bffffff\", \"value\": 180},     {\"hexagon\": \"872830958ffffff\", \"value\": 220},     {\"hexagon\": \"872830959ffffff\", \"value\": 270},     {\"hexagon\": \"8728309caffffff\", \"value\": 190},     {\"hexagon\": \"8728309cbffffff\", \"value\": 240},     {\"hexagon\": \"8728309c8ffffff\", \"value\": 160},     {\"hexagon\": \"8728309c9ffffff\", \"value\": 310}, ] In\u00a0[\u00a0]: Copied! <pre>m = DeckGLMap(center=[-122.4, 37.75], zoom=10, pitch=45)\nm.add_basemap(\"CartoDB.DarkMatter\")\n\nm.add_h3_hexagon_layer(\n    data=h3_data,\n    get_hexagon=\"hexagon\",\n    get_fill_color=[51, 136, 255, 128],\n    get_line_color=[255, 255, 255, 100],\n    get_elevation=\"value\",\n    extruded=True,\n    elevation_scale=20,\n    opacity=0.8,\n)\nm\n</pre> m = DeckGLMap(center=[-122.4, 37.75], zoom=10, pitch=45) m.add_basemap(\"CartoDB.DarkMatter\")  m.add_h3_hexagon_layer(     data=h3_data,     get_hexagon=\"hexagon\",     get_fill_color=[51, 136, 255, 128],     get_line_color=[255, 255, 255, 100],     get_elevation=\"value\",     extruded=True,     elevation_scale=20,     opacity=0.8, ) m In\u00a0[\u00a0]: Copied! <pre>m.to_html(\"h3_hexagon_layer_example.html\")\n</pre> m.to_html(\"h3_hexagon_layer_example.html\")"},{"location":"deckgl/h3_hexagon_layer/#h3-hexagon-layer-example","title":"H3 Hexagon Layer Example\u00b6","text":"<p>Visualize data using Uber's H3 spatial indexing system.</p>"},{"location":"deckgl/h3_hexagon_layer/#sample-h3-data","title":"Sample H3 data\u00b6","text":""},{"location":"deckgl/h3_hexagon_layer/#create-map-with-h3-hexagon-layer","title":"Create map with H3 hexagon layer\u00b6","text":""},{"location":"deckgl/h3_hexagon_layer/#export-to-html","title":"Export to HTML\u00b6","text":""},{"location":"deckgl/heatmap_layer/","title":"Heatmap layer","text":"In\u00a0[\u00a0]: Copied! <pre># %pip install -U anymap-ts\n</pre> # %pip install -U anymap-ts In\u00a0[\u00a0]: Copied! <pre>import random\nfrom anymap_ts import DeckGLMap\n\n# Generate random points around San Francisco\npoints = [\n    {\n        \"coordinates\": [\n            -122.4 + random.uniform(-0.3, 0.3),\n            37.8 + random.uniform(-0.3, 0.3),\n        ]\n    }\n    for _ in range(2000)\n]\n\nm = DeckGLMap(center=[-122.4, 37.8], zoom=11)\nm.add_basemap(\"CartoDB.DarkMatter\")\nm.add_heatmap_layer(\n    data=points,\n    name=\"heatmap-basic\",\n    get_position=\"coordinates\",\n    radius_pixels=50,\n    intensity=1,\n    threshold=0.05,\n    opacity=1,\n)\nm\n</pre> import random from anymap_ts import DeckGLMap  # Generate random points around San Francisco points = [     {         \"coordinates\": [             -122.4 + random.uniform(-0.3, 0.3),             37.8 + random.uniform(-0.3, 0.3),         ]     }     for _ in range(2000) ]  m = DeckGLMap(center=[-122.4, 37.8], zoom=11) m.add_basemap(\"CartoDB.DarkMatter\") m.add_heatmap_layer(     data=points,     name=\"heatmap-basic\",     get_position=\"coordinates\",     radius_pixels=50,     intensity=1,     threshold=0.05,     opacity=1, ) m In\u00a0[\u00a0]: Copied! <pre>custom_colors = [\n    [255, 255, 178, 25],\n    [254, 217, 118, 85],\n    [254, 178, 76, 127],\n    [253, 141, 60, 170],\n    [240, 59, 32, 212],\n    [189, 0, 38, 255],\n]\n\nm2 = DeckGLMap(center=[-122.4, 37.8], zoom=11)\nm2.add_basemap(\"CartoDB.DarkMatter\")\nm2.add_heatmap_layer(\n    data=points,\n    name=\"heatmap-custom\",\n    get_position=\"coordinates\",\n    radius_pixels=40,\n    intensity=1.2,\n    color_range=custom_colors,\n)\nm2\n</pre> custom_colors = [     [255, 255, 178, 25],     [254, 217, 118, 85],     [254, 178, 76, 127],     [253, 141, 60, 170],     [240, 59, 32, 212],     [189, 0, 38, 255], ]  m2 = DeckGLMap(center=[-122.4, 37.8], zoom=11) m2.add_basemap(\"CartoDB.DarkMatter\") m2.add_heatmap_layer(     data=points,     name=\"heatmap-custom\",     get_position=\"coordinates\",     radius_pixels=40,     intensity=1.2,     color_range=custom_colors, ) m2 In\u00a0[\u00a0]: Copied! <pre># Points with weight values\nweighted_points = [\n    {\n        \"coordinates\": [\n            -122.4 + random.uniform(-0.3, 0.3),\n            37.8 + random.uniform(-0.3, 0.3),\n        ],\n        \"weight\": random.random(),\n    }\n    for _ in range(2000)\n]\n\nm3 = DeckGLMap(center=[-122.4, 37.8], zoom=11)\nm3.add_basemap(\"CartoDB.DarkMatter\")\nm3.add_heatmap_layer(\n    data=weighted_points,\n    name=\"heatmap-weighted\",\n    get_position=\"coordinates\",\n    get_weight=\"weight\",\n    radius_pixels=35,\n    intensity=1,\n)\nm3\n</pre> # Points with weight values weighted_points = [     {         \"coordinates\": [             -122.4 + random.uniform(-0.3, 0.3),             37.8 + random.uniform(-0.3, 0.3),         ],         \"weight\": random.random(),     }     for _ in range(2000) ]  m3 = DeckGLMap(center=[-122.4, 37.8], zoom=11) m3.add_basemap(\"CartoDB.DarkMatter\") m3.add_heatmap_layer(     data=weighted_points,     name=\"heatmap-weighted\",     get_position=\"coordinates\",     get_weight=\"weight\",     radius_pixels=35,     intensity=1, ) m3 In\u00a0[\u00a0]: Copied! <pre>m4 = DeckGLMap(center=[-122.4, 37.8], zoom=11)\nm4.add_basemap(\"CartoDB.DarkMatter\")\nm4.add_heatmap_layer(\n    data=points,\n    name=\"heatmap-density\",\n    get_position=\"coordinates\",\n    radius_pixels=50,\n)\nm4.add_layer_control()\nm4\n</pre> m4 = DeckGLMap(center=[-122.4, 37.8], zoom=11) m4.add_basemap(\"CartoDB.DarkMatter\") m4.add_heatmap_layer(     data=points,     name=\"heatmap-density\",     get_position=\"coordinates\",     radius_pixels=50, ) m4.add_layer_control() m4 In\u00a0[\u00a0]: Copied! <pre>m5 = DeckGLMap(center=[-122.4, 37.8], zoom=11)\nm5.add_basemap(\"CartoDB.DarkMatter\")\nm5.add_deckgl_layer(\n    layer_type=\"HeatmapLayer\",\n    data=points,\n    name=\"heatmap-generic\",\n    getPosition=\"coordinates\",\n    radiusPixels=45,\n    intensity=1,\n    threshold=0.05,\n)\nm5\n</pre> m5 = DeckGLMap(center=[-122.4, 37.8], zoom=11) m5.add_basemap(\"CartoDB.DarkMatter\") m5.add_deckgl_layer(     layer_type=\"HeatmapLayer\",     data=points,     name=\"heatmap-generic\",     getPosition=\"coordinates\",     radiusPixels=45,     intensity=1,     threshold=0.05, ) m5 In\u00a0[\u00a0]: Copied! <pre>m.to_html(\"heatmap_layer_example.html\")\n</pre> m.to_html(\"heatmap_layer_example.html\")"},{"location":"deckgl/heatmap_layer/#heatmap-layer-example","title":"Heatmap Layer Example\u00b6","text":"<p>This notebook demonstrates the DeckGL HeatmapLayer for density visualization.</p>"},{"location":"deckgl/heatmap_layer/#basic-heatmap-layer","title":"Basic Heatmap Layer\u00b6","text":""},{"location":"deckgl/heatmap_layer/#heatmap-with-custom-color-range","title":"Heatmap with Custom Color Range\u00b6","text":""},{"location":"deckgl/heatmap_layer/#heatmap-with-weighted-points","title":"Heatmap with Weighted Points\u00b6","text":""},{"location":"deckgl/heatmap_layer/#heatmap-with-layer-control","title":"Heatmap with Layer Control\u00b6","text":""},{"location":"deckgl/heatmap_layer/#using-the-generic-add_deckgl_layer-method","title":"Using the Generic add_deckgl_layer Method\u00b6","text":""},{"location":"deckgl/heatmap_layer/#export-to-html","title":"Export to HTML\u00b6","text":""},{"location":"deckgl/hexagon_layer/","title":"Hexagon layer","text":"In\u00a0[\u00a0]: Copied! <pre># %pip install -U anymap-ts\n</pre> # %pip install -U anymap-ts In\u00a0[\u00a0]: Copied! <pre>import random\nfrom anymap_ts import DeckGLMap\n\n# Generate random points around San Francisco\npoints = [\n    {\n        \"coordinates\": [\n            -122.4 + random.uniform(-0.3, 0.3),\n            37.8 + random.uniform(-0.3, 0.3),\n        ]\n    }\n    for _ in range(2000)\n]\n\nm = DeckGLMap(center=[-122.4, 37.8], zoom=10, pitch=45)\nm.add_basemap(\"CartoDB.DarkMatter\")\nm.add_hexagon_layer(\n    data=points,\n    name=\"hexagon-basic\",\n    get_position=\"coordinates\",\n    radius=500,\n    elevation_scale=4,\n    extruded=True,\n    opacity=0.8,\n)\nm\n</pre> import random from anymap_ts import DeckGLMap  # Generate random points around San Francisco points = [     {         \"coordinates\": [             -122.4 + random.uniform(-0.3, 0.3),             37.8 + random.uniform(-0.3, 0.3),         ]     }     for _ in range(2000) ]  m = DeckGLMap(center=[-122.4, 37.8], zoom=10, pitch=45) m.add_basemap(\"CartoDB.DarkMatter\") m.add_hexagon_layer(     data=points,     name=\"hexagon-basic\",     get_position=\"coordinates\",     radius=500,     elevation_scale=4,     extruded=True,     opacity=0.8, ) m In\u00a0[\u00a0]: Copied! <pre>m2 = DeckGLMap(center=[-122.4, 37.8], zoom=10)\nm2.add_basemap(\"CartoDB.DarkMatter\")\nm2.add_hexagon_layer(\n    data=points,\n    name=\"hexagon-flat\",\n    get_position=\"coordinates\",\n    radius=400,\n    extruded=False,\n    opacity=0.7,\n)\nm2\n</pre> m2 = DeckGLMap(center=[-122.4, 37.8], zoom=10) m2.add_basemap(\"CartoDB.DarkMatter\") m2.add_hexagon_layer(     data=points,     name=\"hexagon-flat\",     get_position=\"coordinates\",     radius=400,     extruded=False,     opacity=0.7, ) m2 In\u00a0[\u00a0]: Copied! <pre>custom_colors = [\n    [68, 1, 84],\n    [72, 40, 120],\n    [62, 74, 137],\n    [49, 104, 142],\n    [38, 130, 142],\n    [53, 183, 121],\n    [109, 205, 89],\n    [180, 222, 44],\n    [253, 231, 37],\n]\n\nm3 = DeckGLMap(center=[-122.4, 37.8], zoom=10, pitch=50)\nm3.add_basemap(\"CartoDB.DarkMatter\")\nm3.add_hexagon_layer(\n    data=points,\n    name=\"hexagon-custom-colors\",\n    get_position=\"coordinates\",\n    radius=600,\n    elevation_scale=6,\n    extruded=True,\n    color_range=custom_colors,\n    opacity=0.9,\n)\nm3\n</pre> custom_colors = [     [68, 1, 84],     [72, 40, 120],     [62, 74, 137],     [49, 104, 142],     [38, 130, 142],     [53, 183, 121],     [109, 205, 89],     [180, 222, 44],     [253, 231, 37], ]  m3 = DeckGLMap(center=[-122.4, 37.8], zoom=10, pitch=50) m3.add_basemap(\"CartoDB.DarkMatter\") m3.add_hexagon_layer(     data=points,     name=\"hexagon-custom-colors\",     get_position=\"coordinates\",     radius=600,     elevation_scale=6,     extruded=True,     color_range=custom_colors,     opacity=0.9, ) m3 In\u00a0[\u00a0]: Copied! <pre>m4 = DeckGLMap(center=[-122.4, 37.8], zoom=10, pitch=40)\nm4.add_basemap(\"CartoDB.DarkMatter\")\nm4.add_hexagon_layer(\n    data=points,\n    name=\"hexagon-density\",\n    get_position=\"coordinates\",\n    radius=500,\n    elevation_scale=5,\n    extruded=True,\n)\nm4.add_layer_control()\nm4\n</pre> m4 = DeckGLMap(center=[-122.4, 37.8], zoom=10, pitch=40) m4.add_basemap(\"CartoDB.DarkMatter\") m4.add_hexagon_layer(     data=points,     name=\"hexagon-density\",     get_position=\"coordinates\",     radius=500,     elevation_scale=5,     extruded=True, ) m4.add_layer_control() m4 In\u00a0[\u00a0]: Copied! <pre>m5 = DeckGLMap(center=[-122.4, 37.8], zoom=10, pitch=45)\nm5.add_basemap(\"CartoDB.DarkMatter\")\nm5.add_deckgl_layer(\n    layer_type=\"HexagonLayer\",\n    data=points,\n    name=\"hexagon-generic\",\n    getPosition=\"coordinates\",\n    radius=500,\n    elevationScale=5,\n    extruded=True,\n    opacity=0.8,\n)\nm5\n</pre> m5 = DeckGLMap(center=[-122.4, 37.8], zoom=10, pitch=45) m5.add_basemap(\"CartoDB.DarkMatter\") m5.add_deckgl_layer(     layer_type=\"HexagonLayer\",     data=points,     name=\"hexagon-generic\",     getPosition=\"coordinates\",     radius=500,     elevationScale=5,     extruded=True,     opacity=0.8, ) m5 In\u00a0[\u00a0]: Copied! <pre>m.to_html(\"hexagon_layer_example.html\")\n</pre> m.to_html(\"hexagon_layer_example.html\")"},{"location":"deckgl/hexagon_layer/#hexagon-layer-example","title":"Hexagon Layer Example\u00b6","text":"<p>This notebook demonstrates the DeckGL HexagonLayer for hexagonal binning and aggregation.</p>"},{"location":"deckgl/hexagon_layer/#basic-hexagon-layer","title":"Basic Hexagon Layer\u00b6","text":""},{"location":"deckgl/hexagon_layer/#flat-hexagon-layer-no-extrusion","title":"Flat Hexagon Layer (No Extrusion)\u00b6","text":""},{"location":"deckgl/hexagon_layer/#custom-color-range","title":"Custom Color Range\u00b6","text":""},{"location":"deckgl/hexagon_layer/#hexagon-layer-with-layer-control","title":"Hexagon Layer with Layer Control\u00b6","text":""},{"location":"deckgl/hexagon_layer/#using-the-generic-add_deckgl_layer-method","title":"Using the Generic add_deckgl_layer Method\u00b6","text":""},{"location":"deckgl/hexagon_layer/#export-to-html","title":"Export to HTML\u00b6","text":""},{"location":"deckgl/icon_layer/","title":"Icon layer","text":"In\u00a0[\u00a0]: Copied! <pre># %pip install -U anymap-ts\n</pre> # %pip install -U anymap-ts In\u00a0[\u00a0]: Copied! <pre>from anymap_ts import DeckGLMap\n\n# POI locations around San Francisco\npois = [\n    {\n        \"coordinates\": [-122.4098, 37.7855],\n        \"name\": \"Restaurant A\",\n        \"icon\": \"marker\",\n        \"size\": 40,\n    },\n    {\n        \"coordinates\": [-122.4150, 37.7820],\n        \"name\": \"Restaurant B\",\n        \"icon\": \"marker\",\n        \"size\": 35,\n    },\n    {\n        \"coordinates\": [-122.4200, 37.7890],\n        \"name\": \"Hotel A\",\n        \"icon\": \"marker\",\n        \"size\": 50,\n    },\n    {\n        \"coordinates\": [-122.4180, 37.7920],\n        \"name\": \"Hotel B\",\n        \"icon\": \"marker\",\n        \"size\": 55,\n    },\n    {\n        \"coordinates\": [-122.4194, 37.7749],\n        \"name\": \"City Hall\",\n        \"icon\": \"marker\",\n        \"size\": 60,\n    },\n    {\n        \"coordinates\": [-122.4534, 37.8083],\n        \"name\": \"Fishermans Wharf\",\n        \"icon\": \"marker\",\n        \"size\": 55,\n    },\n]\n\n# Using a public icon atlas URL (Mapbox Maki icons)\nicon_atlas = (\n    \"https://raw.githubusercontent.com/visgl/deck.gl-data/master/website/icon-atlas.png\"\n)\nicon_mapping = {\n    \"marker\": {\n        \"x\": 0,\n        \"y\": 0,\n        \"width\": 128,\n        \"height\": 128,\n        \"anchorY\": 128,\n        \"mask\": True,\n    }\n}\n\nm = DeckGLMap(center=[-122.42, 37.79], zoom=13)\nm.add_basemap(\"CartoDB.DarkMatter\")\nm.add_icon_layer(\n    data=pois,\n    name=\"icon-basic\",\n    get_position=\"coordinates\",\n    get_icon=\"icon\",\n    get_size=\"size\",\n    icon_atlas=icon_atlas,\n    icon_mapping=icon_mapping,\n    get_color=[255, 100, 100],\n    size_min_pixels=20,\n    size_max_pixels=80,\n)\nm\n</pre> from anymap_ts import DeckGLMap  # POI locations around San Francisco pois = [     {         \"coordinates\": [-122.4098, 37.7855],         \"name\": \"Restaurant A\",         \"icon\": \"marker\",         \"size\": 40,     },     {         \"coordinates\": [-122.4150, 37.7820],         \"name\": \"Restaurant B\",         \"icon\": \"marker\",         \"size\": 35,     },     {         \"coordinates\": [-122.4200, 37.7890],         \"name\": \"Hotel A\",         \"icon\": \"marker\",         \"size\": 50,     },     {         \"coordinates\": [-122.4180, 37.7920],         \"name\": \"Hotel B\",         \"icon\": \"marker\",         \"size\": 55,     },     {         \"coordinates\": [-122.4194, 37.7749],         \"name\": \"City Hall\",         \"icon\": \"marker\",         \"size\": 60,     },     {         \"coordinates\": [-122.4534, 37.8083],         \"name\": \"Fishermans Wharf\",         \"icon\": \"marker\",         \"size\": 55,     }, ]  # Using a public icon atlas URL (Mapbox Maki icons) icon_atlas = (     \"https://raw.githubusercontent.com/visgl/deck.gl-data/master/website/icon-atlas.png\" ) icon_mapping = {     \"marker\": {         \"x\": 0,         \"y\": 0,         \"width\": 128,         \"height\": 128,         \"anchorY\": 128,         \"mask\": True,     } }  m = DeckGLMap(center=[-122.42, 37.79], zoom=13) m.add_basemap(\"CartoDB.DarkMatter\") m.add_icon_layer(     data=pois,     name=\"icon-basic\",     get_position=\"coordinates\",     get_icon=\"icon\",     get_size=\"size\",     icon_atlas=icon_atlas,     icon_mapping=icon_mapping,     get_color=[255, 100, 100],     size_min_pixels=20,     size_max_pixels=80, ) m In\u00a0[\u00a0]: Copied! <pre># POIs with category-based coloring\nrestaurants = [\n    {\n        \"coordinates\": [-122.4098, 37.7855],\n        \"name\": \"Restaurant A\",\n        \"icon\": \"marker\",\n        \"size\": 40,\n        \"color\": [255, 100, 100],\n    },\n    {\n        \"coordinates\": [-122.4150, 37.7820],\n        \"name\": \"Restaurant B\",\n        \"icon\": \"marker\",\n        \"size\": 35,\n        \"color\": [255, 100, 100],\n    },\n    {\n        \"coordinates\": [-122.4200, 37.7890],\n        \"name\": \"Restaurant C\",\n        \"icon\": \"marker\",\n        \"size\": 45,\n        \"color\": [255, 100, 100],\n    },\n]\n\nhotels = [\n    {\n        \"coordinates\": [-122.4100, 37.7880],\n        \"name\": \"Hotel A\",\n        \"icon\": \"marker\",\n        \"size\": 50,\n        \"color\": [100, 150, 255],\n    },\n    {\n        \"coordinates\": [-122.4180, 37.7920],\n        \"name\": \"Hotel B\",\n        \"icon\": \"marker\",\n        \"size\": 55,\n        \"color\": [100, 150, 255],\n    },\n]\n\nattractions = [\n    {\n        \"coordinates\": [-122.4194, 37.7749],\n        \"name\": \"City Hall\",\n        \"icon\": \"marker\",\n        \"size\": 60,\n        \"color\": [100, 255, 150],\n    },\n    {\n        \"coordinates\": [-122.4534, 37.8083],\n        \"name\": \"Fishermans Wharf\",\n        \"icon\": \"marker\",\n        \"size\": 55,\n        \"color\": [100, 255, 150],\n    },\n    {\n        \"coordinates\": [-122.4862, 37.8199],\n        \"name\": \"Golden Gate View\",\n        \"icon\": \"marker\",\n        \"size\": 65,\n        \"color\": [100, 255, 150],\n    },\n]\n\nall_pois = restaurants + hotels + attractions\n\nm2 = DeckGLMap(center=[-122.42, 37.79], zoom=12)\nm2.add_basemap(\"CartoDB.DarkMatter\")\nm2.add_icon_layer(\n    data=all_pois,\n    name=\"icon-colored\",\n    get_position=\"coordinates\",\n    get_icon=\"icon\",\n    get_size=\"size\",\n    icon_atlas=icon_atlas,\n    icon_mapping=icon_mapping,\n    get_color=\"color\",\n    size_min_pixels=20,\n)\nm2\n</pre> # POIs with category-based coloring restaurants = [     {         \"coordinates\": [-122.4098, 37.7855],         \"name\": \"Restaurant A\",         \"icon\": \"marker\",         \"size\": 40,         \"color\": [255, 100, 100],     },     {         \"coordinates\": [-122.4150, 37.7820],         \"name\": \"Restaurant B\",         \"icon\": \"marker\",         \"size\": 35,         \"color\": [255, 100, 100],     },     {         \"coordinates\": [-122.4200, 37.7890],         \"name\": \"Restaurant C\",         \"icon\": \"marker\",         \"size\": 45,         \"color\": [255, 100, 100],     }, ]  hotels = [     {         \"coordinates\": [-122.4100, 37.7880],         \"name\": \"Hotel A\",         \"icon\": \"marker\",         \"size\": 50,         \"color\": [100, 150, 255],     },     {         \"coordinates\": [-122.4180, 37.7920],         \"name\": \"Hotel B\",         \"icon\": \"marker\",         \"size\": 55,         \"color\": [100, 150, 255],     }, ]  attractions = [     {         \"coordinates\": [-122.4194, 37.7749],         \"name\": \"City Hall\",         \"icon\": \"marker\",         \"size\": 60,         \"color\": [100, 255, 150],     },     {         \"coordinates\": [-122.4534, 37.8083],         \"name\": \"Fishermans Wharf\",         \"icon\": \"marker\",         \"size\": 55,         \"color\": [100, 255, 150],     },     {         \"coordinates\": [-122.4862, 37.8199],         \"name\": \"Golden Gate View\",         \"icon\": \"marker\",         \"size\": 65,         \"color\": [100, 255, 150],     }, ]  all_pois = restaurants + hotels + attractions  m2 = DeckGLMap(center=[-122.42, 37.79], zoom=12) m2.add_basemap(\"CartoDB.DarkMatter\") m2.add_icon_layer(     data=all_pois,     name=\"icon-colored\",     get_position=\"coordinates\",     get_icon=\"icon\",     get_size=\"size\",     icon_atlas=icon_atlas,     icon_mapping=icon_mapping,     get_color=\"color\",     size_min_pixels=20, ) m2 In\u00a0[\u00a0]: Copied! <pre>m3 = DeckGLMap(center=[-122.42, 37.79], zoom=12)\nm3.add_basemap(\"CartoDB.DarkMatter\")\n\nm3.add_icon_layer(\n    data=restaurants,\n    name=\"icon-restaurants\",\n    get_position=\"coordinates\",\n    get_icon=\"icon\",\n    get_size=\"size\",\n    icon_atlas=icon_atlas,\n    icon_mapping=icon_mapping,\n    get_color=[255, 100, 100],\n)\n\nm3.add_icon_layer(\n    data=hotels,\n    name=\"icon-hotels\",\n    get_position=\"coordinates\",\n    get_icon=\"icon\",\n    get_size=\"size\",\n    icon_atlas=icon_atlas,\n    icon_mapping=icon_mapping,\n    get_color=[100, 150, 255],\n)\n\nm3.add_icon_layer(\n    data=attractions,\n    name=\"icon-attractions\",\n    get_position=\"coordinates\",\n    get_icon=\"icon\",\n    get_size=\"size\",\n    icon_atlas=icon_atlas,\n    icon_mapping=icon_mapping,\n    get_color=[100, 255, 150],\n)\n\nm3.add_layer_control()\nm3\n</pre> m3 = DeckGLMap(center=[-122.42, 37.79], zoom=12) m3.add_basemap(\"CartoDB.DarkMatter\")  m3.add_icon_layer(     data=restaurants,     name=\"icon-restaurants\",     get_position=\"coordinates\",     get_icon=\"icon\",     get_size=\"size\",     icon_atlas=icon_atlas,     icon_mapping=icon_mapping,     get_color=[255, 100, 100], )  m3.add_icon_layer(     data=hotels,     name=\"icon-hotels\",     get_position=\"coordinates\",     get_icon=\"icon\",     get_size=\"size\",     icon_atlas=icon_atlas,     icon_mapping=icon_mapping,     get_color=[100, 150, 255], )  m3.add_icon_layer(     data=attractions,     name=\"icon-attractions\",     get_position=\"coordinates\",     get_icon=\"icon\",     get_size=\"size\",     icon_atlas=icon_atlas,     icon_mapping=icon_mapping,     get_color=[100, 255, 150], )  m3.add_layer_control() m3 In\u00a0[\u00a0]: Copied! <pre>m4 = DeckGLMap(center=[-122.42, 37.79], zoom=13)\nm4.add_basemap(\"CartoDB.DarkMatter\")\n\nm4.add_deckgl_layer(\n    layer_type=\"IconLayer\",\n    data=pois,\n    name=\"icon-generic\",\n    getPosition=\"coordinates\",\n    getIcon=\"icon\",\n    getSize=\"size\",\n    iconAtlas=icon_atlas,\n    iconMapping=icon_mapping,\n    getColor=[138, 43, 226],\n    sizeMinPixels=20,\n    sizeMaxPixels=80,\n    pickable=True,\n)\nm4\n</pre> m4 = DeckGLMap(center=[-122.42, 37.79], zoom=13) m4.add_basemap(\"CartoDB.DarkMatter\")  m4.add_deckgl_layer(     layer_type=\"IconLayer\",     data=pois,     name=\"icon-generic\",     getPosition=\"coordinates\",     getIcon=\"icon\",     getSize=\"size\",     iconAtlas=icon_atlas,     iconMapping=icon_mapping,     getColor=[138, 43, 226],     sizeMinPixels=20,     sizeMaxPixels=80,     pickable=True, ) m4 In\u00a0[\u00a0]: Copied! <pre>m3.to_html(\"icon_layer_example.html\")\n</pre> m3.to_html(\"icon_layer_example.html\")"},{"location":"deckgl/icon_layer/#icon-layer-example","title":"Icon Layer Example\u00b6","text":"<p>This notebook demonstrates the DeckGL IconLayer for rendering custom marker icons on maps.</p>"},{"location":"deckgl/icon_layer/#basic-icon-layer","title":"Basic Icon Layer\u00b6","text":""},{"location":"deckgl/icon_layer/#icon-layer-with-different-categories","title":"Icon Layer with Different Categories\u00b6","text":""},{"location":"deckgl/icon_layer/#multiple-icon-layers-with-layer-control","title":"Multiple Icon Layers with Layer Control\u00b6","text":""},{"location":"deckgl/icon_layer/#using-the-generic-add_deckgl_layer-method","title":"Using the Generic add_deckgl_layer Method\u00b6","text":""},{"location":"deckgl/icon_layer/#export-to-html","title":"Export to HTML\u00b6","text":""},{"location":"deckgl/mvt_layer/","title":"Mvt layer","text":"In\u00a0[\u00a0]: Copied! <pre># %pip install -U anymap-ts\n</pre> # %pip install -U anymap-ts In\u00a0[\u00a0]: Copied! <pre>from anymap_ts import DeckGLMap\n</pre> from anymap_ts import DeckGLMap In\u00a0[\u00a0]: Copied! <pre>m = DeckGLMap(center=[-122.4, 37.8], zoom=11)\nm.add_basemap(\"CartoDB.DarkMatter\")\n\n# Add CARTO vector tiles\nm.add_mvt_layer(\n    data=\"https://tiles.basemaps.cartocdn.com/vectortiles/carto.streets/v1/{z}/{x}/{y}.mvt\",\n    min_zoom=0,\n    max_zoom=14,\n    get_line_color=[255, 255, 255, 200],\n    get_fill_color=[100, 130, 180, 100],\n    get_line_width=1,\n    line_width_min_pixels=1,\n    pickable=True,\n)\nm\n</pre> m = DeckGLMap(center=[-122.4, 37.8], zoom=11) m.add_basemap(\"CartoDB.DarkMatter\")  # Add CARTO vector tiles m.add_mvt_layer(     data=\"https://tiles.basemaps.cartocdn.com/vectortiles/carto.streets/v1/{z}/{x}/{y}.mvt\",     min_zoom=0,     max_zoom=14,     get_line_color=[255, 255, 255, 200],     get_fill_color=[100, 130, 180, 100],     get_line_width=1,     line_width_min_pixels=1,     pickable=True, ) m In\u00a0[\u00a0]: Copied! <pre>m.to_html(\"mvt_layer_example.html\")\n</pre> m.to_html(\"mvt_layer_example.html\")"},{"location":"deckgl/mvt_layer/#mvt-layer-example","title":"MVT Layer Example\u00b6","text":"<p>Mapbox Vector Tiles rendering using deck.gl MVTLayer.</p>"},{"location":"deckgl/mvt_layer/#create-a-map-with-mvt-layer","title":"Create a map with MVT layer\u00b6","text":""},{"location":"deckgl/mvt_layer/#export-to-html","title":"Export to HTML\u00b6","text":""},{"location":"deckgl/polygon_layer/","title":"Polygon layer","text":"In\u00a0[\u00a0]: Copied! <pre># %pip install -U anymap-ts\n</pre> # %pip install -U anymap-ts In\u00a0[\u00a0]: Copied! <pre>from anymap_ts import DeckGLMap\n\n# San Francisco districts\ndistricts = [\n    {\n        \"polygon\": [\n            [-122.405, 37.795],\n            [-122.395, 37.795],\n            [-122.395, 37.785],\n            [-122.405, 37.785],\n            [-122.405, 37.795],\n        ],\n        \"name\": \"Financial District\",\n        \"elevation\": 500,\n    },\n    {\n        \"polygon\": [\n            [-122.415, 37.785],\n            [-122.395, 37.785],\n            [-122.395, 37.770],\n            [-122.415, 37.770],\n            [-122.415, 37.785],\n        ],\n        \"name\": \"SoMa\",\n        \"elevation\": 400,\n    },\n    {\n        \"polygon\": [\n            [-122.425, 37.770],\n            [-122.405, 37.770],\n            [-122.405, 37.750],\n            [-122.425, 37.750],\n            [-122.425, 37.770],\n        ],\n        \"name\": \"Mission District\",\n        \"elevation\": 350,\n    },\n    {\n        \"polygon\": [\n            [-122.410, 37.798],\n            [-122.403, 37.798],\n            [-122.403, 37.792],\n            [-122.410, 37.792],\n            [-122.410, 37.798],\n        ],\n        \"name\": \"Chinatown\",\n        \"elevation\": 300,\n    },\n]\n\nm = DeckGLMap(center=[-122.41, 37.78], zoom=13)\nm.add_basemap(\"CartoDB.DarkMatter\")\nm.add_polygon_layer(\n    data=districts,\n    name=\"polygon-basic\",\n    get_polygon=\"polygon\",\n    get_fill_color=[100, 150, 255, 150],\n    get_line_color=[255, 255, 255, 200],\n    line_width_min_pixels=2,\n)\nm\n</pre> from anymap_ts import DeckGLMap  # San Francisco districts districts = [     {         \"polygon\": [             [-122.405, 37.795],             [-122.395, 37.795],             [-122.395, 37.785],             [-122.405, 37.785],             [-122.405, 37.795],         ],         \"name\": \"Financial District\",         \"elevation\": 500,     },     {         \"polygon\": [             [-122.415, 37.785],             [-122.395, 37.785],             [-122.395, 37.770],             [-122.415, 37.770],             [-122.415, 37.785],         ],         \"name\": \"SoMa\",         \"elevation\": 400,     },     {         \"polygon\": [             [-122.425, 37.770],             [-122.405, 37.770],             [-122.405, 37.750],             [-122.425, 37.750],             [-122.425, 37.770],         ],         \"name\": \"Mission District\",         \"elevation\": 350,     },     {         \"polygon\": [             [-122.410, 37.798],             [-122.403, 37.798],             [-122.403, 37.792],             [-122.410, 37.792],             [-122.410, 37.798],         ],         \"name\": \"Chinatown\",         \"elevation\": 300,     }, ]  m = DeckGLMap(center=[-122.41, 37.78], zoom=13) m.add_basemap(\"CartoDB.DarkMatter\") m.add_polygon_layer(     data=districts,     name=\"polygon-basic\",     get_polygon=\"polygon\",     get_fill_color=[100, 150, 255, 150],     get_line_color=[255, 255, 255, 200],     line_width_min_pixels=2, ) m In\u00a0[\u00a0]: Copied! <pre>m2 = DeckGLMap(center=[-122.41, 37.78], zoom=13, pitch=45, bearing=-17)\nm2.add_basemap(\"CartoDB.DarkMatter\")\nm2.add_polygon_layer(\n    data=districts,\n    name=\"polygon-3d\",\n    get_polygon=\"polygon\",\n    get_fill_color=[255, 100, 100, 180],\n    get_line_color=[255, 255, 255, 255],\n    extruded=True,\n    get_elevation=\"elevation\",\n    line_width_min_pixels=2,\n)\nm2\n</pre> m2 = DeckGLMap(center=[-122.41, 37.78], zoom=13, pitch=45, bearing=-17) m2.add_basemap(\"CartoDB.DarkMatter\") m2.add_polygon_layer(     data=districts,     name=\"polygon-3d\",     get_polygon=\"polygon\",     get_fill_color=[255, 100, 100, 180],     get_line_color=[255, 255, 255, 255],     extruded=True,     get_elevation=\"elevation\",     line_width_min_pixels=2, ) m2 In\u00a0[\u00a0]: Copied! <pre># Additional districts\nother_districts = [\n    {\n        \"polygon\": [\n            [-122.445, 37.805],\n            [-122.425, 37.805],\n            [-122.425, 37.798],\n            [-122.445, 37.798],\n            [-122.445, 37.805],\n        ],\n        \"name\": \"Marina\",\n        \"elevation\": 200,\n    },\n    {\n        \"polygon\": [\n            [-122.440, 37.765],\n            [-122.425, 37.765],\n            [-122.425, 37.755],\n            [-122.440, 37.755],\n            [-122.440, 37.765],\n        ],\n        \"name\": \"Castro\",\n        \"elevation\": 300,\n    },\n]\n\nm3 = DeckGLMap(center=[-122.42, 37.78], zoom=12, pitch=45, bearing=-17)\nm3.add_basemap(\"CartoDB.DarkMatter\")\n\nm3.add_polygon_layer(\n    data=districts,\n    name=\"polygon-downtown\",\n    get_polygon=\"polygon\",\n    get_fill_color=[255, 100, 100, 180],\n    extruded=True,\n    get_elevation=\"elevation\",\n)\n\nm3.add_polygon_layer(\n    data=other_districts,\n    name=\"polygon-neighborhoods\",\n    get_polygon=\"polygon\",\n    get_fill_color=[100, 200, 255, 180],\n    extruded=True,\n    get_elevation=\"elevation\",\n)\n\nm3.add_layer_control()\nm3\n</pre> # Additional districts other_districts = [     {         \"polygon\": [             [-122.445, 37.805],             [-122.425, 37.805],             [-122.425, 37.798],             [-122.445, 37.798],             [-122.445, 37.805],         ],         \"name\": \"Marina\",         \"elevation\": 200,     },     {         \"polygon\": [             [-122.440, 37.765],             [-122.425, 37.765],             [-122.425, 37.755],             [-122.440, 37.755],             [-122.440, 37.765],         ],         \"name\": \"Castro\",         \"elevation\": 300,     }, ]  m3 = DeckGLMap(center=[-122.42, 37.78], zoom=12, pitch=45, bearing=-17) m3.add_basemap(\"CartoDB.DarkMatter\")  m3.add_polygon_layer(     data=districts,     name=\"polygon-downtown\",     get_polygon=\"polygon\",     get_fill_color=[255, 100, 100, 180],     extruded=True,     get_elevation=\"elevation\", )  m3.add_polygon_layer(     data=other_districts,     name=\"polygon-neighborhoods\",     get_polygon=\"polygon\",     get_fill_color=[100, 200, 255, 180],     extruded=True,     get_elevation=\"elevation\", )  m3.add_layer_control() m3 In\u00a0[\u00a0]: Copied! <pre>m4 = DeckGLMap(center=[-122.41, 37.78], zoom=13, pitch=45)\nm4.add_basemap(\"CartoDB.DarkMatter\")\n\nm4.add_deckgl_layer(\n    layer_type=\"PolygonLayer\",\n    data=districts,\n    name=\"polygon-generic\",\n    getPolygon=\"polygon\",\n    getFillColor=[100, 255, 150, 180],\n    getLineColor=[255, 255, 255, 255],\n    extruded=True,\n    getElevation=\"elevation\",\n    lineWidthMinPixels=2,\n    pickable=True,\n)\nm4\n</pre> m4 = DeckGLMap(center=[-122.41, 37.78], zoom=13, pitch=45) m4.add_basemap(\"CartoDB.DarkMatter\")  m4.add_deckgl_layer(     layer_type=\"PolygonLayer\",     data=districts,     name=\"polygon-generic\",     getPolygon=\"polygon\",     getFillColor=[100, 255, 150, 180],     getLineColor=[255, 255, 255, 255],     extruded=True,     getElevation=\"elevation\",     lineWidthMinPixels=2,     pickable=True, ) m4 In\u00a0[\u00a0]: Copied! <pre>m2.to_html(\"polygon_layer_example.html\")\n</pre> m2.to_html(\"polygon_layer_example.html\")"},{"location":"deckgl/polygon_layer/#polygon-layer-example","title":"Polygon Layer Example\u00b6","text":"<p>This notebook demonstrates the DeckGL PolygonLayer for rendering filled and stroked polygons with 3D extrusion support.</p>"},{"location":"deckgl/polygon_layer/#basic-polygon-layer-flat","title":"Basic Polygon Layer (Flat)\u00b6","text":""},{"location":"deckgl/polygon_layer/#extruded-3d-polygons","title":"Extruded 3D Polygons\u00b6","text":""},{"location":"deckgl/polygon_layer/#multiple-polygon-layers-with-layer-control","title":"Multiple Polygon Layers with Layer Control\u00b6","text":""},{"location":"deckgl/polygon_layer/#using-the-generic-add_deckgl_layer-method","title":"Using the Generic add_deckgl_layer Method\u00b6","text":""},{"location":"deckgl/polygon_layer/#export-to-html","title":"Export to HTML\u00b6","text":""},{"location":"deckgl/quadkey_layer/","title":"Quadkey layer","text":"In\u00a0[\u00a0]: Copied! <pre># %pip install -U anymap-ts\n</pre> # %pip install -U anymap-ts In\u00a0[\u00a0]: Copied! <pre>from anymap_ts import DeckGLMap\n</pre> from anymap_ts import DeckGLMap In\u00a0[\u00a0]: Copied! <pre># Sample quadkey data (around San Francisco area)\nquadkey_data = [\n    {\"quadkey\": \"0230102\", \"value\": 150},\n    {\"quadkey\": \"0230103\", \"value\": 200},\n    {\"quadkey\": \"0230110\", \"value\": 180},\n    {\"quadkey\": \"0230111\", \"value\": 250},\n    {\"quadkey\": \"0230120\", \"value\": 300},\n    {\"quadkey\": \"0230121\", \"value\": 220},\n    {\"quadkey\": \"0230122\", \"value\": 190},\n    {\"quadkey\": \"0230123\", \"value\": 280},\n]\n</pre> # Sample quadkey data (around San Francisco area) quadkey_data = [     {\"quadkey\": \"0230102\", \"value\": 150},     {\"quadkey\": \"0230103\", \"value\": 200},     {\"quadkey\": \"0230110\", \"value\": 180},     {\"quadkey\": \"0230111\", \"value\": 250},     {\"quadkey\": \"0230120\", \"value\": 300},     {\"quadkey\": \"0230121\", \"value\": 220},     {\"quadkey\": \"0230122\", \"value\": 190},     {\"quadkey\": \"0230123\", \"value\": 280}, ] In\u00a0[\u00a0]: Copied! <pre>m = DeckGLMap(center=[-122.4, 37.75], zoom=6, pitch=45)\nm.add_basemap(\"CartoDB.DarkMatter\")\n\nm.add_quadkey_layer(\n    data=quadkey_data,\n    get_quadkey=\"quadkey\",\n    get_fill_color=[255, 140, 0, 180],\n    get_elevation=\"value\",\n    extruded=True,\n    elevation_scale=50,\n    pickable=True,\n)\nm\n</pre> m = DeckGLMap(center=[-122.4, 37.75], zoom=6, pitch=45) m.add_basemap(\"CartoDB.DarkMatter\")  m.add_quadkey_layer(     data=quadkey_data,     get_quadkey=\"quadkey\",     get_fill_color=[255, 140, 0, 180],     get_elevation=\"value\",     extruded=True,     elevation_scale=50,     pickable=True, ) m In\u00a0[\u00a0]: Copied! <pre>m.to_html(\"quadkey_layer_example.html\")\n</pre> m.to_html(\"quadkey_layer_example.html\")"},{"location":"deckgl/quadkey_layer/#quadkey-layer-example","title":"Quadkey Layer Example\u00b6","text":"<p>Bing Maps quadkey tile indexing visualization using deck.gl QuadkeyLayer.</p>"},{"location":"deckgl/quadkey_layer/#define-quadkey-data","title":"Define quadkey data\u00b6","text":""},{"location":"deckgl/quadkey_layer/#create-map-with-quadkey-layer","title":"Create map with quadkey layer\u00b6","text":""},{"location":"deckgl/quadkey_layer/#export-to-html","title":"Export to HTML\u00b6","text":""},{"location":"deckgl/s2_layer/","title":"S2 layer","text":"In\u00a0[\u00a0]: Copied! <pre># %pip install -U anymap-ts\n</pre> # %pip install -U anymap-ts In\u00a0[\u00a0]: Copied! <pre>from anymap_ts import DeckGLMap\n</pre> from anymap_ts import DeckGLMap In\u00a0[\u00a0]: Copied! <pre># Sample S2 cell tokens (around San Francisco area)\ns2_data = [\n    {\"token\": \"80858c\", \"value\": 100},\n    {\"token\": \"80858d\", \"value\": 200},\n    {\"token\": \"80858e\", \"value\": 150},\n    {\"token\": \"80858f\", \"value\": 300},\n    {\"token\": \"808590\", \"value\": 250},\n    {\"token\": \"808591\", \"value\": 180},\n    {\"token\": \"808594\", \"value\": 220},\n    {\"token\": \"808595\", \"value\": 270},\n]\n</pre> # Sample S2 cell tokens (around San Francisco area) s2_data = [     {\"token\": \"80858c\", \"value\": 100},     {\"token\": \"80858d\", \"value\": 200},     {\"token\": \"80858e\", \"value\": 150},     {\"token\": \"80858f\", \"value\": 300},     {\"token\": \"808590\", \"value\": 250},     {\"token\": \"808591\", \"value\": 180},     {\"token\": \"808594\", \"value\": 220},     {\"token\": \"808595\", \"value\": 270}, ] In\u00a0[\u00a0]: Copied! <pre>m = DeckGLMap(center=[-122.4, 37.75], zoom=8, pitch=45)\nm.add_basemap(\"CartoDB.DarkMatter\")\n\nm.add_s2_layer(\n    data=s2_data,\n    get_s2_token=\"token\",\n    get_fill_color=[51, 136, 255, 180],\n    get_elevation=\"value\",\n    extruded=True,\n    elevation_scale=100,\n    pickable=True,\n)\nm\n</pre> m = DeckGLMap(center=[-122.4, 37.75], zoom=8, pitch=45) m.add_basemap(\"CartoDB.DarkMatter\")  m.add_s2_layer(     data=s2_data,     get_s2_token=\"token\",     get_fill_color=[51, 136, 255, 180],     get_elevation=\"value\",     extruded=True,     elevation_scale=100,     pickable=True, ) m In\u00a0[\u00a0]: Copied! <pre>m.to_html(\"s2_layer_example.html\")\n</pre> m.to_html(\"s2_layer_example.html\")"},{"location":"deckgl/s2_layer/#s2-layer-example","title":"S2 Layer Example\u00b6","text":"<p>Google S2 geometry cells visualization using deck.gl S2Layer.</p>"},{"location":"deckgl/s2_layer/#define-s2-cell-data","title":"Define S2 cell data\u00b6","text":""},{"location":"deckgl/s2_layer/#create-map-with-s2-layer","title":"Create map with S2 layer\u00b6","text":""},{"location":"deckgl/s2_layer/#export-to-html","title":"Export to HTML\u00b6","text":""},{"location":"deckgl/scatterplot_layer/","title":"Scatterplot layer","text":"In\u00a0[\u00a0]: Copied! <pre># %pip install -U anymap-ts\n</pre> # %pip install -U anymap-ts In\u00a0[\u00a0]: Copied! <pre>import random\nfrom anymap_ts import DeckGLMap\n\n# Generate random points around San Francisco\npoints = [\n    {\n        \"coordinates\": [\n            -122.4 + random.uniform(-0.2, 0.2),\n            37.8 + random.uniform(-0.2, 0.2),\n        ],\n        \"value\": random.randint(10, 100),\n    }\n    for _ in range(500)\n]\n\nm = DeckGLMap(center=[-122.4, 37.8], zoom=10)\nm.add_basemap(\"CartoDB.DarkMatter\")\nm.add_scatterplot_layer(\n    data=points,\n    name=\"scatterplot-basic\",\n    get_position=\"coordinates\",\n    get_radius=100,\n    get_fill_color=[255, 140, 0, 200],\n    radius_min_pixels=2,\n    radius_max_pixels=20,\n)\nm\n</pre> import random from anymap_ts import DeckGLMap  # Generate random points around San Francisco points = [     {         \"coordinates\": [             -122.4 + random.uniform(-0.2, 0.2),             37.8 + random.uniform(-0.2, 0.2),         ],         \"value\": random.randint(10, 100),     }     for _ in range(500) ]  m = DeckGLMap(center=[-122.4, 37.8], zoom=10) m.add_basemap(\"CartoDB.DarkMatter\") m.add_scatterplot_layer(     data=points,     name=\"scatterplot-basic\",     get_position=\"coordinates\",     get_radius=100,     get_fill_color=[255, 140, 0, 200],     radius_min_pixels=2,     radius_max_pixels=20, ) m In\u00a0[\u00a0]: Copied! <pre>m2 = DeckGLMap(center=[-122.4, 37.8], zoom=10)\nm2.add_basemap(\"CartoDB.DarkMatter\")\nm2.add_scatterplot_layer(\n    data=points,\n    name=\"scatterplot-sized\",\n    get_position=\"coordinates\",\n    get_radius=\"value\",\n    get_fill_color=[0, 200, 100, 180],\n    radius_scale=10,\n    radius_min_pixels=3,\n    radius_max_pixels=50,\n    stroked=True,\n    get_line_color=[255, 255, 255, 200],\n    line_width_min_pixels=1,\n)\nm2\n</pre> m2 = DeckGLMap(center=[-122.4, 37.8], zoom=10) m2.add_basemap(\"CartoDB.DarkMatter\") m2.add_scatterplot_layer(     data=points,     name=\"scatterplot-sized\",     get_position=\"coordinates\",     get_radius=\"value\",     get_fill_color=[0, 200, 100, 180],     radius_scale=10,     radius_min_pixels=3,     radius_max_pixels=50,     stroked=True,     get_line_color=[255, 255, 255, 200],     line_width_min_pixels=1, ) m2 In\u00a0[\u00a0]: Copied! <pre>high_value_points = [p for p in points if p[\"value\"] &gt;= 50]\nlow_value_points = [p for p in points if p[\"value\"] &lt; 50]\n\nm3 = DeckGLMap(center=[-122.4, 37.8], zoom=10)\nm3.add_basemap(\"CartoDB.DarkMatter\")\n\nm3.add_scatterplot_layer(\n    data=high_value_points,\n    name=\"scatterplot-high-value\",\n    get_position=\"coordinates\",\n    get_radius=\"value\",\n    get_fill_color=[255, 50, 50, 200],\n    radius_scale=15,\n    radius_min_pixels=5,\n)\n\nm3.add_scatterplot_layer(\n    data=low_value_points,\n    name=\"scatterplot-low-value\",\n    get_position=\"coordinates\",\n    get_radius=\"value\",\n    get_fill_color=[50, 100, 255, 200],\n    radius_scale=15,\n    radius_min_pixels=3,\n)\n\nm3.add_layer_control()\nm3\n</pre> high_value_points = [p for p in points if p[\"value\"] &gt;= 50] low_value_points = [p for p in points if p[\"value\"] &lt; 50]  m3 = DeckGLMap(center=[-122.4, 37.8], zoom=10) m3.add_basemap(\"CartoDB.DarkMatter\")  m3.add_scatterplot_layer(     data=high_value_points,     name=\"scatterplot-high-value\",     get_position=\"coordinates\",     get_radius=\"value\",     get_fill_color=[255, 50, 50, 200],     radius_scale=15,     radius_min_pixels=5, )  m3.add_scatterplot_layer(     data=low_value_points,     name=\"scatterplot-low-value\",     get_position=\"coordinates\",     get_radius=\"value\",     get_fill_color=[50, 100, 255, 200],     radius_scale=15,     radius_min_pixels=3, )  m3.add_layer_control() m3 In\u00a0[\u00a0]: Copied! <pre>m4 = DeckGLMap(center=[-122.4, 37.8], zoom=10)\nm4.add_basemap(\"CartoDB.DarkMatter\")\n\nm4.add_deckgl_layer(\n    layer_type=\"ScatterplotLayer\",\n    data=points,\n    name=\"scatterplot-generic\",\n    getPosition=\"coordinates\",\n    getRadius=100,\n    getFillColor=[138, 43, 226, 200],\n    radiusMinPixels=3,\n    radiusMaxPixels=30,\n    opacity=0.8,\n)\nm4\n</pre> m4 = DeckGLMap(center=[-122.4, 37.8], zoom=10) m4.add_basemap(\"CartoDB.DarkMatter\")  m4.add_deckgl_layer(     layer_type=\"ScatterplotLayer\",     data=points,     name=\"scatterplot-generic\",     getPosition=\"coordinates\",     getRadius=100,     getFillColor=[138, 43, 226, 200],     radiusMinPixels=3,     radiusMaxPixels=30,     opacity=0.8, ) m4 In\u00a0[\u00a0]: Copied! <pre>m.to_html(\"scatterplot_layer_example.html\")\n</pre> m.to_html(\"scatterplot_layer_example.html\")"},{"location":"deckgl/scatterplot_layer/#scatterplot-layer-example","title":"Scatterplot Layer Example\u00b6","text":"<p>This notebook demonstrates the DeckGL ScatterplotLayer for visualizing point data.</p>"},{"location":"deckgl/scatterplot_layer/#basic-scatterplot-layer","title":"Basic Scatterplot Layer\u00b6","text":""},{"location":"deckgl/scatterplot_layer/#scatterplot-with-size-based-on-value","title":"Scatterplot with Size Based on Value\u00b6","text":""},{"location":"deckgl/scatterplot_layer/#multiple-scatterplot-layers-with-layer-control","title":"Multiple Scatterplot Layers with Layer Control\u00b6","text":""},{"location":"deckgl/scatterplot_layer/#using-the-generic-add_deckgl_layer-method","title":"Using the Generic add_deckgl_layer Method\u00b6","text":""},{"location":"deckgl/scatterplot_layer/#export-to-html","title":"Export to HTML\u00b6","text":""},{"location":"deckgl/scenegraph_layer/","title":"Scenegraph layer","text":"In\u00a0[\u00a0]: Copied! <pre># %pip install -U anymap-ts\n</pre> # %pip install -U anymap-ts In\u00a0[\u00a0]: Copied! <pre>from anymap_ts import DeckGLMap\n</pre> from anymap_ts import DeckGLMap In\u00a0[\u00a0]: Copied! <pre># Sample positions for glTF models\nmodel_positions = [\n    {\"coordinates\": [-122.4, 37.8, 0], \"orientation\": [0, 0, 90]},\n    {\"coordinates\": [-122.38, 37.79, 0], \"orientation\": [0, 0, 180]},\n    {\"coordinates\": [-122.42, 37.78, 0], \"orientation\": [0, 0, 270]},\n    {\"coordinates\": [-122.39, 37.81, 0], \"orientation\": [0, 0, 0]},\n    {\"coordinates\": [-122.41, 37.77, 0], \"orientation\": [0, 0, 45]},\n]\n</pre> # Sample positions for glTF models model_positions = [     {\"coordinates\": [-122.4, 37.8, 0], \"orientation\": [0, 0, 90]},     {\"coordinates\": [-122.38, 37.79, 0], \"orientation\": [0, 0, 180]},     {\"coordinates\": [-122.42, 37.78, 0], \"orientation\": [0, 0, 270]},     {\"coordinates\": [-122.39, 37.81, 0], \"orientation\": [0, 0, 0]},     {\"coordinates\": [-122.41, 37.77, 0], \"orientation\": [0, 0, 45]}, ] In\u00a0[\u00a0]: Copied! <pre>m = DeckGLMap(center=[-122.4, 37.79], zoom=13, pitch=60, bearing=-17)\nm.add_basemap(\"CartoDB.DarkMatter\")\n\nm.add_scenegraph_layer(\n    data=model_positions,\n    # Khronos glTF sample model\n    scenegraph=\"https://raw.githubusercontent.com/KhronosGroup/glTF-Sample-Models/master/2.0/Duck/glTF-Binary/Duck.glb\",\n    get_position=\"coordinates\",\n    get_orientation=\"orientation\",\n    size_scale=500,\n    pickable=True,\n)\nm\n</pre> m = DeckGLMap(center=[-122.4, 37.79], zoom=13, pitch=60, bearing=-17) m.add_basemap(\"CartoDB.DarkMatter\")  m.add_scenegraph_layer(     data=model_positions,     # Khronos glTF sample model     scenegraph=\"https://raw.githubusercontent.com/KhronosGroup/glTF-Sample-Models/master/2.0/Duck/glTF-Binary/Duck.glb\",     get_position=\"coordinates\",     get_orientation=\"orientation\",     size_scale=500,     pickable=True, ) m In\u00a0[\u00a0]: Copied! <pre>m.to_html(\"scenegraph_layer_example.html\")\n</pre> m.to_html(\"scenegraph_layer_example.html\")"},{"location":"deckgl/scenegraph_layer/#scenegraph-layer-example","title":"Scenegraph Layer Example\u00b6","text":"<p>glTF 3D model rendering using deck.gl ScenegraphLayer.</p>"},{"location":"deckgl/scenegraph_layer/#define-model-positions","title":"Define model positions\u00b6","text":""},{"location":"deckgl/scenegraph_layer/#create-map-with-scenegraph-layer","title":"Create map with scenegraph layer\u00b6","text":""},{"location":"deckgl/scenegraph_layer/#export-to-html","title":"Export to HTML\u00b6","text":""},{"location":"deckgl/simplemesh_layer/","title":"Simplemesh layer","text":"In\u00a0[\u00a0]: Copied! <pre># %pip install -U anymap-ts\n</pre> # %pip install -U anymap-ts In\u00a0[\u00a0]: Copied! <pre>from anymap_ts import DeckGLMap\n</pre> from anymap_ts import DeckGLMap In\u00a0[\u00a0]: Copied! <pre># Sample mesh data positions (locations for mesh instances)\nmesh_data = [\n    {\"position\": [-122.4, 37.8], \"color\": [255, 140, 0, 255]},\n    {\"position\": [-122.38, 37.79], \"color\": [0, 200, 255, 255]},\n    {\"position\": [-122.42, 37.78], \"color\": [255, 100, 100, 255]},\n    {\"position\": [-122.39, 37.81], \"color\": [100, 255, 100, 255]},\n    {\"position\": [-122.41, 37.77], \"color\": [200, 100, 255, 255]},\n]\n</pre> # Sample mesh data positions (locations for mesh instances) mesh_data = [     {\"position\": [-122.4, 37.8], \"color\": [255, 140, 0, 255]},     {\"position\": [-122.38, 37.79], \"color\": [0, 200, 255, 255]},     {\"position\": [-122.42, 37.78], \"color\": [255, 100, 100, 255]},     {\"position\": [-122.39, 37.81], \"color\": [100, 255, 100, 255]},     {\"position\": [-122.41, 37.77], \"color\": [200, 100, 255, 255]}, ] In\u00a0[\u00a0]: Copied! <pre># GLB model URL - using Khronos glTF sample models\nMODEL_URL = \"https://raw.githubusercontent.com/KhronosGroup/glTF-Sample-Models/master/2.0/Duck/glTF-Binary/Duck.glb\"\n\nm = DeckGLMap(center=[-122.4, 37.79], zoom=13, pitch=60, bearing=-17)\nm.add_basemap(\"CartoDB.DarkMatter\")\n\n# Use ScenegraphLayer for GLB/glTF models\nm.add_scenegraph_layer(\n    data=mesh_data,\n    scenegraph=MODEL_URL,\n    get_position=\"position\",\n    get_color=\"color\",\n    size_scale=500,\n    pickable=True,\n)\nm\n</pre> # GLB model URL - using Khronos glTF sample models MODEL_URL = \"https://raw.githubusercontent.com/KhronosGroup/glTF-Sample-Models/master/2.0/Duck/glTF-Binary/Duck.glb\"  m = DeckGLMap(center=[-122.4, 37.79], zoom=13, pitch=60, bearing=-17) m.add_basemap(\"CartoDB.DarkMatter\")  # Use ScenegraphLayer for GLB/glTF models m.add_scenegraph_layer(     data=mesh_data,     scenegraph=MODEL_URL,     get_position=\"position\",     get_color=\"color\",     size_scale=500,     pickable=True, ) m In\u00a0[\u00a0]: Copied! <pre>m.to_html(\"mesh_layer_example.html\")\n</pre> m.to_html(\"mesh_layer_example.html\")"},{"location":"deckgl/simplemesh_layer/#mesh-layers-example","title":"Mesh Layers Example\u00b6","text":"<p>deck.gl provides two main options for 3D mesh rendering:</p> <ol> <li>SimpleMeshLayer - For simple geometry primitives (spheres, cubes, etc.) created programmatically</li> <li>ScenegraphLayer - For loading and rendering glTF/GLB 3D models (recommended for external model files)</li> </ol> <p>This notebook demonstrates ScenegraphLayer which is the recommended approach for rendering 3D models from GLB/glTF files.</p>"},{"location":"deckgl/simplemesh_layer/#define-mesh-data-positions","title":"Define mesh data positions\u00b6","text":""},{"location":"deckgl/simplemesh_layer/#create-map-with-scenegraphlayer","title":"Create map with ScenegraphLayer\u00b6","text":"<p>Using a GLB model from deck.gl examples. ScenegraphLayer is the recommended way to render glTF/GLB models.</p>"},{"location":"deckgl/simplemesh_layer/#export-to-html","title":"Export to HTML\u00b6","text":"<p>If the widget doesn't render in the notebook, export to HTML and open in a browser.</p>"},{"location":"deckgl/solidpolygon_layer/","title":"Solidpolygon layer","text":"In\u00a0[\u00a0]: Copied! <pre># %pip install -U anymap-ts\n</pre> # %pip install -U anymap-ts In\u00a0[\u00a0]: Copied! <pre>from anymap_ts import DeckGLMap\n</pre> from anymap_ts import DeckGLMap In\u00a0[\u00a0]: Copied! <pre>polygons = [\n    {\n        \"polygon\": [\n            [-122.402, 37.795],\n            [-122.400, 37.795],\n            [-122.400, 37.793],\n            [-122.402, 37.793],\n        ],\n        \"elevation\": 200,\n        \"color\": [255, 140, 0, 200],\n    },\n    {\n        \"polygon\": [\n            [-122.398, 37.796],\n            [-122.395, 37.796],\n            [-122.395, 37.793],\n            [-122.398, 37.793],\n        ],\n        \"elevation\": 350,\n        \"color\": [0, 200, 255, 200],\n    },\n    {\n        \"polygon\": [\n            [-122.405, 37.790],\n            [-122.401, 37.790],\n            [-122.401, 37.787],\n            [-122.405, 37.787],\n        ],\n        \"elevation\": 150,\n        \"color\": [255, 100, 100, 200],\n    },\n]\n</pre> polygons = [     {         \"polygon\": [             [-122.402, 37.795],             [-122.400, 37.795],             [-122.400, 37.793],             [-122.402, 37.793],         ],         \"elevation\": 200,         \"color\": [255, 140, 0, 200],     },     {         \"polygon\": [             [-122.398, 37.796],             [-122.395, 37.796],             [-122.395, 37.793],             [-122.398, 37.793],         ],         \"elevation\": 350,         \"color\": [0, 200, 255, 200],     },     {         \"polygon\": [             [-122.405, 37.790],             [-122.401, 37.790],             [-122.401, 37.787],             [-122.405, 37.787],         ],         \"elevation\": 150,         \"color\": [255, 100, 100, 200],     }, ] In\u00a0[\u00a0]: Copied! <pre>m = DeckGLMap(center=[-122.4, 37.79], zoom=14, pitch=45, bearing=-17)\nm.add_basemap(\"CartoDB.DarkMatter\")\n\nm.add_solid_polygon_layer(\n    data=polygons,\n    get_polygon=\"polygon\",\n    get_elevation=\"elevation\",\n    get_fill_color=\"color\",\n    extruded=True,\n    elevation_scale=10,\n    pickable=True,\n)\nm\n</pre> m = DeckGLMap(center=[-122.4, 37.79], zoom=14, pitch=45, bearing=-17) m.add_basemap(\"CartoDB.DarkMatter\")  m.add_solid_polygon_layer(     data=polygons,     get_polygon=\"polygon\",     get_elevation=\"elevation\",     get_fill_color=\"color\",     extruded=True,     elevation_scale=10,     pickable=True, ) m In\u00a0[\u00a0]: Copied! <pre>m.to_html(\"solidpolygon_layer_example.html\")\n</pre> m.to_html(\"solidpolygon_layer_example.html\")"},{"location":"deckgl/solidpolygon_layer/#solid-polygon-layer-example","title":"Solid Polygon Layer Example\u00b6","text":"<p>Filled polygon visualization using deck.gl SolidPolygonLayer.</p>"},{"location":"deckgl/solidpolygon_layer/#define-polygon-data-building-footprints","title":"Define polygon data (building footprints)\u00b6","text":""},{"location":"deckgl/solidpolygon_layer/#create-map-with-solid-polygon-layer","title":"Create map with solid polygon layer\u00b6","text":""},{"location":"deckgl/solidpolygon_layer/#export-to-html","title":"Export to HTML\u00b6","text":""},{"location":"deckgl/terrain_layer/","title":"Terrain layer","text":"In\u00a0[\u00a0]: Copied! <pre># %pip install -U anymap-ts\n</pre> # %pip install -U anymap-ts In\u00a0[\u00a0]: Copied! <pre>from anymap_ts import DeckGLMap\n</pre> from anymap_ts import DeckGLMap In\u00a0[\u00a0]: Copied! <pre># Terrain-RGB elevation data URL template\nTERRAIN_URL = \"https://s3.amazonaws.com/elevation-tiles-prod/terrarium/{z}/{x}/{y}.png\"\n\n# Satellite imagery for texture\nTEXTURE_URL = \"https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}\"\n\nm = DeckGLMap(center=[-119.5, 37.7], zoom=10, pitch=60, bearing=30)  # Yosemite area\nm.add_basemap(\"CartoDB.DarkMatter\")\n\nm.add_terrain_layer(\n    elevation_data=TERRAIN_URL,\n    texture=TEXTURE_URL,\n    elevation_decoder={\n        \"rScaler\": 256,\n        \"gScaler\": 1,\n        \"bScaler\": 1 / 256,\n        \"offset\": -32768,\n    },\n    mesh_max_error=4,\n    opacity=1.0,\n)\nm\n</pre> # Terrain-RGB elevation data URL template TERRAIN_URL = \"https://s3.amazonaws.com/elevation-tiles-prod/terrarium/{z}/{x}/{y}.png\"  # Satellite imagery for texture TEXTURE_URL = \"https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}\"  m = DeckGLMap(center=[-119.5, 37.7], zoom=10, pitch=60, bearing=30)  # Yosemite area m.add_basemap(\"CartoDB.DarkMatter\")  m.add_terrain_layer(     elevation_data=TERRAIN_URL,     texture=TEXTURE_URL,     elevation_decoder={         \"rScaler\": 256,         \"gScaler\": 1,         \"bScaler\": 1 / 256,         \"offset\": -32768,     },     mesh_max_error=4,     opacity=1.0, ) m In\u00a0[\u00a0]: Copied! <pre>m.to_html(\"terrain_layer_example.html\")\n</pre> m.to_html(\"terrain_layer_example.html\")"},{"location":"deckgl/terrain_layer/#terrain-layer-example","title":"Terrain Layer Example\u00b6","text":"<p>3D terrain visualization using deck.gl TerrainLayer with elevation tiles.</p>"},{"location":"deckgl/terrain_layer/#create-a-3d-terrain-map","title":"Create a 3D terrain map\u00b6","text":""},{"location":"deckgl/terrain_layer/#export-to-html","title":"Export to HTML\u00b6","text":""},{"location":"deckgl/text_layer/","title":"Text layer","text":"In\u00a0[\u00a0]: Copied! <pre># %pip install -U anymap-ts\n</pre> # %pip install -U anymap-ts In\u00a0[\u00a0]: Copied! <pre>from anymap_ts import DeckGLMap\n\n# Bay Area city labels\ncities = [\n    {\"coordinates\": [-122.4194, 37.7749], \"text\": \"San Francisco\", \"size\": 24},\n    {\"coordinates\": [-122.2711, 37.8044], \"text\": \"Oakland\", \"size\": 20},\n    {\"coordinates\": [-122.2727, 37.8716], \"text\": \"Berkeley\", \"size\": 18},\n    {\"coordinates\": [-122.0322, 37.3688], \"text\": \"San Jose\", \"size\": 20},\n    {\"coordinates\": [-122.1430, 37.4419], \"text\": \"Palo Alto\", \"size\": 16},\n    {\"coordinates\": [-122.0096, 37.5485], \"text\": \"Fremont\", \"size\": 16},\n]\n\nm = DeckGLMap(center=[-122.3, 37.6], zoom=9)\nm.add_basemap(\"CartoDB.DarkMatter\")\nm.add_text_layer(\n    data=cities,\n    name=\"text-basic\",\n    get_position=\"coordinates\",\n    get_text=\"text\",\n    get_size=\"size\",\n    get_color=[255, 255, 255, 255],\n)\nm\n</pre> from anymap_ts import DeckGLMap  # Bay Area city labels cities = [     {\"coordinates\": [-122.4194, 37.7749], \"text\": \"San Francisco\", \"size\": 24},     {\"coordinates\": [-122.2711, 37.8044], \"text\": \"Oakland\", \"size\": 20},     {\"coordinates\": [-122.2727, 37.8716], \"text\": \"Berkeley\", \"size\": 18},     {\"coordinates\": [-122.0322, 37.3688], \"text\": \"San Jose\", \"size\": 20},     {\"coordinates\": [-122.1430, 37.4419], \"text\": \"Palo Alto\", \"size\": 16},     {\"coordinates\": [-122.0096, 37.5485], \"text\": \"Fremont\", \"size\": 16}, ]  m = DeckGLMap(center=[-122.3, 37.6], zoom=9) m.add_basemap(\"CartoDB.DarkMatter\") m.add_text_layer(     data=cities,     name=\"text-basic\",     get_position=\"coordinates\",     get_text=\"text\",     get_size=\"size\",     get_color=[255, 255, 255, 255], ) m In\u00a0[\u00a0]: Copied! <pre># Landmarks with colors\nlandmarks = [\n    {\n        \"coordinates\": [-122.4862, 37.8199],\n        \"text\": \"Golden Gate Bridge\",\n        \"size\": 16,\n        \"color\": [255, 200, 100],\n    },\n    {\n        \"coordinates\": [-122.4534, 37.8083],\n        \"text\": \"Alcatraz\",\n        \"size\": 14,\n        \"color\": [255, 150, 150],\n    },\n    {\n        \"coordinates\": [-122.3894, 37.6213],\n        \"text\": \"SFO Airport\",\n        \"size\": 14,\n        \"color\": [100, 200, 255],\n    },\n    {\n        \"coordinates\": [-122.4783, 37.8199],\n        \"text\": \"Sausalito\",\n        \"size\": 14,\n        \"color\": [200, 255, 200],\n    },\n    {\n        \"coordinates\": [-122.3894, 37.7866],\n        \"text\": \"Ferry Building\",\n        \"size\": 14,\n        \"color\": [255, 180, 100],\n    },\n]\n\nm2 = DeckGLMap(center=[-122.42, 37.79], zoom=11)\nm2.add_basemap(\"CartoDB.DarkMatter\")\nm2.add_text_layer(\n    data=landmarks,\n    name=\"text-styled\",\n    get_position=\"coordinates\",\n    get_text=\"text\",\n    get_size=\"size\",\n    get_color=\"color\",\n    font_family=\"Arial\",\n    font_weight=\"bold\",\n    outline_width=2,\n    outline_color=[0, 0, 0, 200],\n    size_min_pixels=10,\n    size_max_pixels=32,\n)\nm2\n</pre> # Landmarks with colors landmarks = [     {         \"coordinates\": [-122.4862, 37.8199],         \"text\": \"Golden Gate Bridge\",         \"size\": 16,         \"color\": [255, 200, 100],     },     {         \"coordinates\": [-122.4534, 37.8083],         \"text\": \"Alcatraz\",         \"size\": 14,         \"color\": [255, 150, 150],     },     {         \"coordinates\": [-122.3894, 37.6213],         \"text\": \"SFO Airport\",         \"size\": 14,         \"color\": [100, 200, 255],     },     {         \"coordinates\": [-122.4783, 37.8199],         \"text\": \"Sausalito\",         \"size\": 14,         \"color\": [200, 255, 200],     },     {         \"coordinates\": [-122.3894, 37.7866],         \"text\": \"Ferry Building\",         \"size\": 14,         \"color\": [255, 180, 100],     }, ]  m2 = DeckGLMap(center=[-122.42, 37.79], zoom=11) m2.add_basemap(\"CartoDB.DarkMatter\") m2.add_text_layer(     data=landmarks,     name=\"text-styled\",     get_position=\"coordinates\",     get_text=\"text\",     get_size=\"size\",     get_color=\"color\",     font_family=\"Arial\",     font_weight=\"bold\",     outline_width=2,     outline_color=[0, 0, 0, 200],     size_min_pixels=10,     size_max_pixels=32, ) m2 In\u00a0[\u00a0]: Copied! <pre>m3 = DeckGLMap(center=[-122.35, 37.7], zoom=10)\nm3.add_basemap(\"CartoDB.DarkMatter\")\n\nm3.add_text_layer(\n    data=cities,\n    name=\"text-cities\",\n    get_position=\"coordinates\",\n    get_text=\"text\",\n    get_size=\"size\",\n    get_color=[255, 255, 255, 255],\n)\n\nm3.add_text_layer(\n    data=landmarks,\n    name=\"text-landmarks\",\n    get_position=\"coordinates\",\n    get_text=\"text\",\n    get_size=\"size\",\n    get_color=\"color\",\n    outline_width=2,\n    outline_color=[0, 0, 0, 200],\n)\n\nm3.add_layer_control()\nm3\n</pre> m3 = DeckGLMap(center=[-122.35, 37.7], zoom=10) m3.add_basemap(\"CartoDB.DarkMatter\")  m3.add_text_layer(     data=cities,     name=\"text-cities\",     get_position=\"coordinates\",     get_text=\"text\",     get_size=\"size\",     get_color=[255, 255, 255, 255], )  m3.add_text_layer(     data=landmarks,     name=\"text-landmarks\",     get_position=\"coordinates\",     get_text=\"text\",     get_size=\"size\",     get_color=\"color\",     outline_width=2,     outline_color=[0, 0, 0, 200], )  m3.add_layer_control() m3 In\u00a0[\u00a0]: Copied! <pre>m4 = DeckGLMap(center=[-122.3, 37.6], zoom=9)\nm4.add_basemap(\"CartoDB.DarkMatter\")\n\nm4.add_deckgl_layer(\n    layer_type=\"TextLayer\",\n    data=cities,\n    name=\"text-generic\",\n    getPosition=\"coordinates\",\n    getText=\"text\",\n    getSize=\"size\",\n    getColor=[255, 200, 100, 255],\n    fontFamily=\"Arial\",\n    fontWeight=\"bold\",\n    outlineWidth=2,\n    outlineColor=[0, 0, 0, 200],\n    billboard=True,\n)\nm4\n</pre> m4 = DeckGLMap(center=[-122.3, 37.6], zoom=9) m4.add_basemap(\"CartoDB.DarkMatter\")  m4.add_deckgl_layer(     layer_type=\"TextLayer\",     data=cities,     name=\"text-generic\",     getPosition=\"coordinates\",     getText=\"text\",     getSize=\"size\",     getColor=[255, 200, 100, 255],     fontFamily=\"Arial\",     fontWeight=\"bold\",     outlineWidth=2,     outlineColor=[0, 0, 0, 200],     billboard=True, ) m4 In\u00a0[\u00a0]: Copied! <pre>m.to_html(\"text_layer_example.html\")\n</pre> m.to_html(\"text_layer_example.html\")"},{"location":"deckgl/text_layer/#text-layer-example","title":"Text Layer Example\u00b6","text":"<p>This notebook demonstrates the DeckGL TextLayer for rendering dynamic text labels on maps.</p>"},{"location":"deckgl/text_layer/#basic-text-layer","title":"Basic Text Layer\u00b6","text":""},{"location":"deckgl/text_layer/#text-layer-with-outline-and-styling","title":"Text Layer with Outline and Styling\u00b6","text":""},{"location":"deckgl/text_layer/#multiple-text-layers-with-layer-control","title":"Multiple Text Layers with Layer Control\u00b6","text":""},{"location":"deckgl/text_layer/#using-the-generic-add_deckgl_layer-method","title":"Using the Generic add_deckgl_layer Method\u00b6","text":""},{"location":"deckgl/text_layer/#export-to-html","title":"Export to HTML\u00b6","text":""},{"location":"deckgl/tile3d_layer/","title":"Tile3d layer","text":"In\u00a0[\u00a0]: Copied! <pre># %pip install -U anymap-ts\n</pre> # %pip install -U anymap-ts In\u00a0[\u00a0]: Copied! <pre>from anymap_ts import DeckGLMap\n</pre> from anymap_ts import DeckGLMap In\u00a0[\u00a0]: Copied! <pre># Public 3D Tiles dataset from loaders.gl test data\nTILESET_URL = \"https://raw.githubusercontent.com/visgl/loaders.gl/master/modules/3d-tiles/test/data/CesiumJS/Batched/BatchedColors/tileset.json\"\n\nm = DeckGLMap(center=[0, 0], zoom=16, pitch=60, bearing=-17)\nm.add_basemap(\"CartoDB.DarkMatter\")\n\n# Add a 3D Tiles dataset\nm.add_tile3d_layer(\n    data=TILESET_URL,\n    opacity=1.0,\n    point_size=2,\n)\nm\n</pre> # Public 3D Tiles dataset from loaders.gl test data TILESET_URL = \"https://raw.githubusercontent.com/visgl/loaders.gl/master/modules/3d-tiles/test/data/CesiumJS/Batched/BatchedColors/tileset.json\"  m = DeckGLMap(center=[0, 0], zoom=16, pitch=60, bearing=-17) m.add_basemap(\"CartoDB.DarkMatter\")  # Add a 3D Tiles dataset m.add_tile3d_layer(     data=TILESET_URL,     opacity=1.0,     point_size=2, ) m In\u00a0[\u00a0]: Copied! <pre>m.to_html(\"tile3d_layer_example.html\")\n</pre> m.to_html(\"tile3d_layer_example.html\")"},{"location":"deckgl/tile3d_layer/#3d-tiles-layer-example","title":"3D Tiles Layer Example\u00b6","text":"<p>OGC 3D Tiles visualization using deck.gl Tile3DLayer.</p>"},{"location":"deckgl/tile3d_layer/#create-a-map-with-3d-tiles","title":"Create a map with 3D Tiles\u00b6","text":""},{"location":"deckgl/tile3d_layer/#export-to-html","title":"Export to HTML\u00b6","text":""},{"location":"deckgl/tile_layer/","title":"Tile layer","text":"In\u00a0[\u00a0]: Copied! <pre># %pip install -U anymap-ts\n</pre> # %pip install -U anymap-ts In\u00a0[\u00a0]: Copied! <pre>from anymap_ts import DeckGLMap\n</pre> from anymap_ts import DeckGLMap In\u00a0[\u00a0]: Copied! <pre>m = DeckGLMap(center=[-122.4, 37.8], zoom=10)\nm.add_basemap(\"CartoDB.DarkMatter\")\n\n# Add OpenStreetMap tiles as a tile layer\nm.add_tile_layer(\n    data=\"https://tile.openstreetmap.org/{z}/{x}/{y}.png\",\n    min_zoom=0,\n    max_zoom=19,\n    tile_size=256,\n    opacity=0.7,\n)\nm\n</pre> m = DeckGLMap(center=[-122.4, 37.8], zoom=10) m.add_basemap(\"CartoDB.DarkMatter\")  # Add OpenStreetMap tiles as a tile layer m.add_tile_layer(     data=\"https://tile.openstreetmap.org/{z}/{x}/{y}.png\",     min_zoom=0,     max_zoom=19,     tile_size=256,     opacity=0.7, ) m In\u00a0[\u00a0]: Copied! <pre>m.to_html(\"tile_layer_example.html\")\n</pre> m.to_html(\"tile_layer_example.html\")"},{"location":"deckgl/tile_layer/#tile-layer-example","title":"Tile Layer Example\u00b6","text":"<p>Custom tile layer rendering using deck.gl TileLayer.</p>"},{"location":"deckgl/tile_layer/#create-a-map-with-a-tile-layer","title":"Create a map with a tile layer\u00b6","text":""},{"location":"deckgl/tile_layer/#export-to-html","title":"Export to HTML\u00b6","text":""},{"location":"deckgl/trips_layer/","title":"Trips layer","text":"In\u00a0[\u00a0]: Copied! <pre># %pip install -U anymap-ts\n</pre> # %pip install -U anymap-ts In\u00a0[\u00a0]: Copied! <pre>from anymap_ts import DeckGLMap\n\n# Sample trip data with waypoints and timestamps\ntrips = [\n    {\n        \"waypoints\": [\n            [-122.45, 37.78],\n            [-122.42, 37.79],\n            [-122.40, 37.78],\n            [-122.38, 37.80],\n            [-122.35, 37.79],\n        ],\n        \"timestamps\": [0, 30, 60, 90, 120],\n        \"name\": \"Trip 1\",\n    },\n    {\n        \"waypoints\": [\n            [-122.50, 37.75],\n            [-122.47, 37.77],\n            [-122.44, 37.76],\n            [-122.41, 37.78],\n            [-122.38, 37.77],\n        ],\n        \"timestamps\": [10, 40, 70, 100, 130],\n        \"name\": \"Trip 2\",\n    },\n    {\n        \"waypoints\": [\n            [-122.43, 37.82],\n            [-122.41, 37.80],\n            [-122.39, 37.78],\n            [-122.37, 37.76],\n            [-122.35, 37.74],\n        ],\n        \"timestamps\": [20, 50, 80, 110, 140],\n        \"name\": \"Trip 3\",\n    },\n]\n\nm = DeckGLMap(center=[-122.42, 37.78], zoom=12)\nm.add_basemap(\"CartoDB.DarkMatter\")\nm.add_trips_layer(\n    data=trips,\n    name=\"trips-basic\",\n    get_path=\"waypoints\",\n    get_timestamps=\"timestamps\",\n    get_color=[253, 128, 93],\n    width_min_pixels=3,\n    trail_length=180,\n    current_time=60,  # Show trails up to time=60\n)\nm\n</pre> from anymap_ts import DeckGLMap  # Sample trip data with waypoints and timestamps trips = [     {         \"waypoints\": [             [-122.45, 37.78],             [-122.42, 37.79],             [-122.40, 37.78],             [-122.38, 37.80],             [-122.35, 37.79],         ],         \"timestamps\": [0, 30, 60, 90, 120],         \"name\": \"Trip 1\",     },     {         \"waypoints\": [             [-122.50, 37.75],             [-122.47, 37.77],             [-122.44, 37.76],             [-122.41, 37.78],             [-122.38, 37.77],         ],         \"timestamps\": [10, 40, 70, 100, 130],         \"name\": \"Trip 2\",     },     {         \"waypoints\": [             [-122.43, 37.82],             [-122.41, 37.80],             [-122.39, 37.78],             [-122.37, 37.76],             [-122.35, 37.74],         ],         \"timestamps\": [20, 50, 80, 110, 140],         \"name\": \"Trip 3\",     }, ]  m = DeckGLMap(center=[-122.42, 37.78], zoom=12) m.add_basemap(\"CartoDB.DarkMatter\") m.add_trips_layer(     data=trips,     name=\"trips-basic\",     get_path=\"waypoints\",     get_timestamps=\"timestamps\",     get_color=[253, 128, 93],     width_min_pixels=3,     trail_length=180,     current_time=60,  # Show trails up to time=60 ) m In\u00a0[\u00a0]: Copied! <pre># Trips with individual colors\ncolored_trips = [\n    {\n        \"waypoints\": trips[0][\"waypoints\"],\n        \"timestamps\": trips[0][\"timestamps\"],\n        \"color\": [255, 100, 100],  # Red\n    },\n    {\n        \"waypoints\": trips[1][\"waypoints\"],\n        \"timestamps\": trips[1][\"timestamps\"],\n        \"color\": [100, 255, 100],  # Green\n    },\n    {\n        \"waypoints\": trips[2][\"waypoints\"],\n        \"timestamps\": trips[2][\"timestamps\"],\n        \"color\": [100, 100, 255],  # Blue\n    },\n]\n\nm2 = DeckGLMap(center=[-122.42, 37.78], zoom=12)\nm2.add_basemap(\"CartoDB.DarkMatter\")\nm2.add_trips_layer(\n    data=colored_trips,\n    name=\"trips-colored\",\n    get_path=\"waypoints\",\n    get_timestamps=\"timestamps\",\n    get_color=\"color\",  # Use color property from data\n    width_min_pixels=4,\n    trail_length=200,\n    current_time=80,\n)\nm2\n</pre> # Trips with individual colors colored_trips = [     {         \"waypoints\": trips[0][\"waypoints\"],         \"timestamps\": trips[0][\"timestamps\"],         \"color\": [255, 100, 100],  # Red     },     {         \"waypoints\": trips[1][\"waypoints\"],         \"timestamps\": trips[1][\"timestamps\"],         \"color\": [100, 255, 100],  # Green     },     {         \"waypoints\": trips[2][\"waypoints\"],         \"timestamps\": trips[2][\"timestamps\"],         \"color\": [100, 100, 255],  # Blue     }, ]  m2 = DeckGLMap(center=[-122.42, 37.78], zoom=12) m2.add_basemap(\"CartoDB.DarkMatter\") m2.add_trips_layer(     data=colored_trips,     name=\"trips-colored\",     get_path=\"waypoints\",     get_timestamps=\"timestamps\",     get_color=\"color\",  # Use color property from data     width_min_pixels=4,     trail_length=200,     current_time=80, ) m2 In\u00a0[\u00a0]: Copied! <pre>m3 = DeckGLMap(center=[-122.42, 37.78], zoom=12)\nm3.add_basemap(\"CartoDB.DarkMatter\")\n\n# Add trips layer using the generic method\nm3.add_deckgl_layer(\n    layer_type=\"TripsLayer\",\n    data=trips,\n    name=\"trips-generic\",\n    getPath=\"waypoints\",\n    getTimestamps=\"timestamps\",\n    getColor=[255, 200, 0],  # Orange\n    widthMinPixels=3,\n    trailLength=150,\n    currentTime=100,\n)\nm3\n</pre> m3 = DeckGLMap(center=[-122.42, 37.78], zoom=12) m3.add_basemap(\"CartoDB.DarkMatter\")  # Add trips layer using the generic method m3.add_deckgl_layer(     layer_type=\"TripsLayer\",     data=trips,     name=\"trips-generic\",     getPath=\"waypoints\",     getTimestamps=\"timestamps\",     getColor=[255, 200, 0],  # Orange     widthMinPixels=3,     trailLength=150,     currentTime=100, ) m3 In\u00a0[\u00a0]: Copied! <pre>m4 = DeckGLMap(center=[-122.42, 37.78], zoom=12)\nm4.add_basemap(\"CartoDB.DarkMatter\")\n\nm4.add_trips_layer(\n    data=trips,\n    name=\"trips-animated\",\n    trail_length=180,\n    current_time=90,\n)\n\nm4.add_layer_control()\nm4\n</pre> m4 = DeckGLMap(center=[-122.42, 37.78], zoom=12) m4.add_basemap(\"CartoDB.DarkMatter\")  m4.add_trips_layer(     data=trips,     name=\"trips-animated\",     trail_length=180,     current_time=90, )  m4.add_layer_control() m4 In\u00a0[\u00a0]: Copied! <pre>m.to_html(\"trips_layer_example.html\")\n</pre> m.to_html(\"trips_layer_example.html\")"},{"location":"deckgl/trips_layer/#trips-layer-example","title":"Trips Layer Example\u00b6","text":"<p>This notebook demonstrates the DeckGL TripsLayer for animated path visualization.</p> <p>Trips layers are ideal for:</p> <ul> <li>Visualizing vehicle routes over time</li> <li>Animation of movement patterns</li> <li>GPS trajectory visualization</li> <li>Time-based path analysis</li> </ul>"},{"location":"deckgl/trips_layer/#basic-trips-layer","title":"Basic Trips Layer\u00b6","text":""},{"location":"deckgl/trips_layer/#trips-layer-with-different-colors","title":"Trips Layer with Different Colors\u00b6","text":""},{"location":"deckgl/trips_layer/#using-the-generic-add_deckgl_layer-method","title":"Using the Generic add_deckgl_layer Method\u00b6","text":""},{"location":"deckgl/trips_layer/#trips-layer-with-layer-control","title":"Trips Layer with Layer Control\u00b6","text":""},{"location":"deckgl/trips_layer/#export-to-html","title":"Export to HTML\u00b6","text":""},{"location":"deckgl/wms_layer/","title":"Wms layer","text":"In\u00a0[\u00a0]: Copied! <pre># %pip install -U anymap-ts\n</pre> # %pip install -U anymap-ts In\u00a0[\u00a0]: Copied! <pre>from anymap_ts import DeckGLMap\n</pre> from anymap_ts import DeckGLMap In\u00a0[\u00a0]: Copied! <pre>m = DeckGLMap(center=[-95, 40], zoom=4)\nm.add_basemap(\"CartoDB.DarkMatter\")\n\n# Add NOAA Weather Radar WMS\nm.add_wms_layer(\n    data=\"https://mesonet.agron.iastate.edu/cgi-bin/wms/nexrad/n0r.cgi\",\n    service_type=\"wms\",\n    layers=[\"nexrad-n0r\"],\n    opacity=0.8,\n)\nm\n</pre> m = DeckGLMap(center=[-95, 40], zoom=4) m.add_basemap(\"CartoDB.DarkMatter\")  # Add NOAA Weather Radar WMS m.add_wms_layer(     data=\"https://mesonet.agron.iastate.edu/cgi-bin/wms/nexrad/n0r.cgi\",     service_type=\"wms\",     layers=[\"nexrad-n0r\"],     opacity=0.8, ) m In\u00a0[\u00a0]: Copied! <pre>m.to_html(\"wms_layer_example.html\")\n</pre> m.to_html(\"wms_layer_example.html\")"},{"location":"deckgl/wms_layer/#wms-layer-example","title":"WMS Layer Example\u00b6","text":"<p>Web Map Service integration using deck.gl WMSLayer.</p>"},{"location":"deckgl/wms_layer/#create-a-map-with-wms-layer","title":"Create a map with WMS layer\u00b6","text":""},{"location":"deckgl/wms_layer/#export-to-html","title":"Export to HTML\u00b6","text":""},{"location":"keplergl/keplergl/","title":"Keplergl","text":"In\u00a0[\u00a0]: Copied! <pre># %pip install -U anymap-ts\n</pre> # %pip install -U anymap-ts In\u00a0[\u00a0]: Copied! <pre>from anymap_ts import KeplerGLMap\nimport pandas as pd\n\n# Create a KeplerGL map\nm = KeplerGLMap(center=[-122.4, 37.8], zoom=10)\nm\n</pre> from anymap_ts import KeplerGLMap import pandas as pd  # Create a KeplerGL map m = KeplerGLMap(center=[-122.4, 37.8], zoom=10) m In\u00a0[\u00a0]: Copied! <pre># Create sample data\nimport random\n\ndf = pd.DataFrame(\n    {\n        \"latitude\": [37.8 + random.uniform(-0.2, 0.2) for _ in range(100)],\n        \"longitude\": [-122.4 + random.uniform(-0.2, 0.2) for _ in range(100)],\n        \"value\": [random.randint(1, 100) for _ in range(100)],\n        \"category\": [random.choice([\"A\", \"B\", \"C\"]) for _ in range(100)],\n    }\n)\n\n# Add data to map\nm.add_data(df, name=\"sample_points\")\n</pre> # Create sample data import random  df = pd.DataFrame(     {         \"latitude\": [37.8 + random.uniform(-0.2, 0.2) for _ in range(100)],         \"longitude\": [-122.4 + random.uniform(-0.2, 0.2) for _ in range(100)],         \"value\": [random.randint(1, 100) for _ in range(100)],         \"category\": [random.choice([\"A\", \"B\", \"C\"]) for _ in range(100)],     } )  # Add data to map m.add_data(df, name=\"sample_points\") In\u00a0[\u00a0]: Copied! <pre># Add GeoJSON data\ngeojson = {\n    \"type\": \"FeatureCollection\",\n    \"features\": [\n        {\n            \"type\": \"Feature\",\n            \"geometry\": {\n                \"type\": \"Polygon\",\n                \"coordinates\": [\n                    [\n                        [-122.5, 37.7],\n                        [-122.3, 37.7],\n                        [-122.3, 37.9],\n                        [-122.5, 37.9],\n                        [-122.5, 37.7],\n                    ]\n                ],\n            },\n            \"properties\": {\"name\": \"Area\"},\n        }\n    ],\n}\n\nm.add_data(geojson, name=\"polygon\")\n</pre> # Add GeoJSON data geojson = {     \"type\": \"FeatureCollection\",     \"features\": [         {             \"type\": \"Feature\",             \"geometry\": {                 \"type\": \"Polygon\",                 \"coordinates\": [                     [                         [-122.5, 37.7],                         [-122.3, 37.7],                         [-122.3, 37.9],                         [-122.5, 37.9],                         [-122.5, 37.7],                     ]                 ],             },             \"properties\": {\"name\": \"Area\"},         }     ], }  m.add_data(geojson, name=\"polygon\") In\u00a0[\u00a0]: Copied! <pre># Export to HTML (limited interactivity)\nm.to_html(\"keplergl_example.html\")\n</pre> # Export to HTML (limited interactivity) m.to_html(\"keplergl_example.html\")"},{"location":"keplergl/keplergl/#keplergl-example","title":"KeplerGL Example\u00b6","text":"<p>This notebook demonstrates the KeplerGL integration in anymap-ts.</p> <p>KeplerGL is a powerful data exploration tool built on deck.gl.</p> <p>Note: For best results, use the anywidget interface in Jupyter. HTML export has limited interactivity.</p>"},{"location":"leaflet/leaflet/","title":"Leaflet","text":"In\u00a0[\u00a0]: Copied! <pre># %pip install -U anymap-ts\n</pre> # %pip install -U anymap-ts In\u00a0[\u00a0]: Copied! <pre>from anymap_ts import LeafletMap\n\n# Create a Leaflet map\nm = LeafletMap(center=[-122.4, 37.8], zoom=10)\nm.add_basemap(\"OpenStreetMap\")\nm.add_control(\"zoom\", position=\"top-right\")\nm\n</pre> from anymap_ts import LeafletMap  # Create a Leaflet map m = LeafletMap(center=[-122.4, 37.8], zoom=10) m.add_basemap(\"OpenStreetMap\") m.add_control(\"zoom\", position=\"top-right\") m In\u00a0[\u00a0]: Copied! <pre># Add markers\nm.add_marker(-122.4194, 37.7749, popup=\"San Francisco\")\nm.add_marker(-122.2712, 37.8044, popup=\"Oakland\")\n</pre> # Add markers m.add_marker(-122.4194, 37.7749, popup=\"San Francisco\") m.add_marker(-122.2712, 37.8044, popup=\"Oakland\") In\u00a0[\u00a0]: Copied! <pre># Add GeoJSON\ngeojson = {\n    \"type\": \"FeatureCollection\",\n    \"features\": [\n        {\n            \"type\": \"Feature\",\n            \"geometry\": {\n                \"type\": \"Polygon\",\n                \"coordinates\": [\n                    [\n                        [-122.5, 37.7],\n                        [-122.3, 37.7],\n                        [-122.3, 37.9],\n                        [-122.5, 37.9],\n                        [-122.5, 37.7],\n                    ]\n                ],\n            },\n            \"properties\": {\"name\": \"Area\"},\n        }\n    ],\n}\n\nm.add_geojson(geojson, name=\"polygon\")\n</pre> # Add GeoJSON geojson = {     \"type\": \"FeatureCollection\",     \"features\": [         {             \"type\": \"Feature\",             \"geometry\": {                 \"type\": \"Polygon\",                 \"coordinates\": [                     [                         [-122.5, 37.7],                         [-122.3, 37.7],                         [-122.3, 37.9],                         [-122.5, 37.9],                         [-122.5, 37.7],                     ]                 ],             },             \"properties\": {\"name\": \"Area\"},         }     ], }  m.add_geojson(geojson, name=\"polygon\") In\u00a0[\u00a0]: Copied! <pre># Export to HTML\nm.to_html(\"leaflet_example.html\")\n</pre> # Export to HTML m.to_html(\"leaflet_example.html\")"},{"location":"leaflet/leaflet/#leaflet-example","title":"Leaflet Example\u00b6","text":"<p>This notebook demonstrates the Leaflet integration in anymap-ts.</p> <p>Leaflet is a lightweight, open-source JavaScript library for mobile-friendly interactive maps.</p>"},{"location":"mapbox/choropleth/","title":"Choropleth","text":"In\u00a0[\u00a0]: Copied! <pre># %pip install -U anymap-ts\n</pre> # %pip install -U anymap-ts In\u00a0[\u00a0]: Copied! <pre>from anymap_ts import MapboxMap\n\nm = MapboxMap(center=[-98, 39], zoom=4)\n\nus_states_url = \"https://raw.githubusercontent.com/PublicaMundi/MappingAPI/master/data/geojson/us-states.json\"\nm.add_choropleth(\n    us_states_url,\n    column=\"density\",\n    cmap=\"YlOrRd\",\n    legend=True,\n    legend_title=\"Population Density\",\n)\nm\n</pre> from anymap_ts import MapboxMap  m = MapboxMap(center=[-98, 39], zoom=4)  us_states_url = \"https://raw.githubusercontent.com/PublicaMundi/MappingAPI/master/data/geojson/us-states.json\" m.add_choropleth(     us_states_url,     column=\"density\",     cmap=\"YlOrRd\",     legend=True,     legend_title=\"Population Density\", ) m In\u00a0[\u00a0]: Copied! <pre># Legend is already added above. You can add a standalone legend for other layers:\n# m.add_legend(title=\"Custom\", labels=[\"A\", \"B\"], colors=[[255,0,0], [0,255,0]])\n</pre> # Legend is already added above. You can add a standalone legend for other layers: # m.add_legend(title=\"Custom\", labels=[\"A\", \"B\"], colors=[[255,0,0], [0,255,0]])"},{"location":"mapbox/choropleth/#mapbox-choropleth-maps","title":"Mapbox - Choropleth Maps\u00b6","text":"<p>Thematic maps with color-coded polygons and legend.</p>"},{"location":"mapbox/choropleth/#load-us-states-and-create-choropleth","title":"Load US States and Create Choropleth\u00b6","text":"<p>US states GeoJSON with population density, styled with YlOrRd colormap.</p>"},{"location":"mapbox/choropleth/#legend-integration","title":"Legend Integration\u00b6","text":"<p>The choropleth automatically adds a legend when <code>legend=True</code>. Customize with <code>legend_title</code>.</p>"},{"location":"mapbox/cog_layer/","title":"Cog layer","text":"In\u00a0[\u00a0]: Copied! <pre># %pip install -U anymap-ts\n</pre> # %pip install -U anymap-ts In\u00a0[\u00a0]: Copied! <pre>from anymap_ts import MapboxMap\n\nm = MapboxMap(\n    center=[-98, 39],\n    zoom=4,\n    style=\"mapbox://styles/mapbox/satellite-streets-v12\",\n)\n\ncog_url = \"https://s3.us-east-1.amazonaws.com/ds-deck.gl-raster-public/cog/Annual_NLCD_LndCov_2024_CU_C1V1.tif\"\nm.add_cog_layer(cog_url, name=\"nlcd\", opacity=0.8)\nm\n</pre> from anymap_ts import MapboxMap  m = MapboxMap(     center=[-98, 39],     zoom=4,     style=\"mapbox://styles/mapbox/satellite-streets-v12\", )  cog_url = \"https://s3.us-east-1.amazonaws.com/ds-deck.gl-raster-public/cog/Annual_NLCD_LndCov_2024_CU_C1V1.tif\" m.add_cog_layer(cog_url, name=\"nlcd\", opacity=0.8) m In\u00a0[\u00a0]: Copied! <pre>m.set_opacity(\"nlcd\", 0.5)\n</pre> m.set_opacity(\"nlcd\", 0.5) In\u00a0[\u00a0]: Copied! <pre>m.remove_cog_layer(\"nlcd\")\n</pre> m.remove_cog_layer(\"nlcd\")"},{"location":"mapbox/cog_layer/#mapbox-cog-layers","title":"Mapbox - COG Layers\u00b6","text":"<p>Cloud Optimized GeoTIFF (COG) layers for raster visualization.</p>"},{"location":"mapbox/cog_layer/#add-cog-layer","title":"Add COG Layer\u00b6","text":"<p>NLCD Land Cover data from AWS.</p>"},{"location":"mapbox/cog_layer/#opacity-control","title":"Opacity Control\u00b6","text":"<p>Adjust COG layer opacity.</p>"},{"location":"mapbox/cog_layer/#remove-cog-layer","title":"Remove COG Layer\u00b6","text":""},{"location":"mapbox/deck_layers/","title":"Deck layers","text":"In\u00a0[\u00a0]: Copied! <pre># %pip install -U anymap-ts\n</pre> # %pip install -U anymap-ts In\u00a0[\u00a0]: Copied! <pre>from anymap_ts import MapboxMap\n\nm = MapboxMap(center=[-122.4, 37.8], zoom=10, style=\"mapbox://styles/mapbox/dark-v11\")\nm\n</pre> from anymap_ts import MapboxMap  m = MapboxMap(center=[-122.4, 37.8], zoom=10, style=\"mapbox://styles/mapbox/dark-v11\") m In\u00a0[\u00a0]: Copied! <pre>import random\n\npoints = [\n    {\n        \"coordinates\": [\n            -122.4 + random.uniform(-0.1, 0.1),\n            37.8 + random.uniform(-0.1, 0.1),\n        ]\n    }\n    for _ in range(50)\n]\nm.add_scatterplot_layer(points, name=\"scatter\", get_radius=100)\nm\n</pre> import random  points = [     {         \"coordinates\": [             -122.4 + random.uniform(-0.1, 0.1),             37.8 + random.uniform(-0.1, 0.1),         ]     }     for _ in range(50) ] m.add_scatterplot_layer(points, name=\"scatter\", get_radius=100) m In\u00a0[\u00a0]: Copied! <pre>routes = [\n    {\n        \"path\": [[-122.4, 37.8], [-122.3, 37.85], [-122.2, 37.8]],\n        \"name\": \"Route 1\",\n    },\n    {\n        \"path\": [[-122.35, 37.75], [-122.25, 37.82]],\n        \"name\": \"Route 2\",\n    },\n]\nm.add_path_layer(routes, name=\"paths\", get_width=3)\nm\n</pre> routes = [     {         \"path\": [[-122.4, 37.8], [-122.3, 37.85], [-122.2, 37.8]],         \"name\": \"Route 1\",     },     {         \"path\": [[-122.35, 37.75], [-122.25, 37.82]],         \"name\": \"Route 2\",     }, ] m.add_path_layer(routes, name=\"paths\", get_width=3) m In\u00a0[\u00a0]: Copied! <pre>polygons = [\n    {\n        \"polygon\": [\n            [-122.42, 37.78],\n            [-122.38, 37.78],\n            [-122.38, 37.82],\n            [-122.42, 37.82],\n            [-122.42, 37.78],\n        ],\n        \"elevation\": 5000,\n    },\n]\nm.add_polygon_layer(polygons, name=\"extruded\", extruded=True, get_elevation=\"elevation\")\nm\n</pre> polygons = [     {         \"polygon\": [             [-122.42, 37.78],             [-122.38, 37.78],             [-122.38, 37.82],             [-122.42, 37.82],             [-122.42, 37.78],         ],         \"elevation\": 5000,     }, ] m.add_polygon_layer(polygons, name=\"extruded\", extruded=True, get_elevation=\"elevation\") m In\u00a0[\u00a0]: Copied! <pre>hex_data = [\n    {\"coordinates\": [-122.4 + i * 0.02, 37.8 + j * 0.02]}\n    for i in range(10)\n    for j in range(10)\n]\nm.add_hexagon_layer(hex_data, name=\"hexagons\", radius=500, elevation_scale=50)\nm\n</pre> hex_data = [     {\"coordinates\": [-122.4 + i * 0.02, 37.8 + j * 0.02]}     for i in range(10)     for j in range(10) ] m.add_hexagon_layer(hex_data, name=\"hexagons\", radius=500, elevation_scale=50) m In\u00a0[\u00a0]: Copied! <pre>grid_data = [{\"coordinates\": [-122.4 + i * 0.01, 37.8]} for i in range(20)]\nm.add_grid_layer(grid_data, name=\"grid\", cell_size=300)\nm\n</pre> grid_data = [{\"coordinates\": [-122.4 + i * 0.01, 37.8]} for i in range(20)] m.add_grid_layer(grid_data, name=\"grid\", cell_size=300) m In\u00a0[\u00a0]: Copied! <pre>heatmap_points = [\n    {\"coordinates\": [-122.4 + i * 0.02, 37.8], \"weight\": 1} for i in range(30)\n]\nm.add_deck_heatmap_layer(heatmap_points, name=\"deck-heatmap\", radius_pixels=50)\nm\n</pre> heatmap_points = [     {\"coordinates\": [-122.4 + i * 0.02, 37.8], \"weight\": 1} for i in range(30) ] m.add_deck_heatmap_layer(heatmap_points, name=\"deck-heatmap\", radius_pixels=50) m In\u00a0[\u00a0]: Copied! <pre>text_data = [\n    {\"coordinates\": [-122.4194, 37.7749], \"text\": \"SF\"},\n    {\"coordinates\": [-122.2712, 37.8044], \"text\": \"Oakland\"},\n]\nm.add_text_layer(text_data, name=\"labels\", get_size=14)\nm\n</pre> text_data = [     {\"coordinates\": [-122.4194, 37.7749], \"text\": \"SF\"},     {\"coordinates\": [-122.2712, 37.8044], \"text\": \"Oakland\"}, ] m.add_text_layer(text_data, name=\"labels\", get_size=14) m In\u00a0[\u00a0]: Copied! <pre>lines = [\n    {\"sourcePosition\": [-122.4, 37.8], \"targetPosition\": [-122.3, 37.85]},\n    {\"sourcePosition\": [-122.3, 37.85], \"targetPosition\": [-122.2, 37.8]},\n]\nm.add_line_layer(lines, name=\"lines\", get_width=2)\nm\n</pre> lines = [     {\"sourcePosition\": [-122.4, 37.8], \"targetPosition\": [-122.3, 37.85]},     {\"sourcePosition\": [-122.3, 37.85], \"targetPosition\": [-122.2, 37.8]}, ] m.add_line_layer(lines, name=\"lines\", get_width=2) m In\u00a0[\u00a0]: Copied! <pre>contour_data = [\n    {\"coordinates\": [-122.4, 37.8], \"value\": 100},\n    {\"coordinates\": [-122.35, 37.82], \"value\": 150},\n    {\"coordinates\": [-122.3, 37.8], \"value\": 120},\n]\nm.add_contour_layer(\n    contour_data, name=\"contour\", get_position=\"coordinates\", get_weight=\"value\"\n)\nm\n</pre> contour_data = [     {\"coordinates\": [-122.4, 37.8], \"value\": 100},     {\"coordinates\": [-122.35, 37.82], \"value\": 150},     {\"coordinates\": [-122.3, 37.8], \"value\": 120}, ] m.add_contour_layer(     contour_data, name=\"contour\", get_position=\"coordinates\", get_weight=\"value\" ) m In\u00a0[\u00a0]: Copied! <pre>screen_data = [{\"coordinates\": [-122.4 + i * 0.02, 37.8]} for i in range(15)]\nm.add_screen_grid_layer(screen_data, name=\"screengrid\", cell_size_pixels=50)\nm\n</pre> screen_data = [{\"coordinates\": [-122.4 + i * 0.02, 37.8]} for i in range(15)] m.add_screen_grid_layer(screen_data, name=\"screengrid\", cell_size_pixels=50) m In\u00a0[\u00a0]: Copied! <pre>trips = [\n    {\n        \"waypoints\": [[-122.4, 37.8], [-122.35, 37.82], [-122.3, 37.8]],\n        \"timestamps\": [0, 100, 200],\n    }\n]\nm.add_trips_layer(trips, name=\"trips\", trail_length=100)\nm\n</pre> trips = [     {         \"waypoints\": [[-122.4, 37.8], [-122.35, 37.82], [-122.3, 37.8]],         \"timestamps\": [0, 100, 200],     } ] m.add_trips_layer(trips, name=\"trips\", trail_length=100) m In\u00a0[\u00a0]: Copied! <pre>generic_data = [{\"coordinates\": [-122.4, 37.8]}, {\"coordinates\": [-122.3, 37.85]}]\nm.add_deckgl_layer(\"ScatterplotLayer\", generic_data, name=\"generic\", getRadius=200)\nm\n</pre> generic_data = [{\"coordinates\": [-122.4, 37.8]}, {\"coordinates\": [-122.3, 37.85]}] m.add_deckgl_layer(\"ScatterplotLayer\", generic_data, name=\"generic\", getRadius=200) m In\u00a0[\u00a0]: Copied! <pre>m.remove_deck_layer(\"generic\")\n</pre> m.remove_deck_layer(\"generic\")"},{"location":"mapbox/deck_layers/#mapbox-deckgl-layers","title":"Mapbox - Deck.gl Layers\u00b6","text":"<p>GPU-accelerated deck.gl layers for data visualization.</p>"},{"location":"mapbox/deck_layers/#scatterplot-layer","title":"Scatterplot Layer\u00b6","text":""},{"location":"mapbox/deck_layers/#path-layer","title":"Path Layer\u00b6","text":""},{"location":"mapbox/deck_layers/#polygon-layer-with-3d-extrusion","title":"Polygon Layer with 3D Extrusion\u00b6","text":""},{"location":"mapbox/deck_layers/#hexagon-layer-aggregation","title":"Hexagon Layer (Aggregation)\u00b6","text":""},{"location":"mapbox/deck_layers/#grid-layer","title":"Grid Layer\u00b6","text":""},{"location":"mapbox/deck_layers/#deckgl-heatmap-layer","title":"Deck.gl Heatmap Layer\u00b6","text":""},{"location":"mapbox/deck_layers/#text-layer","title":"Text Layer\u00b6","text":""},{"location":"mapbox/deck_layers/#line-layer","title":"Line Layer\u00b6","text":""},{"location":"mapbox/deck_layers/#contour-layer","title":"Contour Layer\u00b6","text":""},{"location":"mapbox/deck_layers/#screen-grid-layer","title":"Screen Grid Layer\u00b6","text":""},{"location":"mapbox/deck_layers/#trips-layer","title":"Trips Layer\u00b6","text":""},{"location":"mapbox/deck_layers/#generic-deckgl-layer","title":"Generic Deck.gl Layer\u00b6","text":""},{"location":"mapbox/deck_layers/#remove-deck-layer","title":"Remove Deck Layer\u00b6","text":""},{"location":"mapbox/layer_management/","title":"Layer management","text":"In\u00a0[\u00a0]: Copied! <pre># %pip install -U anymap-ts\n</pre> # %pip install -U anymap-ts In\u00a0[\u00a0]: Copied! <pre>from anymap_ts import MapboxMap\n\nm = MapboxMap(center=[-122.4, 37.8], zoom=10)\n\nm.add_geojson(\n    {\n        \"type\": \"FeatureCollection\",\n        \"features\": [\n            {\n                \"type\": \"Feature\",\n                \"geometry\": {\"type\": \"Point\", \"coordinates\": [-122.4194, 37.7749]},\n                \"properties\": {},\n            }\n        ],\n    },\n    name=\"points-layer\",\n)\nm.add_geojson(\n    {\n        \"type\": \"FeatureCollection\",\n        \"features\": [\n            {\n                \"type\": \"Feature\",\n                \"geometry\": {\n                    \"type\": \"LineString\",\n                    \"coordinates\": [[-122.4, 37.8], [-122.3, 37.85]],\n                },\n                \"properties\": {},\n            }\n        ],\n    },\n    name=\"lines-layer\",\n    layer_type=\"line\",\n)\nm.add_geojson(\n    {\n        \"type\": \"FeatureCollection\",\n        \"features\": [\n            {\n                \"type\": \"Feature\",\n                \"geometry\": {\n                    \"type\": \"Polygon\",\n                    \"coordinates\": [\n                        [\n                            [-122.45, 37.75],\n                            [-122.35, 37.75],\n                            [-122.35, 37.85],\n                            [-122.45, 37.85],\n                            [-122.45, 37.75],\n                        ]\n                    ],\n                },\n                \"properties\": {\"density\": 50},\n            }\n        ],\n    },\n    name=\"polygons-layer\",\n    layer_type=\"fill\",\n)\nm\n</pre> from anymap_ts import MapboxMap  m = MapboxMap(center=[-122.4, 37.8], zoom=10)  m.add_geojson(     {         \"type\": \"FeatureCollection\",         \"features\": [             {                 \"type\": \"Feature\",                 \"geometry\": {\"type\": \"Point\", \"coordinates\": [-122.4194, 37.7749]},                 \"properties\": {},             }         ],     },     name=\"points-layer\", ) m.add_geojson(     {         \"type\": \"FeatureCollection\",         \"features\": [             {                 \"type\": \"Feature\",                 \"geometry\": {                     \"type\": \"LineString\",                     \"coordinates\": [[-122.4, 37.8], [-122.3, 37.85]],                 },                 \"properties\": {},             }         ],     },     name=\"lines-layer\",     layer_type=\"line\", ) m.add_geojson(     {         \"type\": \"FeatureCollection\",         \"features\": [             {                 \"type\": \"Feature\",                 \"geometry\": {                     \"type\": \"Polygon\",                     \"coordinates\": [                         [                             [-122.45, 37.75],                             [-122.35, 37.75],                             [-122.35, 37.85],                             [-122.45, 37.85],                             [-122.45, 37.75],                         ]                     ],                 },                 \"properties\": {\"density\": 50},             }         ],     },     name=\"polygons-layer\",     layer_type=\"fill\", ) m In\u00a0[\u00a0]: Copied! <pre>m.set_visibility(\"lines-layer\", False)\n</pre> m.set_visibility(\"lines-layer\", False) In\u00a0[\u00a0]: Copied! <pre>m.set_opacity(\"polygons-layer\", 0.5)\n</pre> m.set_opacity(\"polygons-layer\", 0.5) In\u00a0[\u00a0]: Copied! <pre>m.move_layer(\"points-layer\", before_id=\"lines-layer\")\n</pre> m.move_layer(\"points-layer\", before_id=\"lines-layer\") In\u00a0[\u00a0]: Copied! <pre>m.set_paint_property(\"points-layer\", \"circle-color\", \"#ff0000\")\nm.set_paint_property(\"points-layer\", \"circle-radius\", 8)\n</pre> m.set_paint_property(\"points-layer\", \"circle-color\", \"#ff0000\") m.set_paint_property(\"points-layer\", \"circle-radius\", 8) In\u00a0[\u00a0]: Copied! <pre># Filter polygons where density &gt;= 40 (Mapbox expression)\nm.set_filter(\"polygons-layer\", [\"&gt;=\", [\"get\", \"density\"], 40])\n</pre> # Filter polygons where density &gt;= 40 (Mapbox expression) m.set_filter(\"polygons-layer\", [\"&gt;=\", [\"get\", \"density\"], 40]) In\u00a0[\u00a0]: Copied! <pre>m.remove_layer(\"lines-layer\")\n</pre> m.remove_layer(\"lines-layer\")"},{"location":"mapbox/layer_management/#mapbox-layer-management","title":"Mapbox - Layer Management\u00b6","text":"<p>Add layers, set visibility, opacity, move, paint properties, remove, and filter.</p>"},{"location":"mapbox/layer_management/#add-multiple-layers","title":"Add Multiple Layers\u00b6","text":""},{"location":"mapbox/layer_management/#set-visibility","title":"Set Visibility\u00b6","text":""},{"location":"mapbox/layer_management/#set-opacity","title":"Set Opacity\u00b6","text":""},{"location":"mapbox/layer_management/#move-layers","title":"Move Layers\u00b6","text":""},{"location":"mapbox/layer_management/#set-paint-property","title":"Set Paint Property\u00b6","text":""},{"location":"mapbox/layer_management/#set-filter","title":"Set Filter\u00b6","text":""},{"location":"mapbox/layer_management/#remove-layers","title":"Remove Layers\u00b6","text":""},{"location":"mapbox/mapbox/","title":"Mapbox","text":"In\u00a0[\u00a0]: Copied! <pre># %pip install -U anymap-ts\n</pre> # %pip install -U anymap-ts In\u00a0[\u00a0]: Copied! <pre>from anymap_ts import MapboxMap\n\nm = MapboxMap(center=[-122.4, 37.8], zoom=10)\nm\n</pre> from anymap_ts import MapboxMap  m = MapboxMap(center=[-122.4, 37.8], zoom=10) m In\u00a0[\u00a0]: Copied! <pre># Options: streets-v12 (default), dark-v11, satellite-streets-v12\nm.add_basemap(\"mapbox://styles/mapbox/satellite-streets-v12\")\nm\n</pre> # Options: streets-v12 (default), dark-v11, satellite-streets-v12 m.add_basemap(\"mapbox://styles/mapbox/satellite-streets-v12\") m In\u00a0[\u00a0]: Copied! <pre>geojson = {\n    \"type\": \"FeatureCollection\",\n    \"features\": [\n        {\n            \"type\": \"Feature\",\n            \"geometry\": {\"type\": \"Point\", \"coordinates\": [-122.4194, 37.7749]},\n            \"properties\": {\"name\": \"San Francisco\"},\n        },\n        {\n            \"type\": \"Feature\",\n            \"geometry\": {\"type\": \"Point\", \"coordinates\": [-122.2712, 37.8044]},\n            \"properties\": {\"name\": \"Oakland\"},\n        },\n        {\n            \"type\": \"Feature\",\n            \"geometry\": {\n                \"type\": \"LineString\",\n                \"coordinates\": [[-122.4194, 37.7749], [-122.2712, 37.8044]],\n            },\n            \"properties\": {\"name\": \"Bay Bridge route\"},\n        },\n        {\n            \"type\": \"Feature\",\n            \"geometry\": {\n                \"type\": \"Polygon\",\n                \"coordinates\": [\n                    [\n                        [-122.5, 37.7],\n                        [-122.3, 37.7],\n                        [-122.3, 37.9],\n                        [-122.5, 37.9],\n                        [-122.5, 37.7],\n                    ]\n                ],\n            },\n            \"properties\": {\"name\": \"Area\"},\n        },\n    ],\n}\n\nm.add_geojson(geojson, name=\"cities\")\nm\n</pre> geojson = {     \"type\": \"FeatureCollection\",     \"features\": [         {             \"type\": \"Feature\",             \"geometry\": {\"type\": \"Point\", \"coordinates\": [-122.4194, 37.7749]},             \"properties\": {\"name\": \"San Francisco\"},         },         {             \"type\": \"Feature\",             \"geometry\": {\"type\": \"Point\", \"coordinates\": [-122.2712, 37.8044]},             \"properties\": {\"name\": \"Oakland\"},         },         {             \"type\": \"Feature\",             \"geometry\": {                 \"type\": \"LineString\",                 \"coordinates\": [[-122.4194, 37.7749], [-122.2712, 37.8044]],             },             \"properties\": {\"name\": \"Bay Bridge route\"},         },         {             \"type\": \"Feature\",             \"geometry\": {                 \"type\": \"Polygon\",                 \"coordinates\": [                     [                         [-122.5, 37.7],                         [-122.3, 37.7],                         [-122.3, 37.9],                         [-122.5, 37.9],                         [-122.5, 37.7],                     ]                 ],             },             \"properties\": {\"name\": \"Area\"},         },     ], }  m.add_geojson(geojson, name=\"cities\") m In\u00a0[\u00a0]: Copied! <pre>m.add_draw_control(position=\"top-right\")\nm\n</pre> m.add_draw_control(position=\"top-right\") m In\u00a0[\u00a0]: Copied! <pre>m.fly_to(-122.4194, 37.7749, zoom=12)\n</pre> m.fly_to(-122.4194, 37.7749, zoom=12) In\u00a0[\u00a0]: Copied! <pre>m.to_html(\"mapbox_example.html\")\n</pre> m.to_html(\"mapbox_example.html\")"},{"location":"mapbox/mapbox/#mapbox-gl-js-basic-usage","title":"Mapbox GL JS - Basic Usage\u00b6","text":"<p>This notebook demonstrates basic Mapbox GL JS integration in anymap-ts.</p> <p>Note: Uses <code>MAPBOX_TOKEN</code> from environment (no explicit token check needed).</p>"},{"location":"mapbox/mapbox/#create-a-basic-map","title":"Create a Basic Map\u00b6","text":""},{"location":"mapbox/mapbox/#add-basemap-mapbox-style","title":"Add Basemap (Mapbox Style)\u00b6","text":"<p>Use Mapbox style URLs. Default is streets-v12. Switch with add_basemap().</p>"},{"location":"mapbox/mapbox/#add-geojson-data-points-lines-polygons","title":"Add GeoJSON Data (Points, Lines, Polygons)\u00b6","text":""},{"location":"mapbox/mapbox/#add-draw-control","title":"Add Draw Control\u00b6","text":""},{"location":"mapbox/mapbox/#fly-to-location","title":"Fly to Location\u00b6","text":""},{"location":"mapbox/mapbox/#export-to-html","title":"Export to HTML\u00b6","text":""},{"location":"mapbox/markers/","title":"Markers","text":"In\u00a0[\u00a0]: Copied! <pre># %pip install -U anymap-ts\n</pre> # %pip install -U anymap-ts In\u00a0[\u00a0]: Copied! <pre>from anymap_ts import MapboxMap\n\nm = MapboxMap(center=[-122.4194, 37.7749], zoom=12)\nm.add_marker(\n    -122.4194,\n    37.7749,\n    popup=\"&lt;b&gt;San Francisco&lt;/b&gt;&lt;br&gt;Golden Gate Bridge nearby\",\n    tooltip=\"Hover: San Francisco\",\n    color=\"#3388ff\",\n    name=\"sf-marker\",\n)\nm\n</pre> from anymap_ts import MapboxMap  m = MapboxMap(center=[-122.4194, 37.7749], zoom=12) m.add_marker(     -122.4194,     37.7749,     popup=\"San FranciscoGolden Gate Bridge nearby\",     tooltip=\"Hover: San Francisco\",     color=\"#3388ff\",     name=\"sf-marker\", ) m In\u00a0[\u00a0]: Copied! <pre>cities = [\n    {\"lng\": -122.4194, \"lat\": 37.7749, \"name\": \"San Francisco\", \"pop\": \"884k\"},\n    {\"lng\": -122.2712, \"lat\": 37.8044, \"name\": \"Oakland\", \"pop\": \"433k\"},\n    {\"lng\": -121.8863, \"lat\": 37.3382, \"name\": \"San Jose\", \"pop\": \"1M\"},\n]\nm.add_markers(\n    cities,\n    lng_column=\"lng\",\n    lat_column=\"lat\",\n    popup_column=\"name\",\n    tooltip_column=\"pop\",\n    name=\"cities\",\n)\nm.fit_bounds([-122.5, 37.2, -121.8, 37.9])\nm\n</pre> cities = [     {\"lng\": -122.4194, \"lat\": 37.7749, \"name\": \"San Francisco\", \"pop\": \"884k\"},     {\"lng\": -122.2712, \"lat\": 37.8044, \"name\": \"Oakland\", \"pop\": \"433k\"},     {\"lng\": -121.8863, \"lat\": 37.3382, \"name\": \"San Jose\", \"pop\": \"1M\"}, ] m.add_markers(     cities,     lng_column=\"lng\",     lat_column=\"lat\",     popup_column=\"name\",     tooltip_column=\"pop\",     name=\"cities\", ) m.fit_bounds([-122.5, 37.2, -121.8, 37.9]) m In\u00a0[\u00a0]: Copied! <pre>m.remove_marker(\"sf-marker\")\nm.remove_marker(\"cities\")\n</pre> m.remove_marker(\"sf-marker\") m.remove_marker(\"cities\")"},{"location":"mapbox/markers/#mapbox-markers","title":"Mapbox - Markers\u00b6","text":"<p>Single and multiple markers with popups and tooltips.</p>"},{"location":"mapbox/markers/#add-single-marker-with-popup-and-tooltip","title":"Add Single Marker with Popup and Tooltip\u00b6","text":""},{"location":"mapbox/markers/#add-multiple-markers-from-data","title":"Add Multiple Markers from Data\u00b6","text":""},{"location":"mapbox/markers/#remove-markers","title":"Remove Markers\u00b6","text":""},{"location":"mapbox/popups_tooltips/","title":"Popups tooltips","text":"In\u00a0[\u00a0]: Copied! <pre># %pip install -U anymap-ts\n</pre> # %pip install -U anymap-ts In\u00a0[\u00a0]: Copied! <pre>from anymap_ts import MapboxMap\n\nm = MapboxMap(center=[-122.4, 37.8], zoom=10)\n\ngeojson = {\n    \"type\": \"FeatureCollection\",\n    \"features\": [\n        {\n            \"type\": \"Feature\",\n            \"geometry\": {\"type\": \"Point\", \"coordinates\": [-122.4194, 37.7749]},\n            \"properties\": {\"name\": \"San Francisco\", \"pop\": 884000},\n        },\n        {\n            \"type\": \"Feature\",\n            \"geometry\": {\"type\": \"Point\", \"coordinates\": [-122.2712, 37.8044]},\n            \"properties\": {\"name\": \"Oakland\", \"pop\": 433000},\n        },\n    ],\n}\nm.add_geojson(geojson, name=\"cities\")\nm\n</pre> from anymap_ts import MapboxMap  m = MapboxMap(center=[-122.4, 37.8], zoom=10)  geojson = {     \"type\": \"FeatureCollection\",     \"features\": [         {             \"type\": \"Feature\",             \"geometry\": {\"type\": \"Point\", \"coordinates\": [-122.4194, 37.7749]},             \"properties\": {\"name\": \"San Francisco\", \"pop\": 884000},         },         {             \"type\": \"Feature\",             \"geometry\": {\"type\": \"Point\", \"coordinates\": [-122.2712, 37.8044]},             \"properties\": {\"name\": \"Oakland\", \"pop\": 433000},         },     ], } m.add_geojson(geojson, name=\"cities\") m In\u00a0[\u00a0]: Copied! <pre>m.add_popup(\n    \"cities\", properties=[\"name\", \"pop\"], template=\"&lt;b&gt;{name}&lt;/b&gt;&lt;br&gt;Population: {pop}\"\n)\n</pre> m.add_popup(     \"cities\", properties=[\"name\", \"pop\"], template=\"{name}Population: {pop}\" ) In\u00a0[\u00a0]: Copied! <pre>m.add_tooltip(\"cities\", properties=[\"name\"], template=\"{name}\")\n</pre> m.add_tooltip(\"cities\", properties=[\"name\"], template=\"{name}\") In\u00a0[\u00a0]: Copied! <pre>m.add_legend(\n    title=\"Cities\",\n    labels=[\"San Francisco\", \"Oakland\"],\n    colors=[\"#3388ff\", \"#ff8833\"],\n    position=\"bottom-right\",\n)\n</pre> m.add_legend(     title=\"Cities\",     labels=[\"San Francisco\", \"Oakland\"],     colors=[\"#3388ff\", \"#ff8833\"],     position=\"bottom-right\", ) In\u00a0[\u00a0]: Copied! <pre>m.add_hover_effect(\n    layer_id=\"cities\",\n    highlight_color=\"#ffff00\",\n    highlight_opacity=0.8,\n)\n</pre> m.add_hover_effect(     layer_id=\"cities\",     highlight_color=\"#ffff00\",     highlight_opacity=0.8, )"},{"location":"mapbox/popups_tooltips/#mapbox-popups-tooltips","title":"Mapbox - Popups &amp; Tooltips\u00b6","text":"<p>Popup on click, tooltip on hover, legend, and hover effects.</p>"},{"location":"mapbox/popups_tooltips/#add-popup-on-click","title":"Add Popup on Click\u00b6","text":""},{"location":"mapbox/popups_tooltips/#add-tooltip-on-hover","title":"Add Tooltip on Hover\u00b6","text":""},{"location":"mapbox/popups_tooltips/#add-legend","title":"Add Legend\u00b6","text":""},{"location":"mapbox/popups_tooltips/#add-hover-effect","title":"Add Hover Effect\u00b6","text":"<p>Use <code>add_hover_effect</code> for hover styling on vector layers.</p>"},{"location":"mapbox/terrain_3d/","title":"Terrain 3d","text":"In\u00a0[\u00a0]: Copied! <pre># %pip install -U anymap-ts\n</pre> # %pip install -U anymap-ts In\u00a0[\u00a0]: Copied! <pre>from anymap_ts import MapboxMap\n\nm = MapboxMap(\n    center=[-122.4, 37.8],\n    zoom=11,\n    pitch=60,\n    style=\"mapbox://styles/mapbox/satellite-streets-v12\",\n)\nm.add_terrain(exaggeration=1.5, source=\"mapbox-dem\")\nm\n</pre> from anymap_ts import MapboxMap  m = MapboxMap(     center=[-122.4, 37.8],     zoom=11,     pitch=60,     style=\"mapbox://styles/mapbox/satellite-streets-v12\", ) m.add_terrain(exaggeration=1.5, source=\"mapbox-dem\") m In\u00a0[\u00a0]: Copied! <pre># Fly to a location to see terrain in 3D\nm.fly_to(-122.4, 37.85, zoom=13)\n</pre> # Fly to a location to see terrain in 3D m.fly_to(-122.4, 37.85, zoom=13) In\u00a0[\u00a0]: Copied! <pre>m.set_fog(\n    color=\"#ffffff\",\n    high_color=\"#add8e6\",\n    low_color=\"#87ceeb\",\n    horizon_blend=0.5,\n    range=[0.5, 10],\n)\n</pre> m.set_fog(     color=\"#ffffff\",     high_color=\"#add8e6\",     low_color=\"#87ceeb\",     horizon_blend=0.5,     range=[0.5, 10], ) In\u00a0[\u00a0]: Copied! <pre>m.remove_terrain()\nm.remove_fog()\n</pre> m.remove_terrain() m.remove_fog()"},{"location":"mapbox/terrain_3d/#mapbox-3d-terrain","title":"Mapbox - 3D Terrain\u00b6","text":"<p>Mapbox DEM terrain, pitch, and atmospheric effects.</p>"},{"location":"mapbox/terrain_3d/#add-terrain-with-mapbox-dem","title":"Add Terrain with Mapbox DEM\u00b6","text":""},{"location":"mapbox/terrain_3d/#set-pitch-for-3d-view","title":"Set Pitch for 3D View\u00b6","text":"<p>Pitch is set in the constructor (60 degrees above). For a steeper view, create a new map with higher pitch.</p>"},{"location":"mapbox/terrain_3d/#set-fog-atmospheric-effects","title":"Set Fog Atmospheric Effects\u00b6","text":""},{"location":"mapbox/terrain_3d/#remove-terrain","title":"Remove Terrain\u00b6","text":""},{"location":"mapbox/ui_controls/","title":"Ui controls","text":"In\u00a0[\u00a0]: Copied! <pre># %pip install -U anymap-ts\n</pre> # %pip install -U anymap-ts In\u00a0[\u00a0]: Copied! <pre>from anymap_ts import MapboxMap\n\nm = MapboxMap(center=[-122.4, 37.8], zoom=10)\nm.add_geojson(\n    {\n        \"type\": \"FeatureCollection\",\n        \"features\": [\n            {\n                \"type\": \"Feature\",\n                \"geometry\": {\"type\": \"Point\", \"coordinates\": [-122.4194, 37.7749]},\n                \"properties\": {\"name\": \"San Francisco\", \"time\": 12},\n            },\n        ],\n    },\n    name=\"points\",\n)\nm\n</pre> from anymap_ts import MapboxMap  m = MapboxMap(center=[-122.4, 37.8], zoom=10) m.add_geojson(     {         \"type\": \"FeatureCollection\",         \"features\": [             {                 \"type\": \"Feature\",                 \"geometry\": {\"type\": \"Point\", \"coordinates\": [-122.4194, 37.7749]},                 \"properties\": {\"name\": \"San Francisco\", \"time\": 12},             },         ],     },     name=\"points\", ) m In\u00a0[\u00a0]: Copied! <pre>m.add_colorbar(colormap=\"viridis\", vmin=0, vmax=100, label=\"Values\", units=\"units\")\n</pre> m.add_colorbar(colormap=\"viridis\", vmin=0, vmax=100, label=\"Values\", units=\"units\") In\u00a0[\u00a0]: Copied! <pre>m.add_search_control(position=\"top-left\", placeholder=\"Search places...\")\n</pre> m.add_search_control(position=\"top-left\", placeholder=\"Search places...\") In\u00a0[\u00a0]: Copied! <pre>m.add_measure_control(position=\"top-right\", default_mode=\"distance\")\n</pre> m.add_measure_control(position=\"top-right\", default_mode=\"distance\") In\u00a0[\u00a0]: Copied! <pre>m.add_print_control(position=\"top-right\")\n</pre> m.add_print_control(position=\"top-right\") In\u00a0[\u00a0]: Copied! <pre>m.add_coordinates_control(position=\"bottom-left\", precision=5)\n</pre> m.add_coordinates_control(position=\"bottom-left\", precision=5) In\u00a0[\u00a0]: Copied! <pre>m.add_time_slider(\n    layer_id=\"points\",\n    property=\"time\",\n    min_value=0,\n    max_value=24,\n    label=\"Hour\",\n)\n</pre> m.add_time_slider(     layer_id=\"points\",     property=\"time\",     min_value=0,     max_value=24,     label=\"Hour\", ) In\u00a0[\u00a0]: Copied! <pre>m.add_opacity_slider(layer_id=\"points\", position=\"top-right\", label=\"Points opacity\")\n</pre> m.add_opacity_slider(layer_id=\"points\", position=\"top-right\", label=\"Points opacity\") In\u00a0[\u00a0]: Copied! <pre>m.add_style_switcher(\n    styles={\n        \"Streets\": \"mapbox://styles/mapbox/streets-v12\",\n        \"Dark\": \"mapbox://styles/mapbox/dark-v11\",\n        \"Satellite\": \"mapbox://styles/mapbox/satellite-streets-v12\",\n    },\n    position=\"top-right\",\n)\n</pre> m.add_style_switcher(     styles={         \"Streets\": \"mapbox://styles/mapbox/streets-v12\",         \"Dark\": \"mapbox://styles/mapbox/dark-v11\",         \"Satellite\": \"mapbox://styles/mapbox/satellite-streets-v12\",     },     position=\"top-right\", )"},{"location":"mapbox/ui_controls/#mapbox-ui-controls","title":"Mapbox - UI Controls\u00b6","text":"<p>Colorbar, search, measure, print, coordinates, time slider, opacity slider, style switcher.</p>"},{"location":"mapbox/ui_controls/#add-colorbar","title":"Add Colorbar\u00b6","text":""},{"location":"mapbox/ui_controls/#add-search-control","title":"Add Search Control\u00b6","text":""},{"location":"mapbox/ui_controls/#add-measure-control","title":"Add Measure Control\u00b6","text":""},{"location":"mapbox/ui_controls/#add-print-control","title":"Add Print Control\u00b6","text":""},{"location":"mapbox/ui_controls/#add-coordinates-control","title":"Add Coordinates Control\u00b6","text":""},{"location":"mapbox/ui_controls/#add-time-slider","title":"Add Time Slider\u00b6","text":""},{"location":"mapbox/ui_controls/#add-opacity-slider","title":"Add Opacity Slider\u00b6","text":""},{"location":"mapbox/ui_controls/#add-style-switcher","title":"Add Style Switcher\u00b6","text":""},{"location":"mapbox/vector_data/","title":"Vector data","text":"In\u00a0[\u00a0]: Copied! <pre># %pip install -U anymap-ts\n</pre> # %pip install -U anymap-ts In\u00a0[\u00a0]: Copied! <pre>from anymap_ts import MapboxMap\n\nm = MapboxMap(center=[-122.4, 37.8], zoom=10)\n\ngeojson = {\n    \"type\": \"FeatureCollection\",\n    \"features\": [\n        {\n            \"type\": \"Feature\",\n            \"geometry\": {\"type\": \"Point\", \"coordinates\": [-122.4194, 37.7749]},\n            \"properties\": {\"name\": \"Point A\"},\n        },\n        {\n            \"type\": \"Feature\",\n            \"geometry\": {\n                \"type\": \"LineString\",\n                \"coordinates\": [[-122.4, 37.8], [-122.3, 37.85]],\n            },\n            \"properties\": {\"name\": \"Line 1\"},\n        },\n        {\n            \"type\": \"Feature\",\n            \"geometry\": {\n                \"type\": \"Polygon\",\n                \"coordinates\": [\n                    [\n                        [-122.45, 37.75],\n                        [-122.35, 37.75],\n                        [-122.35, 37.85],\n                        [-122.45, 37.85],\n                        [-122.45, 37.75],\n                    ]\n                ],\n            },\n            \"properties\": {\"name\": \"Polygon 1\"},\n        },\n    ],\n}\nm.add_geojson(geojson, name=\"vector-layer\")\nm\n</pre> from anymap_ts import MapboxMap  m = MapboxMap(center=[-122.4, 37.8], zoom=10)  geojson = {     \"type\": \"FeatureCollection\",     \"features\": [         {             \"type\": \"Feature\",             \"geometry\": {\"type\": \"Point\", \"coordinates\": [-122.4194, 37.7749]},             \"properties\": {\"name\": \"Point A\"},         },         {             \"type\": \"Feature\",             \"geometry\": {                 \"type\": \"LineString\",                 \"coordinates\": [[-122.4, 37.8], [-122.3, 37.85]],             },             \"properties\": {\"name\": \"Line 1\"},         },         {             \"type\": \"Feature\",             \"geometry\": {                 \"type\": \"Polygon\",                 \"coordinates\": [                     [                         [-122.45, 37.75],                         [-122.35, 37.75],                         [-122.35, 37.85],                         [-122.45, 37.85],                         [-122.45, 37.75],                     ]                 ],             },             \"properties\": {\"name\": \"Polygon 1\"},         },     ], } m.add_geojson(geojson, name=\"vector-layer\") m In\u00a0[\u00a0]: Copied! <pre>heatmap_geojson = {\n    \"type\": \"FeatureCollection\",\n    \"features\": [\n        {\n            \"type\": \"Feature\",\n            \"geometry\": {\"type\": \"Point\", \"coordinates\": [-122.4 + i * 0.02, 37.8]},\n            \"properties\": {\"intensity\": 1},\n        }\n        for i in range(25)\n    ],\n}\nm.add_heatmap(heatmap_geojson, name=\"heatmap\", radius=25, intensity=1.5)\nm\n</pre> heatmap_geojson = {     \"type\": \"FeatureCollection\",     \"features\": [         {             \"type\": \"Feature\",             \"geometry\": {\"type\": \"Point\", \"coordinates\": [-122.4 + i * 0.02, 37.8]},             \"properties\": {\"intensity\": 1},         }         for i in range(25)     ], } m.add_heatmap(heatmap_geojson, name=\"heatmap\", radius=25, intensity=1.5) m In\u00a0[\u00a0]: Copied! <pre>updated_geojson = {\n    \"type\": \"FeatureCollection\",\n    \"features\": [\n        {\n            \"type\": \"Feature\",\n            \"geometry\": {\"type\": \"Point\", \"coordinates\": [-122.38, 37.82]},\n            \"properties\": {\"name\": \"Updated Point\"},\n        },\n    ],\n}\nm.update_geojson_source(\"vector-layer-source\", updated_geojson)\n</pre> updated_geojson = {     \"type\": \"FeatureCollection\",     \"features\": [         {             \"type\": \"Feature\",             \"geometry\": {\"type\": \"Point\", \"coordinates\": [-122.38, 37.82]},             \"properties\": {\"name\": \"Updated Point\"},         },     ], } m.update_geojson_source(\"vector-layer-source\", updated_geojson) In\u00a0[\u00a0]: Copied! <pre>tile_url = \"https://tile.openstreetmap.org/{z}/{x}/{y}.png\"\nm.add_tile_layer(tile_url, name=\"osm-tiles\", attribution=\"\u00a9 OpenStreetMap\")\nm\n</pre> tile_url = \"https://tile.openstreetmap.org/{z}/{x}/{y}.png\" m.add_tile_layer(tile_url, name=\"osm-tiles\", attribution=\"\u00a9 OpenStreetMap\") m"},{"location":"mapbox/vector_data/#mapbox-vector-data-heatmap","title":"Mapbox - Vector Data &amp; Heatmap\u00b6","text":"<p>GeoJSON, heatmaps, source updates, and tile layers.</p>"},{"location":"mapbox/vector_data/#add-geojson-points-lines-polygons","title":"Add GeoJSON (Points, Lines, Polygons)\u00b6","text":""},{"location":"mapbox/vector_data/#add-heatmap-from-point-data","title":"Add Heatmap from Point Data\u00b6","text":""},{"location":"mapbox/vector_data/#update-geojson-source","title":"Update GeoJSON Source\u00b6","text":""},{"location":"mapbox/vector_data/#add-tile-layer","title":"Add Tile Layer\u00b6","text":""},{"location":"maplibre/arc_layer/","title":"Arc layer","text":"In\u00a0[\u00a0]: Copied! <pre># %pip install -U anymap-ts\n</pre> # %pip install -U anymap-ts In\u00a0[\u00a0]: Copied! <pre>from anymap_ts import MapLibreMap\n\n# Sample flight data from San Francisco to major cities\nflights = [\n    {\n        \"source\": [-122.4194, 37.7749],\n        \"target\": [-73.9857, 40.7484],\n        \"name\": \"SF to NYC\",\n    },\n    {\n        \"source\": [-122.4194, 37.7749],\n        \"target\": [-87.6298, 41.8781],\n        \"name\": \"SF to Chicago\",\n    },\n    {\n        \"source\": [-122.4194, 37.7749],\n        \"target\": [-118.2437, 34.0522],\n        \"name\": \"SF to LA\",\n    },\n    {\n        \"source\": [-122.4194, 37.7749],\n        \"target\": [-95.3698, 29.7604],\n        \"name\": \"SF to Houston\",\n    },\n    {\n        \"source\": [-122.4194, 37.7749],\n        \"target\": [-80.1918, 25.7617],\n        \"name\": \"SF to Miami\",\n    },\n]\n\nm = MapLibreMap(center=[-98.5795, 39.8283], zoom=3, pitch=30)\nm.add_basemap(\"CartoDB.DarkMatter\")\nm.add_arc_layer(\n    data=flights,\n    name=\"flights\",\n    get_source_color=[0, 128, 255, 255],\n    get_target_color=[255, 128, 0, 255],\n    get_width=2,\n    opacity=0.8,\n)\nm\n</pre> from anymap_ts import MapLibreMap  # Sample flight data from San Francisco to major cities flights = [     {         \"source\": [-122.4194, 37.7749],         \"target\": [-73.9857, 40.7484],         \"name\": \"SF to NYC\",     },     {         \"source\": [-122.4194, 37.7749],         \"target\": [-87.6298, 41.8781],         \"name\": \"SF to Chicago\",     },     {         \"source\": [-122.4194, 37.7749],         \"target\": [-118.2437, 34.0522],         \"name\": \"SF to LA\",     },     {         \"source\": [-122.4194, 37.7749],         \"target\": [-95.3698, 29.7604],         \"name\": \"SF to Houston\",     },     {         \"source\": [-122.4194, 37.7749],         \"target\": [-80.1918, 25.7617],         \"name\": \"SF to Miami\",     }, ]  m = MapLibreMap(center=[-98.5795, 39.8283], zoom=3, pitch=30) m.add_basemap(\"CartoDB.DarkMatter\") m.add_arc_layer(     data=flights,     name=\"flights\",     get_source_color=[0, 128, 255, 255],     get_target_color=[255, 128, 0, 255],     get_width=2,     opacity=0.8, ) m In\u00a0[\u00a0]: Copied! <pre># International flights using great circle paths\ninternational_flights = [\n    {\n        \"source\": [-122.4194, 37.7749],\n        \"target\": [139.6917, 35.6895],\n        \"name\": \"SF to Tokyo\",\n    },\n    {\n        \"source\": [-122.4194, 37.7749],\n        \"target\": [-0.1276, 51.5074],\n        \"name\": \"SF to London\",\n    },\n    {\n        \"source\": [-122.4194, 37.7749],\n        \"target\": [2.3522, 48.8566],\n        \"name\": \"SF to Paris\",\n    },\n    {\n        \"source\": [-122.4194, 37.7749],\n        \"target\": [151.2093, -33.8688],\n        \"name\": \"SF to Sydney\",\n    },\n]\n\nm2 = MapLibreMap(center=[-122.4, 20], zoom=1, pitch=20)\nm2.add_basemap(\"CartoDB.DarkMatter\")\nm2.add_arc_layer(\n    data=international_flights,\n    name=\"international\",\n    get_source_color=[255, 215, 0, 255],\n    get_target_color=[255, 69, 0, 255],\n    get_width=3,\n    great_circle=True,\n    get_height=1,\n)\nm2\n</pre> # International flights using great circle paths international_flights = [     {         \"source\": [-122.4194, 37.7749],         \"target\": [139.6917, 35.6895],         \"name\": \"SF to Tokyo\",     },     {         \"source\": [-122.4194, 37.7749],         \"target\": [-0.1276, 51.5074],         \"name\": \"SF to London\",     },     {         \"source\": [-122.4194, 37.7749],         \"target\": [2.3522, 48.8566],         \"name\": \"SF to Paris\",     },     {         \"source\": [-122.4194, 37.7749],         \"target\": [151.2093, -33.8688],         \"name\": \"SF to Sydney\",     }, ]  m2 = MapLibreMap(center=[-122.4, 20], zoom=1, pitch=20) m2.add_basemap(\"CartoDB.DarkMatter\") m2.add_arc_layer(     data=international_flights,     name=\"international\",     get_source_color=[255, 215, 0, 255],     get_target_color=[255, 69, 0, 255],     get_width=3,     great_circle=True,     get_height=1, ) m2 In\u00a0[\u00a0]: Copied! <pre>from anymap_ts import DeckGLMap\n\n# Bay Area commute patterns\ncommutes = [\n    {\"source\": [-122.2712, 37.8044], \"target\": [-122.4194, 37.7749], \"volume\": 5000},\n    {\"source\": [-122.0308, 37.3382], \"target\": [-122.4194, 37.7749], \"volume\": 3000},\n    {\"source\": [-121.8853, 37.3387], \"target\": [-122.4194, 37.7749], \"volume\": 4000},\n    {\"source\": [-122.4783, 37.8199], \"target\": [-122.4194, 37.7749], \"volume\": 2500},\n    {\"source\": [-122.1561, 37.4419], \"target\": [-122.4194, 37.7749], \"volume\": 3500},\n]\n\nm3 = DeckGLMap(center=[-122.2, 37.6], zoom=9, pitch=45)\nm3.add_basemap(\"CartoDB.DarkMatter\")\nm3.add_arc_layer(\n    data=commutes,\n    name=\"commutes\",\n    get_source_color=[51, 136, 255, 255],\n    get_target_color=[255, 136, 51, 255],\n    get_width=2,\n    opacity=0.7,\n)\nm3\n</pre> from anymap_ts import DeckGLMap  # Bay Area commute patterns commutes = [     {\"source\": [-122.2712, 37.8044], \"target\": [-122.4194, 37.7749], \"volume\": 5000},     {\"source\": [-122.0308, 37.3382], \"target\": [-122.4194, 37.7749], \"volume\": 3000},     {\"source\": [-121.8853, 37.3387], \"target\": [-122.4194, 37.7749], \"volume\": 4000},     {\"source\": [-122.4783, 37.8199], \"target\": [-122.4194, 37.7749], \"volume\": 2500},     {\"source\": [-122.1561, 37.4419], \"target\": [-122.4194, 37.7749], \"volume\": 3500}, ]  m3 = DeckGLMap(center=[-122.2, 37.6], zoom=9, pitch=45) m3.add_basemap(\"CartoDB.DarkMatter\") m3.add_arc_layer(     data=commutes,     name=\"commutes\",     get_source_color=[51, 136, 255, 255],     get_target_color=[255, 136, 51, 255],     get_width=2,     opacity=0.7, ) m3 In\u00a0[\u00a0]: Copied! <pre># Multiple arc layers with layer control\nm4 = MapLibreMap(center=[-98.5795, 39.8283], zoom=3)\nm4.add_basemap(\"CartoDB.DarkMatter\")\n\n# Add domestic flights\nm4.add_arc_layer(\n    data=flights,\n    name=\"arc-domestic\",\n    get_source_color=[0, 200, 100, 255],\n    get_target_color=[100, 200, 0, 255],\n    get_width=2,\n)\n\n# Add international flights\nm4.add_arc_layer(\n    data=international_flights,\n    name=\"arc-international\",\n    get_source_color=[255, 100, 100, 255],\n    get_target_color=[100, 100, 255, 255],\n    get_width=2,\n    great_circle=True,\n)\n\n# Add layer control to manage arc layers\nm4.add_layer_control()\nm4\n</pre> # Multiple arc layers with layer control m4 = MapLibreMap(center=[-98.5795, 39.8283], zoom=3) m4.add_basemap(\"CartoDB.DarkMatter\")  # Add domestic flights m4.add_arc_layer(     data=flights,     name=\"arc-domestic\",     get_source_color=[0, 200, 100, 255],     get_target_color=[100, 200, 0, 255],     get_width=2, )  # Add international flights m4.add_arc_layer(     data=international_flights,     name=\"arc-international\",     get_source_color=[255, 100, 100, 255],     get_target_color=[100, 100, 255, 255],     get_width=2,     great_circle=True, )  # Add layer control to manage arc layers m4.add_layer_control() m4 In\u00a0[\u00a0]: Copied! <pre># Remove a specific arc layer\nm4.remove_arc_layer(\"arc-domestic\")\n</pre> # Remove a specific arc layer m4.remove_arc_layer(\"arc-domestic\") In\u00a0[\u00a0]: Copied! <pre>m.to_html(\"arc_layer_example.html\")\n</pre> m.to_html(\"arc_layer_example.html\")"},{"location":"maplibre/arc_layer/#arc-layer-example","title":"Arc Layer Example\u00b6","text":"<p>This notebook demonstrates the DeckGL ArcLayer for visualizing origin-destination data.</p> <p>Arc layers are ideal for:</p> <ul> <li>Flight routes and migration patterns</li> <li>Transportation networks</li> <li>Supply chain visualization</li> <li>Any origin-destination flow data</li> </ul>"},{"location":"maplibre/arc_layer/#basic-arc-layer-with-maplibre","title":"Basic Arc Layer with MapLibre\u00b6","text":""},{"location":"maplibre/arc_layer/#arc-layer-with-great-circle-routing","title":"Arc Layer with Great Circle Routing\u00b6","text":""},{"location":"maplibre/arc_layer/#arc-layer-with-deckglmap","title":"Arc Layer with DeckGLMap\u00b6","text":""},{"location":"maplibre/arc_layer/#arc-layer-with-layer-control","title":"Arc Layer with Layer Control\u00b6","text":""},{"location":"maplibre/arc_layer/#remove-arc-layer","title":"Remove Arc Layer\u00b6","text":""},{"location":"maplibre/arc_layer/#export-to-html","title":"Export to HTML\u00b6","text":""},{"location":"maplibre/buildings_3d/","title":"Buildings 3d","text":"In\u00a0[\u00a0]: Copied! <pre># %pip install -U anymap-ts\n</pre> # %pip install -U anymap-ts In\u00a0[\u00a0]: Copied! <pre>from anymap_ts import Map\n\n# Manhattan, NYC - lots of tall buildings\n# Using OpenFreeMap Liberty style which has building data\nm = Map(\n    center=[-74.0060, 40.7128],\n    zoom=15,\n    pitch=60,\n    bearing=-17,\n    style=\"https://tiles.openfreemap.org/styles/liberty\",\n)\nm.add_3d_buildings()\nm\n</pre> from anymap_ts import Map  # Manhattan, NYC - lots of tall buildings # Using OpenFreeMap Liberty style which has building data m = Map(     center=[-74.0060, 40.7128],     zoom=15,     pitch=60,     bearing=-17,     style=\"https://tiles.openfreemap.org/styles/liberty\", ) m.add_3d_buildings() m In\u00a0[\u00a0]: Copied! <pre># San Francisco with blue buildings\nm2 = Map(\n    center=[-122.4194, 37.7749],\n    zoom=15.5,\n    pitch=55,\n    bearing=45,\n    style=\"https://tiles.openfreemap.org/styles/liberty\",\n)\nm2.add_3d_buildings(\n    fill_extrusion_color=\"#4682B4\", fill_extrusion_opacity=0.8  # Steel blue\n)\nm2\n</pre> # San Francisco with blue buildings m2 = Map(     center=[-122.4194, 37.7749],     zoom=15.5,     pitch=55,     bearing=45,     style=\"https://tiles.openfreemap.org/styles/liberty\", ) m2.add_3d_buildings(     fill_extrusion_color=\"#4682B4\", fill_extrusion_opacity=0.8  # Steel blue ) m2 In\u00a0[\u00a0]: Copied! <pre># Downtown LA with terrain and buildings\nm3 = Map(\n    center=[-118.2437, 34.0522],\n    zoom=15,\n    pitch=60,\n    bearing=-30,\n    style=\"https://tiles.openfreemap.org/styles/liberty\",\n)\nm3.add_3d_terrain(exaggeration=1.5)\nm3.add_3d_buildings(fill_extrusion_color=\"#808080\", fill_extrusion_opacity=0.7)\nm3\n</pre> # Downtown LA with terrain and buildings m3 = Map(     center=[-118.2437, 34.0522],     zoom=15,     pitch=60,     bearing=-30,     style=\"https://tiles.openfreemap.org/styles/liberty\", ) m3.add_3d_terrain(exaggeration=1.5) m3.add_3d_buildings(fill_extrusion_color=\"#808080\", fill_extrusion_opacity=0.7) m3 In\u00a0[\u00a0]: Copied! <pre># Chicago with warm sunset colors\nm4 = Map(\n    center=[-87.6298, 41.8781],\n    zoom=15.5,\n    pitch=60,\n    bearing=100,\n    style=\"https://tiles.openfreemap.org/styles/liberty\",\n)\nm4.add_3d_buildings(\n    fill_extrusion_color=\"#FF8C00\",  # Dark orange for sunset effect\n    fill_extrusion_opacity=0.85,\n    min_zoom=13,\n)\nm4\n</pre> # Chicago with warm sunset colors m4 = Map(     center=[-87.6298, 41.8781],     zoom=15.5,     pitch=60,     bearing=100,     style=\"https://tiles.openfreemap.org/styles/liberty\", ) m4.add_3d_buildings(     fill_extrusion_color=\"#FF8C00\",  # Dark orange for sunset effect     fill_extrusion_opacity=0.85,     min_zoom=13, ) m4 In\u00a0[\u00a0]: Copied! <pre># Seattle\nm5 = Map(\n    center=[-122.3321, 47.6062],\n    zoom=15,\n    pitch=65,\n    bearing=-45,\n    style=\"https://tiles.openfreemap.org/styles/liberty\",\n)\nm5.add_3d_buildings(\n    fill_extrusion_color=\"#1a1a2e\", fill_extrusion_opacity=0.9  # Dark blue\n)\nm5\n</pre> # Seattle m5 = Map(     center=[-122.3321, 47.6062],     zoom=15,     pitch=65,     bearing=-45,     style=\"https://tiles.openfreemap.org/styles/liberty\", ) m5.add_3d_buildings(     fill_extrusion_color=\"#1a1a2e\", fill_extrusion_opacity=0.9  # Dark blue ) m5 In\u00a0[\u00a0]: Copied! <pre># Boston\nm6 = Map(\n    center=[-71.0589, 42.3601],\n    zoom=15,\n    pitch=55,\n    bearing=20,\n    style=\"https://tiles.openfreemap.org/styles/liberty\",\n)\nm6.add_3d_buildings(\n    fill_extrusion_color=\"#8B4513\",  # Saddle brown - brick city look\n    fill_extrusion_opacity=0.7,\n)\nm6\n</pre> # Boston m6 = Map(     center=[-71.0589, 42.3601],     zoom=15,     pitch=55,     bearing=20,     style=\"https://tiles.openfreemap.org/styles/liberty\", ) m6.add_3d_buildings(     fill_extrusion_color=\"#8B4513\",  # Saddle brown - brick city look     fill_extrusion_opacity=0.7, ) m6 In\u00a0[\u00a0]: Copied! <pre># Tokyo - large urban area\nm7 = Map(\n    center=[139.6917, 35.6895],\n    zoom=15,\n    pitch=60,\n    bearing=0,\n    style=\"https://tiles.openfreemap.org/styles/liberty\",\n)\nm7.add_3d_buildings(\n    fill_extrusion_color=\"#C0C0C0\", fill_extrusion_opacity=0.8  # Silver\n)\nm7\n</pre> # Tokyo - large urban area m7 = Map(     center=[139.6917, 35.6895],     zoom=15,     pitch=60,     bearing=0,     style=\"https://tiles.openfreemap.org/styles/liberty\", ) m7.add_3d_buildings(     fill_extrusion_color=\"#C0C0C0\", fill_extrusion_opacity=0.8  # Silver ) m7 In\u00a0[\u00a0]: Copied! <pre># Using Positron style\nm8 = Map(\n    center=[-0.1276, 51.5074],  # London\n    zoom=15,\n    pitch=60,\n    bearing=30,\n    style=\"https://tiles.openfreemap.org/styles/positron\",\n)\nm8.add_3d_buildings(\n    fill_extrusion_color=\"#6B8E23\", fill_extrusion_opacity=0.7  # Olive green\n)\nm8\n</pre> # Using Positron style m8 = Map(     center=[-0.1276, 51.5074],  # London     zoom=15,     pitch=60,     bearing=30,     style=\"https://tiles.openfreemap.org/styles/positron\", ) m8.add_3d_buildings(     fill_extrusion_color=\"#6B8E23\", fill_extrusion_opacity=0.7  # Olive green ) m8 In\u00a0[\u00a0]: Copied! <pre>m.to_html(\"buildings_3d_example.html\")\n</pre> m.to_html(\"buildings_3d_example.html\")"},{"location":"maplibre/buildings_3d/#3d-buildings","title":"3D Buildings\u00b6","text":"<p>This notebook demonstrates how to add 3D building extrusions to MapLibre maps.</p> <p>Important: 3D buildings require a vector tile style with building data. The examples below use OpenFreeMap's Liberty style which includes building heights.</p>"},{"location":"maplibre/buildings_3d/#basic-3d-buildings","title":"Basic 3D Buildings\u00b6","text":""},{"location":"maplibre/buildings_3d/#custom-building-colors","title":"Custom Building Colors\u00b6","text":""},{"location":"maplibre/buildings_3d/#3d-buildings-with-terrain","title":"3D Buildings with Terrain\u00b6","text":""},{"location":"maplibre/buildings_3d/#golden-hour-effect","title":"Golden Hour Effect\u00b6","text":""},{"location":"maplibre/buildings_3d/#different-cities","title":"Different Cities\u00b6","text":""},{"location":"maplibre/buildings_3d/#interactive-navigation","title":"Interactive Navigation\u00b6","text":"<p>Use the map controls to:</p> <ul> <li>Rotate: Right-click and drag, or use Shift + left-click and drag</li> <li>Tilt: Ctrl + click and drag</li> <li>Zoom: Scroll wheel or double-click</li> </ul>"},{"location":"maplibre/buildings_3d/#using-other-vector-styles","title":"Using Other Vector Styles\u00b6","text":"<p>You can use any vector tile style that includes building data. Here's an example with the Positron style from OpenFreeMap:</p>"},{"location":"maplibre/buildings_3d/#export-to-html","title":"Export to HTML\u00b6","text":""},{"location":"maplibre/choropleth/","title":"Choropleth","text":"In\u00a0[\u00a0]: Copied! <pre># %pip install -U anymap-ts\n</pre> # %pip install -U anymap-ts In\u00a0[\u00a0]: Copied! <pre>from anymap_ts import Map\n\n# US states GeoJSON with population data\nstates_url = \"https://raw.githubusercontent.com/PublicaMundi/MappingAPI/master/data/geojson/us-states.json\"\n\nm = Map(center=[-98, 38], zoom=3)\nm.add_choropleth(\n    states_url,\n    column=\"density\",\n    cmap=\"YlOrRd\",\n    classification=\"quantile\",\n    k=5,\n    legend_title=\"Population Density\",\n)\nm\n</pre> from anymap_ts import Map  # US states GeoJSON with population data states_url = \"https://raw.githubusercontent.com/PublicaMundi/MappingAPI/master/data/geojson/us-states.json\"  m = Map(center=[-98, 38], zoom=3) m.add_choropleth(     states_url,     column=\"density\",     cmap=\"YlOrRd\",     classification=\"quantile\",     k=5,     legend_title=\"Population Density\", ) m In\u00a0[\u00a0]: Copied! <pre>m2 = Map(center=[-98, 38], zoom=3)\nm2.add_choropleth(\n    states_url,\n    column=\"density\",\n    cmap=\"Blues\",\n    classification=\"quantile\",\n    k=5,\n    legend_title=\"Density (Quantile)\",\n)\nm2\n</pre> m2 = Map(center=[-98, 38], zoom=3) m2.add_choropleth(     states_url,     column=\"density\",     cmap=\"Blues\",     classification=\"quantile\",     k=5,     legend_title=\"Density (Quantile)\", ) m2 In\u00a0[\u00a0]: Copied! <pre># Equal interval works better with more uniformly distributed data\n# For skewed data like density, consider using manual breaks\nm3 = Map(center=[-98, 38], zoom=3)\nm3.add_choropleth(\n    states_url,\n    column=\"density\",\n    cmap=\"Greens\",\n    classification=\"manual\",\n    breaks=[0, 25, 75, 150, 300, 1200],  # Custom breaks for better distribution\n    k=5,\n    legend_title=\"Density (Custom Equal-ish)\",\n)\nm3\n</pre> # Equal interval works better with more uniformly distributed data # For skewed data like density, consider using manual breaks m3 = Map(center=[-98, 38], zoom=3) m3.add_choropleth(     states_url,     column=\"density\",     cmap=\"Greens\",     classification=\"manual\",     breaks=[0, 25, 75, 150, 300, 1200],  # Custom breaks for better distribution     k=5,     legend_title=\"Density (Custom Equal-ish)\", ) m3 In\u00a0[\u00a0]: Copied! <pre>m4 = Map(center=[-98, 38], zoom=3)\nm4.add_choropleth(\n    states_url,\n    column=\"density\",\n    cmap=\"Oranges\",\n    classification=\"quantile\",\n    k=7,\n    legend_title=\"Density (Quantile, 7 classes)\",\n)\nm4\n</pre> m4 = Map(center=[-98, 38], zoom=3) m4.add_choropleth(     states_url,     column=\"density\",     cmap=\"Oranges\",     classification=\"quantile\",     k=7,     legend_title=\"Density (Quantile, 7 classes)\", ) m4 In\u00a0[\u00a0]: Copied! <pre># Viridis colormap (perceptually uniform)\nm5 = Map(center=[-98, 38], zoom=3)\nm5.add_choropleth(\n    states_url, column=\"density\", cmap=\"viridis\", k=6, legend_title=\"Density (Viridis)\"\n)\nm5\n</pre> # Viridis colormap (perceptually uniform) m5 = Map(center=[-98, 38], zoom=3) m5.add_choropleth(     states_url, column=\"density\", cmap=\"viridis\", k=6, legend_title=\"Density (Viridis)\" ) m5 In\u00a0[\u00a0]: Copied! <pre># Spectral colormap (diverging - good for showing deviation from middle)\nm6 = Map(center=[-98, 38], zoom=3)\nm6.add_choropleth(\n    states_url,\n    column=\"density\",\n    cmap=\"Spectral\",\n    k=5,\n    legend_title=\"Density (Spectral)\",\n)\nm6\n</pre> # Spectral colormap (diverging - good for showing deviation from middle) m6 = Map(center=[-98, 38], zoom=3) m6.add_choropleth(     states_url,     column=\"density\",     cmap=\"Spectral\",     k=5,     legend_title=\"Density (Spectral)\", ) m6 In\u00a0[\u00a0]: Copied! <pre># Plasma colormap\nm7 = Map(center=[-98, 38], zoom=3)\nm7.add_choropleth(\n    states_url, column=\"density\", cmap=\"plasma\", k=5, legend_title=\"Density (Plasma)\"\n)\nm7\n</pre> # Plasma colormap m7 = Map(center=[-98, 38], zoom=3) m7.add_choropleth(     states_url, column=\"density\", cmap=\"plasma\", k=5, legend_title=\"Density (Plasma)\" ) m7 In\u00a0[\u00a0]: Copied! <pre>m8 = Map(center=[-98, 38], zoom=3)\nm8.add_basemap(\"CartoDB.DarkMatter\")\nm8.add_choropleth(\n    states_url,\n    column=\"density\",\n    cmap=\"inferno\",\n    classification=\"quantile\",\n    k=5,\n    fill_opacity=0.8,\n    line_color=\"#ffffff\",\n    line_width=2,\n    legend_title=\"Population Density\",\n)\nm8\n</pre> m8 = Map(center=[-98, 38], zoom=3) m8.add_basemap(\"CartoDB.DarkMatter\") m8.add_choropleth(     states_url,     column=\"density\",     cmap=\"inferno\",     classification=\"quantile\",     k=5,     fill_opacity=0.8,     line_color=\"#ffffff\",     line_width=2,     legend_title=\"Population Density\", ) m8 In\u00a0[\u00a0]: Copied! <pre>m9 = Map(center=[-98, 38], zoom=3)\nm9.add_choropleth(\n    states_url,\n    column=\"density\",\n    cmap=\"RdYlGn\",\n    classification=\"manual\",\n    breaks=[0, 20, 50, 100, 250, 1200],  # 5 classes with meaningful thresholds\n    k=5,\n    legend_title=\"Custom Breaks\",\n)\nm9\n</pre> m9 = Map(center=[-98, 38], zoom=3) m9.add_choropleth(     states_url,     column=\"density\",     cmap=\"RdYlGn\",     classification=\"manual\",     breaks=[0, 20, 50, 100, 250, 1200],  # 5 classes with meaningful thresholds     k=5,     legend_title=\"Custom Breaks\", ) m9 In\u00a0[\u00a0]: Copied! <pre>m10 = Map(center=[-98, 38], zoom=3)\nm10.add_choropleth(\n    states_url, column=\"density\", cmap=\"coolwarm\", k=5, legend=False  # No legend\n)\nm10\n</pre> m10 = Map(center=[-98, 38], zoom=3) m10.add_choropleth(     states_url, column=\"density\", cmap=\"coolwarm\", k=5, legend=False  # No legend ) m10 In\u00a0[\u00a0]: Copied! <pre>m11 = Map(center=[-98, 38], zoom=3)\nm11.add_choropleth(\n    states_url,\n    column=\"density\",\n    cmap=\"Purples\",\n    k=5,\n    hover=False,  # Disable hover highlight\n    legend_title=\"No Hover Effect\",\n)\nm11\n</pre> m11 = Map(center=[-98, 38], zoom=3) m11.add_choropleth(     states_url,     column=\"density\",     cmap=\"Purples\",     k=5,     hover=False,  # Disable hover highlight     legend_title=\"No Hover Effect\", ) m11 In\u00a0[\u00a0]: Copied! <pre>m.to_html(\"choropleth_example.html\")\n</pre> m.to_html(\"choropleth_example.html\")"},{"location":"maplibre/choropleth/#choropleth-maps","title":"Choropleth Maps\u00b6","text":"<p>This notebook demonstrates how to create choropleth (thematic) maps with automatic data classification and color mapping.</p>"},{"location":"maplibre/choropleth/#basic-choropleth-with-us-states","title":"Basic Choropleth with US States\u00b6","text":""},{"location":"maplibre/choropleth/#different-classification-methods","title":"Different Classification Methods\u00b6","text":""},{"location":"maplibre/choropleth/#quantile-classification-recommended-for-skewed-data","title":"Quantile Classification (Recommended for skewed data)\u00b6","text":"<p>Quantile classification divides data so each class has an equal number of features. This works well for skewed distributions like population density.</p>"},{"location":"maplibre/choropleth/#equal-interval-classification","title":"Equal Interval Classification\u00b6","text":"<p>Equal interval divides the data range into equal-width bins.</p> <p>Note: Equal interval can produce poor results with skewed data (like population density where most values are low). In such cases, most features end up in the first class. Use <code>quantile</code> or <code>manual</code> breaks for skewed data.</p>"},{"location":"maplibre/choropleth/#more-classes-with-quantile","title":"More Classes with Quantile\u00b6","text":""},{"location":"maplibre/choropleth/#different-color-maps","title":"Different Color Maps\u00b6","text":"<p>Any matplotlib colormap is supported. Common options include:</p> <ul> <li>Sequential: viridis, plasma, inferno, Blues, Greens, Reds, Purples</li> <li>Diverging: RdBu, RdYlGn, Spectral, coolwarm, seismic</li> <li>Qualitative: Set1, Set2, tab10, Paired</li> </ul>"},{"location":"maplibre/choropleth/#custom-styling","title":"Custom Styling\u00b6","text":""},{"location":"maplibre/choropleth/#manual-classification-breaks","title":"Manual Classification Breaks\u00b6","text":"<p>For full control, specify exact break values. This is useful when you have meaningful thresholds (e.g., low/medium/high categories).</p>"},{"location":"maplibre/choropleth/#choropleth-without-legend","title":"Choropleth without Legend\u00b6","text":""},{"location":"maplibre/choropleth/#choropleth-with-hover-disabled","title":"Choropleth with Hover Disabled\u00b6","text":""},{"location":"maplibre/choropleth/#export-to-html","title":"Export to HTML\u00b6","text":""},{"location":"maplibre/clustering/","title":"Clustering","text":"In\u00a0[\u00a0]: Copied! <pre># %pip install -U anymap-ts\n</pre> # %pip install -U anymap-ts In\u00a0[\u00a0]: Copied! <pre>from anymap_ts import Map\n\n# Load earthquake data from USGS\nearthquake_url = (\n    \"https://earthquake.usgs.gov/earthquakes/feed/v1.0/summary/all_week.geojson\"\n)\n\nm = Map(center=[-98, 38], zoom=3)\nm.add_cluster_layer(earthquake_url, name=\"earthquakes\")\nm\n</pre> from anymap_ts import Map  # Load earthquake data from USGS earthquake_url = (     \"https://earthquake.usgs.gov/earthquakes/feed/v1.0/summary/all_week.geojson\" )  m = Map(center=[-98, 38], zoom=3) m.add_cluster_layer(earthquake_url, name=\"earthquakes\") m In\u00a0[\u00a0]: Copied! <pre>import random\n\n# Generate random point data\nfeatures = []\nfor i in range(1000):\n    features.append(\n        {\n            \"type\": \"Feature\",\n            \"geometry\": {\n                \"type\": \"Point\",\n                \"coordinates\": [\n                    -122.4 + random.uniform(-2, 2),\n                    37.8 + random.uniform(-2, 2),\n                ],\n            },\n            \"properties\": {\"id\": i, \"value\": random.randint(1, 100)},\n        }\n    )\n\ngeojson = {\"type\": \"FeatureCollection\", \"features\": features}\n\nm2 = Map(center=[-122.4, 37.8], zoom=8)\nm2.add_basemap(\"CartoDB.DarkMatter\")\nm2.add_cluster_layer(\n    geojson,\n    name=\"random-points\",\n    cluster_colors=[\"#00ff00\", \"#ffff00\", \"#ff0000\"],  # Green -&gt; Yellow -&gt; Red\n    cluster_steps=[50, 200],  # Color changes at 50 and 200 points\n    cluster_radius=60,\n    cluster_min_radius=18,\n    cluster_max_radius=40,\n    unclustered_color=\"#00ffff\",\n    unclustered_radius=6,\n)\nm2\n</pre> import random  # Generate random point data features = [] for i in range(1000):     features.append(         {             \"type\": \"Feature\",             \"geometry\": {                 \"type\": \"Point\",                 \"coordinates\": [                     -122.4 + random.uniform(-2, 2),                     37.8 + random.uniform(-2, 2),                 ],             },             \"properties\": {\"id\": i, \"value\": random.randint(1, 100)},         }     )  geojson = {\"type\": \"FeatureCollection\", \"features\": features}  m2 = Map(center=[-122.4, 37.8], zoom=8) m2.add_basemap(\"CartoDB.DarkMatter\") m2.add_cluster_layer(     geojson,     name=\"random-points\",     cluster_colors=[\"#00ff00\", \"#ffff00\", \"#ff0000\"],  # Green -&gt; Yellow -&gt; Red     cluster_steps=[50, 200],  # Color changes at 50 and 200 points     cluster_radius=60,     cluster_min_radius=18,     cluster_max_radius=40,     unclustered_color=\"#00ffff\",     unclustered_radius=6, ) m2 In\u00a0[\u00a0]: Copied! <pre>m3 = Map(center=[-98, 38], zoom=3)\nm3.add_basemap(\"CartoDB.Voyager\")\nm3.add_cluster_layer(\n    earthquake_url,\n    name=\"earthquakes-styled\",\n    cluster_colors=[\"#2dc4b2\", \"#3bb3c3\", \"#669ec4\", \"#8b88b6\", \"#a2719b\"],\n    cluster_steps=[10, 50, 100, 500],\n    cluster_min_radius=12,\n    cluster_max_radius=35,\n    unclustered_color=\"#e55e5e\",\n    unclustered_radius=5,\n)\nm3\n</pre> m3 = Map(center=[-98, 38], zoom=3) m3.add_basemap(\"CartoDB.Voyager\") m3.add_cluster_layer(     earthquake_url,     name=\"earthquakes-styled\",     cluster_colors=[\"#2dc4b2\", \"#3bb3c3\", \"#669ec4\", \"#8b88b6\", \"#a2719b\"],     cluster_steps=[10, 50, 100, 500],     cluster_min_radius=12,     cluster_max_radius=35,     unclustered_color=\"#e55e5e\",     unclustered_radius=5, ) m3 In\u00a0[\u00a0]: Copied! <pre>m4 = Map(center=[-122.4, 37.8], zoom=8)\nm4.add_cluster_layer(\n    geojson,\n    name=\"no-zoom\",\n    zoom_on_click=False,  # Disable click-to-zoom behavior\n    cluster_colors=[\"#3388ff\", \"#ff8833\"],\n    cluster_steps=[100],\n)\nm4\n</pre> m4 = Map(center=[-122.4, 37.8], zoom=8) m4.add_cluster_layer(     geojson,     name=\"no-zoom\",     zoom_on_click=False,  # Disable click-to-zoom behavior     cluster_colors=[\"#3388ff\", \"#ff8833\"],     cluster_steps=[100], ) m4 In\u00a0[\u00a0]: Copied! <pre># Create map and add cluster layer\nm5 = Map(center=[-122.4, 37.8], zoom=8)\nlayer_id = m5.add_cluster_layer(geojson, name=\"removable\")\nprint(f\"Layer ID: {layer_id}\")\nm5\n</pre> # Create map and add cluster layer m5 = Map(center=[-122.4, 37.8], zoom=8) layer_id = m5.add_cluster_layer(geojson, name=\"removable\") print(f\"Layer ID: {layer_id}\") m5 In\u00a0[\u00a0]: Copied! <pre># Remove the cluster layer\nm5.remove_cluster_layer(\"removable\")\n</pre> # Remove the cluster layer m5.remove_cluster_layer(\"removable\") In\u00a0[\u00a0]: Copied! <pre>m3.to_html(\"clustering_example.html\")\n</pre> m3.to_html(\"clustering_example.html\")"},{"location":"maplibre/clustering/#geojson-clustering-example","title":"GeoJSON Clustering Example\u00b6","text":"<p>This notebook demonstrates how to create clustered point layers in MapLibre. Clustering automatically groups nearby points at lower zoom levels and expands them as you zoom in.</p>"},{"location":"maplibre/clustering/#basic-clustering","title":"Basic Clustering\u00b6","text":""},{"location":"maplibre/clustering/#custom-cluster-colors-and-sizes","title":"Custom Cluster Colors and Sizes\u00b6","text":""},{"location":"maplibre/clustering/#clustering-with-more-color-steps","title":"Clustering with More Color Steps\u00b6","text":""},{"location":"maplibre/clustering/#disable-zoom-on-click","title":"Disable Zoom on Click\u00b6","text":""},{"location":"maplibre/clustering/#remove-cluster-layer","title":"Remove Cluster Layer\u00b6","text":""},{"location":"maplibre/clustering/#export-to-html","title":"Export to HTML\u00b6","text":""},{"location":"maplibre/cog_layer/","title":"Cog layer","text":"In\u00a0[\u00a0]: Copied! <pre># %pip install -U anymap-ts\n</pre> # %pip install -U anymap-ts In\u00a0[\u00a0]: Copied! <pre>from anymap_ts import Map\n\n# NLCD 2024 Land Cover COG (Continental US)\nCOG_URL = \"https://s3.us-east-1.amazonaws.com/ds-deck.gl-raster-public/cog/Annual_NLCD_LndCov_2024_CU_C1V1.tif\"\n\n# Create a MapLibre map\nm = Map(center=[-98.5, 39.8], zoom=4, style=\"dark-matter\")\n\n# Add the COG layer - the map will automatically fit to the COG bounds\nm.add_cog_layer(COG_URL, name=\"nlcd-landcover\", opacity=1.0)\n\nm\n</pre> from anymap_ts import Map  # NLCD 2024 Land Cover COG (Continental US) COG_URL = \"https://s3.us-east-1.amazonaws.com/ds-deck.gl-raster-public/cog/Annual_NLCD_LndCov_2024_CU_C1V1.tif\"  # Create a MapLibre map m = Map(center=[-98.5, 39.8], zoom=4, style=\"dark-matter\")  # Add the COG layer - the map will automatically fit to the COG bounds m.add_cog_layer(COG_URL, name=\"nlcd-landcover\", opacity=1.0)  m In\u00a0[\u00a0]: Copied! <pre>from anymap_ts import DeckGLMap\n\n# Create a DeckGL map\nm2 = DeckGLMap(center=[-98.5, 39.8], zoom=4, style=\"dark-matter\")\n\n# Add the COG layer with debug mode to visualize the reprojection mesh\nm2.add_cog_layer(\n    COG_URL,\n    name=\"nlcd-landcover-debug\",\n    debug=True,  # Show the reprojection mesh\n    debug_opacity=0.25,\n)\n\nm2\n</pre> from anymap_ts import DeckGLMap  # Create a DeckGL map m2 = DeckGLMap(center=[-98.5, 39.8], zoom=4, style=\"dark-matter\")  # Add the COG layer with debug mode to visualize the reprojection mesh m2.add_cog_layer(     COG_URL,     name=\"nlcd-landcover-debug\",     debug=True,  # Show the reprojection mesh     debug_opacity=0.25, )  m2 In\u00a0[\u00a0]: Copied! <pre>import os\nfrom anymap_ts import MapboxMap\n\n# Create a Mapbox map (requires MAPBOX_TOKEN environment variable)\n# Skip if no token is set\nif os.environ.get(\"MAPBOX_TOKEN\"):\n    m3 = MapboxMap(\n        center=[-98.5, 39.8], zoom=4, style=\"mapbox://styles/mapbox/dark-v11\"\n    )\n\n    # Add the COG layer\n    m3.add_cog_layer(COG_URL, name=\"nlcd-landcover-mapbox\", opacity=0.9)\n\n    display(m3)\nelse:\n    print(\"Set MAPBOX_TOKEN environment variable to use Mapbox maps\")\n</pre> import os from anymap_ts import MapboxMap  # Create a Mapbox map (requires MAPBOX_TOKEN environment variable) # Skip if no token is set if os.environ.get(\"MAPBOX_TOKEN\"):     m3 = MapboxMap(         center=[-98.5, 39.8], zoom=4, style=\"mapbox://styles/mapbox/dark-v11\"     )      # Add the COG layer     m3.add_cog_layer(COG_URL, name=\"nlcd-landcover-mapbox\", opacity=0.9)      display(m3) else:     print(\"Set MAPBOX_TOKEN environment variable to use Mapbox maps\") In\u00a0[\u00a0]: Copied! <pre># Export to standalone HTML\nm.to_html(\"cog_layer_example.html\")\nprint(\"Exported to cog_layer_example.html\")\n</pre> # Export to standalone HTML m.to_html(\"cog_layer_example.html\") print(\"Exported to cog_layer_example.html\")"},{"location":"maplibre/cog_layer/#cog-layer-example","title":"COG Layer Example\u00b6","text":"<p>This notebook demonstrates how to visualize Cloud Optimized GeoTIFFs (COGs) using the @developmentseed/deck.gl-geotiff package.</p> <p>The COG layer provides GPU-accelerated rendering with automatic reprojection support, allowing you to visualize large raster datasets directly in the browser without server-side processing.</p>"},{"location":"maplibre/cog_layer/#maplibre-example","title":"MapLibre Example\u00b6","text":"<p>The <code>add_cog_layer</code> method is available on the MapLibre Map class. It uses deck.gl overlay to render COG files.</p>"},{"location":"maplibre/cog_layer/#deckgl-example","title":"DeckGL Example\u00b6","text":"<p>The DeckGL map class also supports COG layers with additional debug options.</p>"},{"location":"maplibre/cog_layer/#mapbox-example","title":"Mapbox Example\u00b6","text":"<p>The Mapbox map class also supports COG layers (requires a Mapbox access token).</p>"},{"location":"maplibre/cog_layer/#configuration-options","title":"Configuration Options\u00b6","text":"<p>The <code>add_cog_layer</code> method supports several configuration options:</p> Parameter Type Default Description <code>url</code> str required URL to the Cloud Optimized GeoTIFF file <code>name</code> str auto Layer identifier <code>opacity</code> float 1.0 Layer opacity (0-1) <code>visible</code> bool True Whether layer is visible <code>debug</code> bool False Show reprojection mesh for debugging <code>debug_opacity</code> float 0.25 Opacity of debug mesh <code>max_error</code> float 0.125 Maximum reprojection error in pixels <code>fit_bounds</code> bool True Fit map to COG bounds after loading <code>before_id</code> str None ID of layer to insert before"},{"location":"maplibre/cog_layer/#about-the-dataset","title":"About the Dataset\u00b6","text":"<p>The example uses the NLCD 2024 Land Cover dataset:</p> <ul> <li>Coverage: Continental United States</li> <li>Resolution: 30 meters</li> <li>Source: USGS National Land Cover Database</li> <li>Format: Cloud Optimized GeoTIFF (COG)</li> </ul> <p>The dataset classifies land cover into categories including:</p> <ul> <li>Developed areas (open space, low/medium/high intensity)</li> <li>Forest (deciduous, evergreen, mixed)</li> <li>Agricultural (pasture, crops)</li> <li>Wetlands</li> <li>Water bodies</li> <li>And more...</li> </ul>"},{"location":"maplibre/colorbar/","title":"Colorbar","text":"In\u00a0[\u00a0]: Copied! <pre># %pip install -U anymap-ts\n</pre> # %pip install -U anymap-ts In\u00a0[\u00a0]: Copied! <pre>from anymap_ts import Map\n\nm = Map(center=[-120, 38], zoom=6)\nm.add_cog_layer(\n    \"https://data.source.coop/giswqs/opengeos/dem_90m.tif\",\n    name=\"dem\",\n)\nm.add_colorbar(\n    colormap=\"terrain\",\n    vmin=0,\n    vmax=4000,\n    label=\"Elevation\",\n    units=\"m\",\n)\nm\n</pre> from anymap_ts import Map  m = Map(center=[-120, 38], zoom=6) m.add_cog_layer(     \"https://data.source.coop/giswqs/opengeos/dem_90m.tif\",     name=\"dem\", ) m.add_colorbar(     colormap=\"terrain\",     vmin=0,     vmax=4000,     label=\"Elevation\",     units=\"m\", ) m In\u00a0[\u00a0]: Copied! <pre>m2 = Map(center=[0, 20], zoom=2)\nm2.add_colorbar(\n    colormap=\"viridis\",\n    vmin=-30,\n    vmax=40,\n    label=\"Temperature\",\n    units=\"\\u00b0C\",\n    position=\"bottom-left\",\n)\nm2\n</pre> m2 = Map(center=[0, 20], zoom=2) m2.add_colorbar(     colormap=\"viridis\",     vmin=-30,     vmax=40,     label=\"Temperature\",     units=\"\\u00b0C\",     position=\"bottom-left\", ) m2 In\u00a0[\u00a0]: Copied! <pre>m3 = Map(center=[-100, 40], zoom=4)\nm3.add_colorbar(\n    colormap=\"plasma\",\n    vmin=0,\n    vmax=100,\n    label=\"Index\",\n    orientation=\"vertical\",\n    position=\"bottom-right\",\n)\nm3\n</pre> m3 = Map(center=[-100, 40], zoom=4) m3.add_colorbar(     colormap=\"plasma\",     vmin=0,     vmax=100,     label=\"Index\",     orientation=\"vertical\",     position=\"bottom-right\", ) m3 In\u00a0[\u00a0]: Copied! <pre>m.update_colorbar(vmin=100, vmax=3000, colormap=\"inferno\")\n</pre> m.update_colorbar(vmin=100, vmax=3000, colormap=\"inferno\") In\u00a0[\u00a0]: Copied! <pre>m.remove_colorbar()\n</pre> m.remove_colorbar()"},{"location":"maplibre/colorbar/#colorbar","title":"Colorbar\u00b6","text":"<p>This notebook demonstrates how to add continuous gradient colorbars to MapLibre maps using the <code>Colorbar</code> component from maplibre-gl-components.</p>"},{"location":"maplibre/colorbar/#basic-colorbar-with-cog-layer","title":"Basic Colorbar with COG Layer\u00b6","text":""},{"location":"maplibre/colorbar/#different-colormaps","title":"Different Colormaps\u00b6","text":""},{"location":"maplibre/colorbar/#vertical-colorbar","title":"Vertical Colorbar\u00b6","text":""},{"location":"maplibre/colorbar/#update-colorbar","title":"Update Colorbar\u00b6","text":""},{"location":"maplibre/colorbar/#remove-colorbar","title":"Remove Colorbar\u00b6","text":""},{"location":"maplibre/control_grid/","title":"Control grid","text":"In\u00a0[\u00a0]: Copied! <pre># %pip install -U anymap-ts\n</pre> # %pip install -U anymap-ts In\u00a0[\u00a0]: Copied! <pre>from anymap_ts import MapLibreMap\n</pre> from anymap_ts import MapLibreMap In\u00a0[\u00a0]: Copied! <pre>m = MapLibreMap(center=[-98, 38.5], zoom=4)\nm.add_control_grid()\nm\n</pre> m = MapLibreMap(center=[-98, 38.5], zoom=4) m.add_control_grid() m In\u00a0[\u00a0]: Copied! <pre>m = MapLibreMap(center=[-98, 38.5], zoom=4)\nm.add_control_grid(exclude=[\"minimap\", \"streetView\", \"gaussianSplat\"])\nm\n</pre> m = MapLibreMap(center=[-98, 38.5], zoom=4) m.add_control_grid(exclude=[\"minimap\", \"streetView\", \"gaussianSplat\"]) m In\u00a0[\u00a0]: Copied! <pre>m = MapLibreMap(center=[-98, 38.5], zoom=4)\nm.add_control_grid(\n    default_controls=[\n        \"fullscreen\",\n        \"globe\",\n        \"terrain\",\n        \"search\",\n        \"basemap\",\n        \"measure\",\n        \"bookmark\",\n        \"print\",\n        \"inspect\",\n    ],\n)\nm\n</pre> m = MapLibreMap(center=[-98, 38.5], zoom=4) m.add_control_grid(     default_controls=[         \"fullscreen\",         \"globe\",         \"terrain\",         \"search\",         \"basemap\",         \"measure\",         \"bookmark\",         \"print\",         \"inspect\",     ], ) m In\u00a0[\u00a0]: Copied! <pre>m = MapLibreMap(center=[-98, 38.5], zoom=4)\nm.add_control_grid(\n    default_controls=[\n        \"fullscreen\",\n        \"globe\",\n        \"terrain\",\n        \"search\",\n        \"basemap\",\n        \"measure\",\n    ],\n    rows=2,\n    columns=3,\n    collapsed=False,\n)\nm\n</pre> m = MapLibreMap(center=[-98, 38.5], zoom=4) m.add_control_grid(     default_controls=[         \"fullscreen\",         \"globe\",         \"terrain\",         \"search\",         \"basemap\",         \"measure\",     ],     rows=2,     columns=3,     collapsed=False, ) m"},{"location":"maplibre/control_grid/#control-grid","title":"Control Grid\u00b6","text":"<p>This notebook demonstrates the <code>add_control_grid()</code> method, which adds a collapsible toolbar with up to 26 built-in controls (search, basemap, terrain, measure, draw, etc.) in a configurable grid layout.</p>"},{"location":"maplibre/control_grid/#all-default-controls","title":"All Default Controls\u00b6","text":"<p>Add all 26 controls with a single call. The grid dimensions are auto-calculated.</p>"},{"location":"maplibre/control_grid/#exclude-specific-controls","title":"Exclude Specific Controls\u00b6","text":"<p>Use the <code>exclude</code> parameter to remove controls you don't need.</p>"},{"location":"maplibre/control_grid/#select-specific-controls","title":"Select Specific Controls\u00b6","text":"<p>Use <code>default_controls</code> to include only the controls you want.</p>"},{"location":"maplibre/control_grid/#custom-grid-layout","title":"Custom Grid Layout\u00b6","text":"<p>Specify rows and columns for a custom grid shape.</p>"},{"location":"maplibre/data_export/","title":"Data export","text":"In\u00a0[\u00a0]: Copied! <pre># %pip install -U anymap-ts\n</pre> # %pip install -U anymap-ts In\u00a0[\u00a0]: Copied! <pre>from anymap_ts import Map\n\ngeojson = {\n    \"type\": \"FeatureCollection\",\n    \"features\": [\n        {\n            \"type\": \"Feature\",\n            \"geometry\": {\"type\": \"Point\", \"coordinates\": [-122.4, 37.8]},\n            \"properties\": {\"name\": \"San Francisco\", \"pop\": 870000},\n        },\n        {\n            \"type\": \"Feature\",\n            \"geometry\": {\"type\": \"Point\", \"coordinates\": [-118.2, 34.1]},\n            \"properties\": {\"name\": \"Los Angeles\", \"pop\": 3900000},\n        },\n        {\n            \"type\": \"Feature\",\n            \"geometry\": {\"type\": \"Point\", \"coordinates\": [-73.9, 40.7]},\n            \"properties\": {\"name\": \"New York\", \"pop\": 8300000},\n        },\n    ],\n}\n\nm = Map(center=[-98, 38], zoom=3)\nm.add_geojson(geojson, name=\"cities\", circle_radius=8, circle_color=\"#ff6600\")\nm\n</pre> from anymap_ts import Map  geojson = {     \"type\": \"FeatureCollection\",     \"features\": [         {             \"type\": \"Feature\",             \"geometry\": {\"type\": \"Point\", \"coordinates\": [-122.4, 37.8]},             \"properties\": {\"name\": \"San Francisco\", \"pop\": 870000},         },         {             \"type\": \"Feature\",             \"geometry\": {\"type\": \"Point\", \"coordinates\": [-118.2, 34.1]},             \"properties\": {\"name\": \"Los Angeles\", \"pop\": 3900000},         },         {             \"type\": \"Feature\",             \"geometry\": {\"type\": \"Point\", \"coordinates\": [-73.9, 40.7]},             \"properties\": {\"name\": \"New York\", \"pop\": 8300000},         },     ], }  m = Map(center=[-98, 38], zoom=3) m.add_geojson(geojson, name=\"cities\", circle_radius=8, circle_color=\"#ff6600\") m In\u00a0[\u00a0]: Copied! <pre># Trigger the query (sends request to JavaScript)\nm.to_geojson(\"cities\")\n</pre> # Trigger the query (sends request to JavaScript) m.to_geojson(\"cities\") In\u00a0[\u00a0]: Copied! <pre># Read the result (available after the event loop processes the response)\nresult = m.to_geojson()\nprint(result)\n</pre> # Read the result (available after the event loop processes the response) result = m.to_geojson() print(result) In\u00a0[\u00a0]: Copied! <pre># Trigger the query\nm.get_visible_features(layers=[\"cities\"])\n</pre> # Trigger the query m.get_visible_features(layers=[\"cities\"]) In\u00a0[\u00a0]: Copied! <pre># Read the result\nresult = m.get_visible_features()\nprint(result)\n</pre> # Read the result result = m.get_visible_features() print(result) In\u00a0[\u00a0]: Copied! <pre># Trigger the query\nm.to_geojson(\"cities\")\n</pre> # Trigger the query m.to_geojson(\"cities\") In\u00a0[\u00a0]: Copied! <pre># Read the result as a GeoDataFrame\ngdf = m.to_geopandas()\nif gdf is not None:\n    print(gdf)\n</pre> # Read the result as a GeoDataFrame gdf = m.to_geopandas() if gdf is not None:     print(gdf) In\u00a0[\u00a0]: Copied! <pre># Update with new data (e.g., add a city)\nupdated_geojson = {\n    \"type\": \"FeatureCollection\",\n    \"features\": [\n        {\n            \"type\": \"Feature\",\n            \"geometry\": {\"type\": \"Point\", \"coordinates\": [-122.4, 37.8]},\n            \"properties\": {\"name\": \"San Francisco\", \"pop\": 870000},\n        },\n        {\n            \"type\": \"Feature\",\n            \"geometry\": {\"type\": \"Point\", \"coordinates\": [-118.2, 34.1]},\n            \"properties\": {\"name\": \"Los Angeles\", \"pop\": 3900000},\n        },\n        {\n            \"type\": \"Feature\",\n            \"geometry\": {\"type\": \"Point\", \"coordinates\": [-73.9, 40.7]},\n            \"properties\": {\"name\": \"New York\", \"pop\": 8300000},\n        },\n        {\n            \"type\": \"Feature\",\n            \"geometry\": {\"type\": \"Point\", \"coordinates\": [-87.6, 41.9]},\n            \"properties\": {\"name\": \"Chicago\", \"pop\": 2700000},\n        },\n        {\n            \"type\": \"Feature\",\n            \"geometry\": {\"type\": \"Point\", \"coordinates\": [-95.4, 29.8]},\n            \"properties\": {\"name\": \"Houston\", \"pop\": 2300000},\n        },\n    ],\n}\n\nm.update_geojson_source(\"cities\", updated_geojson)\n</pre> # Update with new data (e.g., add a city) updated_geojson = {     \"type\": \"FeatureCollection\",     \"features\": [         {             \"type\": \"Feature\",             \"geometry\": {\"type\": \"Point\", \"coordinates\": [-122.4, 37.8]},             \"properties\": {\"name\": \"San Francisco\", \"pop\": 870000},         },         {             \"type\": \"Feature\",             \"geometry\": {\"type\": \"Point\", \"coordinates\": [-118.2, 34.1]},             \"properties\": {\"name\": \"Los Angeles\", \"pop\": 3900000},         },         {             \"type\": \"Feature\",             \"geometry\": {\"type\": \"Point\", \"coordinates\": [-73.9, 40.7]},             \"properties\": {\"name\": \"New York\", \"pop\": 8300000},         },         {             \"type\": \"Feature\",             \"geometry\": {\"type\": \"Point\", \"coordinates\": [-87.6, 41.9]},             \"properties\": {\"name\": \"Chicago\", \"pop\": 2700000},         },         {             \"type\": \"Feature\",             \"geometry\": {\"type\": \"Point\", \"coordinates\": [-95.4, 29.8]},             \"properties\": {\"name\": \"Houston\", \"pop\": 2300000},         },     ], }  m.update_geojson_source(\"cities\", updated_geojson) In\u00a0[\u00a0]: Copied! <pre>m2 = Map(center=[-122.4, 37.8], zoom=10)\nm2.add_basemap(\"OpenStreetMap\")\nm2.add_image(\n    \"custom-marker\",\n    \"https://maplibre.org/maplibre-gl-js/docs/assets/custom_marker.png\",\n)\nm2\n</pre> m2 = Map(center=[-122.4, 37.8], zoom=10) m2.add_basemap(\"OpenStreetMap\") m2.add_image(     \"custom-marker\",     \"https://maplibre.org/maplibre-gl-js/docs/assets/custom_marker.png\", ) m2"},{"location":"maplibre/data_export/#data-export-source-updates","title":"Data Export &amp; Source Updates\u00b6","text":"<p>This notebook demonstrates:</p> <ul> <li>Export to GeoJSON: Get layer data as a GeoJSON dict</li> <li>Export to GeoDataFrame: Convert layer data to a GeoDataFrame</li> <li>Get Visible Features: Query all features currently visible in the viewport</li> <li>Update GeoJSON Source: Update layer data in place for real-time dashboards</li> </ul>"},{"location":"maplibre/data_export/#setup-add-geojson-data","title":"Setup: Add GeoJSON Data\u00b6","text":""},{"location":"maplibre/data_export/#export-to-geojson","title":"Export to GeoJSON\u00b6","text":"<p>Get layer data as a GeoJSON dict. The first call triggers a query to the JavaScript side. Run it in one cell, then read the result in the next cell (the event loop processes the response between cells).</p>"},{"location":"maplibre/data_export/#get-visible-features","title":"Get Visible Features\u00b6","text":"<p>Query all features currently visible in the map viewport. Same two-cell pattern: trigger in one cell, read in the next.</p>"},{"location":"maplibre/data_export/#export-to-geodataframe","title":"Export to GeoDataFrame\u00b6","text":"<p>Requires <code>geopandas</code> to be installed. Uses the same two-cell pattern.</p>"},{"location":"maplibre/data_export/#update-geojson-source","title":"Update GeoJSON Source\u00b6","text":"<p>Update the data of an existing source in place \u2014 no need to remove and re-add layers. Essential for real-time/streaming data.</p>"},{"location":"maplibre/data_export/#custom-image-for-symbol-layers","title":"Custom Image for Symbol Layers\u00b6","text":"<p>Load a custom icon to use in symbol layers.</p>"},{"location":"maplibre/deck_advanced_layers/","title":"Deck advanced layers","text":"In\u00a0[\u00a0]: Copied! <pre># %pip install -U anymap-ts\n</pre> # %pip install -U anymap-ts In\u00a0[\u00a0]: Copied! <pre>from anymap_ts import MapLibreMap\n\ncities = [\n    {\"coordinates\": [-122.4194, 37.7749], \"population\": 870000, \"name\": \"SF\"},\n    {\"coordinates\": [-118.2437, 34.0522], \"population\": 3900000, \"name\": \"LA\"},\n    {\"coordinates\": [-73.9857, 40.7484], \"population\": 8300000, \"name\": \"NYC\"},\n    {\"coordinates\": [-87.6298, 41.8781], \"population\": 2700000, \"name\": \"Chicago\"},\n    {\"coordinates\": [-95.3698, 29.7604], \"population\": 2300000, \"name\": \"Houston\"},\n]\n\nm = MapLibreMap(center=[-98, 39], zoom=3, pitch=45)\nm.add_basemap(\"CartoDB.DarkMatter\")\nm.add_column_layer(\n    data=cities,\n    name=\"population\",\n    get_position=\"coordinates\",\n    get_elevation=\"population\",\n    elevation_scale=0.05,\n    radius=50000,\n    get_fill_color=[255, 140, 0, 200],\n    extruded=True,\n)\nm\n</pre> from anymap_ts import MapLibreMap  cities = [     {\"coordinates\": [-122.4194, 37.7749], \"population\": 870000, \"name\": \"SF\"},     {\"coordinates\": [-118.2437, 34.0522], \"population\": 3900000, \"name\": \"LA\"},     {\"coordinates\": [-73.9857, 40.7484], \"population\": 8300000, \"name\": \"NYC\"},     {\"coordinates\": [-87.6298, 41.8781], \"population\": 2700000, \"name\": \"Chicago\"},     {\"coordinates\": [-95.3698, 29.7604], \"population\": 2300000, \"name\": \"Houston\"}, ]  m = MapLibreMap(center=[-98, 39], zoom=3, pitch=45) m.add_basemap(\"CartoDB.DarkMatter\") m.add_column_layer(     data=cities,     name=\"population\",     get_position=\"coordinates\",     get_elevation=\"population\",     elevation_scale=0.05,     radius=50000,     get_fill_color=[255, 140, 0, 200],     extruded=True, ) m In\u00a0[\u00a0]: Copied! <pre>buildings = [\n    {\n        \"polygon\": [\n            [-122.42, 37.78],\n            [-122.41, 37.78],\n            [-122.41, 37.77],\n            [-122.42, 37.77],\n        ],\n        \"height\": 800,\n    },\n    {\n        \"polygon\": [\n            [-122.41, 37.79],\n            [-122.40, 37.79],\n            [-122.40, 37.78],\n            [-122.41, 37.78],\n        ],\n        \"height\": 1200,\n    },\n]\n\nm4 = MapLibreMap(center=[-122.41, 37.78], zoom=14, pitch=60)\nm4.add_basemap(\"CartoDB.DarkMatter\")\nm4.add_solid_polygon_layer(\n    data=buildings,\n    name=\"buildings\",\n    get_fill_color=[0, 150, 255, 128],\n    get_elevation=\"height\",\n    extruded=True,\n    wireframe=True,\n)\nm4\n</pre> buildings = [     {         \"polygon\": [             [-122.42, 37.78],             [-122.41, 37.78],             [-122.41, 37.77],             [-122.42, 37.77],         ],         \"height\": 800,     },     {         \"polygon\": [             [-122.41, 37.79],             [-122.40, 37.79],             [-122.40, 37.78],             [-122.41, 37.78],         ],         \"height\": 1200,     }, ]  m4 = MapLibreMap(center=[-122.41, 37.78], zoom=14, pitch=60) m4.add_basemap(\"CartoDB.DarkMatter\") m4.add_solid_polygon_layer(     data=buildings,     name=\"buildings\",     get_fill_color=[0, 150, 255, 128],     get_elevation=\"height\",     extruded=True,     wireframe=True, ) m4 In\u00a0[\u00a0]: Copied! <pre>m5 = MapLibreMap(center=[-122.4, 37.75], zoom=11)\nm5.add_bitmap_layer(\n    image=\"https://raw.githubusercontent.com/visgl/deck.gl-data/master/website/sf-districts.png\",\n    bounds=[-122.519, 37.7045, -122.355, 37.829],\n    name=\"overlay\",\n    opacity=0.7,\n)\nm5\n</pre> m5 = MapLibreMap(center=[-122.4, 37.75], zoom=11) m5.add_bitmap_layer(     image=\"https://raw.githubusercontent.com/visgl/deck.gl-data/master/website/sf-districts.png\",     bounds=[-122.519, 37.7045, -122.355, 37.829],     name=\"overlay\",     opacity=0.7, ) m5 In\u00a0[\u00a0]: Copied! <pre>import random\n\nrandom.seed(42)\ngrid_cells = [\n    {\n        \"coordinates\": [-122.4 + i * 0.01, 37.75 + j * 0.01],\n        \"value\": random.randint(100, 2000),\n        \"color\": [\n            int(255 * random.random()),\n            int(200 * random.random()),\n            100,\n            200,\n        ],\n    }\n    for i in range(10)\n    for j in range(10)\n]\n\nm6 = MapLibreMap(center=[-122.35, 37.8], zoom=12, pitch=45)\nm6.add_basemap(\"CartoDB.DarkMatter\")\nm6.add_grid_cell_layer(\n    data=grid_cells,\n    name=\"grid-cells\",\n    get_color=\"color\",\n    get_elevation=\"value\",\n    cell_size=500,\n    elevation_scale=2,\n    extruded=True,\n)\nm6\n</pre> import random  random.seed(42) grid_cells = [     {         \"coordinates\": [-122.4 + i * 0.01, 37.75 + j * 0.01],         \"value\": random.randint(100, 2000),         \"color\": [             int(255 * random.random()),             int(200 * random.random()),             100,             200,         ],     }     for i in range(10)     for j in range(10) ]  m6 = MapLibreMap(center=[-122.35, 37.8], zoom=12, pitch=45) m6.add_basemap(\"CartoDB.DarkMatter\") m6.add_grid_cell_layer(     data=grid_cells,     name=\"grid-cells\",     get_color=\"color\",     get_elevation=\"value\",     cell_size=500,     elevation_scale=2,     extruded=True, ) m6 In\u00a0[\u00a0]: Copied! <pre>m.remove_deck_layer(\"population\")\n</pre> m.remove_deck_layer(\"population\")"},{"location":"maplibre/deck_advanced_layers/#advanced-deckgl-layers-on-maplibre","title":"Advanced Deck.gl Layers on MapLibre\u00b6","text":"<p>This notebook demonstrates advanced deck.gl layers on MapLibreMap, including:</p> <ul> <li>Column, Solid Polygon layers</li> <li>Bitmap, Grid Cell layers</li> </ul>"},{"location":"maplibre/deck_advanced_layers/#column-layer","title":"Column Layer\u00b6","text":"<p>Render 3D columns (bar charts) at map positions.</p>"},{"location":"maplibre/deck_advanced_layers/#solid-polygon-layer","title":"Solid Polygon Layer\u00b6","text":"<p>Render extruded 3D polygons.</p>"},{"location":"maplibre/deck_advanced_layers/#bitmap-layer","title":"Bitmap Layer\u00b6","text":"<p>Overlay a raster image on the map with GPU rendering.</p>"},{"location":"maplibre/deck_advanced_layers/#grid-cell-layer","title":"Grid Cell Layer\u00b6","text":"<p>Render pre-aggregated grid cells with elevation.</p>"},{"location":"maplibre/deck_advanced_layers/#remove-layers","title":"Remove Layers\u00b6","text":""},{"location":"maplibre/deck_layers/","title":"Deck layers","text":"In\u00a0[\u00a0]: Copied! <pre># %pip install -U anymap-ts\n</pre> # %pip install -U anymap-ts In\u00a0[\u00a0]: Copied! <pre>from anymap_ts import MapLibreMap\n\npoints = [\n    {\"coordinates\": [-122.4194, 37.7749], \"size\": 100, \"name\": \"San Francisco\"},\n    {\"coordinates\": [-118.2437, 34.0522], \"size\": 200, \"name\": \"Los Angeles\"},\n    {\"coordinates\": [-73.9857, 40.7484], \"size\": 300, \"name\": \"New York\"},\n    {\"coordinates\": [-87.6298, 41.8781], \"size\": 150, \"name\": \"Chicago\"},\n    {\"coordinates\": [-95.3698, 29.7604], \"size\": 120, \"name\": \"Houston\"},\n]\n\nm = MapLibreMap(center=[-98, 39], zoom=3)\nm.add_basemap(\"CartoDB.DarkMatter\")\nm.add_scatterplot_layer(\n    data=points,\n    name=\"cities\",\n    get_position=\"coordinates\",\n    get_radius=\"size\",\n    get_fill_color=[255, 140, 0, 200],\n    radius_scale=100,\n    radius_min_pixels=5,\n)\nm\n</pre> from anymap_ts import MapLibreMap  points = [     {\"coordinates\": [-122.4194, 37.7749], \"size\": 100, \"name\": \"San Francisco\"},     {\"coordinates\": [-118.2437, 34.0522], \"size\": 200, \"name\": \"Los Angeles\"},     {\"coordinates\": [-73.9857, 40.7484], \"size\": 300, \"name\": \"New York\"},     {\"coordinates\": [-87.6298, 41.8781], \"size\": 150, \"name\": \"Chicago\"},     {\"coordinates\": [-95.3698, 29.7604], \"size\": 120, \"name\": \"Houston\"}, ]  m = MapLibreMap(center=[-98, 39], zoom=3) m.add_basemap(\"CartoDB.DarkMatter\") m.add_scatterplot_layer(     data=points,     name=\"cities\",     get_position=\"coordinates\",     get_radius=\"size\",     get_fill_color=[255, 140, 0, 200],     radius_scale=100,     radius_min_pixels=5, ) m In\u00a0[\u00a0]: Copied! <pre>routes = [\n    {\n        \"path\": [\n            [-122.4194, 37.7749],\n            [-121.8853, 37.3387],\n            [-121.4944, 38.5816],\n            [-120.5, 37.5],\n        ],\n        \"name\": \"Route A\",\n    },\n    {\n        \"path\": [\n            [-122.4194, 37.7749],\n            [-122.2712, 37.8044],\n            [-122.0308, 37.3382],\n        ],\n        \"name\": \"Route B\",\n    },\n]\n\nm2 = MapLibreMap(center=[-121.5, 37.8], zoom=8)\nm2.add_basemap(\"CartoDB.DarkMatter\")\nm2.add_path_layer(\n    data=routes,\n    name=\"routes\",\n    get_color=[0, 200, 255, 200],\n    get_width=5,\n    width_min_pixels=2,\n)\nm2\n</pre> routes = [     {         \"path\": [             [-122.4194, 37.7749],             [-121.8853, 37.3387],             [-121.4944, 38.5816],             [-120.5, 37.5],         ],         \"name\": \"Route A\",     },     {         \"path\": [             [-122.4194, 37.7749],             [-122.2712, 37.8044],             [-122.0308, 37.3382],         ],         \"name\": \"Route B\",     }, ]  m2 = MapLibreMap(center=[-121.5, 37.8], zoom=8) m2.add_basemap(\"CartoDB.DarkMatter\") m2.add_path_layer(     data=routes,     name=\"routes\",     get_color=[0, 200, 255, 200],     get_width=5,     width_min_pixels=2, ) m2 In\u00a0[\u00a0]: Copied! <pre>polygons = [\n    {\n        \"polygon\": [\n            [-122.45, 37.80],\n            [-122.40, 37.80],\n            [-122.40, 37.75],\n            [-122.45, 37.75],\n        ],\n        \"height\": 500,\n        \"name\": \"Zone A\",\n    },\n    {\n        \"polygon\": [\n            [-122.40, 37.80],\n            [-122.35, 37.80],\n            [-122.35, 37.75],\n            [-122.40, 37.75],\n        ],\n        \"height\": 1000,\n        \"name\": \"Zone B\",\n    },\n]\n\nm3 = MapLibreMap(center=[-122.4, 37.77], zoom=13, pitch=45)\nm3.add_basemap(\"CartoDB.DarkMatter\")\nm3.add_polygon_layer(\n    data=polygons,\n    name=\"zones\",\n    get_fill_color=[0, 128, 255, 128],\n    get_line_color=[255, 255, 255, 255],\n    get_elevation=\"height\",\n    extruded=True,\n)\nm3\n</pre> polygons = [     {         \"polygon\": [             [-122.45, 37.80],             [-122.40, 37.80],             [-122.40, 37.75],             [-122.45, 37.75],         ],         \"height\": 500,         \"name\": \"Zone A\",     },     {         \"polygon\": [             [-122.40, 37.80],             [-122.35, 37.80],             [-122.35, 37.75],             [-122.40, 37.75],         ],         \"height\": 1000,         \"name\": \"Zone B\",     }, ]  m3 = MapLibreMap(center=[-122.4, 37.77], zoom=13, pitch=45) m3.add_basemap(\"CartoDB.DarkMatter\") m3.add_polygon_layer(     data=polygons,     name=\"zones\",     get_fill_color=[0, 128, 255, 128],     get_line_color=[255, 255, 255, 255],     get_elevation=\"height\",     extruded=True, ) m3 In\u00a0[\u00a0]: Copied! <pre>import random\n\nrandom.seed(42)\nhex_points = [\n    {\"coordinates\": [-122.4 + random.gauss(0, 0.05), 37.78 + random.gauss(0, 0.03)]}\n    for _ in range(500)\n]\n\nm4 = MapLibreMap(center=[-122.4, 37.78], zoom=11, pitch=45)\nm4.add_basemap(\"CartoDB.DarkMatter\")\nm4.add_hexagon_layer(\n    data=hex_points,\n    name=\"hexbins\",\n    radius=300,\n    elevation_scale=10,\n    extruded=True,\n)\nm4\n</pre> import random  random.seed(42) hex_points = [     {\"coordinates\": [-122.4 + random.gauss(0, 0.05), 37.78 + random.gauss(0, 0.03)]}     for _ in range(500) ]  m4 = MapLibreMap(center=[-122.4, 37.78], zoom=11, pitch=45) m4.add_basemap(\"CartoDB.DarkMatter\") m4.add_hexagon_layer(     data=hex_points,     name=\"hexbins\",     radius=300,     elevation_scale=10,     extruded=True, ) m4 In\u00a0[\u00a0]: Copied! <pre>m5 = MapLibreMap(center=[-122.4, 37.78], zoom=11, pitch=45)\nm5.add_basemap(\"CartoDB.DarkMatter\")\nm5.add_grid_layer(\n    data=hex_points,\n    name=\"grid\",\n    cell_size=300,\n    elevation_scale=10,\n    extruded=True,\n)\nm5\n</pre> m5 = MapLibreMap(center=[-122.4, 37.78], zoom=11, pitch=45) m5.add_basemap(\"CartoDB.DarkMatter\") m5.add_grid_layer(     data=hex_points,     name=\"grid\",     cell_size=300,     elevation_scale=10,     extruded=True, ) m5 In\u00a0[\u00a0]: Copied! <pre>weighted_points = [\n    {\n        \"coordinates\": [-122.4 + random.gauss(0, 0.05), 37.78 + random.gauss(0, 0.03)],\n        \"weight\": random.randint(1, 10),\n    }\n    for _ in range(300)\n]\n\nm6 = MapLibreMap(center=[-122.4, 37.78], zoom=11)\nm6.add_basemap(\"CartoDB.DarkMatter\")\nm6.add_deck_heatmap_layer(\n    data=weighted_points,\n    name=\"heatmap\",\n    get_weight=\"weight\",\n    radius_pixels=40,\n    intensity=1.5,\n)\nm6\n</pre> weighted_points = [     {         \"coordinates\": [-122.4 + random.gauss(0, 0.05), 37.78 + random.gauss(0, 0.03)],         \"weight\": random.randint(1, 10),     }     for _ in range(300) ]  m6 = MapLibreMap(center=[-122.4, 37.78], zoom=11) m6.add_basemap(\"CartoDB.DarkMatter\") m6.add_deck_heatmap_layer(     data=weighted_points,     name=\"heatmap\",     get_weight=\"weight\",     radius_pixels=40,     intensity=1.5, ) m6 In\u00a0[\u00a0]: Copied! <pre>labels = [\n    {\"coordinates\": [-122.4194, 37.7749], \"text\": \"San Francisco\"},\n    {\"coordinates\": [-118.2437, 34.0522], \"text\": \"Los Angeles\"},\n    {\"coordinates\": [-73.9857, 40.7484], \"text\": \"New York\"},\n    {\"coordinates\": [-87.6298, 41.8781], \"text\": \"Chicago\"},\n    {\"coordinates\": [-95.3698, 29.7604], \"text\": \"Houston\"},\n]\n\nm7 = MapLibreMap(center=[-98, 39], zoom=3)\nm7.add_basemap(\"CartoDB.DarkMatter\")\nm7.add_text_layer(\n    data=labels,\n    name=\"city-labels\",\n    get_size=16,\n    get_color=[255, 255, 255, 255],\n)\nm7\n</pre> labels = [     {\"coordinates\": [-122.4194, 37.7749], \"text\": \"San Francisco\"},     {\"coordinates\": [-118.2437, 34.0522], \"text\": \"Los Angeles\"},     {\"coordinates\": [-73.9857, 40.7484], \"text\": \"New York\"},     {\"coordinates\": [-87.6298, 41.8781], \"text\": \"Chicago\"},     {\"coordinates\": [-95.3698, 29.7604], \"text\": \"Houston\"}, ]  m7 = MapLibreMap(center=[-98, 39], zoom=3) m7.add_basemap(\"CartoDB.DarkMatter\") m7.add_text_layer(     data=labels,     name=\"city-labels\",     get_size=16,     get_color=[255, 255, 255, 255], ) m7 In\u00a0[\u00a0]: Copied! <pre>lines = [\n    {\"sourcePosition\": [-122.4194, 37.7749], \"targetPosition\": [-73.9857, 40.7484]},\n    {\"sourcePosition\": [-122.4194, 37.7749], \"targetPosition\": [-87.6298, 41.8781]},\n    {\"sourcePosition\": [-122.4194, 37.7749], \"targetPosition\": [-118.2437, 34.0522]},\n]\n\nm8 = MapLibreMap(center=[-98, 39], zoom=3)\nm8.add_basemap(\"CartoDB.DarkMatter\")\nm8.add_line_layer(\n    data=lines,\n    name=\"connections\",\n    get_color=[0, 255, 128, 200],\n    get_width=2,\n)\nm8\n</pre> lines = [     {\"sourcePosition\": [-122.4194, 37.7749], \"targetPosition\": [-73.9857, 40.7484]},     {\"sourcePosition\": [-122.4194, 37.7749], \"targetPosition\": [-87.6298, 41.8781]},     {\"sourcePosition\": [-122.4194, 37.7749], \"targetPosition\": [-118.2437, 34.0522]}, ]  m8 = MapLibreMap(center=[-98, 39], zoom=3) m8.add_basemap(\"CartoDB.DarkMatter\") m8.add_line_layer(     data=lines,     name=\"connections\",     get_color=[0, 255, 128, 200],     get_width=2, ) m8 In\u00a0[\u00a0]: Copied! <pre>m9 = MapLibreMap(center=[-122.4, 37.78], zoom=11)\nm9.add_basemap(\"CartoDB.DarkMatter\")\nm9.add_contour_layer(\n    data=hex_points,\n    name=\"contours\",\n    cell_size=200,\n    contours=[\n        {\"threshold\": 1, \"color\": [255, 255, 178], \"strokeWidth\": 1},\n        {\"threshold\": 3, \"color\": [253, 141, 60], \"strokeWidth\": 2},\n        {\"threshold\": 5, \"color\": [189, 0, 38], \"strokeWidth\": 3},\n    ],\n)\nm9\n</pre> m9 = MapLibreMap(center=[-122.4, 37.78], zoom=11) m9.add_basemap(\"CartoDB.DarkMatter\") m9.add_contour_layer(     data=hex_points,     name=\"contours\",     cell_size=200,     contours=[         {\"threshold\": 1, \"color\": [255, 255, 178], \"strokeWidth\": 1},         {\"threshold\": 3, \"color\": [253, 141, 60], \"strokeWidth\": 2},         {\"threshold\": 5, \"color\": [189, 0, 38], \"strokeWidth\": 3},     ], ) m9 In\u00a0[\u00a0]: Copied! <pre>m10 = MapLibreMap(center=[-122.4, 37.78], zoom=11)\nm10.add_basemap(\"CartoDB.DarkMatter\")\nm10.add_screen_grid_layer(\n    data=hex_points,\n    name=\"screengrid\",\n    cell_size_pixels=30,\n    opacity=0.6,\n)\nm10\n</pre> m10 = MapLibreMap(center=[-122.4, 37.78], zoom=11) m10.add_basemap(\"CartoDB.DarkMatter\") m10.add_screen_grid_layer(     data=hex_points,     name=\"screengrid\",     cell_size_pixels=30,     opacity=0.6, ) m10 In\u00a0[\u00a0]: Copied! <pre>trips = [\n    {\n        \"waypoints\": [\n            [-122.4194, 37.7749],\n            [-122.40, 37.78],\n            [-122.38, 37.77],\n            [-122.36, 37.79],\n        ],\n        \"timestamps\": [0, 50, 100, 150],\n    },\n    {\n        \"waypoints\": [\n            [-122.45, 37.77],\n            [-122.43, 37.76],\n            [-122.41, 37.78],\n            [-122.39, 37.76],\n        ],\n        \"timestamps\": [0, 40, 80, 120],\n    },\n]\n\nm11 = MapLibreMap(center=[-122.4, 37.77], zoom=13)\nm11.add_basemap(\"CartoDB.DarkMatter\")\nm11.add_trips_layer(\n    data=trips,\n    name=\"trips\",\n    get_color=[253, 128, 93],\n    trail_length=100,\n    current_time=75,\n    width_min_pixels=3,\n)\nm11\n</pre> trips = [     {         \"waypoints\": [             [-122.4194, 37.7749],             [-122.40, 37.78],             [-122.38, 37.77],             [-122.36, 37.79],         ],         \"timestamps\": [0, 50, 100, 150],     },     {         \"waypoints\": [             [-122.45, 37.77],             [-122.43, 37.76],             [-122.41, 37.78],             [-122.39, 37.76],         ],         \"timestamps\": [0, 40, 80, 120],     }, ]  m11 = MapLibreMap(center=[-122.4, 37.77], zoom=13) m11.add_basemap(\"CartoDB.DarkMatter\") m11.add_trips_layer(     data=trips,     name=\"trips\",     get_color=[253, 128, 93],     trail_length=100,     current_time=75,     width_min_pixels=3, ) m11 In\u00a0[\u00a0]: Copied! <pre>m12 = MapLibreMap(center=[-98, 39], zoom=3)\nm12.add_basemap(\"CartoDB.DarkMatter\")\nm12.add_deckgl_layer(\n    layer_type=\"ScatterplotLayer\",\n    data=points,\n    name=\"generic-scatter\",\n    getPosition=\"coordinates\",\n    getRadius=50000,\n    getFillColor=[255, 0, 128, 200],\n    radiusMinPixels=5,\n)\nm12\n</pre> m12 = MapLibreMap(center=[-98, 39], zoom=3) m12.add_basemap(\"CartoDB.DarkMatter\") m12.add_deckgl_layer(     layer_type=\"ScatterplotLayer\",     data=points,     name=\"generic-scatter\",     getPosition=\"coordinates\",     getRadius=50000,     getFillColor=[255, 0, 128, 200],     radiusMinPixels=5, ) m12 In\u00a0[\u00a0]: Copied! <pre>m12.remove_deck_layer(\"generic-scatter\")\n</pre> m12.remove_deck_layer(\"generic-scatter\")"},{"location":"maplibre/deck_layers/#deckgl-layers-on-maplibre","title":"Deck.gl Layers on MapLibre\u00b6","text":"<p>This notebook demonstrates the deck.gl visualization layers available directly on MapLibreMap.</p> <p>These GPU-accelerated layers include:</p> <ul> <li>Scatterplot, Path, Polygon, Line layers</li> <li>Hexagon, Grid, Heatmap aggregation layers</li> <li>Icon, Text label layers</li> <li>Contour, Screen Grid layers</li> <li>Trips animation layer</li> <li>GeoJSON layer with auto-styling</li> </ul>"},{"location":"maplibre/deck_layers/#scatterplot-layer","title":"Scatterplot Layer\u00b6","text":"<p>Render sized and colored circles at point locations.</p>"},{"location":"maplibre/deck_layers/#path-layer","title":"Path Layer\u00b6","text":"<p>Render polylines for routes and trajectories.</p>"},{"location":"maplibre/deck_layers/#polygon-layer","title":"Polygon Layer\u00b6","text":"<p>Render filled polygons with optional 3D extrusion.</p>"},{"location":"maplibre/deck_layers/#hexagon-layer","title":"Hexagon Layer\u00b6","text":"<p>Aggregate points into 3D hexagonal bins.</p>"},{"location":"maplibre/deck_layers/#grid-layer","title":"Grid Layer\u00b6","text":"<p>Aggregate points into a square grid with 3D elevation.</p>"},{"location":"maplibre/deck_layers/#deckgl-heatmap-layer","title":"Deck.gl Heatmap Layer\u00b6","text":"<p>GPU-accelerated heatmap alternative to the native MapLibre heatmap.</p>"},{"location":"maplibre/deck_layers/#text-layer","title":"Text Layer\u00b6","text":"<p>Place text labels at specified positions.</p>"},{"location":"maplibre/deck_layers/#line-layer","title":"Line Layer\u00b6","text":"<p>Render straight lines between source and target positions.</p>"},{"location":"maplibre/deck_layers/#contour-layer","title":"Contour Layer\u00b6","text":"<p>Generate isolines and isobands from point data.</p>"},{"location":"maplibre/deck_layers/#screen-grid-layer","title":"Screen Grid Layer\u00b6","text":"<p>Aggregate points into a grid in screen space.</p>"},{"location":"maplibre/deck_layers/#trips-layer","title":"Trips Layer\u00b6","text":"<p>Animate trajectories over time.</p>"},{"location":"maplibre/deck_layers/#generic-deckgl-layer","title":"Generic Deck.gl Layer\u00b6","text":"<p>Use <code>add_deckgl_layer()</code> to add any deck.gl layer type with a single flexible interface.</p>"},{"location":"maplibre/deck_layers/#remove-deckgl-layers","title":"Remove Deck.gl Layers\u00b6","text":""},{"location":"maplibre/feature_query_filter/","title":"Feature query filter","text":"In\u00a0[\u00a0]: Copied! <pre># %pip install -U anymap-ts\n</pre> # %pip install -U anymap-ts In\u00a0[\u00a0]: Copied! <pre>from anymap_ts import Map\n\nm = Map(center=[-98.5, 39.8], zoom=3)\nm.add_geojson(\n    \"https://d2ad6b4ur7yvpq.cloudfront.net/naturalearth-3.3.0/ne_110m_admin_0_countries.geojson\",\n    name=\"countries\",\n    layer_type=\"fill\",\n    paint={\n        \"fill-color\": \"#627BC1\",\n        \"fill-opacity\": 0.5,\n        \"fill-outline-color\": \"#333\",\n    },\n)\nm\n</pre> from anymap_ts import Map  m = Map(center=[-98.5, 39.8], zoom=3) m.add_geojson(     \"https://d2ad6b4ur7yvpq.cloudfront.net/naturalearth-3.3.0/ne_110m_admin_0_countries.geojson\",     name=\"countries\",     layer_type=\"fill\",     paint={         \"fill-color\": \"#627BC1\",         \"fill-opacity\": 0.5,         \"fill-outline-color\": \"#333\",     }, ) m In\u00a0[\u00a0]: Copied! <pre>m.set_filter(\"countries\", [\"&gt;\", [\"get\", \"pop_est\"], 100000000])\n</pre> m.set_filter(\"countries\", [\"&gt;\", [\"get\", \"pop_est\"], 100000000]) In\u00a0[\u00a0]: Copied! <pre>m.set_filter(\"countries\", [\"==\", [\"get\", \"continent\"], \"Europe\"])\n</pre> m.set_filter(\"countries\", [\"==\", [\"get\", \"continent\"], \"Europe\"]) In\u00a0[\u00a0]: Copied! <pre>m.set_filter(\"countries\", None)\n</pre> m.set_filter(\"countries\", None) In\u00a0[\u00a0]: Copied! <pre>import time\n\nm.query_rendered_features(layers=[\"countries\"])\ntime.sleep(1)  # Wait for async response\nfeatures = m.queried_features\nprint(f\"Number of features: {len(features.get('features', []))}\")\n</pre> import time  m.query_rendered_features(layers=[\"countries\"]) time.sleep(1)  # Wait for async response features = m.queried_features print(f\"Number of features: {len(features.get('features', []))}\") In\u00a0[\u00a0]: Copied! <pre>m.query_rendered_features(\n    layers=[\"countries\"],\n    filter_expression=[\"==\", [\"get\", \"continent\"], \"Africa\"],\n)\ntime.sleep(1)\nfeatures = m.queried_features\nprint(f\"African countries in viewport: {len(features.get('features', []))}\")\nfor f in features.get(\"features\", [])[:5]:\n    print(f\"  - {f.get('properties', {}).get('name', 'Unknown')}\")\n</pre> m.query_rendered_features(     layers=[\"countries\"],     filter_expression=[\"==\", [\"get\", \"continent\"], \"Africa\"], ) time.sleep(1) features = m.queried_features print(f\"African countries in viewport: {len(features.get('features', []))}\") for f in features.get(\"features\", [])[:5]:     print(f\"  - {f.get('properties', {}).get('name', 'Unknown')}\")"},{"location":"maplibre/feature_query_filter/#feature-query-filter","title":"Feature Query &amp; Filter\u00b6","text":"<p>This notebook demonstrates how to programmatically filter layers and query visible features on MapLibre maps.</p>"},{"location":"maplibre/feature_query_filter/#load-geojson-data","title":"Load GeoJSON Data\u00b6","text":""},{"location":"maplibre/feature_query_filter/#apply-a-filter","title":"Apply a Filter\u00b6","text":"<p>Show only countries with population greater than 100 million.</p>"},{"location":"maplibre/feature_query_filter/#change-filter","title":"Change Filter\u00b6","text":"<p>Show only European countries.</p>"},{"location":"maplibre/feature_query_filter/#clear-filter","title":"Clear Filter\u00b6","text":"<p>Pass <code>None</code> to clear the filter and show all features.</p>"},{"location":"maplibre/feature_query_filter/#query-rendered-features","title":"Query Rendered Features\u00b6","text":"<p>Query features currently visible in the viewport.</p>"},{"location":"maplibre/feature_query_filter/#query-with-filter-expression","title":"Query with Filter Expression\u00b6","text":"<p>Query only features matching a filter.</p>"},{"location":"maplibre/flatgeobuf/","title":"Flatgeobuf","text":"In\u00a0[\u00a0]: Copied! <pre># %pip install -U anymap-ts\n</pre> # %pip install -U anymap-ts In\u00a0[\u00a0]: Copied! <pre>from anymap_ts import Map\n\nm = Map(center=[-100, 40], zoom=4)\nm.add_flatgeobuf(\n    \"https://flatgeobuf.org/test/data/UScounties.fgb\",\n    name=\"counties\",\n)\nm\n</pre> from anymap_ts import Map  m = Map(center=[-100, 40], zoom=4) m.add_flatgeobuf(     \"https://flatgeobuf.org/test/data/UScounties.fgb\",     name=\"counties\", ) m In\u00a0[\u00a0]: Copied! <pre>m2 = Map(center=[-100, 40], zoom=4)\nm2.add_flatgeobuf(\n    \"https://flatgeobuf.org/test/data/UScounties.fgb\",\n    name=\"counties-styled\",\n    paint={\n        \"fill-color\": \"#088\",\n        \"fill-opacity\": 0.4,\n        \"fill-outline-color\": \"#333\",\n    },\n)\nm2\n</pre> m2 = Map(center=[-100, 40], zoom=4) m2.add_flatgeobuf(     \"https://flatgeobuf.org/test/data/UScounties.fgb\",     name=\"counties-styled\",     paint={         \"fill-color\": \"#088\",         \"fill-opacity\": 0.4,         \"fill-outline-color\": \"#333\",     }, ) m2 In\u00a0[\u00a0]: Copied! <pre>m.remove_flatgeobuf(\"counties\")\n</pre> m.remove_flatgeobuf(\"counties\")"},{"location":"maplibre/flatgeobuf/#flatgeobuf-layer","title":"FlatGeobuf Layer\u00b6","text":"<p>This notebook demonstrates how to load and display FlatGeobuf files on MapLibre maps. FlatGeobuf is a cloud-native vector format that supports streaming reads.</p>"},{"location":"maplibre/flatgeobuf/#load-flatgeobuf-from-url","title":"Load FlatGeobuf from URL\u00b6","text":""},{"location":"maplibre/flatgeobuf/#custom-styling","title":"Custom Styling\u00b6","text":""},{"location":"maplibre/flatgeobuf/#remove-flatgeobuf-layer","title":"Remove FlatGeobuf Layer\u00b6","text":""},{"location":"maplibre/globe_projection/","title":"Globe projection","text":"In\u00a0[\u00a0]: Copied! <pre># %pip install -U anymap-ts\n</pre> # %pip install -U anymap-ts In\u00a0[\u00a0]: Copied! <pre>from anymap_ts import Map\n\nm = Map(center=[0, 20], zoom=1, projection=\"globe\")\nm.add_basemap(\"OpenStreetMap\")\nm\n</pre> from anymap_ts import Map  m = Map(center=[0, 20], zoom=1, projection=\"globe\") m.add_basemap(\"OpenStreetMap\") m In\u00a0[\u00a0]: Copied! <pre>m2 = Map(center=[0, 20], zoom=1, projection=\"globe\")\nm2.add_basemap(\"Esri.WorldImagery\")\nm2\n</pre> m2 = Map(center=[0, 20], zoom=1, projection=\"globe\") m2.add_basemap(\"Esri.WorldImagery\") m2 In\u00a0[\u00a0]: Copied! <pre>m.set_projection(\"mercator\")\n</pre> m.set_projection(\"mercator\") In\u00a0[\u00a0]: Copied! <pre>flights = [\n    {\"source\": [-122.4, 37.8], \"target\": [139.7, 35.7]},\n    {\"source\": [-122.4, 37.8], \"target\": [-0.1, 51.5]},\n    {\"source\": [-122.4, 37.8], \"target\": [151.2, -33.9]},\n    {\"source\": [-73.9, 40.7], \"target\": [2.3, 48.9]},\n    {\"source\": [-73.9, 40.7], \"target\": [55.3, 25.3]},\n]\n\nm3 = Map(center=[0, 20], zoom=1, projection=\"globe\")\nm3.add_basemap(\"CartoDB.DarkMatter\")\nm3.add_arc_layer(\n    data=flights,\n    name=\"flights\",\n    get_source_color=[0, 200, 255, 255],\n    get_target_color=[255, 100, 50, 255],\n    get_width=2,\n    great_circle=True,\n)\nm3\n</pre> flights = [     {\"source\": [-122.4, 37.8], \"target\": [139.7, 35.7]},     {\"source\": [-122.4, 37.8], \"target\": [-0.1, 51.5]},     {\"source\": [-122.4, 37.8], \"target\": [151.2, -33.9]},     {\"source\": [-73.9, 40.7], \"target\": [2.3, 48.9]},     {\"source\": [-73.9, 40.7], \"target\": [55.3, 25.3]}, ]  m3 = Map(center=[0, 20], zoom=1, projection=\"globe\") m3.add_basemap(\"CartoDB.DarkMatter\") m3.add_arc_layer(     data=flights,     name=\"flights\",     get_source_color=[0, 200, 255, 255],     get_target_color=[255, 100, 50, 255],     get_width=2,     great_circle=True, ) m3 In\u00a0[\u00a0]: Copied! <pre>m3.to_html(\"globe_projection_example.html\")\n</pre> m3.to_html(\"globe_projection_example.html\")"},{"location":"maplibre/globe_projection/#globe-projection","title":"Globe Projection\u00b6","text":"<p>MapLibre GL JS v4+ supports globe projection, enabling a 3D globe view.</p> <p>Use <code>projection=\"globe\"</code> in the Map constructor, or call <code>set_projection()</code> to switch dynamically between <code>mercator</code> (flat) and <code>globe</code> (3D sphere) projections.</p>"},{"location":"maplibre/globe_projection/#globe-view","title":"Globe View\u00b6","text":""},{"location":"maplibre/globe_projection/#globe-with-satellite-imagery","title":"Globe with Satellite Imagery\u00b6","text":""},{"location":"maplibre/globe_projection/#switch-back-to-mercator","title":"Switch Back to Mercator\u00b6","text":"<p>You can switch projections dynamically.</p>"},{"location":"maplibre/globe_projection/#globe-with-arc-layer","title":"Globe with Arc Layer\u00b6","text":"<p>Combine globe projection with deck.gl layers for striking visualizations.</p>"},{"location":"maplibre/globe_projection/#export-to-html","title":"Export to HTML\u00b6","text":""},{"location":"maplibre/image_overlay/","title":"Image overlay","text":"In\u00a0[\u00a0]: Copied! <pre># %pip install -U anymap-ts\n</pre> # %pip install -U anymap-ts In\u00a0[\u00a0]: Copied! <pre>from anymap_ts import Map\n\nm = Map(center=[-75.0, 42.0], zoom=5)\n\n# Add an image overlay with corner coordinates\n# Coordinates are: top-left, top-right, bottom-right, bottom-left\nm.add_image_layer(\n    url=\"https://docs.mapbox.com/mapbox-gl-js/assets/radar.gif\",\n    coordinates=[\n        [-80.425, 46.437],  # top-left\n        [-71.516, 46.437],  # top-right\n        [-71.516, 37.936],  # bottom-right\n        [-80.425, 37.936],  # bottom-left\n    ],\n    opacity=0.8,\n)\nm\n</pre> from anymap_ts import Map  m = Map(center=[-75.0, 42.0], zoom=5)  # Add an image overlay with corner coordinates # Coordinates are: top-left, top-right, bottom-right, bottom-left m.add_image_layer(     url=\"https://docs.mapbox.com/mapbox-gl-js/assets/radar.gif\",     coordinates=[         [-80.425, 46.437],  # top-left         [-71.516, 46.437],  # top-right         [-71.516, 37.936],  # bottom-right         [-80.425, 37.936],  # bottom-left     ],     opacity=0.8, ) m In\u00a0[\u00a0]: Copied! <pre>m.to_html(\"image_overlay_example.html\")\n</pre> m.to_html(\"image_overlay_example.html\")"},{"location":"maplibre/image_overlay/#image-overlay-example","title":"Image Overlay Example\u00b6","text":"<p>This notebook demonstrates how to add georeferenced image overlays to a map using the <code>add_image_layer</code> method.</p>"},{"location":"maplibre/image_overlay/#basic-image-overlay","title":"Basic Image Overlay\u00b6","text":""},{"location":"maplibre/image_overlay/#export-to-html","title":"Export to HTML\u00b6","text":""},{"location":"maplibre/layer_management/","title":"Layer management","text":"In\u00a0[\u00a0]: Copied! <pre># %pip install -U anymap-ts\n</pre> # %pip install -U anymap-ts In\u00a0[\u00a0]: Copied! <pre>from anymap_ts import Map\n\n# Create sample data\npoints = {\n    \"type\": \"FeatureCollection\",\n    \"features\": [\n        {\n            \"type\": \"Feature\",\n            \"geometry\": {\"type\": \"Point\", \"coordinates\": [-122.4, 37.8]},\n            \"properties\": {\"name\": \"A\"},\n        },\n        {\n            \"type\": \"Feature\",\n            \"geometry\": {\"type\": \"Point\", \"coordinates\": [-122.3, 37.7]},\n            \"properties\": {\"name\": \"B\"},\n        },\n        {\n            \"type\": \"Feature\",\n            \"geometry\": {\"type\": \"Point\", \"coordinates\": [-122.5, 37.9]},\n            \"properties\": {\"name\": \"C\"},\n        },\n    ],\n}\n\npolygons = {\n    \"type\": \"FeatureCollection\",\n    \"features\": [\n        {\n            \"type\": \"Feature\",\n            \"geometry\": {\n                \"type\": \"Polygon\",\n                \"coordinates\": [\n                    [\n                        [-122.5, 37.7],\n                        [-122.3, 37.7],\n                        [-122.3, 37.9],\n                        [-122.5, 37.9],\n                        [-122.5, 37.7],\n                    ]\n                ],\n            },\n            \"properties\": {\"name\": \"Zone 1\"},\n        }\n    ],\n}\n\nm = Map(center=[-122.4, 37.8], zoom=11)\nm.add_vector(\n    polygons, name=\"zones\", paint={\"fill-color\": \"#3388ff\", \"fill-opacity\": 0.3}\n)\nm.add_vector(\n    points, name=\"points\", paint={\"circle-color\": \"#ff0000\", \"circle-radius\": 8}\n)\nm\n</pre> from anymap_ts import Map  # Create sample data points = {     \"type\": \"FeatureCollection\",     \"features\": [         {             \"type\": \"Feature\",             \"geometry\": {\"type\": \"Point\", \"coordinates\": [-122.4, 37.8]},             \"properties\": {\"name\": \"A\"},         },         {             \"type\": \"Feature\",             \"geometry\": {\"type\": \"Point\", \"coordinates\": [-122.3, 37.7]},             \"properties\": {\"name\": \"B\"},         },         {             \"type\": \"Feature\",             \"geometry\": {\"type\": \"Point\", \"coordinates\": [-122.5, 37.9]},             \"properties\": {\"name\": \"C\"},         },     ], }  polygons = {     \"type\": \"FeatureCollection\",     \"features\": [         {             \"type\": \"Feature\",             \"geometry\": {                 \"type\": \"Polygon\",                 \"coordinates\": [                     [                         [-122.5, 37.7],                         [-122.3, 37.7],                         [-122.3, 37.9],                         [-122.5, 37.9],                         [-122.5, 37.7],                     ]                 ],             },             \"properties\": {\"name\": \"Zone 1\"},         }     ], }  m = Map(center=[-122.4, 37.8], zoom=11) m.add_vector(     polygons, name=\"zones\", paint={\"fill-color\": \"#3388ff\", \"fill-opacity\": 0.3} ) m.add_vector(     points, name=\"points\", paint={\"circle-color\": \"#ff0000\", \"circle-radius\": 8} ) m In\u00a0[\u00a0]: Copied! <pre># List all layer IDs\nlayer_ids = m.get_layer_ids()\nprint(\"Layer IDs:\", layer_ids)\n</pre> # List all layer IDs layer_ids = m.get_layer_ids() print(\"Layer IDs:\", layer_ids) In\u00a0[\u00a0]: Copied! <pre># Get configuration for a specific layer\nlayer_config = m.get_layer(\"points\")\nprint(\"Points layer config:\", layer_config)\n</pre> # Get configuration for a specific layer layer_config = m.get_layer(\"points\") print(\"Points layer config:\", layer_config) In\u00a0[\u00a0]: Copied! <pre># Change the circle color dynamically\nm.set_paint_property(\"points\", \"circle-color\", \"#00ff00\")\nm.set_paint_property(\"points\", \"circle-radius\", 12)\n</pre> # Change the circle color dynamically m.set_paint_property(\"points\", \"circle-color\", \"#00ff00\") m.set_paint_property(\"points\", \"circle-radius\", 12) In\u00a0[\u00a0]: Copied! <pre># Toggle layer visibility\nm.set_layout_property(\"zones\", \"visibility\", \"none\")\n</pre> # Toggle layer visibility m.set_layout_property(\"zones\", \"visibility\", \"none\") In\u00a0[\u00a0]: Copied! <pre># Show the layer again\nm.set_layout_property(\"zones\", \"visibility\", \"visible\")\n</pre> # Show the layer again m.set_layout_property(\"zones\", \"visibility\", \"visible\") In\u00a0[\u00a0]: Copied! <pre># Move points layer below zones layer\nm.move_layer(\"points\", \"zones\")\n</pre> # Move points layer below zones layer m.move_layer(\"points\", \"zones\") In\u00a0[\u00a0]: Copied! <pre># Move points back to top\nm.move_layer(\"points\")\n</pre> # Move points back to top m.move_layer(\"points\") In\u00a0[\u00a0]: Copied! <pre># Set layer opacity\nm.set_opacity(\"zones\", 0.7)\n</pre> # Set layer opacity m.set_opacity(\"zones\", 0.7) In\u00a0[\u00a0]: Copied! <pre># Toggle visibility\nm.set_visibility(\"points\", False)\n</pre> # Toggle visibility m.set_visibility(\"points\", False) In\u00a0[\u00a0]: Copied! <pre># Show again\nm.set_visibility(\"points\", True)\n</pre> # Show again m.set_visibility(\"points\", True) In\u00a0[\u00a0]: Copied! <pre>m.to_html(\"layer_management_example.html\")\n</pre> m.to_html(\"layer_management_example.html\")"},{"location":"maplibre/layer_management/#layer-management-example","title":"Layer Management Example\u00b6","text":"<p>This notebook demonstrates the layer management utilities including setting paint/layout properties, moving layers, and getting layer information.</p>"},{"location":"maplibre/layer_management/#setup-create-layers","title":"Setup: Create Layers\u00b6","text":""},{"location":"maplibre/layer_management/#get-layer-ids","title":"Get Layer IDs\u00b6","text":""},{"location":"maplibre/layer_management/#get-layer-configuration","title":"Get Layer Configuration\u00b6","text":""},{"location":"maplibre/layer_management/#set-paint-properties","title":"Set Paint Properties\u00b6","text":""},{"location":"maplibre/layer_management/#set-layout-properties","title":"Set Layout Properties\u00b6","text":""},{"location":"maplibre/layer_management/#move-layer-order","title":"Move Layer Order\u00b6","text":""},{"location":"maplibre/layer_management/#set-visibility-and-opacity","title":"Set Visibility and Opacity\u00b6","text":""},{"location":"maplibre/layer_management/#export-to-html","title":"Export to HTML\u00b6","text":""},{"location":"maplibre/lidar_layer/","title":"Lidar layer","text":"In\u00a0[\u00a0]: Copied! <pre># %pip install -U anymap-ts\n</pre> # %pip install -U anymap-ts In\u00a0[\u00a0]: Copied! <pre>from anymap_ts import MapLibreMap\n\n# Create map centered on Autzen Stadium, Eugene, Oregon\nm = MapLibreMap(center=[-123.07, 44.05], zoom=15, pitch=60, bearing=-20, height=\"800px\")\nm.add_basemap(\"CartoDB.DarkMatter\")\n\n# Add the LiDAR control panel\n# Users can load files via the UI, change color schemes, filter classifications, etc.\nm.add_lidar_control(\n    position=\"top-left\",\n    collapsed=False,\n    color_scheme=\"classification\",\n    pickable=True,\n    point_size=2,\n    panel_max_height=600,\n)\nm\n</pre> from anymap_ts import MapLibreMap  # Create map centered on Autzen Stadium, Eugene, Oregon m = MapLibreMap(center=[-123.07, 44.05], zoom=15, pitch=60, bearing=-20, height=\"800px\") m.add_basemap(\"CartoDB.DarkMatter\")  # Add the LiDAR control panel # Users can load files via the UI, change color schemes, filter classifications, etc. m.add_lidar_control(     position=\"top-left\",     collapsed=False,     color_scheme=\"classification\",     pickable=True,     point_size=2,     panel_max_height=600, ) m In\u00a0[\u00a0]: Copied! <pre>from anymap_ts import MapLibreMap\n\n# Autzen Stadium COPC dataset\nAUTZEN_URL = \"https://s3.amazonaws.com/hobu-lidar/autzen-classified.copc.laz\"\n\nm2 = MapLibreMap(\n    center=[-123.07, 44.05],\n    zoom=15,\n    pitch=60,\n)\nm2.add_basemap(\"CartoDB.DarkMatter\")\n\n# Load LiDAR from URL\nm2.add_lidar_layer(\n    source=AUTZEN_URL,\n    name=\"autzen\",\n    color_scheme=\"elevation\",\n    point_size=2,\n    opacity=1.0,\n    pickable=True,\n    auto_zoom=True,\n    streaming_mode=True,\n)\nm2\n</pre> from anymap_ts import MapLibreMap  # Autzen Stadium COPC dataset AUTZEN_URL = \"https://s3.amazonaws.com/hobu-lidar/autzen-classified.copc.laz\"  m2 = MapLibreMap(     center=[-123.07, 44.05],     zoom=15,     pitch=60, ) m2.add_basemap(\"CartoDB.DarkMatter\")  # Load LiDAR from URL m2.add_lidar_layer(     source=AUTZEN_URL,     name=\"autzen\",     color_scheme=\"elevation\",     point_size=2,     opacity=1.0,     pickable=True,     auto_zoom=True,     streaming_mode=True, ) m2 In\u00a0[\u00a0]: Copied! <pre>from anymap_ts import MapLibreMap\n\nm3 = MapLibreMap(\n    center=[-123.07, 44.05],\n    zoom=15,\n    pitch=60,\n)\nm3.add_basemap(\"CartoDB.DarkMatter\")\n\n# Classification color scheme shows different land cover types\nm3.add_lidar_layer(\n    source=\"https://s3.amazonaws.com/hobu-lidar/autzen-classified.copc.laz\",\n    name=\"autzen-classification\",\n    color_scheme=\"classification\",  # Ground, vegetation, buildings, etc.\n    point_size=2,\n    pickable=True,\n)\n\n# Add layer control to manage LiDAR visibility\n# Note: add_layer_control should be called AFTER add_lidar_layer\nm3.add_layer_control(position=\"top-right\", collapsed=False)\nm3\n</pre> from anymap_ts import MapLibreMap  m3 = MapLibreMap(     center=[-123.07, 44.05],     zoom=15,     pitch=60, ) m3.add_basemap(\"CartoDB.DarkMatter\")  # Classification color scheme shows different land cover types m3.add_lidar_layer(     source=\"https://s3.amazonaws.com/hobu-lidar/autzen-classified.copc.laz\",     name=\"autzen-classification\",     color_scheme=\"classification\",  # Ground, vegetation, buildings, etc.     point_size=2,     pickable=True, )  # Add layer control to manage LiDAR visibility # Note: add_layer_control should be called AFTER add_lidar_layer m3.add_layer_control(position=\"top-right\", collapsed=False) m3 In\u00a0[\u00a0]: Copied! <pre>from anymap_ts import MapLibreMap\n\nm4 = MapLibreMap(\n    center=[-123.07, 44.05],\n    zoom=15,\n    pitch=60,\n)\nm4.add_basemap(\"CartoDB.DarkMatter\")\n\n# Intensity color scheme highlights reflectivity\nm4.add_lidar_layer(\n    source=\"https://s3.amazonaws.com/hobu-lidar/autzen-classified.copc.laz\",\n    name=\"autzen-intensity\",\n    color_scheme=\"intensity\",\n    point_size=2,\n    pickable=True,\n)\nm4\n</pre> from anymap_ts import MapLibreMap  m4 = MapLibreMap(     center=[-123.07, 44.05],     zoom=15,     pitch=60, ) m4.add_basemap(\"CartoDB.DarkMatter\")  # Intensity color scheme highlights reflectivity m4.add_lidar_layer(     source=\"https://s3.amazonaws.com/hobu-lidar/autzen-classified.copc.laz\",     name=\"autzen-intensity\",     color_scheme=\"intensity\",     point_size=2,     pickable=True, ) m4 In\u00a0[\u00a0]: Copied! <pre># Change the color scheme of an existing LiDAR layer\nm2.set_lidar_color_scheme(\"classification\")\n</pre> # Change the color scheme of an existing LiDAR layer m2.set_lidar_color_scheme(\"classification\") In\u00a0[\u00a0]: Copied! <pre># Change to intensity\nm2.set_lidar_color_scheme(\"intensity\")\n</pre> # Change to intensity m2.set_lidar_color_scheme(\"intensity\") In\u00a0[\u00a0]: Copied! <pre># Change back to elevation\nm2.set_lidar_color_scheme(\"elevation\")\n</pre> # Change back to elevation m2.set_lidar_color_scheme(\"elevation\") In\u00a0[\u00a0]: Copied! <pre># Increase point size\nm2.set_lidar_point_size(4)\n</pre> # Increase point size m2.set_lidar_point_size(4) In\u00a0[\u00a0]: Copied! <pre># Decrease opacity\nm2.set_lidar_opacity(0.7)\n</pre> # Decrease opacity m2.set_lidar_opacity(0.7) In\u00a0[\u00a0]: Copied! <pre># Reset to defaults\nm2.set_lidar_point_size(2)\nm2.set_lidar_opacity(1.0)\n</pre> # Reset to defaults m2.set_lidar_point_size(2) m2.set_lidar_opacity(1.0) In\u00a0[\u00a0]: Copied! <pre># Remove a specific LiDAR layer\nm2.remove_lidar_layer(\"autzen\")\n</pre> # Remove a specific LiDAR layer m2.remove_lidar_layer(\"autzen\") In\u00a0[\u00a0]: Copied! <pre>m3.to_html(\"lidar_layer_example.html\")\n</pre> m3.to_html(\"lidar_layer_example.html\")"},{"location":"maplibre/lidar_layer/#lidar-layer-example","title":"LiDAR Layer Example\u00b6","text":"<p>This notebook demonstrates LiDAR point cloud visualization using the <code>maplibre-gl-lidar</code> package.</p> <p>Key features:</p> <ul> <li>Load LAS, LAZ, and COPC (Cloud-Optimized Point Cloud) files</li> <li>Color schemes: elevation, intensity, classification, RGB</li> <li>Interactive control panel with classification filtering</li> <li>Streaming support for large COPC files</li> <li>Point picking with attribute tooltips</li> </ul>"},{"location":"maplibre/lidar_layer/#basic-lidar-with-maplibre-interactive-control-panel","title":"Basic LiDAR with MapLibre (Interactive Control Panel)\u00b6","text":""},{"location":"maplibre/lidar_layer/#programmatic-lidar-loading-from-url","title":"Programmatic LiDAR Loading from URL\u00b6","text":"<p>Load LiDAR data directly from a URL without the control panel UI.</p>"},{"location":"maplibre/lidar_layer/#color-scheme-classification-with-layer-control","title":"Color Scheme: Classification with Layer Control\u00b6","text":"<p>Visualize LiDAR data colored by classification codes (ground, vegetation, buildings, etc.). The layer control allows toggling visibility and adjusting opacity of the LiDAR layer.</p>"},{"location":"maplibre/lidar_layer/#color-scheme-intensity","title":"Color Scheme: Intensity\u00b6","text":"<p>Visualize LiDAR data colored by return intensity values.</p>"},{"location":"maplibre/lidar_layer/#change-color-scheme-dynamically","title":"Change Color Scheme Dynamically\u00b6","text":""},{"location":"maplibre/lidar_layer/#adjust-point-size-and-opacity","title":"Adjust Point Size and Opacity\u00b6","text":""},{"location":"maplibre/lidar_layer/#remove-lidar-layer","title":"Remove LiDAR Layer\u00b6","text":""},{"location":"maplibre/lidar_layer/#export-to-html","title":"Export to HTML\u00b6","text":""},{"location":"maplibre/maplibre/","title":"Maplibre","text":"In\u00a0[\u00a0]: Copied! <pre># %pip install -U anymap-ts\n</pre> # %pip install -U anymap-ts In\u00a0[\u00a0]: Copied! <pre>from anymap_ts import Map\n\nm = Map(center=[-122.4, 37.8], zoom=10)\nm.add_basemap(\"OpenStreetMap\")\nm.add_draw_control(position=\"top-left\")\nm.add_layer_control()\nm\n</pre> from anymap_ts import Map  m = Map(center=[-122.4, 37.8], zoom=10) m.add_basemap(\"OpenStreetMap\") m.add_draw_control(position=\"top-left\") m.add_layer_control() m In\u00a0[\u00a0]: Copied! <pre>m.get_draw_data()\n</pre> m.get_draw_data() In\u00a0[\u00a0]: Copied! <pre>m.to_html(\"map.html\")\n</pre> m.to_html(\"map.html\")"},{"location":"maplibre/maplibre_heatmap/","title":"Maplibre heatmap","text":"In\u00a0[\u00a0]: Copied! <pre># %pip install -U anymap-ts\n</pre> # %pip install -U anymap-ts In\u00a0[\u00a0]: Copied! <pre>import random\nfrom anymap_ts import Map\n\n# Generate random earthquake-like data\nfeatures = []\nfor _ in range(500):\n    features.append(\n        {\n            \"type\": \"Feature\",\n            \"geometry\": {\n                \"type\": \"Point\",\n                \"coordinates\": [\n                    -122.4 + random.uniform(-1, 1),\n                    37.8 + random.uniform(-1, 1),\n                ],\n            },\n            \"properties\": {\"magnitude\": random.uniform(1, 6)},\n        }\n    )\n\ngeojson = {\"type\": \"FeatureCollection\", \"features\": features}\n\nm = Map(center=[-122.4, 37.8], zoom=9)\nm.add_basemap(\"CartoDB.DarkMatter\")\nm.add_heatmap(geojson, radius=25)\nm\n</pre> import random from anymap_ts import Map  # Generate random earthquake-like data features = [] for _ in range(500):     features.append(         {             \"type\": \"Feature\",             \"geometry\": {                 \"type\": \"Point\",                 \"coordinates\": [                     -122.4 + random.uniform(-1, 1),                     37.8 + random.uniform(-1, 1),                 ],             },             \"properties\": {\"magnitude\": random.uniform(1, 6)},         }     )  geojson = {\"type\": \"FeatureCollection\", \"features\": features}  m = Map(center=[-122.4, 37.8], zoom=9) m.add_basemap(\"CartoDB.DarkMatter\") m.add_heatmap(geojson, radius=25) m In\u00a0[\u00a0]: Copied! <pre>m2 = Map(center=[-122.4, 37.8], zoom=9)\nm2.add_basemap(\"CartoDB.DarkMatter\")\nm2.add_heatmap(geojson, weight_property=\"magnitude\", radius=30, intensity=0.8)\nm2\n</pre> m2 = Map(center=[-122.4, 37.8], zoom=9) m2.add_basemap(\"CartoDB.DarkMatter\") m2.add_heatmap(geojson, weight_property=\"magnitude\", radius=30, intensity=0.8) m2 In\u00a0[\u00a0]: Copied! <pre>m3 = Map(center=[-122.4, 37.8], zoom=9)\nm3.add_basemap(\"CartoDB.DarkMatter\")\n\n# Custom colormap from blue to red\ncustom_colormap = [\n    [0, \"rgba(0,0,255,0)\"],\n    [0.2, \"blue\"],\n    [0.4, \"cyan\"],\n    [0.6, \"lime\"],\n    [0.8, \"yellow\"],\n    [1, \"red\"],\n]\n\nm3.add_heatmap(\n    geojson, weight_property=\"magnitude\", radius=35, colormap=custom_colormap\n)\nm3\n</pre> m3 = Map(center=[-122.4, 37.8], zoom=9) m3.add_basemap(\"CartoDB.DarkMatter\")  # Custom colormap from blue to red custom_colormap = [     [0, \"rgba(0,0,255,0)\"],     [0.2, \"blue\"],     [0.4, \"cyan\"],     [0.6, \"lime\"],     [0.8, \"yellow\"],     [1, \"red\"], ]  m3.add_heatmap(     geojson, weight_property=\"magnitude\", radius=35, colormap=custom_colormap ) m3 In\u00a0[\u00a0]: Copied! <pre>m4 = Map(center=[-120, 37], zoom=5)\nm4.add_basemap(\"CartoDB.DarkMatter\")\n\n# Load earthquake data from USGS\nearthquake_url = (\n    \"https://earthquake.usgs.gov/earthquakes/feed/v1.0/summary/all_week.geojson\"\n)\nm4.add_heatmap(earthquake_url, weight_property=\"mag\", radius=20, intensity=0.5)\nm4\n</pre> m4 = Map(center=[-120, 37], zoom=5) m4.add_basemap(\"CartoDB.DarkMatter\")  # Load earthquake data from USGS earthquake_url = (     \"https://earthquake.usgs.gov/earthquakes/feed/v1.0/summary/all_week.geojson\" ) m4.add_heatmap(earthquake_url, weight_property=\"mag\", radius=20, intensity=0.5) m4 In\u00a0[\u00a0]: Copied! <pre>m4.to_html(\"maplibre_heatmap_example.html\")\n</pre> m4.to_html(\"maplibre_heatmap_example.html\")"},{"location":"maplibre/maplibre_heatmap/#maplibre-heatmap-example","title":"MapLibre Heatmap Example\u00b6","text":"<p>This notebook demonstrates how to create heatmap visualizations using MapLibre's native heatmap layer.</p>"},{"location":"maplibre/maplibre_heatmap/#basic-heatmap","title":"Basic Heatmap\u00b6","text":""},{"location":"maplibre/maplibre_heatmap/#weighted-heatmap","title":"Weighted Heatmap\u00b6","text":""},{"location":"maplibre/maplibre_heatmap/#custom-colormap","title":"Custom Colormap\u00b6","text":""},{"location":"maplibre/maplibre_heatmap/#heatmap-from-url","title":"Heatmap from URL\u00b6","text":""},{"location":"maplibre/maplibre_heatmap/#export-to-html","title":"Export to HTML\u00b6","text":""},{"location":"maplibre/markers/","title":"Markers","text":"In\u00a0[\u00a0]: Copied! <pre># %pip install -U anymap-ts\n</pre> # %pip install -U anymap-ts In\u00a0[\u00a0]: Copied! <pre>from anymap_ts import Map\n\nm = Map(center=[-122.4, 37.8], zoom=10)\nm.add_marker(\n    -122.4,\n    37.8,\n    popup=\"&lt;b&gt;San Francisco&lt;/b&gt;&lt;br&gt;Click to see this popup!\",\n    tooltip=\"Hover over me!\",\n)\nm\n</pre> from anymap_ts import Map  m = Map(center=[-122.4, 37.8], zoom=10) m.add_marker(     -122.4,     37.8,     popup=\"San FranciscoClick to see this popup!\",     tooltip=\"Hover over me!\", ) m In\u00a0[\u00a0]: Copied! <pre>m2 = Map(center=[-100, 40], zoom=4)\n\ncities = [\n    {\n        \"name\": \"San Francisco\",\n        \"info\": \"Population: 884,363\",\n        \"lng\": -122.4,\n        \"lat\": 37.8,\n    },\n    {\"name\": \"New York\", \"info\": \"Population: 8,336,817\", \"lng\": -74.0, \"lat\": 40.7},\n    {\"name\": \"Chicago\", \"info\": \"Population: 2,693,976\", \"lng\": -87.6, \"lat\": 41.9},\n    {\n        \"name\": \"Los Angeles\",\n        \"info\": \"Population: 3,979,576\",\n        \"lng\": -118.2,\n        \"lat\": 34.1,\n    },\n    {\"name\": \"Seattle\", \"info\": \"Population: 737,015\", \"lng\": -122.3, \"lat\": 47.6},\n]\n\n# Use popup_column for click content and tooltip_column for hover content\nm2.add_markers(cities, popup_column=\"name\", tooltip_column=\"info\", color=\"#ff6600\")\nm2\n</pre> m2 = Map(center=[-100, 40], zoom=4)  cities = [     {         \"name\": \"San Francisco\",         \"info\": \"Population: 884,363\",         \"lng\": -122.4,         \"lat\": 37.8,     },     {\"name\": \"New York\", \"info\": \"Population: 8,336,817\", \"lng\": -74.0, \"lat\": 40.7},     {\"name\": \"Chicago\", \"info\": \"Population: 2,693,976\", \"lng\": -87.6, \"lat\": 41.9},     {         \"name\": \"Los Angeles\",         \"info\": \"Population: 3,979,576\",         \"lng\": -118.2,         \"lat\": 34.1,     },     {\"name\": \"Seattle\", \"info\": \"Population: 737,015\", \"lng\": -122.3, \"lat\": 47.6}, ]  # Use popup_column for click content and tooltip_column for hover content m2.add_markers(cities, popup_column=\"name\", tooltip_column=\"info\", color=\"#ff6600\") m2 In\u00a0[\u00a0]: Copied! <pre>geojson_data = {\n    \"type\": \"FeatureCollection\",\n    \"features\": [\n        {\n            \"type\": \"Feature\",\n            \"geometry\": {\"type\": \"Point\", \"coordinates\": [-122.4, 37.8]},\n            \"properties\": {\"city\": \"San Francisco\", \"population\": 884363},\n        },\n        {\n            \"type\": \"Feature\",\n            \"geometry\": {\"type\": \"Point\", \"coordinates\": [-74.0, 40.7]},\n            \"properties\": {\"city\": \"New York\", \"population\": 8336817},\n        },\n        {\n            \"type\": \"Feature\",\n            \"geometry\": {\"type\": \"Point\", \"coordinates\": [-87.6, 41.9]},\n            \"properties\": {\"city\": \"Chicago\", \"population\": 2693976},\n        },\n    ],\n}\n\nm3 = Map(center=[-100, 40], zoom=4)\nm3.add_markers(geojson_data, popup_column=\"city\", color=\"#3388ff\")\nm3\n</pre> geojson_data = {     \"type\": \"FeatureCollection\",     \"features\": [         {             \"type\": \"Feature\",             \"geometry\": {\"type\": \"Point\", \"coordinates\": [-122.4, 37.8]},             \"properties\": {\"city\": \"San Francisco\", \"population\": 884363},         },         {             \"type\": \"Feature\",             \"geometry\": {\"type\": \"Point\", \"coordinates\": [-74.0, 40.7]},             \"properties\": {\"city\": \"New York\", \"population\": 8336817},         },         {             \"type\": \"Feature\",             \"geometry\": {\"type\": \"Point\", \"coordinates\": [-87.6, 41.9]},             \"properties\": {\"city\": \"Chicago\", \"population\": 2693976},         },     ], }  m3 = Map(center=[-100, 40], zoom=4) m3.add_markers(geojson_data, popup_column=\"city\", color=\"#3388ff\") m3 In\u00a0[\u00a0]: Copied! <pre>m_scale = Map(center=[-122.4, 37.8], zoom=12)\n\n# Small marker (scale 0.5)\nm_scale.add_marker(\n    -122.45,\n    37.78,\n    popup=\"Small marker\",\n    tooltip=\"Scale: 0.5\",\n    scale=0.5,\n    color=\"#ff0000\",\n)\n\n# Default marker (scale 1.0)\nm_scale.add_marker(\n    -122.40,\n    37.80,\n    popup=\"Default marker\",\n    tooltip=\"Scale: 1.0\",\n    scale=1.0,\n    color=\"#00ff00\",\n)\n\n# Large marker (scale 1.5)\nm_scale.add_marker(\n    -122.35,\n    37.82,\n    popup=\"Large marker\",\n    tooltip=\"Scale: 1.5\",\n    scale=1.5,\n    color=\"#0000ff\",\n)\n\n# Extra large marker (scale 2.0)\nm_scale.add_marker(\n    -122.38,\n    37.76,\n    popup=\"Extra large marker\",\n    tooltip=\"Scale: 2.0\",\n    scale=2.0,\n    color=\"#ff00ff\",\n)\n\nm_scale\n</pre> m_scale = Map(center=[-122.4, 37.8], zoom=12)  # Small marker (scale 0.5) m_scale.add_marker(     -122.45,     37.78,     popup=\"Small marker\",     tooltip=\"Scale: 0.5\",     scale=0.5,     color=\"#ff0000\", )  # Default marker (scale 1.0) m_scale.add_marker(     -122.40,     37.80,     popup=\"Default marker\",     tooltip=\"Scale: 1.0\",     scale=1.0,     color=\"#00ff00\", )  # Large marker (scale 1.5) m_scale.add_marker(     -122.35,     37.82,     popup=\"Large marker\",     tooltip=\"Scale: 1.5\",     scale=1.5,     color=\"#0000ff\", )  # Extra large marker (scale 2.0) m_scale.add_marker(     -122.38,     37.76,     popup=\"Extra large marker\",     tooltip=\"Scale: 2.0\",     scale=2.0,     color=\"#ff00ff\", )  m_scale In\u00a0[\u00a0]: Copied! <pre>m_width = Map(center=[-122.4, 37.8], zoom=11)\n\n# Marker with wide popup (400px) containing longer content\nlong_content = \"\"\"\n&lt;h3&gt;San Francisco&lt;/h3&gt;\n&lt;p&gt;San Francisco is a city in California known for the Golden Gate Bridge, \ncable cars, and Victorian architecture. It's a major tech hub and cultural center.&lt;/p&gt;\n\"\"\"\n\nm_width.add_marker(\n    -122.42,\n    37.78,\n    popup=long_content,\n    tooltip=\"Wide popup (400px)\",\n    popup_max_width=\"400px\",\n    tooltip_max_width=\"150px\",\n    color=\"#9c27b0\",\n)\n\n# Marker with narrow popup (150px)\nm_width.add_marker(\n    -122.38,\n    37.80,\n    popup=\"&lt;b&gt;Narrow popup&lt;/b&gt;&lt;br&gt;Max width: 150px\",\n    tooltip=\"Narrow popup example\",\n    popup_max_width=\"150px\",\n    color=\"#ff9800\",\n)\n\nm_width\n</pre> m_width = Map(center=[-122.4, 37.8], zoom=11)  # Marker with wide popup (400px) containing longer content long_content = \"\"\" San Francisco <p>San Francisco is a city in California known for the Golden Gate Bridge,  cable cars, and Victorian architecture. It's a major tech hub and cultural center.</p> \"\"\"  m_width.add_marker(     -122.42,     37.78,     popup=long_content,     tooltip=\"Wide popup (400px)\",     popup_max_width=\"400px\",     tooltip_max_width=\"150px\",     color=\"#9c27b0\", )  # Marker with narrow popup (150px) m_width.add_marker(     -122.38,     37.80,     popup=\"Narrow popupMax width: 150px\",     tooltip=\"Narrow popup example\",     popup_max_width=\"150px\",     color=\"#ff9800\", )  m_width In\u00a0[\u00a0]: Copied! <pre>m4 = Map(center=[-122.4, 37.8], zoom=11)\n\n# Add markers with different colors and tooltips\nm4.add_marker(-122.42, 37.78, popup=\"Red marker\", tooltip=\"I'm red!\", color=\"#ff0000\")\nm4.add_marker(\n    -122.40, 37.80, popup=\"Green marker\", tooltip=\"I'm green!\", color=\"#00ff00\"\n)\nm4.add_marker(-122.38, 37.82, popup=\"Blue marker\", tooltip=\"I'm blue!\", color=\"#0000ff\")\nm4\n</pre> m4 = Map(center=[-122.4, 37.8], zoom=11)  # Add markers with different colors and tooltips m4.add_marker(-122.42, 37.78, popup=\"Red marker\", tooltip=\"I'm red!\", color=\"#ff0000\") m4.add_marker(     -122.40, 37.80, popup=\"Green marker\", tooltip=\"I'm green!\", color=\"#00ff00\" ) m4.add_marker(-122.38, 37.82, popup=\"Blue marker\", tooltip=\"I'm blue!\", color=\"#0000ff\") m4 In\u00a0[\u00a0]: Copied! <pre>m5 = Map(center=[-100, 40], zoom=4)\n\nlandmarks = [\n    {\n        \"name\": \"Golden Gate Bridge\",\n        \"desc\": \"Famous suspension bridge\",\n        \"lng\": -122.4783,\n        \"lat\": 37.8199,\n    },\n    {\n        \"name\": \"Statue of Liberty\",\n        \"desc\": \"Iconic NYC landmark\",\n        \"lng\": -74.0445,\n        \"lat\": 40.6892,\n    },\n    {\n        \"name\": \"Space Needle\",\n        \"desc\": \"Seattle observation tower\",\n        \"lng\": -122.3493,\n        \"lat\": 47.6205,\n    },\n    {\n        \"name\": \"Willis Tower\",\n        \"desc\": \"Chicago skyscraper\",\n        \"lng\": -87.6359,\n        \"lat\": 41.8789,\n    },\n]\n\n# All markers scaled to 1.5x with tooltips\nm5.add_markers(\n    landmarks,\n    popup_column=\"name\",\n    tooltip_column=\"desc\",\n    color=\"#e91e63\",\n    scale=1.5,\n    popup_max_width=\"300px\",\n)\nm5\n</pre> m5 = Map(center=[-100, 40], zoom=4)  landmarks = [     {         \"name\": \"Golden Gate Bridge\",         \"desc\": \"Famous suspension bridge\",         \"lng\": -122.4783,         \"lat\": 37.8199,     },     {         \"name\": \"Statue of Liberty\",         \"desc\": \"Iconic NYC landmark\",         \"lng\": -74.0445,         \"lat\": 40.6892,     },     {         \"name\": \"Space Needle\",         \"desc\": \"Seattle observation tower\",         \"lng\": -122.3493,         \"lat\": 47.6205,     },     {         \"name\": \"Willis Tower\",         \"desc\": \"Chicago skyscraper\",         \"lng\": -87.6359,         \"lat\": 41.8789,     }, ]  # All markers scaled to 1.5x with tooltips m5.add_markers(     landmarks,     popup_column=\"name\",     tooltip_column=\"desc\",     color=\"#e91e63\",     scale=1.5,     popup_max_width=\"300px\", ) m5 In\u00a0[\u00a0]: Copied! <pre>m4.to_html(\"markers_example.html\")\n</pre> m4.to_html(\"markers_example.html\")"},{"location":"maplibre/markers/#markers-example","title":"Markers Example\u00b6","text":"<p>This notebook demonstrates how to add markers to a MapLibre map using the <code>add_marker</code> and <code>add_markers</code> methods.</p>"},{"location":"maplibre/markers/#features","title":"Features\u00b6","text":"<ul> <li>popup: HTML content shown when clicking the marker</li> <li>tooltip: HTML content shown when hovering over the marker</li> <li>scale: Marker size multiplier (default 1.0, range 0.1-3.0)</li> <li>popup_max_width: Maximum width of popup (CSS value, default \"240px\")</li> <li>tooltip_max_width: Maximum width of tooltip (CSS value, default \"240px\")</li> <li>draggable: Whether the marker can be dragged</li> </ul>"},{"location":"maplibre/markers/#add-a-single-marker-with-popup-and-tooltip","title":"Add a Single Marker with Popup and Tooltip\u00b6","text":""},{"location":"maplibre/markers/#add-multiple-markers-with-tooltips","title":"Add Multiple Markers with Tooltips\u00b6","text":""},{"location":"maplibre/markers/#add-markers-from-geojson","title":"Add Markers from GeoJSON\u00b6","text":""},{"location":"maplibre/markers/#marker-scale","title":"Marker Scale\u00b6","text":"<p>Adjust marker sizes using the <code>scale</code> parameter (default 1.0, range 0.1-3.0).</p>"},{"location":"maplibre/markers/#popup-and-tooltip-max-width","title":"Popup and Tooltip Max Width\u00b6","text":"<p>Control the maximum width of popups and tooltips using CSS values.</p>"},{"location":"maplibre/markers/#custom-marker-colors","title":"Custom Marker Colors\u00b6","text":""},{"location":"maplibre/markers/#multiple-markers-with-scale","title":"Multiple Markers with Scale\u00b6","text":"<p>Apply scale to all markers in <code>add_markers</code>.</p>"},{"location":"maplibre/markers/#export-to-html","title":"Export to HTML\u00b6","text":""},{"location":"maplibre/measure/","title":"Measure","text":"In\u00a0[\u00a0]: Copied! <pre># %pip install -U anymap-ts\n</pre> # %pip install -U anymap-ts In\u00a0[\u00a0]: Copied! <pre>from anymap_ts import Map\n\nm = Map(center=[-122.4, 37.8], zoom=10)\nm.add_measure_control(\n    position=\"top-right\",\n    default_mode=\"distance\",\n    distance_unit=\"kilometers\",\n)\nm\n</pre> from anymap_ts import Map  m = Map(center=[-122.4, 37.8], zoom=10) m.add_measure_control(     position=\"top-right\",     default_mode=\"distance\",     distance_unit=\"kilometers\", ) m In\u00a0[\u00a0]: Copied! <pre>m2 = Map(center=[-100, 40], zoom=4)\nm2.add_measure_control(\n    position=\"top-right\",\n    default_mode=\"area\",\n    area_unit=\"square-miles\",\n    line_color=\"#e74c3c\",\n    fill_color=\"rgba(231, 76, 60, 0.2)\",\n)\nm2\n</pre> m2 = Map(center=[-100, 40], zoom=4) m2.add_measure_control(     position=\"top-right\",     default_mode=\"area\",     area_unit=\"square-miles\",     line_color=\"#e74c3c\",     fill_color=\"rgba(231, 76, 60, 0.2)\", ) m2 In\u00a0[\u00a0]: Copied! <pre>m.remove_measure_control()\n</pre> m.remove_measure_control()"},{"location":"maplibre/measure/#measurement-tools","title":"Measurement Tools\u00b6","text":"<p>This notebook demonstrates how to add measurement tools for distances and areas on MapLibre maps.</p>"},{"location":"maplibre/measure/#distance-measurement","title":"Distance Measurement\u00b6","text":""},{"location":"maplibre/measure/#area-measurement-with-custom-colors","title":"Area Measurement with Custom Colors\u00b6","text":""},{"location":"maplibre/measure/#remove-measure-control","title":"Remove Measure Control\u00b6","text":""},{"location":"maplibre/pmtiles_layer/","title":"Pmtiles layer","text":"In\u00a0[\u00a0]: Copied! <pre># %pip install -U anymap-ts\n</pre> # %pip install -U anymap-ts In\u00a0[\u00a0]: Copied! <pre>from anymap_ts import Map\n</pre> from anymap_ts import Map In\u00a0[\u00a0]: Copied! <pre># Create a map centered on the world\nm = Map(\n    center=[0, 20],\n    zoom=2,\n)\n\n# Add a vector PMTiles layer with custom styling\nm.add_pmtiles_layer(\n    url=\"https://pmtiles.io/protomaps(vector)ODbL_firenze.pmtiles\",\n    layer_id=\"firenze\",\n    style={\n        \"type\": \"fill\",\n        \"source-layer\": \"buildings\",\n        \"fill-color\": \"#ff6b6b\",\n        \"fill-opacity\": 0.6,\n        \"fill-outline-color\": \"#ffffff\",\n    },\n    opacity=0.8,\n)\n\n# Add layer control\nm.add_layer_control()\n\nm\n</pre> # Create a map centered on the world m = Map(     center=[0, 20],     zoom=2, )  # Add a vector PMTiles layer with custom styling m.add_pmtiles_layer(     url=\"https://pmtiles.io/protomaps(vector)ODbL_firenze.pmtiles\",     layer_id=\"firenze\",     style={         \"type\": \"fill\",         \"source-layer\": \"buildings\",         \"fill-color\": \"#ff6b6b\",         \"fill-opacity\": 0.6,         \"fill-outline-color\": \"#ffffff\",     },     opacity=0.8, )  # Add layer control m.add_layer_control()  m In\u00a0[\u00a0]: Copied! <pre># Create a map focused on Firenze (Florence), Italy\nm2 = Map(\n    center=[11.2558, 43.7696],  # Florence coordinates\n    zoom=12,\n    style=\"https://demotiles.maplibre.org/style.json\",\n    height=\"500px\",\n)\n\n# Add roads as lines\nm2.add_pmtiles_layer(\n    url=\"https://pmtiles.io/protomaps(vector)ODbL_firenze.pmtiles\",\n    layer_id=\"roads\",\n    style={\n        \"type\": \"line\",\n        \"source-layer\": \"roads\",\n        \"line-color\": \"#2c3e50\",\n        \"line-width\": 2,\n        \"line-opacity\": 0.8,\n    },\n)\n\n# Add buildings as fills\nm2.add_pmtiles_layer(\n    url=\"https://pmtiles.io/protomaps(vector)ODbL_firenze.pmtiles\",\n    layer_id=\"buildings\",\n    style={\n        \"type\": \"fill\",\n        \"source-layer\": \"buildings\",\n        \"fill-color\": \"#e74c3c\",\n        \"fill-opacity\": 0.6,\n        \"fill-outline-color\": \"#c0392b\",\n    },\n)\n\n# Add points of interest as circles\nm2.add_pmtiles_layer(\n    url=\"https://pmtiles.io/protomaps(vector)ODbL_firenze.pmtiles\",\n    layer_id=\"pois\",\n    style={\n        \"type\": \"circle\",\n        \"source-layer\": \"pois\",\n        \"circle-color\": \"#f39c12\",\n        \"circle-radius\": 4,\n        \"circle-opacity\": 0.9,\n        \"circle-stroke-color\": \"#e67e22\",\n        \"circle-stroke-width\": 1,\n    },\n)\n\n# Add layer control\nm2.add_layer_control()\n\nm2\n</pre> # Create a map focused on Firenze (Florence), Italy m2 = Map(     center=[11.2558, 43.7696],  # Florence coordinates     zoom=12,     style=\"https://demotiles.maplibre.org/style.json\",     height=\"500px\", )  # Add roads as lines m2.add_pmtiles_layer(     url=\"https://pmtiles.io/protomaps(vector)ODbL_firenze.pmtiles\",     layer_id=\"roads\",     style={         \"type\": \"line\",         \"source-layer\": \"roads\",         \"line-color\": \"#2c3e50\",         \"line-width\": 2,         \"line-opacity\": 0.8,     }, )  # Add buildings as fills m2.add_pmtiles_layer(     url=\"https://pmtiles.io/protomaps(vector)ODbL_firenze.pmtiles\",     layer_id=\"buildings\",     style={         \"type\": \"fill\",         \"source-layer\": \"buildings\",         \"fill-color\": \"#e74c3c\",         \"fill-opacity\": 0.6,         \"fill-outline-color\": \"#c0392b\",     }, )  # Add points of interest as circles m2.add_pmtiles_layer(     url=\"https://pmtiles.io/protomaps(vector)ODbL_firenze.pmtiles\",     layer_id=\"pois\",     style={         \"type\": \"circle\",         \"source-layer\": \"pois\",         \"circle-color\": \"#f39c12\",         \"circle-radius\": 4,         \"circle-opacity\": 0.9,         \"circle-stroke-color\": \"#e67e22\",         \"circle-stroke-width\": 1,     }, )  # Add layer control m2.add_layer_control()  m2 In\u00a0[\u00a0]: Copied! <pre># Note: This is a placeholder example as we don't have a public raster PMTiles URL\n# In practice, you would use your own raster PMTiles file\n\nm3 = Map(\n    center=[-120.5, 35.5],\n    zoom=8,\n    style=\"https://demotiles.maplibre.org/style.json\",\n    height=\"500px\",\n)\n\n# Example of how to add a raster PMTiles layer\n# m3.add_pmtiles_layer(\n#     url=\"https://example.com/satellite.pmtiles\",\n#     layer_id=\"satellite\",\n#     source_type=\"raster\",\n#     opacity=0.8\n# )\n\nprint(\"For raster PMTiles, use source_type='raster' and adjust opacity as needed.\")\nprint(\"The layer will be added as a raster layer with the specified opacity.\")\n\nm3\n</pre> # Note: This is a placeholder example as we don't have a public raster PMTiles URL # In practice, you would use your own raster PMTiles file  m3 = Map(     center=[-120.5, 35.5],     zoom=8,     style=\"https://demotiles.maplibre.org/style.json\",     height=\"500px\", )  # Example of how to add a raster PMTiles layer # m3.add_pmtiles_layer( #     url=\"https://example.com/satellite.pmtiles\", #     layer_id=\"satellite\", #     source_type=\"raster\", #     opacity=0.8 # )  print(\"For raster PMTiles, use source_type='raster' and adjust opacity as needed.\") print(\"The layer will be added as a raster layer with the specified opacity.\")  m3 In\u00a0[\u00a0]: Copied! <pre># Remove a layer\n# m2.remove_pmtiles_layer(\"roads\")\n\n# Set layer visibility\n# m2.set_visibility(\"buildings\", False)\n\n# Set layer opacity\n# m2.set_opacity(\"buildings\", 0.3)\n\nprint(\"Layer management methods:\")\nprint(\"- remove_pmtiles_layer(layer_id)\")\nprint(\"- set_visibility(layer_id, visible)\")\nprint(\"- set_opacity(layer_id, opacity)\")\n</pre> # Remove a layer # m2.remove_pmtiles_layer(\"roads\")  # Set layer visibility # m2.set_visibility(\"buildings\", False)  # Set layer opacity # m2.set_opacity(\"buildings\", 0.3)  print(\"Layer management methods:\") print(\"- remove_pmtiles_layer(layer_id)\") print(\"- set_visibility(layer_id, visible)\") print(\"- set_opacity(layer_id, opacity)\") In\u00a0[\u00a0]: Copied! <pre>from anymap_ts import Map\n\n# Use Example 2 which is centered on Florence at the right zoom\nm = Map(\n    center=[11.2558, 43.7696],\n    zoom=14,\n    style=\"https://demotiles.maplibre.org/style.json\",\n    height=\"500px\",\n)\n\nm.add_pmtiles_layer(\n    url=\"https://pmtiles.io/protomaps(vector)ODbL_firenze.pmtiles\",\n    layer_id=\"buildings\",\n    style={\n        \"type\": \"fill\",\n        \"source-layer\": \"buildings\",\n        \"fill-color\": \"#e74c3c\",\n        \"fill-opacity\": 0.7,\n        \"fill-outline-color\": \"#c0392b\",\n    },\n)\n\nm\n</pre> from anymap_ts import Map  # Use Example 2 which is centered on Florence at the right zoom m = Map(     center=[11.2558, 43.7696],     zoom=14,     style=\"https://demotiles.maplibre.org/style.json\",     height=\"500px\", )  m.add_pmtiles_layer(     url=\"https://pmtiles.io/protomaps(vector)ODbL_firenze.pmtiles\",     layer_id=\"buildings\",     style={         \"type\": \"fill\",         \"source-layer\": \"buildings\",         \"fill-color\": \"#e74c3c\",         \"fill-opacity\": 0.7,         \"fill-outline-color\": \"#c0392b\",     }, )  m In\u00a0[\u00a0]: Copied! <pre>from anymap_ts import Map\n\nm = Map(\n    center=[11.2558, 43.7696],\n    zoom=14,\n    style=\"https://demotiles.maplibre.org/style.json\",\n    height=\"500px\",\n)\n\nm.add_pmtiles_layer(\n    url=\"https://pmtiles.io/protomaps(vector)ODbL_firenze.pmtiles\",\n    layer_id=\"buildings_test\",\n    style={\n        \"type\": \"fill\",\n        \"source-layer\": \"buildings\",\n        \"fill-color\": \"#e74c3c\",\n        \"fill-opacity\": 0.7,\n        \"fill-outline-color\": \"#c0392b\",\n    },\n)\n\nm\n</pre> from anymap_ts import Map  m = Map(     center=[11.2558, 43.7696],     zoom=14,     style=\"https://demotiles.maplibre.org/style.json\",     height=\"500px\", )  m.add_pmtiles_layer(     url=\"https://pmtiles.io/protomaps(vector)ODbL_firenze.pmtiles\",     layer_id=\"buildings_test\",     style={         \"type\": \"fill\",         \"source-layer\": \"buildings\",         \"fill-color\": \"#e74c3c\",         \"fill-opacity\": 0.7,         \"fill-outline-color\": \"#c0392b\",     }, )  m In\u00a0[\u00a0]: Copied! <pre>from anymap_ts import Map\n\nm = Map(\n    center=[11.2558, 43.7696],\n    zoom=14,\n    style=\"https://demotiles.maplibre.org/style.json\",\n    height=\"500px\",\n)\n\nm.add_pmtiles_layer(\n    url=\"https://pmtiles.io/protomaps(vector)ODbL_firenze.pmtiles\",\n    layer_id=\"buildings_v3\",\n    style={\n        \"type\": \"fill\",\n        \"source-layer\": \"buildings\",\n        \"fill-color\": \"#e74c3c\",\n        \"fill-opacity\": 0.7,\n        \"fill-outline-color\": \"#c0392b\",\n    },\n)\n\nm\n</pre> from anymap_ts import Map  m = Map(     center=[11.2558, 43.7696],     zoom=14,     style=\"https://demotiles.maplibre.org/style.json\",     height=\"500px\", )  m.add_pmtiles_layer(     url=\"https://pmtiles.io/protomaps(vector)ODbL_firenze.pmtiles\",     layer_id=\"buildings_v3\",     style={         \"type\": \"fill\",         \"source-layer\": \"buildings\",         \"fill-color\": \"#e74c3c\",         \"fill-opacity\": 0.7,         \"fill-outline-color\": \"#c0392b\",     }, )  m In\u00a0[\u00a0]: Copied! <pre># Check if the ESM content includes the PMTiles handler\nfrom anymap_ts import Map\n\nm = Map()\nesm_content = m._esm if isinstance(m._esm, str) else open(str(m._esm)).read()\nprint(\"Bundle size:\", len(esm_content))\nprint(\"Has addPMTilesLayer:\", \"addPMTilesLayer\" in esm_content)\nprint(\"Has pmtiles://:\", \"pmtiles://\" in esm_content)\nprint(\n    \"Has PMTilesProtocol:\",\n    \"PMTilesProtocol\" in esm_content or \"Protocol\" in esm_content,\n)\nprint(\"Has addProtocol:\", \"addProtocol\" in esm_content)\n\n# Check the specific call pattern\nimport re\n\nmatches = re.findall(r\".{0,40}addProtocol.{0,60}\", esm_content)\nfor match in matches[:5]:\n    print(\"Found:\", match.strip())\n</pre> # Check if the ESM content includes the PMTiles handler from anymap_ts import Map  m = Map() esm_content = m._esm if isinstance(m._esm, str) else open(str(m._esm)).read() print(\"Bundle size:\", len(esm_content)) print(\"Has addPMTilesLayer:\", \"addPMTilesLayer\" in esm_content) print(\"Has pmtiles://:\", \"pmtiles://\" in esm_content) print(     \"Has PMTilesProtocol:\",     \"PMTilesProtocol\" in esm_content or \"Protocol\" in esm_content, ) print(\"Has addProtocol:\", \"addProtocol\" in esm_content)  # Check the specific call pattern import re  matches = re.findall(r\".{0,40}addProtocol.{0,60}\", esm_content) for match in matches[:5]:     print(\"Found:\", match.strip())"},{"location":"maplibre/pmtiles_layer/#pmtiles-layer-support","title":"PMTiles Layer Support\u00b6","text":"<p>This notebook demonstrates how to use PMTiles with anymap-ts MapLibre backend.</p> <p>PMTiles is a single-file archive format for pyramids of map tiles that enables efficient web-native map serving without requiring a separate tile server.</p>"},{"location":"maplibre/pmtiles_layer/#features","title":"Features\u00b6","text":"<ul> <li>Support for both vector and raster PMTiles</li> <li>Customizable styling for vector layers</li> <li>Layer opacity and visibility controls</li> <li>Integration with layer control panel</li> </ul>"},{"location":"maplibre/pmtiles_layer/#installation","title":"Installation\u00b6","text":"<p>Make sure you have anymap-ts installed:</p> <pre>pip install anymap-ts\n</pre>"},{"location":"maplibre/pmtiles_layer/#example-1-vector-pmtiles-world-countries","title":"Example 1: Vector PMTiles - World Countries\u00b6","text":"<p>Let's start with a vector PMTiles file showing world countries from Natural Earth data.</p>"},{"location":"maplibre/pmtiles_layer/#example-2-different-layer-types","title":"Example 2: Different Layer Types\u00b6","text":"<p>PMTiles vector data can be styled using different layer types (fill, line, circle, symbol).</p>"},{"location":"maplibre/pmtiles_layer/#example-3-raster-pmtiles","title":"Example 3: Raster PMTiles\u00b6","text":"<p>PMTiles also supports raster tiles for satellite imagery, digital elevation models, etc.</p>"},{"location":"maplibre/pmtiles_layer/#layer-management","title":"Layer Management\u00b6","text":"<p>You can programmatically control PMTiles layers:</p>"},{"location":"maplibre/pmtiles_layer/#style-configuration","title":"Style Configuration\u00b6","text":"<p>The <code>style</code> parameter accepts MapLibre style properties:</p>"},{"location":"maplibre/pmtiles_layer/#for-fill-layers","title":"For Fill Layers\u00b6","text":"<pre>style = {\n    \"type\": \"fill\",\n    \"source-layer\": \"layer_name\",\n    \"fill-color\": \"#3388ff\",\n    \"fill-opacity\": 0.6,\n    \"fill-outline-color\": \"#ffffff\"\n}\n</pre>"},{"location":"maplibre/pmtiles_layer/#for-line-layers","title":"For Line Layers\u00b6","text":"<pre>style = {\n    \"type\": \"line\",\n    \"source-layer\": \"layer_name\",\n    \"line-color\": \"#ff0000\",\n    \"line-width\": 2,\n    \"line-opacity\": 0.8\n}\n</pre>"},{"location":"maplibre/pmtiles_layer/#for-circle-layers","title":"For Circle Layers\u00b6","text":"<pre>style = {\n    \"type\": \"circle\",\n    \"source-layer\": \"layer_name\",\n    \"circle-color\": \"#00ff00\",\n    \"circle-radius\": 5,\n    \"circle-opacity\": 0.9\n}\n</pre>"},{"location":"maplibre/pmtiles_layer/#benefits-of-pmtiles","title":"Benefits of PMTiles\u00b6","text":"<ol> <li>Single File: No need for complex tile server infrastructure</li> <li>Efficient: HTTP range requests enable fast random access</li> <li>Scalable: Works with CDNs and cloud storage</li> <li>Portable: Easy to share and deploy</li> <li>Cost-effective: Reduces server costs and complexity</li> </ol>"},{"location":"maplibre/pointcloud_layer/","title":"Pointcloud layer","text":"In\u00a0[\u00a0]: Copied! <pre># %pip install -U anymap-ts\n</pre> # %pip install -U anymap-ts In\u00a0[\u00a0]: Copied! <pre>import random\nfrom anymap_ts import MapLibreMap\n\n\n# Generate sample 3D point cloud data\ndef generate_points(center_lng, center_lat, num_points=1000, spread=0.01):\n    points = []\n    for _ in range(num_points):\n        lng = center_lng + random.uniform(-spread, spread)\n        lat = center_lat + random.uniform(-spread, spread)\n        # Elevation based on distance from center (creates a dome shape)\n        dist = ((lng - center_lng) ** 2 + (lat - center_lat) ** 2) ** 0.5\n        elevation = max(0, 500 - dist * 50000) + random.uniform(0, 50)\n        # Color by elevation (blue to red)\n        color_ratio = min(elevation / 500, 1)\n        color = [\n            int(255 * color_ratio),\n            int(100 * (1 - color_ratio)),\n            int(255 * (1 - color_ratio)),\n            255,\n        ]\n        points.append({\"position\": [lng, lat, elevation], \"color\": color})\n    return points\n\n\n# Generate points around San Francisco\npoint_cloud = generate_points(-122.4194, 37.7749)\n\nm = MapLibreMap(center=[-122.4194, 37.7749], zoom=14, pitch=60)\nm.add_basemap(\"CartoDB.DarkMatter\")\nm.add_point_cloud_layer(\n    data=point_cloud,\n    name=\"pointcloud-demo\",\n    get_position=\"position\",\n    get_color=\"color\",\n    point_size=3,\n    opacity=0.9,\n)\nm\n</pre> import random from anymap_ts import MapLibreMap   # Generate sample 3D point cloud data def generate_points(center_lng, center_lat, num_points=1000, spread=0.01):     points = []     for _ in range(num_points):         lng = center_lng + random.uniform(-spread, spread)         lat = center_lat + random.uniform(-spread, spread)         # Elevation based on distance from center (creates a dome shape)         dist = ((lng - center_lng) ** 2 + (lat - center_lat) ** 2) ** 0.5         elevation = max(0, 500 - dist * 50000) + random.uniform(0, 50)         # Color by elevation (blue to red)         color_ratio = min(elevation / 500, 1)         color = [             int(255 * color_ratio),             int(100 * (1 - color_ratio)),             int(255 * (1 - color_ratio)),             255,         ]         points.append({\"position\": [lng, lat, elevation], \"color\": color})     return points   # Generate points around San Francisco point_cloud = generate_points(-122.4194, 37.7749)  m = MapLibreMap(center=[-122.4194, 37.7749], zoom=14, pitch=60) m.add_basemap(\"CartoDB.DarkMatter\") m.add_point_cloud_layer(     data=point_cloud,     name=\"pointcloud-demo\",     get_position=\"position\",     get_color=\"color\",     point_size=3,     opacity=0.9, ) m In\u00a0[\u00a0]: Copied! <pre>from anymap_ts import DeckGLMap\n\n# Generate larger point cloud\nlarge_cloud = generate_points(-122.4194, 37.7749, num_points=5000, spread=0.02)\n\nm2 = DeckGLMap(center=[-122.4194, 37.7749], zoom=13, pitch=50, bearing=30)\nm2.add_basemap(\"CartoDB.DarkMatter\")\nm2.add_point_cloud_layer(\n    data=large_cloud,\n    name=\"large-cloud\",\n    get_position=\"position\",\n    get_color=\"color\",\n    point_size=2,\n    size_units=\"pixels\",\n    opacity=0.8,\n)\nm2\n</pre> from anymap_ts import DeckGLMap  # Generate larger point cloud large_cloud = generate_points(-122.4194, 37.7749, num_points=5000, spread=0.02)  m2 = DeckGLMap(center=[-122.4194, 37.7749], zoom=13, pitch=50, bearing=30) m2.add_basemap(\"CartoDB.DarkMatter\") m2.add_point_cloud_layer(     data=large_cloud,     name=\"large-cloud\",     get_position=\"position\",     get_color=\"color\",     point_size=2,     size_units=\"pixels\",     opacity=0.8, ) m2 In\u00a0[\u00a0]: Copied! <pre># Simple point cloud with uniform color\nsimple_points = [\n    {\"position\": [lng, lat, alt]}\n    for lng in [-122.42, -122.41, -122.40, -122.39]\n    for lat in [37.77, 37.78, 37.79, 37.80]\n    for alt in [0, 100, 200, 300]\n]\n\nm3 = MapLibreMap(center=[-122.405, 37.785], zoom=13, pitch=60)\nm3.add_basemap(\"CartoDB.Positron\")\nm3.add_point_cloud_layer(\n    data=simple_points,\n    name=\"grid-points\",\n    get_position=\"position\",\n    get_color=[0, 200, 255, 200],  # Uniform cyan color\n    point_size=8,\n)\nm3\n</pre> # Simple point cloud with uniform color simple_points = [     {\"position\": [lng, lat, alt]}     for lng in [-122.42, -122.41, -122.40, -122.39]     for lat in [37.77, 37.78, 37.79, 37.80]     for alt in [0, 100, 200, 300] ]  m3 = MapLibreMap(center=[-122.405, 37.785], zoom=13, pitch=60) m3.add_basemap(\"CartoDB.Positron\") m3.add_point_cloud_layer(     data=simple_points,     name=\"grid-points\",     get_position=\"position\",     get_color=[0, 200, 255, 200],  # Uniform cyan color     point_size=8, ) m3 In\u00a0[\u00a0]: Copied! <pre># Generate two point clouds\ncloud1 = generate_points(-122.43, 37.78, num_points=500, spread=0.005)\ncloud2 = generate_points(-122.40, 37.77, num_points=500, spread=0.005)\n\nm4 = MapLibreMap(center=[-122.415, 37.775], zoom=13, pitch=45)\nm4.add_basemap(\"CartoDB.DarkMatter\")\n\n# Add first point cloud (blue theme)\nfor p in cloud1:\n    p[\"color\"] = [100, 150, 255, 200]\n\nm4.add_point_cloud_layer(\n    data=cloud1,\n    name=\"pointcloud-north\",\n    get_position=\"position\",\n    get_color=\"color\",\n    point_size=4,\n)\n\n# Add second point cloud (orange theme)\nfor p in cloud2:\n    p[\"color\"] = [255, 150, 100, 200]\n\nm4.add_point_cloud_layer(\n    data=cloud2,\n    name=\"pointcloud-south\",\n    get_position=\"position\",\n    get_color=\"color\",\n    point_size=4,\n)\n\n# Add layer control\nm4.add_layer_control()\nm4\n</pre> # Generate two point clouds cloud1 = generate_points(-122.43, 37.78, num_points=500, spread=0.005) cloud2 = generate_points(-122.40, 37.77, num_points=500, spread=0.005)  m4 = MapLibreMap(center=[-122.415, 37.775], zoom=13, pitch=45) m4.add_basemap(\"CartoDB.DarkMatter\")  # Add first point cloud (blue theme) for p in cloud1:     p[\"color\"] = [100, 150, 255, 200]  m4.add_point_cloud_layer(     data=cloud1,     name=\"pointcloud-north\",     get_position=\"position\",     get_color=\"color\",     point_size=4, )  # Add second point cloud (orange theme) for p in cloud2:     p[\"color\"] = [255, 150, 100, 200]  m4.add_point_cloud_layer(     data=cloud2,     name=\"pointcloud-south\",     get_position=\"position\",     get_color=\"color\",     point_size=4, )  # Add layer control m4.add_layer_control() m4 In\u00a0[\u00a0]: Copied! <pre># Combine arc and point cloud layers\nm5 = MapLibreMap(center=[-122.4, 37.78], zoom=11, pitch=50)\nm5.add_basemap(\"CartoDB.DarkMatter\")\n\n# Add point clouds at locations\nlocations = [\n    (-122.45, 37.80),  # Golden Gate\n    (-122.40, 37.78),  # Downtown\n    (-122.35, 37.75),  # East Bay\n]\n\nfor i, (lng, lat) in enumerate(locations):\n    cloud = generate_points(lng, lat, num_points=200, spread=0.003)\n    for p in cloud:\n        p[\"color\"] = [100 + 50 * i, 200 - 50 * i, 150, 200]\n    m5.add_point_cloud_layer(\n        data=cloud,\n        name=f\"pointcloud-loc{i}\",\n        get_position=\"position\",\n        get_color=\"color\",\n        point_size=3,\n    )\n\n# Add arcs connecting the locations\narcs = [\n    {\"source\": list(locations[0]), \"target\": list(locations[1])},\n    {\"source\": list(locations[1]), \"target\": list(locations[2])},\n    {\"source\": list(locations[0]), \"target\": list(locations[2])},\n]\n\nm5.add_arc_layer(\n    data=arcs,\n    name=\"arc-connections\",\n    get_source_color=[0, 255, 200, 255],\n    get_target_color=[255, 200, 0, 255],\n    get_width=2,\n)\n\nm5.add_layer_control()\nm5\n</pre> # Combine arc and point cloud layers m5 = MapLibreMap(center=[-122.4, 37.78], zoom=11, pitch=50) m5.add_basemap(\"CartoDB.DarkMatter\")  # Add point clouds at locations locations = [     (-122.45, 37.80),  # Golden Gate     (-122.40, 37.78),  # Downtown     (-122.35, 37.75),  # East Bay ]  for i, (lng, lat) in enumerate(locations):     cloud = generate_points(lng, lat, num_points=200, spread=0.003)     for p in cloud:         p[\"color\"] = [100 + 50 * i, 200 - 50 * i, 150, 200]     m5.add_point_cloud_layer(         data=cloud,         name=f\"pointcloud-loc{i}\",         get_position=\"position\",         get_color=\"color\",         point_size=3,     )  # Add arcs connecting the locations arcs = [     {\"source\": list(locations[0]), \"target\": list(locations[1])},     {\"source\": list(locations[1]), \"target\": list(locations[2])},     {\"source\": list(locations[0]), \"target\": list(locations[2])}, ]  m5.add_arc_layer(     data=arcs,     name=\"arc-connections\",     get_source_color=[0, 255, 200, 255],     get_target_color=[255, 200, 0, 255],     get_width=2, )  m5.add_layer_control() m5 In\u00a0[\u00a0]: Copied! <pre># Remove a specific point cloud layer\nm4.remove_point_cloud_layer(\"pointcloud-north\")\n</pre> # Remove a specific point cloud layer m4.remove_point_cloud_layer(\"pointcloud-north\") In\u00a0[\u00a0]: Copied! <pre>m.to_html(\"pointcloud_layer_example.html\")\n</pre> m.to_html(\"pointcloud_layer_example.html\")"},{"location":"maplibre/pointcloud_layer/#point-cloud-layer-example","title":"Point Cloud Layer Example\u00b6","text":"<p>This notebook demonstrates the DeckGL PointCloudLayer for visualizing 3D point data.</p> <p>Point cloud layers are ideal for:</p> <ul> <li>LiDAR data visualization</li> <li>3D scanning results</li> <li>Elevation data</li> <li>Any 3D point dataset</li> </ul>"},{"location":"maplibre/pointcloud_layer/#basic-point-cloud-with-maplibre","title":"Basic Point Cloud with MapLibre\u00b6","text":""},{"location":"maplibre/pointcloud_layer/#point-cloud-with-deckglmap","title":"Point Cloud with DeckGLMap\u00b6","text":""},{"location":"maplibre/pointcloud_layer/#point-cloud-with-uniform-color","title":"Point Cloud with Uniform Color\u00b6","text":""},{"location":"maplibre/pointcloud_layer/#point-cloud-with-layer-control","title":"Point Cloud with Layer Control\u00b6","text":""},{"location":"maplibre/pointcloud_layer/#combined-arc-and-point-cloud-layers","title":"Combined Arc and Point Cloud Layers\u00b6","text":""},{"location":"maplibre/pointcloud_layer/#remove-point-cloud-layer","title":"Remove Point Cloud Layer\u00b6","text":""},{"location":"maplibre/pointcloud_layer/#export-to-html","title":"Export to HTML\u00b6","text":""},{"location":"maplibre/popups/","title":"Popups","text":"In\u00a0[\u00a0]: Copied! <pre># %pip install -U anymap-ts\n</pre> # %pip install -U anymap-ts In\u00a0[\u00a0]: Copied! <pre>from anymap_ts import Map\n\n# Create sample GeoJSON data\ngeojson = {\n    \"type\": \"FeatureCollection\",\n    \"features\": [\n        {\n            \"type\": \"Feature\",\n            \"geometry\": {\"type\": \"Point\", \"coordinates\": [-122.4, 37.8]},\n            \"properties\": {\n                \"name\": \"San Francisco\",\n                \"population\": 884363,\n                \"state\": \"California\",\n            },\n        },\n        {\n            \"type\": \"Feature\",\n            \"geometry\": {\"type\": \"Point\", \"coordinates\": [-122.3, 47.6]},\n            \"properties\": {\n                \"name\": \"Seattle\",\n                \"population\": 737015,\n                \"state\": \"Washington\",\n            },\n        },\n        {\n            \"type\": \"Feature\",\n            \"geometry\": {\"type\": \"Point\", \"coordinates\": [-122.7, 45.5]},\n            \"properties\": {\"name\": \"Portland\", \"population\": 652503, \"state\": \"Oregon\"},\n        },\n    ],\n}\n\nm = Map(center=[-122.4, 45], zoom=5)\nm.add_vector(geojson, name=\"cities\")\nm.add_popup(\"cities\", properties=[\"name\", \"population\", \"state\"])\nm\n</pre> from anymap_ts import Map  # Create sample GeoJSON data geojson = {     \"type\": \"FeatureCollection\",     \"features\": [         {             \"type\": \"Feature\",             \"geometry\": {\"type\": \"Point\", \"coordinates\": [-122.4, 37.8]},             \"properties\": {                 \"name\": \"San Francisco\",                 \"population\": 884363,                 \"state\": \"California\",             },         },         {             \"type\": \"Feature\",             \"geometry\": {\"type\": \"Point\", \"coordinates\": [-122.3, 47.6]},             \"properties\": {                 \"name\": \"Seattle\",                 \"population\": 737015,                 \"state\": \"Washington\",             },         },         {             \"type\": \"Feature\",             \"geometry\": {\"type\": \"Point\", \"coordinates\": [-122.7, 45.5]},             \"properties\": {\"name\": \"Portland\", \"population\": 652503, \"state\": \"Oregon\"},         },     ], }  m = Map(center=[-122.4, 45], zoom=5) m.add_vector(geojson, name=\"cities\") m.add_popup(\"cities\", properties=[\"name\", \"population\", \"state\"]) m In\u00a0[\u00a0]: Copied! <pre>m2 = Map(center=[-122.4, 45], zoom=5)\nm2.add_vector(geojson, name=\"cities-custom\")\nm2.add_popup(\n    \"cities-custom\",\n    template=\"&lt;h3&gt;{name}&lt;/h3&gt;&lt;p&gt;Population: {population}&lt;/p&gt;&lt;p&gt;State: {state}&lt;/p&gt;\",\n)\nm2\n</pre> m2 = Map(center=[-122.4, 45], zoom=5) m2.add_vector(geojson, name=\"cities-custom\") m2.add_popup(     \"cities-custom\",     template=\"{name}<p>Population: {population}</p><p>State: {state}</p>\", ) m2 In\u00a0[\u00a0]: Copied! <pre>polygon_geojson = {\n    \"type\": \"FeatureCollection\",\n    \"features\": [\n        {\n            \"type\": \"Feature\",\n            \"geometry\": {\n                \"type\": \"Polygon\",\n                \"coordinates\": [\n                    [\n                        [-122.5, 37.7],\n                        [-122.3, 37.7],\n                        [-122.3, 37.9],\n                        [-122.5, 37.9],\n                        [-122.5, 37.7],\n                    ]\n                ],\n            },\n            \"properties\": {\"name\": \"Area A\", \"type\": \"residential\"},\n        },\n        {\n            \"type\": \"Feature\",\n            \"geometry\": {\n                \"type\": \"Polygon\",\n                \"coordinates\": [\n                    [\n                        [-122.3, 37.7],\n                        [-122.1, 37.7],\n                        [-122.1, 37.9],\n                        [-122.3, 37.9],\n                        [-122.3, 37.7],\n                    ]\n                ],\n            },\n            \"properties\": {\"name\": \"Area B\", \"type\": \"commercial\"},\n        },\n    ],\n}\n\nm3 = Map(center=[-122.3, 37.8], zoom=11)\nm3.add_vector(\n    polygon_geojson, name=\"areas\", paint={\"fill-color\": \"#3388ff\", \"fill-opacity\": 0.5}\n)\nm3.add_popup(\"areas\")\nm3\n</pre> polygon_geojson = {     \"type\": \"FeatureCollection\",     \"features\": [         {             \"type\": \"Feature\",             \"geometry\": {                 \"type\": \"Polygon\",                 \"coordinates\": [                     [                         [-122.5, 37.7],                         [-122.3, 37.7],                         [-122.3, 37.9],                         [-122.5, 37.9],                         [-122.5, 37.7],                     ]                 ],             },             \"properties\": {\"name\": \"Area A\", \"type\": \"residential\"},         },         {             \"type\": \"Feature\",             \"geometry\": {                 \"type\": \"Polygon\",                 \"coordinates\": [                     [                         [-122.3, 37.7],                         [-122.1, 37.7],                         [-122.1, 37.9],                         [-122.3, 37.9],                         [-122.3, 37.7],                     ]                 ],             },             \"properties\": {\"name\": \"Area B\", \"type\": \"commercial\"},         },     ], }  m3 = Map(center=[-122.3, 37.8], zoom=11) m3.add_vector(     polygon_geojson, name=\"areas\", paint={\"fill-color\": \"#3388ff\", \"fill-opacity\": 0.5} ) m3.add_popup(\"areas\") m3 In\u00a0[\u00a0]: Copied! <pre>m3.to_html(\"popups_example.html\")\n</pre> m3.to_html(\"popups_example.html\")"},{"location":"maplibre/popups/#popups-example","title":"Popups Example\u00b6","text":"<p>This notebook demonstrates how to add interactive popups to map layers using the <code>add_popup</code> method.</p>"},{"location":"maplibre/popups/#basic-popup-with-property-list","title":"Basic Popup with Property List\u00b6","text":""},{"location":"maplibre/popups/#custom-html-template-popup","title":"Custom HTML Template Popup\u00b6","text":""},{"location":"maplibre/popups/#popup-on-polygon-layer","title":"Popup on Polygon Layer\u00b6","text":""},{"location":"maplibre/popups/#export-to-html","title":"Export to HTML\u00b6","text":""},{"location":"maplibre/print_control/","title":"Print control","text":"In\u00a0[\u00a0]: Copied! <pre># %pip install -U anymap-ts\n</pre> # %pip install -U anymap-ts In\u00a0[\u00a0]: Copied! <pre>from anymap_ts import Map\n\nm = Map(center=[-122.4, 37.8], zoom=10)\nm.add_print_control(position=\"top-right\")\nm\n</pre> from anymap_ts import Map  m = Map(center=[-122.4, 37.8], zoom=10) m.add_print_control(position=\"top-right\") m In\u00a0[\u00a0]: Copied! <pre>m2 = Map(\n    center=[-112.1, 36.1],\n    zoom=13,\n    pitch=60,\n    bearing=-17,\n    style=\"https://tiles.openfreemap.org/styles/liberty\",\n)\nm2.add_3d_terrain(exaggeration=1.5)\nm2.add_print_control(\n    position=\"top-right\",\n    format=\"png\",\n    filename=\"grand-canyon\",\n    include_north_arrow=True,\n    include_scale_bar=True,\n)\nm2\n</pre> m2 = Map(     center=[-112.1, 36.1],     zoom=13,     pitch=60,     bearing=-17,     style=\"https://tiles.openfreemap.org/styles/liberty\", ) m2.add_3d_terrain(exaggeration=1.5) m2.add_print_control(     position=\"top-right\",     format=\"png\",     filename=\"grand-canyon\",     include_north_arrow=True,     include_scale_bar=True, ) m2 In\u00a0[\u00a0]: Copied! <pre>m.remove_print_control()\n</pre> m.remove_print_control()"},{"location":"maplibre/print_control/#print-export-control","title":"Print / Export Control\u00b6","text":"<p>This notebook demonstrates how to add a print/export control for saving the map view as PNG, JPEG, or PDF.</p>"},{"location":"maplibre/print_control/#basic-print-control","title":"Basic Print Control\u00b6","text":""},{"location":"maplibre/print_control/#print-control-with-layers-and-options","title":"Print Control with Layers and Options\u00b6","text":""},{"location":"maplibre/print_control/#remove-print-control","title":"Remove Print Control\u00b6","text":""},{"location":"maplibre/route_animation/","title":"Route animation","text":"In\u00a0[\u00a0]: Copied! <pre># %pip install -U anymap-ts\n</pre> # %pip install -U anymap-ts In\u00a0[\u00a0]: Copied! <pre>from anymap_ts import Map\n\n# Simple route along the California coast\nroute = [\n    [-122.4194, 37.7749],  # San Francisco\n    [-122.3, 37.5],\n    [-121.9, 36.9],\n    [-121.8, 36.6],  # Monterey\n    [-121.5, 36.2],\n    [-120.8, 35.4],\n    [-120.6, 35.1],  # San Luis Obispo\n    [-119.9, 34.6],\n    [-119.7, 34.4],  # Santa Barbara\n    [-118.5, 34.1],\n    [-118.2437, 34.0522],  # Los Angeles\n]\n\nm = Map(center=[-120.5, 35.5], zoom=6)\nm.add_basemap(\"CartoDB.Positron\")\n\n# Also add the route as a line for reference\nroute_geojson = {\n    \"type\": \"Feature\",\n    \"properties\": {},\n    \"geometry\": {\"type\": \"LineString\", \"coordinates\": route},\n}\nm.add_geojson(\n    route_geojson,\n    name=\"route-line\",\n    paint={\"line-color\": \"#888\", \"line-width\": 2, \"line-dasharray\": [2, 2]},\n)\n\n# Animate a marker along the route\nanim_id = m.animate_along_route(\n    route, duration=15000, loop=True, marker_color=\"#ff0000\"  # 15 seconds\n)\nprint(f\"Animation ID: {anim_id}\")\nm\n</pre> from anymap_ts import Map  # Simple route along the California coast route = [     [-122.4194, 37.7749],  # San Francisco     [-122.3, 37.5],     [-121.9, 36.9],     [-121.8, 36.6],  # Monterey     [-121.5, 36.2],     [-120.8, 35.4],     [-120.6, 35.1],  # San Luis Obispo     [-119.9, 34.6],     [-119.7, 34.4],  # Santa Barbara     [-118.5, 34.1],     [-118.2437, 34.0522],  # Los Angeles ]  m = Map(center=[-120.5, 35.5], zoom=6) m.add_basemap(\"CartoDB.Positron\")  # Also add the route as a line for reference route_geojson = {     \"type\": \"Feature\",     \"properties\": {},     \"geometry\": {\"type\": \"LineString\", \"coordinates\": route}, } m.add_geojson(     route_geojson,     name=\"route-line\",     paint={\"line-color\": \"#888\", \"line-width\": 2, \"line-dasharray\": [2, 2]}, )  # Animate a marker along the route anim_id = m.animate_along_route(     route, duration=15000, loop=True, marker_color=\"#ff0000\"  # 15 seconds ) print(f\"Animation ID: {anim_id}\") m In\u00a0[\u00a0]: Copied! <pre># Circular route around a park\nimport math\n\n# Create a circular route\ncenter = [-122.4, 37.77]\nradius = 0.02  # degrees\npoints = 50\n\ncircular_route = []\nfor i in range(points + 1):\n    angle = 2 * math.pi * i / points\n    lng = center[0] + radius * math.cos(angle)\n    lat = center[1] + radius * math.sin(angle)\n    circular_route.append([lng, lat])\n\nm2 = Map(center=center, zoom=14)\nm2.add_basemap(\"CartoDB.Voyager\")\n\nanim2 = m2.animate_along_route(\n    circular_route,\n    duration=10000,\n    loop=True,\n    marker_color=\"#3388ff\",\n    show_trail=True,\n    trail_color=\"#3388ff\",\n    trail_width=4,\n)\nm2\n</pre> # Circular route around a park import math  # Create a circular route center = [-122.4, 37.77] radius = 0.02  # degrees points = 50  circular_route = [] for i in range(points + 1):     angle = 2 * math.pi * i / points     lng = center[0] + radius * math.cos(angle)     lat = center[1] + radius * math.sin(angle)     circular_route.append([lng, lat])  m2 = Map(center=center, zoom=14) m2.add_basemap(\"CartoDB.Voyager\")  anim2 = m2.animate_along_route(     circular_route,     duration=10000,     loop=True,     marker_color=\"#3388ff\",     show_trail=True,     trail_color=\"#3388ff\",     trail_width=4, ) m2 In\u00a0[\u00a0]: Copied! <pre># Route for control demo\ncontrol_route = [\n    [-74.0060, 40.7128],  # NYC\n    [-73.8, 40.8],\n    [-73.5, 40.9],\n    [-73.2, 41.0],\n    [-72.8, 41.2],\n    [-72.5, 41.4],\n    [-72.2, 41.6],\n    [-71.8, 41.8],\n    [-71.4, 42.0],\n    [-71.0589, 42.3601],  # Boston\n]\n\nm3 = Map(center=[-72.5, 41.2], zoom=7)\n\n# Add route line\nm3.add_geojson(\n    {\n        \"type\": \"Feature\",\n        \"geometry\": {\"type\": \"LineString\", \"coordinates\": control_route},\n    },\n    name=\"nyc-boston\",\n    paint={\"line-color\": \"#333\", \"line-width\": 3},\n)\n\nanim3 = m3.animate_along_route(\n    control_route,\n    duration=8000,\n    loop=True,\n    marker_color=\"#00aa00\",\n    animation_id=\"nyc-to-boston\",\n)\nm3\n</pre> # Route for control demo control_route = [     [-74.0060, 40.7128],  # NYC     [-73.8, 40.8],     [-73.5, 40.9],     [-73.2, 41.0],     [-72.8, 41.2],     [-72.5, 41.4],     [-72.2, 41.6],     [-71.8, 41.8],     [-71.4, 42.0],     [-71.0589, 42.3601],  # Boston ]  m3 = Map(center=[-72.5, 41.2], zoom=7)  # Add route line m3.add_geojson(     {         \"type\": \"Feature\",         \"geometry\": {\"type\": \"LineString\", \"coordinates\": control_route},     },     name=\"nyc-boston\",     paint={\"line-color\": \"#333\", \"line-width\": 3}, )  anim3 = m3.animate_along_route(     control_route,     duration=8000,     loop=True,     marker_color=\"#00aa00\",     animation_id=\"nyc-to-boston\", ) m3 In\u00a0[\u00a0]: Copied! <pre># Pause the animation\nm3.pause_animation(\"nyc-to-boston\")\n</pre> # Pause the animation m3.pause_animation(\"nyc-to-boston\") In\u00a0[\u00a0]: Copied! <pre># Resume the animation\nm3.resume_animation(\"nyc-to-boston\")\n</pre> # Resume the animation m3.resume_animation(\"nyc-to-boston\") In\u00a0[\u00a0]: Copied! <pre># Speed up the animation (2x speed)\nm3.set_animation_speed(\"nyc-to-boston\", 2.0)\n</pre> # Speed up the animation (2x speed) m3.set_animation_speed(\"nyc-to-boston\", 2.0) In\u00a0[\u00a0]: Copied! <pre># Slow down the animation (0.5x speed)\nm3.set_animation_speed(\"nyc-to-boston\", 0.5)\n</pre> # Slow down the animation (0.5x speed) m3.set_animation_speed(\"nyc-to-boston\", 0.5) In\u00a0[\u00a0]: Copied! <pre># Stop the animation\nm3.stop_animation(\"nyc-to-boston\")\n</pre> # Stop the animation m3.stop_animation(\"nyc-to-boston\") In\u00a0[\u00a0]: Copied! <pre># Flight path that plays once\nflight_route = [\n    [-122.3321, 47.6062],  # Seattle\n    [-119.0, 46.0],\n    [-115.0, 43.0],\n    [-111.0, 41.0],\n    [-107.0, 39.5],\n    [-104.0, 38.5],\n    [-100.0, 37.5],\n    [-97.0, 36.5],\n    [-94.0, 35.5],\n    [-91.0, 34.5],\n    [-87.0, 33.5],\n    [-84.3880, 33.7490],  # Atlanta\n]\n\nm4 = Map(center=[-102, 40], zoom=4)\nm4.add_basemap(\"CartoDB.DarkMatter\")\n\n# Add route as arc\nm4.add_geojson(\n    {\n        \"type\": \"Feature\",\n        \"geometry\": {\"type\": \"LineString\", \"coordinates\": flight_route},\n    },\n    name=\"flight-path\",\n    paint={\"line-color\": \"#ff8800\", \"line-width\": 2, \"line-opacity\": 0.5},\n)\n\nm4.animate_along_route(\n    flight_route,\n    duration=6000,\n    loop=False,  # Play once\n    marker_color=\"#ff8800\",\n    show_trail=True,\n    trail_color=\"#ff8800\",\n    trail_width=3,\n)\nm4\n</pre> # Flight path that plays once flight_route = [     [-122.3321, 47.6062],  # Seattle     [-119.0, 46.0],     [-115.0, 43.0],     [-111.0, 41.0],     [-107.0, 39.5],     [-104.0, 38.5],     [-100.0, 37.5],     [-97.0, 36.5],     [-94.0, 35.5],     [-91.0, 34.5],     [-87.0, 33.5],     [-84.3880, 33.7490],  # Atlanta ]  m4 = Map(center=[-102, 40], zoom=4) m4.add_basemap(\"CartoDB.DarkMatter\")  # Add route as arc m4.add_geojson(     {         \"type\": \"Feature\",         \"geometry\": {\"type\": \"LineString\", \"coordinates\": flight_route},     },     name=\"flight-path\",     paint={\"line-color\": \"#ff8800\", \"line-width\": 2, \"line-opacity\": 0.5}, )  m4.animate_along_route(     flight_route,     duration=6000,     loop=False,  # Play once     marker_color=\"#ff8800\",     show_trail=True,     trail_color=\"#ff8800\",     trail_width=3, ) m4 In\u00a0[\u00a0]: Copied! <pre># Two cars racing\nroute_1 = [[-122.4, 37.8], [-122.3, 37.7], [-122.2, 37.6], [-122.1, 37.5]]\n\nroute_2 = [[-122.4, 37.78], [-122.28, 37.68], [-122.18, 37.58], [-122.1, 37.5]]\n\nm5 = Map(center=[-122.25, 37.65], zoom=10)\n\nm5.animate_along_route(\n    route_1, duration=5000, loop=True, marker_color=\"#ff0000\", animation_id=\"car-red\"\n)\n\nm5.animate_along_route(\n    route_2,\n    duration=4500,  # Slightly faster\n    loop=True,\n    marker_color=\"#0000ff\",\n    animation_id=\"car-blue\",\n)\nm5\n</pre> # Two cars racing route_1 = [[-122.4, 37.8], [-122.3, 37.7], [-122.2, 37.6], [-122.1, 37.5]]  route_2 = [[-122.4, 37.78], [-122.28, 37.68], [-122.18, 37.58], [-122.1, 37.5]]  m5 = Map(center=[-122.25, 37.65], zoom=10)  m5.animate_along_route(     route_1, duration=5000, loop=True, marker_color=\"#ff0000\", animation_id=\"car-red\" )  m5.animate_along_route(     route_2,     duration=4500,  # Slightly faster     loop=True,     marker_color=\"#0000ff\",     animation_id=\"car-blue\", ) m5 In\u00a0[\u00a0]: Copied! <pre># Note: Animations may not work in static HTML export\n# The HTML export captures the map state at the time of export\nm.to_html(\"route_animation_example.html\")\n</pre> # Note: Animations may not work in static HTML export # The HTML export captures the map state at the time of export m.to_html(\"route_animation_example.html\")"},{"location":"maplibre/route_animation/#route-animation","title":"Route Animation\u00b6","text":"<p>This notebook demonstrates how to animate markers along a route. Great for visualizing GPS tracks, vehicle movements, or storytelling on maps.</p>"},{"location":"maplibre/route_animation/#basic-route-animation","title":"Basic Route Animation\u00b6","text":""},{"location":"maplibre/route_animation/#animation-with-trail","title":"Animation with Trail\u00b6","text":""},{"location":"maplibre/route_animation/#animation-controls","title":"Animation Controls\u00b6","text":""},{"location":"maplibre/route_animation/#non-looping-animation","title":"Non-Looping Animation\u00b6","text":""},{"location":"maplibre/route_animation/#multiple-simultaneous-animations","title":"Multiple Simultaneous Animations\u00b6","text":""},{"location":"maplibre/route_animation/#export-to-html","title":"Export to HTML\u00b6","text":""},{"location":"maplibre/search_control/","title":"Search control","text":"In\u00a0[\u00a0]: Copied! <pre># %pip install -U anymap-ts\n</pre> # %pip install -U anymap-ts In\u00a0[\u00a0]: Copied! <pre>from anymap_ts import Map\n\nm = Map(center=[-100, 40], zoom=4)\nm.add_search_control(position=\"top-left\")\nm\n</pre> from anymap_ts import Map  m = Map(center=[-100, 40], zoom=4) m.add_search_control(position=\"top-left\") m In\u00a0[\u00a0]: Copied! <pre>m2 = Map(center=[0, 20], zoom=2)\nm2.add_search_control(\n    position=\"top-left\",\n    placeholder=\"Find a location...\",\n    collapsed=False,\n    fly_to_zoom=12,\n    show_marker=True,\n)\nm2\n</pre> m2 = Map(center=[0, 20], zoom=2) m2.add_search_control(     position=\"top-left\",     placeholder=\"Find a location...\",     collapsed=False,     fly_to_zoom=12,     show_marker=True, ) m2 In\u00a0[\u00a0]: Copied! <pre>m.remove_search_control()\n</pre> m.remove_search_control()"},{"location":"maplibre/search_control/#search-control","title":"Search Control\u00b6","text":"<p>This notebook demonstrates how to add a search/geocoder control to MapLibre maps. The search control uses OpenStreetMap Nominatim for geocoding.</p>"},{"location":"maplibre/search_control/#basic-search-control","title":"Basic Search Control\u00b6","text":""},{"location":"maplibre/search_control/#expanded-search-with-custom-options","title":"Expanded Search with Custom Options\u00b6","text":""},{"location":"maplibre/search_control/#remove-search-control","title":"Remove Search Control\u00b6","text":""},{"location":"maplibre/sky_fog/","title":"Sky fog","text":"In\u00a0[\u00a0]: Copied! <pre># %pip install -U anymap-ts\n</pre> # %pip install -U anymap-ts In\u00a0[\u00a0]: Copied! <pre>from anymap_ts import Map\n\nm = Map(\n    center=[-122.4, 37.8],\n    zoom=12,\n    pitch=60,\n    bearing=-17,\n    style=\"https://tiles.openfreemap.org/styles/liberty\",\n)\nm.add_3d_terrain(exaggeration=1.5)\nm.set_sky()\nm\n</pre> from anymap_ts import Map  m = Map(     center=[-122.4, 37.8],     zoom=12,     pitch=60,     bearing=-17,     style=\"https://tiles.openfreemap.org/styles/liberty\", ) m.add_3d_terrain(exaggeration=1.5) m.set_sky() m In\u00a0[\u00a0]: Copied! <pre>m2 = Map(\n    center=[6.8652, 45.8326],\n    zoom=12,\n    pitch=70,\n    bearing=30,\n    style=\"https://tiles.openfreemap.org/styles/liberty\",\n)\nm2.add_3d_terrain(exaggeration=1.5)\nm2.set_sky(\n    sky_color=\"#1E90FF\",\n    horizon_color=\"#FFD700\",\n    fog_color=\"#FFFACD\",\n    sky_horizon_blend=0.4,\n    horizon_fog_blend=0.6,\n    fog_ground_blend=0.8,\n    atmosphere_blend=0.9,\n)\nm2\n</pre> m2 = Map(     center=[6.8652, 45.8326],     zoom=12,     pitch=70,     bearing=30,     style=\"https://tiles.openfreemap.org/styles/liberty\", ) m2.add_3d_terrain(exaggeration=1.5) m2.set_sky(     sky_color=\"#1E90FF\",     horizon_color=\"#FFD700\",     fog_color=\"#FFFACD\",     sky_horizon_blend=0.4,     horizon_fog_blend=0.6,     fog_ground_blend=0.8,     atmosphere_blend=0.9, ) m2 In\u00a0[\u00a0]: Copied! <pre>m3 = Map(\n    center=[-112.1129, 36.1069],\n    zoom=13,\n    pitch=65,\n    bearing=-45,\n    style=\"https://tiles.openfreemap.org/styles/liberty\",\n)\nm3.add_3d_terrain(exaggeration=1.5)\nm3.set_sky(\n    sky_color=\"#FF6347\",\n    horizon_color=\"#FF8C00\",\n    fog_color=\"#FFD700\",\n    sky_horizon_blend=0.3,\n    horizon_fog_blend=0.5,\n    fog_ground_blend=0.4,\n    atmosphere_blend=0.85,\n)\nm3\n</pre> m3 = Map(     center=[-112.1129, 36.1069],     zoom=13,     pitch=65,     bearing=-45,     style=\"https://tiles.openfreemap.org/styles/liberty\", ) m3.add_3d_terrain(exaggeration=1.5) m3.set_sky(     sky_color=\"#FF6347\",     horizon_color=\"#FF8C00\",     fog_color=\"#FFD700\",     sky_horizon_blend=0.3,     horizon_fog_blend=0.5,     fog_ground_blend=0.4,     atmosphere_blend=0.85, ) m3 In\u00a0[\u00a0]: Copied! <pre>m4 = Map(\n    center=[0, 20],\n    zoom=2,\n    pitch=0,\n    style=\"https://tiles.openfreemap.org/styles/liberty\",\n)\nm4.set_sky(\n    sky_color=\"#87CEEB\",\n    horizon_color=\"#B0E0E6\",\n    fog_color=\"#F0F8FF\",\n    atmosphere_blend=1.0,\n)\nm4\n</pre> m4 = Map(     center=[0, 20],     zoom=2,     pitch=0,     style=\"https://tiles.openfreemap.org/styles/liberty\", ) m4.set_sky(     sky_color=\"#87CEEB\",     horizon_color=\"#B0E0E6\",     fog_color=\"#F0F8FF\",     atmosphere_blend=1.0, ) m4 In\u00a0[\u00a0]: Copied! <pre>m.remove_sky()\n</pre> m.remove_sky() In\u00a0[\u00a0]: Copied! <pre>m2.to_html(\"sky_fog_example.html\")\n</pre> m2.to_html(\"sky_fog_example.html\")"},{"location":"maplibre/sky_fog/#sky-fog","title":"Sky &amp; Fog\u00b6","text":"<p>This notebook demonstrates how to add atmospheric sky and fog effects to MapLibre maps.</p> <p>MapLibre v5 unifies sky and fog into a single <code>map.setSky()</code> API. These effects work best with 3D terrain enabled.</p>"},{"location":"maplibre/sky_fog/#basic-sky-with-3d-terrain","title":"Basic Sky with 3D Terrain\u00b6","text":""},{"location":"maplibre/sky_fog/#custom-sky-colors","title":"Custom Sky Colors\u00b6","text":""},{"location":"maplibre/sky_fog/#sunset-effect","title":"Sunset Effect\u00b6","text":""},{"location":"maplibre/sky_fog/#globe-atmosphere-effect","title":"Globe Atmosphere Effect\u00b6","text":"<p>Set <code>atmosphere_blend</code> close to 1.0 for a globe-like atmosphere halo.</p>"},{"location":"maplibre/sky_fog/#remove-sky","title":"Remove Sky\u00b6","text":""},{"location":"maplibre/sky_fog/#export-to-html","title":"Export to HTML\u00b6","text":""},{"location":"maplibre/solara/","title":"Solara","text":"In\u00a0[\u00a0]: Copied! <pre>%pip install -U anymap-ts solara\n</pre> %pip install -U anymap-ts solara In\u00a0[\u00a0]: Copied! <pre>import solara\nfrom anymap_ts import MapLibreMap\n\n\nclass Map(MapLibreMap):\n    def __init__(self, **kwargs):\n        super().__init__(\n            center=[-117.592133766, 47.653004], zoom=15.3, height=\"700px\", *kwargs\n        )\n        super().add_basemap(\"Esri.WorldImagery\")\n\n\n@solara.component\ndef Page():\n    Map().element()\n\n\nPage()\n</pre> import solara from anymap_ts import MapLibreMap   class Map(MapLibreMap):     def __init__(self, **kwargs):         super().__init__(             center=[-117.592133766, 47.653004], zoom=15.3, height=\"700px\", *kwargs         )         super().add_basemap(\"Esri.WorldImagery\")   @solara.component def Page():     Map().element()   Page()"},{"location":"maplibre/solara/#solara-example","title":"Solara Example\u00b6","text":"<p>This example demonstrates how to use Solara to create a simple map.</p>"},{"location":"maplibre/split_map/","title":"Split map","text":"In\u00a0[\u00a0]: Copied! <pre># %pip install -U anymap-ts\n</pre> # %pip install -U anymap-ts In\u00a0[\u00a0]: Copied! <pre>from anymap_ts import Map\n\nm = Map(center=[-122.4194, 37.7749], zoom=12)\n\n# Add satellite imagery\nm.add_tile_layer(\n    \"https://mt1.google.com/vt/lyrs=s&amp;x={x}&amp;y={y}&amp;z={z}\",\n    name=\"satellite\",\n    attribution=\"Google\",\n)\n\n# Add OpenStreetMap\nm.add_tile_layer(\n    \"https://tile.openstreetmap.org/{z}/{x}/{y}.png\",\n    name=\"osm\",\n    attribution=\"OpenStreetMap contributors\",\n)\n\n# Enable split map\nm.add_split_map(\"satellite\", \"osm\")\nm\n</pre> from anymap_ts import Map  m = Map(center=[-122.4194, 37.7749], zoom=12)  # Add satellite imagery m.add_tile_layer(     \"https://mt1.google.com/vt/lyrs=s&amp;x={x}&amp;y={y}&amp;z={z}\",     name=\"satellite\",     attribution=\"Google\", )  # Add OpenStreetMap m.add_tile_layer(     \"https://tile.openstreetmap.org/{z}/{x}/{y}.png\",     name=\"osm\",     attribution=\"OpenStreetMap contributors\", )  # Enable split map m.add_split_map(\"satellite\", \"osm\") m In\u00a0[\u00a0]: Copied! <pre>m2 = Map(center=[-73.9857, 40.7484], zoom=13)\n\nm2.add_tile_layer(\n    \"https://mt1.google.com/vt/lyrs=s&amp;x={x}&amp;y={y}&amp;z={z}\",\n    name=\"satellite\",\n    attribution=\"Google\",\n)\n\nm2.add_tile_layer(\n    \"https://tile.openstreetmap.org/{z}/{x}/{y}.png\",\n    name=\"osm\",\n    attribution=\"OpenStreetMap contributors\",\n)\n\n# Start with the slider at 30%\nm2.add_split_map(\"satellite\", \"osm\", position=30)\nm2\n</pre> m2 = Map(center=[-73.9857, 40.7484], zoom=13)  m2.add_tile_layer(     \"https://mt1.google.com/vt/lyrs=s&amp;x={x}&amp;y={y}&amp;z={z}\",     name=\"satellite\",     attribution=\"Google\", )  m2.add_tile_layer(     \"https://tile.openstreetmap.org/{z}/{x}/{y}.png\",     name=\"osm\",     attribution=\"OpenStreetMap contributors\", )  # Start with the slider at 30% m2.add_split_map(\"satellite\", \"osm\", position=30) m2 In\u00a0[\u00a0]: Copied! <pre>m.remove_split_map()\n</pre> m.remove_split_map() In\u00a0[\u00a0]: Copied! <pre>m2.to_html(\"split_map_example.html\")\n</pre> m2.to_html(\"split_map_example.html\")"},{"location":"maplibre/split_map/#split-map-swipecompare","title":"Split Map (Swipe/Compare)\u00b6","text":"<p>This notebook demonstrates how to compare two map layers side-by-side with a draggable divider.</p> <p>The split map view uses two synced MapLibre map instances. The left side shows one layer and the right side shows another, with a draggable slider to control the split position.</p>"},{"location":"maplibre/split_map/#compare-satellite-and-openstreetmap","title":"Compare Satellite and OpenStreetMap\u00b6","text":""},{"location":"maplibre/split_map/#custom-split-position","title":"Custom Split Position\u00b6","text":"<p>Set the initial slider position (0-100).</p>"},{"location":"maplibre/split_map/#remove-split-map","title":"Remove Split Map\u00b6","text":"<p>Return to normal single-view mode.</p>"},{"location":"maplibre/split_map/#export-to-html","title":"Export to HTML\u00b6","text":""},{"location":"maplibre/style_switcher/","title":"Style switcher","text":"In\u00a0[\u00a0]: Copied! <pre># %pip install -U anymap-ts\n</pre> # %pip install -U anymap-ts In\u00a0[\u00a0]: Copied! <pre>from anymap_ts import Map\n\nm = Map(center=[-122.4, 37.8], zoom=10)\nm.add_style_switcher(\n    styles={\n        \"Light\": \"https://basemaps.cartocdn.com/gl/positron-gl-style/style.json\",\n        \"Dark\": \"https://basemaps.cartocdn.com/gl/dark-matter-gl-style/style.json\",\n        \"Voyager\": \"https://basemaps.cartocdn.com/gl/voyager-gl-style/style.json\",\n    },\n    position=\"top-right\",\n)\nm\n</pre> from anymap_ts import Map  m = Map(center=[-122.4, 37.8], zoom=10) m.add_style_switcher(     styles={         \"Light\": \"https://basemaps.cartocdn.com/gl/positron-gl-style/style.json\",         \"Dark\": \"https://basemaps.cartocdn.com/gl/dark-matter-gl-style/style.json\",         \"Voyager\": \"https://basemaps.cartocdn.com/gl/voyager-gl-style/style.json\",     },     position=\"top-right\", ) m In\u00a0[\u00a0]: Copied! <pre>m.remove_style_switcher()\n</pre> m.remove_style_switcher() In\u00a0[\u00a0]: Copied! <pre>m2 = Map(center=[-122.4, 37.8], zoom=10)\n\n# Add a satellite tile layer\nm2.add_tile_layer(\n    \"https://mt1.google.com/vt/lyrs=s&amp;x={x}&amp;y={y}&amp;z={z}\",\n    name=\"satellite\",\n    attribution=\"Google\",\n)\n\n# Add opacity slider for the satellite layer\nm2.add_opacity_slider(\"satellite\", label=\"Satellite Opacity\")\nm2\n</pre> m2 = Map(center=[-122.4, 37.8], zoom=10)  # Add a satellite tile layer m2.add_tile_layer(     \"https://mt1.google.com/vt/lyrs=s&amp;x={x}&amp;y={y}&amp;z={z}\",     name=\"satellite\",     attribution=\"Google\", )  # Add opacity slider for the satellite layer m2.add_opacity_slider(\"satellite\", label=\"Satellite Opacity\") m2 In\u00a0[\u00a0]: Copied! <pre>m3 = Map(center=[-122.4, 37.8], zoom=10)\n\nm3.add_tile_layer(\n    \"https://mt1.google.com/vt/lyrs=s&amp;x={x}&amp;y={y}&amp;z={z}\",\n    name=\"satellite\",\n    attribution=\"Google\",\n)\n\nm3.add_tile_layer(\n    \"https://tile.openstreetmap.org/{z}/{x}/{y}.png\",\n    name=\"osm\",\n    attribution=\"OpenStreetMap\",\n)\n\nm3.add_opacity_slider(\"satellite\", label=\"Satellite\")\nm3.add_opacity_slider(\"osm\", label=\"OSM\")\nm3\n</pre> m3 = Map(center=[-122.4, 37.8], zoom=10)  m3.add_tile_layer(     \"https://mt1.google.com/vt/lyrs=s&amp;x={x}&amp;y={y}&amp;z={z}\",     name=\"satellite\",     attribution=\"Google\", )  m3.add_tile_layer(     \"https://tile.openstreetmap.org/{z}/{x}/{y}.png\",     name=\"osm\",     attribution=\"OpenStreetMap\", )  m3.add_opacity_slider(\"satellite\", label=\"Satellite\") m3.add_opacity_slider(\"osm\", label=\"OSM\") m3 In\u00a0[\u00a0]: Copied! <pre>m3.remove_opacity_slider(\"satellite\")\n</pre> m3.remove_opacity_slider(\"satellite\")"},{"location":"maplibre/style_switcher/#style-switcher-opacity-slider","title":"Style Switcher &amp; Opacity Slider\u00b6","text":"<p>This notebook demonstrates:</p> <ul> <li>Style Switcher: A dropdown to switch between map styles</li> <li>Opacity Slider: A per-layer slider to adjust opacity</li> </ul>"},{"location":"maplibre/style_switcher/#style-switcher","title":"Style Switcher\u00b6","text":"<p>Add a dropdown control to switch between basemap styles.</p>"},{"location":"maplibre/style_switcher/#remove-style-switcher","title":"Remove Style Switcher\u00b6","text":""},{"location":"maplibre/style_switcher/#opacity-slider","title":"Opacity Slider\u00b6","text":"<p>Add a slider to control the opacity of a map layer.</p>"},{"location":"maplibre/style_switcher/#multiple-opacity-sliders","title":"Multiple Opacity Sliders\u00b6","text":""},{"location":"maplibre/style_switcher/#remove-opacity-slider","title":"Remove Opacity Slider\u00b6","text":""},{"location":"maplibre/terrain_3d/","title":"Terrain 3d","text":"In\u00a0[\u00a0]: Copied! <pre># %pip install -U anymap-ts\n</pre> # %pip install -U anymap-ts In\u00a0[\u00a0]: Copied! <pre>from anymap_ts import Map\n\n# Create a map with pitch to see 3D terrain\nm = Map(center=[-119.5, 37.7], zoom=11, pitch=60, bearing=30)  # Yosemite area\nm.add_basemap(\"Esri.WorldImagery\")\n\n# Enable 3D terrain with default settings\nm.add_3d_terrain()\nm\n</pre> from anymap_ts import Map  # Create a map with pitch to see 3D terrain m = Map(center=[-119.5, 37.7], zoom=11, pitch=60, bearing=30)  # Yosemite area m.add_basemap(\"Esri.WorldImagery\")  # Enable 3D terrain with default settings m.add_3d_terrain() m In\u00a0[\u00a0]: Copied! <pre># Create map with more dramatic terrain\nm2 = Map(center=[-105.8, 40.0], zoom=10, pitch=60, bearing=0)  # Rocky Mountains\n\n# Exaggerate terrain height by 1.5x\nm2.add_3d_terrain(exaggeration=1.5)\nm2\n</pre> # Create map with more dramatic terrain m2 = Map(center=[-105.8, 40.0], zoom=10, pitch=60, bearing=0)  # Rocky Mountains  # Exaggerate terrain height by 1.5x m2.add_3d_terrain(exaggeration=1.5) m2 In\u00a0[\u00a0]: Copied! <pre># Grand Canyon visualization\nm3 = Map(center=[-112.1, 36.1], zoom=12, pitch=70, bearing=45)\n\nm3.add_3d_terrain(exaggeration=1.2)\nm3\n</pre> # Grand Canyon visualization m3 = Map(center=[-112.1, 36.1], zoom=12, pitch=70, bearing=45)  m3.add_3d_terrain(exaggeration=1.2) m3 In\u00a0[\u00a0]: Copied! <pre># Mount Rainier\nm4 = Map(center=[-121.76, 46.85], zoom=11, pitch=65, bearing=-20)\n\nm4.add_basemap(\"Esri.WorldImagery\")\nm4.add_3d_terrain(exaggeration=1.3)\nm4\n</pre> # Mount Rainier m4 = Map(center=[-121.76, 46.85], zoom=11, pitch=65, bearing=-20)  m4.add_basemap(\"Esri.WorldImagery\") m4.add_3d_terrain(exaggeration=1.3) m4 In\u00a0[\u00a0]: Copied! <pre>m4.to_html(\"terrain_3d_example.html\")\n</pre> m4.to_html(\"terrain_3d_example.html\")"},{"location":"maplibre/terrain_3d/#3d-terrain-example","title":"3D Terrain Example\u00b6","text":"<p>This notebook demonstrates how to enable 3D terrain visualization using MapLibre's terrain capabilities.</p>"},{"location":"maplibre/terrain_3d/#basic-3d-terrain","title":"Basic 3D Terrain\u00b6","text":""},{"location":"maplibre/terrain_3d/#terrain-with-exaggeration","title":"Terrain with Exaggeration\u00b6","text":""},{"location":"maplibre/terrain_3d/#grand-canyon-view","title":"Grand Canyon View\u00b6","text":""},{"location":"maplibre/terrain_3d/#mount-rainier","title":"Mount Rainier\u00b6","text":""},{"location":"maplibre/terrain_3d/#export-to-html","title":"Export to HTML\u00b6","text":""},{"location":"maplibre/time_slider/","title":"Time slider","text":"In\u00a0[\u00a0]: Copied! <pre># %pip install -U anymap-ts\n</pre> # %pip install -U anymap-ts In\u00a0[\u00a0]: Copied! <pre>import random\n\nfrom anymap_ts import Map\n\n# Generate sample earthquake data with years\nrandom.seed(42)\nearthquakes = {\n    \"type\": \"FeatureCollection\",\n    \"features\": [\n        {\n            \"type\": \"Feature\",\n            \"geometry\": {\n                \"type\": \"Point\",\n                \"coordinates\": [\n                    -120 + random.gauss(0, 15),\n                    35 + random.gauss(0, 10),\n                ],\n            },\n            \"properties\": {\n                \"year\": random.randint(2000, 2024),\n                \"magnitude\": round(random.uniform(3.0, 8.0), 1),\n            },\n        }\n        for _ in range(200)\n    ],\n}\n\nm = Map(center=[-120, 35], zoom=3)\nm.add_geojson(earthquakes, name=\"quakes\", circle_radius=5, circle_color=\"#ff4444\")\nm.add_time_slider(\n    layer_id=\"quakes\",\n    property=\"year\",\n    min_value=2000,\n    max_value=2024,\n    step=1,\n    label=\"Year\",\n)\nm\n</pre> import random  from anymap_ts import Map  # Generate sample earthquake data with years random.seed(42) earthquakes = {     \"type\": \"FeatureCollection\",     \"features\": [         {             \"type\": \"Feature\",             \"geometry\": {                 \"type\": \"Point\",                 \"coordinates\": [                     -120 + random.gauss(0, 15),                     35 + random.gauss(0, 10),                 ],             },             \"properties\": {                 \"year\": random.randint(2000, 2024),                 \"magnitude\": round(random.uniform(3.0, 8.0), 1),             },         }         for _ in range(200)     ], }  m = Map(center=[-120, 35], zoom=3) m.add_geojson(earthquakes, name=\"quakes\", circle_radius=5, circle_color=\"#ff4444\") m.add_time_slider(     layer_id=\"quakes\",     property=\"year\",     min_value=2000,     max_value=2024,     step=1,     label=\"Year\", ) m In\u00a0[\u00a0]: Copied! <pre>m2 = Map(center=[-120, 35], zoom=3)\nm2.add_geojson(earthquakes, name=\"quakes\", circle_radius=5, circle_color=\"#ff8800\")\nm2.add_time_slider(\n    layer_id=\"quakes\",\n    property=\"year\",\n    min_value=2000,\n    max_value=2024,\n    step=1,\n    label=\"Year\",\n    auto_play=True,\n    interval=300,\n)\nm2\n</pre> m2 = Map(center=[-120, 35], zoom=3) m2.add_geojson(earthquakes, name=\"quakes\", circle_radius=5, circle_color=\"#ff8800\") m2.add_time_slider(     layer_id=\"quakes\",     property=\"year\",     min_value=2000,     max_value=2024,     step=1,     label=\"Year\",     auto_play=True,     interval=300, ) m2 In\u00a0[\u00a0]: Copied! <pre>m3 = Map(center=[-120, 35], zoom=3)\nm3.add_geojson(earthquakes, name=\"quakes\", circle_radius=5, circle_color=\"#cc00ff\")\nm3.add_time_slider(\n    layer_id=\"quakes\",\n    property=\"magnitude\",\n    min_value=3,\n    max_value=8,\n    step=0.5,\n    label=\"Max Magnitude\",\n)\nm3\n</pre> m3 = Map(center=[-120, 35], zoom=3) m3.add_geojson(earthquakes, name=\"quakes\", circle_radius=5, circle_color=\"#cc00ff\") m3.add_time_slider(     layer_id=\"quakes\",     property=\"magnitude\",     min_value=3,     max_value=8,     step=0.5,     label=\"Max Magnitude\", ) m3 In\u00a0[\u00a0]: Copied! <pre>m.remove_time_slider()\n</pre> m.remove_time_slider()"},{"location":"maplibre/time_slider/#time-slider","title":"Time Slider\u00b6","text":"<p>Filter map data by a temporal property using an interactive slider control.</p> <p>Features:</p> <ul> <li>Slider to filter data by numeric/temporal property</li> <li>Play/pause button for auto-animation</li> <li>Customizable range, step, and speed</li> </ul>"},{"location":"maplibre/time_slider/#basic-time-slider","title":"Basic Time Slider\u00b6","text":"<p>Filter earthquake data by year.</p>"},{"location":"maplibre/time_slider/#auto-playing-time-slider","title":"Auto-Playing Time Slider\u00b6","text":"<p>Set <code>auto_play=True</code> to automatically animate through time steps.</p>"},{"location":"maplibre/time_slider/#filter-by-magnitude","title":"Filter by Magnitude\u00b6","text":""},{"location":"maplibre/time_slider/#remove-time-slider","title":"Remove Time Slider\u00b6","text":""},{"location":"maplibre/to_html/","title":"To html","text":"In\u00a0[\u00a0]: Copied! <pre># %pip install -U anymap-ts\n</pre> # %pip install -U anymap-ts In\u00a0[\u00a0]: Copied! <pre>from anymap_ts import MapLibreMap\n\nm = MapLibreMap(center=[-98, 38.5], zoom=4)\nm.add_basemap(\"Esri.WorldImagery\")\ngeojson_data = {\n    \"type\": \"FeatureCollection\",\n    \"features\": [\n        # Points - Landmarks\n        {\n            \"type\": \"Feature\",\n            \"geometry\": {\"type\": \"Point\", \"coordinates\": [-122.4194, 37.7749]},\n            \"properties\": {\"name\": \"San Francisco City Hall\", \"type\": \"landmark\"},\n        },\n        {\n            \"type\": \"Feature\",\n            \"geometry\": {\"type\": \"Point\", \"coordinates\": [-122.4862, 37.8199]},\n            \"properties\": {\"name\": \"Golden Gate Bridge\", \"type\": \"landmark\"},\n        },\n        # LineStrings - Routes\n        {\n            \"type\": \"Feature\",\n            \"geometry\": {\n                \"type\": \"LineString\",\n                \"coordinates\": [\n                    [-122.4194, 37.7749],\n                    [-122.4100, 37.7855],\n                    [-122.3894, 37.7866],\n                ],\n            },\n            \"properties\": {\"name\": \"Market Street Route\", \"type\": \"route\"},\n        },\n        # Polygons - Neighborhoods\n        {\n            \"type\": \"Feature\",\n            \"geometry\": {\n                \"type\": \"Polygon\",\n                \"coordinates\": [\n                    [\n                        [-122.415, 37.795],\n                        [-122.395, 37.795],\n                        [-122.395, 37.780],\n                        [-122.415, 37.780],\n                        [-122.415, 37.795],\n                    ]\n                ],\n            },\n            \"properties\": {\n                \"name\": \"Downtown\",\n                \"type\": \"neighborhood\",\n                \"elevation\": 500,\n            },\n        },\n    ],\n}\nm.add_geojson(geojson_data)\nm.to_html(\"map.html\")\nm\n</pre> from anymap_ts import MapLibreMap  m = MapLibreMap(center=[-98, 38.5], zoom=4) m.add_basemap(\"Esri.WorldImagery\") geojson_data = {     \"type\": \"FeatureCollection\",     \"features\": [         # Points - Landmarks         {             \"type\": \"Feature\",             \"geometry\": {\"type\": \"Point\", \"coordinates\": [-122.4194, 37.7749]},             \"properties\": {\"name\": \"San Francisco City Hall\", \"type\": \"landmark\"},         },         {             \"type\": \"Feature\",             \"geometry\": {\"type\": \"Point\", \"coordinates\": [-122.4862, 37.8199]},             \"properties\": {\"name\": \"Golden Gate Bridge\", \"type\": \"landmark\"},         },         # LineStrings - Routes         {             \"type\": \"Feature\",             \"geometry\": {                 \"type\": \"LineString\",                 \"coordinates\": [                     [-122.4194, 37.7749],                     [-122.4100, 37.7855],                     [-122.3894, 37.7866],                 ],             },             \"properties\": {\"name\": \"Market Street Route\", \"type\": \"route\"},         },         # Polygons - Neighborhoods         {             \"type\": \"Feature\",             \"geometry\": {                 \"type\": \"Polygon\",                 \"coordinates\": [                     [                         [-122.415, 37.795],                         [-122.395, 37.795],                         [-122.395, 37.780],                         [-122.415, 37.780],                         [-122.415, 37.795],                     ]                 ],             },             \"properties\": {                 \"name\": \"Downtown\",                 \"type\": \"neighborhood\",                 \"elevation\": 500,             },         },     ], } m.add_geojson(geojson_data) m.to_html(\"map.html\") m In\u00a0[\u00a0]: Copied! <pre>from anymap_ts import Map\n\nm = Map(center=[-98, 38.5], zoom=4)\n\n# Add a single marker with popup and tooltip\nm.add_marker(-122.4, 37.8, popup=\"San Francisco\", tooltip=\"Hover me!\", color=\"#0000ff\")\n\n# Add multiple markers from a list of dictionaries\ncities = [\n    {\"name\": \"New York\", \"lng\": -74.0, \"lat\": 40.7},\n    {\"name\": \"Chicago\", \"lng\": -87.6, \"lat\": 41.9},\n    {\"name\": \"Los Angeles\", \"lng\": -118.2, \"lat\": 34.1},\n    {\"name\": \"Seattle\", \"lng\": -122.3, \"lat\": 47.6},\n]\nm.add_markers(cities, popup_column=\"name\", color=\"#ff6600\")\n\n# Add a legend\nm.add_legend(\n    title=\"Land Cover\",\n    labels=[\"Forest\", \"Water\", \"Urban\"],\n    colors=[\"#228822\", \"#0000FF\", \"#808080\"],\n    position=\"bottom-right\",\n)\n\n# Export to HTML - markers and legend will be preserved\nm.to_html(\"markers_legend.html\")\nm\n</pre> from anymap_ts import Map  m = Map(center=[-98, 38.5], zoom=4)  # Add a single marker with popup and tooltip m.add_marker(-122.4, 37.8, popup=\"San Francisco\", tooltip=\"Hover me!\", color=\"#0000ff\")  # Add multiple markers from a list of dictionaries cities = [     {\"name\": \"New York\", \"lng\": -74.0, \"lat\": 40.7},     {\"name\": \"Chicago\", \"lng\": -87.6, \"lat\": 41.9},     {\"name\": \"Los Angeles\", \"lng\": -118.2, \"lat\": 34.1},     {\"name\": \"Seattle\", \"lng\": -122.3, \"lat\": 47.6}, ] m.add_markers(cities, popup_column=\"name\", color=\"#ff6600\")  # Add a legend m.add_legend(     title=\"Land Cover\",     labels=[\"Forest\", \"Water\", \"Urban\"],     colors=[\"#228822\", \"#0000FF\", \"#808080\"],     position=\"bottom-right\", )  # Export to HTML - markers and legend will be preserved m.to_html(\"markers_legend.html\") m"},{"location":"maplibre/to_html/#to-html","title":"To HTML\u00b6","text":"<p>This notebook demonstrates the <code>to_html()</code> method, which renders the map as an HTML file.</p>"},{"location":"maplibre/to_html/#all-default-controls","title":"All Default Controls\u00b6","text":"<p>Add all 26 controls with a single call. The grid dimensions are auto-calculated.</p>"},{"location":"maplibre/to_html/#markers-and-legend","title":"Markers and Legend\u00b6","text":"<p>Add multiple markers and a legend to the map, then export to HTML.</p>"},{"location":"maplibre/tooltip/","title":"Tooltip","text":"In\u00a0[\u00a0]: Copied! <pre># %pip install -U anymap-ts\n</pre> # %pip install -U anymap-ts In\u00a0[\u00a0]: Copied! <pre>from anymap_ts import Map\n\ngeojson = {\n    \"type\": \"FeatureCollection\",\n    \"features\": [\n        {\n            \"type\": \"Feature\",\n            \"geometry\": {\"type\": \"Point\", \"coordinates\": [-122.4, 37.8]},\n            \"properties\": {\"name\": \"San Francisco\", \"pop\": 870000, \"state\": \"CA\"},\n        },\n        {\n            \"type\": \"Feature\",\n            \"geometry\": {\"type\": \"Point\", \"coordinates\": [-118.2, 34.1]},\n            \"properties\": {\"name\": \"Los Angeles\", \"pop\": 3900000, \"state\": \"CA\"},\n        },\n        {\n            \"type\": \"Feature\",\n            \"geometry\": {\"type\": \"Point\", \"coordinates\": [-73.9, 40.7]},\n            \"properties\": {\"name\": \"New York\", \"pop\": 8300000, \"state\": \"NY\"},\n        },\n    ],\n}\n\nm = Map(center=[-98, 38], zoom=3)\nm.add_geojson(geojson, name=\"cities\", circle_radius=8, circle_color=\"#ff6600\")\nm.add_tooltip(\"cities\", template=\"&lt;b&gt;{name}&lt;/b&gt;&lt;br&gt;Population: {pop}&lt;br&gt;State: {state}\")\nm\n</pre> from anymap_ts import Map  geojson = {     \"type\": \"FeatureCollection\",     \"features\": [         {             \"type\": \"Feature\",             \"geometry\": {\"type\": \"Point\", \"coordinates\": [-122.4, 37.8]},             \"properties\": {\"name\": \"San Francisco\", \"pop\": 870000, \"state\": \"CA\"},         },         {             \"type\": \"Feature\",             \"geometry\": {\"type\": \"Point\", \"coordinates\": [-118.2, 34.1]},             \"properties\": {\"name\": \"Los Angeles\", \"pop\": 3900000, \"state\": \"CA\"},         },         {             \"type\": \"Feature\",             \"geometry\": {\"type\": \"Point\", \"coordinates\": [-73.9, 40.7]},             \"properties\": {\"name\": \"New York\", \"pop\": 8300000, \"state\": \"NY\"},         },     ], }  m = Map(center=[-98, 38], zoom=3) m.add_geojson(geojson, name=\"cities\", circle_radius=8, circle_color=\"#ff6600\") m.add_tooltip(\"cities\", template=\"{name}Population: {pop}State: {state}\") m In\u00a0[\u00a0]: Copied! <pre>m2 = Map(center=[-98, 38], zoom=3)\nm2.add_geojson(geojson, name=\"cities\", circle_radius=8, circle_color=\"#0088ff\")\nm2.add_tooltip(\"cities\", properties=[\"name\", \"pop\"])\nm2\n</pre> m2 = Map(center=[-98, 38], zoom=3) m2.add_geojson(geojson, name=\"cities\", circle_radius=8, circle_color=\"#0088ff\") m2.add_tooltip(\"cities\", properties=[\"name\", \"pop\"]) m2 In\u00a0[\u00a0]: Copied! <pre>m3 = Map(center=[-98, 38], zoom=3)\nm3.add_geojson(geojson, name=\"cities\", circle_radius=8, circle_color=\"#00cc66\")\nm3.add_tooltip(\"cities\")\nm3\n</pre> m3 = Map(center=[-98, 38], zoom=3) m3.add_geojson(geojson, name=\"cities\", circle_radius=8, circle_color=\"#00cc66\") m3.add_tooltip(\"cities\") m3 In\u00a0[\u00a0]: Copied! <pre>m3.remove_tooltip(\"cities\")\n</pre> m3.remove_tooltip(\"cities\") In\u00a0[\u00a0]: Copied! <pre>m4 = Map(center=[-122.4, 37.8], zoom=10)\nm4.add_basemap(\"OpenStreetMap\")\nm4.add_coordinates_control(position=\"bottom-left\", precision=4)\nm4\n</pre> m4 = Map(center=[-122.4, 37.8], zoom=10) m4.add_basemap(\"OpenStreetMap\") m4.add_coordinates_control(position=\"bottom-left\", precision=4) m4 In\u00a0[\u00a0]: Copied! <pre>m5 = Map(center=[-122.4, 37.8], zoom=15)\nm5.add_basemap(\"OpenStreetMap\")\nm5.add_coordinates_control(position=\"bottom-right\", precision=6)\nm5\n</pre> m5 = Map(center=[-122.4, 37.8], zoom=15) m5.add_basemap(\"OpenStreetMap\") m5.add_coordinates_control(position=\"bottom-right\", precision=6) m5 In\u00a0[\u00a0]: Copied! <pre>m5.remove_coordinates_control()\n</pre> m5.remove_coordinates_control()"},{"location":"maplibre/tooltip/#tooltip-coordinates-control","title":"Tooltip &amp; Coordinates Control\u00b6","text":"<p>This notebook demonstrates:</p> <ul> <li>Tooltips: Show formatted information on feature hover</li> <li>Coordinates Control: Display cursor lat/lng position</li> </ul>"},{"location":"maplibre/tooltip/#tooltip-with-template","title":"Tooltip with Template\u00b6","text":"<p>Use <code>{property}</code> placeholders to format tooltip content.</p>"},{"location":"maplibre/tooltip/#tooltip-with-selected-properties","title":"Tooltip with Selected Properties\u00b6","text":"<p>Show only specific properties in the tooltip.</p>"},{"location":"maplibre/tooltip/#tooltip-showing-all-properties","title":"Tooltip Showing All Properties\u00b6","text":"<p>When no template or properties are specified, all feature properties are displayed.</p>"},{"location":"maplibre/tooltip/#remove-tooltip","title":"Remove Tooltip\u00b6","text":""},{"location":"maplibre/tooltip/#coordinates-control","title":"Coordinates Control\u00b6","text":"<p>Display the cursor's latitude and longitude as you move the mouse.</p>"},{"location":"maplibre/tooltip/#high-precision-coordinates","title":"High-Precision Coordinates\u00b6","text":""},{"location":"maplibre/tooltip/#remove-coordinates-control","title":"Remove Coordinates Control\u00b6","text":""},{"location":"maplibre/ui_controls/","title":"Ui controls","text":"In\u00a0[\u00a0]: Copied! <pre># %pip install -U anymap-ts\n</pre> # %pip install -U anymap-ts In\u00a0[\u00a0]: Copied! <pre>from anymap_ts import MapLibreMap\n</pre> from anymap_ts import MapLibreMap In\u00a0[\u00a0]: Copied! <pre>m = MapLibreMap(center=[11.25, 43.77], zoom=12)\nm.add_pmtiles_control(\n    position=\"top-right\",\n    collapsed=False,\n    default_url=\"https://pmtiles.io/protomaps(vector)ODbL_firenze.pmtiles\",\n    load_default_url=True,\n)\nm\n</pre> m = MapLibreMap(center=[11.25, 43.77], zoom=12) m.add_pmtiles_control(     position=\"top-right\",     collapsed=False,     default_url=\"https://pmtiles.io/protomaps(vector)ODbL_firenze.pmtiles\",     load_default_url=True, ) m In\u00a0[\u00a0]: Copied! <pre>m = MapLibreMap(center=[-120, 37], zoom=6)\nm.add_cog_control(position=\"top-right\", collapsed=False, default_colormap=\"viridis\")\nm\n</pre> m = MapLibreMap(center=[-120, 37], zoom=6) m.add_cog_control(position=\"top-right\", collapsed=False, default_colormap=\"viridis\") m In\u00a0[\u00a0]: Copied! <pre>m = MapLibreMap(center=[0, 20], zoom=2)\nm.add_zarr_control(position=\"top-right\", collapsed=False)\nm\n</pre> m = MapLibreMap(center=[0, 20], zoom=2) m.add_zarr_control(position=\"top-right\", collapsed=False) m In\u00a0[\u00a0]: Copied! <pre>m = MapLibreMap(center=[0, 20], zoom=2)\nm.add_vector_control(\n    position=\"top-right\",\n    collapsed=False,\n    default_url=\"https://raw.githubusercontent.com/datasets/geo-countries/master/data/countries.geojson\",\n    default_fill_color=\"#3388ff\",\n    default_stroke_color=\"#2266cc\",\n)\nm\n</pre> m = MapLibreMap(center=[0, 20], zoom=2) m.add_vector_control(     position=\"top-right\",     collapsed=False,     default_url=\"https://raw.githubusercontent.com/datasets/geo-countries/master/data/countries.geojson\",     default_fill_color=\"#3388ff\",     default_stroke_color=\"#2266cc\", ) m In\u00a0[\u00a0]: Copied! <pre>m = MapLibreMap(center=[0, 20], zoom=2)\nm.add_pmtiles_control(position=\"top-right\", collapsed=True)\nm.add_cog_control(position=\"top-right\", collapsed=True)\nm.add_zarr_control(position=\"top-right\", collapsed=True)\nm.add_vector_control(position=\"top-right\", collapsed=True)\nm\n</pre> m = MapLibreMap(center=[0, 20], zoom=2) m.add_pmtiles_control(position=\"top-right\", collapsed=True) m.add_cog_control(position=\"top-right\", collapsed=True) m.add_zarr_control(position=\"top-right\", collapsed=True) m.add_vector_control(position=\"top-right\", collapsed=True) m"},{"location":"maplibre/ui_controls/#ui-controls-for-maplibre","title":"UI Controls for MapLibre\u00b6","text":"<p>This notebook demonstrates the UI controls for loading various data formats:</p> <ul> <li>PMTiles</li> <li>COG (Cloud Optimized GeoTIFF)</li> <li>Zarr</li> <li>Vector (GeoJSON, GeoParquet, FlatGeobuf)</li> </ul>"},{"location":"maplibre/ui_controls/#pmtiles-control","title":"PMTiles Control\u00b6","text":"<p>Load PMTiles vector or raster tiles via an interactive UI panel.</p>"},{"location":"maplibre/ui_controls/#cog-control","title":"COG Control\u00b6","text":"<p>Load Cloud Optimized GeoTIFF files via an interactive UI panel with colormap selection.</p>"},{"location":"maplibre/ui_controls/#zarr-control","title":"Zarr Control\u00b6","text":"<p>Load Zarr pyramid datasets via an interactive UI panel.</p>"},{"location":"maplibre/ui_controls/#vector-control","title":"Vector Control\u00b6","text":"<p>Load vector datasets (GeoJSON, GeoParquet, FlatGeobuf) via URL.</p>"},{"location":"maplibre/ui_controls/#all-controls-together","title":"All Controls Together\u00b6","text":"<p>You can add multiple controls to the same map.</p>"},{"location":"maplibre/video_layer/","title":"Video layer","text":"In\u00a0[\u00a0]: Copied! <pre># %pip install -U anymap-ts\n</pre> # %pip install -U anymap-ts In\u00a0[\u00a0]: Copied! <pre>from anymap_ts import Map\n\nm = Map(\n    center=[-122.514426, 37.562984],\n    zoom=17,\n    bearing=-96,\n)\nm.add_basemap(\"Esri.WorldImagery\")\nm.add_video_layer(\n    urls=[\n        \"https://static-assets.mapbox.com/mapbox-gl-js/drone.mp4\",\n        \"https://static-assets.mapbox.com/mapbox-gl-js/drone.webm\",\n    ],\n    coordinates=[\n        [-122.51596391658498, 37.56238816766053],\n        [-122.51467645489949, 37.56410183312965],\n        [-122.51309394645498, 37.563391708549425],\n        [-122.51423120498498, 37.56161849366671],\n    ],\n    name=\"drone-video\",\n    opacity=0.9,\n)\nm\n</pre> from anymap_ts import Map  m = Map(     center=[-122.514426, 37.562984],     zoom=17,     bearing=-96, ) m.add_basemap(\"Esri.WorldImagery\") m.add_video_layer(     urls=[         \"https://static-assets.mapbox.com/mapbox-gl-js/drone.mp4\",         \"https://static-assets.mapbox.com/mapbox-gl-js/drone.webm\",     ],     coordinates=[         [-122.51596391658498, 37.56238816766053],         [-122.51467645489949, 37.56410183312965],         [-122.51309394645498, 37.563391708549425],         [-122.51423120498498, 37.56161849366671],     ],     name=\"drone-video\",     opacity=0.9, ) m In\u00a0[\u00a0]: Copied! <pre># Pause the video\nm.pause_video(\"drone-video\")\n</pre> # Pause the video m.pause_video(\"drone-video\") In\u00a0[\u00a0]: Copied! <pre># Seek to 5 seconds\nm.seek_video(\"drone-video\", 5)\n</pre> # Seek to 5 seconds m.seek_video(\"drone-video\", 5) In\u00a0[\u00a0]: Copied! <pre># Resume playing\nm.play_video(\"drone-video\")\n</pre> # Resume playing m.play_video(\"drone-video\") In\u00a0[\u00a0]: Copied! <pre>m.remove_video_layer(\"drone-video\")\n</pre> m.remove_video_layer(\"drone-video\") In\u00a0[\u00a0]: Copied! <pre># Create a new map with the video layer for export\nm2 = Map(\n    center=[-122.514426, 37.562984],\n    zoom=17,\n    bearing=-96,\n)\nm2.add_video_layer(\n    urls=[\n        \"https://static-assets.mapbox.com/mapbox-gl-js/drone.mp4\",\n        \"https://static-assets.mapbox.com/mapbox-gl-js/drone.webm\",\n    ],\n    coordinates=[\n        [-122.51596391658498, 37.56238816766053],\n        [-122.51467645489949, 37.56410183312965],\n        [-122.51309394645498, 37.563391708549425],\n        [-122.51423120498498, 37.56161849366671],\n    ],\n    name=\"drone-video\",\n)\nm2.to_html(\"video_layer_example.html\")\n</pre> # Create a new map with the video layer for export m2 = Map(     center=[-122.514426, 37.562984],     zoom=17,     bearing=-96, ) m2.add_video_layer(     urls=[         \"https://static-assets.mapbox.com/mapbox-gl-js/drone.mp4\",         \"https://static-assets.mapbox.com/mapbox-gl-js/drone.webm\",     ],     coordinates=[         [-122.51596391658498, 37.56238816766053],         [-122.51467645489949, 37.56410183312965],         [-122.51309394645498, 37.563391708549425],         [-122.51423120498498, 37.56161849366671],     ],     name=\"drone-video\", ) m2.to_html(\"video_layer_example.html\")"},{"location":"maplibre/video_layer/#video-layer","title":"Video Layer\u00b6","text":"<p>This notebook demonstrates how to overlay georeferenced video on a MapLibre map.</p> <p>Video layers use MapLibre's native <code>video</code> source type, which displays a video at specified geographic coordinates.</p>"},{"location":"maplibre/video_layer/#add-a-video-layer","title":"Add a Video Layer\u00b6","text":"<p>Overlay a drone video on the map at specified geographic coordinates.</p>"},{"location":"maplibre/video_layer/#playback-controls","title":"Playback Controls\u00b6","text":"<p>Control video playback programmatically.</p>"},{"location":"maplibre/video_layer/#remove-video-layer","title":"Remove Video Layer\u00b6","text":""},{"location":"maplibre/video_layer/#export-to-html","title":"Export to HTML\u00b6","text":""},{"location":"maplibre/zarr_layer/","title":"Zarr layer","text":"In\u00a0[\u00a0]: Copied! <pre># %pip install -U anymap-ts\n</pre> # %pip install -U anymap-ts In\u00a0[\u00a0]: Copied! <pre>from anymap_ts import Map\n\n# CarbonPlan 4D climate pyramid (v2, temp/precip by month)\nZARR_URL = (\n    \"https://carbonplan-maps.s3.us-west-2.amazonaws.com/v2/demo/4d/tavg-prec-month\"\n)\n\n# Create a MapLibre map\nm = Map(center=[-100, 40], zoom=3, style=\"dark-matter\")\n\n# Add the Zarr layer with precipitation data for January\n# Note: This dataset uses 'x' and 'y' instead of 'lon' and 'lat'\nm.add_zarr_layer(\n    url=ZARR_URL,\n    variable=\"climate\",\n    name=\"climate-prec\",\n    clim=(0, 300),  # Precipitation range\n    colormap=[\n        \"#f7fbff\",\n        \"#deebf7\",\n        \"#c6dbef\",\n        \"#9ecae1\",\n        \"#6baed6\",\n        \"#4292c6\",\n        \"#2171b5\",\n        \"#08519c\",\n        \"#08306b\",\n    ],  # Blues\n    opacity=0.8,\n    selector={\"band\": \"prec\", \"month\": 1},  # January precipitation\n    spatial_dimensions={\"lat\": \"y\", \"lon\": \"x\"},  # Custom dimension names\n    zarr_version=2,\n)\n\nm\n</pre> from anymap_ts import Map  # CarbonPlan 4D climate pyramid (v2, temp/precip by month) ZARR_URL = (     \"https://carbonplan-maps.s3.us-west-2.amazonaws.com/v2/demo/4d/tavg-prec-month\" )  # Create a MapLibre map m = Map(center=[-100, 40], zoom=3, style=\"dark-matter\")  # Add the Zarr layer with precipitation data for January # Note: This dataset uses 'x' and 'y' instead of 'lon' and 'lat' m.add_zarr_layer(     url=ZARR_URL,     variable=\"climate\",     name=\"climate-prec\",     clim=(0, 300),  # Precipitation range     colormap=[         \"#f7fbff\",         \"#deebf7\",         \"#c6dbef\",         \"#9ecae1\",         \"#6baed6\",         \"#4292c6\",         \"#2171b5\",         \"#08519c\",         \"#08306b\",     ],  # Blues     opacity=0.8,     selector={\"band\": \"prec\", \"month\": 1},  # January precipitation     spatial_dimensions={\"lat\": \"y\", \"lon\": \"x\"},  # Custom dimension names     zarr_version=2, )  m In\u00a0[\u00a0]: Copied! <pre># Update to show July precipitation\nm.update_zarr_layer(\n    layer_id=\"climate-prec\",\n    selector={\"band\": \"prec\", \"month\": 7},  # July\n)\n</pre> # Update to show July precipitation m.update_zarr_layer(     layer_id=\"climate-prec\",     selector={\"band\": \"prec\", \"month\": 7},  # July ) In\u00a0[\u00a0]: Copied! <pre># Switch to temperature data with a warm colormap\nm.update_zarr_layer(\n    layer_id=\"climate-prec\",\n    selector={\"band\": \"tavg\", \"month\": 7},  # July temperature\n    clim=(-20, 30),  # Temperature range in Celsius\n    colormap=[\n        \"#313695\",\n        \"#4575b4\",\n        \"#74add1\",\n        \"#abd9e9\",\n        \"#e0f3f8\",\n        \"#ffffbf\",\n        \"#fee090\",\n        \"#fdae61\",\n        \"#f46d43\",\n        \"#d73027\",\n        \"#a50026\",\n    ],\n)\n</pre> # Switch to temperature data with a warm colormap m.update_zarr_layer(     layer_id=\"climate-prec\",     selector={\"band\": \"tavg\", \"month\": 7},  # July temperature     clim=(-20, 30),  # Temperature range in Celsius     colormap=[         \"#313695\",         \"#4575b4\",         \"#74add1\",         \"#abd9e9\",         \"#e0f3f8\",         \"#ffffbf\",         \"#fee090\",         \"#fdae61\",         \"#f46d43\",         \"#d73027\",         \"#a50026\",     ], ) In\u00a0[\u00a0]: Copied! <pre>from anymap_ts import Map\n\n# Ocean temperature (v3 pyramid, EPSG:3857)\nOCEAN_URL = \"https://atlantis-vis-o.s3-ext.jc.rl.ac.uk/noc-npd-era5-demo/npd-eorca1-era5v1/gn/T1y/tos_con\"\n\nm2 = Map(center=[0, 30], zoom=2, style=\"dark-matter\")\n\nm2.add_zarr_layer(\n    url=OCEAN_URL,\n    variable=\"tos_con\",\n    name=\"ocean-temp\",\n    clim=(0, 50),\n    colormap=[\n        \"#000004\",\n        \"#1b0c41\",\n        \"#4a0c6b\",\n        \"#781c6d\",\n        \"#a52c60\",\n        \"#cf4446\",\n        \"#ed6925\",\n        \"#fb9b06\",\n        \"#f7d13d\",\n        \"#fcffa4\",\n    ],  # Inferno\n    opacity=0.9,\n    selector={\"time\": 0},\n)\n\nm2\n</pre> from anymap_ts import Map  # Ocean temperature (v3 pyramid, EPSG:3857) OCEAN_URL = \"https://atlantis-vis-o.s3-ext.jc.rl.ac.uk/noc-npd-era5-demo/npd-eorca1-era5v1/gn/T1y/tos_con\"  m2 = Map(center=[0, 30], zoom=2, style=\"dark-matter\")  m2.add_zarr_layer(     url=OCEAN_URL,     variable=\"tos_con\",     name=\"ocean-temp\",     clim=(0, 50),     colormap=[         \"#000004\",         \"#1b0c41\",         \"#4a0c6b\",         \"#781c6d\",         \"#a52c60\",         \"#cf4446\",         \"#ed6925\",         \"#fb9b06\",         \"#f7d13d\",         \"#fcffa4\",     ],  # Inferno     opacity=0.9,     selector={\"time\": 0}, )  m2 In\u00a0[\u00a0]: Copied! <pre>from anymap_ts import Map\n\n# Burn Probability over CONUS (30m resolution, Zarr v3)\nBURN_URL = \"https://carbonplan-share.s3.us-west-2.amazonaws.com/zarr-layer-examples/13-lvl-30m-4326-scott-BP.zarr\"\n\nm3 = Map(center=[-98, 39], zoom=4, style=\"dark-matter\")\n\n# Note: This dataset uses \"latitude\"/\"longitude\" dimension names (not \"lat\"/\"lon\")\n# The library will read bounds from the coordinate arrays automatically\nm3.add_zarr_layer(\n    url=BURN_URL,\n    variable=\"BP\",\n    name=\"burn-prob\",\n    clim=(0, 0.13),\n    colormap=[\n        \"#000004\",\n        \"#1b0c41\",\n        \"#4a0c6b\",\n        \"#781c6d\",\n        \"#a52c60\",\n        \"#cf4446\",\n        \"#ed6925\",\n        \"#fb9b06\",\n        \"#f7d13d\",\n        \"#fcffa4\",\n    ],  # Inferno/Fire\n    opacity=0.9,\n    spatial_dimensions={\n        \"lat\": \"latitude\",\n        \"lon\": \"longitude\",\n    },  # Custom dimension names\n    zarr_version=3,\n)\n\nm3\n</pre> from anymap_ts import Map  # Burn Probability over CONUS (30m resolution, Zarr v3) BURN_URL = \"https://carbonplan-share.s3.us-west-2.amazonaws.com/zarr-layer-examples/13-lvl-30m-4326-scott-BP.zarr\"  m3 = Map(center=[-98, 39], zoom=4, style=\"dark-matter\")  # Note: This dataset uses \"latitude\"/\"longitude\" dimension names (not \"lat\"/\"lon\") # The library will read bounds from the coordinate arrays automatically m3.add_zarr_layer(     url=BURN_URL,     variable=\"BP\",     name=\"burn-prob\",     clim=(0, 0.13),     colormap=[         \"#000004\",         \"#1b0c41\",         \"#4a0c6b\",         \"#781c6d\",         \"#a52c60\",         \"#cf4446\",         \"#ed6925\",         \"#fb9b06\",         \"#f7d13d\",         \"#fcffa4\",     ],  # Inferno/Fire     opacity=0.9,     spatial_dimensions={         \"lat\": \"latitude\",         \"lon\": \"longitude\",     },  # Custom dimension names     zarr_version=3, )  m3 In\u00a0[\u00a0]: Copied! <pre># Remove a zarr layer\nm.remove_zarr_layer(\"climate-prec\")\n</pre> # Remove a zarr layer m.remove_zarr_layer(\"climate-prec\")"},{"location":"maplibre/zarr_layer/#zarr-layer-example","title":"Zarr Layer Example\u00b6","text":"<p>This notebook demonstrates how to visualize Zarr datasets using the @carbonplan/zarr-layer package.</p> <p>The Zarr layer provides GPU-accelerated rendering with support for:</p> <ul> <li>Zarr v2 and v3 formats via zarrita.js</li> <li>EPSG:4326 and EPSG:3857 projections</li> <li>Globe and mercator projections</li> <li>Multi-dimensional data with selectors</li> <li>Dynamic updates (colormap, clim, selector)</li> </ul>"},{"location":"maplibre/zarr_layer/#basic-example-4d-climate-pyramid","title":"Basic Example: 4D Climate Pyramid\u00b6","text":"<p>Add a Zarr layer using the CarbonPlan 4D climate pyramid dataset with temperature and precipitation by month.</p>"},{"location":"maplibre/zarr_layer/#update-layer-properties","title":"Update Layer Properties\u00b6","text":"<p>You can dynamically update layer properties like selector, colormap, and clim without recreating the layer.</p>"},{"location":"maplibre/zarr_layer/#ocean-temperature-zarr-v3","title":"Ocean Temperature (Zarr v3)\u00b6","text":"<p>This example uses a Zarr v3 pyramid dataset with ocean temperature data.</p>"},{"location":"maplibre/zarr_layer/#burn-probability-over-conus","title":"Burn Probability over CONUS\u00b6","text":"<p>This example uses a high-resolution (30m) Zarr v3 dataset showing wildfire burn probability.</p>"},{"location":"maplibre/zarr_layer/#configuration-options","title":"Configuration Options\u00b6","text":"<p>The <code>add_zarr_layer</code> method supports several configuration options:</p> Parameter Type Default Description <code>url</code> str required URL to the Zarr store <code>variable</code> str required Variable name in the Zarr dataset <code>name</code> str auto Layer identifier <code>colormap</code> List[str] ['#000000', '#ffffff'] Hex color strings for visualization <code>clim</code> Tuple[float, float] (0, 100) Color scale limits (min, max) <code>opacity</code> float 1.0 Layer opacity (0-1) <code>selector</code> Dict {} Dimension selector (e.g., {\"month\": 4, \"band\": \"tavg\"}) <code>minzoom</code> int 0 Minimum zoom level for rendering <code>maxzoom</code> int 22 Maximum zoom level for rendering <code>fill_value</code> float auto No-data value <code>spatial_dimensions</code> Dict auto Custom spatial dimension names (e.g., {\"lat\": \"y\", \"lon\": \"x\"}) <code>zarr_version</code> int auto Zarr format version (2 or 3) <code>bounds</code> List[float] auto Explicit bounds [west, south, east, north] for datasets without coordinate arrays"},{"location":"maplibre/zarr_layer/#sample-datasets","title":"Sample Datasets\u00b6","text":"<p>CarbonPlan provides several sample datasets at zarr-layer.demo.carbonplan.org:</p> Dataset URL Variable Description 4D Climate carbonplan-maps.s3.../v2/demo/4d/tavg-prec-month climate Temp/precip by month Ocean Temperature atlantis-vis-o.s3-ext.../tos_con tos_con v3 pyramid, EPSG:3857 Burn Probability carbonplan-share.s3.../13-lvl-30m-4326-scott-BP.zarr BP 30m resolution CONUS"},{"location":"openlayers/openlayers/","title":"Openlayers","text":"In\u00a0[\u00a0]: Copied! <pre># %pip install -U anymap-ts\n</pre> # %pip install -U anymap-ts In\u00a0[\u00a0]: Copied! <pre>from anymap_ts import OpenLayersMap\n\n# Create an OpenLayers map\nm = OpenLayersMap(center=[-122.4, 37.8], zoom=10)\nm.add_basemap(\"OpenStreetMap\")\nm\n</pre> from anymap_ts import OpenLayersMap  # Create an OpenLayers map m = OpenLayersMap(center=[-122.4, 37.8], zoom=10) m.add_basemap(\"OpenStreetMap\") m In\u00a0[\u00a0]: Copied! <pre># Add GeoJSON\ngeojson = {\n    \"type\": \"FeatureCollection\",\n    \"features\": [\n        {\n            \"type\": \"Feature\",\n            \"geometry\": {\"type\": \"Point\", \"coordinates\": [-122.4194, 37.7749]},\n            \"properties\": {\"name\": \"San Francisco\"},\n        }\n    ],\n}\n\nm.add_geojson(\n    geojson,\n    name=\"cities\",\n    style={\"fillColor\": \"rgba(255, 0, 0, 0.8)\", \"strokeColor\": \"#ffffff\", \"radius\": 8},\n)\n</pre> # Add GeoJSON geojson = {     \"type\": \"FeatureCollection\",     \"features\": [         {             \"type\": \"Feature\",             \"geometry\": {\"type\": \"Point\", \"coordinates\": [-122.4194, 37.7749]},             \"properties\": {\"name\": \"San Francisco\"},         }     ], }  m.add_geojson(     geojson,     name=\"cities\",     style={\"fillColor\": \"rgba(255, 0, 0, 0.8)\", \"strokeColor\": \"#ffffff\", \"radius\": 8}, ) In\u00a0[\u00a0]: Copied! <pre># Add WMS layer (example - replace with actual WMS service)\n# m.add_wms_layer(\n#     url=\"https://example.com/wms\",\n#     layers=\"layer_name\",\n#     name=\"WMS Layer\"\n# )\n</pre> # Add WMS layer (example - replace with actual WMS service) # m.add_wms_layer( #     url=\"https://example.com/wms\", #     layers=\"layer_name\", #     name=\"WMS Layer\" # ) In\u00a0[\u00a0]: Copied! <pre># Add markers\nm.add_marker(-122.4194, 37.7749, color=\"#ff0000\")\nm.add_marker(-122.2712, 37.8044, color=\"#00ff00\")\n</pre> # Add markers m.add_marker(-122.4194, 37.7749, color=\"#ff0000\") m.add_marker(-122.2712, 37.8044, color=\"#00ff00\") In\u00a0[\u00a0]: Copied! <pre># Fly to location\nm.fly_to(-122.4194, 37.7749, zoom=14)\n</pre> # Fly to location m.fly_to(-122.4194, 37.7749, zoom=14) In\u00a0[\u00a0]: Copied! <pre># Export to HTML\nm.to_html(\"openlayers_example.html\")\n</pre> # Export to HTML m.to_html(\"openlayers_example.html\")"},{"location":"openlayers/openlayers/#openlayers-example","title":"OpenLayers Example\u00b6","text":"<p>This notebook demonstrates the OpenLayers integration in anymap-ts.</p> <p>OpenLayers is a high-performance library with excellent WMS/WMTS support and projection handling.</p>"},{"location":"potree/potree/","title":"Potree","text":"In\u00a0[\u00a0]: Copied! <pre># %pip install -U anymap-ts\n</pre> # %pip install -U anymap-ts In\u00a0[\u00a0]: Copied! <pre>from anymap_ts import PotreeViewer\n\n# Create a Potree viewer\nviewer = PotreeViewer(\n    point_budget=1000000, point_size=1.0, background=\"#1a1a2e\", edl_enabled=True\n)\nviewer\n</pre> from anymap_ts import PotreeViewer  # Create a Potree viewer viewer = PotreeViewer(     point_budget=1000000, point_size=1.0, background=\"#1a1a2e\", edl_enabled=True ) viewer In\u00a0[\u00a0]: Copied! <pre># Load a point cloud (replace with your Potree-formatted dataset URL)\n# viewer.load_point_cloud(\n#     url=\"path/to/pointcloud/cloud.js\",\n#     name=\"lidar_data\",\n#     point_size_type=\"adaptive\",\n#     shape=\"circle\"\n# )\n</pre> # Load a point cloud (replace with your Potree-formatted dataset URL) # viewer.load_point_cloud( #     url=\"path/to/pointcloud/cloud.js\", #     name=\"lidar_data\", #     point_size_type=\"adaptive\", #     shape=\"circle\" # ) In\u00a0[\u00a0]: Copied! <pre># Adjust visualization settings\nviewer.set_point_budget(2000000)  # Increase for more detail\nviewer.set_point_size(1.5)\n</pre> # Adjust visualization settings viewer.set_point_budget(2000000)  # Increase for more detail viewer.set_point_size(1.5) In\u00a0[\u00a0]: Copied! <pre># Adjust Eye Dome Lighting\nviewer.set_edl(enabled=True, radius=1.8, strength=0.5)\n</pre> # Adjust Eye Dome Lighting viewer.set_edl(enabled=True, radius=1.8, strength=0.5) In\u00a0[\u00a0]: Copied! <pre># Set camera position\nviewer.set_camera_position(0, 0, 100)\nviewer.set_camera_target(0, 0, 0)\n</pre> # Set camera position viewer.set_camera_position(0, 0, 100) viewer.set_camera_target(0, 0, 0) In\u00a0[\u00a0]: Copied! <pre># Add measurement tool\n# viewer.add_measurement_tool(\"distance\")\n</pre> # Add measurement tool # viewer.add_measurement_tool(\"distance\") In\u00a0[\u00a0]: Copied! <pre># Add annotation\nviewer.add_annotation(\n    position=(10, 20, 30),\n    title=\"Point of Interest\",\n    description=\"This is an important location\",\n)\n</pre> # Add annotation viewer.add_annotation(     position=(10, 20, 30),     title=\"Point of Interest\",     description=\"This is an important location\", ) In\u00a0[\u00a0]: Copied! <pre># Export to HTML\nviewer.to_html(\"potree_example.html\")\n</pre> # Export to HTML viewer.to_html(\"potree_example.html\")"},{"location":"potree/potree/#potree-example","title":"Potree Example\u00b6","text":"<p>This notebook demonstrates the Potree integration in anymap-ts.</p> <p>Potree is a WebGL-based point cloud viewer for large-scale LiDAR datasets.</p> <p>Note: You need a Potree-formatted point cloud dataset (converted from LAS/LAZ) to visualize.</p>"},{"location":"typescript/","title":"TypeScript Examples","text":"<p>anymap-ts is built with TypeScript, providing type-safe interactive maps through the anywidget framework. This section demonstrates how to use the TypeScript renderers directly.</p>"},{"location":"typescript/#architecture-overview","title":"Architecture Overview","text":"<p>anymap-ts uses the anywidget pattern for Python-JavaScript communication:</p> <pre><code>Python (anymap_ts)  &lt;--&gt;  anywidget model  &lt;--&gt;  TypeScript Renderer\n</code></pre> <p>Each map type has a corresponding TypeScript renderer that:</p> <ol> <li>Receives a <code>model</code> object for state synchronization with Python</li> <li>Receives an <code>el</code> DOM element for rendering</li> <li>Handles method calls from Python via <code>_js_calls</code></li> <li>Sends events back to Python via <code>_js_events</code></li> </ol>"},{"location":"typescript/#available-renderers","title":"Available Renderers","text":"Renderer Library Source File <code>MapLibreRenderer</code> MapLibre GL JS <code>src/maplibre/MapLibreRenderer.ts</code> <code>LeafletRenderer</code> Leaflet <code>src/leaflet/LeafletRenderer.ts</code> <code>MapboxRenderer</code> Mapbox GL JS <code>src/mapbox/MapboxRenderer.ts</code> <code>CesiumWidget</code> Cesium <code>src/cesium/index.ts</code> <code>DeckGLRenderer</code> DeckGL + MapLibre <code>src/deckgl/DeckGLRenderer.ts</code> <code>OpenLayersRenderer</code> OpenLayers <code>src/openlayers/OpenLayersRenderer.ts</code> <code>PotreeWidget</code> Potree <code>src/potree/index.ts</code> <code>KeplerGLWidget</code> KeplerGL <code>src/keplergl/index.ts</code>"},{"location":"typescript/#examples-by-category","title":"Examples by Category","text":""},{"location":"typescript/#basic-mapping","title":"Basic Mapping","text":"<ul> <li>MapLibre GL JS - Vector maps with drawing and layer control</li> <li>Leaflet - Lightweight, mobile-friendly maps</li> <li>Mapbox GL JS - Commercial vector maps (requires token)</li> <li>OpenLayers - Feature-rich with WMS/WMTS support</li> </ul>"},{"location":"typescript/#3d-visualization","title":"3D Visualization","text":"<ul> <li>Cesium - 3D globe with terrain and 3D Tiles</li> </ul>"},{"location":"typescript/#gpu-accelerated-layers","title":"GPU-Accelerated Layers","text":"<ul> <li>DeckGL - ScatterplotLayer, HexagonLayer, HeatmapLayer, ArcLayer</li> </ul>"},{"location":"typescript/#scientific-data","title":"Scientific Data","text":"<ul> <li>COG Layer - Cloud Optimized GeoTIFF visualization</li> <li>Zarr Layer - Multi-dimensional dataset visualization</li> </ul>"},{"location":"typescript/#specialized-viewers","title":"Specialized Viewers","text":"<ul> <li>Potree - Point cloud visualization for LiDAR</li> <li>KeplerGL - Interactive data exploration</li> </ul>"},{"location":"typescript/#core-types","title":"Core Types","text":"<p>The anywidget communication types are defined in <code>src/types/anywidget.ts</code>:</p> <pre><code>// Method call from Python to JavaScript\ninterface JsCall {\n  id: number;\n  method: string;\n  args: unknown[];\n  kwargs: Record&lt;string, unknown&gt;;\n}\n\n// Event from JavaScript to Python\ninterface JsEvent {\n  type: string;\n  data: unknown;\n  timestamp: number;\n}\n\n// Render context provided by anywidget\ninterface RenderContext {\n  model: MapWidgetModel;\n  el: HTMLElement;\n}\n</code></pre>"},{"location":"typescript/#typescript-source-files","title":"TypeScript Source Files","text":"<p>Standalone TypeScript example files are available in <code>src/examples/</code>:</p> File Description <code>maplibre.ts</code> MapLibre with draw and layer control <code>leaflet.ts</code> Leaflet with markers and GeoJSON <code>mapbox.ts</code> Mapbox GL JS example <code>cesium.ts</code> Cesium 3D globe <code>deckgl.ts</code> DeckGL visualization layers <code>openlayers.ts</code> OpenLayers mapping <code>potree.ts</code> Potree point cloud viewer <code>keplergl.ts</code> KeplerGL data exploration <code>cog_layer.ts</code> COG layer visualization <code>zarr_layer.ts</code> Zarr layer visualization"},{"location":"typescript/examples/arc_layer/","title":"Arc Layer","text":"<p>The DeckGL ArcLayer renders raised arcs joining pairs of source and target points, ideal for visualizing origin-destination data like flight routes, migration patterns, and transportation networks.</p>"},{"location":"typescript/examples/arc_layer/#python-example","title":"Python Example","text":"<pre><code>from anymap_ts import MapLibreMap\n\n# Sample flight data from San Francisco\nflights = [\n    {\"source\": [-122.4194, 37.7749], \"target\": [-73.9857, 40.7484], \"name\": \"SF to NYC\"},\n    {\"source\": [-122.4194, 37.7749], \"target\": [-87.6298, 41.8781], \"name\": \"SF to Chicago\"},\n    {\"source\": [-122.4194, 37.7749], \"target\": [-118.2437, 34.0522], \"name\": \"SF to LA\"},\n]\n\nm = MapLibreMap(center=[-98.5795, 39.8283], zoom=3, pitch=30)\nm.add_basemap(\"CartoDB.DarkMatter\")\nm.add_arc_layer(\n    data=flights,\n    name=\"flights\",\n    get_source_color=[0, 128, 255, 255],\n    get_target_color=[255, 128, 0, 255],\n    get_width=2,\n    great_circle=True,\n)\nm\n</code></pre>"},{"location":"typescript/examples/arc_layer/#typescript-implementation","title":"TypeScript Implementation","text":"<p>The <code>handleAddArcLayer</code> method in <code>MapLibreRenderer</code> creates deck.gl ArcLayer instances:</p> <pre><code>import { ArcLayer } from '@deck.gl/layers';\n\nprivate handleAddArcLayer(args: unknown[], kwargs: Record&lt;string, unknown&gt;): void {\n  this.initializeDeckOverlay();\n  const id = kwargs.id as string || `arc-${Date.now()}`;\n  const data = kwargs.data as unknown[];\n\n  const layer = new ArcLayer({\n    id,\n    data,\n    pickable: kwargs.pickable !== false,\n    opacity: kwargs.opacity as number ?? 0.8,\n    getWidth: kwargs.getWidth ?? 1,\n    getHeight: kwargs.getHeight ?? 1,\n    greatCircle: kwargs.greatCircle as boolean ?? false,\n    getSourcePosition: (d: any) =&gt; d[kwargs.getSourcePosition as string] || d.source,\n    getTargetPosition: (d: any) =&gt; d[kwargs.getTargetPosition as string] || d.target,\n    getSourceColor: kwargs.getSourceColor ?? [51, 136, 255, 255],\n    getTargetColor: kwargs.getTargetColor ?? [255, 136, 51, 255],\n  });\n\n  this.deckLayers.set(id, layer);\n  this.updateDeckOverlay();\n  this.deckLayerAdapter?.notifyLayerAdded(id);\n}\n</code></pre>"},{"location":"typescript/examples/arc_layer/#layer-control-integration","title":"Layer Control Integration","text":"<p>Arc layers integrate with the layer control via <code>DeckLayerAdapter</code>:</p> <pre><code>// Layer IDs starting with 'arc-' are managed by DeckLayerAdapter\ngetLayerIds(): string[] {\n  return Array.from(this.deckLayers.keys()).filter(id =&gt;\n    id.startsWith('arc-') || id.startsWith('pointcloud-')\n  );\n}\n\n// Toggle visibility by cloning the immutable deck.gl layer\nsetVisibility(layerId: string, visible: boolean): void {\n  const layer = this.deckLayers.get(layerId);\n  if (layer &amp;&amp; typeof layer.clone === 'function') {\n    const updated = layer.clone({ visible });\n    this.deckLayers.set(layerId, updated);\n    this.updateOverlay();\n  }\n}\n</code></pre>"},{"location":"typescript/examples/arc_layer/#api-reference","title":"API Reference","text":""},{"location":"typescript/examples/arc_layer/#parameters","title":"Parameters","text":"Parameter Type Default Description <code>data</code> <code>Array</code> required Array of arc data objects <code>name</code> <code>string</code> auto-generated Layer identifier <code>get_source_position</code> <code>string</code> <code>\"source\"</code> Accessor for source [lng, lat] <code>get_target_position</code> <code>string</code> <code>\"target\"</code> Accessor for target [lng, lat] <code>get_source_color</code> <code>Array&lt;int&gt;</code> <code>[51, 136, 255, 255]</code> RGBA color at source <code>get_target_color</code> <code>Array&lt;int&gt;</code> <code>[255, 136, 51, 255]</code> RGBA color at target <code>get_width</code> <code>number</code> <code>1</code> Arc width in pixels <code>get_height</code> <code>number</code> <code>1</code> Arc height multiplier <code>great_circle</code> <code>bool</code> <code>false</code> Use great circle path <code>pickable</code> <code>bool</code> <code>true</code> Enable hover/click <code>opacity</code> <code>float</code> <code>0.8</code> Layer opacity"},{"location":"typescript/examples/arc_layer/#data-format","title":"Data Format","text":"<p>Each arc object should have source and target coordinates:</p> <pre><code>{\n  source: [longitude, latitude],  // or [longitude, latitude, altitude]\n  target: [longitude, latitude],\n  // ... additional properties\n}\n</code></pre>"},{"location":"typescript/examples/arc_layer/#source-files","title":"Source Files","text":"<ul> <li>MapLibre Handler: <code>src/maplibre/MapLibreRenderer.ts</code></li> <li>Mapbox Handler: <code>src/mapbox/MapboxRenderer.ts</code></li> <li>DeckGL Handler: <code>src/deckgl/DeckGLRenderer.ts</code></li> <li>Layer Adapter: <code>src/maplibre/adapters/DeckLayerAdapter.ts</code></li> </ul> <p>See also: Python notebook example</p>"},{"location":"typescript/examples/cesium/","title":"Cesium","text":"<p>Cesium is a powerful 3D globe visualization library with terrain and 3D Tiles support.</p>"},{"location":"typescript/examples/cesium/#python-example","title":"Python Example","text":"<pre><code>from anymap_ts import CesiumMap\n\nm = CesiumMap(center=[-122.4, 37.8], zoom=10)\nm.add_basemap(\"OpenStreetMap\")\nm.add_geojson(geojson, name=\"features\", stroke=\"#ff0000\", fill=\"rgba(255,0,0,0.3)\")\nm.fly_to(-122.4194, 37.7749, height=50000, heading=45, pitch=-45)\nm\n</code></pre> <p>Note: Some features like Cesium World Terrain require a Cesium Ion access token. Set the <code>CESIUM_TOKEN</code> environment variable.</p>"},{"location":"typescript/examples/cesium/#typescript-implementation","title":"TypeScript Implementation","text":"<p>Cesium is loaded dynamically from CDN since it's too large to bundle:</p> <pre><code>const CESIUM_VERSION = '1.120';\nconst CESIUM_BASE_URL = `https://cesium.com/downloads/cesiumjs/releases/${CESIUM_VERSION}/Build/Cesium`;\n\n// Load Cesium JS dynamically\nfunction loadCesiumJS(): Promise&lt;void&gt; {\n  return new Promise((resolve, reject) =&gt; {\n    if (window.Cesium) {\n      resolve();\n      return;\n    }\n\n    window.CESIUM_BASE_URL = CESIUM_BASE_URL;\n\n    const script = document.createElement('script');\n    script.src = `${CESIUM_BASE_URL}/Cesium.js`;\n    script.async = true;\n    script.onload = () =&gt; resolve();\n    script.onerror = () =&gt; reject(new Error('Failed to load Cesium'));\n    document.head.appendChild(script);\n  });\n}\n</code></pre>"},{"location":"typescript/examples/cesium/#cesiumwidget-class","title":"CesiumWidget Class","text":"<pre><code>class CesiumWidget {\n  private viewer: Cesium.Viewer | null = null;\n  private dataSources: Map&lt;string, Cesium.DataSource&gt; = new Map();\n\n  async initialize(): Promise&lt;void&gt; {\n    const Cesium = window.Cesium;\n    const accessToken = this.model.get('access_token');\n\n    if (accessToken) {\n      Cesium.Ion.defaultAccessToken = accessToken;\n    }\n\n    // Create viewer\n    this.viewer = new Cesium.Viewer(this.container, {\n      baseLayerPicker: false,\n      geocoder: false,\n      homeButton: false,\n      animation: false,\n      timeline: false,\n    });\n\n    // Set initial camera position\n    const center = this.model.get('center');\n    const height = this.zoomToHeight(this.model.get('zoom'));\n\n    this.viewer.camera.setView({\n      destination: Cesium.Cartesian3.fromDegrees(center[0], center[1], height),\n    });\n  }\n}\n</code></pre>"},{"location":"typescript/examples/cesium/#key-methods","title":"Key Methods","text":""},{"location":"typescript/examples/cesium/#camera-control","title":"Camera Control","text":"<pre><code>// Convert zoom level to camera height\nfunction zoomToHeight(zoom: number): number {\n  return 40000000 / Math.pow(2, zoom);\n}\n\nhandle_flyTo(args: unknown[], kwargs: Record&lt;string, unknown&gt;): void {\n  const Cesium = window.Cesium;\n  const lng = args[0] as number;\n  const lat = args[1] as number;\n  const height = kwargs.height as number || this.zoomToHeight(kwargs.zoom as number || 10);\n  const heading = kwargs.heading as number || 0;\n  const pitch = kwargs.pitch as number || -90;\n  const duration = kwargs.duration as number ?? 2;\n\n  this.viewer.camera.flyTo({\n    destination: Cesium.Cartesian3.fromDegrees(lng, lat, height),\n    orientation: {\n      heading: Cesium.Math.toRadians(heading),\n      pitch: Cesium.Math.toRadians(pitch),\n      roll: 0,\n    },\n    duration,\n  });\n}\n\nhandle_resetView(args: unknown[], kwargs: Record&lt;string, unknown&gt;): void {\n  this.viewer.camera.flyHome(kwargs.duration as number ?? 2);\n}\n</code></pre>"},{"location":"typescript/examples/cesium/#adding-geojson","title":"Adding GeoJSON","text":"<pre><code>async handle_addGeoJSON(args: unknown[], kwargs: Record&lt;string, unknown&gt;): Promise&lt;void&gt; {\n  const Cesium = window.Cesium;\n  const data = kwargs.data as object;\n  const name = kwargs.name as string;\n  const stroke = kwargs.stroke as string || '#3388ff';\n  const fill = kwargs.fill as string || 'rgba(51, 136, 255, 0.5)';\n\n  const dataSource = await Cesium.GeoJsonDataSource.load(data, {\n    stroke: Cesium.Color.fromCssColorString(stroke),\n    fill: Cesium.Color.fromCssColorString(fill),\n    clampToGround: true,\n  });\n\n  await this.viewer.dataSources.add(dataSource);\n  this.dataSources.set(name, dataSource);\n\n  if (kwargs.flyTo !== false) {\n    this.viewer.zoomTo(dataSource);\n  }\n}\n</code></pre>"},{"location":"typescript/examples/cesium/#terrain","title":"Terrain","text":"<pre><code>handle_setTerrain(args: unknown[], kwargs: Record&lt;string, unknown&gt;): void {\n  const Cesium = window.Cesium;\n\n  this.viewer.scene.setTerrain(\n    Cesium.Terrain.fromWorldTerrain({\n      requestVertexNormals: true,\n      requestWaterMask: true,\n    })\n  );\n}\n</code></pre>"},{"location":"typescript/examples/cesium/#basemap","title":"Basemap","text":"<pre><code>handle_addBasemap(args: unknown[], kwargs: Record&lt;string, unknown&gt;): void {\n  const Cesium = window.Cesium;\n  const url = args[0] as string;\n  const name = kwargs.name as string || 'basemap';\n\n  const imageryProvider = new Cesium.UrlTemplateImageryProvider({ url });\n  const layer = this.viewer.imageryLayers.addImageryProvider(imageryProvider);\n  this.imageryLayers.set(name, layer);\n}\n</code></pre>"},{"location":"typescript/examples/cesium/#3d-features","title":"3D Features","text":""},{"location":"typescript/examples/cesium/#camera-orientation","title":"Camera Orientation","text":"<p>Cesium supports full 3D camera control with heading, pitch, and roll:</p> <pre><code>// Heading: rotation around the vertical axis (0-360 degrees)\n// Pitch: rotation around the lateral axis (-90 to 90 degrees)\n// Roll: rotation around the longitudinal axis\n\nthis.viewer.camera.flyTo({\n  destination: Cesium.Cartesian3.fromDegrees(lng, lat, height),\n  orientation: {\n    heading: Cesium.Math.toRadians(45),  // 45 degrees from north\n    pitch: Cesium.Math.toRadians(-45),   // 45 degrees down\n    roll: 0,\n  },\n});\n</code></pre>"},{"location":"typescript/examples/cesium/#3d-tilesets","title":"3D Tilesets","text":"<pre><code>handle_add3DTileset(args: unknown[], kwargs: Record&lt;string, unknown&gt;): void {\n  const Cesium = window.Cesium;\n  const url = kwargs.url as string;\n  const name = kwargs.name as string;\n\n  const tileset = this.viewer.scene.primitives.add(\n    new Cesium.Cesium3DTileset({ url })\n  );\n\n  this.tilesets.set(name, tileset);\n}\n</code></pre>"},{"location":"typescript/examples/cesium/#source-files","title":"Source Files","text":"<ul> <li>Widget: <code>src/cesium/index.ts</code></li> <li>Types: <code>src/types/cesium.ts</code></li> </ul> <p>See also: Python notebook example</p>"},{"location":"typescript/examples/cog_layer/","title":"COG Layer","text":"<p>Cloud Optimized GeoTIFFs (COGs) enable efficient raster visualization with automatic reprojection.</p>"},{"location":"typescript/examples/cog_layer/#python-example","title":"Python Example","text":"<pre><code>from anymap_ts import Map\n\nCOG_URL = \"https://s3.us-east-1.amazonaws.com/ds-deck.gl-raster-public/cog/Annual_NLCD_LndCov_2024_CU_C1V1.tif\"\n\nm = Map(center=[-98.5, 39.8], zoom=4, style=\"dark-matter\")\nm.add_cog_layer(COG_URL, name=\"nlcd-landcover\", opacity=1.0)\nm\n</code></pre>"},{"location":"typescript/examples/cog_layer/#typescript-implementation","title":"TypeScript Implementation","text":"<p>COG layers use the <code>@developmentseed/deck.gl-geotiff</code> package with deck.gl overlay:</p> <pre><code>import { MapboxOverlay } from '@deck.gl/mapbox';\nimport { COGLayer, proj } from '@developmentseed/deck.gl-geotiff';\nimport { toProj4 } from 'geotiff-geokeys-to-proj4';\n\n// Parse GeoKeys for reprojection\nasync function geoKeysParser(geoKeys: Record&lt;string, unknown&gt;): Promise&lt;proj.ProjectionInfo&gt; {\n  const projDefinition = toProj4(geoKeys);\n  return {\n    def: projDefinition.proj4,\n    parsed: proj.parseCrs(projDefinition.proj4),\n    coordinatesUnits: projDefinition.coordinatesUnits,\n  };\n}\n</code></pre>"},{"location":"typescript/examples/cog_layer/#adding-cog-layer","title":"Adding COG Layer","text":"<pre><code>private handleAddCOGLayer(args: unknown[], kwargs: Record&lt;string, unknown&gt;): void {\n  // Initialize deck.gl overlay if needed\n  this.initializeDeckOverlay();\n\n  const id = kwargs.id as string || `cog-${Date.now()}`;\n  const geotiff = kwargs.geotiff as string;\n  const fitBounds = kwargs.fitBounds !== false;\n\n  const layer = new COGLayer({\n    id,\n    geotiff,\n    opacity: kwargs.opacity as number ?? 1,\n    visible: kwargs.visible !== false,\n    debug: kwargs.debug as boolean ?? false,\n    debugOpacity: kwargs.debugOpacity as number ?? 0.25,\n    maxError: kwargs.maxError as number ?? 0.125,\n    beforeId: kwargs.beforeId as string,\n    geoKeysParser,\n    onGeoTIFFLoad: (tiff, options) =&gt; {\n      if (fitBounds &amp;&amp; this.map) {\n        const { west, south, east, north } = options.geographicBounds;\n        this.map.fitBounds([[west, south], [east, north]], { padding: 40, duration: 1000 });\n      }\n    },\n  });\n\n  this.deckLayers.set(id, layer);\n  this.updateDeckOverlay();\n}\n</code></pre>"},{"location":"typescript/examples/cog_layer/#removing-cog-layer","title":"Removing COG Layer","text":"<pre><code>private handleRemoveCOGLayer(args: unknown[], kwargs: Record&lt;string, unknown&gt;): void {\n  const [id] = args as [string];\n  this.deckLayers.delete(id);\n  this.updateDeckOverlay();\n}\n</code></pre>"},{"location":"typescript/examples/cog_layer/#configuration-options","title":"Configuration Options","text":"Parameter Type Default Description <code>geotiff</code> string required URL to the Cloud Optimized GeoTIFF file <code>id</code> string auto Layer identifier <code>opacity</code> number 1.0 Layer opacity (0-1) <code>visible</code> boolean true Whether layer is visible <code>debug</code> boolean false Show reprojection mesh for debugging <code>debugOpacity</code> number 0.25 Opacity of debug mesh <code>maxError</code> number 0.125 Maximum reprojection error in pixels <code>fitBounds</code> boolean true Fit map to COG bounds after loading <code>beforeId</code> string undefined ID of layer to insert before"},{"location":"typescript/examples/cog_layer/#layer-control-integration","title":"Layer Control Integration","text":"<p>The COG layer adapter allows integration with the layer control:</p> <pre><code>class COGLayerAdapter implements CustomLayerAdapter {\n  private map: MapLibreMap;\n  private deckOverlay: MapboxOverlay;\n  private deckLayers: Map&lt;string, unknown&gt;;\n\n  getLayerIds(): string[] {\n    return Array.from(this.deckLayers.keys()).filter((id) =&gt; id.startsWith('cog-'));\n  }\n\n  setVisibility(layerId: string, visible: boolean): void {\n    const layer = this.deckLayers.get(layerId);\n    if (layer) {\n      const updatedLayer = (layer as COGLayer).clone({ visible });\n      this.deckLayers.set(layerId, updatedLayer);\n      this.updateOverlay();\n    }\n  }\n\n  setOpacity(layerId: string, opacity: number): void {\n    const layer = this.deckLayers.get(layerId);\n    if (layer) {\n      const updatedLayer = (layer as COGLayer).clone({ opacity });\n      this.deckLayers.set(layerId, updatedLayer);\n      this.updateOverlay();\n    }\n  }\n}\n</code></pre>"},{"location":"typescript/examples/cog_layer/#debug-mode","title":"Debug Mode","text":"<p>Enable debug mode to visualize the reprojection mesh:</p> <pre><code>m.add_cog_layer(\n    COG_URL,\n    name=\"nlcd-debug\",\n    debug=True,\n    debug_opacity=0.25,\n)\n</code></pre> <p>This shows the triangular mesh used for GPU reprojection, useful for debugging projection issues.</p>"},{"location":"typescript/examples/cog_layer/#source-files","title":"Source Files","text":"<ul> <li>MapLibre Implementation: <code>src/maplibre/MapLibreRenderer.ts</code></li> <li>DeckGL Implementation: <code>src/deckgl/DeckGLRenderer.ts</code></li> <li>Layer Adapter: <code>src/maplibre/adapters/COGLayerAdapter.ts</code></li> <li>Layer with Opacity: <code>src/maplibre/layers/COGLayerWithOpacity.ts</code></li> </ul> <p>See also: Python notebook example</p>"},{"location":"typescript/examples/deckgl/","title":"DeckGL","text":"<p>DeckGL provides GPU-accelerated visualization layers on top of MapLibre GL JS.</p>"},{"location":"typescript/examples/deckgl/#python-example","title":"Python Example","text":"<pre><code>from anymap_ts import DeckGLMap\nimport random\n\n# Create map with dark basemap\nm = DeckGLMap(center=[-122.4, 37.8], zoom=10)\nm.add_basemap(\"CartoDB.DarkMatter\")\n\n# Generate sample data\npoints = [\n    {\"coordinates\": [-122.4 + random.uniform(-0.2, 0.2), 37.8 + random.uniform(-0.2, 0.2)], \"value\": random.randint(1, 100)}\n    for _ in range(1000)\n]\n\n# Add scatterplot layer\nm.add_scatterplot_layer(data=points, name=\"scatterplot\", get_radius=100, get_fill_color=[255, 140, 0, 200])\n\n# Add hexagon aggregation layer\nm.add_hexagon_layer(data=points, name=\"hexagons\", radius=500, elevation_scale=10, extruded=True)\nm\n</code></pre>"},{"location":"typescript/examples/deckgl/#typescript-implementation","title":"TypeScript Implementation","text":"<p>The <code>DeckGLRenderer</code> extends <code>MapLibreRenderer</code> and adds deck.gl overlay support:</p> <pre><code>import { MapboxOverlay } from '@deck.gl/mapbox';\nimport { ScatterplotLayer, ArcLayer } from '@deck.gl/layers';\nimport { HexagonLayer, HeatmapLayer } from '@deck.gl/aggregation-layers';\nimport { MapLibreRenderer } from '../maplibre/MapLibreRenderer';\n\nexport class DeckGLRenderer extends MapLibreRenderer {\n  private deckOverlay: MapboxOverlay | null = null;\n  private deckLayers: Map&lt;string, unknown&gt; = new Map();\n\n  async initialize(): Promise&lt;void&gt; {\n    await super.initialize();\n\n    // Create deck.gl overlay\n    this.deckOverlay = new MapboxOverlay({ layers: [] });\n    this.map.addControl(this.deckOverlay);\n  }\n\n  private updateDeckOverlay(): void {\n    const layers = Array.from(this.deckLayers.values());\n    this.deckOverlay.setProps({ layers });\n  }\n}\n</code></pre>"},{"location":"typescript/examples/deckgl/#layer-types","title":"Layer Types","text":""},{"location":"typescript/examples/deckgl/#scatterplotlayer","title":"ScatterplotLayer","text":"<pre><code>private handleAddScatterplotLayer(args: unknown[], kwargs: Record&lt;string, unknown&gt;): void {\n  const id = kwargs.id as string || `scatterplot-${Date.now()}`;\n  const data = kwargs.data as unknown[];\n\n  const layer = new ScatterplotLayer({\n    id,\n    data,\n    pickable: true,\n    opacity: kwargs.opacity as number ?? 0.8,\n    stroked: true,\n    filled: true,\n    radiusScale: kwargs.radiusScale as number ?? 1,\n    radiusMinPixels: kwargs.radiusMinPixels as number ?? 1,\n    getPosition: (d: any) =&gt; d.coordinates || d.position,\n    getRadius: kwargs.getRadius ?? 5,\n    getFillColor: kwargs.getFillColor ?? [51, 136, 255, 200],\n    getLineColor: kwargs.getLineColor ?? [255, 255, 255, 255],\n  });\n\n  this.deckLayers.set(id, layer);\n  this.updateDeckOverlay();\n}\n</code></pre>"},{"location":"typescript/examples/deckgl/#hexagonlayer-aggregation","title":"HexagonLayer (Aggregation)","text":"<pre><code>private handleAddHexagonLayer(args: unknown[], kwargs: Record&lt;string, unknown&gt;): void {\n  const id = kwargs.id as string || `hexagon-${Date.now()}`;\n  const data = kwargs.data as unknown[];\n\n  const layer = new HexagonLayer({\n    id,\n    data,\n    pickable: true,\n    extruded: kwargs.extruded as boolean ?? true,\n    radius: kwargs.radius as number ?? 1000,\n    elevationScale: kwargs.elevationScale as number ?? 4,\n    getPosition: (d: any) =&gt; d.coordinates || d.position,\n    colorRange: [\n      [1, 152, 189],\n      [73, 227, 206],\n      [216, 254, 181],\n      [254, 237, 177],\n      [254, 173, 84],\n      [209, 55, 78],\n    ],\n  });\n\n  this.deckLayers.set(id, layer);\n  this.updateDeckOverlay();\n}\n</code></pre>"},{"location":"typescript/examples/deckgl/#heatmaplayer","title":"HeatmapLayer","text":"<pre><code>private handleAddHeatmapLayer(args: unknown[], kwargs: Record&lt;string, unknown&gt;): void {\n  const id = kwargs.id as string || `heatmap-${Date.now()}`;\n  const data = kwargs.data as unknown[];\n\n  const layer = new HeatmapLayer({\n    id,\n    data,\n    opacity: kwargs.opacity as number ?? 1,\n    radiusPixels: kwargs.radiusPixels as number ?? 30,\n    intensity: kwargs.intensity as number ?? 1,\n    threshold: kwargs.threshold as number ?? 0.05,\n    getPosition: (d: any) =&gt; d.coordinates || d.position,\n    getWeight: kwargs.getWeight ?? 1,\n    colorRange: [\n      [255, 255, 178, 25],\n      [254, 217, 118, 85],\n      [254, 178, 76, 127],\n      [253, 141, 60, 170],\n      [240, 59, 32, 212],\n      [189, 0, 38, 255],\n    ],\n  });\n\n  this.deckLayers.set(id, layer);\n  this.updateDeckOverlay();\n}\n</code></pre>"},{"location":"typescript/examples/deckgl/#arclayer-connections","title":"ArcLayer (Connections)","text":"<pre><code>private handleAddArcLayer(args: unknown[], kwargs: Record&lt;string, unknown&gt;): void {\n  const id = kwargs.id as string || `arc-${Date.now()}`;\n  const data = kwargs.data as unknown[];\n\n  const layer = new ArcLayer({\n    id,\n    data,\n    pickable: true,\n    getWidth: kwargs.getWidth ?? 1,\n    getSourcePosition: (d: any) =&gt; d.source || d.from,\n    getTargetPosition: (d: any) =&gt; d.target || d.to,\n    getSourceColor: kwargs.getSourceColor ?? [51, 136, 255, 255],\n    getTargetColor: kwargs.getTargetColor ?? [255, 136, 51, 255],\n  });\n\n  this.deckLayers.set(id, layer);\n  this.updateDeckOverlay();\n}\n</code></pre>"},{"location":"typescript/examples/deckgl/#available-layers","title":"Available Layers","text":"Layer Description <code>ScatterplotLayer</code> Render points as circles <code>ArcLayer</code> Render arcs between source and target positions <code>PathLayer</code> Render paths/polylines <code>PolygonLayer</code> Render filled and/or stroked polygons <code>HexagonLayer</code> Aggregate points into hexagonal bins <code>HeatmapLayer</code> Render heatmap based on point density <code>GridLayer</code> Aggregate points into rectangular bins <code>IconLayer</code> Render icons at positions <code>TextLayer</code> Render text labels <code>GeoJsonLayer</code> Render GeoJSON data"},{"location":"typescript/examples/deckgl/#source-files","title":"Source Files","text":"<ul> <li>Renderer: <code>src/deckgl/DeckGLRenderer.ts</code></li> <li>Types: <code>src/types/deckgl.ts</code></li> </ul> <p>See also: Python notebook example</p>"},{"location":"typescript/examples/keplergl/","title":"KeplerGL","text":"<p>KeplerGL is a powerful data exploration tool built on deck.gl.</p>"},{"location":"typescript/examples/keplergl/#python-example","title":"Python Example","text":"<pre><code>from anymap_ts import KeplerGLMap\nimport pandas as pd\nimport random\n\nm = KeplerGLMap(center=[-122.4, 37.8], zoom=10)\n\n# Create sample data\ndf = pd.DataFrame({\n    \"latitude\": [37.8 + random.uniform(-0.2, 0.2) for _ in range(100)],\n    \"longitude\": [-122.4 + random.uniform(-0.2, 0.2) for _ in range(100)],\n    \"value\": [random.randint(1, 100) for _ in range(100)],\n    \"category\": [random.choice([\"A\", \"B\", \"C\"]) for _ in range(100)],\n})\n\nm.add_data(df, name=\"sample_points\")\nm\n</code></pre> <p>Note: For best results, use the anywidget interface in Jupyter. HTML export has limited interactivity.</p>"},{"location":"typescript/examples/keplergl/#typescript-implementation","title":"TypeScript Implementation","text":"<p>KeplerGL is loaded dynamically and requires React:</p> <pre><code>class KeplerGLWidget {\n  private keplerGl: any = null;\n  private store: any = null;\n\n  async initialize(): Promise&lt;void&gt; {\n    await loadKeplerGL();\n\n    const { KeplerGl, keplerGlReducer, addDataToMap } = window.KeplerGl;\n\n    // Create Redux store\n    this.store = createStore(\n      combineReducers({ keplerGl: keplerGlReducer }),\n      applyMiddleware(taskMiddleware)\n    );\n\n    // Render KeplerGL component\n    const root = createRoot(this.container);\n    root.render(\n      &lt;Provider store={this.store}&gt;\n        &lt;KeplerGl\n          id=\"map\"\n          mapboxApiAccessToken={this.model.get('access_token')}\n          width={this.container.clientWidth}\n          height={this.container.clientHeight}\n        /&gt;\n      &lt;/Provider&gt;\n    );\n  }\n}\n</code></pre>"},{"location":"typescript/examples/keplergl/#key-methods","title":"Key Methods","text":""},{"location":"typescript/examples/keplergl/#adding-data","title":"Adding Data","text":"<pre><code>handle_addData(args: unknown[], kwargs: Record&lt;string, unknown&gt;): void {\n  const { addDataToMap } = window.KeplerGl;\n\n  const data = kwargs.data;\n  const name = kwargs.name as string;\n\n  // Determine data format\n  let processedData;\n  if (this.isDataFrame(data)) {\n    processedData = this.convertDataFrameToRows(data);\n  } else if (this.isGeoJSON(data)) {\n    processedData = data;\n  }\n\n  // Dispatch to KeplerGL store\n  this.store.dispatch(\n    addDataToMap({\n      datasets: {\n        info: { label: name, id: name },\n        data: processedData,\n      },\n    })\n  );\n}\n\nprivate convertDataFrameToRows(df: any): { fields: any[]; rows: any[] } {\n  const columns = Object.keys(df);\n  const fields = columns.map((name) =&gt; ({\n    name,\n    type: this.inferType(df[name][0]),\n  }));\n\n  const rows = [];\n  const length = df[columns[0]].length;\n  for (let i = 0; i &lt; length; i++) {\n    rows.push(columns.map((col) =&gt; df[col][i]));\n  }\n\n  return { fields, rows };\n}\n</code></pre>"},{"location":"typescript/examples/keplergl/#configuration","title":"Configuration","text":"<pre><code>handle_setConfig(args: unknown[], kwargs: Record&lt;string, unknown&gt;): void {\n  const { receiveMapConfig } = window.KeplerGl;\n  const config = kwargs.config as object;\n\n  this.store.dispatch(receiveMapConfig(config));\n}\n\nhandle_setFilter(args: unknown[], kwargs: Record&lt;string, unknown&gt;): void {\n  const { setFilter } = window.KeplerGl;\n\n  this.store.dispatch(setFilter({\n    idx: kwargs.idx as number,\n    prop: kwargs.prop as string,\n    value: kwargs.value,\n  }));\n}\n</code></pre>"},{"location":"typescript/examples/keplergl/#layer-management","title":"Layer Management","text":"<pre><code>handle_addLayer(args: unknown[], kwargs: Record&lt;string, unknown&gt;): void {\n  const { addLayer } = window.KeplerGl;\n\n  this.store.dispatch(addLayer({\n    type: kwargs.type as string,\n    dataId: kwargs.dataId as string,\n    config: kwargs.config as object,\n  }));\n}\n\nhandle_updateLayerConfig(args: unknown[], kwargs: Record&lt;string, unknown&gt;): void {\n  const { layerConfigChange } = window.KeplerGl;\n\n  this.store.dispatch(layerConfigChange({\n    oldLayer: this.getLayerById(kwargs.layerId as string),\n    newConfig: kwargs.config as object,\n  }));\n}\n</code></pre>"},{"location":"typescript/examples/keplergl/#data-formats","title":"Data Formats","text":"<p>KeplerGL supports multiple data formats:</p>"},{"location":"typescript/examples/keplergl/#dataframe-like-objects","title":"DataFrame-like Objects","text":"<pre><code>const data = {\n  latitude: [37.7749, 37.8044, 37.3382],\n  longitude: [-122.4194, -122.2712, -122.0308],\n  value: [100, 80, 60],\n  category: ['A', 'B', 'A'],\n};\n</code></pre>"},{"location":"typescript/examples/keplergl/#geojson","title":"GeoJSON","text":"<pre><code>const geojson = {\n  type: 'FeatureCollection',\n  features: [\n    {\n      type: 'Feature',\n      geometry: {\n        type: 'Polygon',\n        coordinates: [[[-122.5, 37.7], [-122.3, 37.7], [-122.3, 37.9], [-122.5, 37.9], [-122.5, 37.7]]],\n      },\n      properties: { name: 'Area' },\n    },\n  ],\n};\n</code></pre>"},{"location":"typescript/examples/keplergl/#built-in-layer-types","title":"Built-in Layer Types","text":"<ul> <li>Point - Render points as circles or icons</li> <li>Arc - Render arcs between points</li> <li>Line - Render line segments</li> <li>Polygon - Render filled polygons</li> <li>Hexagon - Hexagonal aggregation</li> <li>Heatmap - Density heatmap</li> <li>Grid - Grid-based aggregation</li> <li>Cluster - Point clustering</li> <li>H3 - H3 hexagonal tiles</li> <li>Trip - Animated path visualization</li> </ul>"},{"location":"typescript/examples/keplergl/#source-files","title":"Source Files","text":"<ul> <li>Widget: <code>src/keplergl/index.ts</code></li> <li>Types: <code>src/types/keplergl.ts</code></li> </ul> <p>See also: Python notebook example</p>"},{"location":"typescript/examples/leaflet/","title":"Leaflet","text":"<p>Leaflet is a lightweight, mobile-friendly mapping library with excellent browser support.</p>"},{"location":"typescript/examples/leaflet/#python-example","title":"Python Example","text":"<pre><code>from anymap_ts import LeafletMap\n\nm = LeafletMap(center=[-122.4, 37.8], zoom=10)\nm.add_basemap(\"OpenStreetMap\")\nm.add_marker(-122.4194, 37.7749, popup=\"San Francisco\")\nm.add_marker(-122.2712, 37.8044, popup=\"Oakland\")\nm\n</code></pre>"},{"location":"typescript/examples/leaflet/#typescript-implementation","title":"TypeScript Implementation","text":"<p>The <code>LeafletRenderer</code> class handles coordinate conversion (Leaflet uses <code>[lat, lng]</code> order):</p> <pre><code>import * as L from 'leaflet';\nimport { BaseMapRenderer } from '../core/BaseMapRenderer';\nimport type { MapWidgetModel } from '../types/anywidget';\n\nexport class LeafletRenderer extends BaseMapRenderer&lt;L.Map&gt; {\n  private layersMap: Map&lt;string, L.Layer&gt; = new Map();\n  private markersMap: Map&lt;string, L.Marker&gt; = new Map();\n\n  protected createMap(): L.Map {\n    // Leaflet uses [lat, lng] but we receive [lng, lat] from Python\n    const center = this.model.get('center') as [number, number];\n    const zoom = this.model.get('zoom');\n\n    return L.map(this.mapContainer!, {\n      center: [center[1], center[0]], // Convert [lng, lat] to [lat, lng]\n      zoom,\n      zoomControl: false,\n    });\n  }\n\n  async initialize(): Promise&lt;void&gt; {\n    this.createMapContainer();\n    this.map = this.createMap();\n    this.setupModelListeners();\n    this.setupMapEvents();\n    this.isMapReady = true;\n    this.processPendingCalls();\n  }\n}\n</code></pre>"},{"location":"typescript/examples/leaflet/#key-methods","title":"Key Methods","text":""},{"location":"typescript/examples/leaflet/#adding-markers","title":"Adding Markers","text":"<pre><code>private handleAddMarker(args: unknown[], kwargs: Record&lt;string, unknown&gt;): void {\n  const [lng, lat] = args as [number, number];\n  const id = kwargs.id as string || `marker-${Date.now()}`;\n  const popup = kwargs.popup as string;\n\n  // Note: Leaflet uses [lat, lng] order\n  const marker = L.marker([lat, lng]);\n\n  if (popup) {\n    marker.bindPopup(popup);\n  }\n\n  marker.addTo(this.map);\n  this.markersMap.set(id, marker);\n}\n</code></pre>"},{"location":"typescript/examples/leaflet/#adding-geojson","title":"Adding GeoJSON","text":"<pre><code>private handleAddGeoJSON(args: unknown[], kwargs: Record&lt;string, unknown&gt;): void {\n  const geojson = kwargs.data as FeatureCollection;\n  const name = kwargs.name as string;\n  const style = kwargs.style as Record&lt;string, unknown&gt;;\n\n  const geoJsonLayer = L.geoJSON(geojson, {\n    style: (feature) =&gt; style || this.getDefaultStyle(feature.geometry.type),\n    pointToLayer: (feature, latlng) =&gt; {\n      return L.circleMarker(latlng, style || this.getDefaultStyle('Point'));\n    },\n  });\n\n  geoJsonLayer.addTo(this.map);\n  this.layersMap.set(name, geoJsonLayer);\n\n  // Optionally fit bounds\n  if (kwargs.fitBounds !== false) {\n    this.map.fitBounds(geoJsonLayer.getBounds());\n  }\n}\n</code></pre>"},{"location":"typescript/examples/leaflet/#navigation","title":"Navigation","text":"<pre><code>private handleFlyTo(args: unknown[], kwargs: Record&lt;string, unknown&gt;): void {\n  const [lng, lat] = args as [number, number];\n  const zoom = kwargs.zoom as number;\n  const duration = (kwargs.duration as number) || 2000;\n\n  // Leaflet's flyTo uses [lat, lng] and duration in seconds\n  this.map.flyTo([lat, lng], zoom || this.map.getZoom(), {\n    duration: duration / 1000,\n  });\n}\n\nprivate handleFitBounds(args: unknown[], kwargs: Record&lt;string, unknown&gt;): void {\n  const [bounds] = args as [[number, number, number, number]];\n\n  // Convert [west, south, east, north] to Leaflet bounds\n  const leafletBounds = L.latLngBounds(\n    [bounds[1], bounds[0]], // Southwest: [lat, lng]\n    [bounds[3], bounds[2]]  // Northeast: [lat, lng]\n  );\n\n  this.map.fitBounds(leafletBounds);\n}\n</code></pre>"},{"location":"typescript/examples/leaflet/#controls","title":"Controls","text":"<pre><code>private handleAddControl(args: unknown[], kwargs: Record&lt;string, unknown&gt;): void {\n  const [controlType] = args as [string];\n  const position = this.convertPosition(kwargs.position as string);\n\n  let control: L.Control;\n  switch (controlType) {\n    case 'zoom':\n      control = L.control.zoom({ position });\n      break;\n    case 'scale':\n      control = L.control.scale({ position, imperial: false });\n      break;\n    case 'layers':\n      control = L.control.layers({}, {}, { position });\n      break;\n  }\n\n  control.addTo(this.map);\n  this.controlsMap.set(controlType, control);\n}\n\n// Convert position from MapLibre format to Leaflet format\nprivate convertPosition(position: string): L.ControlPosition {\n  const map: Record&lt;string, L.ControlPosition&gt; = {\n    'top-left': 'topleft',\n    'top-right': 'topright',\n    'bottom-left': 'bottomleft',\n    'bottom-right': 'bottomright',\n  };\n  return map[position] || 'topright';\n}\n</code></pre>"},{"location":"typescript/examples/leaflet/#default-styles","title":"Default Styles","text":"<pre><code>private getDefaultStyle(geometryType: string): Record&lt;string, unknown&gt; {\n  const defaults = {\n    Point: {\n      radius: 8,\n      fillColor: '#3388ff',\n      color: '#ffffff',\n      weight: 2,\n      fillOpacity: 0.8,\n    },\n    LineString: {\n      color: '#3388ff',\n      weight: 3,\n      opacity: 0.8,\n    },\n    Polygon: {\n      fillColor: '#3388ff',\n      color: '#0000ff',\n      weight: 2,\n      fillOpacity: 0.5,\n    },\n  };\n  return defaults[geometryType] || defaults.Point;\n}\n</code></pre>"},{"location":"typescript/examples/leaflet/#source-files","title":"Source Files","text":"<ul> <li>Renderer: <code>src/leaflet/LeafletRenderer.ts</code></li> <li>Types: <code>src/types/leaflet.ts</code></li> </ul> <p>See also: Python notebook example</p>"},{"location":"typescript/examples/mapbox/","title":"Mapbox GL JS","text":"<p>Mapbox GL JS is a commercial vector tile mapping library. Requires an access token.</p>"},{"location":"typescript/examples/mapbox/#python-example","title":"Python Example","text":"<pre><code>import os\nfrom anymap_ts import MapboxMap\n\nm = MapboxMap(center=[-122.4, 37.8], zoom=10)\nm.add_basemap(\"OpenStreetMap\")\nm.add_geojson(geojson, name=\"cities\")\nm.fly_to(-122.4194, 37.7749, zoom=12)\nm\n</code></pre> <p>Note: Set the <code>MAPBOX_TOKEN</code> environment variable or pass <code>access_token</code> to the constructor.</p>"},{"location":"typescript/examples/mapbox/#typescript-implementation","title":"TypeScript Implementation","text":"<p>The <code>MapboxRenderer</code> extends <code>MapLibreRenderer</code> since Mapbox GL JS has a similar API:</p> <pre><code>import mapboxgl from 'mapbox-gl';\nimport { BaseMapRenderer } from '../core/BaseMapRenderer';\nimport type { MapWidgetModel } from '../types/anywidget';\n\nexport class MapboxRenderer extends BaseMapRenderer&lt;mapboxgl.Map&gt; {\n  constructor(model: MapWidgetModel, el: HTMLElement) {\n    super(model, el);\n\n    // Set access token\n    const token = model.get('access_token') as string;\n    if (token) {\n      mapboxgl.accessToken = token;\n    }\n\n    this.registerMethods();\n  }\n\n  protected createMap(): mapboxgl.Map {\n    const center = this.model.get('center') as [number, number];\n    const zoom = this.model.get('zoom');\n    const style = this.model.get('style') as string || 'mapbox://styles/mapbox/streets-v12';\n\n    return new mapboxgl.Map({\n      container: this.mapContainer!,\n      style,\n      center,\n      zoom,\n    });\n  }\n\n  async initialize(): Promise&lt;void&gt; {\n    this.createMapContainer();\n    this.map = this.createMap();\n    this.setupModelListeners();\n    this.setupMapEvents();\n\n    await new Promise&lt;void&gt;((resolve) =&gt; {\n      this.map!.on('load', () =&gt; {\n        this.isMapReady = true;\n        this.processPendingCalls();\n        resolve();\n      });\n    });\n  }\n}\n</code></pre>"},{"location":"typescript/examples/mapbox/#key-methods","title":"Key Methods","text":""},{"location":"typescript/examples/mapbox/#adding-geojson","title":"Adding GeoJSON","text":"<pre><code>private handleAddGeoJSON(args: unknown[], kwargs: Record&lt;string, unknown&gt;): void {\n  const geojson = kwargs.data as FeatureCollection;\n  const name = kwargs.name as string;\n  const sourceId = `${name}-source`;\n\n  // Add source\n  this.map.addSource(sourceId, {\n    type: 'geojson',\n    data: geojson,\n  });\n\n  // Determine layer type\n  const layerType = this.inferLayerType(geojson);\n\n  // Add layer\n  this.map.addLayer({\n    id: name,\n    type: layerType,\n    source: sourceId,\n    paint: this.getDefaultPaint(layerType),\n  });\n}\n</code></pre>"},{"location":"typescript/examples/mapbox/#navigation","title":"Navigation","text":"<pre><code>private handleFlyTo(args: unknown[], kwargs: Record&lt;string, unknown&gt;): void {\n  const [lng, lat] = args as [number, number];\n\n  this.map.flyTo({\n    center: [lng, lat],\n    zoom: kwargs.zoom as number,\n    bearing: kwargs.bearing as number,\n    pitch: kwargs.pitch as number,\n    duration: kwargs.duration as number || 2000,\n  });\n}\n</code></pre>"},{"location":"typescript/examples/mapbox/#mapbox-specific-features","title":"Mapbox-Specific Features","text":""},{"location":"typescript/examples/mapbox/#3d-terrain","title":"3D Terrain","text":"<pre><code>private handleSetTerrain(args: unknown[], kwargs: Record&lt;string, unknown&gt;): void {\n  // Add terrain source\n  this.map.addSource('mapbox-dem', {\n    type: 'raster-dem',\n    url: 'mapbox://mapbox.mapbox-terrain-dem-v1',\n    tileSize: 512,\n    maxzoom: 14,\n  });\n\n  // Enable terrain\n  this.map.setTerrain({\n    source: 'mapbox-dem',\n    exaggeration: kwargs.exaggeration as number || 1.5,\n  });\n\n  // Add sky layer\n  this.map.addLayer({\n    id: 'sky',\n    type: 'sky',\n    paint: {\n      'sky-type': 'atmosphere',\n    },\n  });\n}\n</code></pre>"},{"location":"typescript/examples/mapbox/#3d-buildings","title":"3D Buildings","text":"<pre><code>private handleAdd3DBuildings(args: unknown[], kwargs: Record&lt;string, unknown&gt;): void {\n  this.map.addLayer({\n    id: '3d-buildings',\n    source: 'composite',\n    'source-layer': 'building',\n    filter: ['==', 'extrude', 'true'],\n    type: 'fill-extrusion',\n    minzoom: 15,\n    paint: {\n      'fill-extrusion-color': '#aaa',\n      'fill-extrusion-height': ['get', 'height'],\n      'fill-extrusion-base': ['get', 'min_height'],\n      'fill-extrusion-opacity': 0.6,\n    },\n  });\n}\n</code></pre>"},{"location":"typescript/examples/mapbox/#source-files","title":"Source Files","text":"<ul> <li>Renderer: <code>src/mapbox/MapboxRenderer.ts</code></li> <li>Types: <code>src/types/mapbox.ts</code></li> </ul> <p>See also: Python notebook example</p>"},{"location":"typescript/examples/maplibre/","title":"MapLibre GL JS","text":"<p>MapLibre GL JS is the default renderer in anymap-ts, providing vector tile maps with drawing and layer control capabilities.</p>"},{"location":"typescript/examples/maplibre/#python-example","title":"Python Example","text":"<pre><code>from anymap_ts import Map\n\nm = Map(center=[-122.4, 37.8], zoom=10)\nm.add_basemap(\"OpenStreetMap\")\nm.add_draw_control(position=\"top-left\")\nm.add_layer_control()\nm\n</code></pre>"},{"location":"typescript/examples/maplibre/#typescript-implementation","title":"TypeScript Implementation","text":"<p>The <code>MapLibreRenderer</code> class extends <code>BaseMapRenderer</code> and provides comprehensive map functionality:</p> <pre><code>import maplibregl, { Map as MapLibreMap } from 'maplibre-gl';\nimport { BaseMapRenderer } from '../core/BaseMapRenderer';\nimport type { MapWidgetModel, RenderContext } from '../types/anywidget';\n\nexport class MapLibreRenderer extends BaseMapRenderer&lt;MapLibreMap&gt; {\n  constructor(model: MapWidgetModel, el: HTMLElement) {\n    super(model, el);\n    this.registerMethods();\n  }\n\n  async initialize(): Promise&lt;void&gt; {\n    this.createMapContainer();\n    this.map = this.createMap();\n    this.setupModelListeners();\n    this.setupMapEvents();\n\n    await new Promise&lt;void&gt;((resolve) =&gt; {\n      this.map!.on('load', () =&gt; {\n        this.isMapReady = true;\n        this.processPendingCalls();\n        resolve();\n      });\n    });\n  }\n\n  protected createMap(): MapLibreMap {\n    const center = this.model.get('center');\n    const zoom = this.model.get('zoom');\n\n    return new MapLibreMap({\n      container: this.mapContainer!,\n      style: this.model.get('style'),\n      center: center as [number, number],\n      zoom,\n    });\n  }\n}\n</code></pre>"},{"location":"typescript/examples/maplibre/#key-methods","title":"Key Methods","text":""},{"location":"typescript/examples/maplibre/#navigation","title":"Navigation","text":"<pre><code>// Set center position\nprivate handleSetCenter(args: unknown[]): void {\n  const [lng, lat] = args as [number, number];\n  this.map.setCenter([lng, lat]);\n}\n\n// Fly to location with animation\nprivate handleFlyTo(args: unknown[], kwargs: Record&lt;string, unknown&gt;): void {\n  const [lng, lat] = args as [number, number];\n  this.map.flyTo({\n    center: [lng, lat],\n    zoom: kwargs.zoom as number,\n    duration: kwargs.duration as number || 2000,\n  });\n}\n\n// Fit bounds\nprivate handleFitBounds(args: unknown[]): void {\n  const [bounds] = args as [[number, number, number, number]];\n  this.map.fitBounds([\n    [bounds[0], bounds[1]],\n    [bounds[2], bounds[3]],\n  ]);\n}\n</code></pre>"},{"location":"typescript/examples/maplibre/#adding-geojson","title":"Adding GeoJSON","text":"<pre><code>private handleAddGeoJSON(args: unknown[], kwargs: Record&lt;string, unknown&gt;): void {\n  const geojson = kwargs.data as FeatureCollection;\n  const name = kwargs.name as string;\n  const sourceId = `${name}-source`;\n\n  // Add source\n  this.map.addSource(sourceId, {\n    type: 'geojson',\n    data: geojson,\n  });\n\n  // Determine layer type from geometry\n  const layerType = this.inferLayerType(geojson.features[0].geometry.type);\n\n  // Add layer with default styling\n  this.map.addLayer({\n    id: name,\n    type: layerType,\n    source: sourceId,\n    paint: this.getDefaultPaint(layerType),\n  });\n}\n</code></pre>"},{"location":"typescript/examples/maplibre/#controls","title":"Controls","text":"<pre><code>// Add navigation, scale, or draw controls\nprivate handleAddControl(args: unknown[], kwargs: Record&lt;string, unknown&gt;): void {\n  const [controlType] = args as [string];\n  const position = kwargs.position as string || 'top-right';\n\n  let control: maplibregl.IControl;\n  switch (controlType) {\n    case 'navigation':\n      control = new maplibregl.NavigationControl();\n      break;\n    case 'scale':\n      control = new maplibregl.ScaleControl();\n      break;\n    case 'fullscreen':\n      control = new maplibregl.FullscreenControl();\n      break;\n  }\n\n  this.map.addControl(control, position);\n}\n</code></pre>"},{"location":"typescript/examples/maplibre/#draw-control","title":"Draw Control","text":"<pre><code>private handleAddDrawControl(args: unknown[], kwargs: Record&lt;string, unknown&gt;): void {\n  const position = kwargs.position as string || 'top-right';\n\n  this.geoEditorPlugin = new GeoEditorPlugin(this.map);\n  this.geoEditorPlugin.initialize({\n    position,\n    drawModes: kwargs.drawModes as string[],\n  }, (data: FeatureCollection) =&gt; {\n    // Sync drawn features to Python\n    this.model.set('_draw_data', data);\n    this.model.save_changes();\n  });\n}\n\n// Get drawn features\nprivate handleGetDrawData(): void {\n  const data = this.geoEditorPlugin.getFeatures();\n  this.model.set('_draw_data', data);\n  this.model.save_changes();\n}\n</code></pre>"},{"location":"typescript/examples/maplibre/#event-handling","title":"Event Handling","text":"<pre><code>private setupMapEvents(): void {\n  // Click event\n  this.map.on('click', (e) =&gt; {\n    this.sendEvent('click', {\n      lngLat: [e.lngLat.lng, e.lngLat.lat],\n      point: [e.point.x, e.point.y],\n    });\n  });\n\n  // Move end event\n  this.map.on('moveend', () =&gt; {\n    const center = this.map.getCenter();\n    this.model.set('current_center', [center.lng, center.lat]);\n    this.model.set('current_zoom', this.map.getZoom());\n    this.model.save_changes();\n  });\n}\n</code></pre>"},{"location":"typescript/examples/maplibre/#source-files","title":"Source Files","text":"<ul> <li>Renderer: <code>src/maplibre/MapLibreRenderer.ts</code></li> <li>Plugins: <code>src/maplibre/plugins/GeoEditorPlugin.ts</code>, <code>LayerControlPlugin.ts</code></li> <li>Types: <code>src/types/maplibre.ts</code></li> </ul> <p>See also: Python notebook example</p>"},{"location":"typescript/examples/openlayers/","title":"OpenLayers","text":"<p>OpenLayers is a high-performance library with excellent WMS/WMTS support and projection handling.</p>"},{"location":"typescript/examples/openlayers/#python-example","title":"Python Example","text":"<pre><code>from anymap_ts import OpenLayersMap\n\nm = OpenLayersMap(center=[-122.4, 37.8], zoom=10)\nm.add_basemap(\"OpenStreetMap\")\nm.add_geojson(geojson, name=\"cities\", style={\"fillColor\": \"rgba(255, 0, 0, 0.8)\", \"strokeColor\": \"#ffffff\", \"radius\": 8})\nm.add_marker(-122.4194, 37.7749, color=\"#ff0000\")\nm.fly_to(-122.4194, 37.7749, zoom=14)\nm\n</code></pre>"},{"location":"typescript/examples/openlayers/#typescript-implementation","title":"TypeScript Implementation","text":"<p>The <code>OpenLayersRenderer</code> wraps the OpenLayers API:</p> <pre><code>import Map from 'ol/Map';\nimport View from 'ol/View';\nimport TileLayer from 'ol/layer/Tile';\nimport VectorLayer from 'ol/layer/Vector';\nimport VectorSource from 'ol/source/Vector';\nimport OSM from 'ol/source/OSM';\nimport XYZ from 'ol/source/XYZ';\nimport GeoJSON from 'ol/format/GeoJSON';\nimport { fromLonLat, toLonLat } from 'ol/proj';\n\nexport class OpenLayersRenderer extends BaseMapRenderer&lt;Map&gt; {\n  private layersMap: Map&lt;string, Layer&gt; = new Map();\n\n  protected createMap(): Map {\n    const center = this.model.get('center') as [number, number];\n    const zoom = this.model.get('zoom');\n\n    return new Map({\n      target: this.mapContainer!,\n      view: new View({\n        center: fromLonLat(center), // Convert to EPSG:3857\n        zoom,\n      }),\n    });\n  }\n}\n</code></pre>"},{"location":"typescript/examples/openlayers/#key-methods","title":"Key Methods","text":""},{"location":"typescript/examples/openlayers/#adding-geojson","title":"Adding GeoJSON","text":"<pre><code>private handleAddGeoJSON(args: unknown[], kwargs: Record&lt;string, unknown&gt;): void {\n  const geojson = kwargs.data as FeatureCollection;\n  const name = kwargs.name as string;\n  const style = kwargs.style as Record&lt;string, unknown&gt;;\n\n  // Parse GeoJSON\n  const features = new GeoJSON().readFeatures(geojson, {\n    featureProjection: 'EPSG:3857', // Reproject to map projection\n  });\n\n  // Create vector source and layer\n  const source = new VectorSource({ features });\n  const layer = new VectorLayer({\n    source,\n    style: this.createStyle(style),\n  });\n\n  this.map.addLayer(layer);\n  this.layersMap.set(name, layer);\n\n  // Fit to extent\n  if (kwargs.fitBounds !== false) {\n    this.map.getView().fit(source.getExtent(), { padding: [50, 50, 50, 50] });\n  }\n}\n</code></pre>"},{"location":"typescript/examples/openlayers/#styling","title":"Styling","text":"<pre><code>private createStyle(options?: Record&lt;string, unknown&gt;): Style {\n  return new Style({\n    fill: new Fill({\n      color: options?.fillColor || 'rgba(51, 136, 255, 0.5)',\n    }),\n    stroke: new Stroke({\n      color: options?.strokeColor || '#3388ff',\n      width: options?.strokeWidth || 2,\n    }),\n    image: new Circle({\n      radius: options?.radius || 8,\n      fill: new Fill({ color: options?.fillColor || '#3388ff' }),\n      stroke: new Stroke({ color: options?.strokeColor || '#ffffff', width: 2 }),\n    }),\n  });\n}\n</code></pre>"},{"location":"typescript/examples/openlayers/#navigation","title":"Navigation","text":"<pre><code>private handleFlyTo(args: unknown[], kwargs: Record&lt;string, unknown&gt;): void {\n  const [lng, lat] = args as [number, number];\n  const zoom = kwargs.zoom as number;\n  const duration = kwargs.duration as number || 2000;\n\n  this.map.getView().animate({\n    center: fromLonLat([lng, lat]),\n    zoom: zoom || this.map.getView().getZoom(),\n    duration,\n  });\n}\n</code></pre>"},{"location":"typescript/examples/openlayers/#markers","title":"Markers","text":"<pre><code>private handleAddMarker(args: unknown[], kwargs: Record&lt;string, unknown&gt;): void {\n  const [lng, lat] = args as [number, number];\n  const id = kwargs.id as string || `marker-${Date.now()}`;\n  const color = kwargs.color as string || '#3388ff';\n\n  const feature = new Feature({\n    geometry: new Point(fromLonLat([lng, lat])),\n  });\n\n  feature.setStyle(new Style({\n    image: new Circle({\n      radius: 8,\n      fill: new Fill({ color }),\n      stroke: new Stroke({ color: '#ffffff', width: 2 }),\n    }),\n  }));\n\n  const source = new VectorSource({ features: [feature] });\n  const layer = new VectorLayer({ source });\n\n  this.map.addLayer(layer);\n  this.markersMap.set(id, layer);\n}\n</code></pre>"},{"location":"typescript/examples/openlayers/#wms-layers","title":"WMS Layers","text":"<pre><code>private handleAddWMSLayer(args: unknown[], kwargs: Record&lt;string, unknown&gt;): void {\n  const url = kwargs.url as string;\n  const layers = kwargs.layers as string;\n  const name = kwargs.name as string;\n\n  const layer = new TileLayer({\n    source: new TileWMS({\n      url,\n      params: {\n        LAYERS: layers,\n        TILED: true,\n      },\n    }),\n  });\n\n  this.map.addLayer(layer);\n  this.layersMap.set(name, layer);\n}\n</code></pre>"},{"location":"typescript/examples/openlayers/#coordinate-system","title":"Coordinate System","text":"<p>OpenLayers uses EPSG:3857 (Web Mercator) internally. Convert coordinates:</p> <pre><code>import { fromLonLat, toLonLat } from 'ol/proj';\n\n// To OpenLayers (EPSG:4326 -&gt; EPSG:3857)\nconst olCoord = fromLonLat([-122.4, 37.8]);\n\n// From OpenLayers (EPSG:3857 -&gt; EPSG:4326)\nconst lngLat = toLonLat(olCoord);\n</code></pre>"},{"location":"typescript/examples/openlayers/#source-files","title":"Source Files","text":"<ul> <li>Renderer: <code>src/openlayers/OpenLayersRenderer.ts</code></li> <li>Types: <code>src/types/openlayers.ts</code></li> </ul> <p>See also: Python notebook example</p>"},{"location":"typescript/examples/pointcloud_layer/","title":"Point Cloud Layer","text":"<p>The DeckGL PointCloudLayer renders 3D point cloud data, ideal for visualizing LiDAR scans, 3D models, and elevation data.</p>"},{"location":"typescript/examples/pointcloud_layer/#python-example","title":"Python Example","text":"<pre><code>import random\nfrom anymap_ts import MapLibreMap\n\n# Generate sample 3D point cloud\npoints = [\n    {\n        \"position\": [-122.4 + random.uniform(-0.01, 0.01),\n                     37.8 + random.uniform(-0.01, 0.01),\n                     random.uniform(0, 500)],\n        \"color\": [255, int(random.uniform(0, 255)), 0, 255]\n    }\n    for _ in range(1000)\n]\n\nm = MapLibreMap(center=[-122.4, 37.8], zoom=14, pitch=60)\nm.add_basemap(\"CartoDB.DarkMatter\")\nm.add_point_cloud_layer(\n    data=points,\n    name=\"lidar-scan\",\n    get_position=\"position\",\n    get_color=\"color\",\n    point_size=3,\n    opacity=0.9,\n)\nm\n</code></pre>"},{"location":"typescript/examples/pointcloud_layer/#typescript-implementation","title":"TypeScript Implementation","text":"<p>The <code>handleAddPointCloudLayer</code> method creates deck.gl PointCloudLayer instances:</p> <pre><code>import { PointCloudLayer } from '@deck.gl/layers';\n\nprivate handleAddPointCloudLayer(args: unknown[], kwargs: Record&lt;string, unknown&gt;): void {\n  this.initializeDeckOverlay();\n  const id = kwargs.id as string || `pointcloud-${Date.now()}`;\n  const data = kwargs.data as unknown[];\n\n  const layer = new PointCloudLayer({\n    id,\n    data,\n    pickable: kwargs.pickable !== false,\n    opacity: kwargs.opacity as number ?? 1,\n    pointSize: kwargs.pointSize as number ?? 2,\n    sizeUnits: kwargs.sizeUnits as string ?? 'pixels',\n    getPosition: (d: any) =&gt; d[kwargs.getPosition as string] || d.position,\n    getNormal: kwargs.getNormal ?? [0, 0, 1],\n    getColor: (d: any) =&gt; {\n      const accessor = kwargs.getColor;\n      if (Array.isArray(accessor)) return accessor;\n      if (typeof accessor === 'string') return d[accessor] || [255, 255, 255, 255];\n      return [255, 255, 255, 255];\n    },\n    coordinateSystem: kwargs.coordinateSystem,\n    coordinateOrigin: kwargs.coordinateOrigin,\n  });\n\n  this.deckLayers.set(id, layer);\n  this.updateDeckOverlay();\n  this.deckLayerAdapter?.notifyLayerAdded(id);\n}\n</code></pre>"},{"location":"typescript/examples/pointcloud_layer/#layer-control-integration","title":"Layer Control Integration","text":"<p>Point cloud layers integrate with the layer control via <code>DeckLayerAdapter</code>:</p> <pre><code>// Layer IDs starting with 'pointcloud-' are managed by DeckLayerAdapter\ngetLayerIds(): string[] {\n  return Array.from(this.deckLayers.keys()).filter(id =&gt;\n    id.startsWith('arc-') || id.startsWith('pointcloud-')\n  );\n}\n\n// Adjust opacity by cloning the immutable deck.gl layer\nsetOpacity(layerId: string, opacity: number): void {\n  const layer = this.deckLayers.get(layerId);\n  if (layer &amp;&amp; typeof layer.clone === 'function') {\n    const updated = layer.clone({ opacity });\n    this.deckLayers.set(layerId, updated);\n    this.updateOverlay();\n  }\n}\n</code></pre>"},{"location":"typescript/examples/pointcloud_layer/#api-reference","title":"API Reference","text":""},{"location":"typescript/examples/pointcloud_layer/#parameters","title":"Parameters","text":"Parameter Type Default Description <code>data</code> <code>Array</code> required Array of point data objects <code>name</code> <code>string</code> auto-generated Layer identifier <code>get_position</code> <code>string</code> <code>\"position\"</code> Accessor for [x, y, z] position <code>get_color</code> <code>Array&lt;int&gt;</code> or <code>string</code> <code>[255, 255, 255, 255]</code> RGBA color or accessor <code>get_normal</code> <code>string</code> <code>[0, 0, 1]</code> Normal vector for lighting <code>point_size</code> <code>number</code> <code>2</code> Point size in size_units <code>size_units</code> <code>string</code> <code>\"pixels\"</code> <code>\"pixels\"</code> or <code>\"meters\"</code> <code>coordinate_system</code> <code>string</code> auto Coordinate system type <code>coordinate_origin</code> <code>Array</code> none Origin for offset coordinates <code>pickable</code> <code>bool</code> <code>true</code> Enable hover/click <code>opacity</code> <code>float</code> <code>1.0</code> Layer opacity"},{"location":"typescript/examples/pointcloud_layer/#data-format","title":"Data Format","text":"<p>Each point object should have position coordinates:</p> <pre><code>{\n  position: [x, y, z],  // [longitude, latitude, altitude] or [x, y, z]\n  color: [r, g, b, a],  // Optional RGBA color\n  normal: [nx, ny, nz]  // Optional normal vector\n}\n</code></pre>"},{"location":"typescript/examples/pointcloud_layer/#coordinate-systems","title":"Coordinate Systems","text":"<p>The <code>coordinate_system</code> parameter supports:</p> <ul> <li><code>CARTESIAN</code> - Local cartesian coordinates</li> <li><code>METER_OFFSETS</code> - Meter offsets from origin</li> <li><code>LNGLAT</code> - WGS84 longitude/latitude (default)</li> <li><code>LNGLAT_OFFSETS</code> - Lng/lat offsets from origin</li> </ul>"},{"location":"typescript/examples/pointcloud_layer/#source-files","title":"Source Files","text":"<ul> <li>MapLibre Handler: <code>src/maplibre/MapLibreRenderer.ts</code></li> <li>Mapbox Handler: <code>src/mapbox/MapboxRenderer.ts</code></li> <li>DeckGL Handler: <code>src/deckgl/DeckGLRenderer.ts</code></li> <li>Layer Adapter: <code>src/maplibre/adapters/DeckLayerAdapter.ts</code></li> </ul> <p>See also: Python notebook example</p>"},{"location":"typescript/examples/potree/","title":"Potree","text":"<p>Potree is a WebGL-based point cloud viewer for large-scale LiDAR datasets.</p>"},{"location":"typescript/examples/potree/#python-example","title":"Python Example","text":"<pre><code>from anymap_ts import PotreeViewer\n\nviewer = PotreeViewer(\n    point_budget=1000000,\n    point_size=1.0,\n    background=\"#1a1a2e\",\n    edl_enabled=True\n)\n\n# Adjust settings\nviewer.set_point_budget(2000000)\nviewer.set_point_size(1.5)\nviewer.set_edl(enabled=True, radius=1.8, strength=0.5)\n\n# Set camera\nviewer.set_camera_position(0, 0, 100)\nviewer.set_camera_target(0, 0, 0)\n\n# Add annotation\nviewer.add_annotation(position=(10, 20, 30), title=\"Point of Interest\", description=\"Important location\")\n\nviewer\n</code></pre>"},{"location":"typescript/examples/potree/#typescript-implementation","title":"TypeScript Implementation","text":"<p>Potree is loaded dynamically from CDN:</p> <pre><code>const POTREE_VERSION = '1.8.2';\nconst POTREE_BASE_URL = `https://unpkg.com/potree-core@${POTREE_VERSION}/build`;\n\nclass PotreeWidget {\n  private viewer: any = null;\n  private pointClouds: Map&lt;string, any&gt; = new Map();\n  private annotations: Map&lt;string, any&gt; = new Map();\n\n  async initialize(): Promise&lt;void&gt; {\n    await loadPotree();\n\n    const Potree = window.Potree;\n\n    // Create viewer\n    this.viewer = new Potree.Viewer(this.container);\n\n    // Configure settings\n    this.viewer.setPointBudget(this.model.get('point_budget') || 1000000);\n    this.viewer.setBackground(this.model.get('background') || '#1a1a2e');\n    this.viewer.setEDLEnabled(this.model.get('edl_enabled') !== false);\n\n    // Set initial camera position\n    const position = this.model.get('camera_position') || [0, 0, 100];\n    const target = this.model.get('camera_target') || [0, 0, 0];\n    this.viewer.scene.view.position.set(...position);\n    this.viewer.scene.view.lookAt(new Potree.Vector3(...target));\n  }\n}\n</code></pre>"},{"location":"typescript/examples/potree/#key-methods","title":"Key Methods","text":""},{"location":"typescript/examples/potree/#loading-point-clouds","title":"Loading Point Clouds","text":"<pre><code>async handle_loadPointCloud(args: unknown[], kwargs: Record&lt;string, unknown&gt;): Promise&lt;void&gt; {\n  const Potree = window.Potree;\n  const url = kwargs.url as string;\n  const name = kwargs.name as string;\n\n  const pointCloud = await Potree.loadPointCloud(url, name);\n\n  // Configure appearance\n  pointCloud.material.size = kwargs.pointSize as number || 1.0;\n  pointCloud.material.pointSizeType = kwargs.pointSizeType || Potree.PointSizeType.ADAPTIVE;\n  pointCloud.material.shape = kwargs.shape || Potree.PointShape.CIRCLE;\n\n  this.viewer.scene.addPointCloud(pointCloud);\n  this.pointClouds.set(name, pointCloud);\n\n  // Fit to point cloud bounds\n  this.viewer.fitToScreen();\n}\n</code></pre>"},{"location":"typescript/examples/potree/#visualization-settings","title":"Visualization Settings","text":"<pre><code>handle_setPointBudget(args: unknown[], kwargs: Record&lt;string, unknown&gt;): void {\n  const budget = args[0] as number;\n  this.viewer.setPointBudget(budget);\n}\n\nhandle_setPointSize(args: unknown[], kwargs: Record&lt;string, unknown&gt;): void {\n  const size = args[0] as number;\n  this.pointClouds.forEach((pc) =&gt; {\n    pc.material.size = size;\n  });\n}\n\nhandle_setEDL(args: unknown[], kwargs: Record&lt;string, unknown&gt;): void {\n  const enabled = kwargs.enabled as boolean ?? true;\n  const radius = kwargs.radius as number ?? 1.4;\n  const strength = kwargs.strength as number ?? 0.4;\n\n  this.viewer.setEDLEnabled(enabled);\n  this.viewer.setEDLRadius(radius);\n  this.viewer.setEDLStrength(strength);\n}\n\nhandle_setBackground(args: unknown[], kwargs: Record&lt;string, unknown&gt;): void {\n  const color = args[0] as string;\n  this.viewer.setBackground(color);\n}\n</code></pre>"},{"location":"typescript/examples/potree/#camera-control","title":"Camera Control","text":"<pre><code>handle_setCameraPosition(args: unknown[], kwargs: Record&lt;string, unknown&gt;): void {\n  const [x, y, z] = args as [number, number, number];\n  this.viewer.scene.view.position.set(x, y, z);\n}\n\nhandle_setCameraTarget(args: unknown[], kwargs: Record&lt;string, unknown&gt;): void {\n  const [x, y, z] = args as [number, number, number];\n  const Potree = window.Potree;\n  this.viewer.scene.view.lookAt(new Potree.Vector3(x, y, z));\n}\n</code></pre>"},{"location":"typescript/examples/potree/#annotations","title":"Annotations","text":"<pre><code>handle_addAnnotation(args: unknown[], kwargs: Record&lt;string, unknown&gt;): void {\n  const Potree = window.Potree;\n  const position = kwargs.position as [number, number, number];\n  const title = kwargs.title as string;\n  const description = kwargs.description as string;\n\n  const annotation = new Potree.Annotation({\n    position: new Potree.Vector3(...position),\n    title,\n    description,\n  });\n\n  this.viewer.scene.annotations.add(annotation);\n  this.annotations.set(title, annotation);\n}\n</code></pre>"},{"location":"typescript/examples/potree/#measurement-tools","title":"Measurement Tools","text":"<pre><code>handle_addMeasurementTool(args: unknown[], kwargs: Record&lt;string, unknown&gt;): void {\n  const Potree = window.Potree;\n  const type = args[0] as string;\n\n  let tool;\n  switch (type) {\n    case 'distance':\n      tool = new Potree.MeasuringTool(this.viewer);\n      break;\n    case 'area':\n      tool = new Potree.AreaTool(this.viewer);\n      break;\n    case 'volume':\n      tool = new Potree.VolumeTool(this.viewer);\n      break;\n    case 'height':\n      tool = new Potree.HeightTool(this.viewer);\n      break;\n  }\n\n  if (tool) {\n    tool.startInsertion();\n  }\n}\n</code></pre>"},{"location":"typescript/examples/potree/#eye-dome-lighting-edl","title":"Eye Dome Lighting (EDL)","text":"<p>EDL enhances depth perception in point clouds:</p> <pre><code>// Enable EDL with custom settings\nthis.viewer.setEDLEnabled(true);\nthis.viewer.setEDLRadius(1.8);    // Light radius\nthis.viewer.setEDLStrength(0.5);  // Effect strength\n</code></pre>"},{"location":"typescript/examples/potree/#source-files","title":"Source Files","text":"<ul> <li>Widget: <code>src/potree/index.ts</code></li> <li>Types: <code>src/types/potree.ts</code></li> </ul> <p>See also: Python notebook example</p>"},{"location":"typescript/examples/zarr_layer/","title":"Zarr Layer","text":"<p>Zarr layers enable visualization of multi-dimensional scientific datasets with GPU acceleration.</p>"},{"location":"typescript/examples/zarr_layer/#python-example","title":"Python Example","text":"<pre><code>from anymap_ts import Map\n\nZARR_URL = \"https://carbonplan-maps.s3.us-west-2.amazonaws.com/v2/demo/4d/tavg-prec-month\"\n\nm = Map(center=[-100, 40], zoom=3, style=\"dark-matter\")\n\nm.add_zarr_layer(\n    url=ZARR_URL,\n    variable=\"climate\",\n    name=\"climate-prec\",\n    clim=(0, 300),\n    colormap=[\"#f7fbff\", \"#deebf7\", \"#c6dbef\", \"#9ecae1\", \"#6baed6\", \"#4292c6\", \"#2171b5\", \"#08519c\", \"#08306b\"],\n    opacity=0.8,\n    selector={\"band\": \"prec\", \"month\": 1},\n    spatial_dimensions={\"lat\": \"y\", \"lon\": \"x\"},\n    zarr_version=2,\n)\nm\n</code></pre>"},{"location":"typescript/examples/zarr_layer/#typescript-implementation","title":"TypeScript Implementation","text":"<p>Zarr layers use the <code>@carbonplan/zarr-layer</code> package:</p> <pre><code>import { ZarrLayer } from '@carbonplan/zarr-layer';\n\nprivate handleAddZarrLayer(args: unknown[], kwargs: Record&lt;string, unknown&gt;): void {\n  const id = kwargs.id as string || `zarr-${Date.now()}`;\n  const source = kwargs.source as string;\n  const variable = kwargs.variable as string;\n\n  const layer = new ZarrLayer({\n    id,\n    source,\n    variable,\n    clim: kwargs.clim as [number, number] || [0, 100],\n    colormap: kwargs.colormap as string[] || ['#000000', '#ffffff'],\n    selector: kwargs.selector as Record&lt;string, unknown&gt; || {},\n    opacity: kwargs.opacity as number ?? 1,\n    minzoom: kwargs.minzoom as number,\n    maxzoom: kwargs.maxzoom as number,\n    fillValue: kwargs.fillValue as number,\n    spatialDimensions: kwargs.spatialDimensions as { lat?: string; lon?: string },\n    zarrVersion: kwargs.zarrVersion as 2 | 3,\n    bounds: kwargs.bounds as [number, number, number, number],\n  });\n\n  this.map.addLayer(layer as unknown as maplibregl.CustomLayerInterface);\n  this.zarrLayers.set(id, layer);\n}\n</code></pre>"},{"location":"typescript/examples/zarr_layer/#updating-zarr-layer","title":"Updating Zarr Layer","text":"<pre><code>private handleUpdateZarrLayer(args: unknown[], kwargs: Record&lt;string, unknown&gt;): void {\n  const id = kwargs.id as string;\n  const layer = this.zarrLayers.get(id);\n  if (!layer) return;\n\n  // Update properties dynamically\n  if (kwargs.selector) layer.setSelector(kwargs.selector as Record&lt;string, number&gt;);\n  if (kwargs.clim) layer.setClim(kwargs.clim as [number, number]);\n  if (kwargs.colormap) layer.setColormap(kwargs.colormap as string[]);\n  if (kwargs.opacity !== undefined) layer.setOpacity(kwargs.opacity as number);\n}\n</code></pre>"},{"location":"typescript/examples/zarr_layer/#removing-zarr-layer","title":"Removing Zarr Layer","text":"<pre><code>private handleRemoveZarrLayer(args: unknown[], kwargs: Record&lt;string, unknown&gt;): void {\n  const [id] = args as [string];\n\n  if (this.map &amp;&amp; this.map.getLayer(id)) {\n    this.map.removeLayer(id);\n  }\n  this.zarrLayers.delete(id);\n}\n</code></pre>"},{"location":"typescript/examples/zarr_layer/#configuration-options","title":"Configuration Options","text":"Parameter Type Default Description <code>source</code> string required URL to the Zarr store <code>variable</code> string required Variable name in the Zarr dataset <code>id</code> string auto Layer identifier <code>colormap</code> string[] <code>['#000000', '#ffffff']</code> Hex color strings for visualization <code>clim</code> [number, number] <code>[0, 100]</code> Color scale limits (min, max) <code>opacity</code> number 1.0 Layer opacity (0-1) <code>selector</code> object <code>{}</code> Dimension selector (e.g., <code>{month: 4, band: \"tavg\"}</code>) <code>minzoom</code> number 0 Minimum zoom level for rendering <code>maxzoom</code> number 22 Maximum zoom level for rendering <code>fillValue</code> number auto No-data value <code>spatialDimensions</code> object auto Custom spatial dimension names <code>zarrVersion</code> number auto Zarr format version (2 or 3) <code>bounds</code> [number, number, number, number] auto Explicit bounds [west, south, east, north]"},{"location":"typescript/examples/zarr_layer/#dynamic-updates","title":"Dynamic Updates","text":"<p>Zarr layers support dynamic updates without recreating the layer:</p> <pre><code># Update selector (e.g., change month)\nm.update_zarr_layer(\n    layer_id=\"climate-prec\",\n    selector={\"band\": \"prec\", \"month\": 7},\n)\n\n# Update colormap and clim\nm.update_zarr_layer(\n    layer_id=\"climate-prec\",\n    selector={\"band\": \"tavg\", \"month\": 7},\n    clim=(-20, 30),\n    colormap=[\"#313695\", \"#4575b4\", \"#74add1\", \"#abd9e9\", \"#e0f3f8\", \"#ffffbf\", \"#fee090\", \"#fdae61\", \"#f46d43\", \"#d73027\", \"#a50026\"],\n)\n</code></pre>"},{"location":"typescript/examples/zarr_layer/#colormaps","title":"Colormaps","text":"<p>Common colormaps as hex arrays:</p> <pre><code>const colormaps = {\n  // Blues (precipitation)\n  blues: ['#f7fbff', '#deebf7', '#c6dbef', '#9ecae1', '#6baed6', '#4292c6', '#2171b5', '#08519c', '#08306b'],\n\n  // RdYlBu (temperature)\n  rdylbu: ['#313695', '#4575b4', '#74add1', '#abd9e9', '#e0f3f8', '#ffffbf', '#fee090', '#fdae61', '#f46d43', '#d73027', '#a50026'],\n\n  // Inferno (general)\n  inferno: ['#000004', '#1b0c41', '#4a0c6b', '#781c6d', '#a52c60', '#cf4446', '#ed6925', '#fb9b06', '#f7d13d', '#fcffa4'],\n};\n</code></pre>"},{"location":"typescript/examples/zarr_layer/#sample-datasets","title":"Sample Datasets","text":"Dataset URL Variable Description 4D Climate <code>carbonplan-maps.s3.../v2/demo/4d/tavg-prec-month</code> climate Temp/precip by month Ocean Temp <code>atlantis-vis-o.s3-ext.../tos_con</code> tos_con v3 pyramid, EPSG:3857 Burn Prob <code>carbonplan-share.s3.../13-lvl-30m-4326-scott-BP.zarr</code> BP 30m resolution CONUS"},{"location":"typescript/examples/zarr_layer/#source-files","title":"Source Files","text":"<ul> <li>MapLibre Implementation: <code>src/maplibre/MapLibreRenderer.ts</code></li> <li>Layer Adapter: <code>src/maplibre/adapters/ZarrLayerAdapter.ts</code></li> </ul> <p>See also: Python notebook example</p>"}]}