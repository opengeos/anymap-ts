{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"anymap-ts","text":"<p>A Python package for creating interactive maps with anywidget and TypeScript</p> <ul> <li>GitHub repo: https://github.com/opengeos/anymap-ts</li> <li>Documentation: https://ts.anymap.dev</li> <li>PyPI: https://pypi.org/project/anymap-ts</li> <li>Free software: MIT License</li> </ul>"},{"location":"#features","title":"Features","text":"<ul> <li>Interactive maps in Jupyter notebooks</li> <li>Bidirectional Python-JavaScript communication via anywidget</li> <li>Drawing and geometry editing with maplibre-gl-geo-editor</li> <li>Layer control with maplibre-gl-layer-control</li> <li>Multiple basemap providers via xyzservices</li> <li>Export to standalone HTML</li> <li>TypeScript-based frontend for type safety and maintainability</li> </ul>"},{"location":"#supported-libraries","title":"Supported Libraries","text":"Library Description Use Case MapLibre GL JS Open-source vector maps Default, general-purpose mapping Mapbox GL JS Commercial vector maps Advanced styling, 3D terrain Leaflet Lightweight, mobile-friendly Simple maps, broad compatibility OpenLayers Feature-rich, enterprise WMS/WMTS, projections DeckGL GPU-accelerated Large-scale data visualization Cesium 3D globe 3D Tiles, terrain, global views KeplerGL Data exploration Interactive data analysis Potree Point clouds LiDAR visualization"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install anymap-ts\n</code></pre>"},{"location":"#quick-start","title":"Quick Start","text":"<pre><code>from anymap_ts import Map\n\n# Create a map centered on a location\nm = Map(center=[-122.4, 37.8], zoom=10)\nm.add_basemap(\"OpenStreetMap\")\nm.add_draw_control()\nm\n</code></pre>"},{"location":"anymap_ts/","title":"anymap_ts module","text":""},{"location":"anymap_ts/#anymap_ts.base","title":"<code>base</code>","text":"<p>Base MapWidget class for all map implementations.</p>"},{"location":"anymap_ts/#anymap_ts.base.MapWidget","title":"<code> MapWidget            (AnyWidget)         </code>","text":"<p>Base class for interactive map widgets.</p> <p>This class provides the core functionality for Python-JavaScript communication using anywidget's traitlet synchronization system.</p> Source code in <code>anymap_ts/base.py</code> <pre><code>class MapWidget(anywidget.AnyWidget):\n    \"\"\"Base class for interactive map widgets.\n\n    This class provides the core functionality for Python-JavaScript communication\n    using anywidget's traitlet synchronization system.\n    \"\"\"\n\n    # Synchronized traits for map state\n    center = traitlets.List([0.0, 0.0]).tag(sync=True)\n    zoom = traitlets.Float(2.0).tag(sync=True)\n    width = traitlets.Unicode(\"100%\").tag(sync=True)\n    height = traitlets.Unicode(\"400px\").tag(sync=True)\n    style = traitlets.Union([traitlets.Unicode(), traitlets.Dict()]).tag(sync=True)\n    max_pitch = traitlets.Float(85.0).tag(sync=True)\n\n    # JavaScript method call queue\n    _js_calls = traitlets.List([]).tag(sync=True)\n    _js_method_counter = traitlets.Int(0)\n\n    # Events from JavaScript\n    _js_events = traitlets.List([]).tag(sync=True)\n\n    # State persistence for layers, sources, and controls\n    _layers = traitlets.Dict({}).tag(sync=True)\n    _sources = traitlets.Dict({}).tag(sync=True)\n    _controls = traitlets.Dict({}).tag(sync=True)\n\n    # Interaction state\n    clicked = traitlets.Dict({}).tag(sync=True)\n    current_bounds = traitlets.List([]).tag(sync=True)\n    current_center = traitlets.List([]).tag(sync=True)\n    current_zoom = traitlets.Float(0.0).tag(sync=True)\n\n    # Drawing data\n    _draw_data = traitlets.Dict({}).tag(sync=True)\n\n    def __init__(self, **kwargs):\n        \"\"\"Initialize the MapWidget.\n\n        Args:\n            **kwargs: Additional widget arguments\n        \"\"\"\n        super().__init__(**kwargs)\n        self._event_handlers: Dict[str, List[Callable]] = {}\n        self.observe(self._handle_js_events, names=[\"_js_events\"])\n\n    def _handle_js_events(self, change: Dict[str, Any]) -&gt; None:\n        \"\"\"Process events received from JavaScript.\n\n        Args:\n            change: Traitlet change dict\n        \"\"\"\n        events = change.get(\"new\", [])\n        for event in events:\n            event_type = event.get(\"type\")\n            if event_type in self._event_handlers:\n                for handler in self._event_handlers[event_type]:\n                    try:\n                        handler(event.get(\"data\"))\n                    except Exception as e:\n                        print(f\"Error in event handler for {event_type}: {e}\")\n        # Clear processed events\n        self._js_events = []\n\n    def call_js_method(self, method: str, *args, **kwargs) -&gt; None:\n        \"\"\"Queue a JavaScript method call.\n\n        Args:\n            method: Name of the JavaScript method to call\n            *args: Positional arguments for the method\n            **kwargs: Keyword arguments for the method\n        \"\"\"\n        self._js_method_counter += 1\n        call = {\n            \"id\": self._js_method_counter,\n            \"method\": method,\n            \"args\": list(args),\n            \"kwargs\": kwargs,\n        }\n        self._js_calls = self._js_calls + [call]\n\n    def on_map_event(self, event_type: str, handler: Callable) -&gt; None:\n        \"\"\"Register an event handler.\n\n        Args:\n            event_type: Type of event (e.g., 'click', 'moveend')\n            handler: Callback function to handle the event\n        \"\"\"\n        if event_type not in self._event_handlers:\n            self._event_handlers[event_type] = []\n        self._event_handlers[event_type].append(handler)\n\n    def off_map_event(\n        self, event_type: str, handler: Optional[Callable] = None\n    ) -&gt; None:\n        \"\"\"Unregister an event handler.\n\n        Args:\n            event_type: Type of event\n            handler: Specific handler to remove. If None, removes all handlers.\n        \"\"\"\n        if event_type in self._event_handlers:\n            if handler is None:\n                del self._event_handlers[event_type]\n            else:\n                self._event_handlers[event_type] = [\n                    h for h in self._event_handlers[event_type] if h != handler\n                ]\n\n    def set_center(self, lng: float, lat: float) -&gt; None:\n        \"\"\"Set the map center.\n\n        Args:\n            lng: Longitude\n            lat: Latitude\n        \"\"\"\n        self.center = [lng, lat]\n\n    def set_zoom(self, zoom: float) -&gt; None:\n        \"\"\"Set the map zoom level.\n\n        Args:\n            zoom: Zoom level\n        \"\"\"\n        self.zoom = zoom\n\n    def fly_to(\n        self,\n        lng: float,\n        lat: float,\n        zoom: Optional[float] = None,\n        duration: int = 2000,\n    ) -&gt; None:\n        \"\"\"Fly to a location with animation.\n\n        Args:\n            lng: Longitude\n            lat: Latitude\n            zoom: Optional zoom level\n            duration: Animation duration in milliseconds\n        \"\"\"\n        self.call_js_method(\"flyTo\", lng, lat, zoom=zoom, duration=duration)\n\n    def fit_bounds(\n        self,\n        bounds: List[float],\n        padding: int = 50,\n        duration: int = 1000,\n    ) -&gt; None:\n        \"\"\"Fit the map to the given bounds.\n\n        Args:\n            bounds: [west, south, east, north] bounds\n            padding: Padding in pixels\n            duration: Animation duration in milliseconds\n        \"\"\"\n        self.call_js_method(\"fitBounds\", bounds, padding=padding, duration=duration)\n\n    @property\n    def viewstate(self) -&gt; Dict[str, Any]:\n        \"\"\"Get current view state.\"\"\"\n        return {\n            \"center\": self.current_center or self.center,\n            \"zoom\": self.current_zoom or self.zoom,\n            \"bounds\": self.current_bounds,\n        }\n\n    def _generate_html_template(self) -&gt; str:\n        \"\"\"Generate HTML template for standalone export.\n\n        Override in subclasses for library-specific templates.\n        \"\"\"\n        raise NotImplementedError(\"Subclasses must implement _generate_html_template\")\n\n    def to_html(\n        self,\n        filepath: Optional[Union[str, Path]] = None,\n        title: str = \"Interactive Map\",\n    ) -&gt; Optional[str]:\n        \"\"\"Export map to standalone HTML file.\n\n        Args:\n            filepath: Path to save the HTML file. If None, returns HTML string.\n            title: Title for the HTML page.\n\n        Returns:\n            HTML string if filepath is None, otherwise None.\n        \"\"\"\n        html = self._generate_html_template()\n        html = html.replace(\"{{title}}\", title)\n\n        if filepath:\n            Path(filepath).write_text(html, encoding=\"utf-8\")\n            return None\n        return html\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.base.MapWidget.viewstate","title":"<code>viewstate: Dict[str, Any]</code>  <code>property</code> <code>readonly</code>","text":"<p>Get current view state.</p>"},{"location":"anymap_ts/#anymap_ts.base.MapWidget.__init__","title":"<code>__init__(self, **kwargs)</code>  <code>special</code>","text":"<p>Initialize the MapWidget.</p> <p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <p>Additional widget arguments</p> <code>{}</code> Source code in <code>anymap_ts/base.py</code> <pre><code>def __init__(self, **kwargs):\n    \"\"\"Initialize the MapWidget.\n\n    Args:\n        **kwargs: Additional widget arguments\n    \"\"\"\n    super().__init__(**kwargs)\n    self._event_handlers: Dict[str, List[Callable]] = {}\n    self.observe(self._handle_js_events, names=[\"_js_events\"])\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.base.MapWidget.call_js_method","title":"<code>call_js_method(self, method, *args, **kwargs)</code>","text":"<p>Queue a JavaScript method call.</p> <p>Parameters:</p> Name Type Description Default <code>method</code> <code>str</code> <p>Name of the JavaScript method to call</p> required <code>*args</code> <p>Positional arguments for the method</p> <code>()</code> <code>**kwargs</code> <p>Keyword arguments for the method</p> <code>{}</code> Source code in <code>anymap_ts/base.py</code> <pre><code>def call_js_method(self, method: str, *args, **kwargs) -&gt; None:\n    \"\"\"Queue a JavaScript method call.\n\n    Args:\n        method: Name of the JavaScript method to call\n        *args: Positional arguments for the method\n        **kwargs: Keyword arguments for the method\n    \"\"\"\n    self._js_method_counter += 1\n    call = {\n        \"id\": self._js_method_counter,\n        \"method\": method,\n        \"args\": list(args),\n        \"kwargs\": kwargs,\n    }\n    self._js_calls = self._js_calls + [call]\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.base.MapWidget.fit_bounds","title":"<code>fit_bounds(self, bounds, padding=50, duration=1000)</code>","text":"<p>Fit the map to the given bounds.</p> <p>Parameters:</p> Name Type Description Default <code>bounds</code> <code>List[float]</code> <p>[west, south, east, north] bounds</p> required <code>padding</code> <code>int</code> <p>Padding in pixels</p> <code>50</code> <code>duration</code> <code>int</code> <p>Animation duration in milliseconds</p> <code>1000</code> Source code in <code>anymap_ts/base.py</code> <pre><code>def fit_bounds(\n    self,\n    bounds: List[float],\n    padding: int = 50,\n    duration: int = 1000,\n) -&gt; None:\n    \"\"\"Fit the map to the given bounds.\n\n    Args:\n        bounds: [west, south, east, north] bounds\n        padding: Padding in pixels\n        duration: Animation duration in milliseconds\n    \"\"\"\n    self.call_js_method(\"fitBounds\", bounds, padding=padding, duration=duration)\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.base.MapWidget.fly_to","title":"<code>fly_to(self, lng, lat, zoom=None, duration=2000)</code>","text":"<p>Fly to a location with animation.</p> <p>Parameters:</p> Name Type Description Default <code>lng</code> <code>float</code> <p>Longitude</p> required <code>lat</code> <code>float</code> <p>Latitude</p> required <code>zoom</code> <code>Optional[float]</code> <p>Optional zoom level</p> <code>None</code> <code>duration</code> <code>int</code> <p>Animation duration in milliseconds</p> <code>2000</code> Source code in <code>anymap_ts/base.py</code> <pre><code>def fly_to(\n    self,\n    lng: float,\n    lat: float,\n    zoom: Optional[float] = None,\n    duration: int = 2000,\n) -&gt; None:\n    \"\"\"Fly to a location with animation.\n\n    Args:\n        lng: Longitude\n        lat: Latitude\n        zoom: Optional zoom level\n        duration: Animation duration in milliseconds\n    \"\"\"\n    self.call_js_method(\"flyTo\", lng, lat, zoom=zoom, duration=duration)\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.base.MapWidget.off_map_event","title":"<code>off_map_event(self, event_type, handler=None)</code>","text":"<p>Unregister an event handler.</p> <p>Parameters:</p> Name Type Description Default <code>event_type</code> <code>str</code> <p>Type of event</p> required <code>handler</code> <code>Optional[Callable]</code> <p>Specific handler to remove. If None, removes all handlers.</p> <code>None</code> Source code in <code>anymap_ts/base.py</code> <pre><code>def off_map_event(\n    self, event_type: str, handler: Optional[Callable] = None\n) -&gt; None:\n    \"\"\"Unregister an event handler.\n\n    Args:\n        event_type: Type of event\n        handler: Specific handler to remove. If None, removes all handlers.\n    \"\"\"\n    if event_type in self._event_handlers:\n        if handler is None:\n            del self._event_handlers[event_type]\n        else:\n            self._event_handlers[event_type] = [\n                h for h in self._event_handlers[event_type] if h != handler\n            ]\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.base.MapWidget.on_map_event","title":"<code>on_map_event(self, event_type, handler)</code>","text":"<p>Register an event handler.</p> <p>Parameters:</p> Name Type Description Default <code>event_type</code> <code>str</code> <p>Type of event (e.g., 'click', 'moveend')</p> required <code>handler</code> <code>Callable</code> <p>Callback function to handle the event</p> required Source code in <code>anymap_ts/base.py</code> <pre><code>def on_map_event(self, event_type: str, handler: Callable) -&gt; None:\n    \"\"\"Register an event handler.\n\n    Args:\n        event_type: Type of event (e.g., 'click', 'moveend')\n        handler: Callback function to handle the event\n    \"\"\"\n    if event_type not in self._event_handlers:\n        self._event_handlers[event_type] = []\n    self._event_handlers[event_type].append(handler)\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.base.MapWidget.set_center","title":"<code>set_center(self, lng, lat)</code>","text":"<p>Set the map center.</p> <p>Parameters:</p> Name Type Description Default <code>lng</code> <code>float</code> <p>Longitude</p> required <code>lat</code> <code>float</code> <p>Latitude</p> required Source code in <code>anymap_ts/base.py</code> <pre><code>def set_center(self, lng: float, lat: float) -&gt; None:\n    \"\"\"Set the map center.\n\n    Args:\n        lng: Longitude\n        lat: Latitude\n    \"\"\"\n    self.center = [lng, lat]\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.base.MapWidget.set_zoom","title":"<code>set_zoom(self, zoom)</code>","text":"<p>Set the map zoom level.</p> <p>Parameters:</p> Name Type Description Default <code>zoom</code> <code>float</code> <p>Zoom level</p> required Source code in <code>anymap_ts/base.py</code> <pre><code>def set_zoom(self, zoom: float) -&gt; None:\n    \"\"\"Set the map zoom level.\n\n    Args:\n        zoom: Zoom level\n    \"\"\"\n    self.zoom = zoom\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.base.MapWidget.to_html","title":"<code>to_html(self, filepath=None, title='Interactive Map')</code>","text":"<p>Export map to standalone HTML file.</p> <p>Parameters:</p> Name Type Description Default <code>filepath</code> <code>Optional[Union[str, Path]]</code> <p>Path to save the HTML file. If None, returns HTML string.</p> <code>None</code> <code>title</code> <code>str</code> <p>Title for the HTML page.</p> <code>'Interactive Map'</code> <p>Returns:</p> Type Description <code>Optional[str]</code> <p>HTML string if filepath is None, otherwise None.</p> Source code in <code>anymap_ts/base.py</code> <pre><code>def to_html(\n    self,\n    filepath: Optional[Union[str, Path]] = None,\n    title: str = \"Interactive Map\",\n) -&gt; Optional[str]:\n    \"\"\"Export map to standalone HTML file.\n\n    Args:\n        filepath: Path to save the HTML file. If None, returns HTML string.\n        title: Title for the HTML page.\n\n    Returns:\n        HTML string if filepath is None, otherwise None.\n    \"\"\"\n    html = self._generate_html_template()\n    html = html.replace(\"{{title}}\", title)\n\n    if filepath:\n        Path(filepath).write_text(html, encoding=\"utf-8\")\n        return None\n    return html\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.basemaps","title":"<code>basemaps</code>","text":"<p>Basemap provider utilities.</p>"},{"location":"anymap_ts/#anymap_ts.basemaps.get_basemap_names","title":"<code>get_basemap_names()</code>","text":"<p>Get list of available basemap names.</p> <p>Returns:</p> Type Description <code>list</code> <p>List of basemap provider names</p> Source code in <code>anymap_ts/basemaps.py</code> <pre><code>def get_basemap_names() -&gt; list:\n    \"\"\"Get list of available basemap names.\n\n    Returns:\n        List of basemap provider names\n    \"\"\"\n    return list(xyz.flatten().keys())\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.basemaps.get_basemap_url","title":"<code>get_basemap_url(name)</code>","text":"<p>Get tile URL and attribution for a named basemap.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Basemap provider name (e.g., \"OpenStreetMap\", \"CartoDB.Positron\")</p> required <p>Returns:</p> Type Description <code>Tuple[str, str]</code> <p>Tuple of (tile_url, attribution)</p> <p>Exceptions:</p> Type Description <code>ValueError</code> <p>If basemap name is not found</p> Source code in <code>anymap_ts/basemaps.py</code> <pre><code>def get_basemap_url(name: str) -&gt; Tuple[str, str]:\n    \"\"\"Get tile URL and attribution for a named basemap.\n\n    Args:\n        name: Basemap provider name (e.g., \"OpenStreetMap\", \"CartoDB.Positron\")\n\n    Returns:\n        Tuple of (tile_url, attribution)\n\n    Raises:\n        ValueError: If basemap name is not found\n    \"\"\"\n    # Handle shortcuts\n    if name in BASEMAP_SHORTCUTS:\n        name = BASEMAP_SHORTCUTS[name]\n\n    # Handle dot notation for nested providers\n    parts = name.split(\".\")\n    provider = xyz\n    for part in parts:\n        provider = getattr(provider, part, None)\n        if provider is None:\n            raise ValueError(f\"Unknown basemap: {name}\")\n\n    url = provider.build_url()\n    attribution = provider.get(\"attribution\", \"\")\n\n    return url, attribution\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.basemaps.get_maplibre_style","title":"<code>get_maplibre_style(name)</code>","text":"<p>Get MapLibre style URL by name.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Style name (e.g., \"positron\", \"dark-matter\")</p> required <p>Returns:</p> Type Description <code>str</code> <p>Style URL</p> <p>Exceptions:</p> Type Description <code>ValueError</code> <p>If style name is not found</p> Source code in <code>anymap_ts/basemaps.py</code> <pre><code>def get_maplibre_style(name: str) -&gt; str:\n    \"\"\"Get MapLibre style URL by name.\n\n    Args:\n        name: Style name (e.g., \"positron\", \"dark-matter\")\n\n    Returns:\n        Style URL\n\n    Raises:\n        ValueError: If style name is not found\n    \"\"\"\n    name_lower = name.lower().replace(\"_\", \"-\")\n    if name_lower in MAPLIBRE_STYLES:\n        return MAPLIBRE_STYLES[name_lower]\n    # Assume it's already a URL\n    if name.startswith(\"http\"):\n        return name\n    raise ValueError(f\"Unknown MapLibre style: {name}\")\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.cesium","title":"<code>cesium</code>","text":"<p>Cesium 3D globe widget implementation.</p>"},{"location":"anymap_ts/#anymap_ts.cesium.CesiumMap","title":"<code> CesiumMap            (MapWidget)         </code>","text":"<p>Interactive 3D globe widget using Cesium.</p> <p>This class provides a Python interface to Cesium for 3D globe visualization with terrain, 3D Tiles, and imagery layer support.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from anymap_ts import CesiumMap\n&gt;&gt;&gt; m = CesiumMap(center=[-122.4, 37.8], zoom=10)\n&gt;&gt;&gt; m.set_terrain()  # Enable Cesium World Terrain\n&gt;&gt;&gt; m.add_3d_tileset(url=\"path/to/tileset.json\")\n&gt;&gt;&gt; m\n</code></pre> Source code in <code>anymap_ts/cesium.py</code> <pre><code>class CesiumMap(MapWidget):\n    \"\"\"Interactive 3D globe widget using Cesium.\n\n    This class provides a Python interface to Cesium for 3D globe\n    visualization with terrain, 3D Tiles, and imagery layer support.\n\n    Example:\n        &gt;&gt;&gt; from anymap_ts import CesiumMap\n        &gt;&gt;&gt; m = CesiumMap(center=[-122.4, 37.8], zoom=10)\n        &gt;&gt;&gt; m.set_terrain()  # Enable Cesium World Terrain\n        &gt;&gt;&gt; m.add_3d_tileset(url=\"path/to/tileset.json\")\n        &gt;&gt;&gt; m\n    \"\"\"\n\n    # ESM module for frontend\n    _esm = STATIC_DIR / \"cesium.js\"\n\n    # Cesium-specific traits\n    access_token = traitlets.Unicode(\"\").tag(sync=True)\n\n    # Camera position traits\n    camera_height = traitlets.Float(10000000).tag(sync=True)\n    heading = traitlets.Float(0.0).tag(sync=True)\n    pitch = traitlets.Float(-90.0).tag(sync=True)\n    roll = traitlets.Float(0.0).tag(sync=True)\n\n    # Terrain\n    terrain_enabled = traitlets.Bool(False).tag(sync=True)\n\n    def __init__(\n        self,\n        center: Tuple[float, float] = (0.0, 0.0),\n        zoom: float = 2.0,\n        width: str = \"100%\",\n        height: str = \"600px\",\n        access_token: Optional[str] = None,\n        terrain: bool = False,\n        **kwargs,\n    ):\n        \"\"\"Initialize a Cesium 3D globe.\n\n        Args:\n            center: Globe center as (longitude, latitude).\n            zoom: Initial zoom level (converted to camera height).\n            width: Widget width as CSS string.\n            height: Widget height as CSS string.\n            access_token: Cesium Ion access token (uses CESIUM_TOKEN env var if not provided).\n            terrain: Whether to enable terrain on initialization.\n            **kwargs: Additional widget arguments.\n        \"\"\"\n        # Get access token from env if not provided\n        if access_token is None:\n            access_token = get_cesium_token()\n\n        super().__init__(\n            center=list(center),\n            zoom=zoom,\n            width=width,\n            height=height,\n            access_token=access_token,\n            terrain_enabled=terrain,\n            **kwargs,\n        )\n\n        # Enable terrain if requested\n        if terrain:\n            self.set_terrain()\n\n    # -------------------------------------------------------------------------\n    # Basemap/Imagery Methods\n    # -------------------------------------------------------------------------\n\n    def add_basemap(\n        self,\n        basemap: str = \"OpenStreetMap\",\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a basemap imagery layer.\n\n        Args:\n            basemap: Name of basemap (e.g., \"OpenStreetMap\", \"Bing\").\n            **kwargs: Additional options.\n        \"\"\"\n        # Common basemap URLs\n        basemap_urls = {\n            \"OpenStreetMap\": \"https://tile.openstreetmap.org/{z}/{x}/{y}.png\",\n            \"CartoDB.Positron\": \"https://a.basemaps.cartocdn.com/light_all/{z}/{x}/{y}.png\",\n            \"CartoDB.DarkMatter\": \"https://a.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}.png\",\n            \"Stamen.Terrain\": \"https://tiles.stadiamaps.com/tiles/stamen_terrain/{z}/{x}/{y}.png\",\n        }\n\n        url = basemap_urls.get(basemap, basemap_urls[\"OpenStreetMap\"])\n\n        self.call_js_method(\"addBasemap\", url, name=basemap, **kwargs)\n\n    def add_imagery_layer(\n        self,\n        url: str,\n        name: Optional[str] = None,\n        layer_type: str = \"xyz\",\n        alpha: float = 1.0,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add an imagery layer.\n\n        Args:\n            url: Imagery URL or service endpoint.\n            name: Layer name.\n            layer_type: Type of imagery ('xyz', 'wms', 'wmts', 'arcgis').\n            alpha: Layer opacity (0-1).\n            **kwargs: Additional options (layers, parameters for WMS, etc.).\n        \"\"\"\n        layer_id = name or f\"imagery-{len(self._layers)}\"\n\n        self.call_js_method(\n            \"addImageryLayer\",\n            url=url,\n            name=layer_id,\n            type=layer_type,\n            alpha=alpha,\n            **kwargs,\n        )\n\n        self._layers = {\n            **self._layers,\n            layer_id: {\"id\": layer_id, \"type\": \"imagery\"},\n        }\n\n    def remove_imagery_layer(self, name: str) -&gt; None:\n        \"\"\"Remove an imagery layer.\n\n        Args:\n            name: Layer name to remove.\n        \"\"\"\n        if name in self._layers:\n            layers = dict(self._layers)\n            del layers[name]\n            self._layers = layers\n        self.call_js_method(\"removeImageryLayer\", name)\n\n    # -------------------------------------------------------------------------\n    # Terrain Methods\n    # -------------------------------------------------------------------------\n\n    def set_terrain(\n        self,\n        url: Optional[str] = None,\n        request_vertex_normals: bool = True,\n        request_water_mask: bool = True,\n    ) -&gt; None:\n        \"\"\"Enable terrain.\n\n        Args:\n            url: Terrain provider URL. If None, uses Cesium World Terrain (requires Ion token).\n            request_vertex_normals: Request vertex normals for lighting.\n            request_water_mask: Request water mask for water effects.\n        \"\"\"\n        self.terrain_enabled = True\n        self.call_js_method(\n            \"setTerrain\",\n            url=url or \"cesium-world-terrain\",\n            requestVertexNormals=request_vertex_normals,\n            requestWaterMask=request_water_mask,\n        )\n\n    def remove_terrain(self) -&gt; None:\n        \"\"\"Disable terrain and use ellipsoid.\"\"\"\n        self.terrain_enabled = False\n        self.call_js_method(\"removeTerrain\")\n\n    # -------------------------------------------------------------------------\n    # 3D Tiles Methods\n    # -------------------------------------------------------------------------\n\n    def add_3d_tileset(\n        self,\n        url: Union[str, int],\n        name: Optional[str] = None,\n        maximum_screen_space_error: float = 16,\n        fly_to: bool = True,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a 3D Tileset.\n\n        Args:\n            url: URL to tileset.json or Cesium Ion asset ID.\n            name: Tileset name.\n            maximum_screen_space_error: Maximum screen space error for LOD.\n            fly_to: Whether to fly to the tileset after loading.\n            **kwargs: Additional options.\n        \"\"\"\n        layer_id = name or f\"tileset-{len(self._layers)}\"\n\n        self.call_js_method(\n            \"add3DTileset\",\n            url=str(url),\n            name=layer_id,\n            maximumScreenSpaceError=maximum_screen_space_error,\n            flyTo=fly_to,\n            **kwargs,\n        )\n\n        self._layers = {\n            **self._layers,\n            layer_id: {\"id\": layer_id, \"type\": \"3dtiles\"},\n        }\n\n    def remove_3d_tileset(self, name: str) -&gt; None:\n        \"\"\"Remove a 3D Tileset.\n\n        Args:\n            name: Tileset name to remove.\n        \"\"\"\n        if name in self._layers:\n            layers = dict(self._layers)\n            del layers[name]\n            self._layers = layers\n        self.call_js_method(\"remove3DTileset\", name)\n\n    # -------------------------------------------------------------------------\n    # GeoJSON Methods\n    # -------------------------------------------------------------------------\n\n    def add_geojson(\n        self,\n        data: Any,\n        name: Optional[str] = None,\n        stroke: str = \"#3388ff\",\n        stroke_width: float = 2,\n        fill: str = \"rgba(51, 136, 255, 0.5)\",\n        clamp_to_ground: bool = True,\n        fly_to: bool = True,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add GeoJSON data.\n\n        Args:\n            data: GeoJSON dict or file path.\n            name: Data source name.\n            stroke: Stroke color.\n            stroke_width: Stroke width.\n            fill: Fill color.\n            clamp_to_ground: Whether to clamp features to terrain.\n            fly_to: Whether to fly to the data after loading.\n            **kwargs: Additional options.\n        \"\"\"\n        geojson = to_geojson(data)\n        layer_id = name or f\"geojson-{len(self._layers)}\"\n\n        self.call_js_method(\n            \"addGeoJSON\",\n            data=geojson,\n            name=layer_id,\n            stroke=stroke,\n            strokeWidth=stroke_width,\n            fill=fill,\n            clampToGround=clamp_to_ground,\n            flyTo=fly_to,\n            **kwargs,\n        )\n\n        self._layers = {\n            **self._layers,\n            layer_id: {\"id\": layer_id, \"type\": \"geojson\"},\n        }\n\n    def remove_data_source(self, name: str) -&gt; None:\n        \"\"\"Remove a data source (GeoJSON, etc.).\n\n        Args:\n            name: Data source name to remove.\n        \"\"\"\n        if name in self._layers:\n            layers = dict(self._layers)\n            del layers[name]\n            self._layers = layers\n        self.call_js_method(\"removeDataSource\", name)\n\n    # -------------------------------------------------------------------------\n    # Camera Methods\n    # -------------------------------------------------------------------------\n\n    def fly_to(\n        self,\n        lng: float,\n        lat: float,\n        height: Optional[float] = None,\n        zoom: Optional[float] = None,\n        heading: float = 0,\n        pitch: float = -90,\n        roll: float = 0,\n        duration: float = 2,\n    ) -&gt; None:\n        \"\"\"Fly to a location.\n\n        Args:\n            lng: Target longitude.\n            lat: Target latitude.\n            height: Camera height in meters (overrides zoom).\n            zoom: Zoom level (converted to height if height not provided).\n            heading: Camera heading in degrees.\n            pitch: Camera pitch in degrees (default -90 = looking down).\n            roll: Camera roll in degrees.\n            duration: Flight duration in seconds.\n        \"\"\"\n        self.call_js_method(\n            \"flyTo\",\n            lng,\n            lat,\n            height=height,\n            zoom=zoom,\n            heading=heading,\n            pitch=pitch,\n            roll=roll,\n            duration=duration,\n        )\n\n    def zoom_to(self, target: str) -&gt; None:\n        \"\"\"Zoom to a layer or data source.\n\n        Args:\n            target: Name of the layer or data source to zoom to.\n        \"\"\"\n        self.call_js_method(\"zoomTo\", target=target)\n\n    def set_camera(\n        self,\n        longitude: float = 0,\n        latitude: float = 0,\n        height: float = 10000000,\n        heading: float = 0,\n        pitch: float = -90,\n        roll: float = 0,\n    ) -&gt; None:\n        \"\"\"Set the camera position immediately (no animation).\n\n        Args:\n            longitude: Camera longitude.\n            latitude: Camera latitude.\n            height: Camera height in meters.\n            heading: Camera heading in degrees.\n            pitch: Camera pitch in degrees.\n            roll: Camera roll in degrees.\n        \"\"\"\n        self.call_js_method(\n            \"setCamera\",\n            longitude=longitude,\n            latitude=latitude,\n            height=height,\n            heading=heading,\n            pitch=pitch,\n            roll=roll,\n        )\n\n    def reset_view(self, duration: float = 2) -&gt; None:\n        \"\"\"Reset camera to home position.\n\n        Args:\n            duration: Animation duration in seconds.\n        \"\"\"\n        self.call_js_method(\"resetView\", duration=duration)\n\n    # -------------------------------------------------------------------------\n    # Layer Management\n    # -------------------------------------------------------------------------\n\n    def set_visibility(self, name: str, visible: bool) -&gt; None:\n        \"\"\"Set layer visibility.\n\n        Args:\n            name: Layer name.\n            visible: Whether layer should be visible.\n        \"\"\"\n        self.call_js_method(\"setVisibility\", name, visible)\n\n    def set_opacity(self, name: str, opacity: float) -&gt; None:\n        \"\"\"Set layer opacity (imagery layers only).\n\n        Args:\n            name: Layer name.\n            opacity: Opacity value (0-1).\n        \"\"\"\n        self.call_js_method(\"setOpacity\", name, opacity)\n\n    # -------------------------------------------------------------------------\n    # HTML Export\n    # -------------------------------------------------------------------------\n\n    def _generate_html_template(self) -&gt; str:\n        \"\"\"Generate standalone HTML for the globe.\"\"\"\n        template_path = Path(__file__).parent / \"templates\" / \"cesium.html\"\n\n        if template_path.exists():\n            template = template_path.read_text(encoding=\"utf-8\")\n        else:\n            template = self._get_default_template()\n\n        state = {\n            \"center\": self.center,\n            \"zoom\": self.zoom,\n            \"access_token\": self.access_token,\n            \"terrain_enabled\": self.terrain_enabled,\n            \"width\": self.width,\n            \"height\": self.height,\n            \"layers\": self._layers,\n            \"js_calls\": self._js_calls,\n        }\n\n        template = template.replace(\"{{state}}\", json.dumps(state, indent=2))\n        template = template.replace(\"{{access_token}}\", self.access_token)\n        return template\n\n    def _get_default_template(self) -&gt; str:\n        \"\"\"Get default HTML template.\"\"\"\n        return \"\"\"&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n    &lt;meta charset=\"utf-8\"&gt;\n    &lt;title&gt;Cesium Globe&lt;/title&gt;\n    &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"&gt;\n    &lt;script src=\"https://cesium.com/downloads/cesiumjs/releases/1.120/Build/Cesium/Cesium.js\"&gt;&lt;/script&gt;\n    &lt;link href=\"https://cesium.com/downloads/cesiumjs/releases/1.120/Build/Cesium/Widgets/widgets.css\" rel=\"stylesheet\"&gt;\n    &lt;style&gt;\n        * { margin: 0; padding: 0; box-sizing: border-box; }\n        html, body { height: 100%; }\n        #cesiumContainer { position: absolute; top: 0; bottom: 0; width: 100%; }\n    &lt;/style&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;div id=\"cesiumContainer\"&gt;&lt;/div&gt;\n    &lt;script&gt;\n        const state = {{state}};\n\n        if (state.access_token) {\n            Cesium.Ion.defaultAccessToken = state.access_token;\n        }\n\n        const viewer = new Cesium.Viewer('cesiumContainer', {\n            baseLayerPicker: false,\n            geocoder: false,\n            homeButton: false,\n            sceneModePicker: false,\n            navigationHelpButton: false,\n            animation: false,\n            timeline: false\n        });\n\n        for (const call of state.js_calls || []) {\n            executeMethod(call.method, call.args, call.kwargs);\n        }\n\n        function executeMethod(method, args, kwargs) {\n            console.log('Executing:', method, args, kwargs);\n        }\n    &lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\"\"\"\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.cesium.CesiumMap.__init__","title":"<code>__init__(self, center=(0.0, 0.0), zoom=2.0, width='100%', height='600px', access_token=None, terrain=False, **kwargs)</code>  <code>special</code>","text":"<p>Initialize a Cesium 3D globe.</p> <p>Parameters:</p> Name Type Description Default <code>center</code> <code>Tuple[float, float]</code> <p>Globe center as (longitude, latitude).</p> <code>(0.0, 0.0)</code> <code>zoom</code> <code>float</code> <p>Initial zoom level (converted to camera height).</p> <code>2.0</code> <code>width</code> <code>str</code> <p>Widget width as CSS string.</p> <code>'100%'</code> <code>height</code> <code>str</code> <p>Widget height as CSS string.</p> <code>'600px'</code> <code>access_token</code> <code>Optional[str]</code> <p>Cesium Ion access token (uses CESIUM_TOKEN env var if not provided).</p> <code>None</code> <code>terrain</code> <code>bool</code> <p>Whether to enable terrain on initialization.</p> <code>False</code> <code>**kwargs</code> <p>Additional widget arguments.</p> <code>{}</code> Source code in <code>anymap_ts/cesium.py</code> <pre><code>def __init__(\n    self,\n    center: Tuple[float, float] = (0.0, 0.0),\n    zoom: float = 2.0,\n    width: str = \"100%\",\n    height: str = \"600px\",\n    access_token: Optional[str] = None,\n    terrain: bool = False,\n    **kwargs,\n):\n    \"\"\"Initialize a Cesium 3D globe.\n\n    Args:\n        center: Globe center as (longitude, latitude).\n        zoom: Initial zoom level (converted to camera height).\n        width: Widget width as CSS string.\n        height: Widget height as CSS string.\n        access_token: Cesium Ion access token (uses CESIUM_TOKEN env var if not provided).\n        terrain: Whether to enable terrain on initialization.\n        **kwargs: Additional widget arguments.\n    \"\"\"\n    # Get access token from env if not provided\n    if access_token is None:\n        access_token = get_cesium_token()\n\n    super().__init__(\n        center=list(center),\n        zoom=zoom,\n        width=width,\n        height=height,\n        access_token=access_token,\n        terrain_enabled=terrain,\n        **kwargs,\n    )\n\n    # Enable terrain if requested\n    if terrain:\n        self.set_terrain()\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.cesium.CesiumMap.add_3d_tileset","title":"<code>add_3d_tileset(self, url, name=None, maximum_screen_space_error=16, fly_to=True, **kwargs)</code>","text":"<p>Add a 3D Tileset.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>Union[str, int]</code> <p>URL to tileset.json or Cesium Ion asset ID.</p> required <code>name</code> <code>Optional[str]</code> <p>Tileset name.</p> <code>None</code> <code>maximum_screen_space_error</code> <code>float</code> <p>Maximum screen space error for LOD.</p> <code>16</code> <code>fly_to</code> <code>bool</code> <p>Whether to fly to the tileset after loading.</p> <code>True</code> <code>**kwargs</code> <p>Additional options.</p> <code>{}</code> Source code in <code>anymap_ts/cesium.py</code> <pre><code>def add_3d_tileset(\n    self,\n    url: Union[str, int],\n    name: Optional[str] = None,\n    maximum_screen_space_error: float = 16,\n    fly_to: bool = True,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a 3D Tileset.\n\n    Args:\n        url: URL to tileset.json or Cesium Ion asset ID.\n        name: Tileset name.\n        maximum_screen_space_error: Maximum screen space error for LOD.\n        fly_to: Whether to fly to the tileset after loading.\n        **kwargs: Additional options.\n    \"\"\"\n    layer_id = name or f\"tileset-{len(self._layers)}\"\n\n    self.call_js_method(\n        \"add3DTileset\",\n        url=str(url),\n        name=layer_id,\n        maximumScreenSpaceError=maximum_screen_space_error,\n        flyTo=fly_to,\n        **kwargs,\n    )\n\n    self._layers = {\n        **self._layers,\n        layer_id: {\"id\": layer_id, \"type\": \"3dtiles\"},\n    }\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.cesium.CesiumMap.add_basemap","title":"<code>add_basemap(self, basemap='OpenStreetMap', **kwargs)</code>","text":"<p>Add a basemap imagery layer.</p> <p>Parameters:</p> Name Type Description Default <code>basemap</code> <code>str</code> <p>Name of basemap (e.g., \"OpenStreetMap\", \"Bing\").</p> <code>'OpenStreetMap'</code> <code>**kwargs</code> <p>Additional options.</p> <code>{}</code> Source code in <code>anymap_ts/cesium.py</code> <pre><code>def add_basemap(\n    self,\n    basemap: str = \"OpenStreetMap\",\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a basemap imagery layer.\n\n    Args:\n        basemap: Name of basemap (e.g., \"OpenStreetMap\", \"Bing\").\n        **kwargs: Additional options.\n    \"\"\"\n    # Common basemap URLs\n    basemap_urls = {\n        \"OpenStreetMap\": \"https://tile.openstreetmap.org/{z}/{x}/{y}.png\",\n        \"CartoDB.Positron\": \"https://a.basemaps.cartocdn.com/light_all/{z}/{x}/{y}.png\",\n        \"CartoDB.DarkMatter\": \"https://a.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}.png\",\n        \"Stamen.Terrain\": \"https://tiles.stadiamaps.com/tiles/stamen_terrain/{z}/{x}/{y}.png\",\n    }\n\n    url = basemap_urls.get(basemap, basemap_urls[\"OpenStreetMap\"])\n\n    self.call_js_method(\"addBasemap\", url, name=basemap, **kwargs)\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.cesium.CesiumMap.add_geojson","title":"<code>add_geojson(self, data, name=None, stroke='#3388ff', stroke_width=2, fill='rgba(51, 136, 255, 0.5)', clamp_to_ground=True, fly_to=True, **kwargs)</code>","text":"<p>Add GeoJSON data.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>GeoJSON dict or file path.</p> required <code>name</code> <code>Optional[str]</code> <p>Data source name.</p> <code>None</code> <code>stroke</code> <code>str</code> <p>Stroke color.</p> <code>'#3388ff'</code> <code>stroke_width</code> <code>float</code> <p>Stroke width.</p> <code>2</code> <code>fill</code> <code>str</code> <p>Fill color.</p> <code>'rgba(51, 136, 255, 0.5)'</code> <code>clamp_to_ground</code> <code>bool</code> <p>Whether to clamp features to terrain.</p> <code>True</code> <code>fly_to</code> <code>bool</code> <p>Whether to fly to the data after loading.</p> <code>True</code> <code>**kwargs</code> <p>Additional options.</p> <code>{}</code> Source code in <code>anymap_ts/cesium.py</code> <pre><code>def add_geojson(\n    self,\n    data: Any,\n    name: Optional[str] = None,\n    stroke: str = \"#3388ff\",\n    stroke_width: float = 2,\n    fill: str = \"rgba(51, 136, 255, 0.5)\",\n    clamp_to_ground: bool = True,\n    fly_to: bool = True,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add GeoJSON data.\n\n    Args:\n        data: GeoJSON dict or file path.\n        name: Data source name.\n        stroke: Stroke color.\n        stroke_width: Stroke width.\n        fill: Fill color.\n        clamp_to_ground: Whether to clamp features to terrain.\n        fly_to: Whether to fly to the data after loading.\n        **kwargs: Additional options.\n    \"\"\"\n    geojson = to_geojson(data)\n    layer_id = name or f\"geojson-{len(self._layers)}\"\n\n    self.call_js_method(\n        \"addGeoJSON\",\n        data=geojson,\n        name=layer_id,\n        stroke=stroke,\n        strokeWidth=stroke_width,\n        fill=fill,\n        clampToGround=clamp_to_ground,\n        flyTo=fly_to,\n        **kwargs,\n    )\n\n    self._layers = {\n        **self._layers,\n        layer_id: {\"id\": layer_id, \"type\": \"geojson\"},\n    }\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.cesium.CesiumMap.add_imagery_layer","title":"<code>add_imagery_layer(self, url, name=None, layer_type='xyz', alpha=1.0, **kwargs)</code>","text":"<p>Add an imagery layer.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>Imagery URL or service endpoint.</p> required <code>name</code> <code>Optional[str]</code> <p>Layer name.</p> <code>None</code> <code>layer_type</code> <code>str</code> <p>Type of imagery ('xyz', 'wms', 'wmts', 'arcgis').</p> <code>'xyz'</code> <code>alpha</code> <code>float</code> <p>Layer opacity (0-1).</p> <code>1.0</code> <code>**kwargs</code> <p>Additional options (layers, parameters for WMS, etc.).</p> <code>{}</code> Source code in <code>anymap_ts/cesium.py</code> <pre><code>def add_imagery_layer(\n    self,\n    url: str,\n    name: Optional[str] = None,\n    layer_type: str = \"xyz\",\n    alpha: float = 1.0,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add an imagery layer.\n\n    Args:\n        url: Imagery URL or service endpoint.\n        name: Layer name.\n        layer_type: Type of imagery ('xyz', 'wms', 'wmts', 'arcgis').\n        alpha: Layer opacity (0-1).\n        **kwargs: Additional options (layers, parameters for WMS, etc.).\n    \"\"\"\n    layer_id = name or f\"imagery-{len(self._layers)}\"\n\n    self.call_js_method(\n        \"addImageryLayer\",\n        url=url,\n        name=layer_id,\n        type=layer_type,\n        alpha=alpha,\n        **kwargs,\n    )\n\n    self._layers = {\n        **self._layers,\n        layer_id: {\"id\": layer_id, \"type\": \"imagery\"},\n    }\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.cesium.CesiumMap.fly_to","title":"<code>fly_to(self, lng, lat, height=None, zoom=None, heading=0, pitch=-90, roll=0, duration=2)</code>","text":"<p>Fly to a location.</p> <p>Parameters:</p> Name Type Description Default <code>lng</code> <code>float</code> <p>Target longitude.</p> required <code>lat</code> <code>float</code> <p>Target latitude.</p> required <code>height</code> <code>Optional[float]</code> <p>Camera height in meters (overrides zoom).</p> <code>None</code> <code>zoom</code> <code>Optional[float]</code> <p>Zoom level (converted to height if height not provided).</p> <code>None</code> <code>heading</code> <code>float</code> <p>Camera heading in degrees.</p> <code>0</code> <code>pitch</code> <code>float</code> <p>Camera pitch in degrees (default -90 = looking down).</p> <code>-90</code> <code>roll</code> <code>float</code> <p>Camera roll in degrees.</p> <code>0</code> <code>duration</code> <code>float</code> <p>Flight duration in seconds.</p> <code>2</code> Source code in <code>anymap_ts/cesium.py</code> <pre><code>def fly_to(\n    self,\n    lng: float,\n    lat: float,\n    height: Optional[float] = None,\n    zoom: Optional[float] = None,\n    heading: float = 0,\n    pitch: float = -90,\n    roll: float = 0,\n    duration: float = 2,\n) -&gt; None:\n    \"\"\"Fly to a location.\n\n    Args:\n        lng: Target longitude.\n        lat: Target latitude.\n        height: Camera height in meters (overrides zoom).\n        zoom: Zoom level (converted to height if height not provided).\n        heading: Camera heading in degrees.\n        pitch: Camera pitch in degrees (default -90 = looking down).\n        roll: Camera roll in degrees.\n        duration: Flight duration in seconds.\n    \"\"\"\n    self.call_js_method(\n        \"flyTo\",\n        lng,\n        lat,\n        height=height,\n        zoom=zoom,\n        heading=heading,\n        pitch=pitch,\n        roll=roll,\n        duration=duration,\n    )\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.cesium.CesiumMap.remove_3d_tileset","title":"<code>remove_3d_tileset(self, name)</code>","text":"<p>Remove a 3D Tileset.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Tileset name to remove.</p> required Source code in <code>anymap_ts/cesium.py</code> <pre><code>def remove_3d_tileset(self, name: str) -&gt; None:\n    \"\"\"Remove a 3D Tileset.\n\n    Args:\n        name: Tileset name to remove.\n    \"\"\"\n    if name in self._layers:\n        layers = dict(self._layers)\n        del layers[name]\n        self._layers = layers\n    self.call_js_method(\"remove3DTileset\", name)\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.cesium.CesiumMap.remove_data_source","title":"<code>remove_data_source(self, name)</code>","text":"<p>Remove a data source (GeoJSON, etc.).</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Data source name to remove.</p> required Source code in <code>anymap_ts/cesium.py</code> <pre><code>def remove_data_source(self, name: str) -&gt; None:\n    \"\"\"Remove a data source (GeoJSON, etc.).\n\n    Args:\n        name: Data source name to remove.\n    \"\"\"\n    if name in self._layers:\n        layers = dict(self._layers)\n        del layers[name]\n        self._layers = layers\n    self.call_js_method(\"removeDataSource\", name)\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.cesium.CesiumMap.remove_imagery_layer","title":"<code>remove_imagery_layer(self, name)</code>","text":"<p>Remove an imagery layer.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Layer name to remove.</p> required Source code in <code>anymap_ts/cesium.py</code> <pre><code>def remove_imagery_layer(self, name: str) -&gt; None:\n    \"\"\"Remove an imagery layer.\n\n    Args:\n        name: Layer name to remove.\n    \"\"\"\n    if name in self._layers:\n        layers = dict(self._layers)\n        del layers[name]\n        self._layers = layers\n    self.call_js_method(\"removeImageryLayer\", name)\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.cesium.CesiumMap.remove_terrain","title":"<code>remove_terrain(self)</code>","text":"<p>Disable terrain and use ellipsoid.</p> Source code in <code>anymap_ts/cesium.py</code> <pre><code>def remove_terrain(self) -&gt; None:\n    \"\"\"Disable terrain and use ellipsoid.\"\"\"\n    self.terrain_enabled = False\n    self.call_js_method(\"removeTerrain\")\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.cesium.CesiumMap.reset_view","title":"<code>reset_view(self, duration=2)</code>","text":"<p>Reset camera to home position.</p> <p>Parameters:</p> Name Type Description Default <code>duration</code> <code>float</code> <p>Animation duration in seconds.</p> <code>2</code> Source code in <code>anymap_ts/cesium.py</code> <pre><code>def reset_view(self, duration: float = 2) -&gt; None:\n    \"\"\"Reset camera to home position.\n\n    Args:\n        duration: Animation duration in seconds.\n    \"\"\"\n    self.call_js_method(\"resetView\", duration=duration)\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.cesium.CesiumMap.set_camera","title":"<code>set_camera(self, longitude=0, latitude=0, height=10000000, heading=0, pitch=-90, roll=0)</code>","text":"<p>Set the camera position immediately (no animation).</p> <p>Parameters:</p> Name Type Description Default <code>longitude</code> <code>float</code> <p>Camera longitude.</p> <code>0</code> <code>latitude</code> <code>float</code> <p>Camera latitude.</p> <code>0</code> <code>height</code> <code>float</code> <p>Camera height in meters.</p> <code>10000000</code> <code>heading</code> <code>float</code> <p>Camera heading in degrees.</p> <code>0</code> <code>pitch</code> <code>float</code> <p>Camera pitch in degrees.</p> <code>-90</code> <code>roll</code> <code>float</code> <p>Camera roll in degrees.</p> <code>0</code> Source code in <code>anymap_ts/cesium.py</code> <pre><code>def set_camera(\n    self,\n    longitude: float = 0,\n    latitude: float = 0,\n    height: float = 10000000,\n    heading: float = 0,\n    pitch: float = -90,\n    roll: float = 0,\n) -&gt; None:\n    \"\"\"Set the camera position immediately (no animation).\n\n    Args:\n        longitude: Camera longitude.\n        latitude: Camera latitude.\n        height: Camera height in meters.\n        heading: Camera heading in degrees.\n        pitch: Camera pitch in degrees.\n        roll: Camera roll in degrees.\n    \"\"\"\n    self.call_js_method(\n        \"setCamera\",\n        longitude=longitude,\n        latitude=latitude,\n        height=height,\n        heading=heading,\n        pitch=pitch,\n        roll=roll,\n    )\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.cesium.CesiumMap.set_opacity","title":"<code>set_opacity(self, name, opacity)</code>","text":"<p>Set layer opacity (imagery layers only).</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Layer name.</p> required <code>opacity</code> <code>float</code> <p>Opacity value (0-1).</p> required Source code in <code>anymap_ts/cesium.py</code> <pre><code>def set_opacity(self, name: str, opacity: float) -&gt; None:\n    \"\"\"Set layer opacity (imagery layers only).\n\n    Args:\n        name: Layer name.\n        opacity: Opacity value (0-1).\n    \"\"\"\n    self.call_js_method(\"setOpacity\", name, opacity)\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.cesium.CesiumMap.set_terrain","title":"<code>set_terrain(self, url=None, request_vertex_normals=True, request_water_mask=True)</code>","text":"<p>Enable terrain.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>Optional[str]</code> <p>Terrain provider URL. If None, uses Cesium World Terrain (requires Ion token).</p> <code>None</code> <code>request_vertex_normals</code> <code>bool</code> <p>Request vertex normals for lighting.</p> <code>True</code> <code>request_water_mask</code> <code>bool</code> <p>Request water mask for water effects.</p> <code>True</code> Source code in <code>anymap_ts/cesium.py</code> <pre><code>def set_terrain(\n    self,\n    url: Optional[str] = None,\n    request_vertex_normals: bool = True,\n    request_water_mask: bool = True,\n) -&gt; None:\n    \"\"\"Enable terrain.\n\n    Args:\n        url: Terrain provider URL. If None, uses Cesium World Terrain (requires Ion token).\n        request_vertex_normals: Request vertex normals for lighting.\n        request_water_mask: Request water mask for water effects.\n    \"\"\"\n    self.terrain_enabled = True\n    self.call_js_method(\n        \"setTerrain\",\n        url=url or \"cesium-world-terrain\",\n        requestVertexNormals=request_vertex_normals,\n        requestWaterMask=request_water_mask,\n    )\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.cesium.CesiumMap.set_visibility","title":"<code>set_visibility(self, name, visible)</code>","text":"<p>Set layer visibility.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Layer name.</p> required <code>visible</code> <code>bool</code> <p>Whether layer should be visible.</p> required Source code in <code>anymap_ts/cesium.py</code> <pre><code>def set_visibility(self, name: str, visible: bool) -&gt; None:\n    \"\"\"Set layer visibility.\n\n    Args:\n        name: Layer name.\n        visible: Whether layer should be visible.\n    \"\"\"\n    self.call_js_method(\"setVisibility\", name, visible)\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.cesium.CesiumMap.zoom_to","title":"<code>zoom_to(self, target)</code>","text":"<p>Zoom to a layer or data source.</p> <p>Parameters:</p> Name Type Description Default <code>target</code> <code>str</code> <p>Name of the layer or data source to zoom to.</p> required Source code in <code>anymap_ts/cesium.py</code> <pre><code>def zoom_to(self, target: str) -&gt; None:\n    \"\"\"Zoom to a layer or data source.\n\n    Args:\n        target: Name of the layer or data source to zoom to.\n    \"\"\"\n    self.call_js_method(\"zoomTo\", target=target)\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.cesium.get_cesium_token","title":"<code>get_cesium_token()</code>","text":"<p>Get Cesium Ion access token from environment variable.</p> <p>Returns:</p> Type Description <code>str</code> <p>Cesium Ion access token or empty string if not set.</p> Source code in <code>anymap_ts/cesium.py</code> <pre><code>def get_cesium_token() -&gt; str:\n    \"\"\"Get Cesium Ion access token from environment variable.\n\n    Returns:\n        Cesium Ion access token or empty string if not set.\n    \"\"\"\n    return os.environ.get(\"CESIUM_TOKEN\", \"\")\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.deckgl","title":"<code>deckgl</code>","text":"<p>DeckGL map widget implementation extending MapLibre with deck.gl layers.</p>"},{"location":"anymap_ts/#anymap_ts.deckgl.DeckGLMap","title":"<code> DeckGLMap            (MapLibreMap)         </code>","text":"<p>Interactive map widget using MapLibre GL JS with deck.gl overlay.</p> <p>This class extends MapLibreMap with deck.gl visualization layer support for GPU-accelerated geospatial visualizations.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from anymap_ts import DeckGLMap\n&gt;&gt;&gt; m = DeckGLMap(center=[-122.4, 37.8], zoom=10)\n&gt;&gt;&gt; m.add_scatterplot_layer(\n...     data=points,\n...     get_position='coordinates',\n...     get_radius=100,\n...     get_fill_color=[255, 0, 0]\n... )\n&gt;&gt;&gt; m\n</code></pre> Source code in <code>anymap_ts/deckgl.py</code> <pre><code>class DeckGLMap(MapLibreMap):\n    \"\"\"Interactive map widget using MapLibre GL JS with deck.gl overlay.\n\n    This class extends MapLibreMap with deck.gl visualization layer support\n    for GPU-accelerated geospatial visualizations.\n\n    Example:\n        &gt;&gt;&gt; from anymap_ts import DeckGLMap\n        &gt;&gt;&gt; m = DeckGLMap(center=[-122.4, 37.8], zoom=10)\n        &gt;&gt;&gt; m.add_scatterplot_layer(\n        ...     data=points,\n        ...     get_position='coordinates',\n        ...     get_radius=100,\n        ...     get_fill_color=[255, 0, 0]\n        ... )\n        &gt;&gt;&gt; m\n    \"\"\"\n\n    # ESM module for frontend (uses DeckGL-enabled version)\n    _esm = STATIC_DIR / \"deckgl.js\"\n\n    # DeckGL layer tracking\n    _deck_layers = traitlets.Dict({}).tag(sync=True)\n\n    def __init__(\n        self,\n        center: Tuple[float, float] = (0.0, 0.0),\n        zoom: float = 2.0,\n        width: str = \"100%\",\n        height: str = \"600px\",\n        style: Union[str, Dict] = \"https://demotiles.maplibre.org/style.json\",\n        bearing: float = 0.0,\n        pitch: float = 0.0,\n        max_pitch: float = 85.0,\n        controls: Optional[Dict[str, Any]] = None,\n        **kwargs,\n    ):\n        \"\"\"Initialize a DeckGL map.\n\n        Args:\n            center: Map center as (longitude, latitude).\n            zoom: Initial zoom level.\n            width: Map width as CSS string.\n            height: Map height as CSS string.\n            style: MapLibre style URL or style object.\n            bearing: Map bearing in degrees.\n            pitch: Map pitch in degrees.\n            max_pitch: Maximum pitch angle in degrees (default: 85).\n            controls: Dict of controls to add (e.g., {\"navigation\": True}).\n            **kwargs: Additional widget arguments.\n        \"\"\"\n        super().__init__(\n            center=center,\n            zoom=zoom,\n            width=width,\n            height=height,\n            style=style,\n            bearing=bearing,\n            pitch=pitch,\n            max_pitch=max_pitch,\n            controls=controls,\n            **kwargs,\n        )\n        self._deck_layers = {}\n\n    # -------------------------------------------------------------------------\n    # DeckGL Scatterplot Layer\n    # -------------------------------------------------------------------------\n\n    def add_scatterplot_layer(\n        self,\n        data: Any,\n        name: Optional[str] = None,\n        get_position: Union[str, Callable] = \"coordinates\",\n        get_radius: Union[float, str, Callable] = 5,\n        get_fill_color: Union[List[int], str, Callable] = None,\n        get_line_color: Union[List[int], str, Callable] = None,\n        radius_scale: float = 1,\n        radius_min_pixels: float = 1,\n        radius_max_pixels: float = 100,\n        line_width_min_pixels: float = 1,\n        stroked: bool = True,\n        filled: bool = True,\n        pickable: bool = True,\n        opacity: float = 0.8,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a scatterplot layer for point visualization.\n\n        Args:\n            data: Array of data objects or GeoJSON.\n            name: Layer ID.\n            get_position: Accessor for point position [lng, lat].\n            get_radius: Accessor for point radius.\n            get_fill_color: Accessor for fill color [r, g, b, a].\n            get_line_color: Accessor for stroke color [r, g, b, a].\n            radius_scale: Global radius multiplier.\n            radius_min_pixels: Minimum radius in pixels.\n            radius_max_pixels: Maximum radius in pixels.\n            line_width_min_pixels: Minimum stroke width.\n            stroked: Whether to draw stroke.\n            filled: Whether to fill points.\n            pickable: Whether layer responds to hover/click.\n            opacity: Layer opacity.\n            **kwargs: Additional layer props.\n        \"\"\"\n        layer_id = name or f\"scatterplot-{len(self._deck_layers)}\"\n        processed_data = self._process_deck_data(data)\n\n        self.call_js_method(\n            \"addScatterplotLayer\",\n            id=layer_id,\n            data=processed_data,\n            getPosition=get_position,\n            getRadius=get_radius,\n            getFillColor=get_fill_color or [51, 136, 255, 200],\n            getLineColor=get_line_color or [255, 255, 255, 255],\n            radiusScale=radius_scale,\n            radiusMinPixels=radius_min_pixels,\n            radiusMaxPixels=radius_max_pixels,\n            lineWidthMinPixels=line_width_min_pixels,\n            stroked=stroked,\n            filled=filled,\n            pickable=pickable,\n            opacity=opacity,\n            **kwargs,\n        )\n\n        self._deck_layers = {\n            **self._deck_layers,\n            layer_id: {\"type\": \"ScatterplotLayer\", \"id\": layer_id},\n        }\n\n    # -------------------------------------------------------------------------\n    # DeckGL Arc Layer\n    # -------------------------------------------------------------------------\n\n    def add_arc_layer(\n        self,\n        data: Any,\n        name: Optional[str] = None,\n        get_source_position: Union[str, Callable] = \"source\",\n        get_target_position: Union[str, Callable] = \"target\",\n        get_source_color: Union[List[int], str, Callable] = None,\n        get_target_color: Union[List[int], str, Callable] = None,\n        get_width: Union[float, str, Callable] = 1,\n        pickable: bool = True,\n        opacity: float = 0.8,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add an arc layer for origin-destination visualization.\n\n        Args:\n            data: Array of data objects with source/target coordinates.\n            name: Layer ID.\n            get_source_position: Accessor for source position [lng, lat].\n            get_target_position: Accessor for target position [lng, lat].\n            get_source_color: Accessor for source color [r, g, b, a].\n            get_target_color: Accessor for target color [r, g, b, a].\n            get_width: Accessor for arc width.\n            pickable: Whether layer responds to hover/click.\n            opacity: Layer opacity.\n            **kwargs: Additional layer props.\n        \"\"\"\n        layer_id = name or f\"arc-{len(self._deck_layers)}\"\n        processed_data = self._process_deck_data(data)\n\n        self.call_js_method(\n            \"addArcLayer\",\n            id=layer_id,\n            data=processed_data,\n            getSourcePosition=get_source_position,\n            getTargetPosition=get_target_position,\n            getSourceColor=get_source_color or [51, 136, 255, 255],\n            getTargetColor=get_target_color or [255, 136, 51, 255],\n            getWidth=get_width,\n            pickable=pickable,\n            opacity=opacity,\n            **kwargs,\n        )\n\n        self._deck_layers = {\n            **self._deck_layers,\n            layer_id: {\"type\": \"ArcLayer\", \"id\": layer_id},\n        }\n\n    # -------------------------------------------------------------------------\n    # DeckGL Point Cloud Layer\n    # -------------------------------------------------------------------------\n\n    def add_point_cloud_layer(\n        self,\n        data: Any,\n        name: Optional[str] = None,\n        get_position: Union[str, Callable] = \"position\",\n        get_color: Union[List[int], str, Callable] = None,\n        get_normal: Union[str, Callable] = None,\n        point_size: float = 2,\n        size_units: str = \"pixels\",\n        coordinate_system: Optional[str] = None,\n        coordinate_origin: Optional[List[float]] = None,\n        pickable: bool = True,\n        opacity: float = 1.0,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a point cloud layer for 3D point visualization.\n\n        Renders large point cloud datasets typically from LiDAR or 3D scanning.\n        Supports both 2D and 3D coordinates with optional normal vectors for\n        lighting effects.\n\n        Args:\n            data: Array of point data with position [x, y, z] coordinates.\n            name: Layer ID. If None, auto-generated.\n            get_position: Accessor for point position [x, y, z].\n            get_color: Accessor for point color [r, g, b, a].\n            get_normal: Accessor for point normal [nx, ny, nz] for lighting.\n            point_size: Point size in size_units.\n            size_units: Units for point_size ('pixels' or 'meters').\n            coordinate_system: Coordinate system ('CARTESIAN', 'METER_OFFSETS',\n                'LNGLAT', 'LNGLAT_OFFSETS').\n            coordinate_origin: Origin for offset coordinate systems [lng, lat, z].\n            pickable: Whether layer responds to hover/click.\n            opacity: Layer opacity (0-1).\n            **kwargs: Additional PointCloudLayer props.\n\n        Example:\n            &gt;&gt;&gt; m = DeckGLMap()\n            &gt;&gt;&gt; points = [\n            ...     {\"position\": [-122.4, 37.8, 100], \"color\": [255, 0, 0]},\n            ...     {\"position\": [-122.5, 37.7, 200], \"color\": [0, 255, 0]},\n            ... ]\n            &gt;&gt;&gt; m.add_point_cloud_layer(\n            ...     data=points,\n            ...     point_size=5,\n            ...     get_color=\"color\"\n            ... )\n        \"\"\"\n        layer_id = name or f\"pointcloud-{len(self._deck_layers)}\"\n        processed_data = self._process_deck_data(data)\n\n        layer_kwargs = {\n            \"id\": layer_id,\n            \"data\": processed_data,\n            \"getPosition\": get_position,\n            \"getColor\": get_color or [255, 255, 255, 255],\n            \"pointSize\": point_size,\n            \"sizeUnits\": size_units,\n            \"pickable\": pickable,\n            \"opacity\": opacity,\n        }\n\n        if get_normal is not None:\n            layer_kwargs[\"getNormal\"] = get_normal\n\n        if coordinate_system is not None:\n            layer_kwargs[\"coordinateSystem\"] = coordinate_system\n\n        if coordinate_origin is not None:\n            layer_kwargs[\"coordinateOrigin\"] = coordinate_origin\n\n        layer_kwargs.update(kwargs)\n        self.call_js_method(\"addPointCloudLayer\", **layer_kwargs)\n\n        self._deck_layers = {\n            **self._deck_layers,\n            layer_id: {\"type\": \"PointCloudLayer\", \"id\": layer_id},\n        }\n\n    # -------------------------------------------------------------------------\n    # DeckGL Path Layer\n    # -------------------------------------------------------------------------\n\n    def add_path_layer(\n        self,\n        data: Any,\n        name: Optional[str] = None,\n        get_path: Union[str, Callable] = \"path\",\n        get_color: Union[List[int], str, Callable] = None,\n        get_width: Union[float, str, Callable] = 1,\n        width_scale: float = 1,\n        width_min_pixels: float = 1,\n        pickable: bool = True,\n        opacity: float = 0.8,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a path layer for polyline visualization.\n\n        Args:\n            data: Array of data objects with path coordinates.\n            name: Layer ID.\n            get_path: Accessor for path coordinates [[lng, lat], ...].\n            get_color: Accessor for path color [r, g, b, a].\n            get_width: Accessor for path width.\n            width_scale: Global width multiplier.\n            width_min_pixels: Minimum width in pixels.\n            pickable: Whether layer responds to hover/click.\n            opacity: Layer opacity.\n            **kwargs: Additional layer props.\n        \"\"\"\n        layer_id = name or f\"path-{len(self._deck_layers)}\"\n        processed_data = self._process_deck_data(data)\n\n        self.call_js_method(\n            \"addPathLayer\",\n            id=layer_id,\n            data=processed_data,\n            getPath=get_path,\n            getColor=get_color or [51, 136, 255, 200],\n            getWidth=get_width,\n            widthScale=width_scale,\n            widthMinPixels=width_min_pixels,\n            pickable=pickable,\n            opacity=opacity,\n            **kwargs,\n        )\n\n        self._deck_layers = {\n            **self._deck_layers,\n            layer_id: {\"type\": \"PathLayer\", \"id\": layer_id},\n        }\n\n    # -------------------------------------------------------------------------\n    # DeckGL Polygon Layer\n    # -------------------------------------------------------------------------\n\n    def add_polygon_layer(\n        self,\n        data: Any,\n        name: Optional[str] = None,\n        get_polygon: Union[str, Callable] = \"polygon\",\n        get_fill_color: Union[List[int], str, Callable] = None,\n        get_line_color: Union[List[int], str, Callable] = None,\n        get_line_width: Union[float, str, Callable] = 1,\n        get_elevation: Union[float, str, Callable] = 0,\n        extruded: bool = False,\n        wireframe: bool = False,\n        filled: bool = True,\n        stroked: bool = True,\n        line_width_min_pixels: float = 1,\n        pickable: bool = True,\n        opacity: float = 0.5,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a polygon layer for filled polygon visualization.\n\n        Args:\n            data: Array of data objects with polygon coordinates.\n            name: Layer ID.\n            get_polygon: Accessor for polygon coordinates.\n            get_fill_color: Accessor for fill color [r, g, b, a].\n            get_line_color: Accessor for stroke color [r, g, b, a].\n            get_line_width: Accessor for stroke width.\n            get_elevation: Accessor for 3D extrusion height.\n            extruded: Whether to render as 3D polygons.\n            wireframe: Whether to render wireframe (extruded only).\n            filled: Whether to fill polygons.\n            stroked: Whether to draw stroke.\n            line_width_min_pixels: Minimum stroke width.\n            pickable: Whether layer responds to hover/click.\n            opacity: Layer opacity.\n            **kwargs: Additional layer props.\n        \"\"\"\n        layer_id = name or f\"polygon-{len(self._deck_layers)}\"\n        processed_data = self._process_deck_data(data)\n\n        self.call_js_method(\n            \"addPolygonLayer\",\n            id=layer_id,\n            data=processed_data,\n            getPolygon=get_polygon,\n            getFillColor=get_fill_color or [51, 136, 255, 128],\n            getLineColor=get_line_color or [0, 0, 255, 255],\n            getLineWidth=get_line_width,\n            getElevation=get_elevation,\n            extruded=extruded,\n            wireframe=wireframe,\n            filled=filled,\n            stroked=stroked,\n            lineWidthMinPixels=line_width_min_pixels,\n            pickable=pickable,\n            opacity=opacity,\n            **kwargs,\n        )\n\n        self._deck_layers = {\n            **self._deck_layers,\n            layer_id: {\"type\": \"PolygonLayer\", \"id\": layer_id},\n        }\n\n    # -------------------------------------------------------------------------\n    # DeckGL Hexagon Layer\n    # -------------------------------------------------------------------------\n\n    def add_hexagon_layer(\n        self,\n        data: Any,\n        name: Optional[str] = None,\n        get_position: Union[str, Callable] = \"coordinates\",\n        radius: float = 1000,\n        elevation_scale: float = 4,\n        extruded: bool = True,\n        color_range: Optional[List[List[int]]] = None,\n        pickable: bool = True,\n        opacity: float = 0.8,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a hexagon layer for hexbin aggregation visualization.\n\n        Args:\n            data: Array of data objects with position coordinates.\n            name: Layer ID.\n            get_position: Accessor for point position [lng, lat].\n            radius: Hexagon radius in meters.\n            elevation_scale: Elevation multiplier for 3D.\n            extruded: Whether to render as 3D hexagons.\n            color_range: Color gradient for aggregation [[r, g, b], ...].\n            pickable: Whether layer responds to hover/click.\n            opacity: Layer opacity.\n            **kwargs: Additional layer props.\n        \"\"\"\n        layer_id = name or f\"hexagon-{len(self._deck_layers)}\"\n        processed_data = self._process_deck_data(data)\n\n        default_color_range = [\n            [1, 152, 189],\n            [73, 227, 206],\n            [216, 254, 181],\n            [254, 237, 177],\n            [254, 173, 84],\n            [209, 55, 78],\n        ]\n\n        self.call_js_method(\n            \"addHexagonLayer\",\n            id=layer_id,\n            data=processed_data,\n            getPosition=get_position,\n            radius=radius,\n            elevationScale=elevation_scale,\n            extruded=extruded,\n            colorRange=color_range or default_color_range,\n            pickable=pickable,\n            opacity=opacity,\n            **kwargs,\n        )\n\n        self._deck_layers = {\n            **self._deck_layers,\n            layer_id: {\"type\": \"HexagonLayer\", \"id\": layer_id},\n        }\n\n    # -------------------------------------------------------------------------\n    # DeckGL Heatmap Layer\n    # -------------------------------------------------------------------------\n\n    def add_heatmap_layer(\n        self,\n        data: Any,\n        name: Optional[str] = None,\n        get_position: Union[str, Callable] = \"coordinates\",\n        get_weight: Union[float, str, Callable] = 1,\n        radius_pixels: float = 30,\n        intensity: float = 1,\n        threshold: float = 0.05,\n        color_range: Optional[List[List[int]]] = None,\n        opacity: float = 1,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a heatmap layer for density visualization.\n\n        Args:\n            data: Array of data objects with position coordinates.\n            name: Layer ID.\n            get_position: Accessor for point position [lng, lat].\n            get_weight: Accessor for point weight.\n            radius_pixels: Influence radius in pixels.\n            intensity: Intensity multiplier.\n            threshold: Minimum density threshold.\n            color_range: Color gradient [[r, g, b, a], ...].\n            opacity: Layer opacity.\n            **kwargs: Additional layer props.\n        \"\"\"\n        layer_id = name or f\"heatmap-{len(self._deck_layers)}\"\n        processed_data = self._process_deck_data(data)\n\n        default_color_range = [\n            [255, 255, 178, 25],\n            [254, 217, 118, 85],\n            [254, 178, 76, 127],\n            [253, 141, 60, 170],\n            [240, 59, 32, 212],\n            [189, 0, 38, 255],\n        ]\n\n        self.call_js_method(\n            \"addHeatmapLayer\",\n            id=layer_id,\n            data=processed_data,\n            getPosition=get_position,\n            getWeight=get_weight,\n            radiusPixels=radius_pixels,\n            intensity=intensity,\n            threshold=threshold,\n            colorRange=color_range or default_color_range,\n            opacity=opacity,\n            **kwargs,\n        )\n\n        self._deck_layers = {\n            **self._deck_layers,\n            layer_id: {\"type\": \"HeatmapLayer\", \"id\": layer_id},\n        }\n\n    # -------------------------------------------------------------------------\n    # DeckGL Grid Layer\n    # -------------------------------------------------------------------------\n\n    def add_grid_layer(\n        self,\n        data: Any,\n        name: Optional[str] = None,\n        get_position: Union[str, Callable] = \"coordinates\",\n        cell_size: float = 200,\n        elevation_scale: float = 4,\n        extruded: bool = True,\n        color_range: Optional[List[List[int]]] = None,\n        pickable: bool = True,\n        opacity: float = 0.8,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a grid layer for square grid aggregation visualization.\n\n        Args:\n            data: Array of data objects with position coordinates.\n            name: Layer ID.\n            get_position: Accessor for point position [lng, lat].\n            cell_size: Grid cell size in meters.\n            elevation_scale: Elevation multiplier for 3D.\n            extruded: Whether to render as 3D cells.\n            color_range: Color gradient [[r, g, b], ...].\n            pickable: Whether layer responds to hover/click.\n            opacity: Layer opacity.\n            **kwargs: Additional layer props.\n        \"\"\"\n        layer_id = name or f\"grid-{len(self._deck_layers)}\"\n        processed_data = self._process_deck_data(data)\n\n        default_color_range = [\n            [1, 152, 189],\n            [73, 227, 206],\n            [216, 254, 181],\n            [254, 237, 177],\n            [254, 173, 84],\n            [209, 55, 78],\n        ]\n\n        self.call_js_method(\n            \"addGridLayer\",\n            id=layer_id,\n            data=processed_data,\n            getPosition=get_position,\n            cellSize=cell_size,\n            elevationScale=elevation_scale,\n            extruded=extruded,\n            colorRange=color_range or default_color_range,\n            pickable=pickable,\n            opacity=opacity,\n            **kwargs,\n        )\n\n        self._deck_layers = {\n            **self._deck_layers,\n            layer_id: {\"type\": \"GridLayer\", \"id\": layer_id},\n        }\n\n    # -------------------------------------------------------------------------\n    # DeckGL Icon Layer\n    # -------------------------------------------------------------------------\n\n    def add_icon_layer(\n        self,\n        data: Any,\n        name: Optional[str] = None,\n        get_position: Union[str, Callable] = \"coordinates\",\n        get_icon: Union[str, Callable] = \"icon\",\n        get_size: Union[float, str, Callable] = 20,\n        get_color: Union[List[int], str, Callable] = None,\n        icon_atlas: Optional[str] = None,\n        icon_mapping: Optional[Dict] = None,\n        pickable: bool = True,\n        opacity: float = 1,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add an icon layer for custom marker visualization.\n\n        Args:\n            data: Array of data objects with position coordinates.\n            name: Layer ID.\n            get_position: Accessor for icon position [lng, lat].\n            get_icon: Accessor for icon name in icon_mapping.\n            get_size: Accessor for icon size.\n            get_color: Accessor for icon tint color [r, g, b, a].\n            icon_atlas: URL to icon atlas image.\n            icon_mapping: Dict mapping icon names to atlas coordinates.\n            pickable: Whether layer responds to hover/click.\n            opacity: Layer opacity.\n            **kwargs: Additional layer props.\n        \"\"\"\n        layer_id = name or f\"icon-{len(self._deck_layers)}\"\n        processed_data = self._process_deck_data(data)\n\n        self.call_js_method(\n            \"addIconLayer\",\n            id=layer_id,\n            data=processed_data,\n            getPosition=get_position,\n            getIcon=get_icon,\n            getSize=get_size,\n            getColor=get_color or [255, 255, 255, 255],\n            iconAtlas=icon_atlas,\n            iconMapping=icon_mapping,\n            pickable=pickable,\n            opacity=opacity,\n            **kwargs,\n        )\n\n        self._deck_layers = {\n            **self._deck_layers,\n            layer_id: {\"type\": \"IconLayer\", \"id\": layer_id},\n        }\n\n    # -------------------------------------------------------------------------\n    # DeckGL Text Layer\n    # -------------------------------------------------------------------------\n\n    def add_text_layer(\n        self,\n        data: Any,\n        name: Optional[str] = None,\n        get_position: Union[str, Callable] = \"coordinates\",\n        get_text: Union[str, Callable] = \"text\",\n        get_size: Union[float, str, Callable] = 12,\n        get_color: Union[List[int], str, Callable] = None,\n        get_angle: Union[float, str, Callable] = 0,\n        text_anchor: str = \"middle\",\n        alignment_baseline: str = \"center\",\n        pickable: bool = True,\n        opacity: float = 1,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a text layer for label visualization.\n\n        Args:\n            data: Array of data objects with position and text.\n            name: Layer ID.\n            get_position: Accessor for text position [lng, lat].\n            get_text: Accessor for text content.\n            get_size: Accessor for text size.\n            get_color: Accessor for text color [r, g, b, a].\n            get_angle: Accessor for text rotation in degrees.\n            text_anchor: Horizontal alignment ('start', 'middle', 'end').\n            alignment_baseline: Vertical alignment ('top', 'center', 'bottom').\n            pickable: Whether layer responds to hover/click.\n            opacity: Layer opacity.\n            **kwargs: Additional layer props.\n        \"\"\"\n        layer_id = name or f\"text-{len(self._deck_layers)}\"\n        processed_data = self._process_deck_data(data)\n\n        self.call_js_method(\n            \"addTextLayer\",\n            id=layer_id,\n            data=processed_data,\n            getPosition=get_position,\n            getText=get_text,\n            getSize=get_size,\n            getColor=get_color or [0, 0, 0, 255],\n            getAngle=get_angle,\n            getTextAnchor=text_anchor,\n            getAlignmentBaseline=alignment_baseline,\n            pickable=pickable,\n            opacity=opacity,\n            **kwargs,\n        )\n\n        self._deck_layers = {\n            **self._deck_layers,\n            layer_id: {\"type\": \"TextLayer\", \"id\": layer_id},\n        }\n\n    # -------------------------------------------------------------------------\n    # DeckGL GeoJSON Layer\n    # -------------------------------------------------------------------------\n\n    def add_geojson_layer(\n        self,\n        data: Any,\n        name: Optional[str] = None,\n        get_fill_color: Union[List[int], str, Callable] = None,\n        get_line_color: Union[List[int], str, Callable] = None,\n        get_line_width: Union[float, str, Callable] = 1,\n        get_point_radius: Union[float, str, Callable] = 5,\n        get_elevation: Union[float, str, Callable] = 0,\n        extruded: bool = False,\n        wireframe: bool = False,\n        filled: bool = True,\n        stroked: bool = True,\n        line_width_min_pixels: float = 1,\n        point_radius_min_pixels: float = 2,\n        pickable: bool = True,\n        opacity: float = 0.8,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a GeoJSON layer for rendering GeoJSON features.\n\n        Args:\n            data: GeoJSON object or URL.\n            name: Layer ID.\n            get_fill_color: Accessor for fill color [r, g, b, a].\n            get_line_color: Accessor for stroke color [r, g, b, a].\n            get_line_width: Accessor for stroke width.\n            get_point_radius: Accessor for point radius.\n            get_elevation: Accessor for 3D extrusion height.\n            extruded: Whether to render as 3D features.\n            wireframe: Whether to render wireframe (extruded only).\n            filled: Whether to fill features.\n            stroked: Whether to draw stroke.\n            line_width_min_pixels: Minimum stroke width.\n            point_radius_min_pixels: Minimum point radius.\n            pickable: Whether layer responds to hover/click.\n            opacity: Layer opacity.\n            **kwargs: Additional layer props.\n        \"\"\"\n        layer_id = name or f\"geojson-{len(self._deck_layers)}\"\n        processed_data = self._process_deck_data(data)\n\n        self.call_js_method(\n            \"addGeoJsonLayer\",\n            id=layer_id,\n            data=processed_data,\n            getFillColor=get_fill_color or [51, 136, 255, 128],\n            getLineColor=get_line_color or [0, 0, 0, 255],\n            getLineWidth=get_line_width,\n            getPointRadius=get_point_radius,\n            getElevation=get_elevation,\n            extruded=extruded,\n            wireframe=wireframe,\n            filled=filled,\n            stroked=stroked,\n            lineWidthMinPixels=line_width_min_pixels,\n            pointRadiusMinPixels=point_radius_min_pixels,\n            pickable=pickable,\n            opacity=opacity,\n            **kwargs,\n        )\n\n        self._deck_layers = {\n            **self._deck_layers,\n            layer_id: {\"type\": \"GeoJsonLayer\", \"id\": layer_id},\n        }\n\n    # -------------------------------------------------------------------------\n    # DeckGL Contour Layer\n    # -------------------------------------------------------------------------\n\n    def add_contour_layer(\n        self,\n        data: Any,\n        name: Optional[str] = None,\n        get_position: Union[str, Callable] = \"coordinates\",\n        get_weight: Union[float, str, Callable] = 1,\n        cell_size: float = 200,\n        contours: Optional[List[Dict]] = None,\n        pickable: bool = True,\n        opacity: float = 1,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a contour layer for isoline visualization.\n\n        Args:\n            data: Array of data objects with position coordinates.\n            name: Layer ID.\n            get_position: Accessor for point position [lng, lat].\n            get_weight: Accessor for point weight.\n            cell_size: Grid cell size for aggregation.\n            contours: Contour definitions [{threshold, color, strokeWidth}, ...].\n            pickable: Whether layer responds to hover/click.\n            opacity: Layer opacity.\n            **kwargs: Additional layer props.\n        \"\"\"\n        layer_id = name or f\"contour-{len(self._deck_layers)}\"\n        processed_data = self._process_deck_data(data)\n\n        default_contours = [\n            {\"threshold\": 1, \"color\": [255, 255, 255], \"strokeWidth\": 1},\n            {\"threshold\": 5, \"color\": [51, 136, 255], \"strokeWidth\": 2},\n            {\"threshold\": 10, \"color\": [0, 0, 255], \"strokeWidth\": 3},\n        ]\n\n        self.call_js_method(\n            \"addContourLayer\",\n            id=layer_id,\n            data=processed_data,\n            getPosition=get_position,\n            getWeight=get_weight,\n            cellSize=cell_size,\n            contours=contours or default_contours,\n            pickable=pickable,\n            opacity=opacity,\n            **kwargs,\n        )\n\n        self._deck_layers = {\n            **self._deck_layers,\n            layer_id: {\"type\": \"ContourLayer\", \"id\": layer_id},\n        }\n\n    # -------------------------------------------------------------------------\n    # DeckGL Screen Grid Layer\n    # -------------------------------------------------------------------------\n\n    def add_screen_grid_layer(\n        self,\n        data: Any,\n        name: Optional[str] = None,\n        get_position: Union[str, Callable] = \"coordinates\",\n        get_weight: Union[float, str, Callable] = 1,\n        cell_size_pixels: float = 50,\n        color_range: Optional[List[List[int]]] = None,\n        pickable: bool = True,\n        opacity: float = 0.8,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a screen grid layer for screen-space grid aggregation.\n\n        Args:\n            data: Array of data objects with position coordinates.\n            name: Layer ID.\n            get_position: Accessor for point position [lng, lat].\n            get_weight: Accessor for point weight.\n            cell_size_pixels: Grid cell size in pixels.\n            color_range: Color gradient [[r, g, b, a], ...].\n            pickable: Whether layer responds to hover/click.\n            opacity: Layer opacity.\n            **kwargs: Additional layer props.\n        \"\"\"\n        layer_id = name or f\"screengrid-{len(self._deck_layers)}\"\n        processed_data = self._process_deck_data(data)\n\n        default_color_range = [\n            [255, 255, 178, 25],\n            [254, 217, 118, 85],\n            [254, 178, 76, 127],\n            [253, 141, 60, 170],\n            [240, 59, 32, 212],\n            [189, 0, 38, 255],\n        ]\n\n        self.call_js_method(\n            \"addScreenGridLayer\",\n            id=layer_id,\n            data=processed_data,\n            getPosition=get_position,\n            getWeight=get_weight,\n            cellSizePixels=cell_size_pixels,\n            colorRange=color_range or default_color_range,\n            pickable=pickable,\n            opacity=opacity,\n            **kwargs,\n        )\n\n        self._deck_layers = {\n            **self._deck_layers,\n            layer_id: {\"type\": \"ScreenGridLayer\", \"id\": layer_id},\n        }\n\n    # -------------------------------------------------------------------------\n    # Generic DeckGL Layer\n    # -------------------------------------------------------------------------\n\n    def add_deckgl_layer(\n        self,\n        layer_type: str,\n        data: Any,\n        name: Optional[str] = None,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a generic deck.gl layer to the map.\n\n        This method provides a flexible way to add any supported deck.gl layer\n        type using a single interface. For commonly used layers, prefer the\n        specific methods (e.g., add_scatterplot_layer) for better IDE support.\n\n        Args:\n            layer_type: The deck.gl layer type. Supported types include:\n                'ScatterplotLayer', 'ArcLayer', 'PathLayer', 'PolygonLayer',\n                'HexagonLayer', 'HeatmapLayer', 'GridLayer', 'IconLayer',\n                'TextLayer', 'GeoJsonLayer', 'ContourLayer', 'ScreenGridLayer',\n                'PointCloudLayer', 'TripsLayer', 'LineLayer'.\n            data: Array of data objects or GeoJSON.\n            name: Layer ID. If None, auto-generated from layer_type.\n            **kwargs: Layer-specific properties passed directly to deck.gl.\n                Common properties include:\n                - opacity: Layer opacity (0-1)\n                - pickable: Whether layer responds to hover/click\n                - getPosition: Accessor for position coordinates\n                - getColor/getFillColor/getLineColor: Color accessors\n\n        Example:\n            &gt;&gt;&gt; m = DeckGLMap()\n            &gt;&gt;&gt; # Add a TripsLayer with animation\n            &gt;&gt;&gt; m.add_deckgl_layer(\n            ...     'TripsLayer',\n            ...     data=trips_data,\n            ...     getPath='waypoints',\n            ...     getTimestamps='timestamps',\n            ...     getColor=[253, 128, 93],\n            ...     trailLength=180,\n            ... )\n            &gt;&gt;&gt; # Add a LineLayer\n            &gt;&gt;&gt; m.add_deckgl_layer(\n            ...     'LineLayer',\n            ...     data=lines_data,\n            ...     getSourcePosition='source',\n            ...     getTargetPosition='target',\n            ...     getColor=[0, 128, 255],\n            ... )\n        \"\"\"\n        # Normalize layer type and create prefix\n        layer_type_clean = layer_type.replace(\"Layer\", \"\")\n        prefix = layer_type_clean.lower()\n        layer_id = name or f\"{prefix}-{len(self._deck_layers)}\"\n        processed_data = self._process_deck_data(data)\n\n        self.call_js_method(\n            \"addDeckGLLayer\",\n            layerType=layer_type,\n            id=layer_id,\n            data=processed_data,\n            **kwargs,\n        )\n\n        self._deck_layers = {\n            **self._deck_layers,\n            layer_id: {\"type\": layer_type, \"id\": layer_id},\n        }\n\n    # -------------------------------------------------------------------------\n    # DeckGL Trips Layer\n    # -------------------------------------------------------------------------\n\n    def add_trips_layer(\n        self,\n        data: Any,\n        name: Optional[str] = None,\n        get_path: Union[str, Callable] = \"waypoints\",\n        get_timestamps: Union[str, Callable] = \"timestamps\",\n        get_color: Union[List[int], str, Callable] = None,\n        width_min_pixels: float = 2,\n        trail_length: float = 180,\n        current_time: float = 0,\n        pickable: bool = True,\n        opacity: float = 0.8,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a trips layer for animated path visualization.\n\n        The TripsLayer renders animated paths showing movement over time,\n        ideal for visualizing vehicle routes, migration patterns, or any\n        time-based trajectory data.\n\n        Args:\n            data: Array of trip objects with waypoints and timestamps.\n            name: Layer ID. If None, auto-generated.\n            get_path: Accessor for waypoint coordinates [[lng, lat], ...].\n            get_timestamps: Accessor for timestamps at each waypoint.\n            get_color: Accessor for trip color [r, g, b] or [r, g, b, a].\n            width_min_pixels: Minimum trail width in pixels.\n            trail_length: Trail length in timestamp units.\n            current_time: Current animation time.\n            pickable: Whether layer responds to hover/click.\n            opacity: Layer opacity (0-1).\n            **kwargs: Additional TripsLayer props.\n\n        Example:\n            &gt;&gt;&gt; m = DeckGLMap()\n            &gt;&gt;&gt; trips = [\n            ...     {\n            ...         \"waypoints\": [[-122.4, 37.8], [-122.5, 37.7], [-122.6, 37.8]],\n            ...         \"timestamps\": [0, 50, 100]\n            ...     }\n            ... ]\n            &gt;&gt;&gt; m.add_trips_layer(\n            ...     data=trips,\n            ...     trail_length=180,\n            ...     current_time=50,\n            ... )\n        \"\"\"\n        layer_id = name or f\"trips-{len(self._deck_layers)}\"\n        processed_data = self._process_deck_data(data)\n\n        self.call_js_method(\n            \"addTripsLayer\",\n            id=layer_id,\n            data=processed_data,\n            getPath=get_path,\n            getTimestamps=get_timestamps,\n            getColor=get_color or [253, 128, 93],\n            widthMinPixels=width_min_pixels,\n            trailLength=trail_length,\n            currentTime=current_time,\n            pickable=pickable,\n            opacity=opacity,\n            **kwargs,\n        )\n\n        self._deck_layers = {\n            **self._deck_layers,\n            layer_id: {\"type\": \"TripsLayer\", \"id\": layer_id},\n        }\n\n    # -------------------------------------------------------------------------\n    # DeckGL Line Layer\n    # -------------------------------------------------------------------------\n\n    def add_line_layer(\n        self,\n        data: Any,\n        name: Optional[str] = None,\n        get_source_position: Union[str, Callable] = \"sourcePosition\",\n        get_target_position: Union[str, Callable] = \"targetPosition\",\n        get_color: Union[List[int], str, Callable] = None,\n        get_width: Union[float, str, Callable] = 1,\n        width_min_pixels: float = 1,\n        pickable: bool = True,\n        opacity: float = 0.8,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a line layer for simple line segment visualization.\n\n        The LineLayer renders straight line segments between source and\n        target positions. Unlike ArcLayer, lines are drawn directly\n        without curvature.\n\n        Args:\n            data: Array of line objects with source/target positions.\n            name: Layer ID. If None, auto-generated.\n            get_source_position: Accessor for source position [lng, lat].\n            get_target_position: Accessor for target position [lng, lat].\n            get_color: Accessor for line color [r, g, b] or [r, g, b, a].\n            get_width: Accessor for line width.\n            width_min_pixels: Minimum line width in pixels.\n            pickable: Whether layer responds to hover/click.\n            opacity: Layer opacity (0-1).\n            **kwargs: Additional LineLayer props.\n\n        Example:\n            &gt;&gt;&gt; m = DeckGLMap()\n            &gt;&gt;&gt; lines = [\n            ...     {\"sourcePosition\": [-122.4, 37.8], \"targetPosition\": [-122.5, 37.7]},\n            ...     {\"sourcePosition\": [-122.5, 37.7], \"targetPosition\": [-122.6, 37.8]},\n            ... ]\n            &gt;&gt;&gt; m.add_line_layer(\n            ...     data=lines,\n            ...     get_color=[0, 128, 255],\n            ...     get_width=2,\n            ... )\n        \"\"\"\n        layer_id = name or f\"line-{len(self._deck_layers)}\"\n        processed_data = self._process_deck_data(data)\n\n        self.call_js_method(\n            \"addLineLayer\",\n            id=layer_id,\n            data=processed_data,\n            getSourcePosition=get_source_position,\n            getTargetPosition=get_target_position,\n            getColor=get_color or [51, 136, 255, 200],\n            getWidth=get_width,\n            widthMinPixels=width_min_pixels,\n            pickable=pickable,\n            opacity=opacity,\n            **kwargs,\n        )\n\n        self._deck_layers = {\n            **self._deck_layers,\n            layer_id: {\"type\": \"LineLayer\", \"id\": layer_id},\n        }\n\n    # -------------------------------------------------------------------------\n    # DeckGL COG Layer\n    # -------------------------------------------------------------------------\n\n    def add_cog_layer(\n        self,\n        url: str,\n        name: Optional[str] = None,\n        opacity: float = 1.0,\n        visible: bool = True,\n        debug: bool = False,\n        debug_opacity: float = 0.25,\n        max_error: float = 0.125,\n        fit_bounds: bool = True,\n        before_id: Optional[str] = None,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a Cloud Optimized GeoTIFF (COG) layer using @developmentseed/deck.gl-geotiff.\n\n        This method renders COG files directly in the browser using GPU-accelerated\n        deck.gl rendering with automatic reprojection support.\n\n        Args:\n            url: URL to the Cloud Optimized GeoTIFF file.\n            name: Layer ID. If None, auto-generated.\n            opacity: Layer opacity (0-1).\n            visible: Whether layer is visible.\n            debug: Show reprojection mesh for debugging.\n            debug_opacity: Opacity of debug mesh (0-1).\n            max_error: Maximum reprojection error in pixels. Lower values\n                create denser mesh for better accuracy.\n            fit_bounds: Whether to fit map to COG bounds after loading.\n            before_id: ID of layer to insert before.\n            **kwargs: Additional COGLayer props.\n\n        Example:\n            &gt;&gt;&gt; m = DeckGLMap()\n            &gt;&gt;&gt; m.add_cog_layer(\n            ...     \"https://example.com/landcover.tif\",\n            ...     name=\"landcover\",\n            ...     opacity=0.8\n            ... )\n        \"\"\"\n        # Use a monotonically increasing counter to avoid ID collisions when layers are removed.\n        counter = getattr(self, \"_cog_layer_counter\", 0)\n        layer_id = name or f\"cog-{counter}\"\n        self._cog_layer_counter = counter + 1\n\n        self.call_js_method(\n            \"addCOGLayer\",\n            id=layer_id,\n            geotiff=url,\n            opacity=opacity,\n            visible=visible,\n            debug=debug,\n            debugOpacity=debug_opacity,\n            maxError=max_error,\n            fitBounds=fit_bounds,\n            beforeId=before_id,\n            **kwargs,\n        )\n\n        self._deck_layers = {\n            **self._deck_layers,\n            layer_id: {\"type\": \"COGLayer\", \"id\": layer_id, \"url\": url},\n        }\n\n    # -------------------------------------------------------------------------\n    # New DeckGL Layer Types\n    # -------------------------------------------------------------------------\n\n    def add_bitmap_layer(\n        self,\n        image: str,\n        bounds: List[float],\n        name: Optional[str] = None,\n        opacity: float = 1.0,\n        visible: bool = True,\n        pickable: bool = False,\n        desaturate: float = 0,\n        transparent_color: Optional[List[int]] = None,\n        tint_color: Optional[List[int]] = None,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a bitmap layer for raster image overlay.\n\n        Args:\n            image: URL or data URI of the image.\n            bounds: Bounding box [west, south, east, north].\n            name: Layer ID.\n            opacity: Layer opacity (0-1).\n            visible: Whether layer is visible.\n            pickable: Whether layer responds to hover/click.\n            desaturate: Desaturation amount (0-1).\n            transparent_color: Color to make transparent [r, g, b, a].\n            tint_color: Color to tint the image [r, g, b].\n            **kwargs: Additional BitmapLayer props.\n        \"\"\"\n        layer_id = name or f\"bitmap-{len(self._deck_layers)}\"\n\n        self.call_js_method(\n            \"addBitmapLayer\",\n            id=layer_id,\n            image=image,\n            bounds=bounds,\n            opacity=opacity,\n            visible=visible,\n            pickable=pickable,\n            desaturate=desaturate,\n            transparentColor=transparent_color or [0, 0, 0, 0],\n            tintColor=tint_color or [255, 255, 255],\n            **kwargs,\n        )\n\n        self._deck_layers = {\n            **self._deck_layers,\n            layer_id: {\"type\": \"BitmapLayer\", \"id\": layer_id},\n        }\n\n    def add_column_layer(\n        self,\n        data: Any,\n        name: Optional[str] = None,\n        get_position: Union[str, Callable] = \"coordinates\",\n        get_fill_color: Union[List[int], str, Callable] = None,\n        get_line_color: Union[List[int], str, Callable] = None,\n        get_elevation: Union[float, str, Callable] = 1000,\n        radius: float = 1000,\n        disk_resolution: int = 20,\n        elevation_scale: float = 1,\n        coverage: float = 1,\n        extruded: bool = True,\n        filled: bool = True,\n        stroked: bool = False,\n        wireframe: bool = False,\n        pickable: bool = True,\n        opacity: float = 0.8,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a column layer for 3D column/bar visualization.\n\n        Args:\n            data: Array of data objects with position coordinates.\n            name: Layer ID.\n            get_position: Accessor for column position [lng, lat].\n            get_fill_color: Accessor for fill color [r, g, b, a].\n            get_line_color: Accessor for stroke color [r, g, b, a].\n            get_elevation: Accessor for column height.\n            radius: Column radius in meters.\n            disk_resolution: Number of sides for column polygon.\n            elevation_scale: Elevation multiplier.\n            coverage: Column coverage (0-1).\n            extruded: Whether to extrude columns.\n            filled: Whether to fill columns.\n            stroked: Whether to stroke columns.\n            wireframe: Whether to render as wireframe.\n            pickable: Whether layer responds to hover/click.\n            opacity: Layer opacity.\n            **kwargs: Additional ColumnLayer props.\n        \"\"\"\n        layer_id = name or f\"column-{len(self._deck_layers)}\"\n        processed_data = self._process_deck_data(data)\n\n        self.call_js_method(\n            \"addColumnLayer\",\n            id=layer_id,\n            data=processed_data,\n            getPosition=get_position,\n            getFillColor=get_fill_color or [255, 140, 0, 200],\n            getLineColor=get_line_color or [0, 0, 0, 255],\n            getElevation=get_elevation,\n            radius=radius,\n            diskResolution=disk_resolution,\n            elevationScale=elevation_scale,\n            coverage=coverage,\n            extruded=extruded,\n            filled=filled,\n            stroked=stroked,\n            wireframe=wireframe,\n            pickable=pickable,\n            opacity=opacity,\n            **kwargs,\n        )\n\n        self._deck_layers = {\n            **self._deck_layers,\n            layer_id: {\"type\": \"ColumnLayer\", \"id\": layer_id},\n        }\n\n    def add_grid_cell_layer(\n        self,\n        data: Any,\n        name: Optional[str] = None,\n        get_position: Union[str, Callable] = \"coordinates\",\n        get_color: Union[List[int], str, Callable] = None,\n        get_elevation: Union[float, str, Callable] = 1000,\n        cell_size: float = 200,\n        coverage: float = 1,\n        elevation_scale: float = 1,\n        extruded: bool = True,\n        pickable: bool = True,\n        opacity: float = 0.8,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a grid cell layer for pre-aggregated grid visualization.\n\n        Args:\n            data: Array of data objects with position coordinates.\n            name: Layer ID.\n            get_position: Accessor for cell position [lng, lat].\n            get_color: Accessor for cell color [r, g, b, a].\n            get_elevation: Accessor for cell height.\n            cell_size: Cell size in meters.\n            coverage: Cell coverage (0-1).\n            elevation_scale: Elevation multiplier.\n            extruded: Whether to extrude cells.\n            pickable: Whether layer responds to hover/click.\n            opacity: Layer opacity.\n            **kwargs: Additional GridCellLayer props.\n        \"\"\"\n        layer_id = name or f\"gridcell-{len(self._deck_layers)}\"\n        processed_data = self._process_deck_data(data)\n\n        self.call_js_method(\n            \"addGridCellLayer\",\n            id=layer_id,\n            data=processed_data,\n            getPosition=get_position,\n            getColor=get_color or [255, 140, 0, 200],\n            getElevation=get_elevation,\n            cellSize=cell_size,\n            coverage=coverage,\n            elevationScale=elevation_scale,\n            extruded=extruded,\n            pickable=pickable,\n            opacity=opacity,\n            **kwargs,\n        )\n\n        self._deck_layers = {\n            **self._deck_layers,\n            layer_id: {\"type\": \"GridCellLayer\", \"id\": layer_id},\n        }\n\n    def add_solid_polygon_layer(\n        self,\n        data: Any,\n        name: Optional[str] = None,\n        get_polygon: Union[str, Callable] = \"polygon\",\n        get_fill_color: Union[List[int], str, Callable] = None,\n        get_line_color: Union[List[int], str, Callable] = None,\n        get_elevation: Union[float, str, Callable] = 0,\n        filled: bool = True,\n        extruded: bool = False,\n        wireframe: bool = False,\n        elevation_scale: float = 1,\n        pickable: bool = True,\n        opacity: float = 0.8,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a solid polygon layer for filled polygon visualization.\n\n        Args:\n            data: Array of data objects with polygon coordinates.\n            name: Layer ID.\n            get_polygon: Accessor for polygon coordinates.\n            get_fill_color: Accessor for fill color [r, g, b, a].\n            get_line_color: Accessor for stroke color [r, g, b, a].\n            get_elevation: Accessor for 3D extrusion height.\n            filled: Whether to fill polygons.\n            extruded: Whether to render as 3D polygons.\n            wireframe: Whether to render wireframe.\n            elevation_scale: Elevation multiplier.\n            pickable: Whether layer responds to hover/click.\n            opacity: Layer opacity.\n            **kwargs: Additional SolidPolygonLayer props.\n        \"\"\"\n        layer_id = name or f\"solidpolygon-{len(self._deck_layers)}\"\n        processed_data = self._process_deck_data(data)\n\n        self.call_js_method(\n            \"addSolidPolygonLayer\",\n            id=layer_id,\n            data=processed_data,\n            getPolygon=get_polygon,\n            getFillColor=get_fill_color or [51, 136, 255, 128],\n            getLineColor=get_line_color or [0, 0, 0, 255],\n            getElevation=get_elevation,\n            filled=filled,\n            extruded=extruded,\n            wireframe=wireframe,\n            elevationScale=elevation_scale,\n            pickable=pickable,\n            opacity=opacity,\n            **kwargs,\n        )\n\n        self._deck_layers = {\n            **self._deck_layers,\n            layer_id: {\"type\": \"SolidPolygonLayer\", \"id\": layer_id},\n        }\n\n    def add_tile_layer(\n        self,\n        data: Union[str, List[str]],\n        name: Optional[str] = None,\n        min_zoom: int = 0,\n        max_zoom: int = 19,\n        tile_size: int = 256,\n        pickable: bool = False,\n        visible: bool = True,\n        opacity: float = 1.0,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a tile layer for raster tile visualization.\n\n        Args:\n            data: Tile URL template with {z}/{x}/{y} placeholders.\n            name: Layer ID.\n            min_zoom: Minimum zoom level.\n            max_zoom: Maximum zoom level.\n            tile_size: Tile size in pixels.\n            pickable: Whether layer responds to hover/click.\n            visible: Whether layer is visible.\n            opacity: Layer opacity (0-1).\n            **kwargs: Additional TileLayer props.\n        \"\"\"\n        layer_id = name or f\"tile-{len(self._deck_layers)}\"\n\n        self.call_js_method(\n            \"addTileLayer\",\n            id=layer_id,\n            data=data,\n            minZoom=min_zoom,\n            maxZoom=max_zoom,\n            tileSize=tile_size,\n            pickable=pickable,\n            visible=visible,\n            opacity=opacity,\n            **kwargs,\n        )\n\n        self._deck_layers = {\n            **self._deck_layers,\n            layer_id: {\"type\": \"TileLayer\", \"id\": layer_id},\n        }\n\n    def add_mvt_layer(\n        self,\n        data: Union[str, List[str]],\n        name: Optional[str] = None,\n        min_zoom: int = 0,\n        max_zoom: int = 14,\n        binary: bool = True,\n        get_fill_color: Union[List[int], str, Callable] = None,\n        get_line_color: Union[List[int], str, Callable] = None,\n        get_line_width: Union[float, str, Callable] = 1,\n        get_point_radius: Union[float, str, Callable] = 5,\n        line_width_min_pixels: float = 1,\n        point_radius_min_pixels: float = 2,\n        pickable: bool = True,\n        visible: bool = True,\n        opacity: float = 1.0,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a Mapbox Vector Tile (MVT) layer.\n\n        Args:\n            data: MVT tile URL template with {z}/{x}/{y} placeholders.\n            name: Layer ID.\n            min_zoom: Minimum zoom level.\n            max_zoom: Maximum zoom level.\n            binary: Whether to use binary format.\n            get_fill_color: Accessor for fill color [r, g, b, a].\n            get_line_color: Accessor for stroke color [r, g, b, a].\n            get_line_width: Accessor for line width.\n            get_point_radius: Accessor for point radius.\n            line_width_min_pixels: Minimum line width in pixels.\n            point_radius_min_pixels: Minimum point radius in pixels.\n            pickable: Whether layer responds to hover/click.\n            visible: Whether layer is visible.\n            opacity: Layer opacity (0-1).\n            **kwargs: Additional MVTLayer props.\n        \"\"\"\n        layer_id = name or f\"mvt-{len(self._deck_layers)}\"\n\n        self.call_js_method(\n            \"addMVTLayer\",\n            id=layer_id,\n            data=data,\n            minZoom=min_zoom,\n            maxZoom=max_zoom,\n            binary=binary,\n            getFillColor=get_fill_color or [51, 136, 255, 128],\n            getLineColor=get_line_color or [0, 0, 0, 255],\n            getLineWidth=get_line_width,\n            getPointRadius=get_point_radius,\n            lineWidthMinPixels=line_width_min_pixels,\n            pointRadiusMinPixels=point_radius_min_pixels,\n            pickable=pickable,\n            visible=visible,\n            opacity=opacity,\n            **kwargs,\n        )\n\n        self._deck_layers = {\n            **self._deck_layers,\n            layer_id: {\"type\": \"MVTLayer\", \"id\": layer_id},\n        }\n\n    def add_tile3d_layer(\n        self,\n        data: str,\n        name: Optional[str] = None,\n        point_size: float = 1,\n        pickable: bool = True,\n        visible: bool = True,\n        opacity: float = 1.0,\n        load_options: Optional[Dict] = None,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a 3D Tiles layer for 3D building/terrain visualization.\n\n        Args:\n            data: URL to tileset.json.\n            name: Layer ID.\n            point_size: Point size for point cloud tiles.\n            pickable: Whether layer responds to hover/click.\n            visible: Whether layer is visible.\n            opacity: Layer opacity (0-1).\n            load_options: Loader options for tile loading.\n            **kwargs: Additional Tile3DLayer props.\n        \"\"\"\n        layer_id = name or f\"tile3d-{len(self._deck_layers)}\"\n\n        self.call_js_method(\n            \"addTile3DLayer\",\n            id=layer_id,\n            data=data,\n            pointSize=point_size,\n            pickable=pickable,\n            visible=visible,\n            opacity=opacity,\n            loadOptions=load_options or {},\n            **kwargs,\n        )\n\n        self._deck_layers = {\n            **self._deck_layers,\n            layer_id: {\"type\": \"Tile3DLayer\", \"id\": layer_id},\n        }\n\n    def add_terrain_layer(\n        self,\n        elevation_data: Union[str, List[str]],\n        name: Optional[str] = None,\n        texture: Optional[str] = None,\n        mesh_max_error: float = 4.0,\n        bounds: Optional[List[float]] = None,\n        elevation_decoder: Optional[Dict] = None,\n        pickable: bool = False,\n        visible: bool = True,\n        opacity: float = 1.0,\n        wireframe: bool = False,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a terrain layer for 3D terrain visualization.\n\n        Args:\n            elevation_data: URL to elevation tiles (e.g., Mapbox terrain).\n            name: Layer ID.\n            texture: URL to texture tiles for terrain surface.\n            mesh_max_error: Maximum mesh error in meters.\n            bounds: Bounding box [west, south, east, north].\n            elevation_decoder: Decoder for elevation data format.\n            pickable: Whether layer responds to hover/click.\n            visible: Whether layer is visible.\n            opacity: Layer opacity (0-1).\n            wireframe: Whether to render as wireframe.\n            **kwargs: Additional TerrainLayer props.\n        \"\"\"\n        layer_id = name or f\"terrain-{len(self._deck_layers)}\"\n\n        default_decoder = {\n            \"rScaler\": 256,\n            \"gScaler\": 1,\n            \"bScaler\": 1 / 256,\n            \"offset\": -32768,\n        }\n\n        self.call_js_method(\n            \"addTerrainLayer\",\n            id=layer_id,\n            elevationData=elevation_data,\n            texture=texture,\n            meshMaxError=mesh_max_error,\n            bounds=bounds,\n            elevationDecoder=elevation_decoder or default_decoder,\n            pickable=pickable,\n            visible=visible,\n            opacity=opacity,\n            wireframe=wireframe,\n            **kwargs,\n        )\n\n        self._deck_layers = {\n            **self._deck_layers,\n            layer_id: {\"type\": \"TerrainLayer\", \"id\": layer_id},\n        }\n\n    def add_great_circle_layer(\n        self,\n        data: Any,\n        name: Optional[str] = None,\n        get_source_position: Union[str, Callable] = \"source\",\n        get_target_position: Union[str, Callable] = \"target\",\n        get_source_color: Union[List[int], str, Callable] = None,\n        get_target_color: Union[List[int], str, Callable] = None,\n        get_width: Union[float, str, Callable] = 1,\n        width_min_pixels: float = 1,\n        width_max_pixels: float = 100,\n        pickable: bool = True,\n        opacity: float = 0.8,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a great circle layer for geodesic arc visualization.\n\n        Args:\n            data: Array of data objects with source/target coordinates.\n            name: Layer ID.\n            get_source_position: Accessor for source position [lng, lat].\n            get_target_position: Accessor for target position [lng, lat].\n            get_source_color: Accessor for source color [r, g, b, a].\n            get_target_color: Accessor for target color [r, g, b, a].\n            get_width: Accessor for line width.\n            width_min_pixels: Minimum line width in pixels.\n            width_max_pixels: Maximum line width in pixels.\n            pickable: Whether layer responds to hover/click.\n            opacity: Layer opacity.\n            **kwargs: Additional GreatCircleLayer props.\n        \"\"\"\n        layer_id = name or f\"greatcircle-{len(self._deck_layers)}\"\n        processed_data = self._process_deck_data(data)\n\n        self.call_js_method(\n            \"addGreatCircleLayer\",\n            id=layer_id,\n            data=processed_data,\n            getSourcePosition=get_source_position,\n            getTargetPosition=get_target_position,\n            getSourceColor=get_source_color or [51, 136, 255, 255],\n            getTargetColor=get_target_color or [255, 136, 51, 255],\n            getWidth=get_width,\n            widthMinPixels=width_min_pixels,\n            widthMaxPixels=width_max_pixels,\n            pickable=pickable,\n            opacity=opacity,\n            **kwargs,\n        )\n\n        self._deck_layers = {\n            **self._deck_layers,\n            layer_id: {\"type\": \"GreatCircleLayer\", \"id\": layer_id},\n        }\n\n    def add_h3_hexagon_layer(\n        self,\n        data: Any,\n        name: Optional[str] = None,\n        get_hexagon: Union[str, Callable] = \"hexagon\",\n        get_fill_color: Union[List[int], str, Callable] = None,\n        get_line_color: Union[List[int], str, Callable] = None,\n        get_elevation: Union[float, str, Callable] = 0,\n        filled: bool = True,\n        stroked: bool = True,\n        extruded: bool = False,\n        wireframe: bool = False,\n        elevation_scale: float = 1,\n        coverage: float = 1,\n        high_precision: bool = False,\n        pickable: bool = True,\n        opacity: float = 0.8,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add an H3 hexagon layer for H3 spatial index visualization.\n\n        Args:\n            data: Array of data objects with H3 index.\n            name: Layer ID.\n            get_hexagon: Accessor for H3 index string.\n            get_fill_color: Accessor for fill color [r, g, b, a].\n            get_line_color: Accessor for stroke color [r, g, b, a].\n            get_elevation: Accessor for 3D extrusion height.\n            filled: Whether to fill hexagons.\n            stroked: Whether to stroke hexagons.\n            extruded: Whether to render as 3D hexagons.\n            wireframe: Whether to render wireframe.\n            elevation_scale: Elevation multiplier.\n            coverage: Hexagon coverage (0-1).\n            high_precision: Use high precision rendering.\n            pickable: Whether layer responds to hover/click.\n            opacity: Layer opacity.\n            **kwargs: Additional H3HexagonLayer props.\n        \"\"\"\n        layer_id = name or f\"h3hexagon-{len(self._deck_layers)}\"\n        processed_data = self._process_deck_data(data)\n\n        self.call_js_method(\n            \"addH3HexagonLayer\",\n            id=layer_id,\n            data=processed_data,\n            getHexagon=get_hexagon,\n            getFillColor=get_fill_color or [51, 136, 255, 128],\n            getLineColor=get_line_color or [0, 0, 0, 255],\n            getElevation=get_elevation,\n            filled=filled,\n            stroked=stroked,\n            extruded=extruded,\n            wireframe=wireframe,\n            elevationScale=elevation_scale,\n            coverage=coverage,\n            highPrecision=high_precision,\n            pickable=pickable,\n            opacity=opacity,\n            **kwargs,\n        )\n\n        self._deck_layers = {\n            **self._deck_layers,\n            layer_id: {\"type\": \"H3HexagonLayer\", \"id\": layer_id},\n        }\n\n    def add_h3_cluster_layer(\n        self,\n        data: Any,\n        name: Optional[str] = None,\n        get_hexagons: Union[str, Callable] = \"hexagons\",\n        get_fill_color: Union[List[int], str, Callable] = None,\n        get_line_color: Union[List[int], str, Callable] = None,\n        get_line_width: Union[float, str, Callable] = 1,\n        filled: bool = True,\n        stroked: bool = True,\n        extruded: bool = False,\n        elevation_scale: float = 1,\n        pickable: bool = True,\n        opacity: float = 0.8,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add an H3 cluster layer for grouped H3 cell visualization.\n\n        Args:\n            data: Array of data objects with H3 index arrays.\n            name: Layer ID.\n            get_hexagons: Accessor for array of H3 index strings.\n            get_fill_color: Accessor for fill color [r, g, b, a].\n            get_line_color: Accessor for stroke color [r, g, b, a].\n            get_line_width: Accessor for line width.\n            filled: Whether to fill clusters.\n            stroked: Whether to stroke clusters.\n            extruded: Whether to render as 3D.\n            elevation_scale: Elevation multiplier.\n            pickable: Whether layer responds to hover/click.\n            opacity: Layer opacity.\n            **kwargs: Additional H3ClusterLayer props.\n        \"\"\"\n        layer_id = name or f\"h3cluster-{len(self._deck_layers)}\"\n        processed_data = self._process_deck_data(data)\n\n        self.call_js_method(\n            \"addH3ClusterLayer\",\n            id=layer_id,\n            data=processed_data,\n            getHexagons=get_hexagons,\n            getFillColor=get_fill_color or [51, 136, 255, 128],\n            getLineColor=get_line_color or [0, 0, 0, 255],\n            getLineWidth=get_line_width,\n            filled=filled,\n            stroked=stroked,\n            extruded=extruded,\n            elevationScale=elevation_scale,\n            pickable=pickable,\n            opacity=opacity,\n            **kwargs,\n        )\n\n        self._deck_layers = {\n            **self._deck_layers,\n            layer_id: {\"type\": \"H3ClusterLayer\", \"id\": layer_id},\n        }\n\n    def add_s2_layer(\n        self,\n        data: Any,\n        name: Optional[str] = None,\n        get_s2_token: Union[str, Callable] = \"s2Token\",\n        get_fill_color: Union[List[int], str, Callable] = None,\n        get_line_color: Union[List[int], str, Callable] = None,\n        get_line_width: Union[float, str, Callable] = 1,\n        get_elevation: Union[float, str, Callable] = 0,\n        filled: bool = True,\n        stroked: bool = True,\n        extruded: bool = False,\n        wireframe: bool = False,\n        elevation_scale: float = 1,\n        pickable: bool = True,\n        opacity: float = 0.8,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add an S2 layer for S2 geometry cell visualization.\n\n        Args:\n            data: Array of data objects with S2 token.\n            name: Layer ID.\n            get_s2_token: Accessor for S2 token string.\n            get_fill_color: Accessor for fill color [r, g, b, a].\n            get_line_color: Accessor for stroke color [r, g, b, a].\n            get_line_width: Accessor for line width.\n            get_elevation: Accessor for 3D extrusion height.\n            filled: Whether to fill cells.\n            stroked: Whether to stroke cells.\n            extruded: Whether to render as 3D.\n            wireframe: Whether to render wireframe.\n            elevation_scale: Elevation multiplier.\n            pickable: Whether layer responds to hover/click.\n            opacity: Layer opacity.\n            **kwargs: Additional S2Layer props.\n        \"\"\"\n        layer_id = name or f\"s2-{len(self._deck_layers)}\"\n        processed_data = self._process_deck_data(data)\n\n        self.call_js_method(\n            \"addS2Layer\",\n            id=layer_id,\n            data=processed_data,\n            getS2Token=get_s2_token,\n            getFillColor=get_fill_color or [51, 136, 255, 128],\n            getLineColor=get_line_color or [0, 0, 0, 255],\n            getLineWidth=get_line_width,\n            getElevation=get_elevation,\n            filled=filled,\n            stroked=stroked,\n            extruded=extruded,\n            wireframe=wireframe,\n            elevationScale=elevation_scale,\n            pickable=pickable,\n            opacity=opacity,\n            **kwargs,\n        )\n\n        self._deck_layers = {\n            **self._deck_layers,\n            layer_id: {\"type\": \"S2Layer\", \"id\": layer_id},\n        }\n\n    def add_quadkey_layer(\n        self,\n        data: Any,\n        name: Optional[str] = None,\n        get_quadkey: Union[str, Callable] = \"quadkey\",\n        get_fill_color: Union[List[int], str, Callable] = None,\n        get_line_color: Union[List[int], str, Callable] = None,\n        get_line_width: Union[float, str, Callable] = 1,\n        get_elevation: Union[float, str, Callable] = 0,\n        filled: bool = True,\n        stroked: bool = True,\n        extruded: bool = False,\n        wireframe: bool = False,\n        elevation_scale: float = 1,\n        pickable: bool = True,\n        opacity: float = 0.8,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a Quadkey layer for Bing Maps tile index visualization.\n\n        Args:\n            data: Array of data objects with quadkey.\n            name: Layer ID.\n            get_quadkey: Accessor for quadkey string.\n            get_fill_color: Accessor for fill color [r, g, b, a].\n            get_line_color: Accessor for stroke color [r, g, b, a].\n            get_line_width: Accessor for line width.\n            get_elevation: Accessor for 3D extrusion height.\n            filled: Whether to fill cells.\n            stroked: Whether to stroke cells.\n            extruded: Whether to render as 3D.\n            wireframe: Whether to render wireframe.\n            elevation_scale: Elevation multiplier.\n            pickable: Whether layer responds to hover/click.\n            opacity: Layer opacity.\n            **kwargs: Additional QuadkeyLayer props.\n        \"\"\"\n        layer_id = name or f\"quadkey-{len(self._deck_layers)}\"\n        processed_data = self._process_deck_data(data)\n\n        self.call_js_method(\n            \"addQuadkeyLayer\",\n            id=layer_id,\n            data=processed_data,\n            getQuadkey=get_quadkey,\n            getFillColor=get_fill_color or [51, 136, 255, 128],\n            getLineColor=get_line_color or [0, 0, 0, 255],\n            getLineWidth=get_line_width,\n            getElevation=get_elevation,\n            filled=filled,\n            stroked=stroked,\n            extruded=extruded,\n            wireframe=wireframe,\n            elevationScale=elevation_scale,\n            pickable=pickable,\n            opacity=opacity,\n            **kwargs,\n        )\n\n        self._deck_layers = {\n            **self._deck_layers,\n            layer_id: {\"type\": \"QuadkeyLayer\", \"id\": layer_id},\n        }\n\n    def add_geohash_layer(\n        self,\n        data: Any,\n        name: Optional[str] = None,\n        get_geohash: Union[str, Callable] = \"geohash\",\n        get_fill_color: Union[List[int], str, Callable] = None,\n        get_line_color: Union[List[int], str, Callable] = None,\n        get_line_width: Union[float, str, Callable] = 1,\n        get_elevation: Union[float, str, Callable] = 0,\n        filled: bool = True,\n        stroked: bool = True,\n        extruded: bool = False,\n        wireframe: bool = False,\n        elevation_scale: float = 1,\n        pickable: bool = True,\n        opacity: float = 0.8,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a Geohash layer for geohash cell visualization.\n\n        Args:\n            data: Array of data objects with geohash.\n            name: Layer ID.\n            get_geohash: Accessor for geohash string.\n            get_fill_color: Accessor for fill color [r, g, b, a].\n            get_line_color: Accessor for stroke color [r, g, b, a].\n            get_line_width: Accessor for line width.\n            get_elevation: Accessor for 3D extrusion height.\n            filled: Whether to fill cells.\n            stroked: Whether to stroke cells.\n            extruded: Whether to render as 3D.\n            wireframe: Whether to render wireframe.\n            elevation_scale: Elevation multiplier.\n            pickable: Whether layer responds to hover/click.\n            opacity: Layer opacity.\n            **kwargs: Additional GeohashLayer props.\n        \"\"\"\n        layer_id = name or f\"geohash-{len(self._deck_layers)}\"\n        processed_data = self._process_deck_data(data)\n\n        self.call_js_method(\n            \"addGeohashLayer\",\n            id=layer_id,\n            data=processed_data,\n            getGeohash=get_geohash,\n            getFillColor=get_fill_color or [51, 136, 255, 128],\n            getLineColor=get_line_color or [0, 0, 0, 255],\n            getLineWidth=get_line_width,\n            getElevation=get_elevation,\n            filled=filled,\n            stroked=stroked,\n            extruded=extruded,\n            wireframe=wireframe,\n            elevationScale=elevation_scale,\n            pickable=pickable,\n            opacity=opacity,\n            **kwargs,\n        )\n\n        self._deck_layers = {\n            **self._deck_layers,\n            layer_id: {\"type\": \"GeohashLayer\", \"id\": layer_id},\n        }\n\n    def add_wms_layer(\n        self,\n        data: str,\n        name: Optional[str] = None,\n        service_type: str = \"wms\",\n        layers: Optional[List[str]] = None,\n        srs: Optional[str] = None,\n        pickable: bool = False,\n        visible: bool = True,\n        opacity: float = 1.0,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a WMS layer for OGC Web Map Service visualization.\n\n        Args:\n            data: WMS base URL.\n            name: Layer ID.\n            service_type: Service type ('wms' or 'template').\n            layers: WMS layer names to request.\n            srs: Spatial reference system (e.g., 'EPSG:4326').\n            pickable: Whether layer responds to hover/click.\n            visible: Whether layer is visible.\n            opacity: Layer opacity (0-1).\n            **kwargs: Additional WMSLayer props.\n        \"\"\"\n        layer_id = name or f\"wms-{len(self._deck_layers)}\"\n\n        self.call_js_method(\n            \"addWMSLayer\",\n            id=layer_id,\n            data=data,\n            serviceType=service_type,\n            layers=layers,\n            srs=srs,\n            pickable=pickable,\n            visible=visible,\n            opacity=opacity,\n            **kwargs,\n        )\n\n        self._deck_layers = {\n            **self._deck_layers,\n            layer_id: {\"type\": \"WMSLayer\", \"id\": layer_id},\n        }\n\n    def add_simple_mesh_layer(\n        self,\n        data: Any,\n        mesh: str,\n        name: Optional[str] = None,\n        texture: Optional[str] = None,\n        get_position: Union[str, Callable] = \"coordinates\",\n        get_color: Union[List[int], str, Callable] = None,\n        get_orientation: Union[str, Callable] = None,\n        get_scale: Union[str, Callable] = None,\n        get_translation: Union[str, Callable] = None,\n        size_scale: float = 1,\n        wireframe: bool = False,\n        pickable: bool = True,\n        opacity: float = 1.0,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a simple mesh layer for 3D mesh visualization.\n\n        Args:\n            data: Array of data objects with position coordinates.\n            mesh: URL to OBJ/glTF mesh file.\n            name: Layer ID.\n            texture: URL to texture image.\n            get_position: Accessor for mesh position [lng, lat, z].\n            get_color: Accessor for mesh color [r, g, b, a].\n            get_orientation: Accessor for mesh orientation [pitch, yaw, roll].\n            get_scale: Accessor for mesh scale [x, y, z].\n            get_translation: Accessor for mesh translation [x, y, z].\n            size_scale: Global size multiplier.\n            wireframe: Whether to render as wireframe.\n            pickable: Whether layer responds to hover/click.\n            opacity: Layer opacity (0-1).\n            **kwargs: Additional SimpleMeshLayer props.\n        \"\"\"\n        layer_id = name or f\"simplemesh-{len(self._deck_layers)}\"\n        processed_data = self._process_deck_data(data)\n\n        layer_kwargs = {\n            \"id\": layer_id,\n            \"data\": processed_data,\n            \"mesh\": mesh,\n            \"getPosition\": get_position,\n            \"getColor\": get_color or [255, 255, 255, 255],\n            \"sizeScale\": size_scale,\n            \"wireframe\": wireframe,\n            \"pickable\": pickable,\n            \"opacity\": opacity,\n        }\n\n        if texture:\n            layer_kwargs[\"texture\"] = texture\n        if get_orientation:\n            layer_kwargs[\"getOrientation\"] = get_orientation\n        if get_scale:\n            layer_kwargs[\"getScale\"] = get_scale\n        if get_translation:\n            layer_kwargs[\"getTranslation\"] = get_translation\n\n        layer_kwargs.update(kwargs)\n        self.call_js_method(\"addSimpleMeshLayer\", **layer_kwargs)\n\n        self._deck_layers = {\n            **self._deck_layers,\n            layer_id: {\"type\": \"SimpleMeshLayer\", \"id\": layer_id},\n        }\n\n    def add_scenegraph_layer(\n        self,\n        data: Any,\n        scenegraph: str,\n        name: Optional[str] = None,\n        get_position: Union[str, Callable] = \"coordinates\",\n        get_color: Union[List[int], str, Callable] = None,\n        get_orientation: Union[str, Callable] = None,\n        get_scale: Union[str, Callable] = None,\n        get_translation: Union[str, Callable] = None,\n        size_scale: float = 1,\n        size_min_pixels: float = 0,\n        size_max_pixels: float = 10000,\n        pickable: bool = True,\n        opacity: float = 1.0,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a scenegraph layer for glTF model visualization.\n\n        Args:\n            data: Array of data objects with position coordinates.\n            scenegraph: URL to glTF/GLB model file.\n            name: Layer ID.\n            get_position: Accessor for model position [lng, lat, z].\n            get_color: Accessor for model tint color [r, g, b, a].\n            get_orientation: Accessor for model orientation [pitch, yaw, roll].\n            get_scale: Accessor for model scale [x, y, z].\n            get_translation: Accessor for model translation [x, y, z].\n            size_scale: Global size multiplier.\n            size_min_pixels: Minimum model size in pixels.\n            size_max_pixels: Maximum model size in pixels.\n            pickable: Whether layer responds to hover/click.\n            opacity: Layer opacity (0-1).\n            **kwargs: Additional ScenegraphLayer props.\n        \"\"\"\n        layer_id = name or f\"scenegraph-{len(self._deck_layers)}\"\n        processed_data = self._process_deck_data(data)\n\n        layer_kwargs = {\n            \"id\": layer_id,\n            \"data\": processed_data,\n            \"scenegraph\": scenegraph,\n            \"getPosition\": get_position,\n            \"getColor\": get_color or [255, 255, 255, 255],\n            \"sizeScale\": size_scale,\n            \"sizeMinPixels\": size_min_pixels,\n            \"sizeMaxPixels\": size_max_pixels,\n            \"pickable\": pickable,\n            \"opacity\": opacity,\n        }\n\n        if get_orientation:\n            layer_kwargs[\"getOrientation\"] = get_orientation\n        if get_scale:\n            layer_kwargs[\"getScale\"] = get_scale\n        if get_translation:\n            layer_kwargs[\"getTranslation\"] = get_translation\n\n        layer_kwargs.update(kwargs)\n        self.call_js_method(\"addScenegraphLayer\", **layer_kwargs)\n\n        self._deck_layers = {\n            **self._deck_layers,\n            layer_id: {\"type\": \"ScenegraphLayer\", \"id\": layer_id},\n        }\n\n    def remove_cog_layer(self, layer_id: str) -&gt; None:\n        \"\"\"Remove a COG layer.\n\n        Args:\n            layer_id: Layer identifier to remove.\n        \"\"\"\n        self.remove_deck_layer(layer_id)\n\n    # -------------------------------------------------------------------------\n    # DeckGL Layer Management\n    # -------------------------------------------------------------------------\n\n    def remove_deck_layer(self, layer_id: str) -&gt; None:\n        \"\"\"Remove a deck.gl layer.\n\n        Args:\n            layer_id: Layer identifier to remove.\n        \"\"\"\n        if layer_id in self._deck_layers:\n            layers = dict(self._deck_layers)\n            del layers[layer_id]\n            self._deck_layers = layers\n        self.call_js_method(\"removeDeckLayer\", layer_id)\n\n    def set_deck_layer_visibility(self, layer_id: str, visible: bool) -&gt; None:\n        \"\"\"Set deck.gl layer visibility.\n\n        Args:\n            layer_id: Layer identifier.\n            visible: Whether layer should be visible.\n        \"\"\"\n        self.call_js_method(\"setDeckLayerVisibility\", layer_id, visible)\n\n    # -------------------------------------------------------------------------\n    # Data Processing Helpers\n    # -------------------------------------------------------------------------\n\n    def _process_deck_data(self, data: Any) -&gt; Any:\n        \"\"\"Process data for deck.gl layers.\n\n        Handles GeoDataFrame, GeoJSON, and list of dicts.\n\n        Args:\n            data: Input data in various formats.\n\n        Returns:\n            Processed data suitable for deck.gl.\n        \"\"\"\n        # Handle GeoDataFrame\n        if hasattr(data, \"__geo_interface__\"):\n            return json.loads(data.to_json())\n\n        # Handle file path\n        if isinstance(data, (str, Path)):\n            path = Path(data)\n            if path.exists() and path.suffix.lower() in [\".geojson\", \".json\"]:\n                with open(path) as f:\n                    return json.load(f)\n            # Could be URL, return as-is\n            return str(data)\n\n        # Handle dict (GeoJSON or config)\n        if isinstance(data, dict):\n            return data\n\n        # Handle list of dicts\n        if isinstance(data, list):\n            return data\n\n        return data\n\n    # -------------------------------------------------------------------------\n    # HTML Export\n    # -------------------------------------------------------------------------\n\n    def _generate_html_template(self) -&gt; str:\n        \"\"\"Generate standalone HTML for the DeckGL map.\"\"\"\n        template_path = Path(__file__).parent / \"templates\" / \"deckgl.html\"\n\n        if template_path.exists():\n            template = template_path.read_text(encoding=\"utf-8\")\n        else:\n            template = self._get_default_template()\n\n        # Serialize state\n        state = {\n            \"center\": self.center,\n            \"zoom\": self.zoom,\n            \"style\": self.style,\n            \"bearing\": self.bearing,\n            \"pitch\": self.pitch,\n            \"width\": self.width,\n            \"height\": self.height,\n            \"layers\": self._layers,\n            \"sources\": self._sources,\n            \"controls\": self._controls,\n            \"deckLayers\": self._deck_layers,\n            \"js_calls\": self._js_calls,\n        }\n\n        template = template.replace(\"{{state}}\", json.dumps(state, indent=2))\n        return template\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.deckgl.DeckGLMap.__init__","title":"<code>__init__(self, center=(0.0, 0.0), zoom=2.0, width='100%', height='600px', style='https://demotiles.maplibre.org/style.json', bearing=0.0, pitch=0.0, max_pitch=85.0, controls=None, **kwargs)</code>  <code>special</code>","text":"<p>Initialize a DeckGL map.</p> <p>Parameters:</p> Name Type Description Default <code>center</code> <code>Tuple[float, float]</code> <p>Map center as (longitude, latitude).</p> <code>(0.0, 0.0)</code> <code>zoom</code> <code>float</code> <p>Initial zoom level.</p> <code>2.0</code> <code>width</code> <code>str</code> <p>Map width as CSS string.</p> <code>'100%'</code> <code>height</code> <code>str</code> <p>Map height as CSS string.</p> <code>'600px'</code> <code>style</code> <code>Union[str, Dict]</code> <p>MapLibre style URL or style object.</p> <code>'https://demotiles.maplibre.org/style.json'</code> <code>bearing</code> <code>float</code> <p>Map bearing in degrees.</p> <code>0.0</code> <code>pitch</code> <code>float</code> <p>Map pitch in degrees.</p> <code>0.0</code> <code>max_pitch</code> <code>float</code> <p>Maximum pitch angle in degrees (default: 85).</p> <code>85.0</code> <code>controls</code> <code>Optional[Dict[str, Any]]</code> <p>Dict of controls to add (e.g., {\"navigation\": True}).</p> <code>None</code> <code>**kwargs</code> <p>Additional widget arguments.</p> <code>{}</code> Source code in <code>anymap_ts/deckgl.py</code> <pre><code>def __init__(\n    self,\n    center: Tuple[float, float] = (0.0, 0.0),\n    zoom: float = 2.0,\n    width: str = \"100%\",\n    height: str = \"600px\",\n    style: Union[str, Dict] = \"https://demotiles.maplibre.org/style.json\",\n    bearing: float = 0.0,\n    pitch: float = 0.0,\n    max_pitch: float = 85.0,\n    controls: Optional[Dict[str, Any]] = None,\n    **kwargs,\n):\n    \"\"\"Initialize a DeckGL map.\n\n    Args:\n        center: Map center as (longitude, latitude).\n        zoom: Initial zoom level.\n        width: Map width as CSS string.\n        height: Map height as CSS string.\n        style: MapLibre style URL or style object.\n        bearing: Map bearing in degrees.\n        pitch: Map pitch in degrees.\n        max_pitch: Maximum pitch angle in degrees (default: 85).\n        controls: Dict of controls to add (e.g., {\"navigation\": True}).\n        **kwargs: Additional widget arguments.\n    \"\"\"\n    super().__init__(\n        center=center,\n        zoom=zoom,\n        width=width,\n        height=height,\n        style=style,\n        bearing=bearing,\n        pitch=pitch,\n        max_pitch=max_pitch,\n        controls=controls,\n        **kwargs,\n    )\n    self._deck_layers = {}\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.deckgl.DeckGLMap.add_arc_layer","title":"<code>add_arc_layer(self, data, name=None, get_source_position='source', get_target_position='target', get_source_color=None, get_target_color=None, get_width=1, pickable=True, opacity=0.8, **kwargs)</code>","text":"<p>Add an arc layer for origin-destination visualization.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>Array of data objects with source/target coordinates.</p> required <code>name</code> <code>Optional[str]</code> <p>Layer ID.</p> <code>None</code> <code>get_source_position</code> <code>Union[str, Callable]</code> <p>Accessor for source position [lng, lat].</p> <code>'source'</code> <code>get_target_position</code> <code>Union[str, Callable]</code> <p>Accessor for target position [lng, lat].</p> <code>'target'</code> <code>get_source_color</code> <code>Union[List[int], str, Callable]</code> <p>Accessor for source color [r, g, b, a].</p> <code>None</code> <code>get_target_color</code> <code>Union[List[int], str, Callable]</code> <p>Accessor for target color [r, g, b, a].</p> <code>None</code> <code>get_width</code> <code>Union[float, str, Callable]</code> <p>Accessor for arc width.</p> <code>1</code> <code>pickable</code> <code>bool</code> <p>Whether layer responds to hover/click.</p> <code>True</code> <code>opacity</code> <code>float</code> <p>Layer opacity.</p> <code>0.8</code> <code>**kwargs</code> <p>Additional layer props.</p> <code>{}</code> Source code in <code>anymap_ts/deckgl.py</code> <pre><code>def add_arc_layer(\n    self,\n    data: Any,\n    name: Optional[str] = None,\n    get_source_position: Union[str, Callable] = \"source\",\n    get_target_position: Union[str, Callable] = \"target\",\n    get_source_color: Union[List[int], str, Callable] = None,\n    get_target_color: Union[List[int], str, Callable] = None,\n    get_width: Union[float, str, Callable] = 1,\n    pickable: bool = True,\n    opacity: float = 0.8,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add an arc layer for origin-destination visualization.\n\n    Args:\n        data: Array of data objects with source/target coordinates.\n        name: Layer ID.\n        get_source_position: Accessor for source position [lng, lat].\n        get_target_position: Accessor for target position [lng, lat].\n        get_source_color: Accessor for source color [r, g, b, a].\n        get_target_color: Accessor for target color [r, g, b, a].\n        get_width: Accessor for arc width.\n        pickable: Whether layer responds to hover/click.\n        opacity: Layer opacity.\n        **kwargs: Additional layer props.\n    \"\"\"\n    layer_id = name or f\"arc-{len(self._deck_layers)}\"\n    processed_data = self._process_deck_data(data)\n\n    self.call_js_method(\n        \"addArcLayer\",\n        id=layer_id,\n        data=processed_data,\n        getSourcePosition=get_source_position,\n        getTargetPosition=get_target_position,\n        getSourceColor=get_source_color or [51, 136, 255, 255],\n        getTargetColor=get_target_color or [255, 136, 51, 255],\n        getWidth=get_width,\n        pickable=pickable,\n        opacity=opacity,\n        **kwargs,\n    )\n\n    self._deck_layers = {\n        **self._deck_layers,\n        layer_id: {\"type\": \"ArcLayer\", \"id\": layer_id},\n    }\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.deckgl.DeckGLMap.add_bitmap_layer","title":"<code>add_bitmap_layer(self, image, bounds, name=None, opacity=1.0, visible=True, pickable=False, desaturate=0, transparent_color=None, tint_color=None, **kwargs)</code>","text":"<p>Add a bitmap layer for raster image overlay.</p> <p>Parameters:</p> Name Type Description Default <code>image</code> <code>str</code> <p>URL or data URI of the image.</p> required <code>bounds</code> <code>List[float]</code> <p>Bounding box [west, south, east, north].</p> required <code>name</code> <code>Optional[str]</code> <p>Layer ID.</p> <code>None</code> <code>opacity</code> <code>float</code> <p>Layer opacity (0-1).</p> <code>1.0</code> <code>visible</code> <code>bool</code> <p>Whether layer is visible.</p> <code>True</code> <code>pickable</code> <code>bool</code> <p>Whether layer responds to hover/click.</p> <code>False</code> <code>desaturate</code> <code>float</code> <p>Desaturation amount (0-1).</p> <code>0</code> <code>transparent_color</code> <code>Optional[List[int]]</code> <p>Color to make transparent [r, g, b, a].</p> <code>None</code> <code>tint_color</code> <code>Optional[List[int]]</code> <p>Color to tint the image [r, g, b].</p> <code>None</code> <code>**kwargs</code> <p>Additional BitmapLayer props.</p> <code>{}</code> Source code in <code>anymap_ts/deckgl.py</code> <pre><code>def add_bitmap_layer(\n    self,\n    image: str,\n    bounds: List[float],\n    name: Optional[str] = None,\n    opacity: float = 1.0,\n    visible: bool = True,\n    pickable: bool = False,\n    desaturate: float = 0,\n    transparent_color: Optional[List[int]] = None,\n    tint_color: Optional[List[int]] = None,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a bitmap layer for raster image overlay.\n\n    Args:\n        image: URL or data URI of the image.\n        bounds: Bounding box [west, south, east, north].\n        name: Layer ID.\n        opacity: Layer opacity (0-1).\n        visible: Whether layer is visible.\n        pickable: Whether layer responds to hover/click.\n        desaturate: Desaturation amount (0-1).\n        transparent_color: Color to make transparent [r, g, b, a].\n        tint_color: Color to tint the image [r, g, b].\n        **kwargs: Additional BitmapLayer props.\n    \"\"\"\n    layer_id = name or f\"bitmap-{len(self._deck_layers)}\"\n\n    self.call_js_method(\n        \"addBitmapLayer\",\n        id=layer_id,\n        image=image,\n        bounds=bounds,\n        opacity=opacity,\n        visible=visible,\n        pickable=pickable,\n        desaturate=desaturate,\n        transparentColor=transparent_color or [0, 0, 0, 0],\n        tintColor=tint_color or [255, 255, 255],\n        **kwargs,\n    )\n\n    self._deck_layers = {\n        **self._deck_layers,\n        layer_id: {\"type\": \"BitmapLayer\", \"id\": layer_id},\n    }\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.deckgl.DeckGLMap.add_cog_layer","title":"<code>add_cog_layer(self, url, name=None, opacity=1.0, visible=True, debug=False, debug_opacity=0.25, max_error=0.125, fit_bounds=True, before_id=None, **kwargs)</code>","text":"<p>Add a Cloud Optimized GeoTIFF (COG) layer using @developmentseed/deck.gl-geotiff.</p> <p>This method renders COG files directly in the browser using GPU-accelerated deck.gl rendering with automatic reprojection support.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>URL to the Cloud Optimized GeoTIFF file.</p> required <code>name</code> <code>Optional[str]</code> <p>Layer ID. If None, auto-generated.</p> <code>None</code> <code>opacity</code> <code>float</code> <p>Layer opacity (0-1).</p> <code>1.0</code> <code>visible</code> <code>bool</code> <p>Whether layer is visible.</p> <code>True</code> <code>debug</code> <code>bool</code> <p>Show reprojection mesh for debugging.</p> <code>False</code> <code>debug_opacity</code> <code>float</code> <p>Opacity of debug mesh (0-1).</p> <code>0.25</code> <code>max_error</code> <code>float</code> <p>Maximum reprojection error in pixels. Lower values create denser mesh for better accuracy.</p> <code>0.125</code> <code>fit_bounds</code> <code>bool</code> <p>Whether to fit map to COG bounds after loading.</p> <code>True</code> <code>before_id</code> <code>Optional[str]</code> <p>ID of layer to insert before.</p> <code>None</code> <code>**kwargs</code> <p>Additional COGLayer props.</p> <code>{}</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; m = DeckGLMap()\n&gt;&gt;&gt; m.add_cog_layer(\n...     \"https://example.com/landcover.tif\",\n...     name=\"landcover\",\n...     opacity=0.8\n... )\n</code></pre> Source code in <code>anymap_ts/deckgl.py</code> <pre><code>def add_cog_layer(\n    self,\n    url: str,\n    name: Optional[str] = None,\n    opacity: float = 1.0,\n    visible: bool = True,\n    debug: bool = False,\n    debug_opacity: float = 0.25,\n    max_error: float = 0.125,\n    fit_bounds: bool = True,\n    before_id: Optional[str] = None,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a Cloud Optimized GeoTIFF (COG) layer using @developmentseed/deck.gl-geotiff.\n\n    This method renders COG files directly in the browser using GPU-accelerated\n    deck.gl rendering with automatic reprojection support.\n\n    Args:\n        url: URL to the Cloud Optimized GeoTIFF file.\n        name: Layer ID. If None, auto-generated.\n        opacity: Layer opacity (0-1).\n        visible: Whether layer is visible.\n        debug: Show reprojection mesh for debugging.\n        debug_opacity: Opacity of debug mesh (0-1).\n        max_error: Maximum reprojection error in pixels. Lower values\n            create denser mesh for better accuracy.\n        fit_bounds: Whether to fit map to COG bounds after loading.\n        before_id: ID of layer to insert before.\n        **kwargs: Additional COGLayer props.\n\n    Example:\n        &gt;&gt;&gt; m = DeckGLMap()\n        &gt;&gt;&gt; m.add_cog_layer(\n        ...     \"https://example.com/landcover.tif\",\n        ...     name=\"landcover\",\n        ...     opacity=0.8\n        ... )\n    \"\"\"\n    # Use a monotonically increasing counter to avoid ID collisions when layers are removed.\n    counter = getattr(self, \"_cog_layer_counter\", 0)\n    layer_id = name or f\"cog-{counter}\"\n    self._cog_layer_counter = counter + 1\n\n    self.call_js_method(\n        \"addCOGLayer\",\n        id=layer_id,\n        geotiff=url,\n        opacity=opacity,\n        visible=visible,\n        debug=debug,\n        debugOpacity=debug_opacity,\n        maxError=max_error,\n        fitBounds=fit_bounds,\n        beforeId=before_id,\n        **kwargs,\n    )\n\n    self._deck_layers = {\n        **self._deck_layers,\n        layer_id: {\"type\": \"COGLayer\", \"id\": layer_id, \"url\": url},\n    }\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.deckgl.DeckGLMap.add_column_layer","title":"<code>add_column_layer(self, data, name=None, get_position='coordinates', get_fill_color=None, get_line_color=None, get_elevation=1000, radius=1000, disk_resolution=20, elevation_scale=1, coverage=1, extruded=True, filled=True, stroked=False, wireframe=False, pickable=True, opacity=0.8, **kwargs)</code>","text":"<p>Add a column layer for 3D column/bar visualization.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>Array of data objects with position coordinates.</p> required <code>name</code> <code>Optional[str]</code> <p>Layer ID.</p> <code>None</code> <code>get_position</code> <code>Union[str, Callable]</code> <p>Accessor for column position [lng, lat].</p> <code>'coordinates'</code> <code>get_fill_color</code> <code>Union[List[int], str, Callable]</code> <p>Accessor for fill color [r, g, b, a].</p> <code>None</code> <code>get_line_color</code> <code>Union[List[int], str, Callable]</code> <p>Accessor for stroke color [r, g, b, a].</p> <code>None</code> <code>get_elevation</code> <code>Union[float, str, Callable]</code> <p>Accessor for column height.</p> <code>1000</code> <code>radius</code> <code>float</code> <p>Column radius in meters.</p> <code>1000</code> <code>disk_resolution</code> <code>int</code> <p>Number of sides for column polygon.</p> <code>20</code> <code>elevation_scale</code> <code>float</code> <p>Elevation multiplier.</p> <code>1</code> <code>coverage</code> <code>float</code> <p>Column coverage (0-1).</p> <code>1</code> <code>extruded</code> <code>bool</code> <p>Whether to extrude columns.</p> <code>True</code> <code>filled</code> <code>bool</code> <p>Whether to fill columns.</p> <code>True</code> <code>stroked</code> <code>bool</code> <p>Whether to stroke columns.</p> <code>False</code> <code>wireframe</code> <code>bool</code> <p>Whether to render as wireframe.</p> <code>False</code> <code>pickable</code> <code>bool</code> <p>Whether layer responds to hover/click.</p> <code>True</code> <code>opacity</code> <code>float</code> <p>Layer opacity.</p> <code>0.8</code> <code>**kwargs</code> <p>Additional ColumnLayer props.</p> <code>{}</code> Source code in <code>anymap_ts/deckgl.py</code> <pre><code>def add_column_layer(\n    self,\n    data: Any,\n    name: Optional[str] = None,\n    get_position: Union[str, Callable] = \"coordinates\",\n    get_fill_color: Union[List[int], str, Callable] = None,\n    get_line_color: Union[List[int], str, Callable] = None,\n    get_elevation: Union[float, str, Callable] = 1000,\n    radius: float = 1000,\n    disk_resolution: int = 20,\n    elevation_scale: float = 1,\n    coverage: float = 1,\n    extruded: bool = True,\n    filled: bool = True,\n    stroked: bool = False,\n    wireframe: bool = False,\n    pickable: bool = True,\n    opacity: float = 0.8,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a column layer for 3D column/bar visualization.\n\n    Args:\n        data: Array of data objects with position coordinates.\n        name: Layer ID.\n        get_position: Accessor for column position [lng, lat].\n        get_fill_color: Accessor for fill color [r, g, b, a].\n        get_line_color: Accessor for stroke color [r, g, b, a].\n        get_elevation: Accessor for column height.\n        radius: Column radius in meters.\n        disk_resolution: Number of sides for column polygon.\n        elevation_scale: Elevation multiplier.\n        coverage: Column coverage (0-1).\n        extruded: Whether to extrude columns.\n        filled: Whether to fill columns.\n        stroked: Whether to stroke columns.\n        wireframe: Whether to render as wireframe.\n        pickable: Whether layer responds to hover/click.\n        opacity: Layer opacity.\n        **kwargs: Additional ColumnLayer props.\n    \"\"\"\n    layer_id = name or f\"column-{len(self._deck_layers)}\"\n    processed_data = self._process_deck_data(data)\n\n    self.call_js_method(\n        \"addColumnLayer\",\n        id=layer_id,\n        data=processed_data,\n        getPosition=get_position,\n        getFillColor=get_fill_color or [255, 140, 0, 200],\n        getLineColor=get_line_color or [0, 0, 0, 255],\n        getElevation=get_elevation,\n        radius=radius,\n        diskResolution=disk_resolution,\n        elevationScale=elevation_scale,\n        coverage=coverage,\n        extruded=extruded,\n        filled=filled,\n        stroked=stroked,\n        wireframe=wireframe,\n        pickable=pickable,\n        opacity=opacity,\n        **kwargs,\n    )\n\n    self._deck_layers = {\n        **self._deck_layers,\n        layer_id: {\"type\": \"ColumnLayer\", \"id\": layer_id},\n    }\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.deckgl.DeckGLMap.add_contour_layer","title":"<code>add_contour_layer(self, data, name=None, get_position='coordinates', get_weight=1, cell_size=200, contours=None, pickable=True, opacity=1, **kwargs)</code>","text":"<p>Add a contour layer for isoline visualization.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>Array of data objects with position coordinates.</p> required <code>name</code> <code>Optional[str]</code> <p>Layer ID.</p> <code>None</code> <code>get_position</code> <code>Union[str, Callable]</code> <p>Accessor for point position [lng, lat].</p> <code>'coordinates'</code> <code>get_weight</code> <code>Union[float, str, Callable]</code> <p>Accessor for point weight.</p> <code>1</code> <code>cell_size</code> <code>float</code> <p>Grid cell size for aggregation.</p> <code>200</code> <code>contours</code> <code>Optional[List[Dict]]</code> <p>Contour definitions [{threshold, color, strokeWidth}, ...].</p> <code>None</code> <code>pickable</code> <code>bool</code> <p>Whether layer responds to hover/click.</p> <code>True</code> <code>opacity</code> <code>float</code> <p>Layer opacity.</p> <code>1</code> <code>**kwargs</code> <p>Additional layer props.</p> <code>{}</code> Source code in <code>anymap_ts/deckgl.py</code> <pre><code>def add_contour_layer(\n    self,\n    data: Any,\n    name: Optional[str] = None,\n    get_position: Union[str, Callable] = \"coordinates\",\n    get_weight: Union[float, str, Callable] = 1,\n    cell_size: float = 200,\n    contours: Optional[List[Dict]] = None,\n    pickable: bool = True,\n    opacity: float = 1,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a contour layer for isoline visualization.\n\n    Args:\n        data: Array of data objects with position coordinates.\n        name: Layer ID.\n        get_position: Accessor for point position [lng, lat].\n        get_weight: Accessor for point weight.\n        cell_size: Grid cell size for aggregation.\n        contours: Contour definitions [{threshold, color, strokeWidth}, ...].\n        pickable: Whether layer responds to hover/click.\n        opacity: Layer opacity.\n        **kwargs: Additional layer props.\n    \"\"\"\n    layer_id = name or f\"contour-{len(self._deck_layers)}\"\n    processed_data = self._process_deck_data(data)\n\n    default_contours = [\n        {\"threshold\": 1, \"color\": [255, 255, 255], \"strokeWidth\": 1},\n        {\"threshold\": 5, \"color\": [51, 136, 255], \"strokeWidth\": 2},\n        {\"threshold\": 10, \"color\": [0, 0, 255], \"strokeWidth\": 3},\n    ]\n\n    self.call_js_method(\n        \"addContourLayer\",\n        id=layer_id,\n        data=processed_data,\n        getPosition=get_position,\n        getWeight=get_weight,\n        cellSize=cell_size,\n        contours=contours or default_contours,\n        pickable=pickable,\n        opacity=opacity,\n        **kwargs,\n    )\n\n    self._deck_layers = {\n        **self._deck_layers,\n        layer_id: {\"type\": \"ContourLayer\", \"id\": layer_id},\n    }\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.deckgl.DeckGLMap.add_deckgl_layer","title":"<code>add_deckgl_layer(self, layer_type, data, name=None, **kwargs)</code>","text":"<p>Add a generic deck.gl layer to the map.</p> <p>This method provides a flexible way to add any supported deck.gl layer type using a single interface. For commonly used layers, prefer the specific methods (e.g., add_scatterplot_layer) for better IDE support.</p> <p>Parameters:</p> Name Type Description Default <code>layer_type</code> <code>str</code> <p>The deck.gl layer type. Supported types include: 'ScatterplotLayer', 'ArcLayer', 'PathLayer', 'PolygonLayer', 'HexagonLayer', 'HeatmapLayer', 'GridLayer', 'IconLayer', 'TextLayer', 'GeoJsonLayer', 'ContourLayer', 'ScreenGridLayer', 'PointCloudLayer', 'TripsLayer', 'LineLayer'.</p> required <code>data</code> <code>Any</code> <p>Array of data objects or GeoJSON.</p> required <code>name</code> <code>Optional[str]</code> <p>Layer ID. If None, auto-generated from layer_type.</p> <code>None</code> <code>**kwargs</code> <p>Layer-specific properties passed directly to deck.gl. Common properties include: - opacity: Layer opacity (0-1) - pickable: Whether layer responds to hover/click - getPosition: Accessor for position coordinates - getColor/getFillColor/getLineColor: Color accessors</p> <code>{}</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; m = DeckGLMap()\n&gt;&gt;&gt; # Add a TripsLayer with animation\n&gt;&gt;&gt; m.add_deckgl_layer(\n...     'TripsLayer',\n...     data=trips_data,\n...     getPath='waypoints',\n...     getTimestamps='timestamps',\n...     getColor=[253, 128, 93],\n...     trailLength=180,\n... )\n&gt;&gt;&gt; # Add a LineLayer\n&gt;&gt;&gt; m.add_deckgl_layer(\n...     'LineLayer',\n...     data=lines_data,\n...     getSourcePosition='source',\n...     getTargetPosition='target',\n...     getColor=[0, 128, 255],\n... )\n</code></pre> Source code in <code>anymap_ts/deckgl.py</code> <pre><code>def add_deckgl_layer(\n    self,\n    layer_type: str,\n    data: Any,\n    name: Optional[str] = None,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a generic deck.gl layer to the map.\n\n    This method provides a flexible way to add any supported deck.gl layer\n    type using a single interface. For commonly used layers, prefer the\n    specific methods (e.g., add_scatterplot_layer) for better IDE support.\n\n    Args:\n        layer_type: The deck.gl layer type. Supported types include:\n            'ScatterplotLayer', 'ArcLayer', 'PathLayer', 'PolygonLayer',\n            'HexagonLayer', 'HeatmapLayer', 'GridLayer', 'IconLayer',\n            'TextLayer', 'GeoJsonLayer', 'ContourLayer', 'ScreenGridLayer',\n            'PointCloudLayer', 'TripsLayer', 'LineLayer'.\n        data: Array of data objects or GeoJSON.\n        name: Layer ID. If None, auto-generated from layer_type.\n        **kwargs: Layer-specific properties passed directly to deck.gl.\n            Common properties include:\n            - opacity: Layer opacity (0-1)\n            - pickable: Whether layer responds to hover/click\n            - getPosition: Accessor for position coordinates\n            - getColor/getFillColor/getLineColor: Color accessors\n\n    Example:\n        &gt;&gt;&gt; m = DeckGLMap()\n        &gt;&gt;&gt; # Add a TripsLayer with animation\n        &gt;&gt;&gt; m.add_deckgl_layer(\n        ...     'TripsLayer',\n        ...     data=trips_data,\n        ...     getPath='waypoints',\n        ...     getTimestamps='timestamps',\n        ...     getColor=[253, 128, 93],\n        ...     trailLength=180,\n        ... )\n        &gt;&gt;&gt; # Add a LineLayer\n        &gt;&gt;&gt; m.add_deckgl_layer(\n        ...     'LineLayer',\n        ...     data=lines_data,\n        ...     getSourcePosition='source',\n        ...     getTargetPosition='target',\n        ...     getColor=[0, 128, 255],\n        ... )\n    \"\"\"\n    # Normalize layer type and create prefix\n    layer_type_clean = layer_type.replace(\"Layer\", \"\")\n    prefix = layer_type_clean.lower()\n    layer_id = name or f\"{prefix}-{len(self._deck_layers)}\"\n    processed_data = self._process_deck_data(data)\n\n    self.call_js_method(\n        \"addDeckGLLayer\",\n        layerType=layer_type,\n        id=layer_id,\n        data=processed_data,\n        **kwargs,\n    )\n\n    self._deck_layers = {\n        **self._deck_layers,\n        layer_id: {\"type\": layer_type, \"id\": layer_id},\n    }\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.deckgl.DeckGLMap.add_geohash_layer","title":"<code>add_geohash_layer(self, data, name=None, get_geohash='geohash', get_fill_color=None, get_line_color=None, get_line_width=1, get_elevation=0, filled=True, stroked=True, extruded=False, wireframe=False, elevation_scale=1, pickable=True, opacity=0.8, **kwargs)</code>","text":"<p>Add a Geohash layer for geohash cell visualization.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>Array of data objects with geohash.</p> required <code>name</code> <code>Optional[str]</code> <p>Layer ID.</p> <code>None</code> <code>get_geohash</code> <code>Union[str, Callable]</code> <p>Accessor for geohash string.</p> <code>'geohash'</code> <code>get_fill_color</code> <code>Union[List[int], str, Callable]</code> <p>Accessor for fill color [r, g, b, a].</p> <code>None</code> <code>get_line_color</code> <code>Union[List[int], str, Callable]</code> <p>Accessor for stroke color [r, g, b, a].</p> <code>None</code> <code>get_line_width</code> <code>Union[float, str, Callable]</code> <p>Accessor for line width.</p> <code>1</code> <code>get_elevation</code> <code>Union[float, str, Callable]</code> <p>Accessor for 3D extrusion height.</p> <code>0</code> <code>filled</code> <code>bool</code> <p>Whether to fill cells.</p> <code>True</code> <code>stroked</code> <code>bool</code> <p>Whether to stroke cells.</p> <code>True</code> <code>extruded</code> <code>bool</code> <p>Whether to render as 3D.</p> <code>False</code> <code>wireframe</code> <code>bool</code> <p>Whether to render wireframe.</p> <code>False</code> <code>elevation_scale</code> <code>float</code> <p>Elevation multiplier.</p> <code>1</code> <code>pickable</code> <code>bool</code> <p>Whether layer responds to hover/click.</p> <code>True</code> <code>opacity</code> <code>float</code> <p>Layer opacity.</p> <code>0.8</code> <code>**kwargs</code> <p>Additional GeohashLayer props.</p> <code>{}</code> Source code in <code>anymap_ts/deckgl.py</code> <pre><code>def add_geohash_layer(\n    self,\n    data: Any,\n    name: Optional[str] = None,\n    get_geohash: Union[str, Callable] = \"geohash\",\n    get_fill_color: Union[List[int], str, Callable] = None,\n    get_line_color: Union[List[int], str, Callable] = None,\n    get_line_width: Union[float, str, Callable] = 1,\n    get_elevation: Union[float, str, Callable] = 0,\n    filled: bool = True,\n    stroked: bool = True,\n    extruded: bool = False,\n    wireframe: bool = False,\n    elevation_scale: float = 1,\n    pickable: bool = True,\n    opacity: float = 0.8,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a Geohash layer for geohash cell visualization.\n\n    Args:\n        data: Array of data objects with geohash.\n        name: Layer ID.\n        get_geohash: Accessor for geohash string.\n        get_fill_color: Accessor for fill color [r, g, b, a].\n        get_line_color: Accessor for stroke color [r, g, b, a].\n        get_line_width: Accessor for line width.\n        get_elevation: Accessor for 3D extrusion height.\n        filled: Whether to fill cells.\n        stroked: Whether to stroke cells.\n        extruded: Whether to render as 3D.\n        wireframe: Whether to render wireframe.\n        elevation_scale: Elevation multiplier.\n        pickable: Whether layer responds to hover/click.\n        opacity: Layer opacity.\n        **kwargs: Additional GeohashLayer props.\n    \"\"\"\n    layer_id = name or f\"geohash-{len(self._deck_layers)}\"\n    processed_data = self._process_deck_data(data)\n\n    self.call_js_method(\n        \"addGeohashLayer\",\n        id=layer_id,\n        data=processed_data,\n        getGeohash=get_geohash,\n        getFillColor=get_fill_color or [51, 136, 255, 128],\n        getLineColor=get_line_color or [0, 0, 0, 255],\n        getLineWidth=get_line_width,\n        getElevation=get_elevation,\n        filled=filled,\n        stroked=stroked,\n        extruded=extruded,\n        wireframe=wireframe,\n        elevationScale=elevation_scale,\n        pickable=pickable,\n        opacity=opacity,\n        **kwargs,\n    )\n\n    self._deck_layers = {\n        **self._deck_layers,\n        layer_id: {\"type\": \"GeohashLayer\", \"id\": layer_id},\n    }\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.deckgl.DeckGLMap.add_geojson_layer","title":"<code>add_geojson_layer(self, data, name=None, get_fill_color=None, get_line_color=None, get_line_width=1, get_point_radius=5, get_elevation=0, extruded=False, wireframe=False, filled=True, stroked=True, line_width_min_pixels=1, point_radius_min_pixels=2, pickable=True, opacity=0.8, **kwargs)</code>","text":"<p>Add a GeoJSON layer for rendering GeoJSON features.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>GeoJSON object or URL.</p> required <code>name</code> <code>Optional[str]</code> <p>Layer ID.</p> <code>None</code> <code>get_fill_color</code> <code>Union[List[int], str, Callable]</code> <p>Accessor for fill color [r, g, b, a].</p> <code>None</code> <code>get_line_color</code> <code>Union[List[int], str, Callable]</code> <p>Accessor for stroke color [r, g, b, a].</p> <code>None</code> <code>get_line_width</code> <code>Union[float, str, Callable]</code> <p>Accessor for stroke width.</p> <code>1</code> <code>get_point_radius</code> <code>Union[float, str, Callable]</code> <p>Accessor for point radius.</p> <code>5</code> <code>get_elevation</code> <code>Union[float, str, Callable]</code> <p>Accessor for 3D extrusion height.</p> <code>0</code> <code>extruded</code> <code>bool</code> <p>Whether to render as 3D features.</p> <code>False</code> <code>wireframe</code> <code>bool</code> <p>Whether to render wireframe (extruded only).</p> <code>False</code> <code>filled</code> <code>bool</code> <p>Whether to fill features.</p> <code>True</code> <code>stroked</code> <code>bool</code> <p>Whether to draw stroke.</p> <code>True</code> <code>line_width_min_pixels</code> <code>float</code> <p>Minimum stroke width.</p> <code>1</code> <code>point_radius_min_pixels</code> <code>float</code> <p>Minimum point radius.</p> <code>2</code> <code>pickable</code> <code>bool</code> <p>Whether layer responds to hover/click.</p> <code>True</code> <code>opacity</code> <code>float</code> <p>Layer opacity.</p> <code>0.8</code> <code>**kwargs</code> <p>Additional layer props.</p> <code>{}</code> Source code in <code>anymap_ts/deckgl.py</code> <pre><code>def add_geojson_layer(\n    self,\n    data: Any,\n    name: Optional[str] = None,\n    get_fill_color: Union[List[int], str, Callable] = None,\n    get_line_color: Union[List[int], str, Callable] = None,\n    get_line_width: Union[float, str, Callable] = 1,\n    get_point_radius: Union[float, str, Callable] = 5,\n    get_elevation: Union[float, str, Callable] = 0,\n    extruded: bool = False,\n    wireframe: bool = False,\n    filled: bool = True,\n    stroked: bool = True,\n    line_width_min_pixels: float = 1,\n    point_radius_min_pixels: float = 2,\n    pickable: bool = True,\n    opacity: float = 0.8,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a GeoJSON layer for rendering GeoJSON features.\n\n    Args:\n        data: GeoJSON object or URL.\n        name: Layer ID.\n        get_fill_color: Accessor for fill color [r, g, b, a].\n        get_line_color: Accessor for stroke color [r, g, b, a].\n        get_line_width: Accessor for stroke width.\n        get_point_radius: Accessor for point radius.\n        get_elevation: Accessor for 3D extrusion height.\n        extruded: Whether to render as 3D features.\n        wireframe: Whether to render wireframe (extruded only).\n        filled: Whether to fill features.\n        stroked: Whether to draw stroke.\n        line_width_min_pixels: Minimum stroke width.\n        point_radius_min_pixels: Minimum point radius.\n        pickable: Whether layer responds to hover/click.\n        opacity: Layer opacity.\n        **kwargs: Additional layer props.\n    \"\"\"\n    layer_id = name or f\"geojson-{len(self._deck_layers)}\"\n    processed_data = self._process_deck_data(data)\n\n    self.call_js_method(\n        \"addGeoJsonLayer\",\n        id=layer_id,\n        data=processed_data,\n        getFillColor=get_fill_color or [51, 136, 255, 128],\n        getLineColor=get_line_color or [0, 0, 0, 255],\n        getLineWidth=get_line_width,\n        getPointRadius=get_point_radius,\n        getElevation=get_elevation,\n        extruded=extruded,\n        wireframe=wireframe,\n        filled=filled,\n        stroked=stroked,\n        lineWidthMinPixels=line_width_min_pixels,\n        pointRadiusMinPixels=point_radius_min_pixels,\n        pickable=pickable,\n        opacity=opacity,\n        **kwargs,\n    )\n\n    self._deck_layers = {\n        **self._deck_layers,\n        layer_id: {\"type\": \"GeoJsonLayer\", \"id\": layer_id},\n    }\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.deckgl.DeckGLMap.add_great_circle_layer","title":"<code>add_great_circle_layer(self, data, name=None, get_source_position='source', get_target_position='target', get_source_color=None, get_target_color=None, get_width=1, width_min_pixels=1, width_max_pixels=100, pickable=True, opacity=0.8, **kwargs)</code>","text":"<p>Add a great circle layer for geodesic arc visualization.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>Array of data objects with source/target coordinates.</p> required <code>name</code> <code>Optional[str]</code> <p>Layer ID.</p> <code>None</code> <code>get_source_position</code> <code>Union[str, Callable]</code> <p>Accessor for source position [lng, lat].</p> <code>'source'</code> <code>get_target_position</code> <code>Union[str, Callable]</code> <p>Accessor for target position [lng, lat].</p> <code>'target'</code> <code>get_source_color</code> <code>Union[List[int], str, Callable]</code> <p>Accessor for source color [r, g, b, a].</p> <code>None</code> <code>get_target_color</code> <code>Union[List[int], str, Callable]</code> <p>Accessor for target color [r, g, b, a].</p> <code>None</code> <code>get_width</code> <code>Union[float, str, Callable]</code> <p>Accessor for line width.</p> <code>1</code> <code>width_min_pixels</code> <code>float</code> <p>Minimum line width in pixels.</p> <code>1</code> <code>width_max_pixels</code> <code>float</code> <p>Maximum line width in pixels.</p> <code>100</code> <code>pickable</code> <code>bool</code> <p>Whether layer responds to hover/click.</p> <code>True</code> <code>opacity</code> <code>float</code> <p>Layer opacity.</p> <code>0.8</code> <code>**kwargs</code> <p>Additional GreatCircleLayer props.</p> <code>{}</code> Source code in <code>anymap_ts/deckgl.py</code> <pre><code>def add_great_circle_layer(\n    self,\n    data: Any,\n    name: Optional[str] = None,\n    get_source_position: Union[str, Callable] = \"source\",\n    get_target_position: Union[str, Callable] = \"target\",\n    get_source_color: Union[List[int], str, Callable] = None,\n    get_target_color: Union[List[int], str, Callable] = None,\n    get_width: Union[float, str, Callable] = 1,\n    width_min_pixels: float = 1,\n    width_max_pixels: float = 100,\n    pickable: bool = True,\n    opacity: float = 0.8,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a great circle layer for geodesic arc visualization.\n\n    Args:\n        data: Array of data objects with source/target coordinates.\n        name: Layer ID.\n        get_source_position: Accessor for source position [lng, lat].\n        get_target_position: Accessor for target position [lng, lat].\n        get_source_color: Accessor for source color [r, g, b, a].\n        get_target_color: Accessor for target color [r, g, b, a].\n        get_width: Accessor for line width.\n        width_min_pixels: Minimum line width in pixels.\n        width_max_pixels: Maximum line width in pixels.\n        pickable: Whether layer responds to hover/click.\n        opacity: Layer opacity.\n        **kwargs: Additional GreatCircleLayer props.\n    \"\"\"\n    layer_id = name or f\"greatcircle-{len(self._deck_layers)}\"\n    processed_data = self._process_deck_data(data)\n\n    self.call_js_method(\n        \"addGreatCircleLayer\",\n        id=layer_id,\n        data=processed_data,\n        getSourcePosition=get_source_position,\n        getTargetPosition=get_target_position,\n        getSourceColor=get_source_color or [51, 136, 255, 255],\n        getTargetColor=get_target_color or [255, 136, 51, 255],\n        getWidth=get_width,\n        widthMinPixels=width_min_pixels,\n        widthMaxPixels=width_max_pixels,\n        pickable=pickable,\n        opacity=opacity,\n        **kwargs,\n    )\n\n    self._deck_layers = {\n        **self._deck_layers,\n        layer_id: {\"type\": \"GreatCircleLayer\", \"id\": layer_id},\n    }\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.deckgl.DeckGLMap.add_grid_cell_layer","title":"<code>add_grid_cell_layer(self, data, name=None, get_position='coordinates', get_color=None, get_elevation=1000, cell_size=200, coverage=1, elevation_scale=1, extruded=True, pickable=True, opacity=0.8, **kwargs)</code>","text":"<p>Add a grid cell layer for pre-aggregated grid visualization.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>Array of data objects with position coordinates.</p> required <code>name</code> <code>Optional[str]</code> <p>Layer ID.</p> <code>None</code> <code>get_position</code> <code>Union[str, Callable]</code> <p>Accessor for cell position [lng, lat].</p> <code>'coordinates'</code> <code>get_color</code> <code>Union[List[int], str, Callable]</code> <p>Accessor for cell color [r, g, b, a].</p> <code>None</code> <code>get_elevation</code> <code>Union[float, str, Callable]</code> <p>Accessor for cell height.</p> <code>1000</code> <code>cell_size</code> <code>float</code> <p>Cell size in meters.</p> <code>200</code> <code>coverage</code> <code>float</code> <p>Cell coverage (0-1).</p> <code>1</code> <code>elevation_scale</code> <code>float</code> <p>Elevation multiplier.</p> <code>1</code> <code>extruded</code> <code>bool</code> <p>Whether to extrude cells.</p> <code>True</code> <code>pickable</code> <code>bool</code> <p>Whether layer responds to hover/click.</p> <code>True</code> <code>opacity</code> <code>float</code> <p>Layer opacity.</p> <code>0.8</code> <code>**kwargs</code> <p>Additional GridCellLayer props.</p> <code>{}</code> Source code in <code>anymap_ts/deckgl.py</code> <pre><code>def add_grid_cell_layer(\n    self,\n    data: Any,\n    name: Optional[str] = None,\n    get_position: Union[str, Callable] = \"coordinates\",\n    get_color: Union[List[int], str, Callable] = None,\n    get_elevation: Union[float, str, Callable] = 1000,\n    cell_size: float = 200,\n    coverage: float = 1,\n    elevation_scale: float = 1,\n    extruded: bool = True,\n    pickable: bool = True,\n    opacity: float = 0.8,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a grid cell layer for pre-aggregated grid visualization.\n\n    Args:\n        data: Array of data objects with position coordinates.\n        name: Layer ID.\n        get_position: Accessor for cell position [lng, lat].\n        get_color: Accessor for cell color [r, g, b, a].\n        get_elevation: Accessor for cell height.\n        cell_size: Cell size in meters.\n        coverage: Cell coverage (0-1).\n        elevation_scale: Elevation multiplier.\n        extruded: Whether to extrude cells.\n        pickable: Whether layer responds to hover/click.\n        opacity: Layer opacity.\n        **kwargs: Additional GridCellLayer props.\n    \"\"\"\n    layer_id = name or f\"gridcell-{len(self._deck_layers)}\"\n    processed_data = self._process_deck_data(data)\n\n    self.call_js_method(\n        \"addGridCellLayer\",\n        id=layer_id,\n        data=processed_data,\n        getPosition=get_position,\n        getColor=get_color or [255, 140, 0, 200],\n        getElevation=get_elevation,\n        cellSize=cell_size,\n        coverage=coverage,\n        elevationScale=elevation_scale,\n        extruded=extruded,\n        pickable=pickable,\n        opacity=opacity,\n        **kwargs,\n    )\n\n    self._deck_layers = {\n        **self._deck_layers,\n        layer_id: {\"type\": \"GridCellLayer\", \"id\": layer_id},\n    }\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.deckgl.DeckGLMap.add_grid_layer","title":"<code>add_grid_layer(self, data, name=None, get_position='coordinates', cell_size=200, elevation_scale=4, extruded=True, color_range=None, pickable=True, opacity=0.8, **kwargs)</code>","text":"<p>Add a grid layer for square grid aggregation visualization.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>Array of data objects with position coordinates.</p> required <code>name</code> <code>Optional[str]</code> <p>Layer ID.</p> <code>None</code> <code>get_position</code> <code>Union[str, Callable]</code> <p>Accessor for point position [lng, lat].</p> <code>'coordinates'</code> <code>cell_size</code> <code>float</code> <p>Grid cell size in meters.</p> <code>200</code> <code>elevation_scale</code> <code>float</code> <p>Elevation multiplier for 3D.</p> <code>4</code> <code>extruded</code> <code>bool</code> <p>Whether to render as 3D cells.</p> <code>True</code> <code>color_range</code> <code>Optional[List[List[int]]]</code> <p>Color gradient [[r, g, b], ...].</p> <code>None</code> <code>pickable</code> <code>bool</code> <p>Whether layer responds to hover/click.</p> <code>True</code> <code>opacity</code> <code>float</code> <p>Layer opacity.</p> <code>0.8</code> <code>**kwargs</code> <p>Additional layer props.</p> <code>{}</code> Source code in <code>anymap_ts/deckgl.py</code> <pre><code>def add_grid_layer(\n    self,\n    data: Any,\n    name: Optional[str] = None,\n    get_position: Union[str, Callable] = \"coordinates\",\n    cell_size: float = 200,\n    elevation_scale: float = 4,\n    extruded: bool = True,\n    color_range: Optional[List[List[int]]] = None,\n    pickable: bool = True,\n    opacity: float = 0.8,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a grid layer for square grid aggregation visualization.\n\n    Args:\n        data: Array of data objects with position coordinates.\n        name: Layer ID.\n        get_position: Accessor for point position [lng, lat].\n        cell_size: Grid cell size in meters.\n        elevation_scale: Elevation multiplier for 3D.\n        extruded: Whether to render as 3D cells.\n        color_range: Color gradient [[r, g, b], ...].\n        pickable: Whether layer responds to hover/click.\n        opacity: Layer opacity.\n        **kwargs: Additional layer props.\n    \"\"\"\n    layer_id = name or f\"grid-{len(self._deck_layers)}\"\n    processed_data = self._process_deck_data(data)\n\n    default_color_range = [\n        [1, 152, 189],\n        [73, 227, 206],\n        [216, 254, 181],\n        [254, 237, 177],\n        [254, 173, 84],\n        [209, 55, 78],\n    ]\n\n    self.call_js_method(\n        \"addGridLayer\",\n        id=layer_id,\n        data=processed_data,\n        getPosition=get_position,\n        cellSize=cell_size,\n        elevationScale=elevation_scale,\n        extruded=extruded,\n        colorRange=color_range or default_color_range,\n        pickable=pickable,\n        opacity=opacity,\n        **kwargs,\n    )\n\n    self._deck_layers = {\n        **self._deck_layers,\n        layer_id: {\"type\": \"GridLayer\", \"id\": layer_id},\n    }\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.deckgl.DeckGLMap.add_h3_cluster_layer","title":"<code>add_h3_cluster_layer(self, data, name=None, get_hexagons='hexagons', get_fill_color=None, get_line_color=None, get_line_width=1, filled=True, stroked=True, extruded=False, elevation_scale=1, pickable=True, opacity=0.8, **kwargs)</code>","text":"<p>Add an H3 cluster layer for grouped H3 cell visualization.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>Array of data objects with H3 index arrays.</p> required <code>name</code> <code>Optional[str]</code> <p>Layer ID.</p> <code>None</code> <code>get_hexagons</code> <code>Union[str, Callable]</code> <p>Accessor for array of H3 index strings.</p> <code>'hexagons'</code> <code>get_fill_color</code> <code>Union[List[int], str, Callable]</code> <p>Accessor for fill color [r, g, b, a].</p> <code>None</code> <code>get_line_color</code> <code>Union[List[int], str, Callable]</code> <p>Accessor for stroke color [r, g, b, a].</p> <code>None</code> <code>get_line_width</code> <code>Union[float, str, Callable]</code> <p>Accessor for line width.</p> <code>1</code> <code>filled</code> <code>bool</code> <p>Whether to fill clusters.</p> <code>True</code> <code>stroked</code> <code>bool</code> <p>Whether to stroke clusters.</p> <code>True</code> <code>extruded</code> <code>bool</code> <p>Whether to render as 3D.</p> <code>False</code> <code>elevation_scale</code> <code>float</code> <p>Elevation multiplier.</p> <code>1</code> <code>pickable</code> <code>bool</code> <p>Whether layer responds to hover/click.</p> <code>True</code> <code>opacity</code> <code>float</code> <p>Layer opacity.</p> <code>0.8</code> <code>**kwargs</code> <p>Additional H3ClusterLayer props.</p> <code>{}</code> Source code in <code>anymap_ts/deckgl.py</code> <pre><code>def add_h3_cluster_layer(\n    self,\n    data: Any,\n    name: Optional[str] = None,\n    get_hexagons: Union[str, Callable] = \"hexagons\",\n    get_fill_color: Union[List[int], str, Callable] = None,\n    get_line_color: Union[List[int], str, Callable] = None,\n    get_line_width: Union[float, str, Callable] = 1,\n    filled: bool = True,\n    stroked: bool = True,\n    extruded: bool = False,\n    elevation_scale: float = 1,\n    pickable: bool = True,\n    opacity: float = 0.8,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add an H3 cluster layer for grouped H3 cell visualization.\n\n    Args:\n        data: Array of data objects with H3 index arrays.\n        name: Layer ID.\n        get_hexagons: Accessor for array of H3 index strings.\n        get_fill_color: Accessor for fill color [r, g, b, a].\n        get_line_color: Accessor for stroke color [r, g, b, a].\n        get_line_width: Accessor for line width.\n        filled: Whether to fill clusters.\n        stroked: Whether to stroke clusters.\n        extruded: Whether to render as 3D.\n        elevation_scale: Elevation multiplier.\n        pickable: Whether layer responds to hover/click.\n        opacity: Layer opacity.\n        **kwargs: Additional H3ClusterLayer props.\n    \"\"\"\n    layer_id = name or f\"h3cluster-{len(self._deck_layers)}\"\n    processed_data = self._process_deck_data(data)\n\n    self.call_js_method(\n        \"addH3ClusterLayer\",\n        id=layer_id,\n        data=processed_data,\n        getHexagons=get_hexagons,\n        getFillColor=get_fill_color or [51, 136, 255, 128],\n        getLineColor=get_line_color or [0, 0, 0, 255],\n        getLineWidth=get_line_width,\n        filled=filled,\n        stroked=stroked,\n        extruded=extruded,\n        elevationScale=elevation_scale,\n        pickable=pickable,\n        opacity=opacity,\n        **kwargs,\n    )\n\n    self._deck_layers = {\n        **self._deck_layers,\n        layer_id: {\"type\": \"H3ClusterLayer\", \"id\": layer_id},\n    }\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.deckgl.DeckGLMap.add_h3_hexagon_layer","title":"<code>add_h3_hexagon_layer(self, data, name=None, get_hexagon='hexagon', get_fill_color=None, get_line_color=None, get_elevation=0, filled=True, stroked=True, extruded=False, wireframe=False, elevation_scale=1, coverage=1, high_precision=False, pickable=True, opacity=0.8, **kwargs)</code>","text":"<p>Add an H3 hexagon layer for H3 spatial index visualization.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>Array of data objects with H3 index.</p> required <code>name</code> <code>Optional[str]</code> <p>Layer ID.</p> <code>None</code> <code>get_hexagon</code> <code>Union[str, Callable]</code> <p>Accessor for H3 index string.</p> <code>'hexagon'</code> <code>get_fill_color</code> <code>Union[List[int], str, Callable]</code> <p>Accessor for fill color [r, g, b, a].</p> <code>None</code> <code>get_line_color</code> <code>Union[List[int], str, Callable]</code> <p>Accessor for stroke color [r, g, b, a].</p> <code>None</code> <code>get_elevation</code> <code>Union[float, str, Callable]</code> <p>Accessor for 3D extrusion height.</p> <code>0</code> <code>filled</code> <code>bool</code> <p>Whether to fill hexagons.</p> <code>True</code> <code>stroked</code> <code>bool</code> <p>Whether to stroke hexagons.</p> <code>True</code> <code>extruded</code> <code>bool</code> <p>Whether to render as 3D hexagons.</p> <code>False</code> <code>wireframe</code> <code>bool</code> <p>Whether to render wireframe.</p> <code>False</code> <code>elevation_scale</code> <code>float</code> <p>Elevation multiplier.</p> <code>1</code> <code>coverage</code> <code>float</code> <p>Hexagon coverage (0-1).</p> <code>1</code> <code>high_precision</code> <code>bool</code> <p>Use high precision rendering.</p> <code>False</code> <code>pickable</code> <code>bool</code> <p>Whether layer responds to hover/click.</p> <code>True</code> <code>opacity</code> <code>float</code> <p>Layer opacity.</p> <code>0.8</code> <code>**kwargs</code> <p>Additional H3HexagonLayer props.</p> <code>{}</code> Source code in <code>anymap_ts/deckgl.py</code> <pre><code>def add_h3_hexagon_layer(\n    self,\n    data: Any,\n    name: Optional[str] = None,\n    get_hexagon: Union[str, Callable] = \"hexagon\",\n    get_fill_color: Union[List[int], str, Callable] = None,\n    get_line_color: Union[List[int], str, Callable] = None,\n    get_elevation: Union[float, str, Callable] = 0,\n    filled: bool = True,\n    stroked: bool = True,\n    extruded: bool = False,\n    wireframe: bool = False,\n    elevation_scale: float = 1,\n    coverage: float = 1,\n    high_precision: bool = False,\n    pickable: bool = True,\n    opacity: float = 0.8,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add an H3 hexagon layer for H3 spatial index visualization.\n\n    Args:\n        data: Array of data objects with H3 index.\n        name: Layer ID.\n        get_hexagon: Accessor for H3 index string.\n        get_fill_color: Accessor for fill color [r, g, b, a].\n        get_line_color: Accessor for stroke color [r, g, b, a].\n        get_elevation: Accessor for 3D extrusion height.\n        filled: Whether to fill hexagons.\n        stroked: Whether to stroke hexagons.\n        extruded: Whether to render as 3D hexagons.\n        wireframe: Whether to render wireframe.\n        elevation_scale: Elevation multiplier.\n        coverage: Hexagon coverage (0-1).\n        high_precision: Use high precision rendering.\n        pickable: Whether layer responds to hover/click.\n        opacity: Layer opacity.\n        **kwargs: Additional H3HexagonLayer props.\n    \"\"\"\n    layer_id = name or f\"h3hexagon-{len(self._deck_layers)}\"\n    processed_data = self._process_deck_data(data)\n\n    self.call_js_method(\n        \"addH3HexagonLayer\",\n        id=layer_id,\n        data=processed_data,\n        getHexagon=get_hexagon,\n        getFillColor=get_fill_color or [51, 136, 255, 128],\n        getLineColor=get_line_color or [0, 0, 0, 255],\n        getElevation=get_elevation,\n        filled=filled,\n        stroked=stroked,\n        extruded=extruded,\n        wireframe=wireframe,\n        elevationScale=elevation_scale,\n        coverage=coverage,\n        highPrecision=high_precision,\n        pickable=pickable,\n        opacity=opacity,\n        **kwargs,\n    )\n\n    self._deck_layers = {\n        **self._deck_layers,\n        layer_id: {\"type\": \"H3HexagonLayer\", \"id\": layer_id},\n    }\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.deckgl.DeckGLMap.add_heatmap_layer","title":"<code>add_heatmap_layer(self, data, name=None, get_position='coordinates', get_weight=1, radius_pixels=30, intensity=1, threshold=0.05, color_range=None, opacity=1, **kwargs)</code>","text":"<p>Add a heatmap layer for density visualization.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>Array of data objects with position coordinates.</p> required <code>name</code> <code>Optional[str]</code> <p>Layer ID.</p> <code>None</code> <code>get_position</code> <code>Union[str, Callable]</code> <p>Accessor for point position [lng, lat].</p> <code>'coordinates'</code> <code>get_weight</code> <code>Union[float, str, Callable]</code> <p>Accessor for point weight.</p> <code>1</code> <code>radius_pixels</code> <code>float</code> <p>Influence radius in pixels.</p> <code>30</code> <code>intensity</code> <code>float</code> <p>Intensity multiplier.</p> <code>1</code> <code>threshold</code> <code>float</code> <p>Minimum density threshold.</p> <code>0.05</code> <code>color_range</code> <code>Optional[List[List[int]]]</code> <p>Color gradient [[r, g, b, a], ...].</p> <code>None</code> <code>opacity</code> <code>float</code> <p>Layer opacity.</p> <code>1</code> <code>**kwargs</code> <p>Additional layer props.</p> <code>{}</code> Source code in <code>anymap_ts/deckgl.py</code> <pre><code>def add_heatmap_layer(\n    self,\n    data: Any,\n    name: Optional[str] = None,\n    get_position: Union[str, Callable] = \"coordinates\",\n    get_weight: Union[float, str, Callable] = 1,\n    radius_pixels: float = 30,\n    intensity: float = 1,\n    threshold: float = 0.05,\n    color_range: Optional[List[List[int]]] = None,\n    opacity: float = 1,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a heatmap layer for density visualization.\n\n    Args:\n        data: Array of data objects with position coordinates.\n        name: Layer ID.\n        get_position: Accessor for point position [lng, lat].\n        get_weight: Accessor for point weight.\n        radius_pixels: Influence radius in pixels.\n        intensity: Intensity multiplier.\n        threshold: Minimum density threshold.\n        color_range: Color gradient [[r, g, b, a], ...].\n        opacity: Layer opacity.\n        **kwargs: Additional layer props.\n    \"\"\"\n    layer_id = name or f\"heatmap-{len(self._deck_layers)}\"\n    processed_data = self._process_deck_data(data)\n\n    default_color_range = [\n        [255, 255, 178, 25],\n        [254, 217, 118, 85],\n        [254, 178, 76, 127],\n        [253, 141, 60, 170],\n        [240, 59, 32, 212],\n        [189, 0, 38, 255],\n    ]\n\n    self.call_js_method(\n        \"addHeatmapLayer\",\n        id=layer_id,\n        data=processed_data,\n        getPosition=get_position,\n        getWeight=get_weight,\n        radiusPixels=radius_pixels,\n        intensity=intensity,\n        threshold=threshold,\n        colorRange=color_range or default_color_range,\n        opacity=opacity,\n        **kwargs,\n    )\n\n    self._deck_layers = {\n        **self._deck_layers,\n        layer_id: {\"type\": \"HeatmapLayer\", \"id\": layer_id},\n    }\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.deckgl.DeckGLMap.add_hexagon_layer","title":"<code>add_hexagon_layer(self, data, name=None, get_position='coordinates', radius=1000, elevation_scale=4, extruded=True, color_range=None, pickable=True, opacity=0.8, **kwargs)</code>","text":"<p>Add a hexagon layer for hexbin aggregation visualization.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>Array of data objects with position coordinates.</p> required <code>name</code> <code>Optional[str]</code> <p>Layer ID.</p> <code>None</code> <code>get_position</code> <code>Union[str, Callable]</code> <p>Accessor for point position [lng, lat].</p> <code>'coordinates'</code> <code>radius</code> <code>float</code> <p>Hexagon radius in meters.</p> <code>1000</code> <code>elevation_scale</code> <code>float</code> <p>Elevation multiplier for 3D.</p> <code>4</code> <code>extruded</code> <code>bool</code> <p>Whether to render as 3D hexagons.</p> <code>True</code> <code>color_range</code> <code>Optional[List[List[int]]]</code> <p>Color gradient for aggregation [[r, g, b], ...].</p> <code>None</code> <code>pickable</code> <code>bool</code> <p>Whether layer responds to hover/click.</p> <code>True</code> <code>opacity</code> <code>float</code> <p>Layer opacity.</p> <code>0.8</code> <code>**kwargs</code> <p>Additional layer props.</p> <code>{}</code> Source code in <code>anymap_ts/deckgl.py</code> <pre><code>def add_hexagon_layer(\n    self,\n    data: Any,\n    name: Optional[str] = None,\n    get_position: Union[str, Callable] = \"coordinates\",\n    radius: float = 1000,\n    elevation_scale: float = 4,\n    extruded: bool = True,\n    color_range: Optional[List[List[int]]] = None,\n    pickable: bool = True,\n    opacity: float = 0.8,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a hexagon layer for hexbin aggregation visualization.\n\n    Args:\n        data: Array of data objects with position coordinates.\n        name: Layer ID.\n        get_position: Accessor for point position [lng, lat].\n        radius: Hexagon radius in meters.\n        elevation_scale: Elevation multiplier for 3D.\n        extruded: Whether to render as 3D hexagons.\n        color_range: Color gradient for aggregation [[r, g, b], ...].\n        pickable: Whether layer responds to hover/click.\n        opacity: Layer opacity.\n        **kwargs: Additional layer props.\n    \"\"\"\n    layer_id = name or f\"hexagon-{len(self._deck_layers)}\"\n    processed_data = self._process_deck_data(data)\n\n    default_color_range = [\n        [1, 152, 189],\n        [73, 227, 206],\n        [216, 254, 181],\n        [254, 237, 177],\n        [254, 173, 84],\n        [209, 55, 78],\n    ]\n\n    self.call_js_method(\n        \"addHexagonLayer\",\n        id=layer_id,\n        data=processed_data,\n        getPosition=get_position,\n        radius=radius,\n        elevationScale=elevation_scale,\n        extruded=extruded,\n        colorRange=color_range or default_color_range,\n        pickable=pickable,\n        opacity=opacity,\n        **kwargs,\n    )\n\n    self._deck_layers = {\n        **self._deck_layers,\n        layer_id: {\"type\": \"HexagonLayer\", \"id\": layer_id},\n    }\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.deckgl.DeckGLMap.add_icon_layer","title":"<code>add_icon_layer(self, data, name=None, get_position='coordinates', get_icon='icon', get_size=20, get_color=None, icon_atlas=None, icon_mapping=None, pickable=True, opacity=1, **kwargs)</code>","text":"<p>Add an icon layer for custom marker visualization.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>Array of data objects with position coordinates.</p> required <code>name</code> <code>Optional[str]</code> <p>Layer ID.</p> <code>None</code> <code>get_position</code> <code>Union[str, Callable]</code> <p>Accessor for icon position [lng, lat].</p> <code>'coordinates'</code> <code>get_icon</code> <code>Union[str, Callable]</code> <p>Accessor for icon name in icon_mapping.</p> <code>'icon'</code> <code>get_size</code> <code>Union[float, str, Callable]</code> <p>Accessor for icon size.</p> <code>20</code> <code>get_color</code> <code>Union[List[int], str, Callable]</code> <p>Accessor for icon tint color [r, g, b, a].</p> <code>None</code> <code>icon_atlas</code> <code>Optional[str]</code> <p>URL to icon atlas image.</p> <code>None</code> <code>icon_mapping</code> <code>Optional[Dict]</code> <p>Dict mapping icon names to atlas coordinates.</p> <code>None</code> <code>pickable</code> <code>bool</code> <p>Whether layer responds to hover/click.</p> <code>True</code> <code>opacity</code> <code>float</code> <p>Layer opacity.</p> <code>1</code> <code>**kwargs</code> <p>Additional layer props.</p> <code>{}</code> Source code in <code>anymap_ts/deckgl.py</code> <pre><code>def add_icon_layer(\n    self,\n    data: Any,\n    name: Optional[str] = None,\n    get_position: Union[str, Callable] = \"coordinates\",\n    get_icon: Union[str, Callable] = \"icon\",\n    get_size: Union[float, str, Callable] = 20,\n    get_color: Union[List[int], str, Callable] = None,\n    icon_atlas: Optional[str] = None,\n    icon_mapping: Optional[Dict] = None,\n    pickable: bool = True,\n    opacity: float = 1,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add an icon layer for custom marker visualization.\n\n    Args:\n        data: Array of data objects with position coordinates.\n        name: Layer ID.\n        get_position: Accessor for icon position [lng, lat].\n        get_icon: Accessor for icon name in icon_mapping.\n        get_size: Accessor for icon size.\n        get_color: Accessor for icon tint color [r, g, b, a].\n        icon_atlas: URL to icon atlas image.\n        icon_mapping: Dict mapping icon names to atlas coordinates.\n        pickable: Whether layer responds to hover/click.\n        opacity: Layer opacity.\n        **kwargs: Additional layer props.\n    \"\"\"\n    layer_id = name or f\"icon-{len(self._deck_layers)}\"\n    processed_data = self._process_deck_data(data)\n\n    self.call_js_method(\n        \"addIconLayer\",\n        id=layer_id,\n        data=processed_data,\n        getPosition=get_position,\n        getIcon=get_icon,\n        getSize=get_size,\n        getColor=get_color or [255, 255, 255, 255],\n        iconAtlas=icon_atlas,\n        iconMapping=icon_mapping,\n        pickable=pickable,\n        opacity=opacity,\n        **kwargs,\n    )\n\n    self._deck_layers = {\n        **self._deck_layers,\n        layer_id: {\"type\": \"IconLayer\", \"id\": layer_id},\n    }\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.deckgl.DeckGLMap.add_line_layer","title":"<code>add_line_layer(self, data, name=None, get_source_position='sourcePosition', get_target_position='targetPosition', get_color=None, get_width=1, width_min_pixels=1, pickable=True, opacity=0.8, **kwargs)</code>","text":"<p>Add a line layer for simple line segment visualization.</p> <p>The LineLayer renders straight line segments between source and target positions. Unlike ArcLayer, lines are drawn directly without curvature.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>Array of line objects with source/target positions.</p> required <code>name</code> <code>Optional[str]</code> <p>Layer ID. If None, auto-generated.</p> <code>None</code> <code>get_source_position</code> <code>Union[str, Callable]</code> <p>Accessor for source position [lng, lat].</p> <code>'sourcePosition'</code> <code>get_target_position</code> <code>Union[str, Callable]</code> <p>Accessor for target position [lng, lat].</p> <code>'targetPosition'</code> <code>get_color</code> <code>Union[List[int], str, Callable]</code> <p>Accessor for line color [r, g, b] or [r, g, b, a].</p> <code>None</code> <code>get_width</code> <code>Union[float, str, Callable]</code> <p>Accessor for line width.</p> <code>1</code> <code>width_min_pixels</code> <code>float</code> <p>Minimum line width in pixels.</p> <code>1</code> <code>pickable</code> <code>bool</code> <p>Whether layer responds to hover/click.</p> <code>True</code> <code>opacity</code> <code>float</code> <p>Layer opacity (0-1).</p> <code>0.8</code> <code>**kwargs</code> <p>Additional LineLayer props.</p> <code>{}</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; m = DeckGLMap()\n&gt;&gt;&gt; lines = [\n...     {\"sourcePosition\": [-122.4, 37.8], \"targetPosition\": [-122.5, 37.7]},\n...     {\"sourcePosition\": [-122.5, 37.7], \"targetPosition\": [-122.6, 37.8]},\n... ]\n&gt;&gt;&gt; m.add_line_layer(\n...     data=lines,\n...     get_color=[0, 128, 255],\n...     get_width=2,\n... )\n</code></pre> Source code in <code>anymap_ts/deckgl.py</code> <pre><code>def add_line_layer(\n    self,\n    data: Any,\n    name: Optional[str] = None,\n    get_source_position: Union[str, Callable] = \"sourcePosition\",\n    get_target_position: Union[str, Callable] = \"targetPosition\",\n    get_color: Union[List[int], str, Callable] = None,\n    get_width: Union[float, str, Callable] = 1,\n    width_min_pixels: float = 1,\n    pickable: bool = True,\n    opacity: float = 0.8,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a line layer for simple line segment visualization.\n\n    The LineLayer renders straight line segments between source and\n    target positions. Unlike ArcLayer, lines are drawn directly\n    without curvature.\n\n    Args:\n        data: Array of line objects with source/target positions.\n        name: Layer ID. If None, auto-generated.\n        get_source_position: Accessor for source position [lng, lat].\n        get_target_position: Accessor for target position [lng, lat].\n        get_color: Accessor for line color [r, g, b] or [r, g, b, a].\n        get_width: Accessor for line width.\n        width_min_pixels: Minimum line width in pixels.\n        pickable: Whether layer responds to hover/click.\n        opacity: Layer opacity (0-1).\n        **kwargs: Additional LineLayer props.\n\n    Example:\n        &gt;&gt;&gt; m = DeckGLMap()\n        &gt;&gt;&gt; lines = [\n        ...     {\"sourcePosition\": [-122.4, 37.8], \"targetPosition\": [-122.5, 37.7]},\n        ...     {\"sourcePosition\": [-122.5, 37.7], \"targetPosition\": [-122.6, 37.8]},\n        ... ]\n        &gt;&gt;&gt; m.add_line_layer(\n        ...     data=lines,\n        ...     get_color=[0, 128, 255],\n        ...     get_width=2,\n        ... )\n    \"\"\"\n    layer_id = name or f\"line-{len(self._deck_layers)}\"\n    processed_data = self._process_deck_data(data)\n\n    self.call_js_method(\n        \"addLineLayer\",\n        id=layer_id,\n        data=processed_data,\n        getSourcePosition=get_source_position,\n        getTargetPosition=get_target_position,\n        getColor=get_color or [51, 136, 255, 200],\n        getWidth=get_width,\n        widthMinPixels=width_min_pixels,\n        pickable=pickable,\n        opacity=opacity,\n        **kwargs,\n    )\n\n    self._deck_layers = {\n        **self._deck_layers,\n        layer_id: {\"type\": \"LineLayer\", \"id\": layer_id},\n    }\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.deckgl.DeckGLMap.add_mvt_layer","title":"<code>add_mvt_layer(self, data, name=None, min_zoom=0, max_zoom=14, binary=True, get_fill_color=None, get_line_color=None, get_line_width=1, get_point_radius=5, line_width_min_pixels=1, point_radius_min_pixels=2, pickable=True, visible=True, opacity=1.0, **kwargs)</code>","text":"<p>Add a Mapbox Vector Tile (MVT) layer.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Union[str, List[str]]</code> <p>MVT tile URL template with {z}/{x}/{y} placeholders.</p> required <code>name</code> <code>Optional[str]</code> <p>Layer ID.</p> <code>None</code> <code>min_zoom</code> <code>int</code> <p>Minimum zoom level.</p> <code>0</code> <code>max_zoom</code> <code>int</code> <p>Maximum zoom level.</p> <code>14</code> <code>binary</code> <code>bool</code> <p>Whether to use binary format.</p> <code>True</code> <code>get_fill_color</code> <code>Union[List[int], str, Callable]</code> <p>Accessor for fill color [r, g, b, a].</p> <code>None</code> <code>get_line_color</code> <code>Union[List[int], str, Callable]</code> <p>Accessor for stroke color [r, g, b, a].</p> <code>None</code> <code>get_line_width</code> <code>Union[float, str, Callable]</code> <p>Accessor for line width.</p> <code>1</code> <code>get_point_radius</code> <code>Union[float, str, Callable]</code> <p>Accessor for point radius.</p> <code>5</code> <code>line_width_min_pixels</code> <code>float</code> <p>Minimum line width in pixels.</p> <code>1</code> <code>point_radius_min_pixels</code> <code>float</code> <p>Minimum point radius in pixels.</p> <code>2</code> <code>pickable</code> <code>bool</code> <p>Whether layer responds to hover/click.</p> <code>True</code> <code>visible</code> <code>bool</code> <p>Whether layer is visible.</p> <code>True</code> <code>opacity</code> <code>float</code> <p>Layer opacity (0-1).</p> <code>1.0</code> <code>**kwargs</code> <p>Additional MVTLayer props.</p> <code>{}</code> Source code in <code>anymap_ts/deckgl.py</code> <pre><code>def add_mvt_layer(\n    self,\n    data: Union[str, List[str]],\n    name: Optional[str] = None,\n    min_zoom: int = 0,\n    max_zoom: int = 14,\n    binary: bool = True,\n    get_fill_color: Union[List[int], str, Callable] = None,\n    get_line_color: Union[List[int], str, Callable] = None,\n    get_line_width: Union[float, str, Callable] = 1,\n    get_point_radius: Union[float, str, Callable] = 5,\n    line_width_min_pixels: float = 1,\n    point_radius_min_pixels: float = 2,\n    pickable: bool = True,\n    visible: bool = True,\n    opacity: float = 1.0,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a Mapbox Vector Tile (MVT) layer.\n\n    Args:\n        data: MVT tile URL template with {z}/{x}/{y} placeholders.\n        name: Layer ID.\n        min_zoom: Minimum zoom level.\n        max_zoom: Maximum zoom level.\n        binary: Whether to use binary format.\n        get_fill_color: Accessor for fill color [r, g, b, a].\n        get_line_color: Accessor for stroke color [r, g, b, a].\n        get_line_width: Accessor for line width.\n        get_point_radius: Accessor for point radius.\n        line_width_min_pixels: Minimum line width in pixels.\n        point_radius_min_pixels: Minimum point radius in pixels.\n        pickable: Whether layer responds to hover/click.\n        visible: Whether layer is visible.\n        opacity: Layer opacity (0-1).\n        **kwargs: Additional MVTLayer props.\n    \"\"\"\n    layer_id = name or f\"mvt-{len(self._deck_layers)}\"\n\n    self.call_js_method(\n        \"addMVTLayer\",\n        id=layer_id,\n        data=data,\n        minZoom=min_zoom,\n        maxZoom=max_zoom,\n        binary=binary,\n        getFillColor=get_fill_color or [51, 136, 255, 128],\n        getLineColor=get_line_color or [0, 0, 0, 255],\n        getLineWidth=get_line_width,\n        getPointRadius=get_point_radius,\n        lineWidthMinPixels=line_width_min_pixels,\n        pointRadiusMinPixels=point_radius_min_pixels,\n        pickable=pickable,\n        visible=visible,\n        opacity=opacity,\n        **kwargs,\n    )\n\n    self._deck_layers = {\n        **self._deck_layers,\n        layer_id: {\"type\": \"MVTLayer\", \"id\": layer_id},\n    }\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.deckgl.DeckGLMap.add_path_layer","title":"<code>add_path_layer(self, data, name=None, get_path='path', get_color=None, get_width=1, width_scale=1, width_min_pixels=1, pickable=True, opacity=0.8, **kwargs)</code>","text":"<p>Add a path layer for polyline visualization.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>Array of data objects with path coordinates.</p> required <code>name</code> <code>Optional[str]</code> <p>Layer ID.</p> <code>None</code> <code>get_path</code> <code>Union[str, Callable]</code> <p>Accessor for path coordinates [[lng, lat], ...].</p> <code>'path'</code> <code>get_color</code> <code>Union[List[int], str, Callable]</code> <p>Accessor for path color [r, g, b, a].</p> <code>None</code> <code>get_width</code> <code>Union[float, str, Callable]</code> <p>Accessor for path width.</p> <code>1</code> <code>width_scale</code> <code>float</code> <p>Global width multiplier.</p> <code>1</code> <code>width_min_pixels</code> <code>float</code> <p>Minimum width in pixels.</p> <code>1</code> <code>pickable</code> <code>bool</code> <p>Whether layer responds to hover/click.</p> <code>True</code> <code>opacity</code> <code>float</code> <p>Layer opacity.</p> <code>0.8</code> <code>**kwargs</code> <p>Additional layer props.</p> <code>{}</code> Source code in <code>anymap_ts/deckgl.py</code> <pre><code>def add_path_layer(\n    self,\n    data: Any,\n    name: Optional[str] = None,\n    get_path: Union[str, Callable] = \"path\",\n    get_color: Union[List[int], str, Callable] = None,\n    get_width: Union[float, str, Callable] = 1,\n    width_scale: float = 1,\n    width_min_pixels: float = 1,\n    pickable: bool = True,\n    opacity: float = 0.8,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a path layer for polyline visualization.\n\n    Args:\n        data: Array of data objects with path coordinates.\n        name: Layer ID.\n        get_path: Accessor for path coordinates [[lng, lat], ...].\n        get_color: Accessor for path color [r, g, b, a].\n        get_width: Accessor for path width.\n        width_scale: Global width multiplier.\n        width_min_pixels: Minimum width in pixels.\n        pickable: Whether layer responds to hover/click.\n        opacity: Layer opacity.\n        **kwargs: Additional layer props.\n    \"\"\"\n    layer_id = name or f\"path-{len(self._deck_layers)}\"\n    processed_data = self._process_deck_data(data)\n\n    self.call_js_method(\n        \"addPathLayer\",\n        id=layer_id,\n        data=processed_data,\n        getPath=get_path,\n        getColor=get_color or [51, 136, 255, 200],\n        getWidth=get_width,\n        widthScale=width_scale,\n        widthMinPixels=width_min_pixels,\n        pickable=pickable,\n        opacity=opacity,\n        **kwargs,\n    )\n\n    self._deck_layers = {\n        **self._deck_layers,\n        layer_id: {\"type\": \"PathLayer\", \"id\": layer_id},\n    }\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.deckgl.DeckGLMap.add_point_cloud_layer","title":"<code>add_point_cloud_layer(self, data, name=None, get_position='position', get_color=None, get_normal=None, point_size=2, size_units='pixels', coordinate_system=None, coordinate_origin=None, pickable=True, opacity=1.0, **kwargs)</code>","text":"<p>Add a point cloud layer for 3D point visualization.</p> <p>Renders large point cloud datasets typically from LiDAR or 3D scanning. Supports both 2D and 3D coordinates with optional normal vectors for lighting effects.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>Array of point data with position [x, y, z] coordinates.</p> required <code>name</code> <code>Optional[str]</code> <p>Layer ID. If None, auto-generated.</p> <code>None</code> <code>get_position</code> <code>Union[str, Callable]</code> <p>Accessor for point position [x, y, z].</p> <code>'position'</code> <code>get_color</code> <code>Union[List[int], str, Callable]</code> <p>Accessor for point color [r, g, b, a].</p> <code>None</code> <code>get_normal</code> <code>Union[str, Callable]</code> <p>Accessor for point normal [nx, ny, nz] for lighting.</p> <code>None</code> <code>point_size</code> <code>float</code> <p>Point size in size_units.</p> <code>2</code> <code>size_units</code> <code>str</code> <p>Units for point_size ('pixels' or 'meters').</p> <code>'pixels'</code> <code>coordinate_system</code> <code>Optional[str]</code> <p>Coordinate system ('CARTESIAN', 'METER_OFFSETS', 'LNGLAT', 'LNGLAT_OFFSETS').</p> <code>None</code> <code>coordinate_origin</code> <code>Optional[List[float]]</code> <p>Origin for offset coordinate systems [lng, lat, z].</p> <code>None</code> <code>pickable</code> <code>bool</code> <p>Whether layer responds to hover/click.</p> <code>True</code> <code>opacity</code> <code>float</code> <p>Layer opacity (0-1).</p> <code>1.0</code> <code>**kwargs</code> <p>Additional PointCloudLayer props.</p> <code>{}</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; m = DeckGLMap()\n&gt;&gt;&gt; points = [\n...     {\"position\": [-122.4, 37.8, 100], \"color\": [255, 0, 0]},\n...     {\"position\": [-122.5, 37.7, 200], \"color\": [0, 255, 0]},\n... ]\n&gt;&gt;&gt; m.add_point_cloud_layer(\n...     data=points,\n...     point_size=5,\n...     get_color=\"color\"\n... )\n</code></pre> Source code in <code>anymap_ts/deckgl.py</code> <pre><code>def add_point_cloud_layer(\n    self,\n    data: Any,\n    name: Optional[str] = None,\n    get_position: Union[str, Callable] = \"position\",\n    get_color: Union[List[int], str, Callable] = None,\n    get_normal: Union[str, Callable] = None,\n    point_size: float = 2,\n    size_units: str = \"pixels\",\n    coordinate_system: Optional[str] = None,\n    coordinate_origin: Optional[List[float]] = None,\n    pickable: bool = True,\n    opacity: float = 1.0,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a point cloud layer for 3D point visualization.\n\n    Renders large point cloud datasets typically from LiDAR or 3D scanning.\n    Supports both 2D and 3D coordinates with optional normal vectors for\n    lighting effects.\n\n    Args:\n        data: Array of point data with position [x, y, z] coordinates.\n        name: Layer ID. If None, auto-generated.\n        get_position: Accessor for point position [x, y, z].\n        get_color: Accessor for point color [r, g, b, a].\n        get_normal: Accessor for point normal [nx, ny, nz] for lighting.\n        point_size: Point size in size_units.\n        size_units: Units for point_size ('pixels' or 'meters').\n        coordinate_system: Coordinate system ('CARTESIAN', 'METER_OFFSETS',\n            'LNGLAT', 'LNGLAT_OFFSETS').\n        coordinate_origin: Origin for offset coordinate systems [lng, lat, z].\n        pickable: Whether layer responds to hover/click.\n        opacity: Layer opacity (0-1).\n        **kwargs: Additional PointCloudLayer props.\n\n    Example:\n        &gt;&gt;&gt; m = DeckGLMap()\n        &gt;&gt;&gt; points = [\n        ...     {\"position\": [-122.4, 37.8, 100], \"color\": [255, 0, 0]},\n        ...     {\"position\": [-122.5, 37.7, 200], \"color\": [0, 255, 0]},\n        ... ]\n        &gt;&gt;&gt; m.add_point_cloud_layer(\n        ...     data=points,\n        ...     point_size=5,\n        ...     get_color=\"color\"\n        ... )\n    \"\"\"\n    layer_id = name or f\"pointcloud-{len(self._deck_layers)}\"\n    processed_data = self._process_deck_data(data)\n\n    layer_kwargs = {\n        \"id\": layer_id,\n        \"data\": processed_data,\n        \"getPosition\": get_position,\n        \"getColor\": get_color or [255, 255, 255, 255],\n        \"pointSize\": point_size,\n        \"sizeUnits\": size_units,\n        \"pickable\": pickable,\n        \"opacity\": opacity,\n    }\n\n    if get_normal is not None:\n        layer_kwargs[\"getNormal\"] = get_normal\n\n    if coordinate_system is not None:\n        layer_kwargs[\"coordinateSystem\"] = coordinate_system\n\n    if coordinate_origin is not None:\n        layer_kwargs[\"coordinateOrigin\"] = coordinate_origin\n\n    layer_kwargs.update(kwargs)\n    self.call_js_method(\"addPointCloudLayer\", **layer_kwargs)\n\n    self._deck_layers = {\n        **self._deck_layers,\n        layer_id: {\"type\": \"PointCloudLayer\", \"id\": layer_id},\n    }\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.deckgl.DeckGLMap.add_polygon_layer","title":"<code>add_polygon_layer(self, data, name=None, get_polygon='polygon', get_fill_color=None, get_line_color=None, get_line_width=1, get_elevation=0, extruded=False, wireframe=False, filled=True, stroked=True, line_width_min_pixels=1, pickable=True, opacity=0.5, **kwargs)</code>","text":"<p>Add a polygon layer for filled polygon visualization.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>Array of data objects with polygon coordinates.</p> required <code>name</code> <code>Optional[str]</code> <p>Layer ID.</p> <code>None</code> <code>get_polygon</code> <code>Union[str, Callable]</code> <p>Accessor for polygon coordinates.</p> <code>'polygon'</code> <code>get_fill_color</code> <code>Union[List[int], str, Callable]</code> <p>Accessor for fill color [r, g, b, a].</p> <code>None</code> <code>get_line_color</code> <code>Union[List[int], str, Callable]</code> <p>Accessor for stroke color [r, g, b, a].</p> <code>None</code> <code>get_line_width</code> <code>Union[float, str, Callable]</code> <p>Accessor for stroke width.</p> <code>1</code> <code>get_elevation</code> <code>Union[float, str, Callable]</code> <p>Accessor for 3D extrusion height.</p> <code>0</code> <code>extruded</code> <code>bool</code> <p>Whether to render as 3D polygons.</p> <code>False</code> <code>wireframe</code> <code>bool</code> <p>Whether to render wireframe (extruded only).</p> <code>False</code> <code>filled</code> <code>bool</code> <p>Whether to fill polygons.</p> <code>True</code> <code>stroked</code> <code>bool</code> <p>Whether to draw stroke.</p> <code>True</code> <code>line_width_min_pixels</code> <code>float</code> <p>Minimum stroke width.</p> <code>1</code> <code>pickable</code> <code>bool</code> <p>Whether layer responds to hover/click.</p> <code>True</code> <code>opacity</code> <code>float</code> <p>Layer opacity.</p> <code>0.5</code> <code>**kwargs</code> <p>Additional layer props.</p> <code>{}</code> Source code in <code>anymap_ts/deckgl.py</code> <pre><code>def add_polygon_layer(\n    self,\n    data: Any,\n    name: Optional[str] = None,\n    get_polygon: Union[str, Callable] = \"polygon\",\n    get_fill_color: Union[List[int], str, Callable] = None,\n    get_line_color: Union[List[int], str, Callable] = None,\n    get_line_width: Union[float, str, Callable] = 1,\n    get_elevation: Union[float, str, Callable] = 0,\n    extruded: bool = False,\n    wireframe: bool = False,\n    filled: bool = True,\n    stroked: bool = True,\n    line_width_min_pixels: float = 1,\n    pickable: bool = True,\n    opacity: float = 0.5,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a polygon layer for filled polygon visualization.\n\n    Args:\n        data: Array of data objects with polygon coordinates.\n        name: Layer ID.\n        get_polygon: Accessor for polygon coordinates.\n        get_fill_color: Accessor for fill color [r, g, b, a].\n        get_line_color: Accessor for stroke color [r, g, b, a].\n        get_line_width: Accessor for stroke width.\n        get_elevation: Accessor for 3D extrusion height.\n        extruded: Whether to render as 3D polygons.\n        wireframe: Whether to render wireframe (extruded only).\n        filled: Whether to fill polygons.\n        stroked: Whether to draw stroke.\n        line_width_min_pixels: Minimum stroke width.\n        pickable: Whether layer responds to hover/click.\n        opacity: Layer opacity.\n        **kwargs: Additional layer props.\n    \"\"\"\n    layer_id = name or f\"polygon-{len(self._deck_layers)}\"\n    processed_data = self._process_deck_data(data)\n\n    self.call_js_method(\n        \"addPolygonLayer\",\n        id=layer_id,\n        data=processed_data,\n        getPolygon=get_polygon,\n        getFillColor=get_fill_color or [51, 136, 255, 128],\n        getLineColor=get_line_color or [0, 0, 255, 255],\n        getLineWidth=get_line_width,\n        getElevation=get_elevation,\n        extruded=extruded,\n        wireframe=wireframe,\n        filled=filled,\n        stroked=stroked,\n        lineWidthMinPixels=line_width_min_pixels,\n        pickable=pickable,\n        opacity=opacity,\n        **kwargs,\n    )\n\n    self._deck_layers = {\n        **self._deck_layers,\n        layer_id: {\"type\": \"PolygonLayer\", \"id\": layer_id},\n    }\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.deckgl.DeckGLMap.add_quadkey_layer","title":"<code>add_quadkey_layer(self, data, name=None, get_quadkey='quadkey', get_fill_color=None, get_line_color=None, get_line_width=1, get_elevation=0, filled=True, stroked=True, extruded=False, wireframe=False, elevation_scale=1, pickable=True, opacity=0.8, **kwargs)</code>","text":"<p>Add a Quadkey layer for Bing Maps tile index visualization.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>Array of data objects with quadkey.</p> required <code>name</code> <code>Optional[str]</code> <p>Layer ID.</p> <code>None</code> <code>get_quadkey</code> <code>Union[str, Callable]</code> <p>Accessor for quadkey string.</p> <code>'quadkey'</code> <code>get_fill_color</code> <code>Union[List[int], str, Callable]</code> <p>Accessor for fill color [r, g, b, a].</p> <code>None</code> <code>get_line_color</code> <code>Union[List[int], str, Callable]</code> <p>Accessor for stroke color [r, g, b, a].</p> <code>None</code> <code>get_line_width</code> <code>Union[float, str, Callable]</code> <p>Accessor for line width.</p> <code>1</code> <code>get_elevation</code> <code>Union[float, str, Callable]</code> <p>Accessor for 3D extrusion height.</p> <code>0</code> <code>filled</code> <code>bool</code> <p>Whether to fill cells.</p> <code>True</code> <code>stroked</code> <code>bool</code> <p>Whether to stroke cells.</p> <code>True</code> <code>extruded</code> <code>bool</code> <p>Whether to render as 3D.</p> <code>False</code> <code>wireframe</code> <code>bool</code> <p>Whether to render wireframe.</p> <code>False</code> <code>elevation_scale</code> <code>float</code> <p>Elevation multiplier.</p> <code>1</code> <code>pickable</code> <code>bool</code> <p>Whether layer responds to hover/click.</p> <code>True</code> <code>opacity</code> <code>float</code> <p>Layer opacity.</p> <code>0.8</code> <code>**kwargs</code> <p>Additional QuadkeyLayer props.</p> <code>{}</code> Source code in <code>anymap_ts/deckgl.py</code> <pre><code>def add_quadkey_layer(\n    self,\n    data: Any,\n    name: Optional[str] = None,\n    get_quadkey: Union[str, Callable] = \"quadkey\",\n    get_fill_color: Union[List[int], str, Callable] = None,\n    get_line_color: Union[List[int], str, Callable] = None,\n    get_line_width: Union[float, str, Callable] = 1,\n    get_elevation: Union[float, str, Callable] = 0,\n    filled: bool = True,\n    stroked: bool = True,\n    extruded: bool = False,\n    wireframe: bool = False,\n    elevation_scale: float = 1,\n    pickable: bool = True,\n    opacity: float = 0.8,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a Quadkey layer for Bing Maps tile index visualization.\n\n    Args:\n        data: Array of data objects with quadkey.\n        name: Layer ID.\n        get_quadkey: Accessor for quadkey string.\n        get_fill_color: Accessor for fill color [r, g, b, a].\n        get_line_color: Accessor for stroke color [r, g, b, a].\n        get_line_width: Accessor for line width.\n        get_elevation: Accessor for 3D extrusion height.\n        filled: Whether to fill cells.\n        stroked: Whether to stroke cells.\n        extruded: Whether to render as 3D.\n        wireframe: Whether to render wireframe.\n        elevation_scale: Elevation multiplier.\n        pickable: Whether layer responds to hover/click.\n        opacity: Layer opacity.\n        **kwargs: Additional QuadkeyLayer props.\n    \"\"\"\n    layer_id = name or f\"quadkey-{len(self._deck_layers)}\"\n    processed_data = self._process_deck_data(data)\n\n    self.call_js_method(\n        \"addQuadkeyLayer\",\n        id=layer_id,\n        data=processed_data,\n        getQuadkey=get_quadkey,\n        getFillColor=get_fill_color or [51, 136, 255, 128],\n        getLineColor=get_line_color or [0, 0, 0, 255],\n        getLineWidth=get_line_width,\n        getElevation=get_elevation,\n        filled=filled,\n        stroked=stroked,\n        extruded=extruded,\n        wireframe=wireframe,\n        elevationScale=elevation_scale,\n        pickable=pickable,\n        opacity=opacity,\n        **kwargs,\n    )\n\n    self._deck_layers = {\n        **self._deck_layers,\n        layer_id: {\"type\": \"QuadkeyLayer\", \"id\": layer_id},\n    }\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.deckgl.DeckGLMap.add_s2_layer","title":"<code>add_s2_layer(self, data, name=None, get_s2_token='s2Token', get_fill_color=None, get_line_color=None, get_line_width=1, get_elevation=0, filled=True, stroked=True, extruded=False, wireframe=False, elevation_scale=1, pickable=True, opacity=0.8, **kwargs)</code>","text":"<p>Add an S2 layer for S2 geometry cell visualization.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>Array of data objects with S2 token.</p> required <code>name</code> <code>Optional[str]</code> <p>Layer ID.</p> <code>None</code> <code>get_s2_token</code> <code>Union[str, Callable]</code> <p>Accessor for S2 token string.</p> <code>'s2Token'</code> <code>get_fill_color</code> <code>Union[List[int], str, Callable]</code> <p>Accessor for fill color [r, g, b, a].</p> <code>None</code> <code>get_line_color</code> <code>Union[List[int], str, Callable]</code> <p>Accessor for stroke color [r, g, b, a].</p> <code>None</code> <code>get_line_width</code> <code>Union[float, str, Callable]</code> <p>Accessor for line width.</p> <code>1</code> <code>get_elevation</code> <code>Union[float, str, Callable]</code> <p>Accessor for 3D extrusion height.</p> <code>0</code> <code>filled</code> <code>bool</code> <p>Whether to fill cells.</p> <code>True</code> <code>stroked</code> <code>bool</code> <p>Whether to stroke cells.</p> <code>True</code> <code>extruded</code> <code>bool</code> <p>Whether to render as 3D.</p> <code>False</code> <code>wireframe</code> <code>bool</code> <p>Whether to render wireframe.</p> <code>False</code> <code>elevation_scale</code> <code>float</code> <p>Elevation multiplier.</p> <code>1</code> <code>pickable</code> <code>bool</code> <p>Whether layer responds to hover/click.</p> <code>True</code> <code>opacity</code> <code>float</code> <p>Layer opacity.</p> <code>0.8</code> <code>**kwargs</code> <p>Additional S2Layer props.</p> <code>{}</code> Source code in <code>anymap_ts/deckgl.py</code> <pre><code>def add_s2_layer(\n    self,\n    data: Any,\n    name: Optional[str] = None,\n    get_s2_token: Union[str, Callable] = \"s2Token\",\n    get_fill_color: Union[List[int], str, Callable] = None,\n    get_line_color: Union[List[int], str, Callable] = None,\n    get_line_width: Union[float, str, Callable] = 1,\n    get_elevation: Union[float, str, Callable] = 0,\n    filled: bool = True,\n    stroked: bool = True,\n    extruded: bool = False,\n    wireframe: bool = False,\n    elevation_scale: float = 1,\n    pickable: bool = True,\n    opacity: float = 0.8,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add an S2 layer for S2 geometry cell visualization.\n\n    Args:\n        data: Array of data objects with S2 token.\n        name: Layer ID.\n        get_s2_token: Accessor for S2 token string.\n        get_fill_color: Accessor for fill color [r, g, b, a].\n        get_line_color: Accessor for stroke color [r, g, b, a].\n        get_line_width: Accessor for line width.\n        get_elevation: Accessor for 3D extrusion height.\n        filled: Whether to fill cells.\n        stroked: Whether to stroke cells.\n        extruded: Whether to render as 3D.\n        wireframe: Whether to render wireframe.\n        elevation_scale: Elevation multiplier.\n        pickable: Whether layer responds to hover/click.\n        opacity: Layer opacity.\n        **kwargs: Additional S2Layer props.\n    \"\"\"\n    layer_id = name or f\"s2-{len(self._deck_layers)}\"\n    processed_data = self._process_deck_data(data)\n\n    self.call_js_method(\n        \"addS2Layer\",\n        id=layer_id,\n        data=processed_data,\n        getS2Token=get_s2_token,\n        getFillColor=get_fill_color or [51, 136, 255, 128],\n        getLineColor=get_line_color or [0, 0, 0, 255],\n        getLineWidth=get_line_width,\n        getElevation=get_elevation,\n        filled=filled,\n        stroked=stroked,\n        extruded=extruded,\n        wireframe=wireframe,\n        elevationScale=elevation_scale,\n        pickable=pickable,\n        opacity=opacity,\n        **kwargs,\n    )\n\n    self._deck_layers = {\n        **self._deck_layers,\n        layer_id: {\"type\": \"S2Layer\", \"id\": layer_id},\n    }\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.deckgl.DeckGLMap.add_scatterplot_layer","title":"<code>add_scatterplot_layer(self, data, name=None, get_position='coordinates', get_radius=5, get_fill_color=None, get_line_color=None, radius_scale=1, radius_min_pixels=1, radius_max_pixels=100, line_width_min_pixels=1, stroked=True, filled=True, pickable=True, opacity=0.8, **kwargs)</code>","text":"<p>Add a scatterplot layer for point visualization.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>Array of data objects or GeoJSON.</p> required <code>name</code> <code>Optional[str]</code> <p>Layer ID.</p> <code>None</code> <code>get_position</code> <code>Union[str, Callable]</code> <p>Accessor for point position [lng, lat].</p> <code>'coordinates'</code> <code>get_radius</code> <code>Union[float, str, Callable]</code> <p>Accessor for point radius.</p> <code>5</code> <code>get_fill_color</code> <code>Union[List[int], str, Callable]</code> <p>Accessor for fill color [r, g, b, a].</p> <code>None</code> <code>get_line_color</code> <code>Union[List[int], str, Callable]</code> <p>Accessor for stroke color [r, g, b, a].</p> <code>None</code> <code>radius_scale</code> <code>float</code> <p>Global radius multiplier.</p> <code>1</code> <code>radius_min_pixels</code> <code>float</code> <p>Minimum radius in pixels.</p> <code>1</code> <code>radius_max_pixels</code> <code>float</code> <p>Maximum radius in pixels.</p> <code>100</code> <code>line_width_min_pixels</code> <code>float</code> <p>Minimum stroke width.</p> <code>1</code> <code>stroked</code> <code>bool</code> <p>Whether to draw stroke.</p> <code>True</code> <code>filled</code> <code>bool</code> <p>Whether to fill points.</p> <code>True</code> <code>pickable</code> <code>bool</code> <p>Whether layer responds to hover/click.</p> <code>True</code> <code>opacity</code> <code>float</code> <p>Layer opacity.</p> <code>0.8</code> <code>**kwargs</code> <p>Additional layer props.</p> <code>{}</code> Source code in <code>anymap_ts/deckgl.py</code> <pre><code>def add_scatterplot_layer(\n    self,\n    data: Any,\n    name: Optional[str] = None,\n    get_position: Union[str, Callable] = \"coordinates\",\n    get_radius: Union[float, str, Callable] = 5,\n    get_fill_color: Union[List[int], str, Callable] = None,\n    get_line_color: Union[List[int], str, Callable] = None,\n    radius_scale: float = 1,\n    radius_min_pixels: float = 1,\n    radius_max_pixels: float = 100,\n    line_width_min_pixels: float = 1,\n    stroked: bool = True,\n    filled: bool = True,\n    pickable: bool = True,\n    opacity: float = 0.8,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a scatterplot layer for point visualization.\n\n    Args:\n        data: Array of data objects or GeoJSON.\n        name: Layer ID.\n        get_position: Accessor for point position [lng, lat].\n        get_radius: Accessor for point radius.\n        get_fill_color: Accessor for fill color [r, g, b, a].\n        get_line_color: Accessor for stroke color [r, g, b, a].\n        radius_scale: Global radius multiplier.\n        radius_min_pixels: Minimum radius in pixels.\n        radius_max_pixels: Maximum radius in pixels.\n        line_width_min_pixels: Minimum stroke width.\n        stroked: Whether to draw stroke.\n        filled: Whether to fill points.\n        pickable: Whether layer responds to hover/click.\n        opacity: Layer opacity.\n        **kwargs: Additional layer props.\n    \"\"\"\n    layer_id = name or f\"scatterplot-{len(self._deck_layers)}\"\n    processed_data = self._process_deck_data(data)\n\n    self.call_js_method(\n        \"addScatterplotLayer\",\n        id=layer_id,\n        data=processed_data,\n        getPosition=get_position,\n        getRadius=get_radius,\n        getFillColor=get_fill_color or [51, 136, 255, 200],\n        getLineColor=get_line_color or [255, 255, 255, 255],\n        radiusScale=radius_scale,\n        radiusMinPixels=radius_min_pixels,\n        radiusMaxPixels=radius_max_pixels,\n        lineWidthMinPixels=line_width_min_pixels,\n        stroked=stroked,\n        filled=filled,\n        pickable=pickable,\n        opacity=opacity,\n        **kwargs,\n    )\n\n    self._deck_layers = {\n        **self._deck_layers,\n        layer_id: {\"type\": \"ScatterplotLayer\", \"id\": layer_id},\n    }\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.deckgl.DeckGLMap.add_scenegraph_layer","title":"<code>add_scenegraph_layer(self, data, scenegraph, name=None, get_position='coordinates', get_color=None, get_orientation=None, get_scale=None, get_translation=None, size_scale=1, size_min_pixels=0, size_max_pixels=10000, pickable=True, opacity=1.0, **kwargs)</code>","text":"<p>Add a scenegraph layer for glTF model visualization.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>Array of data objects with position coordinates.</p> required <code>scenegraph</code> <code>str</code> <p>URL to glTF/GLB model file.</p> required <code>name</code> <code>Optional[str]</code> <p>Layer ID.</p> <code>None</code> <code>get_position</code> <code>Union[str, Callable]</code> <p>Accessor for model position [lng, lat, z].</p> <code>'coordinates'</code> <code>get_color</code> <code>Union[List[int], str, Callable]</code> <p>Accessor for model tint color [r, g, b, a].</p> <code>None</code> <code>get_orientation</code> <code>Union[str, Callable]</code> <p>Accessor for model orientation [pitch, yaw, roll].</p> <code>None</code> <code>get_scale</code> <code>Union[str, Callable]</code> <p>Accessor for model scale [x, y, z].</p> <code>None</code> <code>get_translation</code> <code>Union[str, Callable]</code> <p>Accessor for model translation [x, y, z].</p> <code>None</code> <code>size_scale</code> <code>float</code> <p>Global size multiplier.</p> <code>1</code> <code>size_min_pixels</code> <code>float</code> <p>Minimum model size in pixels.</p> <code>0</code> <code>size_max_pixels</code> <code>float</code> <p>Maximum model size in pixels.</p> <code>10000</code> <code>pickable</code> <code>bool</code> <p>Whether layer responds to hover/click.</p> <code>True</code> <code>opacity</code> <code>float</code> <p>Layer opacity (0-1).</p> <code>1.0</code> <code>**kwargs</code> <p>Additional ScenegraphLayer props.</p> <code>{}</code> Source code in <code>anymap_ts/deckgl.py</code> <pre><code>def add_scenegraph_layer(\n    self,\n    data: Any,\n    scenegraph: str,\n    name: Optional[str] = None,\n    get_position: Union[str, Callable] = \"coordinates\",\n    get_color: Union[List[int], str, Callable] = None,\n    get_orientation: Union[str, Callable] = None,\n    get_scale: Union[str, Callable] = None,\n    get_translation: Union[str, Callable] = None,\n    size_scale: float = 1,\n    size_min_pixels: float = 0,\n    size_max_pixels: float = 10000,\n    pickable: bool = True,\n    opacity: float = 1.0,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a scenegraph layer for glTF model visualization.\n\n    Args:\n        data: Array of data objects with position coordinates.\n        scenegraph: URL to glTF/GLB model file.\n        name: Layer ID.\n        get_position: Accessor for model position [lng, lat, z].\n        get_color: Accessor for model tint color [r, g, b, a].\n        get_orientation: Accessor for model orientation [pitch, yaw, roll].\n        get_scale: Accessor for model scale [x, y, z].\n        get_translation: Accessor for model translation [x, y, z].\n        size_scale: Global size multiplier.\n        size_min_pixels: Minimum model size in pixels.\n        size_max_pixels: Maximum model size in pixels.\n        pickable: Whether layer responds to hover/click.\n        opacity: Layer opacity (0-1).\n        **kwargs: Additional ScenegraphLayer props.\n    \"\"\"\n    layer_id = name or f\"scenegraph-{len(self._deck_layers)}\"\n    processed_data = self._process_deck_data(data)\n\n    layer_kwargs = {\n        \"id\": layer_id,\n        \"data\": processed_data,\n        \"scenegraph\": scenegraph,\n        \"getPosition\": get_position,\n        \"getColor\": get_color or [255, 255, 255, 255],\n        \"sizeScale\": size_scale,\n        \"sizeMinPixels\": size_min_pixels,\n        \"sizeMaxPixels\": size_max_pixels,\n        \"pickable\": pickable,\n        \"opacity\": opacity,\n    }\n\n    if get_orientation:\n        layer_kwargs[\"getOrientation\"] = get_orientation\n    if get_scale:\n        layer_kwargs[\"getScale\"] = get_scale\n    if get_translation:\n        layer_kwargs[\"getTranslation\"] = get_translation\n\n    layer_kwargs.update(kwargs)\n    self.call_js_method(\"addScenegraphLayer\", **layer_kwargs)\n\n    self._deck_layers = {\n        **self._deck_layers,\n        layer_id: {\"type\": \"ScenegraphLayer\", \"id\": layer_id},\n    }\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.deckgl.DeckGLMap.add_screen_grid_layer","title":"<code>add_screen_grid_layer(self, data, name=None, get_position='coordinates', get_weight=1, cell_size_pixels=50, color_range=None, pickable=True, opacity=0.8, **kwargs)</code>","text":"<p>Add a screen grid layer for screen-space grid aggregation.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>Array of data objects with position coordinates.</p> required <code>name</code> <code>Optional[str]</code> <p>Layer ID.</p> <code>None</code> <code>get_position</code> <code>Union[str, Callable]</code> <p>Accessor for point position [lng, lat].</p> <code>'coordinates'</code> <code>get_weight</code> <code>Union[float, str, Callable]</code> <p>Accessor for point weight.</p> <code>1</code> <code>cell_size_pixels</code> <code>float</code> <p>Grid cell size in pixels.</p> <code>50</code> <code>color_range</code> <code>Optional[List[List[int]]]</code> <p>Color gradient [[r, g, b, a], ...].</p> <code>None</code> <code>pickable</code> <code>bool</code> <p>Whether layer responds to hover/click.</p> <code>True</code> <code>opacity</code> <code>float</code> <p>Layer opacity.</p> <code>0.8</code> <code>**kwargs</code> <p>Additional layer props.</p> <code>{}</code> Source code in <code>anymap_ts/deckgl.py</code> <pre><code>def add_screen_grid_layer(\n    self,\n    data: Any,\n    name: Optional[str] = None,\n    get_position: Union[str, Callable] = \"coordinates\",\n    get_weight: Union[float, str, Callable] = 1,\n    cell_size_pixels: float = 50,\n    color_range: Optional[List[List[int]]] = None,\n    pickable: bool = True,\n    opacity: float = 0.8,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a screen grid layer for screen-space grid aggregation.\n\n    Args:\n        data: Array of data objects with position coordinates.\n        name: Layer ID.\n        get_position: Accessor for point position [lng, lat].\n        get_weight: Accessor for point weight.\n        cell_size_pixels: Grid cell size in pixels.\n        color_range: Color gradient [[r, g, b, a], ...].\n        pickable: Whether layer responds to hover/click.\n        opacity: Layer opacity.\n        **kwargs: Additional layer props.\n    \"\"\"\n    layer_id = name or f\"screengrid-{len(self._deck_layers)}\"\n    processed_data = self._process_deck_data(data)\n\n    default_color_range = [\n        [255, 255, 178, 25],\n        [254, 217, 118, 85],\n        [254, 178, 76, 127],\n        [253, 141, 60, 170],\n        [240, 59, 32, 212],\n        [189, 0, 38, 255],\n    ]\n\n    self.call_js_method(\n        \"addScreenGridLayer\",\n        id=layer_id,\n        data=processed_data,\n        getPosition=get_position,\n        getWeight=get_weight,\n        cellSizePixels=cell_size_pixels,\n        colorRange=color_range or default_color_range,\n        pickable=pickable,\n        opacity=opacity,\n        **kwargs,\n    )\n\n    self._deck_layers = {\n        **self._deck_layers,\n        layer_id: {\"type\": \"ScreenGridLayer\", \"id\": layer_id},\n    }\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.deckgl.DeckGLMap.add_simple_mesh_layer","title":"<code>add_simple_mesh_layer(self, data, mesh, name=None, texture=None, get_position='coordinates', get_color=None, get_orientation=None, get_scale=None, get_translation=None, size_scale=1, wireframe=False, pickable=True, opacity=1.0, **kwargs)</code>","text":"<p>Add a simple mesh layer for 3D mesh visualization.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>Array of data objects with position coordinates.</p> required <code>mesh</code> <code>str</code> <p>URL to OBJ/glTF mesh file.</p> required <code>name</code> <code>Optional[str]</code> <p>Layer ID.</p> <code>None</code> <code>texture</code> <code>Optional[str]</code> <p>URL to texture image.</p> <code>None</code> <code>get_position</code> <code>Union[str, Callable]</code> <p>Accessor for mesh position [lng, lat, z].</p> <code>'coordinates'</code> <code>get_color</code> <code>Union[List[int], str, Callable]</code> <p>Accessor for mesh color [r, g, b, a].</p> <code>None</code> <code>get_orientation</code> <code>Union[str, Callable]</code> <p>Accessor for mesh orientation [pitch, yaw, roll].</p> <code>None</code> <code>get_scale</code> <code>Union[str, Callable]</code> <p>Accessor for mesh scale [x, y, z].</p> <code>None</code> <code>get_translation</code> <code>Union[str, Callable]</code> <p>Accessor for mesh translation [x, y, z].</p> <code>None</code> <code>size_scale</code> <code>float</code> <p>Global size multiplier.</p> <code>1</code> <code>wireframe</code> <code>bool</code> <p>Whether to render as wireframe.</p> <code>False</code> <code>pickable</code> <code>bool</code> <p>Whether layer responds to hover/click.</p> <code>True</code> <code>opacity</code> <code>float</code> <p>Layer opacity (0-1).</p> <code>1.0</code> <code>**kwargs</code> <p>Additional SimpleMeshLayer props.</p> <code>{}</code> Source code in <code>anymap_ts/deckgl.py</code> <pre><code>def add_simple_mesh_layer(\n    self,\n    data: Any,\n    mesh: str,\n    name: Optional[str] = None,\n    texture: Optional[str] = None,\n    get_position: Union[str, Callable] = \"coordinates\",\n    get_color: Union[List[int], str, Callable] = None,\n    get_orientation: Union[str, Callable] = None,\n    get_scale: Union[str, Callable] = None,\n    get_translation: Union[str, Callable] = None,\n    size_scale: float = 1,\n    wireframe: bool = False,\n    pickable: bool = True,\n    opacity: float = 1.0,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a simple mesh layer for 3D mesh visualization.\n\n    Args:\n        data: Array of data objects with position coordinates.\n        mesh: URL to OBJ/glTF mesh file.\n        name: Layer ID.\n        texture: URL to texture image.\n        get_position: Accessor for mesh position [lng, lat, z].\n        get_color: Accessor for mesh color [r, g, b, a].\n        get_orientation: Accessor for mesh orientation [pitch, yaw, roll].\n        get_scale: Accessor for mesh scale [x, y, z].\n        get_translation: Accessor for mesh translation [x, y, z].\n        size_scale: Global size multiplier.\n        wireframe: Whether to render as wireframe.\n        pickable: Whether layer responds to hover/click.\n        opacity: Layer opacity (0-1).\n        **kwargs: Additional SimpleMeshLayer props.\n    \"\"\"\n    layer_id = name or f\"simplemesh-{len(self._deck_layers)}\"\n    processed_data = self._process_deck_data(data)\n\n    layer_kwargs = {\n        \"id\": layer_id,\n        \"data\": processed_data,\n        \"mesh\": mesh,\n        \"getPosition\": get_position,\n        \"getColor\": get_color or [255, 255, 255, 255],\n        \"sizeScale\": size_scale,\n        \"wireframe\": wireframe,\n        \"pickable\": pickable,\n        \"opacity\": opacity,\n    }\n\n    if texture:\n        layer_kwargs[\"texture\"] = texture\n    if get_orientation:\n        layer_kwargs[\"getOrientation\"] = get_orientation\n    if get_scale:\n        layer_kwargs[\"getScale\"] = get_scale\n    if get_translation:\n        layer_kwargs[\"getTranslation\"] = get_translation\n\n    layer_kwargs.update(kwargs)\n    self.call_js_method(\"addSimpleMeshLayer\", **layer_kwargs)\n\n    self._deck_layers = {\n        **self._deck_layers,\n        layer_id: {\"type\": \"SimpleMeshLayer\", \"id\": layer_id},\n    }\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.deckgl.DeckGLMap.add_solid_polygon_layer","title":"<code>add_solid_polygon_layer(self, data, name=None, get_polygon='polygon', get_fill_color=None, get_line_color=None, get_elevation=0, filled=True, extruded=False, wireframe=False, elevation_scale=1, pickable=True, opacity=0.8, **kwargs)</code>","text":"<p>Add a solid polygon layer for filled polygon visualization.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>Array of data objects with polygon coordinates.</p> required <code>name</code> <code>Optional[str]</code> <p>Layer ID.</p> <code>None</code> <code>get_polygon</code> <code>Union[str, Callable]</code> <p>Accessor for polygon coordinates.</p> <code>'polygon'</code> <code>get_fill_color</code> <code>Union[List[int], str, Callable]</code> <p>Accessor for fill color [r, g, b, a].</p> <code>None</code> <code>get_line_color</code> <code>Union[List[int], str, Callable]</code> <p>Accessor for stroke color [r, g, b, a].</p> <code>None</code> <code>get_elevation</code> <code>Union[float, str, Callable]</code> <p>Accessor for 3D extrusion height.</p> <code>0</code> <code>filled</code> <code>bool</code> <p>Whether to fill polygons.</p> <code>True</code> <code>extruded</code> <code>bool</code> <p>Whether to render as 3D polygons.</p> <code>False</code> <code>wireframe</code> <code>bool</code> <p>Whether to render wireframe.</p> <code>False</code> <code>elevation_scale</code> <code>float</code> <p>Elevation multiplier.</p> <code>1</code> <code>pickable</code> <code>bool</code> <p>Whether layer responds to hover/click.</p> <code>True</code> <code>opacity</code> <code>float</code> <p>Layer opacity.</p> <code>0.8</code> <code>**kwargs</code> <p>Additional SolidPolygonLayer props.</p> <code>{}</code> Source code in <code>anymap_ts/deckgl.py</code> <pre><code>def add_solid_polygon_layer(\n    self,\n    data: Any,\n    name: Optional[str] = None,\n    get_polygon: Union[str, Callable] = \"polygon\",\n    get_fill_color: Union[List[int], str, Callable] = None,\n    get_line_color: Union[List[int], str, Callable] = None,\n    get_elevation: Union[float, str, Callable] = 0,\n    filled: bool = True,\n    extruded: bool = False,\n    wireframe: bool = False,\n    elevation_scale: float = 1,\n    pickable: bool = True,\n    opacity: float = 0.8,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a solid polygon layer for filled polygon visualization.\n\n    Args:\n        data: Array of data objects with polygon coordinates.\n        name: Layer ID.\n        get_polygon: Accessor for polygon coordinates.\n        get_fill_color: Accessor for fill color [r, g, b, a].\n        get_line_color: Accessor for stroke color [r, g, b, a].\n        get_elevation: Accessor for 3D extrusion height.\n        filled: Whether to fill polygons.\n        extruded: Whether to render as 3D polygons.\n        wireframe: Whether to render wireframe.\n        elevation_scale: Elevation multiplier.\n        pickable: Whether layer responds to hover/click.\n        opacity: Layer opacity.\n        **kwargs: Additional SolidPolygonLayer props.\n    \"\"\"\n    layer_id = name or f\"solidpolygon-{len(self._deck_layers)}\"\n    processed_data = self._process_deck_data(data)\n\n    self.call_js_method(\n        \"addSolidPolygonLayer\",\n        id=layer_id,\n        data=processed_data,\n        getPolygon=get_polygon,\n        getFillColor=get_fill_color or [51, 136, 255, 128],\n        getLineColor=get_line_color or [0, 0, 0, 255],\n        getElevation=get_elevation,\n        filled=filled,\n        extruded=extruded,\n        wireframe=wireframe,\n        elevationScale=elevation_scale,\n        pickable=pickable,\n        opacity=opacity,\n        **kwargs,\n    )\n\n    self._deck_layers = {\n        **self._deck_layers,\n        layer_id: {\"type\": \"SolidPolygonLayer\", \"id\": layer_id},\n    }\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.deckgl.DeckGLMap.add_terrain_layer","title":"<code>add_terrain_layer(self, elevation_data, name=None, texture=None, mesh_max_error=4.0, bounds=None, elevation_decoder=None, pickable=False, visible=True, opacity=1.0, wireframe=False, **kwargs)</code>","text":"<p>Add a terrain layer for 3D terrain visualization.</p> <p>Parameters:</p> Name Type Description Default <code>elevation_data</code> <code>Union[str, List[str]]</code> <p>URL to elevation tiles (e.g., Mapbox terrain).</p> required <code>name</code> <code>Optional[str]</code> <p>Layer ID.</p> <code>None</code> <code>texture</code> <code>Optional[str]</code> <p>URL to texture tiles for terrain surface.</p> <code>None</code> <code>mesh_max_error</code> <code>float</code> <p>Maximum mesh error in meters.</p> <code>4.0</code> <code>bounds</code> <code>Optional[List[float]]</code> <p>Bounding box [west, south, east, north].</p> <code>None</code> <code>elevation_decoder</code> <code>Optional[Dict]</code> <p>Decoder for elevation data format.</p> <code>None</code> <code>pickable</code> <code>bool</code> <p>Whether layer responds to hover/click.</p> <code>False</code> <code>visible</code> <code>bool</code> <p>Whether layer is visible.</p> <code>True</code> <code>opacity</code> <code>float</code> <p>Layer opacity (0-1).</p> <code>1.0</code> <code>wireframe</code> <code>bool</code> <p>Whether to render as wireframe.</p> <code>False</code> <code>**kwargs</code> <p>Additional TerrainLayer props.</p> <code>{}</code> Source code in <code>anymap_ts/deckgl.py</code> <pre><code>def add_terrain_layer(\n    self,\n    elevation_data: Union[str, List[str]],\n    name: Optional[str] = None,\n    texture: Optional[str] = None,\n    mesh_max_error: float = 4.0,\n    bounds: Optional[List[float]] = None,\n    elevation_decoder: Optional[Dict] = None,\n    pickable: bool = False,\n    visible: bool = True,\n    opacity: float = 1.0,\n    wireframe: bool = False,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a terrain layer for 3D terrain visualization.\n\n    Args:\n        elevation_data: URL to elevation tiles (e.g., Mapbox terrain).\n        name: Layer ID.\n        texture: URL to texture tiles for terrain surface.\n        mesh_max_error: Maximum mesh error in meters.\n        bounds: Bounding box [west, south, east, north].\n        elevation_decoder: Decoder for elevation data format.\n        pickable: Whether layer responds to hover/click.\n        visible: Whether layer is visible.\n        opacity: Layer opacity (0-1).\n        wireframe: Whether to render as wireframe.\n        **kwargs: Additional TerrainLayer props.\n    \"\"\"\n    layer_id = name or f\"terrain-{len(self._deck_layers)}\"\n\n    default_decoder = {\n        \"rScaler\": 256,\n        \"gScaler\": 1,\n        \"bScaler\": 1 / 256,\n        \"offset\": -32768,\n    }\n\n    self.call_js_method(\n        \"addTerrainLayer\",\n        id=layer_id,\n        elevationData=elevation_data,\n        texture=texture,\n        meshMaxError=mesh_max_error,\n        bounds=bounds,\n        elevationDecoder=elevation_decoder or default_decoder,\n        pickable=pickable,\n        visible=visible,\n        opacity=opacity,\n        wireframe=wireframe,\n        **kwargs,\n    )\n\n    self._deck_layers = {\n        **self._deck_layers,\n        layer_id: {\"type\": \"TerrainLayer\", \"id\": layer_id},\n    }\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.deckgl.DeckGLMap.add_text_layer","title":"<code>add_text_layer(self, data, name=None, get_position='coordinates', get_text='text', get_size=12, get_color=None, get_angle=0, text_anchor='middle', alignment_baseline='center', pickable=True, opacity=1, **kwargs)</code>","text":"<p>Add a text layer for label visualization.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>Array of data objects with position and text.</p> required <code>name</code> <code>Optional[str]</code> <p>Layer ID.</p> <code>None</code> <code>get_position</code> <code>Union[str, Callable]</code> <p>Accessor for text position [lng, lat].</p> <code>'coordinates'</code> <code>get_text</code> <code>Union[str, Callable]</code> <p>Accessor for text content.</p> <code>'text'</code> <code>get_size</code> <code>Union[float, str, Callable]</code> <p>Accessor for text size.</p> <code>12</code> <code>get_color</code> <code>Union[List[int], str, Callable]</code> <p>Accessor for text color [r, g, b, a].</p> <code>None</code> <code>get_angle</code> <code>Union[float, str, Callable]</code> <p>Accessor for text rotation in degrees.</p> <code>0</code> <code>text_anchor</code> <code>str</code> <p>Horizontal alignment ('start', 'middle', 'end').</p> <code>'middle'</code> <code>alignment_baseline</code> <code>str</code> <p>Vertical alignment ('top', 'center', 'bottom').</p> <code>'center'</code> <code>pickable</code> <code>bool</code> <p>Whether layer responds to hover/click.</p> <code>True</code> <code>opacity</code> <code>float</code> <p>Layer opacity.</p> <code>1</code> <code>**kwargs</code> <p>Additional layer props.</p> <code>{}</code> Source code in <code>anymap_ts/deckgl.py</code> <pre><code>def add_text_layer(\n    self,\n    data: Any,\n    name: Optional[str] = None,\n    get_position: Union[str, Callable] = \"coordinates\",\n    get_text: Union[str, Callable] = \"text\",\n    get_size: Union[float, str, Callable] = 12,\n    get_color: Union[List[int], str, Callable] = None,\n    get_angle: Union[float, str, Callable] = 0,\n    text_anchor: str = \"middle\",\n    alignment_baseline: str = \"center\",\n    pickable: bool = True,\n    opacity: float = 1,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a text layer for label visualization.\n\n    Args:\n        data: Array of data objects with position and text.\n        name: Layer ID.\n        get_position: Accessor for text position [lng, lat].\n        get_text: Accessor for text content.\n        get_size: Accessor for text size.\n        get_color: Accessor for text color [r, g, b, a].\n        get_angle: Accessor for text rotation in degrees.\n        text_anchor: Horizontal alignment ('start', 'middle', 'end').\n        alignment_baseline: Vertical alignment ('top', 'center', 'bottom').\n        pickable: Whether layer responds to hover/click.\n        opacity: Layer opacity.\n        **kwargs: Additional layer props.\n    \"\"\"\n    layer_id = name or f\"text-{len(self._deck_layers)}\"\n    processed_data = self._process_deck_data(data)\n\n    self.call_js_method(\n        \"addTextLayer\",\n        id=layer_id,\n        data=processed_data,\n        getPosition=get_position,\n        getText=get_text,\n        getSize=get_size,\n        getColor=get_color or [0, 0, 0, 255],\n        getAngle=get_angle,\n        getTextAnchor=text_anchor,\n        getAlignmentBaseline=alignment_baseline,\n        pickable=pickable,\n        opacity=opacity,\n        **kwargs,\n    )\n\n    self._deck_layers = {\n        **self._deck_layers,\n        layer_id: {\"type\": \"TextLayer\", \"id\": layer_id},\n    }\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.deckgl.DeckGLMap.add_tile3d_layer","title":"<code>add_tile3d_layer(self, data, name=None, point_size=1, pickable=True, visible=True, opacity=1.0, load_options=None, **kwargs)</code>","text":"<p>Add a 3D Tiles layer for 3D building/terrain visualization.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>str</code> <p>URL to tileset.json.</p> required <code>name</code> <code>Optional[str]</code> <p>Layer ID.</p> <code>None</code> <code>point_size</code> <code>float</code> <p>Point size for point cloud tiles.</p> <code>1</code> <code>pickable</code> <code>bool</code> <p>Whether layer responds to hover/click.</p> <code>True</code> <code>visible</code> <code>bool</code> <p>Whether layer is visible.</p> <code>True</code> <code>opacity</code> <code>float</code> <p>Layer opacity (0-1).</p> <code>1.0</code> <code>load_options</code> <code>Optional[Dict]</code> <p>Loader options for tile loading.</p> <code>None</code> <code>**kwargs</code> <p>Additional Tile3DLayer props.</p> <code>{}</code> Source code in <code>anymap_ts/deckgl.py</code> <pre><code>def add_tile3d_layer(\n    self,\n    data: str,\n    name: Optional[str] = None,\n    point_size: float = 1,\n    pickable: bool = True,\n    visible: bool = True,\n    opacity: float = 1.0,\n    load_options: Optional[Dict] = None,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a 3D Tiles layer for 3D building/terrain visualization.\n\n    Args:\n        data: URL to tileset.json.\n        name: Layer ID.\n        point_size: Point size for point cloud tiles.\n        pickable: Whether layer responds to hover/click.\n        visible: Whether layer is visible.\n        opacity: Layer opacity (0-1).\n        load_options: Loader options for tile loading.\n        **kwargs: Additional Tile3DLayer props.\n    \"\"\"\n    layer_id = name or f\"tile3d-{len(self._deck_layers)}\"\n\n    self.call_js_method(\n        \"addTile3DLayer\",\n        id=layer_id,\n        data=data,\n        pointSize=point_size,\n        pickable=pickable,\n        visible=visible,\n        opacity=opacity,\n        loadOptions=load_options or {},\n        **kwargs,\n    )\n\n    self._deck_layers = {\n        **self._deck_layers,\n        layer_id: {\"type\": \"Tile3DLayer\", \"id\": layer_id},\n    }\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.deckgl.DeckGLMap.add_tile_layer","title":"<code>add_tile_layer(self, data, name=None, min_zoom=0, max_zoom=19, tile_size=256, pickable=False, visible=True, opacity=1.0, **kwargs)</code>","text":"<p>Add a tile layer for raster tile visualization.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Union[str, List[str]]</code> <p>Tile URL template with {z}/{x}/{y} placeholders.</p> required <code>name</code> <code>Optional[str]</code> <p>Layer ID.</p> <code>None</code> <code>min_zoom</code> <code>int</code> <p>Minimum zoom level.</p> <code>0</code> <code>max_zoom</code> <code>int</code> <p>Maximum zoom level.</p> <code>19</code> <code>tile_size</code> <code>int</code> <p>Tile size in pixels.</p> <code>256</code> <code>pickable</code> <code>bool</code> <p>Whether layer responds to hover/click.</p> <code>False</code> <code>visible</code> <code>bool</code> <p>Whether layer is visible.</p> <code>True</code> <code>opacity</code> <code>float</code> <p>Layer opacity (0-1).</p> <code>1.0</code> <code>**kwargs</code> <p>Additional TileLayer props.</p> <code>{}</code> Source code in <code>anymap_ts/deckgl.py</code> <pre><code>def add_tile_layer(\n    self,\n    data: Union[str, List[str]],\n    name: Optional[str] = None,\n    min_zoom: int = 0,\n    max_zoom: int = 19,\n    tile_size: int = 256,\n    pickable: bool = False,\n    visible: bool = True,\n    opacity: float = 1.0,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a tile layer for raster tile visualization.\n\n    Args:\n        data: Tile URL template with {z}/{x}/{y} placeholders.\n        name: Layer ID.\n        min_zoom: Minimum zoom level.\n        max_zoom: Maximum zoom level.\n        tile_size: Tile size in pixels.\n        pickable: Whether layer responds to hover/click.\n        visible: Whether layer is visible.\n        opacity: Layer opacity (0-1).\n        **kwargs: Additional TileLayer props.\n    \"\"\"\n    layer_id = name or f\"tile-{len(self._deck_layers)}\"\n\n    self.call_js_method(\n        \"addTileLayer\",\n        id=layer_id,\n        data=data,\n        minZoom=min_zoom,\n        maxZoom=max_zoom,\n        tileSize=tile_size,\n        pickable=pickable,\n        visible=visible,\n        opacity=opacity,\n        **kwargs,\n    )\n\n    self._deck_layers = {\n        **self._deck_layers,\n        layer_id: {\"type\": \"TileLayer\", \"id\": layer_id},\n    }\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.deckgl.DeckGLMap.add_trips_layer","title":"<code>add_trips_layer(self, data, name=None, get_path='waypoints', get_timestamps='timestamps', get_color=None, width_min_pixels=2, trail_length=180, current_time=0, pickable=True, opacity=0.8, **kwargs)</code>","text":"<p>Add a trips layer for animated path visualization.</p> <p>The TripsLayer renders animated paths showing movement over time, ideal for visualizing vehicle routes, migration patterns, or any time-based trajectory data.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>Array of trip objects with waypoints and timestamps.</p> required <code>name</code> <code>Optional[str]</code> <p>Layer ID. If None, auto-generated.</p> <code>None</code> <code>get_path</code> <code>Union[str, Callable]</code> <p>Accessor for waypoint coordinates [[lng, lat], ...].</p> <code>'waypoints'</code> <code>get_timestamps</code> <code>Union[str, Callable]</code> <p>Accessor for timestamps at each waypoint.</p> <code>'timestamps'</code> <code>get_color</code> <code>Union[List[int], str, Callable]</code> <p>Accessor for trip color [r, g, b] or [r, g, b, a].</p> <code>None</code> <code>width_min_pixels</code> <code>float</code> <p>Minimum trail width in pixels.</p> <code>2</code> <code>trail_length</code> <code>float</code> <p>Trail length in timestamp units.</p> <code>180</code> <code>current_time</code> <code>float</code> <p>Current animation time.</p> <code>0</code> <code>pickable</code> <code>bool</code> <p>Whether layer responds to hover/click.</p> <code>True</code> <code>opacity</code> <code>float</code> <p>Layer opacity (0-1).</p> <code>0.8</code> <code>**kwargs</code> <p>Additional TripsLayer props.</p> <code>{}</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; m = DeckGLMap()\n&gt;&gt;&gt; trips = [\n...     {\n...         \"waypoints\": [[-122.4, 37.8], [-122.5, 37.7], [-122.6, 37.8]],\n...         \"timestamps\": [0, 50, 100]\n...     }\n... ]\n&gt;&gt;&gt; m.add_trips_layer(\n...     data=trips,\n...     trail_length=180,\n...     current_time=50,\n... )\n</code></pre> Source code in <code>anymap_ts/deckgl.py</code> <pre><code>def add_trips_layer(\n    self,\n    data: Any,\n    name: Optional[str] = None,\n    get_path: Union[str, Callable] = \"waypoints\",\n    get_timestamps: Union[str, Callable] = \"timestamps\",\n    get_color: Union[List[int], str, Callable] = None,\n    width_min_pixels: float = 2,\n    trail_length: float = 180,\n    current_time: float = 0,\n    pickable: bool = True,\n    opacity: float = 0.8,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a trips layer for animated path visualization.\n\n    The TripsLayer renders animated paths showing movement over time,\n    ideal for visualizing vehicle routes, migration patterns, or any\n    time-based trajectory data.\n\n    Args:\n        data: Array of trip objects with waypoints and timestamps.\n        name: Layer ID. If None, auto-generated.\n        get_path: Accessor for waypoint coordinates [[lng, lat], ...].\n        get_timestamps: Accessor for timestamps at each waypoint.\n        get_color: Accessor for trip color [r, g, b] or [r, g, b, a].\n        width_min_pixels: Minimum trail width in pixels.\n        trail_length: Trail length in timestamp units.\n        current_time: Current animation time.\n        pickable: Whether layer responds to hover/click.\n        opacity: Layer opacity (0-1).\n        **kwargs: Additional TripsLayer props.\n\n    Example:\n        &gt;&gt;&gt; m = DeckGLMap()\n        &gt;&gt;&gt; trips = [\n        ...     {\n        ...         \"waypoints\": [[-122.4, 37.8], [-122.5, 37.7], [-122.6, 37.8]],\n        ...         \"timestamps\": [0, 50, 100]\n        ...     }\n        ... ]\n        &gt;&gt;&gt; m.add_trips_layer(\n        ...     data=trips,\n        ...     trail_length=180,\n        ...     current_time=50,\n        ... )\n    \"\"\"\n    layer_id = name or f\"trips-{len(self._deck_layers)}\"\n    processed_data = self._process_deck_data(data)\n\n    self.call_js_method(\n        \"addTripsLayer\",\n        id=layer_id,\n        data=processed_data,\n        getPath=get_path,\n        getTimestamps=get_timestamps,\n        getColor=get_color or [253, 128, 93],\n        widthMinPixels=width_min_pixels,\n        trailLength=trail_length,\n        currentTime=current_time,\n        pickable=pickable,\n        opacity=opacity,\n        **kwargs,\n    )\n\n    self._deck_layers = {\n        **self._deck_layers,\n        layer_id: {\"type\": \"TripsLayer\", \"id\": layer_id},\n    }\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.deckgl.DeckGLMap.add_wms_layer","title":"<code>add_wms_layer(self, data, name=None, service_type='wms', layers=None, srs=None, pickable=False, visible=True, opacity=1.0, **kwargs)</code>","text":"<p>Add a WMS layer for OGC Web Map Service visualization.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>str</code> <p>WMS base URL.</p> required <code>name</code> <code>Optional[str]</code> <p>Layer ID.</p> <code>None</code> <code>service_type</code> <code>str</code> <p>Service type ('wms' or 'template').</p> <code>'wms'</code> <code>layers</code> <code>Optional[List[str]]</code> <p>WMS layer names to request.</p> <code>None</code> <code>srs</code> <code>Optional[str]</code> <p>Spatial reference system (e.g., 'EPSG:4326').</p> <code>None</code> <code>pickable</code> <code>bool</code> <p>Whether layer responds to hover/click.</p> <code>False</code> <code>visible</code> <code>bool</code> <p>Whether layer is visible.</p> <code>True</code> <code>opacity</code> <code>float</code> <p>Layer opacity (0-1).</p> <code>1.0</code> <code>**kwargs</code> <p>Additional WMSLayer props.</p> <code>{}</code> Source code in <code>anymap_ts/deckgl.py</code> <pre><code>def add_wms_layer(\n    self,\n    data: str,\n    name: Optional[str] = None,\n    service_type: str = \"wms\",\n    layers: Optional[List[str]] = None,\n    srs: Optional[str] = None,\n    pickable: bool = False,\n    visible: bool = True,\n    opacity: float = 1.0,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a WMS layer for OGC Web Map Service visualization.\n\n    Args:\n        data: WMS base URL.\n        name: Layer ID.\n        service_type: Service type ('wms' or 'template').\n        layers: WMS layer names to request.\n        srs: Spatial reference system (e.g., 'EPSG:4326').\n        pickable: Whether layer responds to hover/click.\n        visible: Whether layer is visible.\n        opacity: Layer opacity (0-1).\n        **kwargs: Additional WMSLayer props.\n    \"\"\"\n    layer_id = name or f\"wms-{len(self._deck_layers)}\"\n\n    self.call_js_method(\n        \"addWMSLayer\",\n        id=layer_id,\n        data=data,\n        serviceType=service_type,\n        layers=layers,\n        srs=srs,\n        pickable=pickable,\n        visible=visible,\n        opacity=opacity,\n        **kwargs,\n    )\n\n    self._deck_layers = {\n        **self._deck_layers,\n        layer_id: {\"type\": \"WMSLayer\", \"id\": layer_id},\n    }\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.deckgl.DeckGLMap.remove_cog_layer","title":"<code>remove_cog_layer(self, layer_id)</code>","text":"<p>Remove a COG layer.</p> <p>Parameters:</p> Name Type Description Default <code>layer_id</code> <code>str</code> <p>Layer identifier to remove.</p> required Source code in <code>anymap_ts/deckgl.py</code> <pre><code>def remove_cog_layer(self, layer_id: str) -&gt; None:\n    \"\"\"Remove a COG layer.\n\n    Args:\n        layer_id: Layer identifier to remove.\n    \"\"\"\n    self.remove_deck_layer(layer_id)\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.deckgl.DeckGLMap.remove_deck_layer","title":"<code>remove_deck_layer(self, layer_id)</code>","text":"<p>Remove a deck.gl layer.</p> <p>Parameters:</p> Name Type Description Default <code>layer_id</code> <code>str</code> <p>Layer identifier to remove.</p> required Source code in <code>anymap_ts/deckgl.py</code> <pre><code>def remove_deck_layer(self, layer_id: str) -&gt; None:\n    \"\"\"Remove a deck.gl layer.\n\n    Args:\n        layer_id: Layer identifier to remove.\n    \"\"\"\n    if layer_id in self._deck_layers:\n        layers = dict(self._deck_layers)\n        del layers[layer_id]\n        self._deck_layers = layers\n    self.call_js_method(\"removeDeckLayer\", layer_id)\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.deckgl.DeckGLMap.set_deck_layer_visibility","title":"<code>set_deck_layer_visibility(self, layer_id, visible)</code>","text":"<p>Set deck.gl layer visibility.</p> <p>Parameters:</p> Name Type Description Default <code>layer_id</code> <code>str</code> <p>Layer identifier.</p> required <code>visible</code> <code>bool</code> <p>Whether layer should be visible.</p> required Source code in <code>anymap_ts/deckgl.py</code> <pre><code>def set_deck_layer_visibility(self, layer_id: str, visible: bool) -&gt; None:\n    \"\"\"Set deck.gl layer visibility.\n\n    Args:\n        layer_id: Layer identifier.\n        visible: Whether layer should be visible.\n    \"\"\"\n    self.call_js_method(\"setDeckLayerVisibility\", layer_id, visible)\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.keplergl","title":"<code>keplergl</code>","text":"<p>KeplerGL map widget implementation.</p> <p>KeplerGL is loaded via CDN since it's React-based and requires complex setup. This implementation provides a Python wrapper with data management capabilities.</p>"},{"location":"anymap_ts/#anymap_ts.keplergl.KeplerGLMap","title":"<code> KeplerGLMap            (MapWidget)         </code>","text":"<p>Interactive map widget using KeplerGL.</p> <p>KeplerGL is a powerful data visualization tool built on top of deck.gl. This class provides a Python interface for adding data and configuring the KeplerGL visualization.</p> <p>Note: KeplerGL is loaded from CDN due to its React-based architecture.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from anymap_ts import KeplerGLMap\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; m = KeplerGLMap()\n&gt;&gt;&gt; df = pd.DataFrame({\n...     'lat': [37.7749, 37.8044],\n...     'lng': [-122.4194, -122.2712],\n...     'value': [100, 200]\n... })\n&gt;&gt;&gt; m.add_data(df, name='points')\n&gt;&gt;&gt; m\n</code></pre> Source code in <code>anymap_ts/keplergl.py</code> <pre><code>class KeplerGLMap(MapWidget):\n    \"\"\"Interactive map widget using KeplerGL.\n\n    KeplerGL is a powerful data visualization tool built on top of deck.gl.\n    This class provides a Python interface for adding data and configuring\n    the KeplerGL visualization.\n\n    Note: KeplerGL is loaded from CDN due to its React-based architecture.\n\n    Example:\n        &gt;&gt;&gt; from anymap_ts import KeplerGLMap\n        &gt;&gt;&gt; import pandas as pd\n        &gt;&gt;&gt; m = KeplerGLMap()\n        &gt;&gt;&gt; df = pd.DataFrame({\n        ...     'lat': [37.7749, 37.8044],\n        ...     'lng': [-122.4194, -122.2712],\n        ...     'value': [100, 200]\n        ... })\n        &gt;&gt;&gt; m.add_data(df, name='points')\n        &gt;&gt;&gt; m\n    \"\"\"\n\n    # ESM module for frontend\n    _esm = STATIC_DIR / \"keplergl.js\"\n\n    # KeplerGL-specific traits\n    config = traitlets.Dict({}).tag(sync=True)\n    datasets = traitlets.Dict({}).tag(sync=True)\n    read_only = traitlets.Bool(False).tag(sync=True)\n    show_data_table = traitlets.Bool(True).tag(sync=True)\n\n    # Mapbox token for basemaps\n    mapbox_token = traitlets.Unicode(\"\").tag(sync=True)\n\n    def __init__(\n        self,\n        center: Tuple[float, float] = (-122.4, 37.8),\n        zoom: float = 10.0,\n        width: str = \"100%\",\n        height: str = \"600px\",\n        config: Optional[Dict] = None,\n        read_only: bool = False,\n        show_data_table: bool = True,\n        mapbox_token: Optional[str] = None,\n        **kwargs,\n    ):\n        \"\"\"Initialize a KeplerGL map.\n\n        Args:\n            center: Map center as (longitude, latitude).\n            zoom: Initial zoom level.\n            width: Widget width as CSS string.\n            height: Widget height as CSS string.\n            config: KeplerGL configuration dict.\n            read_only: Whether the UI is read-only.\n            show_data_table: Whether to show the data table panel.\n            mapbox_token: Mapbox access token for basemaps.\n            **kwargs: Additional widget arguments.\n        \"\"\"\n        import os\n\n        if mapbox_token is None:\n            mapbox_token = os.environ.get(\"MAPBOX_TOKEN\", \"\")\n\n        super().__init__(\n            center=list(center),\n            zoom=zoom,\n            width=width,\n            height=height,\n            config=config or {},\n            read_only=read_only,\n            show_data_table=show_data_table,\n            mapbox_token=mapbox_token,\n            **kwargs,\n        )\n        self.datasets = {}\n\n    # -------------------------------------------------------------------------\n    # Data Methods\n    # -------------------------------------------------------------------------\n\n    def add_data(\n        self,\n        data: Any,\n        name: Optional[str] = None,\n    ) -&gt; None:\n        \"\"\"Add data to the map.\n\n        Args:\n            data: Data to add (DataFrame, GeoDataFrame, dict, or file path).\n            name: Dataset name/label.\n        \"\"\"\n        dataset_id = name or f\"data_{uuid.uuid4().hex[:8]}\"\n        processed_data = self._process_data(data)\n\n        self.datasets = {\n            **self.datasets,\n            dataset_id: {\n                \"info\": {\n                    \"id\": dataset_id,\n                    \"label\": dataset_id,\n                },\n                \"data\": processed_data,\n            },\n        }\n\n        self.call_js_method(\n            \"addData\",\n            dataId=dataset_id,\n            data=processed_data,\n        )\n\n    def _process_data(self, data: Any) -&gt; Dict:\n        \"\"\"Process data into KeplerGL format.\n\n        Args:\n            data: Input data.\n\n        Returns:\n            Processed data dict with fields and rows.\n        \"\"\"\n        # Handle DataFrame\n        if hasattr(data, \"to_dict\"):\n            # Check if it's a GeoDataFrame\n            if hasattr(data, \"geometry\"):\n                # Convert to GeoJSON for geometry columns\n                geojson = json.loads(data.to_json())\n                return {\n                    \"type\": \"geojson\",\n                    \"data\": geojson,\n                }\n            else:\n                # Regular DataFrame\n                fields = []\n                for col in data.columns:\n                    dtype = str(data[col].dtype)\n                    if \"int\" in dtype:\n                        field_type = \"integer\"\n                    elif \"float\" in dtype:\n                        field_type = \"real\"\n                    elif \"datetime\" in dtype:\n                        field_type = \"timestamp\"\n                    elif \"bool\" in dtype:\n                        field_type = \"boolean\"\n                    else:\n                        field_type = \"string\"\n\n                    fields.append({\"name\": col, \"type\": field_type})\n\n                # Convert to list of lists\n                rows = data.values.tolist()\n\n                return {\n                    \"fields\": fields,\n                    \"rows\": rows,\n                }\n\n        # Handle dict (assume it's already GeoJSON or processed)\n        if isinstance(data, dict):\n            if \"type\" in data and data[\"type\"] in [\n                \"FeatureCollection\",\n                \"Feature\",\n                \"Point\",\n                \"LineString\",\n                \"Polygon\",\n                \"MultiPoint\",\n                \"MultiLineString\",\n                \"MultiPolygon\",\n            ]:\n                return {\"type\": \"geojson\", \"data\": data}\n            return data\n\n        # Handle file path\n        if isinstance(data, (str, Path)):\n            path = Path(data)\n            if path.exists():\n                if path.suffix.lower() in [\".geojson\", \".json\"]:\n                    with open(path) as f:\n                        geojson = json.load(f)\n                    return {\"type\": \"geojson\", \"data\": geojson}\n                elif path.suffix.lower() == \".csv\":\n                    try:\n                        import pandas as pd\n\n                        df = pd.read_csv(path)\n                        return self._process_data(df)\n                    except ImportError:\n                        raise ImportError(\n                            \"pandas is required to load CSV files. \"\n                            \"Install with: pip install pandas\"\n                        )\n\n        return data\n\n    def remove_data(self, name: str) -&gt; None:\n        \"\"\"Remove a dataset.\n\n        Args:\n            name: Dataset name to remove.\n        \"\"\"\n        if name in self.datasets:\n            datasets = dict(self.datasets)\n            del datasets[name]\n            self.datasets = datasets\n        self.call_js_method(\"removeData\", dataId=name)\n\n    # -------------------------------------------------------------------------\n    # Configuration Methods\n    # -------------------------------------------------------------------------\n\n    def set_config(self, config: Dict) -&gt; None:\n        \"\"\"Set the KeplerGL configuration.\n\n        Args:\n            config: Configuration dict.\n        \"\"\"\n        self.config = config\n        self.call_js_method(\"setConfig\", config=config)\n\n    def get_config(self) -&gt; Dict:\n        \"\"\"Get the current KeplerGL configuration.\n\n        Returns:\n            Configuration dict.\n        \"\"\"\n        return self.config\n\n    def save_config(self, filepath: Union[str, Path]) -&gt; None:\n        \"\"\"Save configuration to a JSON file.\n\n        Args:\n            filepath: Path to save the configuration.\n        \"\"\"\n        with open(filepath, \"w\") as f:\n            json.dump(self.config, f, indent=2)\n\n    def load_config(self, filepath: Union[str, Path]) -&gt; None:\n        \"\"\"Load configuration from a JSON file.\n\n        Args:\n            filepath: Path to the configuration file.\n        \"\"\"\n        with open(filepath) as f:\n            config = json.load(f)\n        self.set_config(config)\n\n    # -------------------------------------------------------------------------\n    # Filter Methods\n    # -------------------------------------------------------------------------\n\n    def add_filter(\n        self,\n        data_id: str,\n        field: str,\n        filter_type: str = \"range\",\n        value: Optional[Any] = None,\n    ) -&gt; None:\n        \"\"\"Add a filter to the visualization.\n\n        Args:\n            data_id: Dataset ID to filter.\n            field: Field name to filter on.\n            filter_type: Type of filter ('range', 'select', 'time').\n            value: Filter value(s).\n        \"\"\"\n        filter_config = {\n            \"dataId\": [data_id],\n            \"name\": [field],\n            \"type\": filter_type,\n        }\n        if value is not None:\n            filter_config[\"value\"] = value\n\n        self.call_js_method(\"addFilter\", filter=filter_config)\n\n    # -------------------------------------------------------------------------\n    # Layer Methods\n    # -------------------------------------------------------------------------\n\n    def add_layer(\n        self,\n        layer_type: str,\n        data_id: str,\n        columns: Dict[str, str],\n        label: Optional[str] = None,\n        color: Optional[List[int]] = None,\n        vis_config: Optional[Dict] = None,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a layer to the visualization.\n\n        Args:\n            layer_type: Layer type ('point', 'arc', 'line', 'hexagon', 'heatmap', etc.).\n            data_id: Dataset ID for the layer.\n            columns: Column mapping (e.g., {'lat': 'latitude', 'lng': 'longitude'}).\n            label: Layer label.\n            color: Layer color as [r, g, b].\n            vis_config: Visual configuration.\n            **kwargs: Additional layer options.\n        \"\"\"\n        layer_config = {\n            \"type\": layer_type,\n            \"config\": {\n                \"dataId\": data_id,\n                \"label\": label or f\"{layer_type}_layer\",\n                \"columns\": columns,\n                \"isVisible\": True,\n            },\n        }\n        if color:\n            layer_config[\"config\"][\"color\"] = color\n        if vis_config:\n            layer_config[\"config\"][\"visConfig\"] = vis_config\n\n        layer_config[\"config\"].update(kwargs)\n\n        self.call_js_method(\"addLayer\", layer=layer_config)\n\n    # -------------------------------------------------------------------------\n    # View Methods\n    # -------------------------------------------------------------------------\n\n    def fly_to(\n        self,\n        lng: float,\n        lat: float,\n        zoom: Optional[float] = None,\n    ) -&gt; None:\n        \"\"\"Fly to a location.\n\n        Args:\n            lng: Target longitude.\n            lat: Target latitude.\n            zoom: Target zoom level.\n        \"\"\"\n        self.center = [lng, lat]\n        if zoom is not None:\n            self.zoom = zoom\n        self.call_js_method(\"flyTo\", lng=lng, lat=lat, zoom=zoom or self.zoom)\n\n    # -------------------------------------------------------------------------\n    # HTML Export\n    # -------------------------------------------------------------------------\n\n    def _generate_html_template(self) -&gt; str:\n        \"\"\"Generate standalone HTML for KeplerGL.\"\"\"\n        template_path = Path(__file__).parent / \"templates\" / \"keplergl.html\"\n\n        if template_path.exists():\n            template = template_path.read_text(encoding=\"utf-8\")\n        else:\n            template = self._get_default_template()\n\n        state = {\n            \"center\": self.center,\n            \"zoom\": self.zoom,\n            \"config\": self.config,\n            \"datasets\": self.datasets,\n            \"read_only\": self.read_only,\n            \"mapbox_token\": self.mapbox_token,\n            \"width\": self.width,\n            \"height\": self.height,\n            \"js_calls\": self._js_calls,\n        }\n\n        template = template.replace(\"{{state}}\", json.dumps(state, indent=2))\n        return template\n\n    def _get_default_template(self) -&gt; str:\n        \"\"\"Get default HTML template.\"\"\"\n        return \"\"\"&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n    &lt;meta charset=\"utf-8\"&gt;\n    &lt;title&gt;KeplerGL Map&lt;/title&gt;\n    &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"&gt;\n    &lt;style&gt;\n        * { margin: 0; padding: 0; box-sizing: border-box; }\n        html, body { height: 100%; }\n        #app { position: absolute; top: 0; bottom: 0; width: 100%; }\n    &lt;/style&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;div id=\"app\"&gt;&lt;/div&gt;\n    &lt;script&gt;\n        const state = {{state}};\n        // KeplerGL requires React/Redux setup - simplified placeholder\n        document.getElementById('app').innerHTML = '&lt;p&gt;KeplerGL visualization requires full React setup. Use Jupyter widget for interactive visualization.&lt;/p&gt;';\n    &lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\"\"\"\n\n    def _repr_html_(self) -&gt; str:\n        \"\"\"Return HTML representation for Jupyter (uses iframe with CDN KeplerGL).\"\"\"\n        state = {\n            \"center\": self.center,\n            \"zoom\": self.zoom,\n            \"config\": self.config,\n            \"datasets\": self.datasets,\n            \"mapbox_token\": self.mapbox_token,\n        }\n\n        html = f\"\"\"\n        &lt;iframe\n            srcdoc='\n            &lt;!DOCTYPE html&gt;\n            &lt;html&gt;\n            &lt;head&gt;\n                &lt;meta charset=\"utf-8\"&gt;\n                &lt;script src=\"https://unpkg.com/react@16.8.4/umd/react.production.min.js\"&gt;&lt;/script&gt;\n                &lt;script src=\"https://unpkg.com/react-dom@16.8.4/umd/react-dom.production.min.js\"&gt;&lt;/script&gt;\n                &lt;script src=\"https://unpkg.com/kepler.gl@3.0.0/umd/keplergl.min.js\"&gt;&lt;/script&gt;\n                &lt;link href=\"https://unpkg.com/kepler.gl@3.0.0/umd/keplergl.min.css\" rel=\"stylesheet\" /&gt;\n                &lt;style&gt;\n                    body {{ margin: 0; padding: 0; overflow: hidden; }}\n                    #app {{ width: 100vw; height: 100vh; }}\n                &lt;/style&gt;\n            &lt;/head&gt;\n            &lt;body&gt;\n                &lt;div id=\"app\"&gt;&lt;/div&gt;\n                &lt;script&gt;\n                    const state = {json.dumps(state)};\n                    // KeplerGL requires complex React setup\n                    document.getElementById(\"app\").innerHTML = \"KeplerGL widget - use anywidget interface for full interactivity\";\n                &lt;/script&gt;\n            &lt;/body&gt;\n            &lt;/html&gt;\n            '\n            width=\"{self.width}\"\n            height=\"{self.height}\"\n            frameborder=\"0\"\n        &gt;&lt;/iframe&gt;\n        \"\"\"\n        return html\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.keplergl.KeplerGLMap.__init__","title":"<code>__init__(self, center=(-122.4, 37.8), zoom=10.0, width='100%', height='600px', config=None, read_only=False, show_data_table=True, mapbox_token=None, **kwargs)</code>  <code>special</code>","text":"<p>Initialize a KeplerGL map.</p> <p>Parameters:</p> Name Type Description Default <code>center</code> <code>Tuple[float, float]</code> <p>Map center as (longitude, latitude).</p> <code>(-122.4, 37.8)</code> <code>zoom</code> <code>float</code> <p>Initial zoom level.</p> <code>10.0</code> <code>width</code> <code>str</code> <p>Widget width as CSS string.</p> <code>'100%'</code> <code>height</code> <code>str</code> <p>Widget height as CSS string.</p> <code>'600px'</code> <code>config</code> <code>Optional[Dict]</code> <p>KeplerGL configuration dict.</p> <code>None</code> <code>read_only</code> <code>bool</code> <p>Whether the UI is read-only.</p> <code>False</code> <code>show_data_table</code> <code>bool</code> <p>Whether to show the data table panel.</p> <code>True</code> <code>mapbox_token</code> <code>Optional[str]</code> <p>Mapbox access token for basemaps.</p> <code>None</code> <code>**kwargs</code> <p>Additional widget arguments.</p> <code>{}</code> Source code in <code>anymap_ts/keplergl.py</code> <pre><code>def __init__(\n    self,\n    center: Tuple[float, float] = (-122.4, 37.8),\n    zoom: float = 10.0,\n    width: str = \"100%\",\n    height: str = \"600px\",\n    config: Optional[Dict] = None,\n    read_only: bool = False,\n    show_data_table: bool = True,\n    mapbox_token: Optional[str] = None,\n    **kwargs,\n):\n    \"\"\"Initialize a KeplerGL map.\n\n    Args:\n        center: Map center as (longitude, latitude).\n        zoom: Initial zoom level.\n        width: Widget width as CSS string.\n        height: Widget height as CSS string.\n        config: KeplerGL configuration dict.\n        read_only: Whether the UI is read-only.\n        show_data_table: Whether to show the data table panel.\n        mapbox_token: Mapbox access token for basemaps.\n        **kwargs: Additional widget arguments.\n    \"\"\"\n    import os\n\n    if mapbox_token is None:\n        mapbox_token = os.environ.get(\"MAPBOX_TOKEN\", \"\")\n\n    super().__init__(\n        center=list(center),\n        zoom=zoom,\n        width=width,\n        height=height,\n        config=config or {},\n        read_only=read_only,\n        show_data_table=show_data_table,\n        mapbox_token=mapbox_token,\n        **kwargs,\n    )\n    self.datasets = {}\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.keplergl.KeplerGLMap.add_data","title":"<code>add_data(self, data, name=None)</code>","text":"<p>Add data to the map.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>Data to add (DataFrame, GeoDataFrame, dict, or file path).</p> required <code>name</code> <code>Optional[str]</code> <p>Dataset name/label.</p> <code>None</code> Source code in <code>anymap_ts/keplergl.py</code> <pre><code>def add_data(\n    self,\n    data: Any,\n    name: Optional[str] = None,\n) -&gt; None:\n    \"\"\"Add data to the map.\n\n    Args:\n        data: Data to add (DataFrame, GeoDataFrame, dict, or file path).\n        name: Dataset name/label.\n    \"\"\"\n    dataset_id = name or f\"data_{uuid.uuid4().hex[:8]}\"\n    processed_data = self._process_data(data)\n\n    self.datasets = {\n        **self.datasets,\n        dataset_id: {\n            \"info\": {\n                \"id\": dataset_id,\n                \"label\": dataset_id,\n            },\n            \"data\": processed_data,\n        },\n    }\n\n    self.call_js_method(\n        \"addData\",\n        dataId=dataset_id,\n        data=processed_data,\n    )\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.keplergl.KeplerGLMap.add_filter","title":"<code>add_filter(self, data_id, field, filter_type='range', value=None)</code>","text":"<p>Add a filter to the visualization.</p> <p>Parameters:</p> Name Type Description Default <code>data_id</code> <code>str</code> <p>Dataset ID to filter.</p> required <code>field</code> <code>str</code> <p>Field name to filter on.</p> required <code>filter_type</code> <code>str</code> <p>Type of filter ('range', 'select', 'time').</p> <code>'range'</code> <code>value</code> <code>Optional[Any]</code> <p>Filter value(s).</p> <code>None</code> Source code in <code>anymap_ts/keplergl.py</code> <pre><code>def add_filter(\n    self,\n    data_id: str,\n    field: str,\n    filter_type: str = \"range\",\n    value: Optional[Any] = None,\n) -&gt; None:\n    \"\"\"Add a filter to the visualization.\n\n    Args:\n        data_id: Dataset ID to filter.\n        field: Field name to filter on.\n        filter_type: Type of filter ('range', 'select', 'time').\n        value: Filter value(s).\n    \"\"\"\n    filter_config = {\n        \"dataId\": [data_id],\n        \"name\": [field],\n        \"type\": filter_type,\n    }\n    if value is not None:\n        filter_config[\"value\"] = value\n\n    self.call_js_method(\"addFilter\", filter=filter_config)\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.keplergl.KeplerGLMap.add_layer","title":"<code>add_layer(self, layer_type, data_id, columns, label=None, color=None, vis_config=None, **kwargs)</code>","text":"<p>Add a layer to the visualization.</p> <p>Parameters:</p> Name Type Description Default <code>layer_type</code> <code>str</code> <p>Layer type ('point', 'arc', 'line', 'hexagon', 'heatmap', etc.).</p> required <code>data_id</code> <code>str</code> <p>Dataset ID for the layer.</p> required <code>columns</code> <code>Dict[str, str]</code> <p>Column mapping (e.g., {'lat': 'latitude', 'lng': 'longitude'}).</p> required <code>label</code> <code>Optional[str]</code> <p>Layer label.</p> <code>None</code> <code>color</code> <code>Optional[List[int]]</code> <p>Layer color as [r, g, b].</p> <code>None</code> <code>vis_config</code> <code>Optional[Dict]</code> <p>Visual configuration.</p> <code>None</code> <code>**kwargs</code> <p>Additional layer options.</p> <code>{}</code> Source code in <code>anymap_ts/keplergl.py</code> <pre><code>def add_layer(\n    self,\n    layer_type: str,\n    data_id: str,\n    columns: Dict[str, str],\n    label: Optional[str] = None,\n    color: Optional[List[int]] = None,\n    vis_config: Optional[Dict] = None,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a layer to the visualization.\n\n    Args:\n        layer_type: Layer type ('point', 'arc', 'line', 'hexagon', 'heatmap', etc.).\n        data_id: Dataset ID for the layer.\n        columns: Column mapping (e.g., {'lat': 'latitude', 'lng': 'longitude'}).\n        label: Layer label.\n        color: Layer color as [r, g, b].\n        vis_config: Visual configuration.\n        **kwargs: Additional layer options.\n    \"\"\"\n    layer_config = {\n        \"type\": layer_type,\n        \"config\": {\n            \"dataId\": data_id,\n            \"label\": label or f\"{layer_type}_layer\",\n            \"columns\": columns,\n            \"isVisible\": True,\n        },\n    }\n    if color:\n        layer_config[\"config\"][\"color\"] = color\n    if vis_config:\n        layer_config[\"config\"][\"visConfig\"] = vis_config\n\n    layer_config[\"config\"].update(kwargs)\n\n    self.call_js_method(\"addLayer\", layer=layer_config)\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.keplergl.KeplerGLMap.fly_to","title":"<code>fly_to(self, lng, lat, zoom=None)</code>","text":"<p>Fly to a location.</p> <p>Parameters:</p> Name Type Description Default <code>lng</code> <code>float</code> <p>Target longitude.</p> required <code>lat</code> <code>float</code> <p>Target latitude.</p> required <code>zoom</code> <code>Optional[float]</code> <p>Target zoom level.</p> <code>None</code> Source code in <code>anymap_ts/keplergl.py</code> <pre><code>def fly_to(\n    self,\n    lng: float,\n    lat: float,\n    zoom: Optional[float] = None,\n) -&gt; None:\n    \"\"\"Fly to a location.\n\n    Args:\n        lng: Target longitude.\n        lat: Target latitude.\n        zoom: Target zoom level.\n    \"\"\"\n    self.center = [lng, lat]\n    if zoom is not None:\n        self.zoom = zoom\n    self.call_js_method(\"flyTo\", lng=lng, lat=lat, zoom=zoom or self.zoom)\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.keplergl.KeplerGLMap.get_config","title":"<code>get_config(self)</code>","text":"<p>Get the current KeplerGL configuration.</p> <p>Returns:</p> Type Description <code>Dict</code> <p>Configuration dict.</p> Source code in <code>anymap_ts/keplergl.py</code> <pre><code>def get_config(self) -&gt; Dict:\n    \"\"\"Get the current KeplerGL configuration.\n\n    Returns:\n        Configuration dict.\n    \"\"\"\n    return self.config\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.keplergl.KeplerGLMap.load_config","title":"<code>load_config(self, filepath)</code>","text":"<p>Load configuration from a JSON file.</p> <p>Parameters:</p> Name Type Description Default <code>filepath</code> <code>Union[str, Path]</code> <p>Path to the configuration file.</p> required Source code in <code>anymap_ts/keplergl.py</code> <pre><code>def load_config(self, filepath: Union[str, Path]) -&gt; None:\n    \"\"\"Load configuration from a JSON file.\n\n    Args:\n        filepath: Path to the configuration file.\n    \"\"\"\n    with open(filepath) as f:\n        config = json.load(f)\n    self.set_config(config)\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.keplergl.KeplerGLMap.remove_data","title":"<code>remove_data(self, name)</code>","text":"<p>Remove a dataset.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Dataset name to remove.</p> required Source code in <code>anymap_ts/keplergl.py</code> <pre><code>def remove_data(self, name: str) -&gt; None:\n    \"\"\"Remove a dataset.\n\n    Args:\n        name: Dataset name to remove.\n    \"\"\"\n    if name in self.datasets:\n        datasets = dict(self.datasets)\n        del datasets[name]\n        self.datasets = datasets\n    self.call_js_method(\"removeData\", dataId=name)\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.keplergl.KeplerGLMap.save_config","title":"<code>save_config(self, filepath)</code>","text":"<p>Save configuration to a JSON file.</p> <p>Parameters:</p> Name Type Description Default <code>filepath</code> <code>Union[str, Path]</code> <p>Path to save the configuration.</p> required Source code in <code>anymap_ts/keplergl.py</code> <pre><code>def save_config(self, filepath: Union[str, Path]) -&gt; None:\n    \"\"\"Save configuration to a JSON file.\n\n    Args:\n        filepath: Path to save the configuration.\n    \"\"\"\n    with open(filepath, \"w\") as f:\n        json.dump(self.config, f, indent=2)\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.keplergl.KeplerGLMap.set_config","title":"<code>set_config(self, config)</code>","text":"<p>Set the KeplerGL configuration.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>Dict</code> <p>Configuration dict.</p> required Source code in <code>anymap_ts/keplergl.py</code> <pre><code>def set_config(self, config: Dict) -&gt; None:\n    \"\"\"Set the KeplerGL configuration.\n\n    Args:\n        config: Configuration dict.\n    \"\"\"\n    self.config = config\n    self.call_js_method(\"setConfig\", config=config)\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.leaflet","title":"<code>leaflet</code>","text":"<p>Leaflet map widget implementation.</p>"},{"location":"anymap_ts/#anymap_ts.leaflet.LeafletMap","title":"<code> LeafletMap            (MapWidget)         </code>","text":"<p>Interactive map widget using Leaflet.</p> <p>This class provides a Python interface to Leaflet maps with full bidirectional communication through anywidget.</p> <p>Note</p> <p>Leaflet uses [lat, lng] order internally, but this class accepts [lng, lat] for consistency with other map libraries.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from anymap_ts import LeafletMap\n&gt;&gt;&gt; m = LeafletMap(center=[-122.4, 37.8], zoom=10)\n&gt;&gt;&gt; m.add_basemap(\"OpenStreetMap\")\n&gt;&gt;&gt; m\n</code></pre> Source code in <code>anymap_ts/leaflet.py</code> <pre><code>class LeafletMap(MapWidget):\n    \"\"\"Interactive map widget using Leaflet.\n\n    This class provides a Python interface to Leaflet maps with\n    full bidirectional communication through anywidget.\n\n    Note:\n        Leaflet uses [lat, lng] order internally, but this class\n        accepts [lng, lat] for consistency with other map libraries.\n\n    Example:\n        &gt;&gt;&gt; from anymap_ts import LeafletMap\n        &gt;&gt;&gt; m = LeafletMap(center=[-122.4, 37.8], zoom=10)\n        &gt;&gt;&gt; m.add_basemap(\"OpenStreetMap\")\n        &gt;&gt;&gt; m\n    \"\"\"\n\n    # ESM module for frontend\n    _esm = STATIC_DIR / \"leaflet.js\"\n    _css = STATIC_DIR / \"leaflet.css\"\n\n    # Layer tracking\n    _layer_dict = traitlets.Dict({}).tag(sync=True)\n\n    def __init__(\n        self,\n        center: Tuple[float, float] = (0.0, 0.0),\n        zoom: float = 2.0,\n        width: str = \"100%\",\n        height: str = \"600px\",\n        controls: Optional[Dict[str, Any]] = None,\n        **kwargs,\n    ):\n        \"\"\"Initialize a Leaflet map.\n\n        Args:\n            center: Map center as (longitude, latitude).\n            zoom: Initial zoom level.\n            width: Map width as CSS string.\n            height: Map height as CSS string.\n            controls: Dict of controls to add (e.g., {\"zoom\": True}).\n            **kwargs: Additional widget arguments.\n        \"\"\"\n        super().__init__(\n            center=list(center),\n            zoom=zoom,\n            width=width,\n            height=height,\n            style=\"\",  # Leaflet doesn't use style URLs\n            **kwargs,\n        )\n\n        # Initialize layer dictionary\n        self._layer_dict = {\"Background\": []}\n\n        # Add default controls\n        if controls is None:\n            controls = {\"zoom\": True, \"scale\": True}\n\n        for control_name, config in controls.items():\n            if config:\n                self.add_control(\n                    control_name, **(config if isinstance(config, dict) else {})\n                )\n\n    # -------------------------------------------------------------------------\n    # Basemap Methods\n    # -------------------------------------------------------------------------\n\n    def add_basemap(\n        self,\n        basemap: str = \"OpenStreetMap\",\n        attribution: Optional[str] = None,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a basemap layer.\n\n        Args:\n            basemap: Name of basemap provider (e.g., \"OpenStreetMap\", \"CartoDB.Positron\").\n            attribution: Custom attribution text.\n            **kwargs: Additional options.\n        \"\"\"\n        try:\n            url, default_attribution = get_basemap_url(basemap)\n        except (ValueError, KeyError):\n            url = basemap\n            default_attribution = \"\"\n\n        self.call_js_method(\n            \"addBasemap\",\n            url,\n            attribution=attribution or default_attribution,\n            name=basemap,\n            **kwargs,\n        )\n\n        # Track in layer dict\n        basemaps = self._layer_dict.get(\"Basemaps\", [])\n        if basemap not in basemaps:\n            self._layer_dict = {\n                **self._layer_dict,\n                \"Basemaps\": basemaps + [basemap],\n            }\n\n    # -------------------------------------------------------------------------\n    # Vector Data Methods\n    # -------------------------------------------------------------------------\n\n    def add_vector(\n        self,\n        data: Any,\n        style: Optional[Dict] = None,\n        name: Optional[str] = None,\n        fit_bounds: bool = True,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add vector data to the map.\n\n        Supports GeoJSON, GeoDataFrame, or file paths to vector formats.\n\n        Args:\n            data: GeoJSON dict, GeoDataFrame, or path to vector file.\n            style: Leaflet style properties.\n            name: Layer name.\n            fit_bounds: Whether to fit map to data bounds.\n            **kwargs: Additional layer options.\n        \"\"\"\n        geojson = to_geojson(data)\n\n        # Handle URL data\n        if geojson.get(\"type\") == \"url\":\n            self.add_geojson(\n                geojson[\"url\"],\n                style=style,\n                name=name,\n                fit_bounds=fit_bounds,\n                **kwargs,\n            )\n            return\n\n        layer_id = name or f\"vector-{len(self._layers)}\"\n\n        # Get default style if not provided\n        if style is None:\n            layer_type = _infer_leaflet_type(geojson)\n            style = _get_default_style(layer_type)\n\n        # Get bounds\n        bounds = get_bounds(data) if fit_bounds else None\n\n        # Call JavaScript\n        self.call_js_method(\n            \"addGeoJSON\",\n            data=geojson,\n            name=layer_id,\n            style=style,\n            fitBounds=fit_bounds,\n            bounds=bounds,\n            **kwargs,\n        )\n\n        # Track layer\n        self._layers = {\n            **self._layers,\n            layer_id: {\n                \"id\": layer_id,\n                \"type\": \"geojson\",\n                \"style\": style,\n            },\n        }\n\n    def add_geojson(\n        self,\n        data: Union[str, Dict],\n        style: Optional[Dict] = None,\n        name: Optional[str] = None,\n        fit_bounds: bool = True,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add GeoJSON data to the map.\n\n        Args:\n            data: GeoJSON dict or URL to GeoJSON file.\n            style: Leaflet style properties.\n            name: Layer name.\n            fit_bounds: Whether to fit map to data bounds.\n            **kwargs: Additional layer options.\n        \"\"\"\n        self.add_vector(\n            data,\n            style=style,\n            name=name,\n            fit_bounds=fit_bounds,\n            **kwargs,\n        )\n\n    # -------------------------------------------------------------------------\n    # Raster Data Methods\n    # -------------------------------------------------------------------------\n\n    def add_tile_layer(\n        self,\n        url: str,\n        name: Optional[str] = None,\n        attribution: str = \"\",\n        min_zoom: int = 0,\n        max_zoom: int = 22,\n        opacity: float = 1.0,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add an XYZ tile layer.\n\n        Args:\n            url: Tile URL template with {x}, {y}, {z} placeholders.\n            name: Layer name.\n            attribution: Attribution text.\n            min_zoom: Minimum zoom level.\n            max_zoom: Maximum zoom level.\n            opacity: Layer opacity.\n            **kwargs: Additional options.\n        \"\"\"\n        layer_id = name or f\"tiles-{len(self._layers)}\"\n\n        self.call_js_method(\n            \"addTileLayer\",\n            url,\n            name=layer_id,\n            attribution=attribution,\n            minZoom=min_zoom,\n            maxZoom=max_zoom,\n            opacity=opacity,\n            **kwargs,\n        )\n\n        # Track layer\n        self._layers = {\n            **self._layers,\n            layer_id: {\n                \"id\": layer_id,\n                \"type\": \"tile\",\n            },\n        }\n\n    # -------------------------------------------------------------------------\n    # Layer Management\n    # -------------------------------------------------------------------------\n\n    def remove_layer(self, layer_id: str) -&gt; None:\n        \"\"\"Remove a layer from the map.\n\n        Args:\n            layer_id: Layer identifier to remove.\n        \"\"\"\n        if layer_id in self._layers:\n            layers = dict(self._layers)\n            del layers[layer_id]\n            self._layers = layers\n        self.call_js_method(\"removeLayer\", layer_id)\n\n    def set_visibility(self, layer_id: str, visible: bool) -&gt; None:\n        \"\"\"Set layer visibility.\n\n        Args:\n            layer_id: Layer identifier.\n            visible: Whether layer should be visible.\n        \"\"\"\n        self.call_js_method(\"setVisibility\", layer_id, visible)\n\n    def set_opacity(self, layer_id: str, opacity: float) -&gt; None:\n        \"\"\"Set layer opacity.\n\n        Args:\n            layer_id: Layer identifier.\n            opacity: Opacity value between 0 and 1.\n        \"\"\"\n        self.call_js_method(\"setOpacity\", layer_id, opacity)\n\n    # -------------------------------------------------------------------------\n    # Controls\n    # -------------------------------------------------------------------------\n\n    def add_control(\n        self,\n        control_type: str,\n        position: str = \"topright\",\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a map control.\n\n        Args:\n            control_type: Type of control ('zoom', 'scale', 'attribution', 'layers').\n            position: Control position ('topleft', 'topright', 'bottomleft', 'bottomright').\n            **kwargs: Control-specific options.\n        \"\"\"\n        # Convert position format\n        position_map = {\n            \"top-left\": \"topleft\",\n            \"top-right\": \"topright\",\n            \"bottom-left\": \"bottomleft\",\n            \"bottom-right\": \"bottomright\",\n        }\n        pos = position_map.get(position, position)\n\n        self.call_js_method(\"addControl\", control_type, position=pos, **kwargs)\n        self._controls = {\n            **self._controls,\n            control_type: {\"type\": control_type, \"position\": pos, **kwargs},\n        }\n\n    def remove_control(self, control_type: str) -&gt; None:\n        \"\"\"Remove a map control.\n\n        Args:\n            control_type: Type of control to remove.\n        \"\"\"\n        self.call_js_method(\"removeControl\", control_type)\n        if control_type in self._controls:\n            controls = dict(self._controls)\n            del controls[control_type]\n            self._controls = controls\n\n    def add_layer_control(\n        self,\n        position: str = \"topright\",\n        collapsed: bool = True,\n    ) -&gt; None:\n        \"\"\"Add a layer control for toggling layer visibility.\n\n        Args:\n            position: Control position.\n            collapsed: Whether control starts collapsed.\n        \"\"\"\n        self.add_control(\"layers\", position=position, collapsed=collapsed)\n\n    # -------------------------------------------------------------------------\n    # Markers\n    # -------------------------------------------------------------------------\n\n    def add_marker(\n        self,\n        lng: float,\n        lat: float,\n        popup: Optional[str] = None,\n        marker_id: Optional[str] = None,\n    ) -&gt; None:\n        \"\"\"Add a marker to the map.\n\n        Args:\n            lng: Longitude.\n            lat: Latitude.\n            popup: HTML content for popup.\n            marker_id: Unique marker ID.\n        \"\"\"\n        self.call_js_method(\"addMarker\", lng, lat, popup=popup, id=marker_id)\n\n    def remove_marker(self, marker_id: str) -&gt; None:\n        \"\"\"Remove a marker from the map.\n\n        Args:\n            marker_id: Marker ID to remove.\n        \"\"\"\n        self.call_js_method(\"removeMarker\", marker_id)\n\n    # -------------------------------------------------------------------------\n    # HTML Export\n    # -------------------------------------------------------------------------\n\n    def _generate_html_template(self) -&gt; str:\n        \"\"\"Generate standalone HTML for the map.\"\"\"\n        template_path = Path(__file__).parent / \"templates\" / \"leaflet.html\"\n\n        if template_path.exists():\n            template = template_path.read_text(encoding=\"utf-8\")\n        else:\n            template = self._get_default_template()\n\n        # Serialize state\n        state = {\n            \"center\": self.center,\n            \"zoom\": self.zoom,\n            \"width\": self.width,\n            \"height\": self.height,\n            \"layers\": self._layers,\n            \"controls\": self._controls,\n            \"js_calls\": self._js_calls,\n        }\n\n        template = template.replace(\"{{state}}\", json.dumps(state, indent=2))\n        return template\n\n    def _get_default_template(self) -&gt; str:\n        \"\"\"Get default HTML template.\"\"\"\n        return \"\"\"&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n    &lt;meta charset=\"utf-8\"&gt;\n    &lt;title&gt;{{title}}&lt;/title&gt;\n    &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"&gt;\n    &lt;link rel=\"stylesheet\" href=\"https://unpkg.com/leaflet@1.9.4/dist/leaflet.css\" /&gt;\n    &lt;script src=\"https://unpkg.com/leaflet@1.9.4/dist/leaflet.js\"&gt;&lt;/script&gt;\n    &lt;style&gt;\n        body { margin: 0; padding: 0; }\n        #map { position: absolute; top: 0; bottom: 0; width: 100%; }\n    &lt;/style&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;div id=\"map\"&gt;&lt;/div&gt;\n    &lt;script&gt;\n        const state = {{state}};\n\n        // Note: Leaflet uses [lat, lng], but we store [lng, lat]\n        const map = L.map('map').setView([state.center[1], state.center[0]], state.zoom);\n\n        // Replay JS calls\n        for (const call of state.js_calls || []) {\n            try {\n                executeMethod(call.method, call.args, call.kwargs);\n            } catch (e) {\n                console.error('Error executing', call.method, e);\n            }\n        }\n\n        function executeMethod(method, args, kwargs) {\n            switch (method) {\n                case 'addBasemap':\n                case 'addTileLayer':\n                    const url = args[0];\n                    L.tileLayer(url, {\n                        attribution: kwargs.attribution || '',\n                        maxZoom: kwargs.maxZoom || 22,\n                        minZoom: kwargs.minZoom || 0,\n                        opacity: kwargs.opacity || 1\n                    }).addTo(map);\n                    break;\n\n                case 'addGeoJSON':\n                    const geojson = kwargs.data;\n                    const style = kwargs.style || {\n                        color: '#3388ff',\n                        weight: 2,\n                        opacity: 0.8,\n                        fillOpacity: 0.5\n                    };\n                    const layer = L.geoJSON(geojson, {\n                        style: style,\n                        pointToLayer: (feature, latlng) =&gt; L.circleMarker(latlng, style)\n                    }).addTo(map);\n\n                    if (kwargs.fitBounds) {\n                        map.fitBounds(layer.getBounds(), { padding: [50, 50] });\n                    }\n                    break;\n\n                case 'addControl':\n                    const controlType = args[0];\n                    const position = kwargs.position || 'topright';\n                    if (controlType === 'zoom' || controlType === 'navigation') {\n                        L.control.zoom({ position }).addTo(map);\n                    } else if (controlType === 'scale') {\n                        L.control.scale({ position, imperial: false }).addTo(map);\n                    }\n                    break;\n\n                case 'addMarker':\n                    const [lng, lat] = args;\n                    const marker = L.marker([lat, lng]).addTo(map);\n                    if (kwargs.popup) {\n                        marker.bindPopup(kwargs.popup);\n                    }\n                    break;\n\n                case 'flyTo':\n                    map.flyTo([args[1], args[0]], kwargs.zoom || map.getZoom(), {\n                        duration: (kwargs.duration || 2000) / 1000\n                    });\n                    break;\n\n                case 'fitBounds':\n                    const bounds = args[0];\n                    map.fitBounds([\n                        [bounds[1], bounds[0]],\n                        [bounds[3], bounds[2]]\n                    ], { padding: [kwargs.padding || 50, kwargs.padding || 50] });\n                    break;\n\n                default:\n                    console.log('Unknown method:', method);\n            }\n        }\n    &lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\"\"\"\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.leaflet.LeafletMap.__init__","title":"<code>__init__(self, center=(0.0, 0.0), zoom=2.0, width='100%', height='600px', controls=None, **kwargs)</code>  <code>special</code>","text":"<p>Initialize a Leaflet map.</p> <p>Parameters:</p> Name Type Description Default <code>center</code> <code>Tuple[float, float]</code> <p>Map center as (longitude, latitude).</p> <code>(0.0, 0.0)</code> <code>zoom</code> <code>float</code> <p>Initial zoom level.</p> <code>2.0</code> <code>width</code> <code>str</code> <p>Map width as CSS string.</p> <code>'100%'</code> <code>height</code> <code>str</code> <p>Map height as CSS string.</p> <code>'600px'</code> <code>controls</code> <code>Optional[Dict[str, Any]]</code> <p>Dict of controls to add (e.g., {\"zoom\": True}).</p> <code>None</code> <code>**kwargs</code> <p>Additional widget arguments.</p> <code>{}</code> Source code in <code>anymap_ts/leaflet.py</code> <pre><code>def __init__(\n    self,\n    center: Tuple[float, float] = (0.0, 0.0),\n    zoom: float = 2.0,\n    width: str = \"100%\",\n    height: str = \"600px\",\n    controls: Optional[Dict[str, Any]] = None,\n    **kwargs,\n):\n    \"\"\"Initialize a Leaflet map.\n\n    Args:\n        center: Map center as (longitude, latitude).\n        zoom: Initial zoom level.\n        width: Map width as CSS string.\n        height: Map height as CSS string.\n        controls: Dict of controls to add (e.g., {\"zoom\": True}).\n        **kwargs: Additional widget arguments.\n    \"\"\"\n    super().__init__(\n        center=list(center),\n        zoom=zoom,\n        width=width,\n        height=height,\n        style=\"\",  # Leaflet doesn't use style URLs\n        **kwargs,\n    )\n\n    # Initialize layer dictionary\n    self._layer_dict = {\"Background\": []}\n\n    # Add default controls\n    if controls is None:\n        controls = {\"zoom\": True, \"scale\": True}\n\n    for control_name, config in controls.items():\n        if config:\n            self.add_control(\n                control_name, **(config if isinstance(config, dict) else {})\n            )\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.leaflet.LeafletMap.add_basemap","title":"<code>add_basemap(self, basemap='OpenStreetMap', attribution=None, **kwargs)</code>","text":"<p>Add a basemap layer.</p> <p>Parameters:</p> Name Type Description Default <code>basemap</code> <code>str</code> <p>Name of basemap provider (e.g., \"OpenStreetMap\", \"CartoDB.Positron\").</p> <code>'OpenStreetMap'</code> <code>attribution</code> <code>Optional[str]</code> <p>Custom attribution text.</p> <code>None</code> <code>**kwargs</code> <p>Additional options.</p> <code>{}</code> Source code in <code>anymap_ts/leaflet.py</code> <pre><code>def add_basemap(\n    self,\n    basemap: str = \"OpenStreetMap\",\n    attribution: Optional[str] = None,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a basemap layer.\n\n    Args:\n        basemap: Name of basemap provider (e.g., \"OpenStreetMap\", \"CartoDB.Positron\").\n        attribution: Custom attribution text.\n        **kwargs: Additional options.\n    \"\"\"\n    try:\n        url, default_attribution = get_basemap_url(basemap)\n    except (ValueError, KeyError):\n        url = basemap\n        default_attribution = \"\"\n\n    self.call_js_method(\n        \"addBasemap\",\n        url,\n        attribution=attribution or default_attribution,\n        name=basemap,\n        **kwargs,\n    )\n\n    # Track in layer dict\n    basemaps = self._layer_dict.get(\"Basemaps\", [])\n    if basemap not in basemaps:\n        self._layer_dict = {\n            **self._layer_dict,\n            \"Basemaps\": basemaps + [basemap],\n        }\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.leaflet.LeafletMap.add_control","title":"<code>add_control(self, control_type, position='topright', **kwargs)</code>","text":"<p>Add a map control.</p> <p>Parameters:</p> Name Type Description Default <code>control_type</code> <code>str</code> <p>Type of control ('zoom', 'scale', 'attribution', 'layers').</p> required <code>position</code> <code>str</code> <p>Control position ('topleft', 'topright', 'bottomleft', 'bottomright').</p> <code>'topright'</code> <code>**kwargs</code> <p>Control-specific options.</p> <code>{}</code> Source code in <code>anymap_ts/leaflet.py</code> <pre><code>def add_control(\n    self,\n    control_type: str,\n    position: str = \"topright\",\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a map control.\n\n    Args:\n        control_type: Type of control ('zoom', 'scale', 'attribution', 'layers').\n        position: Control position ('topleft', 'topright', 'bottomleft', 'bottomright').\n        **kwargs: Control-specific options.\n    \"\"\"\n    # Convert position format\n    position_map = {\n        \"top-left\": \"topleft\",\n        \"top-right\": \"topright\",\n        \"bottom-left\": \"bottomleft\",\n        \"bottom-right\": \"bottomright\",\n    }\n    pos = position_map.get(position, position)\n\n    self.call_js_method(\"addControl\", control_type, position=pos, **kwargs)\n    self._controls = {\n        **self._controls,\n        control_type: {\"type\": control_type, \"position\": pos, **kwargs},\n    }\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.leaflet.LeafletMap.add_geojson","title":"<code>add_geojson(self, data, style=None, name=None, fit_bounds=True, **kwargs)</code>","text":"<p>Add GeoJSON data to the map.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Union[str, Dict]</code> <p>GeoJSON dict or URL to GeoJSON file.</p> required <code>style</code> <code>Optional[Dict]</code> <p>Leaflet style properties.</p> <code>None</code> <code>name</code> <code>Optional[str]</code> <p>Layer name.</p> <code>None</code> <code>fit_bounds</code> <code>bool</code> <p>Whether to fit map to data bounds.</p> <code>True</code> <code>**kwargs</code> <p>Additional layer options.</p> <code>{}</code> Source code in <code>anymap_ts/leaflet.py</code> <pre><code>def add_geojson(\n    self,\n    data: Union[str, Dict],\n    style: Optional[Dict] = None,\n    name: Optional[str] = None,\n    fit_bounds: bool = True,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add GeoJSON data to the map.\n\n    Args:\n        data: GeoJSON dict or URL to GeoJSON file.\n        style: Leaflet style properties.\n        name: Layer name.\n        fit_bounds: Whether to fit map to data bounds.\n        **kwargs: Additional layer options.\n    \"\"\"\n    self.add_vector(\n        data,\n        style=style,\n        name=name,\n        fit_bounds=fit_bounds,\n        **kwargs,\n    )\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.leaflet.LeafletMap.add_layer_control","title":"<code>add_layer_control(self, position='topright', collapsed=True)</code>","text":"<p>Add a layer control for toggling layer visibility.</p> <p>Parameters:</p> Name Type Description Default <code>position</code> <code>str</code> <p>Control position.</p> <code>'topright'</code> <code>collapsed</code> <code>bool</code> <p>Whether control starts collapsed.</p> <code>True</code> Source code in <code>anymap_ts/leaflet.py</code> <pre><code>def add_layer_control(\n    self,\n    position: str = \"topright\",\n    collapsed: bool = True,\n) -&gt; None:\n    \"\"\"Add a layer control for toggling layer visibility.\n\n    Args:\n        position: Control position.\n        collapsed: Whether control starts collapsed.\n    \"\"\"\n    self.add_control(\"layers\", position=position, collapsed=collapsed)\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.leaflet.LeafletMap.add_marker","title":"<code>add_marker(self, lng, lat, popup=None, marker_id=None)</code>","text":"<p>Add a marker to the map.</p> <p>Parameters:</p> Name Type Description Default <code>lng</code> <code>float</code> <p>Longitude.</p> required <code>lat</code> <code>float</code> <p>Latitude.</p> required <code>popup</code> <code>Optional[str]</code> <p>HTML content for popup.</p> <code>None</code> <code>marker_id</code> <code>Optional[str]</code> <p>Unique marker ID.</p> <code>None</code> Source code in <code>anymap_ts/leaflet.py</code> <pre><code>def add_marker(\n    self,\n    lng: float,\n    lat: float,\n    popup: Optional[str] = None,\n    marker_id: Optional[str] = None,\n) -&gt; None:\n    \"\"\"Add a marker to the map.\n\n    Args:\n        lng: Longitude.\n        lat: Latitude.\n        popup: HTML content for popup.\n        marker_id: Unique marker ID.\n    \"\"\"\n    self.call_js_method(\"addMarker\", lng, lat, popup=popup, id=marker_id)\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.leaflet.LeafletMap.add_tile_layer","title":"<code>add_tile_layer(self, url, name=None, attribution='', min_zoom=0, max_zoom=22, opacity=1.0, **kwargs)</code>","text":"<p>Add an XYZ tile layer.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>Tile URL template with {x}, {y}, {z} placeholders.</p> required <code>name</code> <code>Optional[str]</code> <p>Layer name.</p> <code>None</code> <code>attribution</code> <code>str</code> <p>Attribution text.</p> <code>''</code> <code>min_zoom</code> <code>int</code> <p>Minimum zoom level.</p> <code>0</code> <code>max_zoom</code> <code>int</code> <p>Maximum zoom level.</p> <code>22</code> <code>opacity</code> <code>float</code> <p>Layer opacity.</p> <code>1.0</code> <code>**kwargs</code> <p>Additional options.</p> <code>{}</code> Source code in <code>anymap_ts/leaflet.py</code> <pre><code>def add_tile_layer(\n    self,\n    url: str,\n    name: Optional[str] = None,\n    attribution: str = \"\",\n    min_zoom: int = 0,\n    max_zoom: int = 22,\n    opacity: float = 1.0,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add an XYZ tile layer.\n\n    Args:\n        url: Tile URL template with {x}, {y}, {z} placeholders.\n        name: Layer name.\n        attribution: Attribution text.\n        min_zoom: Minimum zoom level.\n        max_zoom: Maximum zoom level.\n        opacity: Layer opacity.\n        **kwargs: Additional options.\n    \"\"\"\n    layer_id = name or f\"tiles-{len(self._layers)}\"\n\n    self.call_js_method(\n        \"addTileLayer\",\n        url,\n        name=layer_id,\n        attribution=attribution,\n        minZoom=min_zoom,\n        maxZoom=max_zoom,\n        opacity=opacity,\n        **kwargs,\n    )\n\n    # Track layer\n    self._layers = {\n        **self._layers,\n        layer_id: {\n            \"id\": layer_id,\n            \"type\": \"tile\",\n        },\n    }\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.leaflet.LeafletMap.add_vector","title":"<code>add_vector(self, data, style=None, name=None, fit_bounds=True, **kwargs)</code>","text":"<p>Add vector data to the map.</p> <p>Supports GeoJSON, GeoDataFrame, or file paths to vector formats.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>GeoJSON dict, GeoDataFrame, or path to vector file.</p> required <code>style</code> <code>Optional[Dict]</code> <p>Leaflet style properties.</p> <code>None</code> <code>name</code> <code>Optional[str]</code> <p>Layer name.</p> <code>None</code> <code>fit_bounds</code> <code>bool</code> <p>Whether to fit map to data bounds.</p> <code>True</code> <code>**kwargs</code> <p>Additional layer options.</p> <code>{}</code> Source code in <code>anymap_ts/leaflet.py</code> <pre><code>def add_vector(\n    self,\n    data: Any,\n    style: Optional[Dict] = None,\n    name: Optional[str] = None,\n    fit_bounds: bool = True,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add vector data to the map.\n\n    Supports GeoJSON, GeoDataFrame, or file paths to vector formats.\n\n    Args:\n        data: GeoJSON dict, GeoDataFrame, or path to vector file.\n        style: Leaflet style properties.\n        name: Layer name.\n        fit_bounds: Whether to fit map to data bounds.\n        **kwargs: Additional layer options.\n    \"\"\"\n    geojson = to_geojson(data)\n\n    # Handle URL data\n    if geojson.get(\"type\") == \"url\":\n        self.add_geojson(\n            geojson[\"url\"],\n            style=style,\n            name=name,\n            fit_bounds=fit_bounds,\n            **kwargs,\n        )\n        return\n\n    layer_id = name or f\"vector-{len(self._layers)}\"\n\n    # Get default style if not provided\n    if style is None:\n        layer_type = _infer_leaflet_type(geojson)\n        style = _get_default_style(layer_type)\n\n    # Get bounds\n    bounds = get_bounds(data) if fit_bounds else None\n\n    # Call JavaScript\n    self.call_js_method(\n        \"addGeoJSON\",\n        data=geojson,\n        name=layer_id,\n        style=style,\n        fitBounds=fit_bounds,\n        bounds=bounds,\n        **kwargs,\n    )\n\n    # Track layer\n    self._layers = {\n        **self._layers,\n        layer_id: {\n            \"id\": layer_id,\n            \"type\": \"geojson\",\n            \"style\": style,\n        },\n    }\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.leaflet.LeafletMap.remove_control","title":"<code>remove_control(self, control_type)</code>","text":"<p>Remove a map control.</p> <p>Parameters:</p> Name Type Description Default <code>control_type</code> <code>str</code> <p>Type of control to remove.</p> required Source code in <code>anymap_ts/leaflet.py</code> <pre><code>def remove_control(self, control_type: str) -&gt; None:\n    \"\"\"Remove a map control.\n\n    Args:\n        control_type: Type of control to remove.\n    \"\"\"\n    self.call_js_method(\"removeControl\", control_type)\n    if control_type in self._controls:\n        controls = dict(self._controls)\n        del controls[control_type]\n        self._controls = controls\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.leaflet.LeafletMap.remove_layer","title":"<code>remove_layer(self, layer_id)</code>","text":"<p>Remove a layer from the map.</p> <p>Parameters:</p> Name Type Description Default <code>layer_id</code> <code>str</code> <p>Layer identifier to remove.</p> required Source code in <code>anymap_ts/leaflet.py</code> <pre><code>def remove_layer(self, layer_id: str) -&gt; None:\n    \"\"\"Remove a layer from the map.\n\n    Args:\n        layer_id: Layer identifier to remove.\n    \"\"\"\n    if layer_id in self._layers:\n        layers = dict(self._layers)\n        del layers[layer_id]\n        self._layers = layers\n    self.call_js_method(\"removeLayer\", layer_id)\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.leaflet.LeafletMap.remove_marker","title":"<code>remove_marker(self, marker_id)</code>","text":"<p>Remove a marker from the map.</p> <p>Parameters:</p> Name Type Description Default <code>marker_id</code> <code>str</code> <p>Marker ID to remove.</p> required Source code in <code>anymap_ts/leaflet.py</code> <pre><code>def remove_marker(self, marker_id: str) -&gt; None:\n    \"\"\"Remove a marker from the map.\n\n    Args:\n        marker_id: Marker ID to remove.\n    \"\"\"\n    self.call_js_method(\"removeMarker\", marker_id)\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.leaflet.LeafletMap.set_opacity","title":"<code>set_opacity(self, layer_id, opacity)</code>","text":"<p>Set layer opacity.</p> <p>Parameters:</p> Name Type Description Default <code>layer_id</code> <code>str</code> <p>Layer identifier.</p> required <code>opacity</code> <code>float</code> <p>Opacity value between 0 and 1.</p> required Source code in <code>anymap_ts/leaflet.py</code> <pre><code>def set_opacity(self, layer_id: str, opacity: float) -&gt; None:\n    \"\"\"Set layer opacity.\n\n    Args:\n        layer_id: Layer identifier.\n        opacity: Opacity value between 0 and 1.\n    \"\"\"\n    self.call_js_method(\"setOpacity\", layer_id, opacity)\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.leaflet.LeafletMap.set_visibility","title":"<code>set_visibility(self, layer_id, visible)</code>","text":"<p>Set layer visibility.</p> <p>Parameters:</p> Name Type Description Default <code>layer_id</code> <code>str</code> <p>Layer identifier.</p> required <code>visible</code> <code>bool</code> <p>Whether layer should be visible.</p> required Source code in <code>anymap_ts/leaflet.py</code> <pre><code>def set_visibility(self, layer_id: str, visible: bool) -&gt; None:\n    \"\"\"Set layer visibility.\n\n    Args:\n        layer_id: Layer identifier.\n        visible: Whether layer should be visible.\n    \"\"\"\n    self.call_js_method(\"setVisibility\", layer_id, visible)\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.mapbox","title":"<code>mapbox</code>","text":"<p>Mapbox GL JS map widget implementation.</p>"},{"location":"anymap_ts/#anymap_ts.mapbox.MapboxMap","title":"<code> MapboxMap            (MapWidget)         </code>","text":"<p>Interactive map widget using Mapbox GL JS.</p> <p>This class provides a Python interface to Mapbox GL JS maps with full bidirectional communication through anywidget.</p> <p>Note</p> <p>Requires a Mapbox access token. Set via MAPBOX_TOKEN environment variable or pass directly to the constructor.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from anymap_ts import MapboxMap\n&gt;&gt;&gt; m = MapboxMap(center=[-122.4, 37.8], zoom=10)\n&gt;&gt;&gt; m.add_basemap(\"mapbox://styles/mapbox/streets-v12\")\n&gt;&gt;&gt; m\n</code></pre> Source code in <code>anymap_ts/mapbox.py</code> <pre><code>class MapboxMap(MapWidget):\n    \"\"\"Interactive map widget using Mapbox GL JS.\n\n    This class provides a Python interface to Mapbox GL JS maps with\n    full bidirectional communication through anywidget.\n\n    Note:\n        Requires a Mapbox access token. Set via MAPBOX_TOKEN environment\n        variable or pass directly to the constructor.\n\n    Example:\n        &gt;&gt;&gt; from anymap_ts import MapboxMap\n        &gt;&gt;&gt; m = MapboxMap(center=[-122.4, 37.8], zoom=10)\n        &gt;&gt;&gt; m.add_basemap(\"mapbox://styles/mapbox/streets-v12\")\n        &gt;&gt;&gt; m\n    \"\"\"\n\n    # ESM module for frontend\n    _esm = STATIC_DIR / \"mapbox.js\"\n    _css = STATIC_DIR / \"mapbox.css\"\n\n    # Mapbox-specific traits\n    access_token = traitlets.Unicode(\"\").tag(sync=True)\n    bearing = traitlets.Float(0.0).tag(sync=True)\n    pitch = traitlets.Float(0.0).tag(sync=True)\n    antialias = traitlets.Bool(True).tag(sync=True)\n    double_click_zoom = traitlets.Bool(True).tag(sync=True)\n\n    # Layer tracking\n    _layer_dict = traitlets.Dict({}).tag(sync=True)\n\n    def __init__(\n        self,\n        center: Tuple[float, float] = (0.0, 0.0),\n        zoom: float = 2.0,\n        width: str = \"100%\",\n        height: str = \"600px\",\n        style: str = \"mapbox://styles/mapbox/streets-v12\",\n        bearing: float = 0.0,\n        pitch: float = 0.0,\n        max_pitch: float = 85.0,\n        access_token: Optional[str] = None,\n        controls: Optional[Dict[str, Any]] = None,\n        **kwargs,\n    ):\n        \"\"\"Initialize a Mapbox map.\n\n        Args:\n            center: Map center as (longitude, latitude).\n            zoom: Initial zoom level.\n            width: Map width as CSS string.\n            height: Map height as CSS string.\n            style: Mapbox style URL (e.g., \"mapbox://styles/mapbox/streets-v12\").\n            bearing: Map bearing in degrees.\n            pitch: Map pitch in degrees.\n            max_pitch: Maximum pitch angle in degrees (default: 85).\n            access_token: Mapbox access token. If None, reads from MAPBOX_TOKEN env var.\n            controls: Dict of controls to add (e.g., {\"navigation\": True}).\n            **kwargs: Additional widget arguments.\n        \"\"\"\n        # Get access token\n        token = access_token or get_mapbox_token()\n        if not token:\n            print(\n                \"Warning: No Mapbox access token provided. \"\n                \"Set MAPBOX_TOKEN environment variable or pass access_token parameter.\"\n            )\n\n        super().__init__(\n            center=list(center),\n            zoom=zoom,\n            width=width,\n            height=height,\n            style=style,\n            bearing=bearing,\n            pitch=pitch,\n            max_pitch=max_pitch,\n            access_token=token,\n            **kwargs,\n        )\n\n        # Initialize layer dictionary\n        self._layer_dict = {\"Background\": []}\n\n        # Add default controls\n        if controls is None:\n            controls = {\"navigation\": True, \"fullscreen\": True}\n\n        for control_name, config in controls.items():\n            if config:\n                self.add_control(\n                    control_name, **(config if isinstance(config, dict) else {})\n                )\n\n    def set_access_token(self, token: str) -&gt; None:\n        \"\"\"Set the Mapbox access token.\n\n        Args:\n            token: Mapbox access token.\n        \"\"\"\n        self.access_token = token\n\n    # -------------------------------------------------------------------------\n    # Basemap Methods\n    # -------------------------------------------------------------------------\n\n    def add_basemap(\n        self,\n        basemap: str = \"mapbox://styles/mapbox/streets-v12\",\n        attribution: Optional[str] = None,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a basemap layer.\n\n        For Mapbox styles, use the style URL format:\n        - \"mapbox://styles/mapbox/streets-v12\"\n        - \"mapbox://styles/mapbox/satellite-v9\"\n        - \"mapbox://styles/mapbox/satellite-streets-v12\"\n        - \"mapbox://styles/mapbox/light-v11\"\n        - \"mapbox://styles/mapbox/dark-v11\"\n        - \"mapbox://styles/mapbox/outdoors-v12\"\n\n        Or use XYZ tile URLs for custom basemaps.\n\n        Args:\n            basemap: Mapbox style URL or XYZ tile URL.\n            attribution: Custom attribution text.\n            **kwargs: Additional options.\n        \"\"\"\n        # If it's a Mapbox style URL, set it as the map style\n        if basemap.startswith(\"mapbox://\"):\n            self.style = basemap\n            return\n\n        # Otherwise, treat as XYZ tile URL\n        try:\n            url, default_attribution = get_basemap_url(basemap)\n        except (ValueError, KeyError):\n            url = basemap\n            default_attribution = \"\"\n\n        self.call_js_method(\n            \"addBasemap\",\n            url,\n            attribution=attribution or default_attribution,\n            name=basemap,\n            **kwargs,\n        )\n\n        # Track in layer dict\n        basemaps = self._layer_dict.get(\"Basemaps\", [])\n        if basemap not in basemaps:\n            self._layer_dict = {\n                **self._layer_dict,\n                \"Basemaps\": basemaps + [basemap],\n            }\n\n    # -------------------------------------------------------------------------\n    # Vector Data Methods\n    # -------------------------------------------------------------------------\n\n    def add_vector(\n        self,\n        data: Any,\n        layer_type: Optional[str] = None,\n        paint: Optional[Dict] = None,\n        name: Optional[str] = None,\n        fit_bounds: bool = True,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add vector data to the map.\n\n        Supports GeoJSON, GeoDataFrame, or file paths to vector formats.\n\n        Args:\n            data: GeoJSON dict, GeoDataFrame, or path to vector file.\n            layer_type: Mapbox layer type ('circle', 'line', 'fill', 'symbol').\n            paint: Mapbox paint properties.\n            name: Layer name.\n            fit_bounds: Whether to fit map to data bounds.\n            **kwargs: Additional layer options.\n        \"\"\"\n        geojson = to_geojson(data)\n\n        # Handle URL data\n        if geojson.get(\"type\") == \"url\":\n            self.add_geojson(\n                geojson[\"url\"],\n                layer_type=layer_type,\n                paint=paint,\n                name=name,\n                fit_bounds=fit_bounds,\n                **kwargs,\n            )\n            return\n\n        layer_id = name or f\"vector-{len(self._layers)}\"\n\n        # Infer layer type if not specified\n        if layer_type is None:\n            layer_type = infer_layer_type(geojson)\n\n        # Get default paint if not provided\n        if paint is None:\n            paint = get_default_paint(layer_type)\n\n        # Get bounds\n        bounds = get_bounds(data) if fit_bounds else None\n\n        # Call JavaScript\n        self.call_js_method(\n            \"addGeoJSON\",\n            data=geojson,\n            name=layer_id,\n            layerType=layer_type,\n            paint=paint,\n            fitBounds=fit_bounds,\n            bounds=bounds,\n            **kwargs,\n        )\n\n        # Track layer\n        self._layers = {\n            **self._layers,\n            layer_id: {\n                \"id\": layer_id,\n                \"type\": layer_type,\n                \"source\": f\"{layer_id}-source\",\n                \"paint\": paint,\n            },\n        }\n\n    def add_geojson(\n        self,\n        data: Union[str, Dict],\n        layer_type: Optional[str] = None,\n        paint: Optional[Dict] = None,\n        name: Optional[str] = None,\n        fit_bounds: bool = True,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add GeoJSON data to the map.\n\n        Args:\n            data: GeoJSON dict or URL to GeoJSON file.\n            layer_type: Mapbox layer type.\n            paint: Mapbox paint properties.\n            name: Layer name.\n            fit_bounds: Whether to fit map to data bounds.\n            **kwargs: Additional layer options.\n        \"\"\"\n        self.add_vector(\n            data,\n            layer_type=layer_type,\n            paint=paint,\n            name=name,\n            fit_bounds=fit_bounds,\n            **kwargs,\n        )\n\n    # -------------------------------------------------------------------------\n    # Raster Data Methods\n    # -------------------------------------------------------------------------\n\n    def add_tile_layer(\n        self,\n        url: str,\n        name: Optional[str] = None,\n        attribution: str = \"\",\n        min_zoom: int = 0,\n        max_zoom: int = 22,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add an XYZ tile layer.\n\n        Args:\n            url: Tile URL template with {x}, {y}, {z} placeholders.\n            name: Layer name.\n            attribution: Attribution text.\n            min_zoom: Minimum zoom level.\n            max_zoom: Maximum zoom level.\n            **kwargs: Additional options.\n        \"\"\"\n        layer_id = name or f\"tiles-{len(self._layers)}\"\n\n        self.call_js_method(\n            \"addTileLayer\",\n            url,\n            name=layer_id,\n            attribution=attribution,\n            minZoom=min_zoom,\n            maxZoom=max_zoom,\n            **kwargs,\n        )\n\n        # Track layer\n        self._layers = {\n            **self._layers,\n            layer_id: {\n                \"id\": layer_id,\n                \"type\": \"raster\",\n                \"source\": f\"{layer_id}-source\",\n            },\n        }\n\n    # -------------------------------------------------------------------------\n    # COG Layer (deck.gl)\n    # -------------------------------------------------------------------------\n\n    def add_cog_layer(\n        self,\n        url: str,\n        name: Optional[str] = None,\n        opacity: float = 1.0,\n        visible: bool = True,\n        debug: bool = False,\n        debug_opacity: float = 0.25,\n        max_error: float = 0.125,\n        fit_bounds: bool = True,\n        before_id: Optional[str] = None,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a Cloud Optimized GeoTIFF (COG) layer using deck.gl-raster.\n\n        This method renders COG files directly in the browser using GPU-accelerated\n        deck.gl rendering with automatic reprojection support.\n\n        Args:\n            url: URL to the Cloud Optimized GeoTIFF file.\n            name: Layer ID. If None, auto-generated.\n            opacity: Layer opacity (0-1).\n            visible: Whether layer is visible.\n            debug: Show reprojection mesh for debugging.\n            debug_opacity: Opacity of debug mesh (0-1).\n            max_error: Maximum reprojection error in pixels. Lower values\n                create denser mesh for better accuracy.\n            fit_bounds: Whether to fit map to COG bounds after loading.\n            before_id: ID of layer to insert before.\n            **kwargs: Additional COGLayer props.\n\n        Example:\n            &gt;&gt;&gt; from anymap_ts import MapboxMap\n            &gt;&gt;&gt; m = MapboxMap()\n            &gt;&gt;&gt; m.add_cog_layer(\n            ...     \"https://example.com/landcover.tif\",\n            ...     name=\"landcover\",\n            ...     opacity=0.8\n            ... )\n        \"\"\"\n        layer_id = name or f\"cog-{len(self._layers)}\"\n\n        self.call_js_method(\n            \"addCOGLayer\",\n            id=layer_id,\n            geotiff=url,\n            opacity=opacity,\n            visible=visible,\n            debug=debug,\n            debugOpacity=debug_opacity,\n            maxError=max_error,\n            fitBounds=fit_bounds,\n            beforeId=before_id,\n            **kwargs,\n        )\n\n        self._layers = {\n            **self._layers,\n            layer_id: {\n                \"id\": layer_id,\n                \"type\": \"cog\",\n                \"url\": url,\n            },\n        }\n\n    def remove_cog_layer(self, layer_id: str) -&gt; None:\n        \"\"\"Remove a COG layer.\n\n        Args:\n            layer_id: Layer identifier to remove.\n        \"\"\"\n        if layer_id in self._layers:\n            layers = dict(self._layers)\n            del layers[layer_id]\n            self._layers = layers\n        self.call_js_method(\"removeCOGLayer\", layer_id)\n\n    # -------------------------------------------------------------------------\n    # Arc Layer (deck.gl)\n    # -------------------------------------------------------------------------\n\n    def add_arc_layer(\n        self,\n        data: Any,\n        name: Optional[str] = None,\n        get_source_position: Union[str, Any] = \"source\",\n        get_target_position: Union[str, Any] = \"target\",\n        get_source_color: Optional[List[int]] = None,\n        get_target_color: Optional[List[int]] = None,\n        get_width: Union[float, str] = 1,\n        get_height: float = 1,\n        great_circle: bool = False,\n        pickable: bool = True,\n        opacity: float = 0.8,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add an arc layer for origin-destination visualization using deck.gl.\n\n        Arc layers are ideal for visualizing connections between locations,\n        such as flight routes, migration patterns, or network flows.\n\n        Args:\n            data: Array of data objects with source/target coordinates.\n                Each object should have source and target positions.\n            name: Layer ID. If None, auto-generated.\n            get_source_position: Accessor for source position [lng, lat].\n                Can be a string (property name) or a value.\n            get_target_position: Accessor for target position [lng, lat].\n                Can be a string (property name) or a value.\n            get_source_color: Source end color as [r, g, b, a].\n                Default: [51, 136, 255, 255] (blue).\n            get_target_color: Target end color as [r, g, b, a].\n                Default: [255, 136, 51, 255] (orange).\n            get_width: Arc width in pixels. Can be a number or accessor.\n            get_height: Arc height multiplier. Higher values create more curved arcs.\n            great_circle: Whether to draw arcs along great circles.\n            pickable: Whether layer responds to hover/click events.\n            opacity: Layer opacity (0-1).\n            **kwargs: Additional ArcLayer props.\n\n        Example:\n            &gt;&gt;&gt; from anymap_ts import MapboxMap\n            &gt;&gt;&gt; m = MapboxMap()\n            &gt;&gt;&gt; arcs = [\n            ...     {\"source\": [-122.4, 37.8], \"target\": [-73.9, 40.7]},\n            ...     {\"source\": [-122.4, 37.8], \"target\": [-0.1, 51.5]},\n            ... ]\n            &gt;&gt;&gt; m.add_arc_layer(arcs, name=\"flights\")\n        \"\"\"\n        layer_id = name or f\"arc-{len(self._layers)}\"\n        processed_data = self._process_deck_data(data)\n\n        self.call_js_method(\n            \"addArcLayer\",\n            id=layer_id,\n            data=processed_data,\n            getSourcePosition=get_source_position,\n            getTargetPosition=get_target_position,\n            getSourceColor=get_source_color or [51, 136, 255, 255],\n            getTargetColor=get_target_color or [255, 136, 51, 255],\n            getWidth=get_width,\n            getHeight=get_height,\n            greatCircle=great_circle,\n            pickable=pickable,\n            opacity=opacity,\n            **kwargs,\n        )\n\n        self._layers = {\n            **self._layers,\n            layer_id: {\n                \"id\": layer_id,\n                \"type\": \"arc\",\n            },\n        }\n\n    def remove_arc_layer(self, layer_id: str) -&gt; None:\n        \"\"\"Remove an arc layer.\n\n        Args:\n            layer_id: Layer identifier to remove.\n        \"\"\"\n        if layer_id in self._layers:\n            layers = dict(self._layers)\n            del layers[layer_id]\n            self._layers = layers\n        self.call_js_method(\"removeArcLayer\", layer_id)\n\n    # -------------------------------------------------------------------------\n    # PointCloud Layer (deck.gl)\n    # -------------------------------------------------------------------------\n\n    def add_point_cloud_layer(\n        self,\n        data: Any,\n        name: Optional[str] = None,\n        get_position: Union[str, Any] = \"position\",\n        get_color: Optional[Union[List[int], str]] = None,\n        get_normal: Optional[Union[str, Any]] = None,\n        point_size: float = 2,\n        size_units: str = \"pixels\",\n        pickable: bool = True,\n        opacity: float = 1.0,\n        material: bool = True,\n        coordinate_system: Optional[int] = None,\n        coordinate_origin: Optional[List[float]] = None,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a point cloud layer for 3D point visualization using deck.gl.\n\n        Point cloud layers render large collections of 3D points, ideal for\n        LiDAR data, photogrammetry outputs, or any 3D point dataset.\n\n        Args:\n            data: Array of point data with positions. Each point should have\n                x, y, z coordinates (or position array).\n            name: Layer ID. If None, auto-generated.\n            get_position: Accessor for point position [x, y, z].\n                Can be a string (property name) or a value.\n            get_color: Accessor or value for point color [r, g, b, a].\n                Default: [255, 255, 255, 255] (white).\n            get_normal: Accessor for point normal [nx, ny, nz] for lighting.\n                Default: [0, 0, 1] (pointing up).\n            point_size: Point size in pixels or meters (depends on size_units).\n            size_units: Size units: 'pixels', 'meters', or 'common'.\n            pickable: Whether layer responds to hover/click events.\n            opacity: Layer opacity (0-1).\n            material: Whether to enable lighting effects.\n            coordinate_system: Coordinate system for positions.\n            coordinate_origin: Origin for coordinate system [x, y, z].\n            **kwargs: Additional PointCloudLayer props.\n\n        Example:\n            &gt;&gt;&gt; from anymap_ts import MapboxMap\n            &gt;&gt;&gt; m = MapboxMap(pitch=45)\n            &gt;&gt;&gt; points = [\n            ...     {\"position\": [-122.4, 37.8, 100], \"color\": [255, 0, 0, 255]},\n            ...     {\"position\": [-122.3, 37.7, 200], \"color\": [0, 255, 0, 255]},\n            ... ]\n            &gt;&gt;&gt; m.add_point_cloud_layer(points, point_size=5)\n        \"\"\"\n        layer_id = name or f\"pointcloud-{len(self._layers)}\"\n        processed_data = self._process_deck_data(data)\n\n        self.call_js_method(\n            \"addPointCloudLayer\",\n            id=layer_id,\n            data=processed_data,\n            getPosition=get_position,\n            getColor=get_color or [255, 255, 255, 255],\n            getNormal=get_normal,\n            pointSize=point_size,\n            sizeUnits=size_units,\n            pickable=pickable,\n            opacity=opacity,\n            material=material,\n            coordinateSystem=coordinate_system,\n            coordinateOrigin=coordinate_origin,\n            **kwargs,\n        )\n\n        self._layers = {\n            **self._layers,\n            layer_id: {\n                \"id\": layer_id,\n                \"type\": \"pointcloud\",\n            },\n        }\n\n    def remove_point_cloud_layer(self, layer_id: str) -&gt; None:\n        \"\"\"Remove a point cloud layer.\n\n        Args:\n            layer_id: Layer identifier to remove.\n        \"\"\"\n        if layer_id in self._layers:\n            layers = dict(self._layers)\n            del layers[layer_id]\n            self._layers = layers\n        self.call_js_method(\"removePointCloudLayer\", layer_id)\n\n    # -------------------------------------------------------------------------\n    # LiDAR Layers (maplibre-gl-lidar)\n    # -------------------------------------------------------------------------\n\n    def add_lidar_control(\n        self,\n        position: str = \"top-right\",\n        collapsed: bool = True,\n        title: str = \"LiDAR Viewer\",\n        point_size: float = 2,\n        opacity: float = 1.0,\n        color_scheme: str = \"elevation\",\n        use_percentile: bool = True,\n        point_budget: int = 1000000,\n        pickable: bool = False,\n        auto_zoom: bool = True,\n        copc_loading_mode: Optional[str] = None,\n        streaming_point_budget: int = 5000000,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add an interactive LiDAR control panel.\n\n        The LiDAR control provides a UI panel for loading, visualizing, and\n        styling LiDAR point cloud files (LAS, LAZ, COPC formats).\n\n        Args:\n            position: Control position ('top-left', 'top-right', 'bottom-left', 'bottom-right').\n            collapsed: Whether the panel starts collapsed.\n            title: Title displayed on the panel.\n            point_size: Point size in pixels.\n            opacity: Layer opacity (0-1).\n            color_scheme: Color scheme ('elevation', 'intensity', 'classification', 'rgb').\n            use_percentile: Use 2-98% percentile for color scaling.\n            point_budget: Maximum number of points to display.\n            pickable: Enable hover/click interactions.\n            auto_zoom: Auto-zoom to point cloud after loading.\n            copc_loading_mode: COPC loading mode ('full' or 'dynamic').\n            streaming_point_budget: Point budget for streaming mode.\n            **kwargs: Additional control options.\n\n        Example:\n            &gt;&gt;&gt; from anymap_ts import MapboxMap\n            &gt;&gt;&gt; m = MapboxMap(pitch=60)\n            &gt;&gt;&gt; m.add_lidar_control(color_scheme=\"classification\", pickable=True)\n        \"\"\"\n        self.call_js_method(\n            \"addLidarControl\",\n            position=position,\n            collapsed=collapsed,\n            title=title,\n            pointSize=point_size,\n            opacity=opacity,\n            colorScheme=color_scheme,\n            usePercentile=use_percentile,\n            pointBudget=point_budget,\n            pickable=pickable,\n            autoZoom=auto_zoom,\n            copcLoadingMode=copc_loading_mode,\n            streamingPointBudget=streaming_point_budget,\n            **kwargs,\n        )\n        self._controls = {\n            **self._controls,\n            \"lidar-control\": {\"position\": position, \"collapsed\": collapsed},\n        }\n\n    def add_lidar_layer(\n        self,\n        source: Union[str, Path],\n        name: Optional[str] = None,\n        color_scheme: str = \"elevation\",\n        point_size: float = 2,\n        opacity: float = 1.0,\n        pickable: bool = True,\n        auto_zoom: bool = True,\n        streaming_mode: bool = True,\n        point_budget: int = 1000000,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Load and display a LiDAR file from URL or local path.\n\n        Supports LAS, LAZ, and COPC (Cloud-Optimized Point Cloud) formats.\n        For local files, the file is read and sent as base64 to JavaScript.\n        For URLs, the data is loaded directly via streaming when possible.\n\n        Args:\n            source: URL or local file path to the LiDAR file.\n            name: Layer identifier. If None, auto-generated.\n            color_scheme: Color scheme ('elevation', 'intensity', 'classification', 'rgb').\n            point_size: Point size in pixels.\n            opacity: Layer opacity (0-1).\n            pickable: Enable hover/click interactions.\n            auto_zoom: Auto-zoom to point cloud after loading.\n            streaming_mode: Use streaming mode for large COPC files.\n            point_budget: Maximum number of points to display.\n            **kwargs: Additional layer options.\n\n        Example:\n            &gt;&gt;&gt; from anymap_ts import MapboxMap\n            &gt;&gt;&gt; m = MapboxMap(center=[-123.07, 44.05], zoom=14, pitch=60)\n            &gt;&gt;&gt; m.add_lidar_layer(\n            ...     source=\"https://s3.amazonaws.com/hobu-lidar/autzen-classified.copc.laz\",\n            ...     name=\"autzen\",\n            ...     color_scheme=\"classification\",\n            ... )\n        \"\"\"\n        import base64\n\n        layer_id = name or f\"lidar-{len(self._layers)}\"\n\n        # Check if source is a local file\n        source_path = Path(source) if isinstance(source, (str, Path)) else None\n        is_local = source_path is not None and source_path.exists()\n\n        if is_local:\n            # Read local file and encode as base64\n            with open(source_path, \"rb\") as f:\n                file_data = f.read()\n            source_b64 = base64.b64encode(file_data).decode(\"utf-8\")\n\n            self.call_js_method(\n                \"addLidarLayer\",\n                source=source_b64,\n                name=layer_id,\n                isBase64=True,\n                filename=source_path.name,\n                colorScheme=color_scheme,\n                pointSize=point_size,\n                opacity=opacity,\n                pickable=pickable,\n                autoZoom=auto_zoom,\n                streamingMode=streaming_mode,\n                pointBudget=point_budget,\n                **kwargs,\n            )\n        else:\n            # Load from URL\n            self.call_js_method(\n                \"addLidarLayer\",\n                source=str(source),\n                name=layer_id,\n                isBase64=False,\n                colorScheme=color_scheme,\n                pointSize=point_size,\n                opacity=opacity,\n                pickable=pickable,\n                autoZoom=auto_zoom,\n                streamingMode=streaming_mode,\n                pointBudget=point_budget,\n                **kwargs,\n            )\n\n        self._layers = {\n            **self._layers,\n            layer_id: {\n                \"id\": layer_id,\n                \"type\": \"lidar\",\n                \"source\": str(source),\n            },\n        }\n\n    def remove_lidar_layer(self, layer_id: Optional[str] = None) -&gt; None:\n        \"\"\"Remove a LiDAR layer.\n\n        Args:\n            layer_id: Layer identifier to remove. If None, removes all LiDAR layers.\n        \"\"\"\n        if layer_id:\n            if layer_id in self._layers:\n                layers = dict(self._layers)\n                del layers[layer_id]\n                self._layers = layers\n            self.call_js_method(\"removeLidarLayer\", id=layer_id)\n        else:\n            # Remove all lidar layers\n            layers = dict(self._layers)\n            self._layers = {k: v for k, v in layers.items() if v.get(\"type\") != \"lidar\"}\n            self.call_js_method(\"removeLidarLayer\")\n\n    def set_lidar_color_scheme(self, color_scheme: str) -&gt; None:\n        \"\"\"Set the LiDAR color scheme.\n\n        Args:\n            color_scheme: Color scheme ('elevation', 'intensity', 'classification', 'rgb').\n        \"\"\"\n        self.call_js_method(\"setLidarColorScheme\", colorScheme=color_scheme)\n\n    def set_lidar_point_size(self, point_size: float) -&gt; None:\n        \"\"\"Set the LiDAR point size.\n\n        Args:\n            point_size: Point size in pixels.\n        \"\"\"\n        self.call_js_method(\"setLidarPointSize\", pointSize=point_size)\n\n    def set_lidar_opacity(self, opacity: float) -&gt; None:\n        \"\"\"Set the LiDAR layer opacity.\n\n        Args:\n            opacity: Opacity value between 0 and 1.\n        \"\"\"\n        self.call_js_method(\"setLidarOpacity\", opacity=opacity)\n\n    def _process_deck_data(self, data: Any) -&gt; Any:\n        \"\"\"Process data for deck.gl layers.\n\n        Handles GeoDataFrame, file paths, GeoJSON, and list of dicts.\n\n        Args:\n            data: Input data in various formats.\n\n        Returns:\n            Processed data suitable for deck.gl layers.\n        \"\"\"\n        # Handle GeoDataFrame\n        if hasattr(data, \"__geo_interface__\"):\n            return data.__geo_interface__\n\n        # Handle file paths\n        if isinstance(data, (str, Path)):\n            path = Path(data)\n            if path.exists():\n                try:\n                    import geopandas as gpd\n\n                    gdf = gpd.read_file(path)\n                    return gdf.__geo_interface__\n                except ImportError:\n                    pass\n\n        # Return as-is for lists, dicts, etc.\n        return data\n\n    # -------------------------------------------------------------------------\n    # Terrain Methods (Mapbox-specific)\n    # -------------------------------------------------------------------------\n\n    def add_terrain(\n        self, exaggeration: float = 1.0, source: str = \"mapbox-dem\"\n    ) -&gt; None:\n        \"\"\"Add 3D terrain to the map.\n\n        Args:\n            exaggeration: Terrain exaggeration factor.\n            source: Terrain source ID.\n        \"\"\"\n        self.call_js_method(\"addTerrain\", source=source, exaggeration=exaggeration)\n\n    def remove_terrain(self) -&gt; None:\n        \"\"\"Remove 3D terrain from the map.\"\"\"\n        self.call_js_method(\"removeTerrain\")\n\n    # -------------------------------------------------------------------------\n    # Layer Management\n    # -------------------------------------------------------------------------\n\n    def add_layer(\n        self,\n        layer_id: str,\n        layer_type: str,\n        source: Union[str, Dict],\n        paint: Optional[Dict] = None,\n        layout: Optional[Dict] = None,\n        before_id: Optional[str] = None,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a generic layer to the map.\n\n        Args:\n            layer_id: Unique layer identifier.\n            layer_type: Mapbox layer type.\n            source: Source ID or source configuration dict.\n            paint: Paint properties.\n            layout: Layout properties.\n            before_id: ID of layer to insert before.\n            **kwargs: Additional layer options.\n        \"\"\"\n        layer_config = {\n            \"id\": layer_id,\n            \"type\": layer_type,\n            \"paint\": paint or {},\n            \"layout\": layout or {},\n            **kwargs,\n        }\n\n        if isinstance(source, str):\n            layer_config[\"source\"] = source\n        else:\n            source_id = f\"{layer_id}-source\"\n            self._sources = {**self._sources, source_id: source}\n            self.call_js_method(\"addSource\", source_id, **source)\n            layer_config[\"source\"] = source_id\n\n        self._layers = {**self._layers, layer_id: layer_config}\n        self.call_js_method(\"addLayer\", beforeId=before_id, **layer_config)\n\n    def remove_layer(self, layer_id: str) -&gt; None:\n        \"\"\"Remove a layer from the map.\n\n        Args:\n            layer_id: Layer identifier to remove.\n        \"\"\"\n        if layer_id in self._layers:\n            layers = dict(self._layers)\n            del layers[layer_id]\n            self._layers = layers\n        self.call_js_method(\"removeLayer\", layer_id)\n\n    def set_visibility(self, layer_id: str, visible: bool) -&gt; None:\n        \"\"\"Set layer visibility.\n\n        Args:\n            layer_id: Layer identifier.\n            visible: Whether layer should be visible.\n        \"\"\"\n        self.call_js_method(\"setVisibility\", layer_id, visible)\n\n    def set_opacity(self, layer_id: str, opacity: float) -&gt; None:\n        \"\"\"Set layer opacity.\n\n        Args:\n            layer_id: Layer identifier.\n            opacity: Opacity value between 0 and 1.\n        \"\"\"\n        self.call_js_method(\"setOpacity\", layer_id, opacity)\n\n    # -------------------------------------------------------------------------\n    # Controls\n    # -------------------------------------------------------------------------\n\n    def add_control(\n        self,\n        control_type: str,\n        position: str = \"top-right\",\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a map control.\n\n        Args:\n            control_type: Type of control ('navigation', 'scale', 'fullscreen', etc.).\n            position: Control position.\n            **kwargs: Control-specific options.\n        \"\"\"\n        self.call_js_method(\"addControl\", control_type, position=position, **kwargs)\n        self._controls = {\n            **self._controls,\n            control_type: {\"type\": control_type, \"position\": position, **kwargs},\n        }\n\n    def remove_control(self, control_type: str) -&gt; None:\n        \"\"\"Remove a map control.\n\n        Args:\n            control_type: Type of control to remove.\n        \"\"\"\n        self.call_js_method(\"removeControl\", control_type)\n        if control_type in self._controls:\n            controls = dict(self._controls)\n            del controls[control_type]\n            self._controls = controls\n\n    # -------------------------------------------------------------------------\n    # Markers\n    # -------------------------------------------------------------------------\n\n    def add_marker(\n        self,\n        lng: float,\n        lat: float,\n        color: str = \"#3388ff\",\n        popup: Optional[str] = None,\n        marker_id: Optional[str] = None,\n    ) -&gt; None:\n        \"\"\"Add a marker to the map.\n\n        Args:\n            lng: Longitude.\n            lat: Latitude.\n            color: Marker color.\n            popup: HTML content for popup.\n            marker_id: Unique marker ID.\n        \"\"\"\n        self.call_js_method(\n            \"addMarker\", lng, lat, color=color, popup=popup, id=marker_id\n        )\n\n    def remove_marker(self, marker_id: str) -&gt; None:\n        \"\"\"Remove a marker from the map.\n\n        Args:\n            marker_id: Marker ID to remove.\n        \"\"\"\n        self.call_js_method(\"removeMarker\", marker_id)\n\n    # -------------------------------------------------------------------------\n    # HTML Export\n    # -------------------------------------------------------------------------\n\n    def _generate_html_template(self) -&gt; str:\n        \"\"\"Generate standalone HTML for the map.\"\"\"\n        template_path = Path(__file__).parent / \"templates\" / \"mapbox.html\"\n\n        if template_path.exists():\n            template = template_path.read_text(encoding=\"utf-8\")\n        else:\n            template = self._get_default_template()\n\n        # Serialize state\n        state = {\n            \"center\": self.center,\n            \"zoom\": self.zoom,\n            \"style\": self.style,\n            \"bearing\": self.bearing,\n            \"pitch\": self.pitch,\n            \"width\": self.width,\n            \"height\": self.height,\n            \"layers\": self._layers,\n            \"sources\": self._sources,\n            \"controls\": self._controls,\n            \"js_calls\": self._js_calls,\n            \"access_token\": self.access_token,\n        }\n\n        template = template.replace(\"{{state}}\", json.dumps(state, indent=2))\n        return template\n\n    def _get_default_template(self) -&gt; str:\n        \"\"\"Get default HTML template.\"\"\"\n        return \"\"\"&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n    &lt;meta charset=\"utf-8\"&gt;\n    &lt;title&gt;{{title}}&lt;/title&gt;\n    &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"&gt;\n    &lt;script src=\"https://api.mapbox.com/mapbox-gl-js/v3.0.0/mapbox-gl.js\"&gt;&lt;/script&gt;\n    &lt;link href=\"https://api.mapbox.com/mapbox-gl-js/v3.0.0/mapbox-gl.css\" rel=\"stylesheet\" /&gt;\n    &lt;style&gt;\n        body { margin: 0; padding: 0; }\n        #map { position: absolute; top: 0; bottom: 0; width: 100%; }\n    &lt;/style&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;div id=\"map\"&gt;&lt;/div&gt;\n    &lt;script&gt;\n        const state = {{state}};\n\n        mapboxgl.accessToken = state.access_token;\n\n        const map = new mapboxgl.Map({\n            container: 'map',\n            style: state.style,\n            center: state.center,\n            zoom: state.zoom,\n            bearing: state.bearing || 0,\n            pitch: state.pitch || 0\n        });\n\n        map.on('load', function() {\n            // Replay JS calls\n            for (const call of state.js_calls || []) {\n                try {\n                    executeMethod(call.method, call.args, call.kwargs);\n                } catch (e) {\n                    console.error('Error executing', call.method, e);\n                }\n            }\n        });\n\n        function executeMethod(method, args, kwargs) {\n            switch (method) {\n                case 'addBasemap':\n                    const url = args[0];\n                    const name = kwargs.name || 'basemap';\n                    const sourceId = 'basemap-' + name;\n                    if (!map.getSource(sourceId)) {\n                        map.addSource(sourceId, {\n                            type: 'raster',\n                            tiles: [url],\n                            tileSize: 256,\n                            attribution: kwargs.attribution || ''\n                        });\n                    }\n                    if (!map.getLayer(sourceId)) {\n                        map.addLayer({\n                            id: sourceId,\n                            type: 'raster',\n                            source: sourceId\n                        });\n                    }\n                    break;\n\n                case 'addGeoJSON':\n                    const layerName = kwargs.name;\n                    const sourceIdGeo = layerName + '-source';\n                    if (!map.getSource(sourceIdGeo)) {\n                        map.addSource(sourceIdGeo, {\n                            type: 'geojson',\n                            data: kwargs.data\n                        });\n                    }\n                    if (!map.getLayer(layerName)) {\n                        map.addLayer({\n                            id: layerName,\n                            type: kwargs.layerType || 'circle',\n                            source: sourceIdGeo,\n                            paint: kwargs.paint || {}\n                        });\n                    }\n                    if (kwargs.fitBounds &amp;&amp; kwargs.bounds) {\n                        map.fitBounds([\n                            [kwargs.bounds[0], kwargs.bounds[1]],\n                            [kwargs.bounds[2], kwargs.bounds[3]]\n                        ], { padding: 50 });\n                    }\n                    break;\n\n                case 'addTileLayer':\n                    const tileUrl = args[0];\n                    const tileName = kwargs.name;\n                    const tileSourceId = tileName + '-source';\n                    if (!map.getSource(tileSourceId)) {\n                        map.addSource(tileSourceId, {\n                            type: 'raster',\n                            tiles: [tileUrl],\n                            tileSize: 256,\n                            attribution: kwargs.attribution || ''\n                        });\n                    }\n                    if (!map.getLayer(tileName)) {\n                        map.addLayer({\n                            id: tileName,\n                            type: 'raster',\n                            source: tileSourceId\n                        });\n                    }\n                    break;\n\n                case 'addControl':\n                    const controlType = args[0];\n                    const position = kwargs.position || 'top-right';\n                    let control;\n                    switch (controlType) {\n                        case 'navigation':\n                            control = new mapboxgl.NavigationControl();\n                            break;\n                        case 'scale':\n                            control = new mapboxgl.ScaleControl();\n                            break;\n                        case 'fullscreen':\n                            control = new mapboxgl.FullscreenControl();\n                            break;\n                    }\n                    if (control) {\n                        map.addControl(control, position);\n                    }\n                    break;\n\n                case 'addTerrain':\n                    const terrainSource = kwargs.source || 'mapbox-dem';\n                    if (!map.getSource(terrainSource)) {\n                        map.addSource(terrainSource, {\n                            type: 'raster-dem',\n                            url: 'mapbox://mapbox.mapbox-terrain-dem-v1',\n                            tileSize: 512,\n                            maxzoom: 14\n                        });\n                    }\n                    map.setTerrain({ source: terrainSource, exaggeration: kwargs.exaggeration || 1 });\n                    break;\n\n                case 'removeTerrain':\n                    map.setTerrain(null);\n                    break;\n\n                case 'flyTo':\n                    map.flyTo({\n                        center: [args[0], args[1]],\n                        zoom: kwargs.zoom,\n                        duration: kwargs.duration || 2000\n                    });\n                    break;\n\n                case 'fitBounds':\n                    const bounds = args[0];\n                    map.fitBounds([\n                        [bounds[0], bounds[1]],\n                        [bounds[2], bounds[3]]\n                    ], {\n                        padding: kwargs.padding || 50,\n                        duration: kwargs.duration || 1000\n                    });\n                    break;\n\n                case 'addMarker':\n                    new mapboxgl.Marker({ color: kwargs.color || '#3388ff' })\n                        .setLngLat([args[0], args[1]])\n                        .addTo(map);\n                    break;\n\n                default:\n                    console.log('Unknown method:', method);\n            }\n        }\n    &lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\"\"\"\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.mapbox.MapboxMap.__init__","title":"<code>__init__(self, center=(0.0, 0.0), zoom=2.0, width='100%', height='600px', style='mapbox://styles/mapbox/streets-v12', bearing=0.0, pitch=0.0, max_pitch=85.0, access_token=None, controls=None, **kwargs)</code>  <code>special</code>","text":"<p>Initialize a Mapbox map.</p> <p>Parameters:</p> Name Type Description Default <code>center</code> <code>Tuple[float, float]</code> <p>Map center as (longitude, latitude).</p> <code>(0.0, 0.0)</code> <code>zoom</code> <code>float</code> <p>Initial zoom level.</p> <code>2.0</code> <code>width</code> <code>str</code> <p>Map width as CSS string.</p> <code>'100%'</code> <code>height</code> <code>str</code> <p>Map height as CSS string.</p> <code>'600px'</code> <code>style</code> <code>str</code> <p>Mapbox style URL (e.g., \"mapbox://styles/mapbox/streets-v12\").</p> <code>'mapbox://styles/mapbox/streets-v12'</code> <code>bearing</code> <code>float</code> <p>Map bearing in degrees.</p> <code>0.0</code> <code>pitch</code> <code>float</code> <p>Map pitch in degrees.</p> <code>0.0</code> <code>max_pitch</code> <code>float</code> <p>Maximum pitch angle in degrees (default: 85).</p> <code>85.0</code> <code>access_token</code> <code>Optional[str]</code> <p>Mapbox access token. If None, reads from MAPBOX_TOKEN env var.</p> <code>None</code> <code>controls</code> <code>Optional[Dict[str, Any]]</code> <p>Dict of controls to add (e.g., {\"navigation\": True}).</p> <code>None</code> <code>**kwargs</code> <p>Additional widget arguments.</p> <code>{}</code> Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def __init__(\n    self,\n    center: Tuple[float, float] = (0.0, 0.0),\n    zoom: float = 2.0,\n    width: str = \"100%\",\n    height: str = \"600px\",\n    style: str = \"mapbox://styles/mapbox/streets-v12\",\n    bearing: float = 0.0,\n    pitch: float = 0.0,\n    max_pitch: float = 85.0,\n    access_token: Optional[str] = None,\n    controls: Optional[Dict[str, Any]] = None,\n    **kwargs,\n):\n    \"\"\"Initialize a Mapbox map.\n\n    Args:\n        center: Map center as (longitude, latitude).\n        zoom: Initial zoom level.\n        width: Map width as CSS string.\n        height: Map height as CSS string.\n        style: Mapbox style URL (e.g., \"mapbox://styles/mapbox/streets-v12\").\n        bearing: Map bearing in degrees.\n        pitch: Map pitch in degrees.\n        max_pitch: Maximum pitch angle in degrees (default: 85).\n        access_token: Mapbox access token. If None, reads from MAPBOX_TOKEN env var.\n        controls: Dict of controls to add (e.g., {\"navigation\": True}).\n        **kwargs: Additional widget arguments.\n    \"\"\"\n    # Get access token\n    token = access_token or get_mapbox_token()\n    if not token:\n        print(\n            \"Warning: No Mapbox access token provided. \"\n            \"Set MAPBOX_TOKEN environment variable or pass access_token parameter.\"\n        )\n\n    super().__init__(\n        center=list(center),\n        zoom=zoom,\n        width=width,\n        height=height,\n        style=style,\n        bearing=bearing,\n        pitch=pitch,\n        max_pitch=max_pitch,\n        access_token=token,\n        **kwargs,\n    )\n\n    # Initialize layer dictionary\n    self._layer_dict = {\"Background\": []}\n\n    # Add default controls\n    if controls is None:\n        controls = {\"navigation\": True, \"fullscreen\": True}\n\n    for control_name, config in controls.items():\n        if config:\n            self.add_control(\n                control_name, **(config if isinstance(config, dict) else {})\n            )\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.mapbox.MapboxMap.add_arc_layer","title":"<code>add_arc_layer(self, data, name=None, get_source_position='source', get_target_position='target', get_source_color=None, get_target_color=None, get_width=1, get_height=1, great_circle=False, pickable=True, opacity=0.8, **kwargs)</code>","text":"<p>Add an arc layer for origin-destination visualization using deck.gl.</p> <p>Arc layers are ideal for visualizing connections between locations, such as flight routes, migration patterns, or network flows.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>Array of data objects with source/target coordinates. Each object should have source and target positions.</p> required <code>name</code> <code>Optional[str]</code> <p>Layer ID. If None, auto-generated.</p> <code>None</code> <code>get_source_position</code> <code>Union[str, Any]</code> <p>Accessor for source position [lng, lat]. Can be a string (property name) or a value.</p> <code>'source'</code> <code>get_target_position</code> <code>Union[str, Any]</code> <p>Accessor for target position [lng, lat]. Can be a string (property name) or a value.</p> <code>'target'</code> <code>get_source_color</code> <code>Optional[List[int]]</code> <p>Source end color as [r, g, b, a]. Default: [51, 136, 255, 255] (blue).</p> <code>None</code> <code>get_target_color</code> <code>Optional[List[int]]</code> <p>Target end color as [r, g, b, a]. Default: [255, 136, 51, 255] (orange).</p> <code>None</code> <code>get_width</code> <code>Union[float, str]</code> <p>Arc width in pixels. Can be a number or accessor.</p> <code>1</code> <code>get_height</code> <code>float</code> <p>Arc height multiplier. Higher values create more curved arcs.</p> <code>1</code> <code>great_circle</code> <code>bool</code> <p>Whether to draw arcs along great circles.</p> <code>False</code> <code>pickable</code> <code>bool</code> <p>Whether layer responds to hover/click events.</p> <code>True</code> <code>opacity</code> <code>float</code> <p>Layer opacity (0-1).</p> <code>0.8</code> <code>**kwargs</code> <p>Additional ArcLayer props.</p> <code>{}</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from anymap_ts import MapboxMap\n&gt;&gt;&gt; m = MapboxMap()\n&gt;&gt;&gt; arcs = [\n...     {\"source\": [-122.4, 37.8], \"target\": [-73.9, 40.7]},\n...     {\"source\": [-122.4, 37.8], \"target\": [-0.1, 51.5]},\n... ]\n&gt;&gt;&gt; m.add_arc_layer(arcs, name=\"flights\")\n</code></pre> Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def add_arc_layer(\n    self,\n    data: Any,\n    name: Optional[str] = None,\n    get_source_position: Union[str, Any] = \"source\",\n    get_target_position: Union[str, Any] = \"target\",\n    get_source_color: Optional[List[int]] = None,\n    get_target_color: Optional[List[int]] = None,\n    get_width: Union[float, str] = 1,\n    get_height: float = 1,\n    great_circle: bool = False,\n    pickable: bool = True,\n    opacity: float = 0.8,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add an arc layer for origin-destination visualization using deck.gl.\n\n    Arc layers are ideal for visualizing connections between locations,\n    such as flight routes, migration patterns, or network flows.\n\n    Args:\n        data: Array of data objects with source/target coordinates.\n            Each object should have source and target positions.\n        name: Layer ID. If None, auto-generated.\n        get_source_position: Accessor for source position [lng, lat].\n            Can be a string (property name) or a value.\n        get_target_position: Accessor for target position [lng, lat].\n            Can be a string (property name) or a value.\n        get_source_color: Source end color as [r, g, b, a].\n            Default: [51, 136, 255, 255] (blue).\n        get_target_color: Target end color as [r, g, b, a].\n            Default: [255, 136, 51, 255] (orange).\n        get_width: Arc width in pixels. Can be a number or accessor.\n        get_height: Arc height multiplier. Higher values create more curved arcs.\n        great_circle: Whether to draw arcs along great circles.\n        pickable: Whether layer responds to hover/click events.\n        opacity: Layer opacity (0-1).\n        **kwargs: Additional ArcLayer props.\n\n    Example:\n        &gt;&gt;&gt; from anymap_ts import MapboxMap\n        &gt;&gt;&gt; m = MapboxMap()\n        &gt;&gt;&gt; arcs = [\n        ...     {\"source\": [-122.4, 37.8], \"target\": [-73.9, 40.7]},\n        ...     {\"source\": [-122.4, 37.8], \"target\": [-0.1, 51.5]},\n        ... ]\n        &gt;&gt;&gt; m.add_arc_layer(arcs, name=\"flights\")\n    \"\"\"\n    layer_id = name or f\"arc-{len(self._layers)}\"\n    processed_data = self._process_deck_data(data)\n\n    self.call_js_method(\n        \"addArcLayer\",\n        id=layer_id,\n        data=processed_data,\n        getSourcePosition=get_source_position,\n        getTargetPosition=get_target_position,\n        getSourceColor=get_source_color or [51, 136, 255, 255],\n        getTargetColor=get_target_color or [255, 136, 51, 255],\n        getWidth=get_width,\n        getHeight=get_height,\n        greatCircle=great_circle,\n        pickable=pickable,\n        opacity=opacity,\n        **kwargs,\n    )\n\n    self._layers = {\n        **self._layers,\n        layer_id: {\n            \"id\": layer_id,\n            \"type\": \"arc\",\n        },\n    }\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.mapbox.MapboxMap.add_basemap","title":"<code>add_basemap(self, basemap='mapbox://styles/mapbox/streets-v12', attribution=None, **kwargs)</code>","text":"<p>Add a basemap layer.</p> <p>For Mapbox styles, use the style URL format: - \"mapbox://styles/mapbox/streets-v12\" - \"mapbox://styles/mapbox/satellite-v9\" - \"mapbox://styles/mapbox/satellite-streets-v12\" - \"mapbox://styles/mapbox/light-v11\" - \"mapbox://styles/mapbox/dark-v11\" - \"mapbox://styles/mapbox/outdoors-v12\"</p> <p>Or use XYZ tile URLs for custom basemaps.</p> <p>Parameters:</p> Name Type Description Default <code>basemap</code> <code>str</code> <p>Mapbox style URL or XYZ tile URL.</p> <code>'mapbox://styles/mapbox/streets-v12'</code> <code>attribution</code> <code>Optional[str]</code> <p>Custom attribution text.</p> <code>None</code> <code>**kwargs</code> <p>Additional options.</p> <code>{}</code> Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def add_basemap(\n    self,\n    basemap: str = \"mapbox://styles/mapbox/streets-v12\",\n    attribution: Optional[str] = None,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a basemap layer.\n\n    For Mapbox styles, use the style URL format:\n    - \"mapbox://styles/mapbox/streets-v12\"\n    - \"mapbox://styles/mapbox/satellite-v9\"\n    - \"mapbox://styles/mapbox/satellite-streets-v12\"\n    - \"mapbox://styles/mapbox/light-v11\"\n    - \"mapbox://styles/mapbox/dark-v11\"\n    - \"mapbox://styles/mapbox/outdoors-v12\"\n\n    Or use XYZ tile URLs for custom basemaps.\n\n    Args:\n        basemap: Mapbox style URL or XYZ tile URL.\n        attribution: Custom attribution text.\n        **kwargs: Additional options.\n    \"\"\"\n    # If it's a Mapbox style URL, set it as the map style\n    if basemap.startswith(\"mapbox://\"):\n        self.style = basemap\n        return\n\n    # Otherwise, treat as XYZ tile URL\n    try:\n        url, default_attribution = get_basemap_url(basemap)\n    except (ValueError, KeyError):\n        url = basemap\n        default_attribution = \"\"\n\n    self.call_js_method(\n        \"addBasemap\",\n        url,\n        attribution=attribution or default_attribution,\n        name=basemap,\n        **kwargs,\n    )\n\n    # Track in layer dict\n    basemaps = self._layer_dict.get(\"Basemaps\", [])\n    if basemap not in basemaps:\n        self._layer_dict = {\n            **self._layer_dict,\n            \"Basemaps\": basemaps + [basemap],\n        }\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.mapbox.MapboxMap.add_cog_layer","title":"<code>add_cog_layer(self, url, name=None, opacity=1.0, visible=True, debug=False, debug_opacity=0.25, max_error=0.125, fit_bounds=True, before_id=None, **kwargs)</code>","text":"<p>Add a Cloud Optimized GeoTIFF (COG) layer using deck.gl-raster.</p> <p>This method renders COG files directly in the browser using GPU-accelerated deck.gl rendering with automatic reprojection support.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>URL to the Cloud Optimized GeoTIFF file.</p> required <code>name</code> <code>Optional[str]</code> <p>Layer ID. If None, auto-generated.</p> <code>None</code> <code>opacity</code> <code>float</code> <p>Layer opacity (0-1).</p> <code>1.0</code> <code>visible</code> <code>bool</code> <p>Whether layer is visible.</p> <code>True</code> <code>debug</code> <code>bool</code> <p>Show reprojection mesh for debugging.</p> <code>False</code> <code>debug_opacity</code> <code>float</code> <p>Opacity of debug mesh (0-1).</p> <code>0.25</code> <code>max_error</code> <code>float</code> <p>Maximum reprojection error in pixels. Lower values create denser mesh for better accuracy.</p> <code>0.125</code> <code>fit_bounds</code> <code>bool</code> <p>Whether to fit map to COG bounds after loading.</p> <code>True</code> <code>before_id</code> <code>Optional[str]</code> <p>ID of layer to insert before.</p> <code>None</code> <code>**kwargs</code> <p>Additional COGLayer props.</p> <code>{}</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from anymap_ts import MapboxMap\n&gt;&gt;&gt; m = MapboxMap()\n&gt;&gt;&gt; m.add_cog_layer(\n...     \"https://example.com/landcover.tif\",\n...     name=\"landcover\",\n...     opacity=0.8\n... )\n</code></pre> Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def add_cog_layer(\n    self,\n    url: str,\n    name: Optional[str] = None,\n    opacity: float = 1.0,\n    visible: bool = True,\n    debug: bool = False,\n    debug_opacity: float = 0.25,\n    max_error: float = 0.125,\n    fit_bounds: bool = True,\n    before_id: Optional[str] = None,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a Cloud Optimized GeoTIFF (COG) layer using deck.gl-raster.\n\n    This method renders COG files directly in the browser using GPU-accelerated\n    deck.gl rendering with automatic reprojection support.\n\n    Args:\n        url: URL to the Cloud Optimized GeoTIFF file.\n        name: Layer ID. If None, auto-generated.\n        opacity: Layer opacity (0-1).\n        visible: Whether layer is visible.\n        debug: Show reprojection mesh for debugging.\n        debug_opacity: Opacity of debug mesh (0-1).\n        max_error: Maximum reprojection error in pixels. Lower values\n            create denser mesh for better accuracy.\n        fit_bounds: Whether to fit map to COG bounds after loading.\n        before_id: ID of layer to insert before.\n        **kwargs: Additional COGLayer props.\n\n    Example:\n        &gt;&gt;&gt; from anymap_ts import MapboxMap\n        &gt;&gt;&gt; m = MapboxMap()\n        &gt;&gt;&gt; m.add_cog_layer(\n        ...     \"https://example.com/landcover.tif\",\n        ...     name=\"landcover\",\n        ...     opacity=0.8\n        ... )\n    \"\"\"\n    layer_id = name or f\"cog-{len(self._layers)}\"\n\n    self.call_js_method(\n        \"addCOGLayer\",\n        id=layer_id,\n        geotiff=url,\n        opacity=opacity,\n        visible=visible,\n        debug=debug,\n        debugOpacity=debug_opacity,\n        maxError=max_error,\n        fitBounds=fit_bounds,\n        beforeId=before_id,\n        **kwargs,\n    )\n\n    self._layers = {\n        **self._layers,\n        layer_id: {\n            \"id\": layer_id,\n            \"type\": \"cog\",\n            \"url\": url,\n        },\n    }\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.mapbox.MapboxMap.add_control","title":"<code>add_control(self, control_type, position='top-right', **kwargs)</code>","text":"<p>Add a map control.</p> <p>Parameters:</p> Name Type Description Default <code>control_type</code> <code>str</code> <p>Type of control ('navigation', 'scale', 'fullscreen', etc.).</p> required <code>position</code> <code>str</code> <p>Control position.</p> <code>'top-right'</code> <code>**kwargs</code> <p>Control-specific options.</p> <code>{}</code> Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def add_control(\n    self,\n    control_type: str,\n    position: str = \"top-right\",\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a map control.\n\n    Args:\n        control_type: Type of control ('navigation', 'scale', 'fullscreen', etc.).\n        position: Control position.\n        **kwargs: Control-specific options.\n    \"\"\"\n    self.call_js_method(\"addControl\", control_type, position=position, **kwargs)\n    self._controls = {\n        **self._controls,\n        control_type: {\"type\": control_type, \"position\": position, **kwargs},\n    }\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.mapbox.MapboxMap.add_geojson","title":"<code>add_geojson(self, data, layer_type=None, paint=None, name=None, fit_bounds=True, **kwargs)</code>","text":"<p>Add GeoJSON data to the map.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Union[str, Dict]</code> <p>GeoJSON dict or URL to GeoJSON file.</p> required <code>layer_type</code> <code>Optional[str]</code> <p>Mapbox layer type.</p> <code>None</code> <code>paint</code> <code>Optional[Dict]</code> <p>Mapbox paint properties.</p> <code>None</code> <code>name</code> <code>Optional[str]</code> <p>Layer name.</p> <code>None</code> <code>fit_bounds</code> <code>bool</code> <p>Whether to fit map to data bounds.</p> <code>True</code> <code>**kwargs</code> <p>Additional layer options.</p> <code>{}</code> Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def add_geojson(\n    self,\n    data: Union[str, Dict],\n    layer_type: Optional[str] = None,\n    paint: Optional[Dict] = None,\n    name: Optional[str] = None,\n    fit_bounds: bool = True,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add GeoJSON data to the map.\n\n    Args:\n        data: GeoJSON dict or URL to GeoJSON file.\n        layer_type: Mapbox layer type.\n        paint: Mapbox paint properties.\n        name: Layer name.\n        fit_bounds: Whether to fit map to data bounds.\n        **kwargs: Additional layer options.\n    \"\"\"\n    self.add_vector(\n        data,\n        layer_type=layer_type,\n        paint=paint,\n        name=name,\n        fit_bounds=fit_bounds,\n        **kwargs,\n    )\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.mapbox.MapboxMap.add_layer","title":"<code>add_layer(self, layer_id, layer_type, source, paint=None, layout=None, before_id=None, **kwargs)</code>","text":"<p>Add a generic layer to the map.</p> <p>Parameters:</p> Name Type Description Default <code>layer_id</code> <code>str</code> <p>Unique layer identifier.</p> required <code>layer_type</code> <code>str</code> <p>Mapbox layer type.</p> required <code>source</code> <code>Union[str, Dict]</code> <p>Source ID or source configuration dict.</p> required <code>paint</code> <code>Optional[Dict]</code> <p>Paint properties.</p> <code>None</code> <code>layout</code> <code>Optional[Dict]</code> <p>Layout properties.</p> <code>None</code> <code>before_id</code> <code>Optional[str]</code> <p>ID of layer to insert before.</p> <code>None</code> <code>**kwargs</code> <p>Additional layer options.</p> <code>{}</code> Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def add_layer(\n    self,\n    layer_id: str,\n    layer_type: str,\n    source: Union[str, Dict],\n    paint: Optional[Dict] = None,\n    layout: Optional[Dict] = None,\n    before_id: Optional[str] = None,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a generic layer to the map.\n\n    Args:\n        layer_id: Unique layer identifier.\n        layer_type: Mapbox layer type.\n        source: Source ID or source configuration dict.\n        paint: Paint properties.\n        layout: Layout properties.\n        before_id: ID of layer to insert before.\n        **kwargs: Additional layer options.\n    \"\"\"\n    layer_config = {\n        \"id\": layer_id,\n        \"type\": layer_type,\n        \"paint\": paint or {},\n        \"layout\": layout or {},\n        **kwargs,\n    }\n\n    if isinstance(source, str):\n        layer_config[\"source\"] = source\n    else:\n        source_id = f\"{layer_id}-source\"\n        self._sources = {**self._sources, source_id: source}\n        self.call_js_method(\"addSource\", source_id, **source)\n        layer_config[\"source\"] = source_id\n\n    self._layers = {**self._layers, layer_id: layer_config}\n    self.call_js_method(\"addLayer\", beforeId=before_id, **layer_config)\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.mapbox.MapboxMap.add_lidar_control","title":"<code>add_lidar_control(self, position='top-right', collapsed=True, title='LiDAR Viewer', point_size=2, opacity=1.0, color_scheme='elevation', use_percentile=True, point_budget=1000000, pickable=False, auto_zoom=True, copc_loading_mode=None, streaming_point_budget=5000000, **kwargs)</code>","text":"<p>Add an interactive LiDAR control panel.</p> <p>The LiDAR control provides a UI panel for loading, visualizing, and styling LiDAR point cloud files (LAS, LAZ, COPC formats).</p> <p>Parameters:</p> Name Type Description Default <code>position</code> <code>str</code> <p>Control position ('top-left', 'top-right', 'bottom-left', 'bottom-right').</p> <code>'top-right'</code> <code>collapsed</code> <code>bool</code> <p>Whether the panel starts collapsed.</p> <code>True</code> <code>title</code> <code>str</code> <p>Title displayed on the panel.</p> <code>'LiDAR Viewer'</code> <code>point_size</code> <code>float</code> <p>Point size in pixels.</p> <code>2</code> <code>opacity</code> <code>float</code> <p>Layer opacity (0-1).</p> <code>1.0</code> <code>color_scheme</code> <code>str</code> <p>Color scheme ('elevation', 'intensity', 'classification', 'rgb').</p> <code>'elevation'</code> <code>use_percentile</code> <code>bool</code> <p>Use 2-98% percentile for color scaling.</p> <code>True</code> <code>point_budget</code> <code>int</code> <p>Maximum number of points to display.</p> <code>1000000</code> <code>pickable</code> <code>bool</code> <p>Enable hover/click interactions.</p> <code>False</code> <code>auto_zoom</code> <code>bool</code> <p>Auto-zoom to point cloud after loading.</p> <code>True</code> <code>copc_loading_mode</code> <code>Optional[str]</code> <p>COPC loading mode ('full' or 'dynamic').</p> <code>None</code> <code>streaming_point_budget</code> <code>int</code> <p>Point budget for streaming mode.</p> <code>5000000</code> <code>**kwargs</code> <p>Additional control options.</p> <code>{}</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from anymap_ts import MapboxMap\n&gt;&gt;&gt; m = MapboxMap(pitch=60)\n&gt;&gt;&gt; m.add_lidar_control(color_scheme=\"classification\", pickable=True)\n</code></pre> Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def add_lidar_control(\n    self,\n    position: str = \"top-right\",\n    collapsed: bool = True,\n    title: str = \"LiDAR Viewer\",\n    point_size: float = 2,\n    opacity: float = 1.0,\n    color_scheme: str = \"elevation\",\n    use_percentile: bool = True,\n    point_budget: int = 1000000,\n    pickable: bool = False,\n    auto_zoom: bool = True,\n    copc_loading_mode: Optional[str] = None,\n    streaming_point_budget: int = 5000000,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add an interactive LiDAR control panel.\n\n    The LiDAR control provides a UI panel for loading, visualizing, and\n    styling LiDAR point cloud files (LAS, LAZ, COPC formats).\n\n    Args:\n        position: Control position ('top-left', 'top-right', 'bottom-left', 'bottom-right').\n        collapsed: Whether the panel starts collapsed.\n        title: Title displayed on the panel.\n        point_size: Point size in pixels.\n        opacity: Layer opacity (0-1).\n        color_scheme: Color scheme ('elevation', 'intensity', 'classification', 'rgb').\n        use_percentile: Use 2-98% percentile for color scaling.\n        point_budget: Maximum number of points to display.\n        pickable: Enable hover/click interactions.\n        auto_zoom: Auto-zoom to point cloud after loading.\n        copc_loading_mode: COPC loading mode ('full' or 'dynamic').\n        streaming_point_budget: Point budget for streaming mode.\n        **kwargs: Additional control options.\n\n    Example:\n        &gt;&gt;&gt; from anymap_ts import MapboxMap\n        &gt;&gt;&gt; m = MapboxMap(pitch=60)\n        &gt;&gt;&gt; m.add_lidar_control(color_scheme=\"classification\", pickable=True)\n    \"\"\"\n    self.call_js_method(\n        \"addLidarControl\",\n        position=position,\n        collapsed=collapsed,\n        title=title,\n        pointSize=point_size,\n        opacity=opacity,\n        colorScheme=color_scheme,\n        usePercentile=use_percentile,\n        pointBudget=point_budget,\n        pickable=pickable,\n        autoZoom=auto_zoom,\n        copcLoadingMode=copc_loading_mode,\n        streamingPointBudget=streaming_point_budget,\n        **kwargs,\n    )\n    self._controls = {\n        **self._controls,\n        \"lidar-control\": {\"position\": position, \"collapsed\": collapsed},\n    }\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.mapbox.MapboxMap.add_lidar_layer","title":"<code>add_lidar_layer(self, source, name=None, color_scheme='elevation', point_size=2, opacity=1.0, pickable=True, auto_zoom=True, streaming_mode=True, point_budget=1000000, **kwargs)</code>","text":"<p>Load and display a LiDAR file from URL or local path.</p> <p>Supports LAS, LAZ, and COPC (Cloud-Optimized Point Cloud) formats. For local files, the file is read and sent as base64 to JavaScript. For URLs, the data is loaded directly via streaming when possible.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>Union[str, Path]</code> <p>URL or local file path to the LiDAR file.</p> required <code>name</code> <code>Optional[str]</code> <p>Layer identifier. If None, auto-generated.</p> <code>None</code> <code>color_scheme</code> <code>str</code> <p>Color scheme ('elevation', 'intensity', 'classification', 'rgb').</p> <code>'elevation'</code> <code>point_size</code> <code>float</code> <p>Point size in pixels.</p> <code>2</code> <code>opacity</code> <code>float</code> <p>Layer opacity (0-1).</p> <code>1.0</code> <code>pickable</code> <code>bool</code> <p>Enable hover/click interactions.</p> <code>True</code> <code>auto_zoom</code> <code>bool</code> <p>Auto-zoom to point cloud after loading.</p> <code>True</code> <code>streaming_mode</code> <code>bool</code> <p>Use streaming mode for large COPC files.</p> <code>True</code> <code>point_budget</code> <code>int</code> <p>Maximum number of points to display.</p> <code>1000000</code> <code>**kwargs</code> <p>Additional layer options.</p> <code>{}</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from anymap_ts import MapboxMap\n&gt;&gt;&gt; m = MapboxMap(center=[-123.07, 44.05], zoom=14, pitch=60)\n&gt;&gt;&gt; m.add_lidar_layer(\n...     source=\"https://s3.amazonaws.com/hobu-lidar/autzen-classified.copc.laz\",\n...     name=\"autzen\",\n...     color_scheme=\"classification\",\n... )\n</code></pre> Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def add_lidar_layer(\n    self,\n    source: Union[str, Path],\n    name: Optional[str] = None,\n    color_scheme: str = \"elevation\",\n    point_size: float = 2,\n    opacity: float = 1.0,\n    pickable: bool = True,\n    auto_zoom: bool = True,\n    streaming_mode: bool = True,\n    point_budget: int = 1000000,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Load and display a LiDAR file from URL or local path.\n\n    Supports LAS, LAZ, and COPC (Cloud-Optimized Point Cloud) formats.\n    For local files, the file is read and sent as base64 to JavaScript.\n    For URLs, the data is loaded directly via streaming when possible.\n\n    Args:\n        source: URL or local file path to the LiDAR file.\n        name: Layer identifier. If None, auto-generated.\n        color_scheme: Color scheme ('elevation', 'intensity', 'classification', 'rgb').\n        point_size: Point size in pixels.\n        opacity: Layer opacity (0-1).\n        pickable: Enable hover/click interactions.\n        auto_zoom: Auto-zoom to point cloud after loading.\n        streaming_mode: Use streaming mode for large COPC files.\n        point_budget: Maximum number of points to display.\n        **kwargs: Additional layer options.\n\n    Example:\n        &gt;&gt;&gt; from anymap_ts import MapboxMap\n        &gt;&gt;&gt; m = MapboxMap(center=[-123.07, 44.05], zoom=14, pitch=60)\n        &gt;&gt;&gt; m.add_lidar_layer(\n        ...     source=\"https://s3.amazonaws.com/hobu-lidar/autzen-classified.copc.laz\",\n        ...     name=\"autzen\",\n        ...     color_scheme=\"classification\",\n        ... )\n    \"\"\"\n    import base64\n\n    layer_id = name or f\"lidar-{len(self._layers)}\"\n\n    # Check if source is a local file\n    source_path = Path(source) if isinstance(source, (str, Path)) else None\n    is_local = source_path is not None and source_path.exists()\n\n    if is_local:\n        # Read local file and encode as base64\n        with open(source_path, \"rb\") as f:\n            file_data = f.read()\n        source_b64 = base64.b64encode(file_data).decode(\"utf-8\")\n\n        self.call_js_method(\n            \"addLidarLayer\",\n            source=source_b64,\n            name=layer_id,\n            isBase64=True,\n            filename=source_path.name,\n            colorScheme=color_scheme,\n            pointSize=point_size,\n            opacity=opacity,\n            pickable=pickable,\n            autoZoom=auto_zoom,\n            streamingMode=streaming_mode,\n            pointBudget=point_budget,\n            **kwargs,\n        )\n    else:\n        # Load from URL\n        self.call_js_method(\n            \"addLidarLayer\",\n            source=str(source),\n            name=layer_id,\n            isBase64=False,\n            colorScheme=color_scheme,\n            pointSize=point_size,\n            opacity=opacity,\n            pickable=pickable,\n            autoZoom=auto_zoom,\n            streamingMode=streaming_mode,\n            pointBudget=point_budget,\n            **kwargs,\n        )\n\n    self._layers = {\n        **self._layers,\n        layer_id: {\n            \"id\": layer_id,\n            \"type\": \"lidar\",\n            \"source\": str(source),\n        },\n    }\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.mapbox.MapboxMap.add_marker","title":"<code>add_marker(self, lng, lat, color='#3388ff', popup=None, marker_id=None)</code>","text":"<p>Add a marker to the map.</p> <p>Parameters:</p> Name Type Description Default <code>lng</code> <code>float</code> <p>Longitude.</p> required <code>lat</code> <code>float</code> <p>Latitude.</p> required <code>color</code> <code>str</code> <p>Marker color.</p> <code>'#3388ff'</code> <code>popup</code> <code>Optional[str]</code> <p>HTML content for popup.</p> <code>None</code> <code>marker_id</code> <code>Optional[str]</code> <p>Unique marker ID.</p> <code>None</code> Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def add_marker(\n    self,\n    lng: float,\n    lat: float,\n    color: str = \"#3388ff\",\n    popup: Optional[str] = None,\n    marker_id: Optional[str] = None,\n) -&gt; None:\n    \"\"\"Add a marker to the map.\n\n    Args:\n        lng: Longitude.\n        lat: Latitude.\n        color: Marker color.\n        popup: HTML content for popup.\n        marker_id: Unique marker ID.\n    \"\"\"\n    self.call_js_method(\n        \"addMarker\", lng, lat, color=color, popup=popup, id=marker_id\n    )\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.mapbox.MapboxMap.add_point_cloud_layer","title":"<code>add_point_cloud_layer(self, data, name=None, get_position='position', get_color=None, get_normal=None, point_size=2, size_units='pixels', pickable=True, opacity=1.0, material=True, coordinate_system=None, coordinate_origin=None, **kwargs)</code>","text":"<p>Add a point cloud layer for 3D point visualization using deck.gl.</p> <p>Point cloud layers render large collections of 3D points, ideal for LiDAR data, photogrammetry outputs, or any 3D point dataset.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>Array of point data with positions. Each point should have x, y, z coordinates (or position array).</p> required <code>name</code> <code>Optional[str]</code> <p>Layer ID. If None, auto-generated.</p> <code>None</code> <code>get_position</code> <code>Union[str, Any]</code> <p>Accessor for point position [x, y, z]. Can be a string (property name) or a value.</p> <code>'position'</code> <code>get_color</code> <code>Optional[Union[List[int], str]]</code> <p>Accessor or value for point color [r, g, b, a]. Default: [255, 255, 255, 255] (white).</p> <code>None</code> <code>get_normal</code> <code>Optional[Union[str, Any]]</code> <p>Accessor for point normal [nx, ny, nz] for lighting. Default: [0, 0, 1] (pointing up).</p> <code>None</code> <code>point_size</code> <code>float</code> <p>Point size in pixels or meters (depends on size_units).</p> <code>2</code> <code>size_units</code> <code>str</code> <p>Size units: 'pixels', 'meters', or 'common'.</p> <code>'pixels'</code> <code>pickable</code> <code>bool</code> <p>Whether layer responds to hover/click events.</p> <code>True</code> <code>opacity</code> <code>float</code> <p>Layer opacity (0-1).</p> <code>1.0</code> <code>material</code> <code>bool</code> <p>Whether to enable lighting effects.</p> <code>True</code> <code>coordinate_system</code> <code>Optional[int]</code> <p>Coordinate system for positions.</p> <code>None</code> <code>coordinate_origin</code> <code>Optional[List[float]]</code> <p>Origin for coordinate system [x, y, z].</p> <code>None</code> <code>**kwargs</code> <p>Additional PointCloudLayer props.</p> <code>{}</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from anymap_ts import MapboxMap\n&gt;&gt;&gt; m = MapboxMap(pitch=45)\n&gt;&gt;&gt; points = [\n...     {\"position\": [-122.4, 37.8, 100], \"color\": [255, 0, 0, 255]},\n...     {\"position\": [-122.3, 37.7, 200], \"color\": [0, 255, 0, 255]},\n... ]\n&gt;&gt;&gt; m.add_point_cloud_layer(points, point_size=5)\n</code></pre> Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def add_point_cloud_layer(\n    self,\n    data: Any,\n    name: Optional[str] = None,\n    get_position: Union[str, Any] = \"position\",\n    get_color: Optional[Union[List[int], str]] = None,\n    get_normal: Optional[Union[str, Any]] = None,\n    point_size: float = 2,\n    size_units: str = \"pixels\",\n    pickable: bool = True,\n    opacity: float = 1.0,\n    material: bool = True,\n    coordinate_system: Optional[int] = None,\n    coordinate_origin: Optional[List[float]] = None,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a point cloud layer for 3D point visualization using deck.gl.\n\n    Point cloud layers render large collections of 3D points, ideal for\n    LiDAR data, photogrammetry outputs, or any 3D point dataset.\n\n    Args:\n        data: Array of point data with positions. Each point should have\n            x, y, z coordinates (or position array).\n        name: Layer ID. If None, auto-generated.\n        get_position: Accessor for point position [x, y, z].\n            Can be a string (property name) or a value.\n        get_color: Accessor or value for point color [r, g, b, a].\n            Default: [255, 255, 255, 255] (white).\n        get_normal: Accessor for point normal [nx, ny, nz] for lighting.\n            Default: [0, 0, 1] (pointing up).\n        point_size: Point size in pixels or meters (depends on size_units).\n        size_units: Size units: 'pixels', 'meters', or 'common'.\n        pickable: Whether layer responds to hover/click events.\n        opacity: Layer opacity (0-1).\n        material: Whether to enable lighting effects.\n        coordinate_system: Coordinate system for positions.\n        coordinate_origin: Origin for coordinate system [x, y, z].\n        **kwargs: Additional PointCloudLayer props.\n\n    Example:\n        &gt;&gt;&gt; from anymap_ts import MapboxMap\n        &gt;&gt;&gt; m = MapboxMap(pitch=45)\n        &gt;&gt;&gt; points = [\n        ...     {\"position\": [-122.4, 37.8, 100], \"color\": [255, 0, 0, 255]},\n        ...     {\"position\": [-122.3, 37.7, 200], \"color\": [0, 255, 0, 255]},\n        ... ]\n        &gt;&gt;&gt; m.add_point_cloud_layer(points, point_size=5)\n    \"\"\"\n    layer_id = name or f\"pointcloud-{len(self._layers)}\"\n    processed_data = self._process_deck_data(data)\n\n    self.call_js_method(\n        \"addPointCloudLayer\",\n        id=layer_id,\n        data=processed_data,\n        getPosition=get_position,\n        getColor=get_color or [255, 255, 255, 255],\n        getNormal=get_normal,\n        pointSize=point_size,\n        sizeUnits=size_units,\n        pickable=pickable,\n        opacity=opacity,\n        material=material,\n        coordinateSystem=coordinate_system,\n        coordinateOrigin=coordinate_origin,\n        **kwargs,\n    )\n\n    self._layers = {\n        **self._layers,\n        layer_id: {\n            \"id\": layer_id,\n            \"type\": \"pointcloud\",\n        },\n    }\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.mapbox.MapboxMap.add_terrain","title":"<code>add_terrain(self, exaggeration=1.0, source='mapbox-dem')</code>","text":"<p>Add 3D terrain to the map.</p> <p>Parameters:</p> Name Type Description Default <code>exaggeration</code> <code>float</code> <p>Terrain exaggeration factor.</p> <code>1.0</code> <code>source</code> <code>str</code> <p>Terrain source ID.</p> <code>'mapbox-dem'</code> Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def add_terrain(\n    self, exaggeration: float = 1.0, source: str = \"mapbox-dem\"\n) -&gt; None:\n    \"\"\"Add 3D terrain to the map.\n\n    Args:\n        exaggeration: Terrain exaggeration factor.\n        source: Terrain source ID.\n    \"\"\"\n    self.call_js_method(\"addTerrain\", source=source, exaggeration=exaggeration)\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.mapbox.MapboxMap.add_tile_layer","title":"<code>add_tile_layer(self, url, name=None, attribution='', min_zoom=0, max_zoom=22, **kwargs)</code>","text":"<p>Add an XYZ tile layer.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>Tile URL template with {x}, {y}, {z} placeholders.</p> required <code>name</code> <code>Optional[str]</code> <p>Layer name.</p> <code>None</code> <code>attribution</code> <code>str</code> <p>Attribution text.</p> <code>''</code> <code>min_zoom</code> <code>int</code> <p>Minimum zoom level.</p> <code>0</code> <code>max_zoom</code> <code>int</code> <p>Maximum zoom level.</p> <code>22</code> <code>**kwargs</code> <p>Additional options.</p> <code>{}</code> Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def add_tile_layer(\n    self,\n    url: str,\n    name: Optional[str] = None,\n    attribution: str = \"\",\n    min_zoom: int = 0,\n    max_zoom: int = 22,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add an XYZ tile layer.\n\n    Args:\n        url: Tile URL template with {x}, {y}, {z} placeholders.\n        name: Layer name.\n        attribution: Attribution text.\n        min_zoom: Minimum zoom level.\n        max_zoom: Maximum zoom level.\n        **kwargs: Additional options.\n    \"\"\"\n    layer_id = name or f\"tiles-{len(self._layers)}\"\n\n    self.call_js_method(\n        \"addTileLayer\",\n        url,\n        name=layer_id,\n        attribution=attribution,\n        minZoom=min_zoom,\n        maxZoom=max_zoom,\n        **kwargs,\n    )\n\n    # Track layer\n    self._layers = {\n        **self._layers,\n        layer_id: {\n            \"id\": layer_id,\n            \"type\": \"raster\",\n            \"source\": f\"{layer_id}-source\",\n        },\n    }\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.mapbox.MapboxMap.add_vector","title":"<code>add_vector(self, data, layer_type=None, paint=None, name=None, fit_bounds=True, **kwargs)</code>","text":"<p>Add vector data to the map.</p> <p>Supports GeoJSON, GeoDataFrame, or file paths to vector formats.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>GeoJSON dict, GeoDataFrame, or path to vector file.</p> required <code>layer_type</code> <code>Optional[str]</code> <p>Mapbox layer type ('circle', 'line', 'fill', 'symbol').</p> <code>None</code> <code>paint</code> <code>Optional[Dict]</code> <p>Mapbox paint properties.</p> <code>None</code> <code>name</code> <code>Optional[str]</code> <p>Layer name.</p> <code>None</code> <code>fit_bounds</code> <code>bool</code> <p>Whether to fit map to data bounds.</p> <code>True</code> <code>**kwargs</code> <p>Additional layer options.</p> <code>{}</code> Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def add_vector(\n    self,\n    data: Any,\n    layer_type: Optional[str] = None,\n    paint: Optional[Dict] = None,\n    name: Optional[str] = None,\n    fit_bounds: bool = True,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add vector data to the map.\n\n    Supports GeoJSON, GeoDataFrame, or file paths to vector formats.\n\n    Args:\n        data: GeoJSON dict, GeoDataFrame, or path to vector file.\n        layer_type: Mapbox layer type ('circle', 'line', 'fill', 'symbol').\n        paint: Mapbox paint properties.\n        name: Layer name.\n        fit_bounds: Whether to fit map to data bounds.\n        **kwargs: Additional layer options.\n    \"\"\"\n    geojson = to_geojson(data)\n\n    # Handle URL data\n    if geojson.get(\"type\") == \"url\":\n        self.add_geojson(\n            geojson[\"url\"],\n            layer_type=layer_type,\n            paint=paint,\n            name=name,\n            fit_bounds=fit_bounds,\n            **kwargs,\n        )\n        return\n\n    layer_id = name or f\"vector-{len(self._layers)}\"\n\n    # Infer layer type if not specified\n    if layer_type is None:\n        layer_type = infer_layer_type(geojson)\n\n    # Get default paint if not provided\n    if paint is None:\n        paint = get_default_paint(layer_type)\n\n    # Get bounds\n    bounds = get_bounds(data) if fit_bounds else None\n\n    # Call JavaScript\n    self.call_js_method(\n        \"addGeoJSON\",\n        data=geojson,\n        name=layer_id,\n        layerType=layer_type,\n        paint=paint,\n        fitBounds=fit_bounds,\n        bounds=bounds,\n        **kwargs,\n    )\n\n    # Track layer\n    self._layers = {\n        **self._layers,\n        layer_id: {\n            \"id\": layer_id,\n            \"type\": layer_type,\n            \"source\": f\"{layer_id}-source\",\n            \"paint\": paint,\n        },\n    }\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.mapbox.MapboxMap.remove_arc_layer","title":"<code>remove_arc_layer(self, layer_id)</code>","text":"<p>Remove an arc layer.</p> <p>Parameters:</p> Name Type Description Default <code>layer_id</code> <code>str</code> <p>Layer identifier to remove.</p> required Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def remove_arc_layer(self, layer_id: str) -&gt; None:\n    \"\"\"Remove an arc layer.\n\n    Args:\n        layer_id: Layer identifier to remove.\n    \"\"\"\n    if layer_id in self._layers:\n        layers = dict(self._layers)\n        del layers[layer_id]\n        self._layers = layers\n    self.call_js_method(\"removeArcLayer\", layer_id)\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.mapbox.MapboxMap.remove_cog_layer","title":"<code>remove_cog_layer(self, layer_id)</code>","text":"<p>Remove a COG layer.</p> <p>Parameters:</p> Name Type Description Default <code>layer_id</code> <code>str</code> <p>Layer identifier to remove.</p> required Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def remove_cog_layer(self, layer_id: str) -&gt; None:\n    \"\"\"Remove a COG layer.\n\n    Args:\n        layer_id: Layer identifier to remove.\n    \"\"\"\n    if layer_id in self._layers:\n        layers = dict(self._layers)\n        del layers[layer_id]\n        self._layers = layers\n    self.call_js_method(\"removeCOGLayer\", layer_id)\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.mapbox.MapboxMap.remove_control","title":"<code>remove_control(self, control_type)</code>","text":"<p>Remove a map control.</p> <p>Parameters:</p> Name Type Description Default <code>control_type</code> <code>str</code> <p>Type of control to remove.</p> required Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def remove_control(self, control_type: str) -&gt; None:\n    \"\"\"Remove a map control.\n\n    Args:\n        control_type: Type of control to remove.\n    \"\"\"\n    self.call_js_method(\"removeControl\", control_type)\n    if control_type in self._controls:\n        controls = dict(self._controls)\n        del controls[control_type]\n        self._controls = controls\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.mapbox.MapboxMap.remove_layer","title":"<code>remove_layer(self, layer_id)</code>","text":"<p>Remove a layer from the map.</p> <p>Parameters:</p> Name Type Description Default <code>layer_id</code> <code>str</code> <p>Layer identifier to remove.</p> required Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def remove_layer(self, layer_id: str) -&gt; None:\n    \"\"\"Remove a layer from the map.\n\n    Args:\n        layer_id: Layer identifier to remove.\n    \"\"\"\n    if layer_id in self._layers:\n        layers = dict(self._layers)\n        del layers[layer_id]\n        self._layers = layers\n    self.call_js_method(\"removeLayer\", layer_id)\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.mapbox.MapboxMap.remove_lidar_layer","title":"<code>remove_lidar_layer(self, layer_id=None)</code>","text":"<p>Remove a LiDAR layer.</p> <p>Parameters:</p> Name Type Description Default <code>layer_id</code> <code>Optional[str]</code> <p>Layer identifier to remove. If None, removes all LiDAR layers.</p> <code>None</code> Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def remove_lidar_layer(self, layer_id: Optional[str] = None) -&gt; None:\n    \"\"\"Remove a LiDAR layer.\n\n    Args:\n        layer_id: Layer identifier to remove. If None, removes all LiDAR layers.\n    \"\"\"\n    if layer_id:\n        if layer_id in self._layers:\n            layers = dict(self._layers)\n            del layers[layer_id]\n            self._layers = layers\n        self.call_js_method(\"removeLidarLayer\", id=layer_id)\n    else:\n        # Remove all lidar layers\n        layers = dict(self._layers)\n        self._layers = {k: v for k, v in layers.items() if v.get(\"type\") != \"lidar\"}\n        self.call_js_method(\"removeLidarLayer\")\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.mapbox.MapboxMap.remove_marker","title":"<code>remove_marker(self, marker_id)</code>","text":"<p>Remove a marker from the map.</p> <p>Parameters:</p> Name Type Description Default <code>marker_id</code> <code>str</code> <p>Marker ID to remove.</p> required Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def remove_marker(self, marker_id: str) -&gt; None:\n    \"\"\"Remove a marker from the map.\n\n    Args:\n        marker_id: Marker ID to remove.\n    \"\"\"\n    self.call_js_method(\"removeMarker\", marker_id)\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.mapbox.MapboxMap.remove_point_cloud_layer","title":"<code>remove_point_cloud_layer(self, layer_id)</code>","text":"<p>Remove a point cloud layer.</p> <p>Parameters:</p> Name Type Description Default <code>layer_id</code> <code>str</code> <p>Layer identifier to remove.</p> required Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def remove_point_cloud_layer(self, layer_id: str) -&gt; None:\n    \"\"\"Remove a point cloud layer.\n\n    Args:\n        layer_id: Layer identifier to remove.\n    \"\"\"\n    if layer_id in self._layers:\n        layers = dict(self._layers)\n        del layers[layer_id]\n        self._layers = layers\n    self.call_js_method(\"removePointCloudLayer\", layer_id)\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.mapbox.MapboxMap.remove_terrain","title":"<code>remove_terrain(self)</code>","text":"<p>Remove 3D terrain from the map.</p> Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def remove_terrain(self) -&gt; None:\n    \"\"\"Remove 3D terrain from the map.\"\"\"\n    self.call_js_method(\"removeTerrain\")\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.mapbox.MapboxMap.set_access_token","title":"<code>set_access_token(self, token)</code>","text":"<p>Set the Mapbox access token.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>str</code> <p>Mapbox access token.</p> required Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def set_access_token(self, token: str) -&gt; None:\n    \"\"\"Set the Mapbox access token.\n\n    Args:\n        token: Mapbox access token.\n    \"\"\"\n    self.access_token = token\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.mapbox.MapboxMap.set_lidar_color_scheme","title":"<code>set_lidar_color_scheme(self, color_scheme)</code>","text":"<p>Set the LiDAR color scheme.</p> <p>Parameters:</p> Name Type Description Default <code>color_scheme</code> <code>str</code> <p>Color scheme ('elevation', 'intensity', 'classification', 'rgb').</p> required Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def set_lidar_color_scheme(self, color_scheme: str) -&gt; None:\n    \"\"\"Set the LiDAR color scheme.\n\n    Args:\n        color_scheme: Color scheme ('elevation', 'intensity', 'classification', 'rgb').\n    \"\"\"\n    self.call_js_method(\"setLidarColorScheme\", colorScheme=color_scheme)\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.mapbox.MapboxMap.set_lidar_opacity","title":"<code>set_lidar_opacity(self, opacity)</code>","text":"<p>Set the LiDAR layer opacity.</p> <p>Parameters:</p> Name Type Description Default <code>opacity</code> <code>float</code> <p>Opacity value between 0 and 1.</p> required Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def set_lidar_opacity(self, opacity: float) -&gt; None:\n    \"\"\"Set the LiDAR layer opacity.\n\n    Args:\n        opacity: Opacity value between 0 and 1.\n    \"\"\"\n    self.call_js_method(\"setLidarOpacity\", opacity=opacity)\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.mapbox.MapboxMap.set_lidar_point_size","title":"<code>set_lidar_point_size(self, point_size)</code>","text":"<p>Set the LiDAR point size.</p> <p>Parameters:</p> Name Type Description Default <code>point_size</code> <code>float</code> <p>Point size in pixels.</p> required Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def set_lidar_point_size(self, point_size: float) -&gt; None:\n    \"\"\"Set the LiDAR point size.\n\n    Args:\n        point_size: Point size in pixels.\n    \"\"\"\n    self.call_js_method(\"setLidarPointSize\", pointSize=point_size)\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.mapbox.MapboxMap.set_opacity","title":"<code>set_opacity(self, layer_id, opacity)</code>","text":"<p>Set layer opacity.</p> <p>Parameters:</p> Name Type Description Default <code>layer_id</code> <code>str</code> <p>Layer identifier.</p> required <code>opacity</code> <code>float</code> <p>Opacity value between 0 and 1.</p> required Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def set_opacity(self, layer_id: str, opacity: float) -&gt; None:\n    \"\"\"Set layer opacity.\n\n    Args:\n        layer_id: Layer identifier.\n        opacity: Opacity value between 0 and 1.\n    \"\"\"\n    self.call_js_method(\"setOpacity\", layer_id, opacity)\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.mapbox.MapboxMap.set_visibility","title":"<code>set_visibility(self, layer_id, visible)</code>","text":"<p>Set layer visibility.</p> <p>Parameters:</p> Name Type Description Default <code>layer_id</code> <code>str</code> <p>Layer identifier.</p> required <code>visible</code> <code>bool</code> <p>Whether layer should be visible.</p> required Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def set_visibility(self, layer_id: str, visible: bool) -&gt; None:\n    \"\"\"Set layer visibility.\n\n    Args:\n        layer_id: Layer identifier.\n        visible: Whether layer should be visible.\n    \"\"\"\n    self.call_js_method(\"setVisibility\", layer_id, visible)\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.mapbox.get_mapbox_token","title":"<code>get_mapbox_token()</code>","text":"<p>Get Mapbox access token from environment variable.</p> <p>Returns:</p> Type Description <code>str</code> <p>Mapbox access token string, or empty string if not set.</p> Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def get_mapbox_token() -&gt; str:\n    \"\"\"Get Mapbox access token from environment variable.\n\n    Returns:\n        Mapbox access token string, or empty string if not set.\n    \"\"\"\n    return os.environ.get(\"MAPBOX_TOKEN\", \"\")\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.maplibre","title":"<code>maplibre</code>","text":"<p>MapLibre GL JS map widget implementation.</p>"},{"location":"anymap_ts/#anymap_ts.maplibre.MapLibreMap","title":"<code> MapLibreMap            (MapWidget)         </code>","text":"<p>Interactive map widget using MapLibre GL JS.</p> <p>This class provides a Python interface to MapLibre GL JS maps with full bidirectional communication through anywidget.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from anymap_ts import Map\n&gt;&gt;&gt; m = Map(center=[-122.4, 37.8], zoom=10)\n&gt;&gt;&gt; m.add_basemap(\"OpenStreetMap\")\n&gt;&gt;&gt; m\n</code></pre> Source code in <code>anymap_ts/maplibre.py</code> <pre><code>class MapLibreMap(MapWidget):\n    \"\"\"Interactive map widget using MapLibre GL JS.\n\n    This class provides a Python interface to MapLibre GL JS maps with\n    full bidirectional communication through anywidget.\n\n    Example:\n        &gt;&gt;&gt; from anymap_ts import Map\n        &gt;&gt;&gt; m = Map(center=[-122.4, 37.8], zoom=10)\n        &gt;&gt;&gt; m.add_basemap(\"OpenStreetMap\")\n        &gt;&gt;&gt; m\n    \"\"\"\n\n    # ESM module for frontend\n    _esm = STATIC_DIR / \"maplibre.js\"\n    _css = STATIC_DIR / \"maplibre.css\"\n\n    # MapLibre-specific traits\n    bearing = traitlets.Float(0.0).tag(sync=True)\n    pitch = traitlets.Float(0.0).tag(sync=True)\n    antialias = traitlets.Bool(True).tag(sync=True)\n    double_click_zoom = traitlets.Bool(True).tag(sync=True)\n\n    # Layer tracking\n    _layer_dict = traitlets.Dict({}).tag(sync=True)\n\n    def __init__(\n        self,\n        center: Tuple[float, float] = (0.0, 0.0),\n        zoom: float = 2.0,\n        width: str = \"100%\",\n        height: str = \"700px\",\n        style: Union[\n            str, Dict\n        ] = \"https://basemaps.cartocdn.com/gl/positron-gl-style/style.json\",\n        bearing: float = 0.0,\n        pitch: float = 0.0,\n        max_pitch: float = 85.0,\n        controls: Optional[Dict[str, Any]] = None,\n        **kwargs,\n    ):\n        \"\"\"Initialize a MapLibre map.\n\n        Args:\n            center: Map center as (longitude, latitude).\n            zoom: Initial zoom level.\n            width: Map width as CSS string.\n            height: Map height as CSS string. Default is \"700px\".\n            style: MapLibre style URL or style object. Default is \"https://basemaps.cartocdn.com/gl/positron-gl-style/style.json\".\n            bearing: Map bearing in degrees.\n            pitch: Map pitch in degrees.\n            max_pitch: Maximum pitch angle in degrees (default: 85).\n            controls: Dict of controls to add. If None, defaults to\n                {\"layer-control\": True, \"control-grid\": True}.\n                Use {\"layer-control\": {\"collapsed\": True}} for custom options.\n            **kwargs: Additional widget arguments.\n        \"\"\"\n        # Handle style shortcuts\n        if isinstance(style, str) and not style.startswith(\"http\"):\n            try:\n                style = get_maplibre_style(style)\n            except ValueError:\n                pass  # Use as-is\n\n        super().__init__(\n            center=list(center),\n            zoom=zoom,\n            width=width,\n            height=height,\n            style=style,\n            bearing=bearing,\n            pitch=pitch,\n            max_pitch=max_pitch,\n            **kwargs,\n        )\n\n        # Initialize layer dictionary\n        self._layer_dict = {\"Background\": []}\n\n        # Add default controls\n        if controls is None:\n            controls = {\n                \"layer-control\": True,\n                \"control-grid\": True,\n            }\n\n        for control_name, config in controls.items():\n            if config:\n                if control_name == \"layer-control\":\n                    self.add_layer_control(\n                        **(config if isinstance(config, dict) else {})\n                    )\n                elif control_name == \"control-grid\":\n                    self.add_control_grid(\n                        **(config if isinstance(config, dict) else {})\n                    )\n                else:\n                    self.add_control(\n                        control_name, **(config if isinstance(config, dict) else {})\n                    )\n\n    # -------------------------------------------------------------------------\n    # Basemap Methods\n    # -------------------------------------------------------------------------\n\n    def add_basemap(\n        self,\n        basemap: str = \"OpenStreetMap\",\n        attribution: Optional[str] = None,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a basemap layer.\n\n        Args:\n            basemap: Name of basemap provider (e.g., \"OpenStreetMap\", \"CartoDB.Positron\")\n            attribution: Custom attribution text\n            **kwargs: Additional options\n        \"\"\"\n        url, default_attribution = get_basemap_url(basemap)\n        self.call_js_method(\n            \"addBasemap\",\n            url,\n            attribution=attribution or default_attribution,\n            name=basemap,\n            **kwargs,\n        )\n\n        # Track in layer dict\n        basemaps = self._layer_dict.get(\"Basemaps\", [])\n        if basemap not in basemaps:\n            self._layer_dict = {\n                **self._layer_dict,\n                \"Basemaps\": basemaps + [basemap],\n            }\n\n    # -------------------------------------------------------------------------\n    # Vector Data Methods\n    # -------------------------------------------------------------------------\n\n    def add_vector(\n        self,\n        data: Any,\n        layer_type: Optional[str] = None,\n        paint: Optional[Dict] = None,\n        name: Optional[str] = None,\n        fit_bounds: bool = True,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add vector data to the map.\n\n        Supports GeoJSON, GeoDataFrame, or file paths to vector formats.\n\n        Args:\n            data: GeoJSON dict, GeoDataFrame, or path to vector file\n            layer_type: MapLibre layer type ('circle', 'line', 'fill', 'symbol')\n            paint: MapLibre paint properties\n            name: Layer name\n            fit_bounds: Whether to fit map to data bounds\n            **kwargs: Additional layer options\n        \"\"\"\n        geojson = to_geojson(data)\n\n        # Handle URL data\n        if geojson.get(\"type\") == \"url\":\n            self.add_geojson(\n                geojson[\"url\"],\n                layer_type=layer_type,\n                paint=paint,\n                name=name,\n                fit_bounds=fit_bounds,\n                **kwargs,\n            )\n            return\n\n        layer_id = name or f\"vector-{len(self._layers)}\"\n\n        # Infer layer type if not specified\n        if layer_type is None:\n            layer_type = infer_layer_type(geojson)\n\n        # Get default paint if not provided\n        if paint is None:\n            paint = get_default_paint(layer_type)\n\n        # Get bounds\n        bounds = get_bounds(data) if fit_bounds else None\n\n        # Call JavaScript\n        self.call_js_method(\n            \"addGeoJSON\",\n            data=geojson,\n            name=layer_id,\n            layerType=layer_type,\n            paint=paint,\n            fitBounds=fit_bounds,\n            bounds=bounds,\n            **kwargs,\n        )\n\n        # Track layer\n        self._layers = {\n            **self._layers,\n            layer_id: {\n                \"id\": layer_id,\n                \"type\": layer_type,\n                \"source\": f\"{layer_id}-source\",\n                \"paint\": paint,\n            },\n        }\n\n    def add_geojson(\n        self,\n        data: Union[str, Dict],\n        layer_type: Optional[str] = None,\n        paint: Optional[Dict] = None,\n        name: Optional[str] = None,\n        fit_bounds: bool = True,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add GeoJSON data to the map.\n\n        Args:\n            data: GeoJSON dict or URL to GeoJSON file\n            layer_type: MapLibre layer type\n            paint: MapLibre paint properties\n            name: Layer name\n            fit_bounds: Whether to fit map to data bounds\n            **kwargs: Additional layer options\n        \"\"\"\n        self.add_vector(\n            data,\n            layer_type=layer_type,\n            paint=paint,\n            name=name,\n            fit_bounds=fit_bounds,\n            **kwargs,\n        )\n\n    # -------------------------------------------------------------------------\n    # Raster Data Methods\n    # -------------------------------------------------------------------------\n\n    def add_raster(\n        self,\n        source: str,\n        name: Optional[str] = None,\n        attribution: str = \"\",\n        indexes: Optional[List[int]] = None,\n        colormap: Optional[str] = None,\n        vmin: Optional[float] = None,\n        vmax: Optional[float] = None,\n        nodata: Optional[float] = None,\n        fit_bounds: bool = True,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a raster layer from a local file using localtileserver.\n\n        Args:\n            source: Path to local raster file\n            name: Layer name\n            attribution: Attribution text\n            indexes: Band indexes to use\n            colormap: Colormap name\n            vmin: Minimum value for colormap\n            vmax: Maximum value for colormap\n            nodata: NoData value\n            fit_bounds: Whether to fit map to raster bounds\n            **kwargs: Additional options\n        \"\"\"\n        try:\n            from localtileserver import TileClient\n        except ImportError:\n            raise ImportError(\n                \"localtileserver is required for local raster support. \"\n                \"Install with: pip install anymap-ts[raster]\"\n            )\n\n        client = TileClient(source)\n\n        # Build tile URL with parameters\n        tile_url = client.get_tile_url()\n        if indexes:\n            tile_url = client.get_tile_url(indexes=indexes)\n        if colormap:\n            tile_url = client.get_tile_url(colormap=colormap)\n        if vmin is not None or vmax is not None:\n            tile_url = client.get_tile_url(\n                vmin=vmin or client.min, vmax=vmax or client.max\n            )\n        if nodata is not None:\n            tile_url = client.get_tile_url(nodata=nodata)\n\n        layer_name = name or Path(source).stem\n\n        self.add_tile_layer(\n            tile_url,\n            name=layer_name,\n            attribution=attribution,\n            **kwargs,\n        )\n\n        # Fit bounds if requested\n        if fit_bounds:\n            bounds = client.bounds()\n            if bounds:\n                self.fit_bounds([bounds[0], bounds[1], bounds[2], bounds[3]])\n\n    def add_tile_layer(\n        self,\n        url: str,\n        name: Optional[str] = None,\n        attribution: str = \"\",\n        min_zoom: int = 0,\n        max_zoom: int = 22,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add an XYZ tile layer.\n\n        Args:\n            url: Tile URL template with {x}, {y}, {z} placeholders\n            name: Layer name\n            attribution: Attribution text\n            min_zoom: Minimum zoom level\n            max_zoom: Maximum zoom level\n            **kwargs: Additional options\n        \"\"\"\n        layer_id = name or f\"tiles-{len(self._layers)}\"\n\n        self.call_js_method(\n            \"addTileLayer\",\n            url,\n            name=layer_id,\n            attribution=attribution,\n            minZoom=min_zoom,\n            maxZoom=max_zoom,\n            **kwargs,\n        )\n\n        # Track layer\n        self._layers = {\n            **self._layers,\n            layer_id: {\n                \"id\": layer_id,\n                \"type\": \"raster\",\n                \"source\": f\"{layer_id}-source\",\n            },\n        }\n\n    # -------------------------------------------------------------------------\n    # COG Layer (deck.gl)\n    # -------------------------------------------------------------------------\n\n    def add_cog_layer(\n        self,\n        url: str,\n        name: Optional[str] = None,\n        opacity: float = 1.0,\n        visible: bool = True,\n        debug: bool = False,\n        debug_opacity: float = 0.25,\n        max_error: float = 0.125,\n        fit_bounds: bool = True,\n        before_id: Optional[str] = None,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a Cloud Optimized GeoTIFF (COG) layer using @developmentseed/deck.gl-geotiff.\n\n        This method renders COG files directly in the browser using GPU-accelerated\n        deck.gl-geotiff rendering with automatic reprojection support.\n\n        Args:\n            url: URL to the Cloud Optimized GeoTIFF file.\n            name: Layer ID. If None, auto-generated.\n            opacity: Layer opacity (0-1).\n            visible: Whether layer is visible.\n            debug: Show reprojection mesh for debugging.\n            debug_opacity: Opacity of debug mesh (0-1).\n            max_error: Maximum reprojection error in pixels. Lower values\n                create denser mesh for better accuracy.\n            fit_bounds: Whether to fit map to COG bounds after loading.\n            before_id: ID of layer to insert before.\n            **kwargs: Additional COGLayer props.\n\n        Example:\n            &gt;&gt;&gt; from anymap_ts import Map\n            &gt;&gt;&gt; m = Map()\n            &gt;&gt;&gt; m.add_cog_layer(\n            ...     \"https://example.com/landcover.tif\",\n            ...     name=\"landcover\",\n            ...     opacity=0.8\n            ... )\n        \"\"\"\n        layer_id = name or f\"cog-{len(self._layers)}\"\n\n        self.call_js_method(\n            \"addCOGLayer\",\n            id=layer_id,\n            geotiff=url,\n            opacity=opacity,\n            visible=visible,\n            debug=debug,\n            debugOpacity=debug_opacity,\n            maxError=max_error,\n            fitBounds=fit_bounds,\n            beforeId=before_id,\n            **kwargs,\n        )\n\n        self._layers = {\n            **self._layers,\n            layer_id: {\n                \"id\": layer_id,\n                \"type\": \"cog\",\n                \"url\": url,\n            },\n        }\n\n    def remove_cog_layer(self, layer_id: str) -&gt; None:\n        \"\"\"Remove a COG layer.\n\n        Args:\n            layer_id: Layer identifier to remove.\n        \"\"\"\n        if layer_id in self._layers:\n            layers = dict(self._layers)\n            del layers[layer_id]\n            self._layers = layers\n        self.call_js_method(\"removeCOGLayer\", layer_id)\n\n    # -------------------------------------------------------------------------\n    # Zarr Layer (@carbonplan/zarr-layer)\n    # -------------------------------------------------------------------------\n\n    def add_zarr_layer(\n        self,\n        url: str,\n        variable: str,\n        name: Optional[str] = None,\n        colormap: Optional[List[str]] = None,\n        clim: Optional[Tuple[float, float]] = None,\n        opacity: float = 1.0,\n        selector: Optional[Dict[str, Any]] = None,\n        minzoom: int = 0,\n        maxzoom: int = 22,\n        fill_value: Optional[float] = None,\n        spatial_dimensions: Optional[Dict[str, str]] = None,\n        zarr_version: Optional[int] = None,\n        bounds: Optional[List[float]] = None,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a Zarr dataset layer for visualizing multidimensional array data.\n\n        This method renders Zarr pyramid datasets directly in the browser using\n        GPU-accelerated WebGL rendering via @carbonplan/zarr-layer.\n\n        Args:\n            url: URL to the Zarr store (pyramid format recommended).\n            variable: Variable name in the Zarr dataset to visualize.\n            name: Layer ID. If None, auto-generated.\n            colormap: List of hex color strings for visualization.\n                Example: ['#0000ff', '#ffff00', '#ff0000'] (blue-yellow-red).\n                Default: ['#000000', '#ffffff'] (black to white).\n            clim: Color range as (min, max) tuple.\n                Default: (0, 100).\n            opacity: Layer opacity (0-1).\n            selector: Dimension selector for multi-dimensional data.\n                Example: {\"month\": 4} to select 4th month.\n            minzoom: Minimum zoom level for rendering.\n            maxzoom: Maximum zoom level for rendering.\n            fill_value: No-data value (auto-detected from metadata if not set).\n            spatial_dimensions: Custom spatial dimension names.\n                Example: {\"lat\": \"y\", \"lon\": \"x\"} for non-standard names.\n            zarr_version: Zarr format version (2 or 3). Auto-detected if not set.\n            bounds: Explicit spatial bounds [xMin, yMin, xMax, yMax].\n                Units depend on CRS: degrees for EPSG:4326, meters for EPSG:3857.\n            **kwargs: Additional ZarrLayer props.\n\n        Example:\n            &gt;&gt;&gt; from anymap_ts import Map\n            &gt;&gt;&gt; m = Map()\n            &gt;&gt;&gt; m.add_zarr_layer(\n            ...     \"https://example.com/climate.zarr\",\n            ...     variable=\"temperature\",\n            ...     clim=(270, 310),\n            ...     colormap=['#0000ff', '#ffff00', '#ff0000'],\n            ...     selector={\"month\": 7}\n            ... )\n        \"\"\"\n        layer_id = name or f\"zarr-{len(self._layers)}\"\n\n        self.call_js_method(\n            \"addZarrLayer\",\n            id=layer_id,\n            source=url,\n            variable=variable,\n            colormap=colormap or [\"#000000\", \"#ffffff\"],\n            clim=list(clim) if clim else [0, 100],\n            opacity=opacity,\n            selector=selector or {},\n            minzoom=minzoom,\n            maxzoom=maxzoom,\n            fillValue=fill_value,\n            spatialDimensions=spatial_dimensions,\n            zarrVersion=zarr_version,\n            bounds=bounds,\n            **kwargs,\n        )\n\n        self._layers = {\n            **self._layers,\n            layer_id: {\n                \"id\": layer_id,\n                \"type\": \"zarr\",\n                \"url\": url,\n                \"variable\": variable,\n            },\n        }\n\n    def remove_zarr_layer(self, layer_id: str) -&gt; None:\n        \"\"\"Remove a Zarr layer.\n\n        Args:\n            layer_id: Layer identifier to remove.\n        \"\"\"\n        if layer_id in self._layers:\n            layers = dict(self._layers)\n            del layers[layer_id]\n            self._layers = layers\n        self.call_js_method(\"removeZarrLayer\", layer_id)\n\n    def update_zarr_layer(\n        self,\n        layer_id: str,\n        selector: Optional[Dict[str, Any]] = None,\n        clim: Optional[Tuple[float, float]] = None,\n        colormap: Optional[List[str]] = None,\n        opacity: Optional[float] = None,\n    ) -&gt; None:\n        \"\"\"Update a Zarr layer's properties dynamically.\n\n        Args:\n            layer_id: Layer identifier.\n            selector: New dimension selector.\n            clim: New color range.\n            colormap: New colormap.\n            opacity: New opacity value (0-1).\n        \"\"\"\n        update_kwargs: Dict[str, Any] = {\"id\": layer_id}\n        if selector is not None:\n            update_kwargs[\"selector\"] = selector\n        if clim is not None:\n            update_kwargs[\"clim\"] = list(clim)\n        if colormap is not None:\n            update_kwargs[\"colormap\"] = colormap\n        if opacity is not None:\n            update_kwargs[\"opacity\"] = opacity\n        self.call_js_method(\"updateZarrLayer\", **update_kwargs)\n\n    # -------------------------------------------------------------------------\n    # Arc Layer (deck.gl)\n    # -------------------------------------------------------------------------\n\n    def add_arc_layer(\n        self,\n        data: Any,\n        name: Optional[str] = None,\n        get_source_position: Union[str, Any] = \"source\",\n        get_target_position: Union[str, Any] = \"target\",\n        get_source_color: Optional[List[int]] = None,\n        get_target_color: Optional[List[int]] = None,\n        get_width: Union[float, str] = 1,\n        get_height: float = 1,\n        great_circle: bool = False,\n        pickable: bool = True,\n        opacity: float = 0.8,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add an arc layer for origin-destination visualization using deck.gl.\n\n        Arc layers are ideal for visualizing connections between locations,\n        such as flight routes, migration patterns, or network flows.\n\n        Args:\n            data: Array of data objects with source/target coordinates.\n                Each object should have source and target positions.\n            name: Layer ID. If None, auto-generated.\n            get_source_position: Accessor for source position [lng, lat].\n                Can be a string (property name) or a value.\n            get_target_position: Accessor for target position [lng, lat].\n                Can be a string (property name) or a value.\n            get_source_color: Source end color as [r, g, b, a].\n                Default: [51, 136, 255, 255] (blue).\n            get_target_color: Target end color as [r, g, b, a].\n                Default: [255, 136, 51, 255] (orange).\n            get_width: Arc width in pixels. Can be a number or accessor.\n            get_height: Arc height multiplier. Higher values create more curved arcs.\n            great_circle: Whether to draw arcs along great circles.\n            pickable: Whether layer responds to hover/click events.\n            opacity: Layer opacity (0-1).\n            **kwargs: Additional ArcLayer props.\n\n        Example:\n            &gt;&gt;&gt; from anymap_ts import MapLibreMap\n            &gt;&gt;&gt; m = MapLibreMap()\n            &gt;&gt;&gt; arcs = [\n            ...     {\"source\": [-122.4, 37.8], \"target\": [-73.9, 40.7]},\n            ...     {\"source\": [-122.4, 37.8], \"target\": [-0.1, 51.5]},\n            ... ]\n            &gt;&gt;&gt; m.add_arc_layer(arcs, name=\"flights\")\n        \"\"\"\n        layer_id = name or f\"arc-{len(self._layers)}\"\n        processed_data = self._process_deck_data(data)\n\n        self.call_js_method(\n            \"addArcLayer\",\n            id=layer_id,\n            data=processed_data,\n            getSourcePosition=get_source_position,\n            getTargetPosition=get_target_position,\n            getSourceColor=get_source_color or [51, 136, 255, 255],\n            getTargetColor=get_target_color or [255, 136, 51, 255],\n            getWidth=get_width,\n            getHeight=get_height,\n            greatCircle=great_circle,\n            pickable=pickable,\n            opacity=opacity,\n            **kwargs,\n        )\n\n        self._layers = {\n            **self._layers,\n            layer_id: {\n                \"id\": layer_id,\n                \"type\": \"arc\",\n            },\n        }\n\n    def remove_arc_layer(self, layer_id: str) -&gt; None:\n        \"\"\"Remove an arc layer.\n\n        Args:\n            layer_id: Layer identifier to remove.\n        \"\"\"\n        if layer_id in self._layers:\n            layers = dict(self._layers)\n            del layers[layer_id]\n            self._layers = layers\n        self.call_js_method(\"removeArcLayer\", layer_id)\n\n    # -------------------------------------------------------------------------\n    # PointCloud Layer (deck.gl)\n    # -------------------------------------------------------------------------\n\n    def add_point_cloud_layer(\n        self,\n        data: Any,\n        name: Optional[str] = None,\n        get_position: Union[str, Any] = \"position\",\n        get_color: Optional[Union[List[int], str]] = None,\n        get_normal: Optional[Union[str, Any]] = None,\n        point_size: float = 2,\n        size_units: str = \"pixels\",\n        pickable: bool = True,\n        opacity: float = 1.0,\n        material: bool = True,\n        coordinate_system: Optional[int] = None,\n        coordinate_origin: Optional[List[float]] = None,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a point cloud layer for 3D point visualization using deck.gl.\n\n        Point cloud layers render large collections of 3D points, ideal for\n        LiDAR data, photogrammetry outputs, or any 3D point dataset.\n\n        Args:\n            data: Array of point data with positions. Each point should have\n                x, y, z coordinates (or position array).\n            name: Layer ID. If None, auto-generated.\n            get_position: Accessor for point position [x, y, z].\n                Can be a string (property name) or a value.\n            get_color: Accessor or value for point color [r, g, b, a].\n                Default: [255, 255, 255, 255] (white).\n            get_normal: Accessor for point normal [nx, ny, nz] for lighting.\n                Default: [0, 0, 1] (pointing up).\n            point_size: Point size in pixels or meters (depends on size_units).\n            size_units: Size units: 'pixels', 'meters', or 'common'.\n            pickable: Whether layer responds to hover/click events.\n            opacity: Layer opacity (0-1).\n            material: Whether to enable lighting effects.\n            coordinate_system: Coordinate system for positions.\n            coordinate_origin: Origin for coordinate system [x, y, z].\n            **kwargs: Additional PointCloudLayer props.\n\n        Example:\n            &gt;&gt;&gt; from anymap_ts import MapLibreMap\n            &gt;&gt;&gt; import numpy as np\n            &gt;&gt;&gt; m = MapLibreMap(pitch=45)\n            &gt;&gt;&gt; points = [\n            ...     {\"position\": [-122.4, 37.8, 100], \"color\": [255, 0, 0, 255]},\n            ...     {\"position\": [-122.3, 37.7, 200], \"color\": [0, 255, 0, 255]},\n            ... ]\n            &gt;&gt;&gt; m.add_point_cloud_layer(points, point_size=5)\n        \"\"\"\n        layer_id = name or f\"pointcloud-{len(self._layers)}\"\n        processed_data = self._process_deck_data(data)\n\n        self.call_js_method(\n            \"addPointCloudLayer\",\n            id=layer_id,\n            data=processed_data,\n            getPosition=get_position,\n            getColor=get_color or [255, 255, 255, 255],\n            getNormal=get_normal,\n            pointSize=point_size,\n            sizeUnits=size_units,\n            pickable=pickable,\n            opacity=opacity,\n            material=material,\n            coordinateSystem=coordinate_system,\n            coordinateOrigin=coordinate_origin,\n            **kwargs,\n        )\n\n        self._layers = {\n            **self._layers,\n            layer_id: {\n                \"id\": layer_id,\n                \"type\": \"pointcloud\",\n            },\n        }\n\n    def remove_point_cloud_layer(self, layer_id: str) -&gt; None:\n        \"\"\"Remove a point cloud layer.\n\n        Args:\n            layer_id: Layer identifier to remove.\n        \"\"\"\n        if layer_id in self._layers:\n            layers = dict(self._layers)\n            del layers[layer_id]\n            self._layers = layers\n        self.call_js_method(\"removePointCloudLayer\", layer_id)\n\n    # -------------------------------------------------------------------------\n    # LiDAR Layers (maplibre-gl-lidar)\n    # -------------------------------------------------------------------------\n\n    def add_lidar_control(\n        self,\n        position: str = \"top-right\",\n        collapsed: bool = True,\n        title: str = \"LiDAR Viewer\",\n        point_size: float = 2,\n        opacity: float = 1.0,\n        color_scheme: str = \"elevation\",\n        use_percentile: bool = True,\n        point_budget: int = 1000000,\n        pickable: bool = False,\n        auto_zoom: bool = True,\n        copc_loading_mode: Optional[str] = None,\n        streaming_point_budget: int = 5000000,\n        panel_max_height: int = 600,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add an interactive LiDAR control panel.\n\n        The LiDAR control provides a UI panel for loading, visualizing, and\n        styling LiDAR point cloud files (LAS, LAZ, COPC formats).\n\n        Args:\n            position: Control position ('top-left', 'top-right', 'bottom-left', 'bottom-right').\n            collapsed: Whether the panel starts collapsed.\n            title: Title displayed on the panel.\n            point_size: Point size in pixels.\n            opacity: Layer opacity (0-1).\n            color_scheme: Color scheme ('elevation', 'intensity', 'classification', 'rgb').\n            use_percentile: Use 2-98% percentile for color scaling.\n            point_budget: Maximum number of points to display.\n            pickable: Enable hover/click interactions.\n            auto_zoom: Auto-zoom to point cloud after loading.\n            copc_loading_mode: COPC loading mode ('full' or 'dynamic').\n            streaming_point_budget: Point budget for streaming mode.\n            panel_max_height: Maximum height of the panel in pixels.\n            **kwargs: Additional control options.\n\n        Example:\n            &gt;&gt;&gt; from anymap_ts import MapLibreMap\n            &gt;&gt;&gt; m = MapLibreMap(pitch=60)\n            &gt;&gt;&gt; m.add_lidar_control(color_scheme=\"classification\", pickable=True)\n        \"\"\"\n        self.call_js_method(\n            \"addLidarControl\",\n            position=position,\n            collapsed=collapsed,\n            title=title,\n            pointSize=point_size,\n            opacity=opacity,\n            colorScheme=color_scheme,\n            usePercentile=use_percentile,\n            pointBudget=point_budget,\n            pickable=pickable,\n            autoZoom=auto_zoom,\n            copcLoadingMode=copc_loading_mode,\n            streamingPointBudget=streaming_point_budget,\n            panelMaxHeight=panel_max_height,\n            **kwargs,\n        )\n        self._controls = {\n            **self._controls,\n            \"lidar-control\": {\"position\": position, \"collapsed\": collapsed},\n        }\n\n    def add_lidar_layer(\n        self,\n        source: Union[str, Path],\n        name: Optional[str] = None,\n        color_scheme: str = \"elevation\",\n        point_size: float = 2,\n        opacity: float = 1.0,\n        pickable: bool = True,\n        auto_zoom: bool = True,\n        streaming_mode: bool = True,\n        point_budget: int = 1000000,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Load and display a LiDAR file from URL or local path.\n\n        Supports LAS, LAZ, and COPC (Cloud-Optimized Point Cloud) formats.\n        For local files, the file is read and sent as base64 to JavaScript.\n        For URLs, the data is loaded directly via streaming when possible.\n\n        Args:\n            source: URL or local file path to the LiDAR file.\n            name: Layer identifier. If None, auto-generated.\n            color_scheme: Color scheme ('elevation', 'intensity', 'classification', 'rgb').\n            point_size: Point size in pixels.\n            opacity: Layer opacity (0-1).\n            pickable: Enable hover/click interactions.\n            auto_zoom: Auto-zoom to point cloud after loading.\n            streaming_mode: Use streaming mode for large COPC files.\n            point_budget: Maximum number of points to display.\n            **kwargs: Additional layer options.\n\n        Example:\n            &gt;&gt;&gt; from anymap_ts import MapLibreMap\n            &gt;&gt;&gt; m = MapLibreMap(center=[-123.07, 44.05], zoom=14, pitch=60)\n            &gt;&gt;&gt; m.add_lidar_layer(\n            ...     source=\"https://s3.amazonaws.com/hobu-lidar/autzen-classified.copc.laz\",\n            ...     name=\"autzen\",\n            ...     color_scheme=\"classification\",\n            ... )\n        \"\"\"\n        layer_id = name or f\"lidar-{len(self._layers)}\"\n\n        # Check if source is a local file\n        source_path = Path(source) if isinstance(source, (str, Path)) else None\n        is_local = source_path is not None and source_path.exists()\n\n        if is_local:\n            # Read local file and encode as base64\n            import base64\n\n            with open(source_path, \"rb\") as f:\n                file_data = f.read()\n            source_b64 = base64.b64encode(file_data).decode(\"utf-8\")\n\n            self.call_js_method(\n                \"addLidarLayer\",\n                source=source_b64,\n                name=layer_id,\n                isBase64=True,\n                filename=source_path.name,\n                colorScheme=color_scheme,\n                pointSize=point_size,\n                opacity=opacity,\n                pickable=pickable,\n                autoZoom=auto_zoom,\n                streamingMode=streaming_mode,\n                pointBudget=point_budget,\n                **kwargs,\n            )\n        else:\n            # Load from URL\n            self.call_js_method(\n                \"addLidarLayer\",\n                source=str(source),\n                name=layer_id,\n                isBase64=False,\n                colorScheme=color_scheme,\n                pointSize=point_size,\n                opacity=opacity,\n                pickable=pickable,\n                autoZoom=auto_zoom,\n                streamingMode=streaming_mode,\n                pointBudget=point_budget,\n                **kwargs,\n            )\n\n        self._layers = {\n            **self._layers,\n            layer_id: {\n                \"id\": layer_id,\n                \"type\": \"lidar\",\n                \"source\": str(source),\n            },\n        }\n\n    def remove_lidar_layer(self, layer_id: Optional[str] = None) -&gt; None:\n        \"\"\"Remove a LiDAR layer.\n\n        Args:\n            layer_id: Layer identifier to remove. If None, removes all LiDAR layers.\n        \"\"\"\n        if layer_id:\n            if layer_id in self._layers:\n                layers = dict(self._layers)\n                del layers[layer_id]\n                self._layers = layers\n            self.call_js_method(\"removeLidarLayer\", id=layer_id)\n        else:\n            # Remove all lidar layers\n            layers = dict(self._layers)\n            self._layers = {k: v for k, v in layers.items() if v.get(\"type\") != \"lidar\"}\n            self.call_js_method(\"removeLidarLayer\")\n\n    def set_lidar_color_scheme(self, color_scheme: str) -&gt; None:\n        \"\"\"Set the LiDAR color scheme.\n\n        Args:\n            color_scheme: Color scheme ('elevation', 'intensity', 'classification', 'rgb').\n        \"\"\"\n        self.call_js_method(\"setLidarColorScheme\", colorScheme=color_scheme)\n\n    def set_lidar_point_size(self, point_size: float) -&gt; None:\n        \"\"\"Set the LiDAR point size.\n\n        Args:\n            point_size: Point size in pixels.\n        \"\"\"\n        self.call_js_method(\"setLidarPointSize\", pointSize=point_size)\n\n    def set_lidar_opacity(self, opacity: float) -&gt; None:\n        \"\"\"Set the LiDAR layer opacity.\n\n        Args:\n            opacity: Opacity value between 0 and 1.\n        \"\"\"\n        self.call_js_method(\"setLidarOpacity\", opacity=opacity)\n\n    # -------------------------------------------------------------------------\n    # maplibre-gl-components UI Controls\n    # -------------------------------------------------------------------------\n\n    def add_pmtiles_control(\n        self,\n        position: str = \"top-right\",\n        collapsed: bool = True,\n        default_url: Optional[str] = None,\n        load_default_url: bool = False,\n        default_opacity: float = 1.0,\n        default_fill_color: str = \"steelblue\",\n        default_line_color: str = \"#333\",\n        default_pickable: bool = True,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a PMTiles layer control for loading PMTiles files via UI.\n\n        This provides an interactive panel for users to enter PMTiles URLs\n        and visualize vector or raster tile data.\n\n        Args:\n            position: Control position ('top-left', 'top-right', 'bottom-left', 'bottom-right').\n            collapsed: Whether the panel starts collapsed.\n            default_url: Default PMTiles URL to pre-fill.\n            load_default_url: Whether to auto-load the default URL.\n            default_opacity: Default layer opacity (0-1).\n            default_fill_color: Default fill color for vector polygons.\n            default_line_color: Default line color for vector lines.\n            default_pickable: Whether features are clickable by default.\n            **kwargs: Additional control options.\n\n        Example:\n            &gt;&gt;&gt; from anymap_ts import MapLibreMap\n            &gt;&gt;&gt; m = MapLibreMap()\n            &gt;&gt;&gt; m.add_pmtiles_control(\n            ...     default_url=\"https://pmtiles.io/protomaps(vector)ODbL_firenze.pmtiles\",\n            ...     load_default_url=True\n            ... )\n        \"\"\"\n        self.call_js_method(\n            \"addPMTilesControl\",\n            position=position,\n            collapsed=collapsed,\n            defaultUrl=default_url or \"\",\n            loadDefaultUrl=load_default_url,\n            defaultOpacity=default_opacity,\n            defaultFillColor=default_fill_color,\n            defaultLineColor=default_line_color,\n            defaultPickable=default_pickable,\n            **kwargs,\n        )\n        self._controls = {\n            **self._controls,\n            \"pmtiles-control\": {\"position\": position, \"collapsed\": collapsed},\n        }\n\n    def add_cog_control(\n        self,\n        position: str = \"top-right\",\n        collapsed: bool = True,\n        default_url: Optional[str] = None,\n        load_default_url: bool = False,\n        default_opacity: float = 1.0,\n        default_colormap: str = \"viridis\",\n        default_bands: str = \"1\",\n        default_rescale_min: float = 0,\n        default_rescale_max: float = 255,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a COG layer control for loading Cloud Optimized GeoTIFFs via UI.\n\n        This provides an interactive panel for users to enter COG URLs\n        and configure visualization parameters like colormap and rescaling.\n\n        Args:\n            position: Control position ('top-left', 'top-right', 'bottom-left', 'bottom-right').\n            collapsed: Whether the panel starts collapsed.\n            default_url: Default COG URL to pre-fill.\n            load_default_url: Whether to auto-load the default URL.\n            default_opacity: Default layer opacity (0-1).\n            default_colormap: Default colormap name.\n            default_bands: Default bands (e.g., '1' or '1,2,3').\n            default_rescale_min: Default minimum value for rescaling.\n            default_rescale_max: Default maximum value for rescaling.\n            **kwargs: Additional control options.\n\n        Example:\n            &gt;&gt;&gt; from anymap_ts import MapLibreMap\n            &gt;&gt;&gt; m = MapLibreMap()\n            &gt;&gt;&gt; m.add_cog_control(\n            ...     default_url=\"https://example.com/cog.tif\",\n            ...     default_colormap=\"terrain\"\n            ... )\n        \"\"\"\n        self.call_js_method(\n            \"addCogControl\",\n            position=position,\n            collapsed=collapsed,\n            defaultUrl=default_url or \"\",\n            loadDefaultUrl=load_default_url,\n            defaultOpacity=default_opacity,\n            defaultColormap=default_colormap,\n            defaultBands=default_bands,\n            defaultRescaleMin=default_rescale_min,\n            defaultRescaleMax=default_rescale_max,\n            **kwargs,\n        )\n        self._controls = {\n            **self._controls,\n            \"cog-control\": {\"position\": position, \"collapsed\": collapsed},\n        }\n\n    def add_zarr_control(\n        self,\n        position: str = \"top-right\",\n        collapsed: bool = True,\n        default_url: Optional[str] = None,\n        load_default_url: bool = False,\n        default_opacity: float = 1.0,\n        default_variable: str = \"\",\n        default_clim: Optional[Tuple[float, float]] = None,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a Zarr layer control for loading Zarr datasets via UI.\n\n        This provides an interactive panel for users to enter Zarr URLs\n        and configure visualization parameters.\n\n        Args:\n            position: Control position ('top-left', 'top-right', 'bottom-left', 'bottom-right').\n            collapsed: Whether the panel starts collapsed.\n            default_url: Default Zarr URL to pre-fill.\n            load_default_url: Whether to auto-load the default URL.\n            default_opacity: Default layer opacity (0-1).\n            default_variable: Default variable name.\n            default_clim: Default color limits (min, max).\n            **kwargs: Additional control options.\n\n        Example:\n            &gt;&gt;&gt; from anymap_ts import MapLibreMap\n            &gt;&gt;&gt; m = MapLibreMap()\n            &gt;&gt;&gt; m.add_zarr_control(\n            ...     default_url=\"https://example.com/data.zarr\",\n            ...     default_variable=\"temperature\"\n            ... )\n        \"\"\"\n        self.call_js_method(\n            \"addZarrControl\",\n            position=position,\n            collapsed=collapsed,\n            defaultUrl=default_url or \"\",\n            loadDefaultUrl=load_default_url,\n            defaultOpacity=default_opacity,\n            defaultVariable=default_variable,\n            defaultClim=list(default_clim) if default_clim else [0, 1],\n            **kwargs,\n        )\n        self._controls = {\n            **self._controls,\n            \"zarr-control\": {\"position\": position, \"collapsed\": collapsed},\n        }\n\n    def add_vector_control(\n        self,\n        position: str = \"top-right\",\n        collapsed: bool = True,\n        default_url: Optional[str] = None,\n        load_default_url: bool = False,\n        default_opacity: float = 1.0,\n        default_fill_color: str = \"#3388ff\",\n        default_stroke_color: str = \"#3388ff\",\n        fit_bounds: bool = True,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a vector layer control for loading vector datasets from URLs.\n\n        This provides an interactive panel for users to enter URLs to\n        GeoJSON, GeoParquet, or FlatGeobuf datasets.\n\n        Args:\n            position: Control position ('top-left', 'top-right', 'bottom-left', 'bottom-right').\n            collapsed: Whether the panel starts collapsed.\n            default_url: Default vector URL to pre-fill.\n            load_default_url: Whether to auto-load the default URL.\n            default_opacity: Default layer opacity (0-1).\n            default_fill_color: Default fill color for polygons.\n            default_stroke_color: Default stroke color for lines/outlines.\n            fit_bounds: Whether to fit map to loaded data bounds.\n            **kwargs: Additional control options.\n\n        Example:\n            &gt;&gt;&gt; from anymap_ts import MapLibreMap\n            &gt;&gt;&gt; m = MapLibreMap()\n            &gt;&gt;&gt; m.add_vector_control(\n            ...     default_url=\"https://example.com/data.geojson\",\n            ...     default_fill_color=\"#ff0000\"\n            ... )\n        \"\"\"\n        self.call_js_method(\n            \"addVectorControl\",\n            position=position,\n            collapsed=collapsed,\n            defaultUrl=default_url or \"\",\n            loadDefaultUrl=load_default_url,\n            defaultOpacity=default_opacity,\n            defaultFillColor=default_fill_color,\n            defaultStrokeColor=default_stroke_color,\n            fitBounds=fit_bounds,\n            **kwargs,\n        )\n        self._controls = {\n            **self._controls,\n            \"vector-control\": {\"position\": position, \"collapsed\": collapsed},\n        }\n\n    def add_control_grid(\n        self,\n        position: str = \"top-right\",\n        default_controls: Optional[List[str]] = None,\n        exclude: Optional[List[str]] = None,\n        rows: Optional[int] = None,\n        columns: Optional[int] = None,\n        collapsed: bool = True,\n        collapsible: bool = True,\n        title: str = \"\",\n        show_row_column_controls: bool = True,\n        gap: int = 2,\n        basemap_style_url: Optional[str] = None,\n        exclude_layers: Optional[List[str]] = None,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a ControlGrid with all default tools or a custom subset.\n\n        The ControlGrid provides a collapsible toolbar with up to 26 built-in\n        controls (search, basemap, terrain, measure, draw, etc.) in a\n        configurable grid layout.\n\n        Args:\n            position: Control position ('top-left', 'top-right', 'bottom-left',\n                'bottom-right').\n            default_controls: Explicit list of control names to include. If None,\n                all 26 default controls are used (minus any in ``exclude``).\n                Valid names: 'globe', 'fullscreen', 'north', 'terrain', 'search',\n                'viewState', 'inspect', 'vectorDataset', 'basemap', 'measure',\n                'geoEditor', 'bookmark', 'print', 'minimap', 'swipe',\n                'streetView', 'addVector', 'cogLayer', 'zarrLayer',\n                'pmtilesLayer', 'stacLayer', 'stacSearch', 'planetaryComputer',\n                'gaussianSplat', 'lidar', 'usgsLidar'.\n            exclude: Controls to remove from the default set. Ignored when\n                ``default_controls`` is provided.\n            rows: Number of grid rows (auto-calculated if None).\n            columns: Number of grid columns (auto-calculated if None).\n            collapsed: Whether the grid starts collapsed. Default True.\n            collapsible: Whether the grid can be collapsed. Default True.\n            title: Optional header title for the grid.\n            show_row_column_controls: Show row/column input fields. Default True.\n            gap: Gap between grid cells in pixels. Default 2.\n            basemap_style_url: Basemap style URL for SwipeControl layer grouping.\n                If None, the current map style is used automatically.\n            exclude_layers: Layer ID patterns to exclude from SwipeControl\n                (e.g., 'measure-*', 'gl-draw-*'). If None, sensible defaults\n                are applied.\n            **kwargs: Additional ControlGrid options.\n\n        Example:\n            &gt;&gt;&gt; from anymap_ts import MapLibreMap\n            &gt;&gt;&gt; m = MapLibreMap()\n            &gt;&gt;&gt; m.add_control_grid()  # All 26 controls\n            &gt;&gt;&gt; # Or with customization:\n            &gt;&gt;&gt; m.add_control_grid(\n            ...     exclude=[\"minimap\", \"streetView\"],\n            ...     collapsed=True,\n            ... )\n        \"\"\"\n        js_kwargs: Dict[str, Any] = {\n            \"position\": position,\n            \"collapsed\": collapsed,\n            \"collapsible\": collapsible,\n            \"showRowColumnControls\": show_row_column_controls,\n            \"gap\": gap,\n            **kwargs,\n        }\n        if default_controls is not None:\n            js_kwargs[\"defaultControls\"] = default_controls\n        if exclude is not None:\n            js_kwargs[\"exclude\"] = exclude\n        if rows is not None:\n            js_kwargs[\"rows\"] = rows\n        if columns is not None:\n            js_kwargs[\"columns\"] = columns\n        if title:\n            js_kwargs[\"title\"] = title\n        if basemap_style_url is not None:\n            js_kwargs[\"basemapStyleUrl\"] = basemap_style_url\n        if exclude_layers is not None:\n            js_kwargs[\"excludeLayers\"] = exclude_layers\n\n        self.call_js_method(\"addControlGrid\", **js_kwargs)\n        self._controls = {\n            **self._controls,\n            \"control-grid\": {\"position\": position, \"collapsed\": collapsed},\n        }\n\n    def _process_deck_data(self, data: Any) -&gt; Any:\n        \"\"\"Process data for deck.gl layers.\n\n        Handles GeoDataFrame, file paths, GeoJSON, and list of dicts.\n\n        Args:\n            data: Input data in various formats.\n\n        Returns:\n            Processed data suitable for deck.gl layers.\n        \"\"\"\n        # Handle GeoDataFrame\n        if hasattr(data, \"__geo_interface__\"):\n            return data.__geo_interface__\n\n        # Handle file paths\n        if isinstance(data, (str, Path)):\n            path = Path(data)\n            if path.exists():\n                try:\n                    import geopandas as gpd\n\n                    gdf = gpd.read_file(path)\n                    return gdf.__geo_interface__\n                except ImportError:\n                    pass\n\n        # Return as-is for lists, dicts, etc.\n        return data\n\n    # -------------------------------------------------------------------------\n    # Layer Management\n    # -------------------------------------------------------------------------\n\n    def add_layer(\n        self,\n        layer_id: str,\n        layer_type: str,\n        source: Union[str, Dict],\n        paint: Optional[Dict] = None,\n        layout: Optional[Dict] = None,\n        before_id: Optional[str] = None,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a generic layer to the map.\n\n        Args:\n            layer_id: Unique layer identifier\n            layer_type: MapLibre layer type\n            source: Source ID or source configuration dict\n            paint: Paint properties\n            layout: Layout properties\n            before_id: ID of layer to insert before\n            **kwargs: Additional layer options\n        \"\"\"\n        layer_config = {\n            \"id\": layer_id,\n            \"type\": layer_type,\n            \"paint\": paint or {},\n            \"layout\": layout or {},\n            **kwargs,\n        }\n\n        if isinstance(source, str):\n            layer_config[\"source\"] = source\n        else:\n            source_id = f\"{layer_id}-source\"\n            self._sources = {**self._sources, source_id: source}\n            self.call_js_method(\"addSource\", source_id, **source)\n            layer_config[\"source\"] = source_id\n\n        self._layers = {**self._layers, layer_id: layer_config}\n        self.call_js_method(\"addLayer\", beforeId=before_id, **layer_config)\n\n    def remove_layer(self, layer_id: str) -&gt; None:\n        \"\"\"Remove a layer from the map.\n\n        Args:\n            layer_id: Layer identifier to remove\n        \"\"\"\n        if layer_id in self._layers:\n            layers = dict(self._layers)\n            del layers[layer_id]\n            self._layers = layers\n        self.call_js_method(\"removeLayer\", layer_id)\n\n    def set_visibility(self, layer_id: str, visible: bool) -&gt; None:\n        \"\"\"Set layer visibility.\n\n        Args:\n            layer_id: Layer identifier\n            visible: Whether layer should be visible\n        \"\"\"\n        self.call_js_method(\"setVisibility\", layer_id, visible)\n\n    def set_opacity(self, layer_id: str, opacity: float) -&gt; None:\n        \"\"\"Set layer opacity.\n\n        Args:\n            layer_id: Layer identifier\n            opacity: Opacity value between 0 and 1\n        \"\"\"\n        self.call_js_method(\"setOpacity\", layer_id, opacity)\n\n    # -------------------------------------------------------------------------\n    # Controls\n    # -------------------------------------------------------------------------\n\n    def add_control(\n        self,\n        control_type: str,\n        position: str = \"top-right\",\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a map control.\n\n        Args:\n            control_type: Type of control ('navigation', 'scale', 'fullscreen', etc.)\n            position: Control position\n            **kwargs: Control-specific options\n        \"\"\"\n        self.call_js_method(\"addControl\", control_type, position=position, **kwargs)\n        self._controls = {\n            **self._controls,\n            control_type: {\"type\": control_type, \"position\": position, **kwargs},\n        }\n\n    def remove_control(self, control_type: str) -&gt; None:\n        \"\"\"Remove a map control.\n\n        Args:\n            control_type: Type of control to remove\n        \"\"\"\n        self.call_js_method(\"removeControl\", control_type)\n        if control_type in self._controls:\n            controls = dict(self._controls)\n            del controls[control_type]\n            self._controls = controls\n\n    def add_layer_control(\n        self,\n        layers: Optional[List[str]] = None,\n        position: str = \"top-right\",\n        collapsed: bool = True,\n    ) -&gt; None:\n        \"\"\"Add a layer visibility control.\n\n        Uses maplibre-gl-layer-control for layer toggling and opacity.\n\n        Args:\n            layers: List of layer IDs to include (None = all layers)\n            position: Control position\n            collapsed: Whether control starts collapsed\n        \"\"\"\n        if layers is None:\n            layers = list(self._layers.keys())\n\n        self.call_js_method(\n            \"addLayerControl\",\n            layers=layers,\n            position=position,\n            collapsed=collapsed,\n        )\n        self._controls = {\n            **self._controls,\n            \"layer-control\": {\"layers\": layers, \"position\": position},\n        }\n\n    # -------------------------------------------------------------------------\n    # Drawing\n    # -------------------------------------------------------------------------\n\n    def add_draw_control(\n        self,\n        position: str = \"top-right\",\n        draw_modes: Optional[List[str]] = None,\n        edit_modes: Optional[List[str]] = None,\n        collapsed: bool = False,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a drawing control using maplibre-gl-geo-editor.\n\n        Args:\n            position: Control position\n            draw_modes: Drawing modes to enable (e.g., ['polygon', 'line', 'marker'])\n            edit_modes: Edit modes to enable (e.g., ['select', 'drag', 'delete'])\n            collapsed: Whether control starts collapsed\n            **kwargs: Additional geo-editor options\n        \"\"\"\n        if draw_modes is None:\n            draw_modes = [\"polygon\", \"line\", \"rectangle\", \"circle\", \"marker\"]\n        if edit_modes is None:\n            edit_modes = [\"select\", \"drag\", \"change\", \"rotate\", \"delete\"]\n\n        self.call_js_method(\n            \"addDrawControl\",\n            position=position,\n            drawModes=draw_modes,\n            editModes=edit_modes,\n            collapsed=collapsed,\n            **kwargs,\n        )\n        self._controls = {\n            **self._controls,\n            \"draw-control\": {\n                \"position\": position,\n                \"drawModes\": draw_modes,\n                \"editModes\": edit_modes,\n            },\n        }\n\n    def get_draw_data(self) -&gt; Dict:\n        \"\"\"Get the current drawn features as GeoJSON.\n\n        Returns:\n            GeoJSON FeatureCollection of drawn features\n        \"\"\"\n        self.call_js_method(\"getDrawData\")\n        # Small delay to allow JS to update the trait\n        import time\n\n        time.sleep(0.1)\n        return self._draw_data or {\"type\": \"FeatureCollection\", \"features\": []}\n\n    @property\n    def draw_data(self) -&gt; Dict:\n        \"\"\"Property to access current draw data.\"\"\"\n        return self._draw_data or {\"type\": \"FeatureCollection\", \"features\": []}\n\n    def load_draw_data(self, geojson: Dict) -&gt; None:\n        \"\"\"Load GeoJSON features into the drawing layer.\n\n        Args:\n            geojson: GeoJSON FeatureCollection to load\n        \"\"\"\n        self._draw_data = geojson\n        self.call_js_method(\"loadDrawData\", geojson)\n\n    def clear_draw_data(self) -&gt; None:\n        \"\"\"Clear all drawn features.\"\"\"\n        self._draw_data = {\"type\": \"FeatureCollection\", \"features\": []}\n        self.call_js_method(\"clearDrawData\")\n\n    def save_draw_data(\n        self,\n        filepath: Union[str, Path],\n        driver: Optional[str] = None,\n    ) -&gt; None:\n        \"\"\"Save drawn features to a file.\n\n        Args:\n            filepath: Path to save file\n            driver: Output driver (auto-detected from extension if not provided)\n\n        Raises:\n            ImportError: If geopandas is not installed\n        \"\"\"\n        try:\n            import geopandas as gpd\n        except ImportError:\n            raise ImportError(\n                \"geopandas is required to save draw data. \"\n                \"Install with: pip install anymap-ts[vector]\"\n            )\n\n        data = self.get_draw_data()\n        if not data.get(\"features\"):\n            print(\"No features to save\")\n            return\n\n        gdf = gpd.GeoDataFrame.from_features(data[\"features\"])\n        filepath = Path(filepath)\n\n        # Infer driver from extension\n        if driver is None:\n            ext = filepath.suffix.lower()\n            driver_map = {\n                \".geojson\": \"GeoJSON\",\n                \".json\": \"GeoJSON\",\n                \".shp\": \"ESRI Shapefile\",\n                \".gpkg\": \"GPKG\",\n            }\n            driver = driver_map.get(ext, \"GeoJSON\")\n\n        gdf.to_file(filepath, driver=driver)\n\n    # -------------------------------------------------------------------------\n    # HTML Export\n    # -------------------------------------------------------------------------\n\n    def _generate_html_template(self) -&gt; str:\n        \"\"\"Generate standalone HTML for the map.\"\"\"\n        template_path = Path(__file__).parent / \"templates\" / \"maplibre.html\"\n\n        if template_path.exists():\n            template = template_path.read_text(encoding=\"utf-8\")\n        else:\n            template = self._get_default_template()\n\n        # Serialize state\n        state = {\n            \"center\": self.center,\n            \"zoom\": self.zoom,\n            \"style\": self.style,\n            \"bearing\": self.bearing,\n            \"pitch\": self.pitch,\n            \"width\": self.width,\n            \"height\": self.height,\n            \"layers\": self._layers,\n            \"sources\": self._sources,\n            \"controls\": self._controls,\n            \"js_calls\": self._js_calls,\n        }\n\n        template = template.replace(\"{{state}}\", json.dumps(state, indent=2))\n        return template\n\n    def _get_default_template(self) -&gt; str:\n        \"\"\"Get default HTML template.\"\"\"\n        return \"\"\"&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n    &lt;meta charset=\"utf-8\"&gt;\n    &lt;title&gt;{{title}}&lt;/title&gt;\n    &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"&gt;\n    &lt;script src=\"https://unpkg.com/maplibre-gl@5/dist/maplibre-gl.js\"&gt;&lt;/script&gt;\n    &lt;link href=\"https://unpkg.com/maplibre-gl@5/dist/maplibre-gl.css\" rel=\"stylesheet\" /&gt;\n    &lt;style&gt;\n        body { margin: 0; padding: 0; }\n        #map { position: absolute; top: 0; bottom: 0; width: 100%; }\n    &lt;/style&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;div id=\"map\"&gt;&lt;/div&gt;\n    &lt;script&gt;\n        const state = {{state}};\n\n        const map = new maplibregl.Map({\n            container: 'map',\n            style: state.style,\n            center: state.center,\n            zoom: state.zoom,\n            bearing: state.bearing || 0,\n            pitch: state.pitch || 0\n        });\n\n        map.on('load', function() {\n            // Replay JS calls\n            for (const call of state.js_calls || []) {\n                try {\n                    executeMethod(call.method, call.args, call.kwargs);\n                } catch (e) {\n                    console.error('Error executing', call.method, e);\n                }\n            }\n        });\n\n        function executeMethod(method, args, kwargs) {\n            switch (method) {\n                case 'addBasemap':\n                    const url = args[0];\n                    const name = kwargs.name || 'basemap';\n                    const sourceId = 'basemap-' + name;\n                    if (!map.getSource(sourceId)) {\n                        map.addSource(sourceId, {\n                            type: 'raster',\n                            tiles: [url],\n                            tileSize: 256,\n                            attribution: kwargs.attribution || ''\n                        });\n                    }\n                    if (!map.getLayer(sourceId)) {\n                        map.addLayer({\n                            id: sourceId,\n                            type: 'raster',\n                            source: sourceId\n                        });\n                    }\n                    break;\n\n                case 'addGeoJSON':\n                    const layerName = kwargs.name;\n                    const sourceIdGeo = layerName + '-source';\n                    if (!map.getSource(sourceIdGeo)) {\n                        map.addSource(sourceIdGeo, {\n                            type: 'geojson',\n                            data: kwargs.data\n                        });\n                    }\n                    if (!map.getLayer(layerName)) {\n                        map.addLayer({\n                            id: layerName,\n                            type: kwargs.layerType || 'circle',\n                            source: sourceIdGeo,\n                            paint: kwargs.paint || {}\n                        });\n                    }\n                    if (kwargs.fitBounds &amp;&amp; kwargs.bounds) {\n                        map.fitBounds([\n                            [kwargs.bounds[0], kwargs.bounds[1]],\n                            [kwargs.bounds[2], kwargs.bounds[3]]\n                        ], { padding: 50 });\n                    }\n                    break;\n\n                case 'addTileLayer':\n                    const tileUrl = args[0];\n                    const tileName = kwargs.name;\n                    const tileSourceId = tileName + '-source';\n                    if (!map.getSource(tileSourceId)) {\n                        map.addSource(tileSourceId, {\n                            type: 'raster',\n                            tiles: [tileUrl],\n                            tileSize: 256,\n                            attribution: kwargs.attribution || ''\n                        });\n                    }\n                    if (!map.getLayer(tileName)) {\n                        map.addLayer({\n                            id: tileName,\n                            type: 'raster',\n                            source: tileSourceId\n                        });\n                    }\n                    break;\n\n                case 'addControl':\n                    const controlType = args[0];\n                    const position = kwargs.position || 'top-right';\n                    let control;\n                    switch (controlType) {\n                        case 'navigation':\n                            control = new maplibregl.NavigationControl();\n                            break;\n                        case 'scale':\n                            control = new maplibregl.ScaleControl();\n                            break;\n                        case 'fullscreen':\n                            control = new maplibregl.FullscreenControl();\n                            break;\n                    }\n                    if (control) {\n                        map.addControl(control, position);\n                    }\n                    break;\n\n                case 'flyTo':\n                    map.flyTo({\n                        center: [args[0], args[1]],\n                        zoom: kwargs.zoom,\n                        duration: kwargs.duration || 2000\n                    });\n                    break;\n\n                case 'fitBounds':\n                    const bounds = args[0];\n                    map.fitBounds([\n                        [bounds[0], bounds[1]],\n                        [bounds[2], bounds[3]]\n                    ], {\n                        padding: kwargs.padding || 50,\n                        duration: kwargs.duration || 1000\n                    });\n                    break;\n\n                default:\n                    console.log('Unknown method:', method);\n            }\n        }\n    &lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\"\"\"\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.maplibre.MapLibreMap.draw_data","title":"<code>draw_data: Dict</code>  <code>property</code> <code>readonly</code>","text":"<p>Property to access current draw data.</p>"},{"location":"anymap_ts/#anymap_ts.maplibre.MapLibreMap.__init__","title":"<code>__init__(self, center=(0.0, 0.0), zoom=2.0, width='100%', height='700px', style='https://basemaps.cartocdn.com/gl/positron-gl-style/style.json', bearing=0.0, pitch=0.0, max_pitch=85.0, controls=None, **kwargs)</code>  <code>special</code>","text":"<p>Initialize a MapLibre map.</p> <p>Parameters:</p> Name Type Description Default <code>center</code> <code>Tuple[float, float]</code> <p>Map center as (longitude, latitude).</p> <code>(0.0, 0.0)</code> <code>zoom</code> <code>float</code> <p>Initial zoom level.</p> <code>2.0</code> <code>width</code> <code>str</code> <p>Map width as CSS string.</p> <code>'100%'</code> <code>height</code> <code>str</code> <p>Map height as CSS string. Default is \"700px\".</p> <code>'700px'</code> <code>style</code> <code>Union[str, Dict]</code> <p>MapLibre style URL or style object. Default is \"https://basemaps.cartocdn.com/gl/positron-gl-style/style.json\".</p> <code>'https://basemaps.cartocdn.com/gl/positron-gl-style/style.json'</code> <code>bearing</code> <code>float</code> <p>Map bearing in degrees.</p> <code>0.0</code> <code>pitch</code> <code>float</code> <p>Map pitch in degrees.</p> <code>0.0</code> <code>max_pitch</code> <code>float</code> <p>Maximum pitch angle in degrees (default: 85).</p> <code>85.0</code> <code>controls</code> <code>Optional[Dict[str, Any]]</code> <p>Dict of controls to add. If None, defaults to {\"layer-control\": True, \"control-grid\": True}. Use {\"layer-control\": {\"collapsed\": True}} for custom options.</p> <code>None</code> <code>**kwargs</code> <p>Additional widget arguments.</p> <code>{}</code> Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def __init__(\n    self,\n    center: Tuple[float, float] = (0.0, 0.0),\n    zoom: float = 2.0,\n    width: str = \"100%\",\n    height: str = \"700px\",\n    style: Union[\n        str, Dict\n    ] = \"https://basemaps.cartocdn.com/gl/positron-gl-style/style.json\",\n    bearing: float = 0.0,\n    pitch: float = 0.0,\n    max_pitch: float = 85.0,\n    controls: Optional[Dict[str, Any]] = None,\n    **kwargs,\n):\n    \"\"\"Initialize a MapLibre map.\n\n    Args:\n        center: Map center as (longitude, latitude).\n        zoom: Initial zoom level.\n        width: Map width as CSS string.\n        height: Map height as CSS string. Default is \"700px\".\n        style: MapLibre style URL or style object. Default is \"https://basemaps.cartocdn.com/gl/positron-gl-style/style.json\".\n        bearing: Map bearing in degrees.\n        pitch: Map pitch in degrees.\n        max_pitch: Maximum pitch angle in degrees (default: 85).\n        controls: Dict of controls to add. If None, defaults to\n            {\"layer-control\": True, \"control-grid\": True}.\n            Use {\"layer-control\": {\"collapsed\": True}} for custom options.\n        **kwargs: Additional widget arguments.\n    \"\"\"\n    # Handle style shortcuts\n    if isinstance(style, str) and not style.startswith(\"http\"):\n        try:\n            style = get_maplibre_style(style)\n        except ValueError:\n            pass  # Use as-is\n\n    super().__init__(\n        center=list(center),\n        zoom=zoom,\n        width=width,\n        height=height,\n        style=style,\n        bearing=bearing,\n        pitch=pitch,\n        max_pitch=max_pitch,\n        **kwargs,\n    )\n\n    # Initialize layer dictionary\n    self._layer_dict = {\"Background\": []}\n\n    # Add default controls\n    if controls is None:\n        controls = {\n            \"layer-control\": True,\n            \"control-grid\": True,\n        }\n\n    for control_name, config in controls.items():\n        if config:\n            if control_name == \"layer-control\":\n                self.add_layer_control(\n                    **(config if isinstance(config, dict) else {})\n                )\n            elif control_name == \"control-grid\":\n                self.add_control_grid(\n                    **(config if isinstance(config, dict) else {})\n                )\n            else:\n                self.add_control(\n                    control_name, **(config if isinstance(config, dict) else {})\n                )\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.maplibre.MapLibreMap.add_arc_layer","title":"<code>add_arc_layer(self, data, name=None, get_source_position='source', get_target_position='target', get_source_color=None, get_target_color=None, get_width=1, get_height=1, great_circle=False, pickable=True, opacity=0.8, **kwargs)</code>","text":"<p>Add an arc layer for origin-destination visualization using deck.gl.</p> <p>Arc layers are ideal for visualizing connections between locations, such as flight routes, migration patterns, or network flows.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>Array of data objects with source/target coordinates. Each object should have source and target positions.</p> required <code>name</code> <code>Optional[str]</code> <p>Layer ID. If None, auto-generated.</p> <code>None</code> <code>get_source_position</code> <code>Union[str, Any]</code> <p>Accessor for source position [lng, lat]. Can be a string (property name) or a value.</p> <code>'source'</code> <code>get_target_position</code> <code>Union[str, Any]</code> <p>Accessor for target position [lng, lat]. Can be a string (property name) or a value.</p> <code>'target'</code> <code>get_source_color</code> <code>Optional[List[int]]</code> <p>Source end color as [r, g, b, a]. Default: [51, 136, 255, 255] (blue).</p> <code>None</code> <code>get_target_color</code> <code>Optional[List[int]]</code> <p>Target end color as [r, g, b, a]. Default: [255, 136, 51, 255] (orange).</p> <code>None</code> <code>get_width</code> <code>Union[float, str]</code> <p>Arc width in pixels. Can be a number or accessor.</p> <code>1</code> <code>get_height</code> <code>float</code> <p>Arc height multiplier. Higher values create more curved arcs.</p> <code>1</code> <code>great_circle</code> <code>bool</code> <p>Whether to draw arcs along great circles.</p> <code>False</code> <code>pickable</code> <code>bool</code> <p>Whether layer responds to hover/click events.</p> <code>True</code> <code>opacity</code> <code>float</code> <p>Layer opacity (0-1).</p> <code>0.8</code> <code>**kwargs</code> <p>Additional ArcLayer props.</p> <code>{}</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from anymap_ts import MapLibreMap\n&gt;&gt;&gt; m = MapLibreMap()\n&gt;&gt;&gt; arcs = [\n...     {\"source\": [-122.4, 37.8], \"target\": [-73.9, 40.7]},\n...     {\"source\": [-122.4, 37.8], \"target\": [-0.1, 51.5]},\n... ]\n&gt;&gt;&gt; m.add_arc_layer(arcs, name=\"flights\")\n</code></pre> Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def add_arc_layer(\n    self,\n    data: Any,\n    name: Optional[str] = None,\n    get_source_position: Union[str, Any] = \"source\",\n    get_target_position: Union[str, Any] = \"target\",\n    get_source_color: Optional[List[int]] = None,\n    get_target_color: Optional[List[int]] = None,\n    get_width: Union[float, str] = 1,\n    get_height: float = 1,\n    great_circle: bool = False,\n    pickable: bool = True,\n    opacity: float = 0.8,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add an arc layer for origin-destination visualization using deck.gl.\n\n    Arc layers are ideal for visualizing connections between locations,\n    such as flight routes, migration patterns, or network flows.\n\n    Args:\n        data: Array of data objects with source/target coordinates.\n            Each object should have source and target positions.\n        name: Layer ID. If None, auto-generated.\n        get_source_position: Accessor for source position [lng, lat].\n            Can be a string (property name) or a value.\n        get_target_position: Accessor for target position [lng, lat].\n            Can be a string (property name) or a value.\n        get_source_color: Source end color as [r, g, b, a].\n            Default: [51, 136, 255, 255] (blue).\n        get_target_color: Target end color as [r, g, b, a].\n            Default: [255, 136, 51, 255] (orange).\n        get_width: Arc width in pixels. Can be a number or accessor.\n        get_height: Arc height multiplier. Higher values create more curved arcs.\n        great_circle: Whether to draw arcs along great circles.\n        pickable: Whether layer responds to hover/click events.\n        opacity: Layer opacity (0-1).\n        **kwargs: Additional ArcLayer props.\n\n    Example:\n        &gt;&gt;&gt; from anymap_ts import MapLibreMap\n        &gt;&gt;&gt; m = MapLibreMap()\n        &gt;&gt;&gt; arcs = [\n        ...     {\"source\": [-122.4, 37.8], \"target\": [-73.9, 40.7]},\n        ...     {\"source\": [-122.4, 37.8], \"target\": [-0.1, 51.5]},\n        ... ]\n        &gt;&gt;&gt; m.add_arc_layer(arcs, name=\"flights\")\n    \"\"\"\n    layer_id = name or f\"arc-{len(self._layers)}\"\n    processed_data = self._process_deck_data(data)\n\n    self.call_js_method(\n        \"addArcLayer\",\n        id=layer_id,\n        data=processed_data,\n        getSourcePosition=get_source_position,\n        getTargetPosition=get_target_position,\n        getSourceColor=get_source_color or [51, 136, 255, 255],\n        getTargetColor=get_target_color or [255, 136, 51, 255],\n        getWidth=get_width,\n        getHeight=get_height,\n        greatCircle=great_circle,\n        pickable=pickable,\n        opacity=opacity,\n        **kwargs,\n    )\n\n    self._layers = {\n        **self._layers,\n        layer_id: {\n            \"id\": layer_id,\n            \"type\": \"arc\",\n        },\n    }\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.maplibre.MapLibreMap.add_basemap","title":"<code>add_basemap(self, basemap='OpenStreetMap', attribution=None, **kwargs)</code>","text":"<p>Add a basemap layer.</p> <p>Parameters:</p> Name Type Description Default <code>basemap</code> <code>str</code> <p>Name of basemap provider (e.g., \"OpenStreetMap\", \"CartoDB.Positron\")</p> <code>'OpenStreetMap'</code> <code>attribution</code> <code>Optional[str]</code> <p>Custom attribution text</p> <code>None</code> <code>**kwargs</code> <p>Additional options</p> <code>{}</code> Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def add_basemap(\n    self,\n    basemap: str = \"OpenStreetMap\",\n    attribution: Optional[str] = None,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a basemap layer.\n\n    Args:\n        basemap: Name of basemap provider (e.g., \"OpenStreetMap\", \"CartoDB.Positron\")\n        attribution: Custom attribution text\n        **kwargs: Additional options\n    \"\"\"\n    url, default_attribution = get_basemap_url(basemap)\n    self.call_js_method(\n        \"addBasemap\",\n        url,\n        attribution=attribution or default_attribution,\n        name=basemap,\n        **kwargs,\n    )\n\n    # Track in layer dict\n    basemaps = self._layer_dict.get(\"Basemaps\", [])\n    if basemap not in basemaps:\n        self._layer_dict = {\n            **self._layer_dict,\n            \"Basemaps\": basemaps + [basemap],\n        }\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.maplibre.MapLibreMap.add_cog_control","title":"<code>add_cog_control(self, position='top-right', collapsed=True, default_url=None, load_default_url=False, default_opacity=1.0, default_colormap='viridis', default_bands='1', default_rescale_min=0, default_rescale_max=255, **kwargs)</code>","text":"<p>Add a COG layer control for loading Cloud Optimized GeoTIFFs via UI.</p> <p>This provides an interactive panel for users to enter COG URLs and configure visualization parameters like colormap and rescaling.</p> <p>Parameters:</p> Name Type Description Default <code>position</code> <code>str</code> <p>Control position ('top-left', 'top-right', 'bottom-left', 'bottom-right').</p> <code>'top-right'</code> <code>collapsed</code> <code>bool</code> <p>Whether the panel starts collapsed.</p> <code>True</code> <code>default_url</code> <code>Optional[str]</code> <p>Default COG URL to pre-fill.</p> <code>None</code> <code>load_default_url</code> <code>bool</code> <p>Whether to auto-load the default URL.</p> <code>False</code> <code>default_opacity</code> <code>float</code> <p>Default layer opacity (0-1).</p> <code>1.0</code> <code>default_colormap</code> <code>str</code> <p>Default colormap name.</p> <code>'viridis'</code> <code>default_bands</code> <code>str</code> <p>Default bands (e.g., '1' or '1,2,3').</p> <code>'1'</code> <code>default_rescale_min</code> <code>float</code> <p>Default minimum value for rescaling.</p> <code>0</code> <code>default_rescale_max</code> <code>float</code> <p>Default maximum value for rescaling.</p> <code>255</code> <code>**kwargs</code> <p>Additional control options.</p> <code>{}</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from anymap_ts import MapLibreMap\n&gt;&gt;&gt; m = MapLibreMap()\n&gt;&gt;&gt; m.add_cog_control(\n...     default_url=\"https://example.com/cog.tif\",\n...     default_colormap=\"terrain\"\n... )\n</code></pre> Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def add_cog_control(\n    self,\n    position: str = \"top-right\",\n    collapsed: bool = True,\n    default_url: Optional[str] = None,\n    load_default_url: bool = False,\n    default_opacity: float = 1.0,\n    default_colormap: str = \"viridis\",\n    default_bands: str = \"1\",\n    default_rescale_min: float = 0,\n    default_rescale_max: float = 255,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a COG layer control for loading Cloud Optimized GeoTIFFs via UI.\n\n    This provides an interactive panel for users to enter COG URLs\n    and configure visualization parameters like colormap and rescaling.\n\n    Args:\n        position: Control position ('top-left', 'top-right', 'bottom-left', 'bottom-right').\n        collapsed: Whether the panel starts collapsed.\n        default_url: Default COG URL to pre-fill.\n        load_default_url: Whether to auto-load the default URL.\n        default_opacity: Default layer opacity (0-1).\n        default_colormap: Default colormap name.\n        default_bands: Default bands (e.g., '1' or '1,2,3').\n        default_rescale_min: Default minimum value for rescaling.\n        default_rescale_max: Default maximum value for rescaling.\n        **kwargs: Additional control options.\n\n    Example:\n        &gt;&gt;&gt; from anymap_ts import MapLibreMap\n        &gt;&gt;&gt; m = MapLibreMap()\n        &gt;&gt;&gt; m.add_cog_control(\n        ...     default_url=\"https://example.com/cog.tif\",\n        ...     default_colormap=\"terrain\"\n        ... )\n    \"\"\"\n    self.call_js_method(\n        \"addCogControl\",\n        position=position,\n        collapsed=collapsed,\n        defaultUrl=default_url or \"\",\n        loadDefaultUrl=load_default_url,\n        defaultOpacity=default_opacity,\n        defaultColormap=default_colormap,\n        defaultBands=default_bands,\n        defaultRescaleMin=default_rescale_min,\n        defaultRescaleMax=default_rescale_max,\n        **kwargs,\n    )\n    self._controls = {\n        **self._controls,\n        \"cog-control\": {\"position\": position, \"collapsed\": collapsed},\n    }\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.maplibre.MapLibreMap.add_cog_layer","title":"<code>add_cog_layer(self, url, name=None, opacity=1.0, visible=True, debug=False, debug_opacity=0.25, max_error=0.125, fit_bounds=True, before_id=None, **kwargs)</code>","text":"<p>Add a Cloud Optimized GeoTIFF (COG) layer using @developmentseed/deck.gl-geotiff.</p> <p>This method renders COG files directly in the browser using GPU-accelerated deck.gl-geotiff rendering with automatic reprojection support.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>URL to the Cloud Optimized GeoTIFF file.</p> required <code>name</code> <code>Optional[str]</code> <p>Layer ID. If None, auto-generated.</p> <code>None</code> <code>opacity</code> <code>float</code> <p>Layer opacity (0-1).</p> <code>1.0</code> <code>visible</code> <code>bool</code> <p>Whether layer is visible.</p> <code>True</code> <code>debug</code> <code>bool</code> <p>Show reprojection mesh for debugging.</p> <code>False</code> <code>debug_opacity</code> <code>float</code> <p>Opacity of debug mesh (0-1).</p> <code>0.25</code> <code>max_error</code> <code>float</code> <p>Maximum reprojection error in pixels. Lower values create denser mesh for better accuracy.</p> <code>0.125</code> <code>fit_bounds</code> <code>bool</code> <p>Whether to fit map to COG bounds after loading.</p> <code>True</code> <code>before_id</code> <code>Optional[str]</code> <p>ID of layer to insert before.</p> <code>None</code> <code>**kwargs</code> <p>Additional COGLayer props.</p> <code>{}</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from anymap_ts import Map\n&gt;&gt;&gt; m = Map()\n&gt;&gt;&gt; m.add_cog_layer(\n...     \"https://example.com/landcover.tif\",\n...     name=\"landcover\",\n...     opacity=0.8\n... )\n</code></pre> Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def add_cog_layer(\n    self,\n    url: str,\n    name: Optional[str] = None,\n    opacity: float = 1.0,\n    visible: bool = True,\n    debug: bool = False,\n    debug_opacity: float = 0.25,\n    max_error: float = 0.125,\n    fit_bounds: bool = True,\n    before_id: Optional[str] = None,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a Cloud Optimized GeoTIFF (COG) layer using @developmentseed/deck.gl-geotiff.\n\n    This method renders COG files directly in the browser using GPU-accelerated\n    deck.gl-geotiff rendering with automatic reprojection support.\n\n    Args:\n        url: URL to the Cloud Optimized GeoTIFF file.\n        name: Layer ID. If None, auto-generated.\n        opacity: Layer opacity (0-1).\n        visible: Whether layer is visible.\n        debug: Show reprojection mesh for debugging.\n        debug_opacity: Opacity of debug mesh (0-1).\n        max_error: Maximum reprojection error in pixels. Lower values\n            create denser mesh for better accuracy.\n        fit_bounds: Whether to fit map to COG bounds after loading.\n        before_id: ID of layer to insert before.\n        **kwargs: Additional COGLayer props.\n\n    Example:\n        &gt;&gt;&gt; from anymap_ts import Map\n        &gt;&gt;&gt; m = Map()\n        &gt;&gt;&gt; m.add_cog_layer(\n        ...     \"https://example.com/landcover.tif\",\n        ...     name=\"landcover\",\n        ...     opacity=0.8\n        ... )\n    \"\"\"\n    layer_id = name or f\"cog-{len(self._layers)}\"\n\n    self.call_js_method(\n        \"addCOGLayer\",\n        id=layer_id,\n        geotiff=url,\n        opacity=opacity,\n        visible=visible,\n        debug=debug,\n        debugOpacity=debug_opacity,\n        maxError=max_error,\n        fitBounds=fit_bounds,\n        beforeId=before_id,\n        **kwargs,\n    )\n\n    self._layers = {\n        **self._layers,\n        layer_id: {\n            \"id\": layer_id,\n            \"type\": \"cog\",\n            \"url\": url,\n        },\n    }\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.maplibre.MapLibreMap.add_control","title":"<code>add_control(self, control_type, position='top-right', **kwargs)</code>","text":"<p>Add a map control.</p> <p>Parameters:</p> Name Type Description Default <code>control_type</code> <code>str</code> <p>Type of control ('navigation', 'scale', 'fullscreen', etc.)</p> required <code>position</code> <code>str</code> <p>Control position</p> <code>'top-right'</code> <code>**kwargs</code> <p>Control-specific options</p> <code>{}</code> Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def add_control(\n    self,\n    control_type: str,\n    position: str = \"top-right\",\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a map control.\n\n    Args:\n        control_type: Type of control ('navigation', 'scale', 'fullscreen', etc.)\n        position: Control position\n        **kwargs: Control-specific options\n    \"\"\"\n    self.call_js_method(\"addControl\", control_type, position=position, **kwargs)\n    self._controls = {\n        **self._controls,\n        control_type: {\"type\": control_type, \"position\": position, **kwargs},\n    }\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.maplibre.MapLibreMap.add_control_grid","title":"<code>add_control_grid(self, position='top-right', default_controls=None, exclude=None, rows=None, columns=None, collapsed=True, collapsible=True, title='', show_row_column_controls=True, gap=2, basemap_style_url=None, exclude_layers=None, **kwargs)</code>","text":"<p>Add a ControlGrid with all default tools or a custom subset.</p> <p>The ControlGrid provides a collapsible toolbar with up to 26 built-in controls (search, basemap, terrain, measure, draw, etc.) in a configurable grid layout.</p> <p>Parameters:</p> Name Type Description Default <code>position</code> <code>str</code> <p>Control position ('top-left', 'top-right', 'bottom-left', 'bottom-right').</p> <code>'top-right'</code> <code>default_controls</code> <code>Optional[List[str]]</code> <p>Explicit list of control names to include. If None, all 26 default controls are used (minus any in <code>exclude</code>). Valid names: 'globe', 'fullscreen', 'north', 'terrain', 'search', 'viewState', 'inspect', 'vectorDataset', 'basemap', 'measure', 'geoEditor', 'bookmark', 'print', 'minimap', 'swipe', 'streetView', 'addVector', 'cogLayer', 'zarrLayer', 'pmtilesLayer', 'stacLayer', 'stacSearch', 'planetaryComputer', 'gaussianSplat', 'lidar', 'usgsLidar'.</p> <code>None</code> <code>exclude</code> <code>Optional[List[str]]</code> <p>Controls to remove from the default set. Ignored when <code>default_controls</code> is provided.</p> <code>None</code> <code>rows</code> <code>Optional[int]</code> <p>Number of grid rows (auto-calculated if None).</p> <code>None</code> <code>columns</code> <code>Optional[int]</code> <p>Number of grid columns (auto-calculated if None).</p> <code>None</code> <code>collapsed</code> <code>bool</code> <p>Whether the grid starts collapsed. Default True.</p> <code>True</code> <code>collapsible</code> <code>bool</code> <p>Whether the grid can be collapsed. Default True.</p> <code>True</code> <code>title</code> <code>str</code> <p>Optional header title for the grid.</p> <code>''</code> <code>show_row_column_controls</code> <code>bool</code> <p>Show row/column input fields. Default True.</p> <code>True</code> <code>gap</code> <code>int</code> <p>Gap between grid cells in pixels. Default 2.</p> <code>2</code> <code>basemap_style_url</code> <code>Optional[str]</code> <p>Basemap style URL for SwipeControl layer grouping. If None, the current map style is used automatically.</p> <code>None</code> <code>exclude_layers</code> <code>Optional[List[str]]</code> <p>Layer ID patterns to exclude from SwipeControl (e.g., 'measure-', 'gl-draw-'). If None, sensible defaults are applied.</p> <code>None</code> <code>**kwargs</code> <p>Additional ControlGrid options.</p> <code>{}</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from anymap_ts import MapLibreMap\n&gt;&gt;&gt; m = MapLibreMap()\n&gt;&gt;&gt; m.add_control_grid()  # All 26 controls\n&gt;&gt;&gt; # Or with customization:\n&gt;&gt;&gt; m.add_control_grid(\n...     exclude=[\"minimap\", \"streetView\"],\n...     collapsed=True,\n... )\n</code></pre> Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def add_control_grid(\n    self,\n    position: str = \"top-right\",\n    default_controls: Optional[List[str]] = None,\n    exclude: Optional[List[str]] = None,\n    rows: Optional[int] = None,\n    columns: Optional[int] = None,\n    collapsed: bool = True,\n    collapsible: bool = True,\n    title: str = \"\",\n    show_row_column_controls: bool = True,\n    gap: int = 2,\n    basemap_style_url: Optional[str] = None,\n    exclude_layers: Optional[List[str]] = None,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a ControlGrid with all default tools or a custom subset.\n\n    The ControlGrid provides a collapsible toolbar with up to 26 built-in\n    controls (search, basemap, terrain, measure, draw, etc.) in a\n    configurable grid layout.\n\n    Args:\n        position: Control position ('top-left', 'top-right', 'bottom-left',\n            'bottom-right').\n        default_controls: Explicit list of control names to include. If None,\n            all 26 default controls are used (minus any in ``exclude``).\n            Valid names: 'globe', 'fullscreen', 'north', 'terrain', 'search',\n            'viewState', 'inspect', 'vectorDataset', 'basemap', 'measure',\n            'geoEditor', 'bookmark', 'print', 'minimap', 'swipe',\n            'streetView', 'addVector', 'cogLayer', 'zarrLayer',\n            'pmtilesLayer', 'stacLayer', 'stacSearch', 'planetaryComputer',\n            'gaussianSplat', 'lidar', 'usgsLidar'.\n        exclude: Controls to remove from the default set. Ignored when\n            ``default_controls`` is provided.\n        rows: Number of grid rows (auto-calculated if None).\n        columns: Number of grid columns (auto-calculated if None).\n        collapsed: Whether the grid starts collapsed. Default True.\n        collapsible: Whether the grid can be collapsed. Default True.\n        title: Optional header title for the grid.\n        show_row_column_controls: Show row/column input fields. Default True.\n        gap: Gap between grid cells in pixels. Default 2.\n        basemap_style_url: Basemap style URL for SwipeControl layer grouping.\n            If None, the current map style is used automatically.\n        exclude_layers: Layer ID patterns to exclude from SwipeControl\n            (e.g., 'measure-*', 'gl-draw-*'). If None, sensible defaults\n            are applied.\n        **kwargs: Additional ControlGrid options.\n\n    Example:\n        &gt;&gt;&gt; from anymap_ts import MapLibreMap\n        &gt;&gt;&gt; m = MapLibreMap()\n        &gt;&gt;&gt; m.add_control_grid()  # All 26 controls\n        &gt;&gt;&gt; # Or with customization:\n        &gt;&gt;&gt; m.add_control_grid(\n        ...     exclude=[\"minimap\", \"streetView\"],\n        ...     collapsed=True,\n        ... )\n    \"\"\"\n    js_kwargs: Dict[str, Any] = {\n        \"position\": position,\n        \"collapsed\": collapsed,\n        \"collapsible\": collapsible,\n        \"showRowColumnControls\": show_row_column_controls,\n        \"gap\": gap,\n        **kwargs,\n    }\n    if default_controls is not None:\n        js_kwargs[\"defaultControls\"] = default_controls\n    if exclude is not None:\n        js_kwargs[\"exclude\"] = exclude\n    if rows is not None:\n        js_kwargs[\"rows\"] = rows\n    if columns is not None:\n        js_kwargs[\"columns\"] = columns\n    if title:\n        js_kwargs[\"title\"] = title\n    if basemap_style_url is not None:\n        js_kwargs[\"basemapStyleUrl\"] = basemap_style_url\n    if exclude_layers is not None:\n        js_kwargs[\"excludeLayers\"] = exclude_layers\n\n    self.call_js_method(\"addControlGrid\", **js_kwargs)\n    self._controls = {\n        **self._controls,\n        \"control-grid\": {\"position\": position, \"collapsed\": collapsed},\n    }\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.maplibre.MapLibreMap.add_draw_control","title":"<code>add_draw_control(self, position='top-right', draw_modes=None, edit_modes=None, collapsed=False, **kwargs)</code>","text":"<p>Add a drawing control using maplibre-gl-geo-editor.</p> <p>Parameters:</p> Name Type Description Default <code>position</code> <code>str</code> <p>Control position</p> <code>'top-right'</code> <code>draw_modes</code> <code>Optional[List[str]]</code> <p>Drawing modes to enable (e.g., ['polygon', 'line', 'marker'])</p> <code>None</code> <code>edit_modes</code> <code>Optional[List[str]]</code> <p>Edit modes to enable (e.g., ['select', 'drag', 'delete'])</p> <code>None</code> <code>collapsed</code> <code>bool</code> <p>Whether control starts collapsed</p> <code>False</code> <code>**kwargs</code> <p>Additional geo-editor options</p> <code>{}</code> Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def add_draw_control(\n    self,\n    position: str = \"top-right\",\n    draw_modes: Optional[List[str]] = None,\n    edit_modes: Optional[List[str]] = None,\n    collapsed: bool = False,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a drawing control using maplibre-gl-geo-editor.\n\n    Args:\n        position: Control position\n        draw_modes: Drawing modes to enable (e.g., ['polygon', 'line', 'marker'])\n        edit_modes: Edit modes to enable (e.g., ['select', 'drag', 'delete'])\n        collapsed: Whether control starts collapsed\n        **kwargs: Additional geo-editor options\n    \"\"\"\n    if draw_modes is None:\n        draw_modes = [\"polygon\", \"line\", \"rectangle\", \"circle\", \"marker\"]\n    if edit_modes is None:\n        edit_modes = [\"select\", \"drag\", \"change\", \"rotate\", \"delete\"]\n\n    self.call_js_method(\n        \"addDrawControl\",\n        position=position,\n        drawModes=draw_modes,\n        editModes=edit_modes,\n        collapsed=collapsed,\n        **kwargs,\n    )\n    self._controls = {\n        **self._controls,\n        \"draw-control\": {\n            \"position\": position,\n            \"drawModes\": draw_modes,\n            \"editModes\": edit_modes,\n        },\n    }\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.maplibre.MapLibreMap.add_geojson","title":"<code>add_geojson(self, data, layer_type=None, paint=None, name=None, fit_bounds=True, **kwargs)</code>","text":"<p>Add GeoJSON data to the map.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Union[str, Dict]</code> <p>GeoJSON dict or URL to GeoJSON file</p> required <code>layer_type</code> <code>Optional[str]</code> <p>MapLibre layer type</p> <code>None</code> <code>paint</code> <code>Optional[Dict]</code> <p>MapLibre paint properties</p> <code>None</code> <code>name</code> <code>Optional[str]</code> <p>Layer name</p> <code>None</code> <code>fit_bounds</code> <code>bool</code> <p>Whether to fit map to data bounds</p> <code>True</code> <code>**kwargs</code> <p>Additional layer options</p> <code>{}</code> Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def add_geojson(\n    self,\n    data: Union[str, Dict],\n    layer_type: Optional[str] = None,\n    paint: Optional[Dict] = None,\n    name: Optional[str] = None,\n    fit_bounds: bool = True,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add GeoJSON data to the map.\n\n    Args:\n        data: GeoJSON dict or URL to GeoJSON file\n        layer_type: MapLibre layer type\n        paint: MapLibre paint properties\n        name: Layer name\n        fit_bounds: Whether to fit map to data bounds\n        **kwargs: Additional layer options\n    \"\"\"\n    self.add_vector(\n        data,\n        layer_type=layer_type,\n        paint=paint,\n        name=name,\n        fit_bounds=fit_bounds,\n        **kwargs,\n    )\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.maplibre.MapLibreMap.add_layer","title":"<code>add_layer(self, layer_id, layer_type, source, paint=None, layout=None, before_id=None, **kwargs)</code>","text":"<p>Add a generic layer to the map.</p> <p>Parameters:</p> Name Type Description Default <code>layer_id</code> <code>str</code> <p>Unique layer identifier</p> required <code>layer_type</code> <code>str</code> <p>MapLibre layer type</p> required <code>source</code> <code>Union[str, Dict]</code> <p>Source ID or source configuration dict</p> required <code>paint</code> <code>Optional[Dict]</code> <p>Paint properties</p> <code>None</code> <code>layout</code> <code>Optional[Dict]</code> <p>Layout properties</p> <code>None</code> <code>before_id</code> <code>Optional[str]</code> <p>ID of layer to insert before</p> <code>None</code> <code>**kwargs</code> <p>Additional layer options</p> <code>{}</code> Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def add_layer(\n    self,\n    layer_id: str,\n    layer_type: str,\n    source: Union[str, Dict],\n    paint: Optional[Dict] = None,\n    layout: Optional[Dict] = None,\n    before_id: Optional[str] = None,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a generic layer to the map.\n\n    Args:\n        layer_id: Unique layer identifier\n        layer_type: MapLibre layer type\n        source: Source ID or source configuration dict\n        paint: Paint properties\n        layout: Layout properties\n        before_id: ID of layer to insert before\n        **kwargs: Additional layer options\n    \"\"\"\n    layer_config = {\n        \"id\": layer_id,\n        \"type\": layer_type,\n        \"paint\": paint or {},\n        \"layout\": layout or {},\n        **kwargs,\n    }\n\n    if isinstance(source, str):\n        layer_config[\"source\"] = source\n    else:\n        source_id = f\"{layer_id}-source\"\n        self._sources = {**self._sources, source_id: source}\n        self.call_js_method(\"addSource\", source_id, **source)\n        layer_config[\"source\"] = source_id\n\n    self._layers = {**self._layers, layer_id: layer_config}\n    self.call_js_method(\"addLayer\", beforeId=before_id, **layer_config)\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.maplibre.MapLibreMap.add_layer_control","title":"<code>add_layer_control(self, layers=None, position='top-right', collapsed=True)</code>","text":"<p>Add a layer visibility control.</p> <p>Uses maplibre-gl-layer-control for layer toggling and opacity.</p> <p>Parameters:</p> Name Type Description Default <code>layers</code> <code>Optional[List[str]]</code> <p>List of layer IDs to include (None = all layers)</p> <code>None</code> <code>position</code> <code>str</code> <p>Control position</p> <code>'top-right'</code> <code>collapsed</code> <code>bool</code> <p>Whether control starts collapsed</p> <code>True</code> Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def add_layer_control(\n    self,\n    layers: Optional[List[str]] = None,\n    position: str = \"top-right\",\n    collapsed: bool = True,\n) -&gt; None:\n    \"\"\"Add a layer visibility control.\n\n    Uses maplibre-gl-layer-control for layer toggling and opacity.\n\n    Args:\n        layers: List of layer IDs to include (None = all layers)\n        position: Control position\n        collapsed: Whether control starts collapsed\n    \"\"\"\n    if layers is None:\n        layers = list(self._layers.keys())\n\n    self.call_js_method(\n        \"addLayerControl\",\n        layers=layers,\n        position=position,\n        collapsed=collapsed,\n    )\n    self._controls = {\n        **self._controls,\n        \"layer-control\": {\"layers\": layers, \"position\": position},\n    }\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.maplibre.MapLibreMap.add_lidar_control","title":"<code>add_lidar_control(self, position='top-right', collapsed=True, title='LiDAR Viewer', point_size=2, opacity=1.0, color_scheme='elevation', use_percentile=True, point_budget=1000000, pickable=False, auto_zoom=True, copc_loading_mode=None, streaming_point_budget=5000000, panel_max_height=600, **kwargs)</code>","text":"<p>Add an interactive LiDAR control panel.</p> <p>The LiDAR control provides a UI panel for loading, visualizing, and styling LiDAR point cloud files (LAS, LAZ, COPC formats).</p> <p>Parameters:</p> Name Type Description Default <code>position</code> <code>str</code> <p>Control position ('top-left', 'top-right', 'bottom-left', 'bottom-right').</p> <code>'top-right'</code> <code>collapsed</code> <code>bool</code> <p>Whether the panel starts collapsed.</p> <code>True</code> <code>title</code> <code>str</code> <p>Title displayed on the panel.</p> <code>'LiDAR Viewer'</code> <code>point_size</code> <code>float</code> <p>Point size in pixels.</p> <code>2</code> <code>opacity</code> <code>float</code> <p>Layer opacity (0-1).</p> <code>1.0</code> <code>color_scheme</code> <code>str</code> <p>Color scheme ('elevation', 'intensity', 'classification', 'rgb').</p> <code>'elevation'</code> <code>use_percentile</code> <code>bool</code> <p>Use 2-98% percentile for color scaling.</p> <code>True</code> <code>point_budget</code> <code>int</code> <p>Maximum number of points to display.</p> <code>1000000</code> <code>pickable</code> <code>bool</code> <p>Enable hover/click interactions.</p> <code>False</code> <code>auto_zoom</code> <code>bool</code> <p>Auto-zoom to point cloud after loading.</p> <code>True</code> <code>copc_loading_mode</code> <code>Optional[str]</code> <p>COPC loading mode ('full' or 'dynamic').</p> <code>None</code> <code>streaming_point_budget</code> <code>int</code> <p>Point budget for streaming mode.</p> <code>5000000</code> <code>panel_max_height</code> <code>int</code> <p>Maximum height of the panel in pixels.</p> <code>600</code> <code>**kwargs</code> <p>Additional control options.</p> <code>{}</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from anymap_ts import MapLibreMap\n&gt;&gt;&gt; m = MapLibreMap(pitch=60)\n&gt;&gt;&gt; m.add_lidar_control(color_scheme=\"classification\", pickable=True)\n</code></pre> Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def add_lidar_control(\n    self,\n    position: str = \"top-right\",\n    collapsed: bool = True,\n    title: str = \"LiDAR Viewer\",\n    point_size: float = 2,\n    opacity: float = 1.0,\n    color_scheme: str = \"elevation\",\n    use_percentile: bool = True,\n    point_budget: int = 1000000,\n    pickable: bool = False,\n    auto_zoom: bool = True,\n    copc_loading_mode: Optional[str] = None,\n    streaming_point_budget: int = 5000000,\n    panel_max_height: int = 600,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add an interactive LiDAR control panel.\n\n    The LiDAR control provides a UI panel for loading, visualizing, and\n    styling LiDAR point cloud files (LAS, LAZ, COPC formats).\n\n    Args:\n        position: Control position ('top-left', 'top-right', 'bottom-left', 'bottom-right').\n        collapsed: Whether the panel starts collapsed.\n        title: Title displayed on the panel.\n        point_size: Point size in pixels.\n        opacity: Layer opacity (0-1).\n        color_scheme: Color scheme ('elevation', 'intensity', 'classification', 'rgb').\n        use_percentile: Use 2-98% percentile for color scaling.\n        point_budget: Maximum number of points to display.\n        pickable: Enable hover/click interactions.\n        auto_zoom: Auto-zoom to point cloud after loading.\n        copc_loading_mode: COPC loading mode ('full' or 'dynamic').\n        streaming_point_budget: Point budget for streaming mode.\n        panel_max_height: Maximum height of the panel in pixels.\n        **kwargs: Additional control options.\n\n    Example:\n        &gt;&gt;&gt; from anymap_ts import MapLibreMap\n        &gt;&gt;&gt; m = MapLibreMap(pitch=60)\n        &gt;&gt;&gt; m.add_lidar_control(color_scheme=\"classification\", pickable=True)\n    \"\"\"\n    self.call_js_method(\n        \"addLidarControl\",\n        position=position,\n        collapsed=collapsed,\n        title=title,\n        pointSize=point_size,\n        opacity=opacity,\n        colorScheme=color_scheme,\n        usePercentile=use_percentile,\n        pointBudget=point_budget,\n        pickable=pickable,\n        autoZoom=auto_zoom,\n        copcLoadingMode=copc_loading_mode,\n        streamingPointBudget=streaming_point_budget,\n        panelMaxHeight=panel_max_height,\n        **kwargs,\n    )\n    self._controls = {\n        **self._controls,\n        \"lidar-control\": {\"position\": position, \"collapsed\": collapsed},\n    }\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.maplibre.MapLibreMap.add_lidar_layer","title":"<code>add_lidar_layer(self, source, name=None, color_scheme='elevation', point_size=2, opacity=1.0, pickable=True, auto_zoom=True, streaming_mode=True, point_budget=1000000, **kwargs)</code>","text":"<p>Load and display a LiDAR file from URL or local path.</p> <p>Supports LAS, LAZ, and COPC (Cloud-Optimized Point Cloud) formats. For local files, the file is read and sent as base64 to JavaScript. For URLs, the data is loaded directly via streaming when possible.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>Union[str, Path]</code> <p>URL or local file path to the LiDAR file.</p> required <code>name</code> <code>Optional[str]</code> <p>Layer identifier. If None, auto-generated.</p> <code>None</code> <code>color_scheme</code> <code>str</code> <p>Color scheme ('elevation', 'intensity', 'classification', 'rgb').</p> <code>'elevation'</code> <code>point_size</code> <code>float</code> <p>Point size in pixels.</p> <code>2</code> <code>opacity</code> <code>float</code> <p>Layer opacity (0-1).</p> <code>1.0</code> <code>pickable</code> <code>bool</code> <p>Enable hover/click interactions.</p> <code>True</code> <code>auto_zoom</code> <code>bool</code> <p>Auto-zoom to point cloud after loading.</p> <code>True</code> <code>streaming_mode</code> <code>bool</code> <p>Use streaming mode for large COPC files.</p> <code>True</code> <code>point_budget</code> <code>int</code> <p>Maximum number of points to display.</p> <code>1000000</code> <code>**kwargs</code> <p>Additional layer options.</p> <code>{}</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from anymap_ts import MapLibreMap\n&gt;&gt;&gt; m = MapLibreMap(center=[-123.07, 44.05], zoom=14, pitch=60)\n&gt;&gt;&gt; m.add_lidar_layer(\n...     source=\"https://s3.amazonaws.com/hobu-lidar/autzen-classified.copc.laz\",\n...     name=\"autzen\",\n...     color_scheme=\"classification\",\n... )\n</code></pre> Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def add_lidar_layer(\n    self,\n    source: Union[str, Path],\n    name: Optional[str] = None,\n    color_scheme: str = \"elevation\",\n    point_size: float = 2,\n    opacity: float = 1.0,\n    pickable: bool = True,\n    auto_zoom: bool = True,\n    streaming_mode: bool = True,\n    point_budget: int = 1000000,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Load and display a LiDAR file from URL or local path.\n\n    Supports LAS, LAZ, and COPC (Cloud-Optimized Point Cloud) formats.\n    For local files, the file is read and sent as base64 to JavaScript.\n    For URLs, the data is loaded directly via streaming when possible.\n\n    Args:\n        source: URL or local file path to the LiDAR file.\n        name: Layer identifier. If None, auto-generated.\n        color_scheme: Color scheme ('elevation', 'intensity', 'classification', 'rgb').\n        point_size: Point size in pixels.\n        opacity: Layer opacity (0-1).\n        pickable: Enable hover/click interactions.\n        auto_zoom: Auto-zoom to point cloud after loading.\n        streaming_mode: Use streaming mode for large COPC files.\n        point_budget: Maximum number of points to display.\n        **kwargs: Additional layer options.\n\n    Example:\n        &gt;&gt;&gt; from anymap_ts import MapLibreMap\n        &gt;&gt;&gt; m = MapLibreMap(center=[-123.07, 44.05], zoom=14, pitch=60)\n        &gt;&gt;&gt; m.add_lidar_layer(\n        ...     source=\"https://s3.amazonaws.com/hobu-lidar/autzen-classified.copc.laz\",\n        ...     name=\"autzen\",\n        ...     color_scheme=\"classification\",\n        ... )\n    \"\"\"\n    layer_id = name or f\"lidar-{len(self._layers)}\"\n\n    # Check if source is a local file\n    source_path = Path(source) if isinstance(source, (str, Path)) else None\n    is_local = source_path is not None and source_path.exists()\n\n    if is_local:\n        # Read local file and encode as base64\n        import base64\n\n        with open(source_path, \"rb\") as f:\n            file_data = f.read()\n        source_b64 = base64.b64encode(file_data).decode(\"utf-8\")\n\n        self.call_js_method(\n            \"addLidarLayer\",\n            source=source_b64,\n            name=layer_id,\n            isBase64=True,\n            filename=source_path.name,\n            colorScheme=color_scheme,\n            pointSize=point_size,\n            opacity=opacity,\n            pickable=pickable,\n            autoZoom=auto_zoom,\n            streamingMode=streaming_mode,\n            pointBudget=point_budget,\n            **kwargs,\n        )\n    else:\n        # Load from URL\n        self.call_js_method(\n            \"addLidarLayer\",\n            source=str(source),\n            name=layer_id,\n            isBase64=False,\n            colorScheme=color_scheme,\n            pointSize=point_size,\n            opacity=opacity,\n            pickable=pickable,\n            autoZoom=auto_zoom,\n            streamingMode=streaming_mode,\n            pointBudget=point_budget,\n            **kwargs,\n        )\n\n    self._layers = {\n        **self._layers,\n        layer_id: {\n            \"id\": layer_id,\n            \"type\": \"lidar\",\n            \"source\": str(source),\n        },\n    }\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.maplibre.MapLibreMap.add_pmtiles_control","title":"<code>add_pmtiles_control(self, position='top-right', collapsed=True, default_url=None, load_default_url=False, default_opacity=1.0, default_fill_color='steelblue', default_line_color='#333', default_pickable=True, **kwargs)</code>","text":"<p>Add a PMTiles layer control for loading PMTiles files via UI.</p> <p>This provides an interactive panel for users to enter PMTiles URLs and visualize vector or raster tile data.</p> <p>Parameters:</p> Name Type Description Default <code>position</code> <code>str</code> <p>Control position ('top-left', 'top-right', 'bottom-left', 'bottom-right').</p> <code>'top-right'</code> <code>collapsed</code> <code>bool</code> <p>Whether the panel starts collapsed.</p> <code>True</code> <code>default_url</code> <code>Optional[str]</code> <p>Default PMTiles URL to pre-fill.</p> <code>None</code> <code>load_default_url</code> <code>bool</code> <p>Whether to auto-load the default URL.</p> <code>False</code> <code>default_opacity</code> <code>float</code> <p>Default layer opacity (0-1).</p> <code>1.0</code> <code>default_fill_color</code> <code>str</code> <p>Default fill color for vector polygons.</p> <code>'steelblue'</code> <code>default_line_color</code> <code>str</code> <p>Default line color for vector lines.</p> <code>'#333'</code> <code>default_pickable</code> <code>bool</code> <p>Whether features are clickable by default.</p> <code>True</code> <code>**kwargs</code> <p>Additional control options.</p> <code>{}</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from anymap_ts import MapLibreMap\n&gt;&gt;&gt; m = MapLibreMap()\n&gt;&gt;&gt; m.add_pmtiles_control(\n...     default_url=\"https://pmtiles.io/protomaps(vector)ODbL_firenze.pmtiles\",\n...     load_default_url=True\n... )\n</code></pre> Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def add_pmtiles_control(\n    self,\n    position: str = \"top-right\",\n    collapsed: bool = True,\n    default_url: Optional[str] = None,\n    load_default_url: bool = False,\n    default_opacity: float = 1.0,\n    default_fill_color: str = \"steelblue\",\n    default_line_color: str = \"#333\",\n    default_pickable: bool = True,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a PMTiles layer control for loading PMTiles files via UI.\n\n    This provides an interactive panel for users to enter PMTiles URLs\n    and visualize vector or raster tile data.\n\n    Args:\n        position: Control position ('top-left', 'top-right', 'bottom-left', 'bottom-right').\n        collapsed: Whether the panel starts collapsed.\n        default_url: Default PMTiles URL to pre-fill.\n        load_default_url: Whether to auto-load the default URL.\n        default_opacity: Default layer opacity (0-1).\n        default_fill_color: Default fill color for vector polygons.\n        default_line_color: Default line color for vector lines.\n        default_pickable: Whether features are clickable by default.\n        **kwargs: Additional control options.\n\n    Example:\n        &gt;&gt;&gt; from anymap_ts import MapLibreMap\n        &gt;&gt;&gt; m = MapLibreMap()\n        &gt;&gt;&gt; m.add_pmtiles_control(\n        ...     default_url=\"https://pmtiles.io/protomaps(vector)ODbL_firenze.pmtiles\",\n        ...     load_default_url=True\n        ... )\n    \"\"\"\n    self.call_js_method(\n        \"addPMTilesControl\",\n        position=position,\n        collapsed=collapsed,\n        defaultUrl=default_url or \"\",\n        loadDefaultUrl=load_default_url,\n        defaultOpacity=default_opacity,\n        defaultFillColor=default_fill_color,\n        defaultLineColor=default_line_color,\n        defaultPickable=default_pickable,\n        **kwargs,\n    )\n    self._controls = {\n        **self._controls,\n        \"pmtiles-control\": {\"position\": position, \"collapsed\": collapsed},\n    }\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.maplibre.MapLibreMap.add_point_cloud_layer","title":"<code>add_point_cloud_layer(self, data, name=None, get_position='position', get_color=None, get_normal=None, point_size=2, size_units='pixels', pickable=True, opacity=1.0, material=True, coordinate_system=None, coordinate_origin=None, **kwargs)</code>","text":"<p>Add a point cloud layer for 3D point visualization using deck.gl.</p> <p>Point cloud layers render large collections of 3D points, ideal for LiDAR data, photogrammetry outputs, or any 3D point dataset.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>Array of point data with positions. Each point should have x, y, z coordinates (or position array).</p> required <code>name</code> <code>Optional[str]</code> <p>Layer ID. If None, auto-generated.</p> <code>None</code> <code>get_position</code> <code>Union[str, Any]</code> <p>Accessor for point position [x, y, z]. Can be a string (property name) or a value.</p> <code>'position'</code> <code>get_color</code> <code>Optional[Union[List[int], str]]</code> <p>Accessor or value for point color [r, g, b, a]. Default: [255, 255, 255, 255] (white).</p> <code>None</code> <code>get_normal</code> <code>Optional[Union[str, Any]]</code> <p>Accessor for point normal [nx, ny, nz] for lighting. Default: [0, 0, 1] (pointing up).</p> <code>None</code> <code>point_size</code> <code>float</code> <p>Point size in pixels or meters (depends on size_units).</p> <code>2</code> <code>size_units</code> <code>str</code> <p>Size units: 'pixels', 'meters', or 'common'.</p> <code>'pixels'</code> <code>pickable</code> <code>bool</code> <p>Whether layer responds to hover/click events.</p> <code>True</code> <code>opacity</code> <code>float</code> <p>Layer opacity (0-1).</p> <code>1.0</code> <code>material</code> <code>bool</code> <p>Whether to enable lighting effects.</p> <code>True</code> <code>coordinate_system</code> <code>Optional[int]</code> <p>Coordinate system for positions.</p> <code>None</code> <code>coordinate_origin</code> <code>Optional[List[float]]</code> <p>Origin for coordinate system [x, y, z].</p> <code>None</code> <code>**kwargs</code> <p>Additional PointCloudLayer props.</p> <code>{}</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from anymap_ts import MapLibreMap\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; m = MapLibreMap(pitch=45)\n&gt;&gt;&gt; points = [\n...     {\"position\": [-122.4, 37.8, 100], \"color\": [255, 0, 0, 255]},\n...     {\"position\": [-122.3, 37.7, 200], \"color\": [0, 255, 0, 255]},\n... ]\n&gt;&gt;&gt; m.add_point_cloud_layer(points, point_size=5)\n</code></pre> Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def add_point_cloud_layer(\n    self,\n    data: Any,\n    name: Optional[str] = None,\n    get_position: Union[str, Any] = \"position\",\n    get_color: Optional[Union[List[int], str]] = None,\n    get_normal: Optional[Union[str, Any]] = None,\n    point_size: float = 2,\n    size_units: str = \"pixels\",\n    pickable: bool = True,\n    opacity: float = 1.0,\n    material: bool = True,\n    coordinate_system: Optional[int] = None,\n    coordinate_origin: Optional[List[float]] = None,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a point cloud layer for 3D point visualization using deck.gl.\n\n    Point cloud layers render large collections of 3D points, ideal for\n    LiDAR data, photogrammetry outputs, or any 3D point dataset.\n\n    Args:\n        data: Array of point data with positions. Each point should have\n            x, y, z coordinates (or position array).\n        name: Layer ID. If None, auto-generated.\n        get_position: Accessor for point position [x, y, z].\n            Can be a string (property name) or a value.\n        get_color: Accessor or value for point color [r, g, b, a].\n            Default: [255, 255, 255, 255] (white).\n        get_normal: Accessor for point normal [nx, ny, nz] for lighting.\n            Default: [0, 0, 1] (pointing up).\n        point_size: Point size in pixels or meters (depends on size_units).\n        size_units: Size units: 'pixels', 'meters', or 'common'.\n        pickable: Whether layer responds to hover/click events.\n        opacity: Layer opacity (0-1).\n        material: Whether to enable lighting effects.\n        coordinate_system: Coordinate system for positions.\n        coordinate_origin: Origin for coordinate system [x, y, z].\n        **kwargs: Additional PointCloudLayer props.\n\n    Example:\n        &gt;&gt;&gt; from anymap_ts import MapLibreMap\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; m = MapLibreMap(pitch=45)\n        &gt;&gt;&gt; points = [\n        ...     {\"position\": [-122.4, 37.8, 100], \"color\": [255, 0, 0, 255]},\n        ...     {\"position\": [-122.3, 37.7, 200], \"color\": [0, 255, 0, 255]},\n        ... ]\n        &gt;&gt;&gt; m.add_point_cloud_layer(points, point_size=5)\n    \"\"\"\n    layer_id = name or f\"pointcloud-{len(self._layers)}\"\n    processed_data = self._process_deck_data(data)\n\n    self.call_js_method(\n        \"addPointCloudLayer\",\n        id=layer_id,\n        data=processed_data,\n        getPosition=get_position,\n        getColor=get_color or [255, 255, 255, 255],\n        getNormal=get_normal,\n        pointSize=point_size,\n        sizeUnits=size_units,\n        pickable=pickable,\n        opacity=opacity,\n        material=material,\n        coordinateSystem=coordinate_system,\n        coordinateOrigin=coordinate_origin,\n        **kwargs,\n    )\n\n    self._layers = {\n        **self._layers,\n        layer_id: {\n            \"id\": layer_id,\n            \"type\": \"pointcloud\",\n        },\n    }\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.maplibre.MapLibreMap.add_raster","title":"<code>add_raster(self, source, name=None, attribution='', indexes=None, colormap=None, vmin=None, vmax=None, nodata=None, fit_bounds=True, **kwargs)</code>","text":"<p>Add a raster layer from a local file using localtileserver.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>str</code> <p>Path to local raster file</p> required <code>name</code> <code>Optional[str]</code> <p>Layer name</p> <code>None</code> <code>attribution</code> <code>str</code> <p>Attribution text</p> <code>''</code> <code>indexes</code> <code>Optional[List[int]]</code> <p>Band indexes to use</p> <code>None</code> <code>colormap</code> <code>Optional[str]</code> <p>Colormap name</p> <code>None</code> <code>vmin</code> <code>Optional[float]</code> <p>Minimum value for colormap</p> <code>None</code> <code>vmax</code> <code>Optional[float]</code> <p>Maximum value for colormap</p> <code>None</code> <code>nodata</code> <code>Optional[float]</code> <p>NoData value</p> <code>None</code> <code>fit_bounds</code> <code>bool</code> <p>Whether to fit map to raster bounds</p> <code>True</code> <code>**kwargs</code> <p>Additional options</p> <code>{}</code> Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def add_raster(\n    self,\n    source: str,\n    name: Optional[str] = None,\n    attribution: str = \"\",\n    indexes: Optional[List[int]] = None,\n    colormap: Optional[str] = None,\n    vmin: Optional[float] = None,\n    vmax: Optional[float] = None,\n    nodata: Optional[float] = None,\n    fit_bounds: bool = True,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a raster layer from a local file using localtileserver.\n\n    Args:\n        source: Path to local raster file\n        name: Layer name\n        attribution: Attribution text\n        indexes: Band indexes to use\n        colormap: Colormap name\n        vmin: Minimum value for colormap\n        vmax: Maximum value for colormap\n        nodata: NoData value\n        fit_bounds: Whether to fit map to raster bounds\n        **kwargs: Additional options\n    \"\"\"\n    try:\n        from localtileserver import TileClient\n    except ImportError:\n        raise ImportError(\n            \"localtileserver is required for local raster support. \"\n            \"Install with: pip install anymap-ts[raster]\"\n        )\n\n    client = TileClient(source)\n\n    # Build tile URL with parameters\n    tile_url = client.get_tile_url()\n    if indexes:\n        tile_url = client.get_tile_url(indexes=indexes)\n    if colormap:\n        tile_url = client.get_tile_url(colormap=colormap)\n    if vmin is not None or vmax is not None:\n        tile_url = client.get_tile_url(\n            vmin=vmin or client.min, vmax=vmax or client.max\n        )\n    if nodata is not None:\n        tile_url = client.get_tile_url(nodata=nodata)\n\n    layer_name = name or Path(source).stem\n\n    self.add_tile_layer(\n        tile_url,\n        name=layer_name,\n        attribution=attribution,\n        **kwargs,\n    )\n\n    # Fit bounds if requested\n    if fit_bounds:\n        bounds = client.bounds()\n        if bounds:\n            self.fit_bounds([bounds[0], bounds[1], bounds[2], bounds[3]])\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.maplibre.MapLibreMap.add_tile_layer","title":"<code>add_tile_layer(self, url, name=None, attribution='', min_zoom=0, max_zoom=22, **kwargs)</code>","text":"<p>Add an XYZ tile layer.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>Tile URL template with {x}, {y}, {z} placeholders</p> required <code>name</code> <code>Optional[str]</code> <p>Layer name</p> <code>None</code> <code>attribution</code> <code>str</code> <p>Attribution text</p> <code>''</code> <code>min_zoom</code> <code>int</code> <p>Minimum zoom level</p> <code>0</code> <code>max_zoom</code> <code>int</code> <p>Maximum zoom level</p> <code>22</code> <code>**kwargs</code> <p>Additional options</p> <code>{}</code> Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def add_tile_layer(\n    self,\n    url: str,\n    name: Optional[str] = None,\n    attribution: str = \"\",\n    min_zoom: int = 0,\n    max_zoom: int = 22,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add an XYZ tile layer.\n\n    Args:\n        url: Tile URL template with {x}, {y}, {z} placeholders\n        name: Layer name\n        attribution: Attribution text\n        min_zoom: Minimum zoom level\n        max_zoom: Maximum zoom level\n        **kwargs: Additional options\n    \"\"\"\n    layer_id = name or f\"tiles-{len(self._layers)}\"\n\n    self.call_js_method(\n        \"addTileLayer\",\n        url,\n        name=layer_id,\n        attribution=attribution,\n        minZoom=min_zoom,\n        maxZoom=max_zoom,\n        **kwargs,\n    )\n\n    # Track layer\n    self._layers = {\n        **self._layers,\n        layer_id: {\n            \"id\": layer_id,\n            \"type\": \"raster\",\n            \"source\": f\"{layer_id}-source\",\n        },\n    }\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.maplibre.MapLibreMap.add_vector","title":"<code>add_vector(self, data, layer_type=None, paint=None, name=None, fit_bounds=True, **kwargs)</code>","text":"<p>Add vector data to the map.</p> <p>Supports GeoJSON, GeoDataFrame, or file paths to vector formats.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>GeoJSON dict, GeoDataFrame, or path to vector file</p> required <code>layer_type</code> <code>Optional[str]</code> <p>MapLibre layer type ('circle', 'line', 'fill', 'symbol')</p> <code>None</code> <code>paint</code> <code>Optional[Dict]</code> <p>MapLibre paint properties</p> <code>None</code> <code>name</code> <code>Optional[str]</code> <p>Layer name</p> <code>None</code> <code>fit_bounds</code> <code>bool</code> <p>Whether to fit map to data bounds</p> <code>True</code> <code>**kwargs</code> <p>Additional layer options</p> <code>{}</code> Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def add_vector(\n    self,\n    data: Any,\n    layer_type: Optional[str] = None,\n    paint: Optional[Dict] = None,\n    name: Optional[str] = None,\n    fit_bounds: bool = True,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add vector data to the map.\n\n    Supports GeoJSON, GeoDataFrame, or file paths to vector formats.\n\n    Args:\n        data: GeoJSON dict, GeoDataFrame, or path to vector file\n        layer_type: MapLibre layer type ('circle', 'line', 'fill', 'symbol')\n        paint: MapLibre paint properties\n        name: Layer name\n        fit_bounds: Whether to fit map to data bounds\n        **kwargs: Additional layer options\n    \"\"\"\n    geojson = to_geojson(data)\n\n    # Handle URL data\n    if geojson.get(\"type\") == \"url\":\n        self.add_geojson(\n            geojson[\"url\"],\n            layer_type=layer_type,\n            paint=paint,\n            name=name,\n            fit_bounds=fit_bounds,\n            **kwargs,\n        )\n        return\n\n    layer_id = name or f\"vector-{len(self._layers)}\"\n\n    # Infer layer type if not specified\n    if layer_type is None:\n        layer_type = infer_layer_type(geojson)\n\n    # Get default paint if not provided\n    if paint is None:\n        paint = get_default_paint(layer_type)\n\n    # Get bounds\n    bounds = get_bounds(data) if fit_bounds else None\n\n    # Call JavaScript\n    self.call_js_method(\n        \"addGeoJSON\",\n        data=geojson,\n        name=layer_id,\n        layerType=layer_type,\n        paint=paint,\n        fitBounds=fit_bounds,\n        bounds=bounds,\n        **kwargs,\n    )\n\n    # Track layer\n    self._layers = {\n        **self._layers,\n        layer_id: {\n            \"id\": layer_id,\n            \"type\": layer_type,\n            \"source\": f\"{layer_id}-source\",\n            \"paint\": paint,\n        },\n    }\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.maplibre.MapLibreMap.add_vector_control","title":"<code>add_vector_control(self, position='top-right', collapsed=True, default_url=None, load_default_url=False, default_opacity=1.0, default_fill_color='#3388ff', default_stroke_color='#3388ff', fit_bounds=True, **kwargs)</code>","text":"<p>Add a vector layer control for loading vector datasets from URLs.</p> <p>This provides an interactive panel for users to enter URLs to GeoJSON, GeoParquet, or FlatGeobuf datasets.</p> <p>Parameters:</p> Name Type Description Default <code>position</code> <code>str</code> <p>Control position ('top-left', 'top-right', 'bottom-left', 'bottom-right').</p> <code>'top-right'</code> <code>collapsed</code> <code>bool</code> <p>Whether the panel starts collapsed.</p> <code>True</code> <code>default_url</code> <code>Optional[str]</code> <p>Default vector URL to pre-fill.</p> <code>None</code> <code>load_default_url</code> <code>bool</code> <p>Whether to auto-load the default URL.</p> <code>False</code> <code>default_opacity</code> <code>float</code> <p>Default layer opacity (0-1).</p> <code>1.0</code> <code>default_fill_color</code> <code>str</code> <p>Default fill color for polygons.</p> <code>'#3388ff'</code> <code>default_stroke_color</code> <code>str</code> <p>Default stroke color for lines/outlines.</p> <code>'#3388ff'</code> <code>fit_bounds</code> <code>bool</code> <p>Whether to fit map to loaded data bounds.</p> <code>True</code> <code>**kwargs</code> <p>Additional control options.</p> <code>{}</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from anymap_ts import MapLibreMap\n&gt;&gt;&gt; m = MapLibreMap()\n&gt;&gt;&gt; m.add_vector_control(\n...     default_url=\"https://example.com/data.geojson\",\n...     default_fill_color=\"#ff0000\"\n... )\n</code></pre> Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def add_vector_control(\n    self,\n    position: str = \"top-right\",\n    collapsed: bool = True,\n    default_url: Optional[str] = None,\n    load_default_url: bool = False,\n    default_opacity: float = 1.0,\n    default_fill_color: str = \"#3388ff\",\n    default_stroke_color: str = \"#3388ff\",\n    fit_bounds: bool = True,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a vector layer control for loading vector datasets from URLs.\n\n    This provides an interactive panel for users to enter URLs to\n    GeoJSON, GeoParquet, or FlatGeobuf datasets.\n\n    Args:\n        position: Control position ('top-left', 'top-right', 'bottom-left', 'bottom-right').\n        collapsed: Whether the panel starts collapsed.\n        default_url: Default vector URL to pre-fill.\n        load_default_url: Whether to auto-load the default URL.\n        default_opacity: Default layer opacity (0-1).\n        default_fill_color: Default fill color for polygons.\n        default_stroke_color: Default stroke color for lines/outlines.\n        fit_bounds: Whether to fit map to loaded data bounds.\n        **kwargs: Additional control options.\n\n    Example:\n        &gt;&gt;&gt; from anymap_ts import MapLibreMap\n        &gt;&gt;&gt; m = MapLibreMap()\n        &gt;&gt;&gt; m.add_vector_control(\n        ...     default_url=\"https://example.com/data.geojson\",\n        ...     default_fill_color=\"#ff0000\"\n        ... )\n    \"\"\"\n    self.call_js_method(\n        \"addVectorControl\",\n        position=position,\n        collapsed=collapsed,\n        defaultUrl=default_url or \"\",\n        loadDefaultUrl=load_default_url,\n        defaultOpacity=default_opacity,\n        defaultFillColor=default_fill_color,\n        defaultStrokeColor=default_stroke_color,\n        fitBounds=fit_bounds,\n        **kwargs,\n    )\n    self._controls = {\n        **self._controls,\n        \"vector-control\": {\"position\": position, \"collapsed\": collapsed},\n    }\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.maplibre.MapLibreMap.add_zarr_control","title":"<code>add_zarr_control(self, position='top-right', collapsed=True, default_url=None, load_default_url=False, default_opacity=1.0, default_variable='', default_clim=None, **kwargs)</code>","text":"<p>Add a Zarr layer control for loading Zarr datasets via UI.</p> <p>This provides an interactive panel for users to enter Zarr URLs and configure visualization parameters.</p> <p>Parameters:</p> Name Type Description Default <code>position</code> <code>str</code> <p>Control position ('top-left', 'top-right', 'bottom-left', 'bottom-right').</p> <code>'top-right'</code> <code>collapsed</code> <code>bool</code> <p>Whether the panel starts collapsed.</p> <code>True</code> <code>default_url</code> <code>Optional[str]</code> <p>Default Zarr URL to pre-fill.</p> <code>None</code> <code>load_default_url</code> <code>bool</code> <p>Whether to auto-load the default URL.</p> <code>False</code> <code>default_opacity</code> <code>float</code> <p>Default layer opacity (0-1).</p> <code>1.0</code> <code>default_variable</code> <code>str</code> <p>Default variable name.</p> <code>''</code> <code>default_clim</code> <code>Optional[Tuple[float, float]]</code> <p>Default color limits (min, max).</p> <code>None</code> <code>**kwargs</code> <p>Additional control options.</p> <code>{}</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from anymap_ts import MapLibreMap\n&gt;&gt;&gt; m = MapLibreMap()\n&gt;&gt;&gt; m.add_zarr_control(\n...     default_url=\"https://example.com/data.zarr\",\n...     default_variable=\"temperature\"\n... )\n</code></pre> Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def add_zarr_control(\n    self,\n    position: str = \"top-right\",\n    collapsed: bool = True,\n    default_url: Optional[str] = None,\n    load_default_url: bool = False,\n    default_opacity: float = 1.0,\n    default_variable: str = \"\",\n    default_clim: Optional[Tuple[float, float]] = None,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a Zarr layer control for loading Zarr datasets via UI.\n\n    This provides an interactive panel for users to enter Zarr URLs\n    and configure visualization parameters.\n\n    Args:\n        position: Control position ('top-left', 'top-right', 'bottom-left', 'bottom-right').\n        collapsed: Whether the panel starts collapsed.\n        default_url: Default Zarr URL to pre-fill.\n        load_default_url: Whether to auto-load the default URL.\n        default_opacity: Default layer opacity (0-1).\n        default_variable: Default variable name.\n        default_clim: Default color limits (min, max).\n        **kwargs: Additional control options.\n\n    Example:\n        &gt;&gt;&gt; from anymap_ts import MapLibreMap\n        &gt;&gt;&gt; m = MapLibreMap()\n        &gt;&gt;&gt; m.add_zarr_control(\n        ...     default_url=\"https://example.com/data.zarr\",\n        ...     default_variable=\"temperature\"\n        ... )\n    \"\"\"\n    self.call_js_method(\n        \"addZarrControl\",\n        position=position,\n        collapsed=collapsed,\n        defaultUrl=default_url or \"\",\n        loadDefaultUrl=load_default_url,\n        defaultOpacity=default_opacity,\n        defaultVariable=default_variable,\n        defaultClim=list(default_clim) if default_clim else [0, 1],\n        **kwargs,\n    )\n    self._controls = {\n        **self._controls,\n        \"zarr-control\": {\"position\": position, \"collapsed\": collapsed},\n    }\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.maplibre.MapLibreMap.add_zarr_layer","title":"<code>add_zarr_layer(self, url, variable, name=None, colormap=None, clim=None, opacity=1.0, selector=None, minzoom=0, maxzoom=22, fill_value=None, spatial_dimensions=None, zarr_version=None, bounds=None, **kwargs)</code>","text":"<p>Add a Zarr dataset layer for visualizing multidimensional array data.</p> <p>This method renders Zarr pyramid datasets directly in the browser using GPU-accelerated WebGL rendering via @carbonplan/zarr-layer.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>URL to the Zarr store (pyramid format recommended).</p> required <code>variable</code> <code>str</code> <p>Variable name in the Zarr dataset to visualize.</p> required <code>name</code> <code>Optional[str]</code> <p>Layer ID. If None, auto-generated.</p> <code>None</code> <code>colormap</code> <code>Optional[List[str]]</code> <p>List of hex color strings for visualization. Example: ['#0000ff', '#ffff00', '#ff0000'] (blue-yellow-red). Default: ['#000000', '#ffffff'] (black to white).</p> <code>None</code> <code>clim</code> <code>Optional[Tuple[float, float]]</code> <p>Color range as (min, max) tuple. Default: (0, 100).</p> <code>None</code> <code>opacity</code> <code>float</code> <p>Layer opacity (0-1).</p> <code>1.0</code> <code>selector</code> <code>Optional[Dict[str, Any]]</code> <p>Dimension selector for multi-dimensional data. Example: {\"month\": 4} to select 4th month.</p> <code>None</code> <code>minzoom</code> <code>int</code> <p>Minimum zoom level for rendering.</p> <code>0</code> <code>maxzoom</code> <code>int</code> <p>Maximum zoom level for rendering.</p> <code>22</code> <code>fill_value</code> <code>Optional[float]</code> <p>No-data value (auto-detected from metadata if not set).</p> <code>None</code> <code>spatial_dimensions</code> <code>Optional[Dict[str, str]]</code> <p>Custom spatial dimension names. Example: {\"lat\": \"y\", \"lon\": \"x\"} for non-standard names.</p> <code>None</code> <code>zarr_version</code> <code>Optional[int]</code> <p>Zarr format version (2 or 3). Auto-detected if not set.</p> <code>None</code> <code>bounds</code> <code>Optional[List[float]]</code> <p>Explicit spatial bounds [xMin, yMin, xMax, yMax]. Units depend on CRS: degrees for EPSG:4326, meters for EPSG:3857.</p> <code>None</code> <code>**kwargs</code> <p>Additional ZarrLayer props.</p> <code>{}</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from anymap_ts import Map\n&gt;&gt;&gt; m = Map()\n&gt;&gt;&gt; m.add_zarr_layer(\n...     \"https://example.com/climate.zarr\",\n...     variable=\"temperature\",\n...     clim=(270, 310),\n...     colormap=['#0000ff', '#ffff00', '#ff0000'],\n...     selector={\"month\": 7}\n... )\n</code></pre> Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def add_zarr_layer(\n    self,\n    url: str,\n    variable: str,\n    name: Optional[str] = None,\n    colormap: Optional[List[str]] = None,\n    clim: Optional[Tuple[float, float]] = None,\n    opacity: float = 1.0,\n    selector: Optional[Dict[str, Any]] = None,\n    minzoom: int = 0,\n    maxzoom: int = 22,\n    fill_value: Optional[float] = None,\n    spatial_dimensions: Optional[Dict[str, str]] = None,\n    zarr_version: Optional[int] = None,\n    bounds: Optional[List[float]] = None,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a Zarr dataset layer for visualizing multidimensional array data.\n\n    This method renders Zarr pyramid datasets directly in the browser using\n    GPU-accelerated WebGL rendering via @carbonplan/zarr-layer.\n\n    Args:\n        url: URL to the Zarr store (pyramid format recommended).\n        variable: Variable name in the Zarr dataset to visualize.\n        name: Layer ID. If None, auto-generated.\n        colormap: List of hex color strings for visualization.\n            Example: ['#0000ff', '#ffff00', '#ff0000'] (blue-yellow-red).\n            Default: ['#000000', '#ffffff'] (black to white).\n        clim: Color range as (min, max) tuple.\n            Default: (0, 100).\n        opacity: Layer opacity (0-1).\n        selector: Dimension selector for multi-dimensional data.\n            Example: {\"month\": 4} to select 4th month.\n        minzoom: Minimum zoom level for rendering.\n        maxzoom: Maximum zoom level for rendering.\n        fill_value: No-data value (auto-detected from metadata if not set).\n        spatial_dimensions: Custom spatial dimension names.\n            Example: {\"lat\": \"y\", \"lon\": \"x\"} for non-standard names.\n        zarr_version: Zarr format version (2 or 3). Auto-detected if not set.\n        bounds: Explicit spatial bounds [xMin, yMin, xMax, yMax].\n            Units depend on CRS: degrees for EPSG:4326, meters for EPSG:3857.\n        **kwargs: Additional ZarrLayer props.\n\n    Example:\n        &gt;&gt;&gt; from anymap_ts import Map\n        &gt;&gt;&gt; m = Map()\n        &gt;&gt;&gt; m.add_zarr_layer(\n        ...     \"https://example.com/climate.zarr\",\n        ...     variable=\"temperature\",\n        ...     clim=(270, 310),\n        ...     colormap=['#0000ff', '#ffff00', '#ff0000'],\n        ...     selector={\"month\": 7}\n        ... )\n    \"\"\"\n    layer_id = name or f\"zarr-{len(self._layers)}\"\n\n    self.call_js_method(\n        \"addZarrLayer\",\n        id=layer_id,\n        source=url,\n        variable=variable,\n        colormap=colormap or [\"#000000\", \"#ffffff\"],\n        clim=list(clim) if clim else [0, 100],\n        opacity=opacity,\n        selector=selector or {},\n        minzoom=minzoom,\n        maxzoom=maxzoom,\n        fillValue=fill_value,\n        spatialDimensions=spatial_dimensions,\n        zarrVersion=zarr_version,\n        bounds=bounds,\n        **kwargs,\n    )\n\n    self._layers = {\n        **self._layers,\n        layer_id: {\n            \"id\": layer_id,\n            \"type\": \"zarr\",\n            \"url\": url,\n            \"variable\": variable,\n        },\n    }\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.maplibre.MapLibreMap.clear_draw_data","title":"<code>clear_draw_data(self)</code>","text":"<p>Clear all drawn features.</p> Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def clear_draw_data(self) -&gt; None:\n    \"\"\"Clear all drawn features.\"\"\"\n    self._draw_data = {\"type\": \"FeatureCollection\", \"features\": []}\n    self.call_js_method(\"clearDrawData\")\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.maplibre.MapLibreMap.get_draw_data","title":"<code>get_draw_data(self)</code>","text":"<p>Get the current drawn features as GeoJSON.</p> <p>Returns:</p> Type Description <code>Dict</code> <p>GeoJSON FeatureCollection of drawn features</p> Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def get_draw_data(self) -&gt; Dict:\n    \"\"\"Get the current drawn features as GeoJSON.\n\n    Returns:\n        GeoJSON FeatureCollection of drawn features\n    \"\"\"\n    self.call_js_method(\"getDrawData\")\n    # Small delay to allow JS to update the trait\n    import time\n\n    time.sleep(0.1)\n    return self._draw_data or {\"type\": \"FeatureCollection\", \"features\": []}\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.maplibre.MapLibreMap.load_draw_data","title":"<code>load_draw_data(self, geojson)</code>","text":"<p>Load GeoJSON features into the drawing layer.</p> <p>Parameters:</p> Name Type Description Default <code>geojson</code> <code>Dict</code> <p>GeoJSON FeatureCollection to load</p> required Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def load_draw_data(self, geojson: Dict) -&gt; None:\n    \"\"\"Load GeoJSON features into the drawing layer.\n\n    Args:\n        geojson: GeoJSON FeatureCollection to load\n    \"\"\"\n    self._draw_data = geojson\n    self.call_js_method(\"loadDrawData\", geojson)\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.maplibre.MapLibreMap.remove_arc_layer","title":"<code>remove_arc_layer(self, layer_id)</code>","text":"<p>Remove an arc layer.</p> <p>Parameters:</p> Name Type Description Default <code>layer_id</code> <code>str</code> <p>Layer identifier to remove.</p> required Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def remove_arc_layer(self, layer_id: str) -&gt; None:\n    \"\"\"Remove an arc layer.\n\n    Args:\n        layer_id: Layer identifier to remove.\n    \"\"\"\n    if layer_id in self._layers:\n        layers = dict(self._layers)\n        del layers[layer_id]\n        self._layers = layers\n    self.call_js_method(\"removeArcLayer\", layer_id)\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.maplibre.MapLibreMap.remove_cog_layer","title":"<code>remove_cog_layer(self, layer_id)</code>","text":"<p>Remove a COG layer.</p> <p>Parameters:</p> Name Type Description Default <code>layer_id</code> <code>str</code> <p>Layer identifier to remove.</p> required Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def remove_cog_layer(self, layer_id: str) -&gt; None:\n    \"\"\"Remove a COG layer.\n\n    Args:\n        layer_id: Layer identifier to remove.\n    \"\"\"\n    if layer_id in self._layers:\n        layers = dict(self._layers)\n        del layers[layer_id]\n        self._layers = layers\n    self.call_js_method(\"removeCOGLayer\", layer_id)\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.maplibre.MapLibreMap.remove_control","title":"<code>remove_control(self, control_type)</code>","text":"<p>Remove a map control.</p> <p>Parameters:</p> Name Type Description Default <code>control_type</code> <code>str</code> <p>Type of control to remove</p> required Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def remove_control(self, control_type: str) -&gt; None:\n    \"\"\"Remove a map control.\n\n    Args:\n        control_type: Type of control to remove\n    \"\"\"\n    self.call_js_method(\"removeControl\", control_type)\n    if control_type in self._controls:\n        controls = dict(self._controls)\n        del controls[control_type]\n        self._controls = controls\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.maplibre.MapLibreMap.remove_layer","title":"<code>remove_layer(self, layer_id)</code>","text":"<p>Remove a layer from the map.</p> <p>Parameters:</p> Name Type Description Default <code>layer_id</code> <code>str</code> <p>Layer identifier to remove</p> required Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def remove_layer(self, layer_id: str) -&gt; None:\n    \"\"\"Remove a layer from the map.\n\n    Args:\n        layer_id: Layer identifier to remove\n    \"\"\"\n    if layer_id in self._layers:\n        layers = dict(self._layers)\n        del layers[layer_id]\n        self._layers = layers\n    self.call_js_method(\"removeLayer\", layer_id)\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.maplibre.MapLibreMap.remove_lidar_layer","title":"<code>remove_lidar_layer(self, layer_id=None)</code>","text":"<p>Remove a LiDAR layer.</p> <p>Parameters:</p> Name Type Description Default <code>layer_id</code> <code>Optional[str]</code> <p>Layer identifier to remove. If None, removes all LiDAR layers.</p> <code>None</code> Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def remove_lidar_layer(self, layer_id: Optional[str] = None) -&gt; None:\n    \"\"\"Remove a LiDAR layer.\n\n    Args:\n        layer_id: Layer identifier to remove. If None, removes all LiDAR layers.\n    \"\"\"\n    if layer_id:\n        if layer_id in self._layers:\n            layers = dict(self._layers)\n            del layers[layer_id]\n            self._layers = layers\n        self.call_js_method(\"removeLidarLayer\", id=layer_id)\n    else:\n        # Remove all lidar layers\n        layers = dict(self._layers)\n        self._layers = {k: v for k, v in layers.items() if v.get(\"type\") != \"lidar\"}\n        self.call_js_method(\"removeLidarLayer\")\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.maplibre.MapLibreMap.remove_point_cloud_layer","title":"<code>remove_point_cloud_layer(self, layer_id)</code>","text":"<p>Remove a point cloud layer.</p> <p>Parameters:</p> Name Type Description Default <code>layer_id</code> <code>str</code> <p>Layer identifier to remove.</p> required Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def remove_point_cloud_layer(self, layer_id: str) -&gt; None:\n    \"\"\"Remove a point cloud layer.\n\n    Args:\n        layer_id: Layer identifier to remove.\n    \"\"\"\n    if layer_id in self._layers:\n        layers = dict(self._layers)\n        del layers[layer_id]\n        self._layers = layers\n    self.call_js_method(\"removePointCloudLayer\", layer_id)\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.maplibre.MapLibreMap.remove_zarr_layer","title":"<code>remove_zarr_layer(self, layer_id)</code>","text":"<p>Remove a Zarr layer.</p> <p>Parameters:</p> Name Type Description Default <code>layer_id</code> <code>str</code> <p>Layer identifier to remove.</p> required Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def remove_zarr_layer(self, layer_id: str) -&gt; None:\n    \"\"\"Remove a Zarr layer.\n\n    Args:\n        layer_id: Layer identifier to remove.\n    \"\"\"\n    if layer_id in self._layers:\n        layers = dict(self._layers)\n        del layers[layer_id]\n        self._layers = layers\n    self.call_js_method(\"removeZarrLayer\", layer_id)\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.maplibre.MapLibreMap.save_draw_data","title":"<code>save_draw_data(self, filepath, driver=None)</code>","text":"<p>Save drawn features to a file.</p> <p>Parameters:</p> Name Type Description Default <code>filepath</code> <code>Union[str, Path]</code> <p>Path to save file</p> required <code>driver</code> <code>Optional[str]</code> <p>Output driver (auto-detected from extension if not provided)</p> <code>None</code> <p>Exceptions:</p> Type Description <code>ImportError</code> <p>If geopandas is not installed</p> Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def save_draw_data(\n    self,\n    filepath: Union[str, Path],\n    driver: Optional[str] = None,\n) -&gt; None:\n    \"\"\"Save drawn features to a file.\n\n    Args:\n        filepath: Path to save file\n        driver: Output driver (auto-detected from extension if not provided)\n\n    Raises:\n        ImportError: If geopandas is not installed\n    \"\"\"\n    try:\n        import geopandas as gpd\n    except ImportError:\n        raise ImportError(\n            \"geopandas is required to save draw data. \"\n            \"Install with: pip install anymap-ts[vector]\"\n        )\n\n    data = self.get_draw_data()\n    if not data.get(\"features\"):\n        print(\"No features to save\")\n        return\n\n    gdf = gpd.GeoDataFrame.from_features(data[\"features\"])\n    filepath = Path(filepath)\n\n    # Infer driver from extension\n    if driver is None:\n        ext = filepath.suffix.lower()\n        driver_map = {\n            \".geojson\": \"GeoJSON\",\n            \".json\": \"GeoJSON\",\n            \".shp\": \"ESRI Shapefile\",\n            \".gpkg\": \"GPKG\",\n        }\n        driver = driver_map.get(ext, \"GeoJSON\")\n\n    gdf.to_file(filepath, driver=driver)\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.maplibre.MapLibreMap.set_lidar_color_scheme","title":"<code>set_lidar_color_scheme(self, color_scheme)</code>","text":"<p>Set the LiDAR color scheme.</p> <p>Parameters:</p> Name Type Description Default <code>color_scheme</code> <code>str</code> <p>Color scheme ('elevation', 'intensity', 'classification', 'rgb').</p> required Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def set_lidar_color_scheme(self, color_scheme: str) -&gt; None:\n    \"\"\"Set the LiDAR color scheme.\n\n    Args:\n        color_scheme: Color scheme ('elevation', 'intensity', 'classification', 'rgb').\n    \"\"\"\n    self.call_js_method(\"setLidarColorScheme\", colorScheme=color_scheme)\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.maplibre.MapLibreMap.set_lidar_opacity","title":"<code>set_lidar_opacity(self, opacity)</code>","text":"<p>Set the LiDAR layer opacity.</p> <p>Parameters:</p> Name Type Description Default <code>opacity</code> <code>float</code> <p>Opacity value between 0 and 1.</p> required Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def set_lidar_opacity(self, opacity: float) -&gt; None:\n    \"\"\"Set the LiDAR layer opacity.\n\n    Args:\n        opacity: Opacity value between 0 and 1.\n    \"\"\"\n    self.call_js_method(\"setLidarOpacity\", opacity=opacity)\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.maplibre.MapLibreMap.set_lidar_point_size","title":"<code>set_lidar_point_size(self, point_size)</code>","text":"<p>Set the LiDAR point size.</p> <p>Parameters:</p> Name Type Description Default <code>point_size</code> <code>float</code> <p>Point size in pixels.</p> required Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def set_lidar_point_size(self, point_size: float) -&gt; None:\n    \"\"\"Set the LiDAR point size.\n\n    Args:\n        point_size: Point size in pixels.\n    \"\"\"\n    self.call_js_method(\"setLidarPointSize\", pointSize=point_size)\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.maplibre.MapLibreMap.set_opacity","title":"<code>set_opacity(self, layer_id, opacity)</code>","text":"<p>Set layer opacity.</p> <p>Parameters:</p> Name Type Description Default <code>layer_id</code> <code>str</code> <p>Layer identifier</p> required <code>opacity</code> <code>float</code> <p>Opacity value between 0 and 1</p> required Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def set_opacity(self, layer_id: str, opacity: float) -&gt; None:\n    \"\"\"Set layer opacity.\n\n    Args:\n        layer_id: Layer identifier\n        opacity: Opacity value between 0 and 1\n    \"\"\"\n    self.call_js_method(\"setOpacity\", layer_id, opacity)\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.maplibre.MapLibreMap.set_visibility","title":"<code>set_visibility(self, layer_id, visible)</code>","text":"<p>Set layer visibility.</p> <p>Parameters:</p> Name Type Description Default <code>layer_id</code> <code>str</code> <p>Layer identifier</p> required <code>visible</code> <code>bool</code> <p>Whether layer should be visible</p> required Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def set_visibility(self, layer_id: str, visible: bool) -&gt; None:\n    \"\"\"Set layer visibility.\n\n    Args:\n        layer_id: Layer identifier\n        visible: Whether layer should be visible\n    \"\"\"\n    self.call_js_method(\"setVisibility\", layer_id, visible)\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.maplibre.MapLibreMap.update_zarr_layer","title":"<code>update_zarr_layer(self, layer_id, selector=None, clim=None, colormap=None, opacity=None)</code>","text":"<p>Update a Zarr layer's properties dynamically.</p> <p>Parameters:</p> Name Type Description Default <code>layer_id</code> <code>str</code> <p>Layer identifier.</p> required <code>selector</code> <code>Optional[Dict[str, Any]]</code> <p>New dimension selector.</p> <code>None</code> <code>clim</code> <code>Optional[Tuple[float, float]]</code> <p>New color range.</p> <code>None</code> <code>colormap</code> <code>Optional[List[str]]</code> <p>New colormap.</p> <code>None</code> <code>opacity</code> <code>Optional[float]</code> <p>New opacity value (0-1).</p> <code>None</code> Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def update_zarr_layer(\n    self,\n    layer_id: str,\n    selector: Optional[Dict[str, Any]] = None,\n    clim: Optional[Tuple[float, float]] = None,\n    colormap: Optional[List[str]] = None,\n    opacity: Optional[float] = None,\n) -&gt; None:\n    \"\"\"Update a Zarr layer's properties dynamically.\n\n    Args:\n        layer_id: Layer identifier.\n        selector: New dimension selector.\n        clim: New color range.\n        colormap: New colormap.\n        opacity: New opacity value (0-1).\n    \"\"\"\n    update_kwargs: Dict[str, Any] = {\"id\": layer_id}\n    if selector is not None:\n        update_kwargs[\"selector\"] = selector\n    if clim is not None:\n        update_kwargs[\"clim\"] = list(clim)\n    if colormap is not None:\n        update_kwargs[\"colormap\"] = colormap\n    if opacity is not None:\n        update_kwargs[\"opacity\"] = opacity\n    self.call_js_method(\"updateZarrLayer\", **update_kwargs)\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.openlayers","title":"<code>openlayers</code>","text":"<p>OpenLayers map widget implementation.</p>"},{"location":"anymap_ts/#anymap_ts.openlayers.OpenLayersMap","title":"<code> OpenLayersMap            (MapWidget)         </code>","text":"<p>Interactive map widget using OpenLayers.</p> <p>This class provides a Python interface to OpenLayers maps with full bidirectional communication through anywidget. OpenLayers excels at WMS/WMTS support and projection handling.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from anymap_ts import OpenLayersMap\n&gt;&gt;&gt; m = OpenLayersMap(center=[-122.4, 37.8], zoom=10)\n&gt;&gt;&gt; m.add_basemap(\"OpenStreetMap\")\n&gt;&gt;&gt; m.add_wms_layer(\n...     url=\"https://example.com/wms\",\n...     layers=\"layer_name\",\n...     name=\"WMS Layer\"\n... )\n&gt;&gt;&gt; m\n</code></pre> Source code in <code>anymap_ts/openlayers.py</code> <pre><code>class OpenLayersMap(MapWidget):\n    \"\"\"Interactive map widget using OpenLayers.\n\n    This class provides a Python interface to OpenLayers maps with\n    full bidirectional communication through anywidget. OpenLayers\n    excels at WMS/WMTS support and projection handling.\n\n    Example:\n        &gt;&gt;&gt; from anymap_ts import OpenLayersMap\n        &gt;&gt;&gt; m = OpenLayersMap(center=[-122.4, 37.8], zoom=10)\n        &gt;&gt;&gt; m.add_basemap(\"OpenStreetMap\")\n        &gt;&gt;&gt; m.add_wms_layer(\n        ...     url=\"https://example.com/wms\",\n        ...     layers=\"layer_name\",\n        ...     name=\"WMS Layer\"\n        ... )\n        &gt;&gt;&gt; m\n    \"\"\"\n\n    # ESM module for frontend\n    _esm = STATIC_DIR / \"openlayers.js\"\n\n    # OpenLayers-specific traits\n    projection = traitlets.Unicode(\"EPSG:3857\").tag(sync=True)\n    rotation = traitlets.Float(0.0).tag(sync=True)\n\n    # Layer tracking\n    _layer_dict = traitlets.Dict({}).tag(sync=True)\n\n    def __init__(\n        self,\n        center: Tuple[float, float] = (0.0, 0.0),\n        zoom: float = 2.0,\n        width: str = \"100%\",\n        height: str = \"600px\",\n        projection: str = \"EPSG:3857\",\n        rotation: float = 0.0,\n        controls: Optional[Dict[str, Any]] = None,\n        **kwargs,\n    ):\n        \"\"\"Initialize an OpenLayers map.\n\n        Args:\n            center: Map center as (longitude, latitude).\n            zoom: Initial zoom level.\n            width: Map width as CSS string.\n            height: Map height as CSS string.\n            projection: Map projection (default EPSG:3857).\n            rotation: Map rotation in radians.\n            controls: Dict of controls to add.\n            **kwargs: Additional widget arguments.\n        \"\"\"\n        super().__init__(\n            center=list(center),\n            zoom=zoom,\n            width=width,\n            height=height,\n            projection=projection,\n            rotation=rotation,\n            **kwargs,\n        )\n\n        # Initialize layer dictionary\n        self._layer_dict = {\"Background\": []}\n\n        # Add default controls\n        if controls is None:\n            controls = {\"zoom\": True, \"attribution\": True}\n\n        for control_name, config in controls.items():\n            if config:\n                self.add_control(\n                    control_name, **(config if isinstance(config, dict) else {})\n                )\n\n    # -------------------------------------------------------------------------\n    # Basemap Methods\n    # -------------------------------------------------------------------------\n\n    def add_basemap(\n        self,\n        basemap: str = \"OpenStreetMap\",\n        attribution: Optional[str] = None,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a basemap layer.\n\n        Args:\n            basemap: Name of basemap provider (e.g., \"OpenStreetMap\", \"CartoDB.Positron\").\n            attribution: Custom attribution text.\n            **kwargs: Additional options.\n        \"\"\"\n        url, default_attribution = get_basemap_url(basemap)\n        self.call_js_method(\n            \"addBasemap\",\n            url,\n            attribution=attribution or default_attribution,\n            name=basemap,\n            **kwargs,\n        )\n\n        basemaps = self._layer_dict.get(\"Basemaps\", [])\n        if basemap not in basemaps:\n            self._layer_dict = {\n                **self._layer_dict,\n                \"Basemaps\": basemaps + [basemap],\n            }\n\n    # -------------------------------------------------------------------------\n    # Tile Layer Methods\n    # -------------------------------------------------------------------------\n\n    def add_tile_layer(\n        self,\n        url: str,\n        name: Optional[str] = None,\n        attribution: str = \"\",\n        min_zoom: int = 0,\n        max_zoom: int = 22,\n        opacity: float = 1.0,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add an XYZ tile layer.\n\n        Args:\n            url: Tile URL template with {x}, {y}, {z} placeholders.\n            name: Layer name.\n            attribution: Attribution text.\n            min_zoom: Minimum zoom level.\n            max_zoom: Maximum zoom level.\n            opacity: Layer opacity.\n            **kwargs: Additional options.\n        \"\"\"\n        layer_id = name or f\"tiles-{len(self._layers)}\"\n\n        self.call_js_method(\n            \"addTileLayer\",\n            url,\n            name=layer_id,\n            attribution=attribution,\n            minZoom=min_zoom,\n            maxZoom=max_zoom,\n            opacity=opacity,\n            **kwargs,\n        )\n\n        self._layers = {\n            **self._layers,\n            layer_id: {\"id\": layer_id, \"type\": \"tile\"},\n        }\n\n    # -------------------------------------------------------------------------\n    # Vector Data Methods\n    # -------------------------------------------------------------------------\n\n    def add_vector(\n        self,\n        data: Any,\n        name: Optional[str] = None,\n        style: Optional[Dict] = None,\n        fit_bounds: bool = True,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add vector data to the map.\n\n        Args:\n            data: GeoJSON dict, GeoDataFrame, or path to vector file.\n            name: Layer name.\n            style: Style configuration dict.\n            fit_bounds: Whether to fit map to data bounds.\n            **kwargs: Additional layer options.\n        \"\"\"\n        geojson = to_geojson(data)\n        layer_id = name or f\"vector-{len(self._layers)}\"\n\n        if style is None:\n            style = self._get_default_style(geojson)\n\n        self.call_js_method(\n            \"addGeoJSON\",\n            data=geojson,\n            name=layer_id,\n            style=style,\n            fitBounds=fit_bounds,\n            **kwargs,\n        )\n\n        self._layers = {\n            **self._layers,\n            layer_id: {\"id\": layer_id, \"type\": \"vector\"},\n        }\n\n    def add_geojson(\n        self,\n        data: Union[str, Dict],\n        name: Optional[str] = None,\n        style: Optional[Dict] = None,\n        fit_bounds: bool = True,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add GeoJSON data to the map.\n\n        Args:\n            data: GeoJSON dict or URL to GeoJSON file.\n            name: Layer name.\n            style: Style configuration dict.\n            fit_bounds: Whether to fit map to data bounds.\n            **kwargs: Additional layer options.\n        \"\"\"\n        self.add_vector(\n            data,\n            name=name,\n            style=style,\n            fit_bounds=fit_bounds,\n            **kwargs,\n        )\n\n    def _get_default_style(self, geojson: Dict) -&gt; Dict:\n        \"\"\"Get default style based on geometry type.\n\n        Args:\n            geojson: GeoJSON data.\n\n        Returns:\n            Style configuration dict.\n        \"\"\"\n        geom_type = self._infer_geom_type(geojson)\n\n        if geom_type in [\"Point\", \"MultiPoint\"]:\n            return {\n                \"fillColor\": \"rgba(51, 136, 255, 0.8)\",\n                \"strokeColor\": \"#ffffff\",\n                \"strokeWidth\": 2,\n                \"radius\": 6,\n            }\n        elif geom_type in [\"LineString\", \"MultiLineString\"]:\n            return {\n                \"strokeColor\": \"#3388ff\",\n                \"strokeWidth\": 3,\n            }\n        else:  # Polygon, MultiPolygon\n            return {\n                \"fillColor\": \"rgba(51, 136, 255, 0.5)\",\n                \"strokeColor\": \"#3388ff\",\n                \"strokeWidth\": 2,\n            }\n\n    def _infer_geom_type(self, geojson: Dict) -&gt; str:\n        \"\"\"Infer geometry type from GeoJSON.\n\n        Args:\n            geojson: GeoJSON data.\n\n        Returns:\n            Geometry type string.\n        \"\"\"\n        if geojson.get(\"type\") == \"FeatureCollection\":\n            features = geojson.get(\"features\", [])\n            if features:\n                return features[0].get(\"geometry\", {}).get(\"type\", \"Point\")\n        elif geojson.get(\"type\") == \"Feature\":\n            return geojson.get(\"geometry\", {}).get(\"type\", \"Point\")\n        return \"Point\"\n\n    # -------------------------------------------------------------------------\n    # WMS/WMTS Methods\n    # -------------------------------------------------------------------------\n\n    def add_wms_layer(\n        self,\n        url: str,\n        layers: str,\n        name: Optional[str] = None,\n        format: str = \"image/png\",\n        transparent: bool = True,\n        server_type: Optional[str] = None,\n        attribution: str = \"\",\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a WMS tile layer.\n\n        Args:\n            url: WMS service URL.\n            layers: Comma-separated layer names.\n            name: Layer name for the map.\n            format: Image format (default: image/png).\n            transparent: Whether to request transparent images.\n            server_type: Server type ('mapserver', 'geoserver', 'qgis').\n            attribution: Attribution text.\n            **kwargs: Additional WMS parameters.\n        \"\"\"\n        layer_id = name or f\"wms-{len(self._layers)}\"\n\n        self.call_js_method(\n            \"addWMSLayer\",\n            url=url,\n            layers=layers,\n            name=layer_id,\n            format=format,\n            transparent=transparent,\n            serverType=server_type,\n            attribution=attribution,\n            **kwargs,\n        )\n\n        self._layers = {\n            **self._layers,\n            layer_id: {\"id\": layer_id, \"type\": \"wms\"},\n        }\n\n    def add_image_wms_layer(\n        self,\n        url: str,\n        layers: str,\n        name: Optional[str] = None,\n        format: str = \"image/png\",\n        transparent: bool = True,\n        server_type: Optional[str] = None,\n        attribution: str = \"\",\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a single-image WMS layer (not tiled).\n\n        Args:\n            url: WMS service URL.\n            layers: Comma-separated layer names.\n            name: Layer name for the map.\n            format: Image format (default: image/png).\n            transparent: Whether to request transparent images.\n            server_type: Server type ('mapserver', 'geoserver', 'qgis').\n            attribution: Attribution text.\n            **kwargs: Additional WMS parameters.\n        \"\"\"\n        layer_id = name or f\"imagewms-{len(self._layers)}\"\n\n        self.call_js_method(\n            \"addImageWMSLayer\",\n            url=url,\n            layers=layers,\n            name=layer_id,\n            format=format,\n            transparent=transparent,\n            serverType=server_type,\n            attribution=attribution,\n            **kwargs,\n        )\n\n        self._layers = {\n            **self._layers,\n            layer_id: {\"id\": layer_id, \"type\": \"imagewms\"},\n        }\n\n    # -------------------------------------------------------------------------\n    # Layer Management\n    # -------------------------------------------------------------------------\n\n    def remove_layer(self, layer_id: str) -&gt; None:\n        \"\"\"Remove a layer from the map.\n\n        Args:\n            layer_id: Layer identifier to remove.\n        \"\"\"\n        if layer_id in self._layers:\n            layers = dict(self._layers)\n            del layers[layer_id]\n            self._layers = layers\n        self.call_js_method(\"removeLayer\", layer_id)\n\n    def set_visibility(self, layer_id: str, visible: bool) -&gt; None:\n        \"\"\"Set layer visibility.\n\n        Args:\n            layer_id: Layer identifier.\n            visible: Whether layer should be visible.\n        \"\"\"\n        self.call_js_method(\"setVisibility\", layer_id, visible)\n\n    def set_opacity(self, layer_id: str, opacity: float) -&gt; None:\n        \"\"\"Set layer opacity.\n\n        Args:\n            layer_id: Layer identifier.\n            opacity: Opacity value between 0 and 1.\n        \"\"\"\n        self.call_js_method(\"setOpacity\", layer_id, opacity)\n\n    # -------------------------------------------------------------------------\n    # Controls\n    # -------------------------------------------------------------------------\n\n    def add_control(\n        self,\n        control_type: str,\n        position: str = \"top-right\",\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a map control.\n\n        Args:\n            control_type: Type of control ('zoom', 'scale', 'fullscreen', etc.).\n            position: Control position.\n            **kwargs: Control-specific options.\n        \"\"\"\n        self.call_js_method(\"addControl\", control_type, position=position, **kwargs)\n        self._controls = {\n            **self._controls,\n            control_type: {\"type\": control_type, \"position\": position, **kwargs},\n        }\n\n    def remove_control(self, control_type: str) -&gt; None:\n        \"\"\"Remove a map control.\n\n        Args:\n            control_type: Type of control to remove.\n        \"\"\"\n        self.call_js_method(\"removeControl\", control_type)\n        if control_type in self._controls:\n            controls = dict(self._controls)\n            del controls[control_type]\n            self._controls = controls\n\n    # -------------------------------------------------------------------------\n    # Navigation\n    # -------------------------------------------------------------------------\n\n    def set_center(self, lng: float, lat: float) -&gt; None:\n        \"\"\"Set the map center.\n\n        Args:\n            lng: Longitude.\n            lat: Latitude.\n        \"\"\"\n        self.center = [lng, lat]\n        self.call_js_method(\"setCenter\", lng, lat)\n\n    def set_zoom(self, zoom: float) -&gt; None:\n        \"\"\"Set the map zoom level.\n\n        Args:\n            zoom: Zoom level.\n        \"\"\"\n        self.zoom = zoom\n        self.call_js_method(\"setZoom\", zoom)\n\n    def fly_to(\n        self,\n        lng: float,\n        lat: float,\n        zoom: Optional[float] = None,\n        duration: int = 2000,\n    ) -&gt; None:\n        \"\"\"Animate to a new location.\n\n        Args:\n            lng: Target longitude.\n            lat: Target latitude.\n            zoom: Target zoom level (optional).\n            duration: Animation duration in milliseconds.\n        \"\"\"\n        self.call_js_method(\n            \"flyTo\", lng, lat, zoom=zoom or self.zoom, duration=duration\n        )\n\n    def fit_bounds(\n        self,\n        bounds: List[float],\n        padding: int = 50,\n        duration: int = 1000,\n    ) -&gt; None:\n        \"\"\"Fit the map to bounds.\n\n        Args:\n            bounds: Bounds as [minLng, minLat, maxLng, maxLat].\n            padding: Padding in pixels.\n            duration: Animation duration in milliseconds.\n        \"\"\"\n        self.call_js_method(\"fitBounds\", bounds, padding=padding, duration=duration)\n\n    def fit_extent(\n        self,\n        extent: List[float],\n        padding: int = 50,\n        duration: int = 1000,\n    ) -&gt; None:\n        \"\"\"Fit the map to an extent (in map projection).\n\n        Args:\n            extent: Extent as [minX, minY, maxX, maxY] in map projection.\n            padding: Padding in pixels.\n            duration: Animation duration in milliseconds.\n        \"\"\"\n        self.call_js_method(\"fitExtent\", extent, padding=padding, duration=duration)\n\n    # -------------------------------------------------------------------------\n    # Markers\n    # -------------------------------------------------------------------------\n\n    def add_marker(\n        self,\n        lng: float,\n        lat: float,\n        popup: Optional[str] = None,\n        color: str = \"#3388ff\",\n        name: Optional[str] = None,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a marker to the map.\n\n        Args:\n            lng: Marker longitude.\n            lat: Marker latitude.\n            popup: Popup content (HTML string).\n            color: Marker color.\n            name: Marker identifier.\n            **kwargs: Additional options.\n        \"\"\"\n        marker_id = name or f\"marker-{len(self._layers)}\"\n        self.call_js_method(\n            \"addMarker\",\n            lng,\n            lat,\n            popup=popup,\n            color=color,\n            id=marker_id,\n            **kwargs,\n        )\n\n    # -------------------------------------------------------------------------\n    # HTML Export\n    # -------------------------------------------------------------------------\n\n    def _generate_html_template(self) -&gt; str:\n        \"\"\"Generate standalone HTML for the map.\"\"\"\n        template_path = Path(__file__).parent / \"templates\" / \"openlayers.html\"\n\n        if template_path.exists():\n            template = template_path.read_text(encoding=\"utf-8\")\n        else:\n            template = self._get_default_template()\n\n        state = {\n            \"center\": self.center,\n            \"zoom\": self.zoom,\n            \"projection\": self.projection,\n            \"rotation\": self.rotation,\n            \"width\": self.width,\n            \"height\": self.height,\n            \"layers\": self._layers,\n            \"controls\": self._controls,\n            \"js_calls\": self._js_calls,\n        }\n\n        template = template.replace(\"{{state}}\", json.dumps(state, indent=2))\n        return template\n\n    def _get_default_template(self) -&gt; str:\n        \"\"\"Get default HTML template.\"\"\"\n        return \"\"\"&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n    &lt;meta charset=\"utf-8\"&gt;\n    &lt;title&gt;OpenLayers Map&lt;/title&gt;\n    &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"&gt;\n    &lt;link rel=\"stylesheet\" href=\"https://cdn.jsdelivr.net/npm/ol@v10.0.0/ol.css\"&gt;\n    &lt;script src=\"https://cdn.jsdelivr.net/npm/ol@v10.0.0/dist/ol.js\"&gt;&lt;/script&gt;\n    &lt;style&gt;\n        * { margin: 0; padding: 0; box-sizing: border-box; }\n        html, body { height: 100%; }\n        #map { position: absolute; top: 0; bottom: 0; width: 100%; }\n    &lt;/style&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;div id=\"map\"&gt;&lt;/div&gt;\n    &lt;script&gt;\n        const state = {{state}};\n\n        const map = new ol.Map({\n            target: 'map',\n            view: new ol.View({\n                center: ol.proj.fromLonLat(state.center),\n                zoom: state.zoom\n            })\n        });\n\n        for (const call of state.js_calls || []) {\n            executeMethod(call.method, call.args, call.kwargs);\n        }\n\n        function executeMethod(method, args, kwargs) {\n            console.log('Executing:', method, args, kwargs);\n        }\n    &lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\"\"\"\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.openlayers.OpenLayersMap.__init__","title":"<code>__init__(self, center=(0.0, 0.0), zoom=2.0, width='100%', height='600px', projection='EPSG:3857', rotation=0.0, controls=None, **kwargs)</code>  <code>special</code>","text":"<p>Initialize an OpenLayers map.</p> <p>Parameters:</p> Name Type Description Default <code>center</code> <code>Tuple[float, float]</code> <p>Map center as (longitude, latitude).</p> <code>(0.0, 0.0)</code> <code>zoom</code> <code>float</code> <p>Initial zoom level.</p> <code>2.0</code> <code>width</code> <code>str</code> <p>Map width as CSS string.</p> <code>'100%'</code> <code>height</code> <code>str</code> <p>Map height as CSS string.</p> <code>'600px'</code> <code>projection</code> <code>str</code> <p>Map projection (default EPSG:3857).</p> <code>'EPSG:3857'</code> <code>rotation</code> <code>float</code> <p>Map rotation in radians.</p> <code>0.0</code> <code>controls</code> <code>Optional[Dict[str, Any]]</code> <p>Dict of controls to add.</p> <code>None</code> <code>**kwargs</code> <p>Additional widget arguments.</p> <code>{}</code> Source code in <code>anymap_ts/openlayers.py</code> <pre><code>def __init__(\n    self,\n    center: Tuple[float, float] = (0.0, 0.0),\n    zoom: float = 2.0,\n    width: str = \"100%\",\n    height: str = \"600px\",\n    projection: str = \"EPSG:3857\",\n    rotation: float = 0.0,\n    controls: Optional[Dict[str, Any]] = None,\n    **kwargs,\n):\n    \"\"\"Initialize an OpenLayers map.\n\n    Args:\n        center: Map center as (longitude, latitude).\n        zoom: Initial zoom level.\n        width: Map width as CSS string.\n        height: Map height as CSS string.\n        projection: Map projection (default EPSG:3857).\n        rotation: Map rotation in radians.\n        controls: Dict of controls to add.\n        **kwargs: Additional widget arguments.\n    \"\"\"\n    super().__init__(\n        center=list(center),\n        zoom=zoom,\n        width=width,\n        height=height,\n        projection=projection,\n        rotation=rotation,\n        **kwargs,\n    )\n\n    # Initialize layer dictionary\n    self._layer_dict = {\"Background\": []}\n\n    # Add default controls\n    if controls is None:\n        controls = {\"zoom\": True, \"attribution\": True}\n\n    for control_name, config in controls.items():\n        if config:\n            self.add_control(\n                control_name, **(config if isinstance(config, dict) else {})\n            )\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.openlayers.OpenLayersMap.add_basemap","title":"<code>add_basemap(self, basemap='OpenStreetMap', attribution=None, **kwargs)</code>","text":"<p>Add a basemap layer.</p> <p>Parameters:</p> Name Type Description Default <code>basemap</code> <code>str</code> <p>Name of basemap provider (e.g., \"OpenStreetMap\", \"CartoDB.Positron\").</p> <code>'OpenStreetMap'</code> <code>attribution</code> <code>Optional[str]</code> <p>Custom attribution text.</p> <code>None</code> <code>**kwargs</code> <p>Additional options.</p> <code>{}</code> Source code in <code>anymap_ts/openlayers.py</code> <pre><code>def add_basemap(\n    self,\n    basemap: str = \"OpenStreetMap\",\n    attribution: Optional[str] = None,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a basemap layer.\n\n    Args:\n        basemap: Name of basemap provider (e.g., \"OpenStreetMap\", \"CartoDB.Positron\").\n        attribution: Custom attribution text.\n        **kwargs: Additional options.\n    \"\"\"\n    url, default_attribution = get_basemap_url(basemap)\n    self.call_js_method(\n        \"addBasemap\",\n        url,\n        attribution=attribution or default_attribution,\n        name=basemap,\n        **kwargs,\n    )\n\n    basemaps = self._layer_dict.get(\"Basemaps\", [])\n    if basemap not in basemaps:\n        self._layer_dict = {\n            **self._layer_dict,\n            \"Basemaps\": basemaps + [basemap],\n        }\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.openlayers.OpenLayersMap.add_control","title":"<code>add_control(self, control_type, position='top-right', **kwargs)</code>","text":"<p>Add a map control.</p> <p>Parameters:</p> Name Type Description Default <code>control_type</code> <code>str</code> <p>Type of control ('zoom', 'scale', 'fullscreen', etc.).</p> required <code>position</code> <code>str</code> <p>Control position.</p> <code>'top-right'</code> <code>**kwargs</code> <p>Control-specific options.</p> <code>{}</code> Source code in <code>anymap_ts/openlayers.py</code> <pre><code>def add_control(\n    self,\n    control_type: str,\n    position: str = \"top-right\",\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a map control.\n\n    Args:\n        control_type: Type of control ('zoom', 'scale', 'fullscreen', etc.).\n        position: Control position.\n        **kwargs: Control-specific options.\n    \"\"\"\n    self.call_js_method(\"addControl\", control_type, position=position, **kwargs)\n    self._controls = {\n        **self._controls,\n        control_type: {\"type\": control_type, \"position\": position, **kwargs},\n    }\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.openlayers.OpenLayersMap.add_geojson","title":"<code>add_geojson(self, data, name=None, style=None, fit_bounds=True, **kwargs)</code>","text":"<p>Add GeoJSON data to the map.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Union[str, Dict]</code> <p>GeoJSON dict or URL to GeoJSON file.</p> required <code>name</code> <code>Optional[str]</code> <p>Layer name.</p> <code>None</code> <code>style</code> <code>Optional[Dict]</code> <p>Style configuration dict.</p> <code>None</code> <code>fit_bounds</code> <code>bool</code> <p>Whether to fit map to data bounds.</p> <code>True</code> <code>**kwargs</code> <p>Additional layer options.</p> <code>{}</code> Source code in <code>anymap_ts/openlayers.py</code> <pre><code>def add_geojson(\n    self,\n    data: Union[str, Dict],\n    name: Optional[str] = None,\n    style: Optional[Dict] = None,\n    fit_bounds: bool = True,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add GeoJSON data to the map.\n\n    Args:\n        data: GeoJSON dict or URL to GeoJSON file.\n        name: Layer name.\n        style: Style configuration dict.\n        fit_bounds: Whether to fit map to data bounds.\n        **kwargs: Additional layer options.\n    \"\"\"\n    self.add_vector(\n        data,\n        name=name,\n        style=style,\n        fit_bounds=fit_bounds,\n        **kwargs,\n    )\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.openlayers.OpenLayersMap.add_image_wms_layer","title":"<code>add_image_wms_layer(self, url, layers, name=None, format='image/png', transparent=True, server_type=None, attribution='', **kwargs)</code>","text":"<p>Add a single-image WMS layer (not tiled).</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>WMS service URL.</p> required <code>layers</code> <code>str</code> <p>Comma-separated layer names.</p> required <code>name</code> <code>Optional[str]</code> <p>Layer name for the map.</p> <code>None</code> <code>format</code> <code>str</code> <p>Image format (default: image/png).</p> <code>'image/png'</code> <code>transparent</code> <code>bool</code> <p>Whether to request transparent images.</p> <code>True</code> <code>server_type</code> <code>Optional[str]</code> <p>Server type ('mapserver', 'geoserver', 'qgis').</p> <code>None</code> <code>attribution</code> <code>str</code> <p>Attribution text.</p> <code>''</code> <code>**kwargs</code> <p>Additional WMS parameters.</p> <code>{}</code> Source code in <code>anymap_ts/openlayers.py</code> <pre><code>def add_image_wms_layer(\n    self,\n    url: str,\n    layers: str,\n    name: Optional[str] = None,\n    format: str = \"image/png\",\n    transparent: bool = True,\n    server_type: Optional[str] = None,\n    attribution: str = \"\",\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a single-image WMS layer (not tiled).\n\n    Args:\n        url: WMS service URL.\n        layers: Comma-separated layer names.\n        name: Layer name for the map.\n        format: Image format (default: image/png).\n        transparent: Whether to request transparent images.\n        server_type: Server type ('mapserver', 'geoserver', 'qgis').\n        attribution: Attribution text.\n        **kwargs: Additional WMS parameters.\n    \"\"\"\n    layer_id = name or f\"imagewms-{len(self._layers)}\"\n\n    self.call_js_method(\n        \"addImageWMSLayer\",\n        url=url,\n        layers=layers,\n        name=layer_id,\n        format=format,\n        transparent=transparent,\n        serverType=server_type,\n        attribution=attribution,\n        **kwargs,\n    )\n\n    self._layers = {\n        **self._layers,\n        layer_id: {\"id\": layer_id, \"type\": \"imagewms\"},\n    }\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.openlayers.OpenLayersMap.add_marker","title":"<code>add_marker(self, lng, lat, popup=None, color='#3388ff', name=None, **kwargs)</code>","text":"<p>Add a marker to the map.</p> <p>Parameters:</p> Name Type Description Default <code>lng</code> <code>float</code> <p>Marker longitude.</p> required <code>lat</code> <code>float</code> <p>Marker latitude.</p> required <code>popup</code> <code>Optional[str]</code> <p>Popup content (HTML string).</p> <code>None</code> <code>color</code> <code>str</code> <p>Marker color.</p> <code>'#3388ff'</code> <code>name</code> <code>Optional[str]</code> <p>Marker identifier.</p> <code>None</code> <code>**kwargs</code> <p>Additional options.</p> <code>{}</code> Source code in <code>anymap_ts/openlayers.py</code> <pre><code>def add_marker(\n    self,\n    lng: float,\n    lat: float,\n    popup: Optional[str] = None,\n    color: str = \"#3388ff\",\n    name: Optional[str] = None,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a marker to the map.\n\n    Args:\n        lng: Marker longitude.\n        lat: Marker latitude.\n        popup: Popup content (HTML string).\n        color: Marker color.\n        name: Marker identifier.\n        **kwargs: Additional options.\n    \"\"\"\n    marker_id = name or f\"marker-{len(self._layers)}\"\n    self.call_js_method(\n        \"addMarker\",\n        lng,\n        lat,\n        popup=popup,\n        color=color,\n        id=marker_id,\n        **kwargs,\n    )\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.openlayers.OpenLayersMap.add_tile_layer","title":"<code>add_tile_layer(self, url, name=None, attribution='', min_zoom=0, max_zoom=22, opacity=1.0, **kwargs)</code>","text":"<p>Add an XYZ tile layer.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>Tile URL template with {x}, {y}, {z} placeholders.</p> required <code>name</code> <code>Optional[str]</code> <p>Layer name.</p> <code>None</code> <code>attribution</code> <code>str</code> <p>Attribution text.</p> <code>''</code> <code>min_zoom</code> <code>int</code> <p>Minimum zoom level.</p> <code>0</code> <code>max_zoom</code> <code>int</code> <p>Maximum zoom level.</p> <code>22</code> <code>opacity</code> <code>float</code> <p>Layer opacity.</p> <code>1.0</code> <code>**kwargs</code> <p>Additional options.</p> <code>{}</code> Source code in <code>anymap_ts/openlayers.py</code> <pre><code>def add_tile_layer(\n    self,\n    url: str,\n    name: Optional[str] = None,\n    attribution: str = \"\",\n    min_zoom: int = 0,\n    max_zoom: int = 22,\n    opacity: float = 1.0,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add an XYZ tile layer.\n\n    Args:\n        url: Tile URL template with {x}, {y}, {z} placeholders.\n        name: Layer name.\n        attribution: Attribution text.\n        min_zoom: Minimum zoom level.\n        max_zoom: Maximum zoom level.\n        opacity: Layer opacity.\n        **kwargs: Additional options.\n    \"\"\"\n    layer_id = name or f\"tiles-{len(self._layers)}\"\n\n    self.call_js_method(\n        \"addTileLayer\",\n        url,\n        name=layer_id,\n        attribution=attribution,\n        minZoom=min_zoom,\n        maxZoom=max_zoom,\n        opacity=opacity,\n        **kwargs,\n    )\n\n    self._layers = {\n        **self._layers,\n        layer_id: {\"id\": layer_id, \"type\": \"tile\"},\n    }\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.openlayers.OpenLayersMap.add_vector","title":"<code>add_vector(self, data, name=None, style=None, fit_bounds=True, **kwargs)</code>","text":"<p>Add vector data to the map.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>GeoJSON dict, GeoDataFrame, or path to vector file.</p> required <code>name</code> <code>Optional[str]</code> <p>Layer name.</p> <code>None</code> <code>style</code> <code>Optional[Dict]</code> <p>Style configuration dict.</p> <code>None</code> <code>fit_bounds</code> <code>bool</code> <p>Whether to fit map to data bounds.</p> <code>True</code> <code>**kwargs</code> <p>Additional layer options.</p> <code>{}</code> Source code in <code>anymap_ts/openlayers.py</code> <pre><code>def add_vector(\n    self,\n    data: Any,\n    name: Optional[str] = None,\n    style: Optional[Dict] = None,\n    fit_bounds: bool = True,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add vector data to the map.\n\n    Args:\n        data: GeoJSON dict, GeoDataFrame, or path to vector file.\n        name: Layer name.\n        style: Style configuration dict.\n        fit_bounds: Whether to fit map to data bounds.\n        **kwargs: Additional layer options.\n    \"\"\"\n    geojson = to_geojson(data)\n    layer_id = name or f\"vector-{len(self._layers)}\"\n\n    if style is None:\n        style = self._get_default_style(geojson)\n\n    self.call_js_method(\n        \"addGeoJSON\",\n        data=geojson,\n        name=layer_id,\n        style=style,\n        fitBounds=fit_bounds,\n        **kwargs,\n    )\n\n    self._layers = {\n        **self._layers,\n        layer_id: {\"id\": layer_id, \"type\": \"vector\"},\n    }\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.openlayers.OpenLayersMap.add_wms_layer","title":"<code>add_wms_layer(self, url, layers, name=None, format='image/png', transparent=True, server_type=None, attribution='', **kwargs)</code>","text":"<p>Add a WMS tile layer.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>WMS service URL.</p> required <code>layers</code> <code>str</code> <p>Comma-separated layer names.</p> required <code>name</code> <code>Optional[str]</code> <p>Layer name for the map.</p> <code>None</code> <code>format</code> <code>str</code> <p>Image format (default: image/png).</p> <code>'image/png'</code> <code>transparent</code> <code>bool</code> <p>Whether to request transparent images.</p> <code>True</code> <code>server_type</code> <code>Optional[str]</code> <p>Server type ('mapserver', 'geoserver', 'qgis').</p> <code>None</code> <code>attribution</code> <code>str</code> <p>Attribution text.</p> <code>''</code> <code>**kwargs</code> <p>Additional WMS parameters.</p> <code>{}</code> Source code in <code>anymap_ts/openlayers.py</code> <pre><code>def add_wms_layer(\n    self,\n    url: str,\n    layers: str,\n    name: Optional[str] = None,\n    format: str = \"image/png\",\n    transparent: bool = True,\n    server_type: Optional[str] = None,\n    attribution: str = \"\",\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a WMS tile layer.\n\n    Args:\n        url: WMS service URL.\n        layers: Comma-separated layer names.\n        name: Layer name for the map.\n        format: Image format (default: image/png).\n        transparent: Whether to request transparent images.\n        server_type: Server type ('mapserver', 'geoserver', 'qgis').\n        attribution: Attribution text.\n        **kwargs: Additional WMS parameters.\n    \"\"\"\n    layer_id = name or f\"wms-{len(self._layers)}\"\n\n    self.call_js_method(\n        \"addWMSLayer\",\n        url=url,\n        layers=layers,\n        name=layer_id,\n        format=format,\n        transparent=transparent,\n        serverType=server_type,\n        attribution=attribution,\n        **kwargs,\n    )\n\n    self._layers = {\n        **self._layers,\n        layer_id: {\"id\": layer_id, \"type\": \"wms\"},\n    }\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.openlayers.OpenLayersMap.fit_bounds","title":"<code>fit_bounds(self, bounds, padding=50, duration=1000)</code>","text":"<p>Fit the map to bounds.</p> <p>Parameters:</p> Name Type Description Default <code>bounds</code> <code>List[float]</code> <p>Bounds as [minLng, minLat, maxLng, maxLat].</p> required <code>padding</code> <code>int</code> <p>Padding in pixels.</p> <code>50</code> <code>duration</code> <code>int</code> <p>Animation duration in milliseconds.</p> <code>1000</code> Source code in <code>anymap_ts/openlayers.py</code> <pre><code>def fit_bounds(\n    self,\n    bounds: List[float],\n    padding: int = 50,\n    duration: int = 1000,\n) -&gt; None:\n    \"\"\"Fit the map to bounds.\n\n    Args:\n        bounds: Bounds as [minLng, minLat, maxLng, maxLat].\n        padding: Padding in pixels.\n        duration: Animation duration in milliseconds.\n    \"\"\"\n    self.call_js_method(\"fitBounds\", bounds, padding=padding, duration=duration)\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.openlayers.OpenLayersMap.fit_extent","title":"<code>fit_extent(self, extent, padding=50, duration=1000)</code>","text":"<p>Fit the map to an extent (in map projection).</p> <p>Parameters:</p> Name Type Description Default <code>extent</code> <code>List[float]</code> <p>Extent as [minX, minY, maxX, maxY] in map projection.</p> required <code>padding</code> <code>int</code> <p>Padding in pixels.</p> <code>50</code> <code>duration</code> <code>int</code> <p>Animation duration in milliseconds.</p> <code>1000</code> Source code in <code>anymap_ts/openlayers.py</code> <pre><code>def fit_extent(\n    self,\n    extent: List[float],\n    padding: int = 50,\n    duration: int = 1000,\n) -&gt; None:\n    \"\"\"Fit the map to an extent (in map projection).\n\n    Args:\n        extent: Extent as [minX, minY, maxX, maxY] in map projection.\n        padding: Padding in pixels.\n        duration: Animation duration in milliseconds.\n    \"\"\"\n    self.call_js_method(\"fitExtent\", extent, padding=padding, duration=duration)\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.openlayers.OpenLayersMap.fly_to","title":"<code>fly_to(self, lng, lat, zoom=None, duration=2000)</code>","text":"<p>Animate to a new location.</p> <p>Parameters:</p> Name Type Description Default <code>lng</code> <code>float</code> <p>Target longitude.</p> required <code>lat</code> <code>float</code> <p>Target latitude.</p> required <code>zoom</code> <code>Optional[float]</code> <p>Target zoom level (optional).</p> <code>None</code> <code>duration</code> <code>int</code> <p>Animation duration in milliseconds.</p> <code>2000</code> Source code in <code>anymap_ts/openlayers.py</code> <pre><code>def fly_to(\n    self,\n    lng: float,\n    lat: float,\n    zoom: Optional[float] = None,\n    duration: int = 2000,\n) -&gt; None:\n    \"\"\"Animate to a new location.\n\n    Args:\n        lng: Target longitude.\n        lat: Target latitude.\n        zoom: Target zoom level (optional).\n        duration: Animation duration in milliseconds.\n    \"\"\"\n    self.call_js_method(\n        \"flyTo\", lng, lat, zoom=zoom or self.zoom, duration=duration\n    )\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.openlayers.OpenLayersMap.remove_control","title":"<code>remove_control(self, control_type)</code>","text":"<p>Remove a map control.</p> <p>Parameters:</p> Name Type Description Default <code>control_type</code> <code>str</code> <p>Type of control to remove.</p> required Source code in <code>anymap_ts/openlayers.py</code> <pre><code>def remove_control(self, control_type: str) -&gt; None:\n    \"\"\"Remove a map control.\n\n    Args:\n        control_type: Type of control to remove.\n    \"\"\"\n    self.call_js_method(\"removeControl\", control_type)\n    if control_type in self._controls:\n        controls = dict(self._controls)\n        del controls[control_type]\n        self._controls = controls\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.openlayers.OpenLayersMap.remove_layer","title":"<code>remove_layer(self, layer_id)</code>","text":"<p>Remove a layer from the map.</p> <p>Parameters:</p> Name Type Description Default <code>layer_id</code> <code>str</code> <p>Layer identifier to remove.</p> required Source code in <code>anymap_ts/openlayers.py</code> <pre><code>def remove_layer(self, layer_id: str) -&gt; None:\n    \"\"\"Remove a layer from the map.\n\n    Args:\n        layer_id: Layer identifier to remove.\n    \"\"\"\n    if layer_id in self._layers:\n        layers = dict(self._layers)\n        del layers[layer_id]\n        self._layers = layers\n    self.call_js_method(\"removeLayer\", layer_id)\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.openlayers.OpenLayersMap.set_center","title":"<code>set_center(self, lng, lat)</code>","text":"<p>Set the map center.</p> <p>Parameters:</p> Name Type Description Default <code>lng</code> <code>float</code> <p>Longitude.</p> required <code>lat</code> <code>float</code> <p>Latitude.</p> required Source code in <code>anymap_ts/openlayers.py</code> <pre><code>def set_center(self, lng: float, lat: float) -&gt; None:\n    \"\"\"Set the map center.\n\n    Args:\n        lng: Longitude.\n        lat: Latitude.\n    \"\"\"\n    self.center = [lng, lat]\n    self.call_js_method(\"setCenter\", lng, lat)\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.openlayers.OpenLayersMap.set_opacity","title":"<code>set_opacity(self, layer_id, opacity)</code>","text":"<p>Set layer opacity.</p> <p>Parameters:</p> Name Type Description Default <code>layer_id</code> <code>str</code> <p>Layer identifier.</p> required <code>opacity</code> <code>float</code> <p>Opacity value between 0 and 1.</p> required Source code in <code>anymap_ts/openlayers.py</code> <pre><code>def set_opacity(self, layer_id: str, opacity: float) -&gt; None:\n    \"\"\"Set layer opacity.\n\n    Args:\n        layer_id: Layer identifier.\n        opacity: Opacity value between 0 and 1.\n    \"\"\"\n    self.call_js_method(\"setOpacity\", layer_id, opacity)\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.openlayers.OpenLayersMap.set_visibility","title":"<code>set_visibility(self, layer_id, visible)</code>","text":"<p>Set layer visibility.</p> <p>Parameters:</p> Name Type Description Default <code>layer_id</code> <code>str</code> <p>Layer identifier.</p> required <code>visible</code> <code>bool</code> <p>Whether layer should be visible.</p> required Source code in <code>anymap_ts/openlayers.py</code> <pre><code>def set_visibility(self, layer_id: str, visible: bool) -&gt; None:\n    \"\"\"Set layer visibility.\n\n    Args:\n        layer_id: Layer identifier.\n        visible: Whether layer should be visible.\n    \"\"\"\n    self.call_js_method(\"setVisibility\", layer_id, visible)\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.openlayers.OpenLayersMap.set_zoom","title":"<code>set_zoom(self, zoom)</code>","text":"<p>Set the map zoom level.</p> <p>Parameters:</p> Name Type Description Default <code>zoom</code> <code>float</code> <p>Zoom level.</p> required Source code in <code>anymap_ts/openlayers.py</code> <pre><code>def set_zoom(self, zoom: float) -&gt; None:\n    \"\"\"Set the map zoom level.\n\n    Args:\n        zoom: Zoom level.\n    \"\"\"\n    self.zoom = zoom\n    self.call_js_method(\"setZoom\", zoom)\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.potree","title":"<code>potree</code>","text":"<p>Potree point cloud viewer widget implementation.</p> <p>Potree is loaded via CDN since it's a complex Three.js-based viewer. This implementation provides a Python wrapper for point cloud visualization.</p>"},{"location":"anymap_ts/#anymap_ts.potree.PotreeViewer","title":"<code> PotreeViewer            (MapWidget)         </code>","text":"<p>Interactive point cloud viewer using Potree.</p> <p>Potree is a WebGL-based point cloud renderer for large-scale LiDAR datasets. This class provides a Python interface for loading and visualizing point clouds.</p> <p>Note: Potree is loaded from CDN due to its complex Three.js dependencies.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from anymap_ts import PotreeViewer\n&gt;&gt;&gt; viewer = PotreeViewer()\n&gt;&gt;&gt; viewer.load_point_cloud(\"path/to/pointcloud/cloud.js\")\n&gt;&gt;&gt; viewer\n</code></pre> Source code in <code>anymap_ts/potree.py</code> <pre><code>class PotreeViewer(MapWidget):\n    \"\"\"Interactive point cloud viewer using Potree.\n\n    Potree is a WebGL-based point cloud renderer for large-scale LiDAR\n    datasets. This class provides a Python interface for loading and\n    visualizing point clouds.\n\n    Note: Potree is loaded from CDN due to its complex Three.js dependencies.\n\n    Example:\n        &gt;&gt;&gt; from anymap_ts import PotreeViewer\n        &gt;&gt;&gt; viewer = PotreeViewer()\n        &gt;&gt;&gt; viewer.load_point_cloud(\"path/to/pointcloud/cloud.js\")\n        &gt;&gt;&gt; viewer\n    \"\"\"\n\n    # ESM module for frontend\n    _esm = STATIC_DIR / \"potree.js\"\n\n    # Potree-specific traits\n    point_budget = traitlets.Int(1000000).tag(sync=True)\n    point_size = traitlets.Float(1.0).tag(sync=True)\n    fov = traitlets.Float(60.0).tag(sync=True)\n    background = traitlets.Unicode(\"#000000\").tag(sync=True)\n\n    # EDL (Eye Dome Lighting) settings\n    edl_enabled = traitlets.Bool(True).tag(sync=True)\n    edl_radius = traitlets.Float(1.4).tag(sync=True)\n    edl_strength = traitlets.Float(0.4).tag(sync=True)\n\n    # Point clouds\n    point_clouds = traitlets.Dict({}).tag(sync=True)\n\n    # Camera\n    camera_position = traitlets.List([0, 0, 100]).tag(sync=True)\n    camera_target = traitlets.List([0, 0, 0]).tag(sync=True)\n\n    def __init__(\n        self,\n        width: str = \"100%\",\n        height: str = \"600px\",\n        point_budget: int = 1000000,\n        point_size: float = 1.0,\n        fov: float = 60.0,\n        background: str = \"#000000\",\n        edl_enabled: bool = True,\n        **kwargs,\n    ):\n        \"\"\"Initialize a Potree viewer.\n\n        Args:\n            width: Widget width as CSS string.\n            height: Widget height as CSS string.\n            point_budget: Maximum number of points to render.\n            point_size: Default point size.\n            fov: Field of view in degrees.\n            background: Background color (hex string).\n            edl_enabled: Enable Eye Dome Lighting.\n            **kwargs: Additional widget arguments.\n        \"\"\"\n        # Potree doesn't use center/zoom like maps\n        super().__init__(\n            center=[0, 0],\n            zoom=1,\n            width=width,\n            height=height,\n            point_budget=point_budget,\n            point_size=point_size,\n            fov=fov,\n            background=background,\n            edl_enabled=edl_enabled,\n            **kwargs,\n        )\n        self.point_clouds = {}\n\n    # -------------------------------------------------------------------------\n    # Point Cloud Methods\n    # -------------------------------------------------------------------------\n\n    def load_point_cloud(\n        self,\n        url: str,\n        name: Optional[str] = None,\n        visible: bool = True,\n        point_size: Optional[float] = None,\n        point_size_type: str = \"adaptive\",\n        shape: str = \"circle\",\n        color: Optional[str] = None,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Load a point cloud.\n\n        Args:\n            url: URL to point cloud (Potree format or LAZ/LAS via Entwine).\n            name: Point cloud name.\n            visible: Whether point cloud is visible.\n            point_size: Point size (overrides default).\n            point_size_type: 'fixed', 'attenuated', or 'adaptive'.\n            shape: Point shape ('square', 'circle', 'paraboloid').\n            color: Point color (hex string or None for native colors).\n            **kwargs: Additional material options.\n        \"\"\"\n        cloud_id = name or f\"pointcloud_{len(self.point_clouds)}\"\n\n        self.point_clouds = {\n            **self.point_clouds,\n            cloud_id: {\n                \"url\": url,\n                \"name\": cloud_id,\n                \"visible\": visible,\n                \"material\": {\n                    \"size\": point_size or self.point_size,\n                    \"pointSizeType\": point_size_type,\n                    \"shape\": shape,\n                    \"color\": color,\n                    **kwargs,\n                },\n            },\n        }\n\n        self.call_js_method(\n            \"loadPointCloud\",\n            url=url,\n            name=cloud_id,\n            visible=visible,\n            material={\n                \"size\": point_size or self.point_size,\n                \"pointSizeType\": point_size_type,\n                \"shape\": shape,\n                \"color\": color,\n                **kwargs,\n            },\n        )\n\n    def remove_point_cloud(self, name: str) -&gt; None:\n        \"\"\"Remove a point cloud.\n\n        Args:\n            name: Point cloud name to remove.\n        \"\"\"\n        if name in self.point_clouds:\n            clouds = dict(self.point_clouds)\n            del clouds[name]\n            self.point_clouds = clouds\n        self.call_js_method(\"removePointCloud\", name=name)\n\n    def set_point_cloud_visibility(self, name: str, visible: bool) -&gt; None:\n        \"\"\"Set point cloud visibility.\n\n        Args:\n            name: Point cloud name.\n            visible: Whether to show the point cloud.\n        \"\"\"\n        self.call_js_method(\"setPointCloudVisibility\", name=name, visible=visible)\n\n    # -------------------------------------------------------------------------\n    # Camera Methods\n    # -------------------------------------------------------------------------\n\n    def set_camera_position(\n        self,\n        x: float,\n        y: float,\n        z: float,\n    ) -&gt; None:\n        \"\"\"Set camera position.\n\n        Args:\n            x: X coordinate.\n            y: Y coordinate.\n            z: Z coordinate.\n        \"\"\"\n        self.camera_position = [x, y, z]\n        self.call_js_method(\"setCameraPosition\", x=x, y=y, z=z)\n\n    def set_camera_target(\n        self,\n        x: float,\n        y: float,\n        z: float,\n    ) -&gt; None:\n        \"\"\"Set camera target (look-at point).\n\n        Args:\n            x: X coordinate.\n            y: Y coordinate.\n            z: Z coordinate.\n        \"\"\"\n        self.camera_target = [x, y, z]\n        self.call_js_method(\"setCameraTarget\", x=x, y=y, z=z)\n\n    def fly_to_point_cloud(self, name: Optional[str] = None) -&gt; None:\n        \"\"\"Fly to a point cloud or all point clouds.\n\n        Args:\n            name: Point cloud name (None for all).\n        \"\"\"\n        self.call_js_method(\"flyToPointCloud\", name=name)\n\n    def reset_camera(self) -&gt; None:\n        \"\"\"Reset camera to default view.\"\"\"\n        self.call_js_method(\"resetCamera\")\n\n    # -------------------------------------------------------------------------\n    # Visualization Settings\n    # -------------------------------------------------------------------------\n\n    def set_point_budget(self, budget: int) -&gt; None:\n        \"\"\"Set the point budget (max points to render).\n\n        Args:\n            budget: Maximum number of points.\n        \"\"\"\n        self.point_budget = budget\n        self.call_js_method(\"setPointBudget\", budget=budget)\n\n    def set_point_size(self, size: float) -&gt; None:\n        \"\"\"Set default point size.\n\n        Args:\n            size: Point size.\n        \"\"\"\n        self.point_size = size\n        self.call_js_method(\"setPointSize\", size=size)\n\n    def set_fov(self, fov: float) -&gt; None:\n        \"\"\"Set field of view.\n\n        Args:\n            fov: Field of view in degrees.\n        \"\"\"\n        self.fov = fov\n        self.call_js_method(\"setFOV\", fov=fov)\n\n    def set_background(self, color: str) -&gt; None:\n        \"\"\"Set background color.\n\n        Args:\n            color: Background color (hex string).\n        \"\"\"\n        self.background = color\n        self.call_js_method(\"setBackground\", color=color)\n\n    def set_edl(\n        self,\n        enabled: bool = True,\n        radius: float = 1.4,\n        strength: float = 0.4,\n    ) -&gt; None:\n        \"\"\"Configure Eye Dome Lighting.\n\n        Args:\n            enabled: Whether to enable EDL.\n            radius: EDL radius.\n            strength: EDL strength.\n        \"\"\"\n        self.edl_enabled = enabled\n        self.edl_radius = radius\n        self.edl_strength = strength\n        self.call_js_method(\n            \"setEDL\",\n            enabled=enabled,\n            radius=radius,\n            strength=strength,\n        )\n\n    # -------------------------------------------------------------------------\n    # Measurement Tools\n    # -------------------------------------------------------------------------\n\n    def add_measurement_tool(self, tool_type: str = \"distance\") -&gt; None:\n        \"\"\"Add a measurement tool.\n\n        Args:\n            tool_type: Type of measurement ('point', 'distance', 'area', 'angle', 'height', 'profile').\n        \"\"\"\n        self.call_js_method(\"addMeasurementTool\", type=tool_type)\n\n    def clear_measurements(self) -&gt; None:\n        \"\"\"Clear all measurements.\"\"\"\n        self.call_js_method(\"clearMeasurements\")\n\n    # -------------------------------------------------------------------------\n    # Clipping\n    # -------------------------------------------------------------------------\n\n    def add_clipping_volume(\n        self,\n        volume_type: str = \"box\",\n        position: Optional[Tuple[float, float, float]] = None,\n        scale: Optional[Tuple[float, float, float]] = None,\n    ) -&gt; None:\n        \"\"\"Add a clipping volume.\n\n        Args:\n            volume_type: Type of volume ('box', 'polygon', 'plane').\n            position: Volume position (x, y, z).\n            scale: Volume scale (x, y, z).\n        \"\"\"\n        self.call_js_method(\n            \"addClippingVolume\",\n            type=volume_type,\n            position=list(position) if position else None,\n            scale=list(scale) if scale else None,\n        )\n\n    def clear_clipping_volumes(self) -&gt; None:\n        \"\"\"Clear all clipping volumes.\"\"\"\n        self.call_js_method(\"clearClippingVolumes\")\n\n    # -------------------------------------------------------------------------\n    # Annotations\n    # -------------------------------------------------------------------------\n\n    def add_annotation(\n        self,\n        position: Tuple[float, float, float],\n        title: str,\n        description: str = \"\",\n        camera_position: Optional[Tuple[float, float, float]] = None,\n        camera_target: Optional[Tuple[float, float, float]] = None,\n    ) -&gt; None:\n        \"\"\"Add an annotation.\n\n        Args:\n            position: Annotation position (x, y, z).\n            title: Annotation title.\n            description: Annotation description.\n            camera_position: Camera position when focused.\n            camera_target: Camera target when focused.\n        \"\"\"\n        self.call_js_method(\n            \"addAnnotation\",\n            position=list(position),\n            title=title,\n            description=description,\n            cameraPosition=list(camera_position) if camera_position else None,\n            cameraTarget=list(camera_target) if camera_target else None,\n        )\n\n    def clear_annotations(self) -&gt; None:\n        \"\"\"Clear all annotations.\"\"\"\n        self.call_js_method(\"clearAnnotations\")\n\n    # -------------------------------------------------------------------------\n    # HTML Export\n    # -------------------------------------------------------------------------\n\n    def _generate_html_template(self) -&gt; str:\n        \"\"\"Generate standalone HTML for Potree viewer.\"\"\"\n        template_path = Path(__file__).parent / \"templates\" / \"potree.html\"\n\n        if template_path.exists():\n            template = template_path.read_text(encoding=\"utf-8\")\n        else:\n            template = self._get_default_template()\n\n        state = {\n            \"point_budget\": self.point_budget,\n            \"point_size\": self.point_size,\n            \"fov\": self.fov,\n            \"background\": self.background,\n            \"edl_enabled\": self.edl_enabled,\n            \"edl_radius\": self.edl_radius,\n            \"edl_strength\": self.edl_strength,\n            \"point_clouds\": self.point_clouds,\n            \"camera_position\": self.camera_position,\n            \"camera_target\": self.camera_target,\n            \"width\": self.width,\n            \"height\": self.height,\n            \"js_calls\": self._js_calls,\n        }\n\n        template = template.replace(\"{{state}}\", json.dumps(state, indent=2))\n        return template\n\n    def _get_default_template(self) -&gt; str:\n        \"\"\"Get default HTML template.\"\"\"\n        return \"\"\"&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n    &lt;meta charset=\"utf-8\"&gt;\n    &lt;title&gt;Potree Viewer&lt;/title&gt;\n    &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"&gt;\n    &lt;style&gt;\n        * { margin: 0; padding: 0; box-sizing: border-box; }\n        html, body { height: 100%; overflow: hidden; }\n        #potree_render_area { position: absolute; top: 0; bottom: 0; width: 100%; }\n    &lt;/style&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;div id=\"potree_render_area\"&gt;&lt;/div&gt;\n    &lt;script&gt;\n        const state = {{state}};\n        document.getElementById('potree_render_area').innerHTML = '&lt;p style=\"color: white; padding: 20px;\"&gt;Potree viewer requires Potree library. Point clouds: ' + Object.keys(state.point_clouds || {}).length + '&lt;/p&gt;';\n    &lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\"\"\"\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.potree.PotreeViewer.__init__","title":"<code>__init__(self, width='100%', height='600px', point_budget=1000000, point_size=1.0, fov=60.0, background='#000000', edl_enabled=True, **kwargs)</code>  <code>special</code>","text":"<p>Initialize a Potree viewer.</p> <p>Parameters:</p> Name Type Description Default <code>width</code> <code>str</code> <p>Widget width as CSS string.</p> <code>'100%'</code> <code>height</code> <code>str</code> <p>Widget height as CSS string.</p> <code>'600px'</code> <code>point_budget</code> <code>int</code> <p>Maximum number of points to render.</p> <code>1000000</code> <code>point_size</code> <code>float</code> <p>Default point size.</p> <code>1.0</code> <code>fov</code> <code>float</code> <p>Field of view in degrees.</p> <code>60.0</code> <code>background</code> <code>str</code> <p>Background color (hex string).</p> <code>'#000000'</code> <code>edl_enabled</code> <code>bool</code> <p>Enable Eye Dome Lighting.</p> <code>True</code> <code>**kwargs</code> <p>Additional widget arguments.</p> <code>{}</code> Source code in <code>anymap_ts/potree.py</code> <pre><code>def __init__(\n    self,\n    width: str = \"100%\",\n    height: str = \"600px\",\n    point_budget: int = 1000000,\n    point_size: float = 1.0,\n    fov: float = 60.0,\n    background: str = \"#000000\",\n    edl_enabled: bool = True,\n    **kwargs,\n):\n    \"\"\"Initialize a Potree viewer.\n\n    Args:\n        width: Widget width as CSS string.\n        height: Widget height as CSS string.\n        point_budget: Maximum number of points to render.\n        point_size: Default point size.\n        fov: Field of view in degrees.\n        background: Background color (hex string).\n        edl_enabled: Enable Eye Dome Lighting.\n        **kwargs: Additional widget arguments.\n    \"\"\"\n    # Potree doesn't use center/zoom like maps\n    super().__init__(\n        center=[0, 0],\n        zoom=1,\n        width=width,\n        height=height,\n        point_budget=point_budget,\n        point_size=point_size,\n        fov=fov,\n        background=background,\n        edl_enabled=edl_enabled,\n        **kwargs,\n    )\n    self.point_clouds = {}\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.potree.PotreeViewer.add_annotation","title":"<code>add_annotation(self, position, title, description='', camera_position=None, camera_target=None)</code>","text":"<p>Add an annotation.</p> <p>Parameters:</p> Name Type Description Default <code>position</code> <code>Tuple[float, float, float]</code> <p>Annotation position (x, y, z).</p> required <code>title</code> <code>str</code> <p>Annotation title.</p> required <code>description</code> <code>str</code> <p>Annotation description.</p> <code>''</code> <code>camera_position</code> <code>Optional[Tuple[float, float, float]]</code> <p>Camera position when focused.</p> <code>None</code> <code>camera_target</code> <code>Optional[Tuple[float, float, float]]</code> <p>Camera target when focused.</p> <code>None</code> Source code in <code>anymap_ts/potree.py</code> <pre><code>def add_annotation(\n    self,\n    position: Tuple[float, float, float],\n    title: str,\n    description: str = \"\",\n    camera_position: Optional[Tuple[float, float, float]] = None,\n    camera_target: Optional[Tuple[float, float, float]] = None,\n) -&gt; None:\n    \"\"\"Add an annotation.\n\n    Args:\n        position: Annotation position (x, y, z).\n        title: Annotation title.\n        description: Annotation description.\n        camera_position: Camera position when focused.\n        camera_target: Camera target when focused.\n    \"\"\"\n    self.call_js_method(\n        \"addAnnotation\",\n        position=list(position),\n        title=title,\n        description=description,\n        cameraPosition=list(camera_position) if camera_position else None,\n        cameraTarget=list(camera_target) if camera_target else None,\n    )\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.potree.PotreeViewer.add_clipping_volume","title":"<code>add_clipping_volume(self, volume_type='box', position=None, scale=None)</code>","text":"<p>Add a clipping volume.</p> <p>Parameters:</p> Name Type Description Default <code>volume_type</code> <code>str</code> <p>Type of volume ('box', 'polygon', 'plane').</p> <code>'box'</code> <code>position</code> <code>Optional[Tuple[float, float, float]]</code> <p>Volume position (x, y, z).</p> <code>None</code> <code>scale</code> <code>Optional[Tuple[float, float, float]]</code> <p>Volume scale (x, y, z).</p> <code>None</code> Source code in <code>anymap_ts/potree.py</code> <pre><code>def add_clipping_volume(\n    self,\n    volume_type: str = \"box\",\n    position: Optional[Tuple[float, float, float]] = None,\n    scale: Optional[Tuple[float, float, float]] = None,\n) -&gt; None:\n    \"\"\"Add a clipping volume.\n\n    Args:\n        volume_type: Type of volume ('box', 'polygon', 'plane').\n        position: Volume position (x, y, z).\n        scale: Volume scale (x, y, z).\n    \"\"\"\n    self.call_js_method(\n        \"addClippingVolume\",\n        type=volume_type,\n        position=list(position) if position else None,\n        scale=list(scale) if scale else None,\n    )\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.potree.PotreeViewer.add_measurement_tool","title":"<code>add_measurement_tool(self, tool_type='distance')</code>","text":"<p>Add a measurement tool.</p> <p>Parameters:</p> Name Type Description Default <code>tool_type</code> <code>str</code> <p>Type of measurement ('point', 'distance', 'area', 'angle', 'height', 'profile').</p> <code>'distance'</code> Source code in <code>anymap_ts/potree.py</code> <pre><code>def add_measurement_tool(self, tool_type: str = \"distance\") -&gt; None:\n    \"\"\"Add a measurement tool.\n\n    Args:\n        tool_type: Type of measurement ('point', 'distance', 'area', 'angle', 'height', 'profile').\n    \"\"\"\n    self.call_js_method(\"addMeasurementTool\", type=tool_type)\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.potree.PotreeViewer.clear_annotations","title":"<code>clear_annotations(self)</code>","text":"<p>Clear all annotations.</p> Source code in <code>anymap_ts/potree.py</code> <pre><code>def clear_annotations(self) -&gt; None:\n    \"\"\"Clear all annotations.\"\"\"\n    self.call_js_method(\"clearAnnotations\")\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.potree.PotreeViewer.clear_clipping_volumes","title":"<code>clear_clipping_volumes(self)</code>","text":"<p>Clear all clipping volumes.</p> Source code in <code>anymap_ts/potree.py</code> <pre><code>def clear_clipping_volumes(self) -&gt; None:\n    \"\"\"Clear all clipping volumes.\"\"\"\n    self.call_js_method(\"clearClippingVolumes\")\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.potree.PotreeViewer.clear_measurements","title":"<code>clear_measurements(self)</code>","text":"<p>Clear all measurements.</p> Source code in <code>anymap_ts/potree.py</code> <pre><code>def clear_measurements(self) -&gt; None:\n    \"\"\"Clear all measurements.\"\"\"\n    self.call_js_method(\"clearMeasurements\")\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.potree.PotreeViewer.fly_to_point_cloud","title":"<code>fly_to_point_cloud(self, name=None)</code>","text":"<p>Fly to a point cloud or all point clouds.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>Optional[str]</code> <p>Point cloud name (None for all).</p> <code>None</code> Source code in <code>anymap_ts/potree.py</code> <pre><code>def fly_to_point_cloud(self, name: Optional[str] = None) -&gt; None:\n    \"\"\"Fly to a point cloud or all point clouds.\n\n    Args:\n        name: Point cloud name (None for all).\n    \"\"\"\n    self.call_js_method(\"flyToPointCloud\", name=name)\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.potree.PotreeViewer.load_point_cloud","title":"<code>load_point_cloud(self, url, name=None, visible=True, point_size=None, point_size_type='adaptive', shape='circle', color=None, **kwargs)</code>","text":"<p>Load a point cloud.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>URL to point cloud (Potree format or LAZ/LAS via Entwine).</p> required <code>name</code> <code>Optional[str]</code> <p>Point cloud name.</p> <code>None</code> <code>visible</code> <code>bool</code> <p>Whether point cloud is visible.</p> <code>True</code> <code>point_size</code> <code>Optional[float]</code> <p>Point size (overrides default).</p> <code>None</code> <code>point_size_type</code> <code>str</code> <p>'fixed', 'attenuated', or 'adaptive'.</p> <code>'adaptive'</code> <code>shape</code> <code>str</code> <p>Point shape ('square', 'circle', 'paraboloid').</p> <code>'circle'</code> <code>color</code> <code>Optional[str]</code> <p>Point color (hex string or None for native colors).</p> <code>None</code> <code>**kwargs</code> <p>Additional material options.</p> <code>{}</code> Source code in <code>anymap_ts/potree.py</code> <pre><code>def load_point_cloud(\n    self,\n    url: str,\n    name: Optional[str] = None,\n    visible: bool = True,\n    point_size: Optional[float] = None,\n    point_size_type: str = \"adaptive\",\n    shape: str = \"circle\",\n    color: Optional[str] = None,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Load a point cloud.\n\n    Args:\n        url: URL to point cloud (Potree format or LAZ/LAS via Entwine).\n        name: Point cloud name.\n        visible: Whether point cloud is visible.\n        point_size: Point size (overrides default).\n        point_size_type: 'fixed', 'attenuated', or 'adaptive'.\n        shape: Point shape ('square', 'circle', 'paraboloid').\n        color: Point color (hex string or None for native colors).\n        **kwargs: Additional material options.\n    \"\"\"\n    cloud_id = name or f\"pointcloud_{len(self.point_clouds)}\"\n\n    self.point_clouds = {\n        **self.point_clouds,\n        cloud_id: {\n            \"url\": url,\n            \"name\": cloud_id,\n            \"visible\": visible,\n            \"material\": {\n                \"size\": point_size or self.point_size,\n                \"pointSizeType\": point_size_type,\n                \"shape\": shape,\n                \"color\": color,\n                **kwargs,\n            },\n        },\n    }\n\n    self.call_js_method(\n        \"loadPointCloud\",\n        url=url,\n        name=cloud_id,\n        visible=visible,\n        material={\n            \"size\": point_size or self.point_size,\n            \"pointSizeType\": point_size_type,\n            \"shape\": shape,\n            \"color\": color,\n            **kwargs,\n        },\n    )\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.potree.PotreeViewer.remove_point_cloud","title":"<code>remove_point_cloud(self, name)</code>","text":"<p>Remove a point cloud.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Point cloud name to remove.</p> required Source code in <code>anymap_ts/potree.py</code> <pre><code>def remove_point_cloud(self, name: str) -&gt; None:\n    \"\"\"Remove a point cloud.\n\n    Args:\n        name: Point cloud name to remove.\n    \"\"\"\n    if name in self.point_clouds:\n        clouds = dict(self.point_clouds)\n        del clouds[name]\n        self.point_clouds = clouds\n    self.call_js_method(\"removePointCloud\", name=name)\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.potree.PotreeViewer.reset_camera","title":"<code>reset_camera(self)</code>","text":"<p>Reset camera to default view.</p> Source code in <code>anymap_ts/potree.py</code> <pre><code>def reset_camera(self) -&gt; None:\n    \"\"\"Reset camera to default view.\"\"\"\n    self.call_js_method(\"resetCamera\")\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.potree.PotreeViewer.set_background","title":"<code>set_background(self, color)</code>","text":"<p>Set background color.</p> <p>Parameters:</p> Name Type Description Default <code>color</code> <code>str</code> <p>Background color (hex string).</p> required Source code in <code>anymap_ts/potree.py</code> <pre><code>def set_background(self, color: str) -&gt; None:\n    \"\"\"Set background color.\n\n    Args:\n        color: Background color (hex string).\n    \"\"\"\n    self.background = color\n    self.call_js_method(\"setBackground\", color=color)\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.potree.PotreeViewer.set_camera_position","title":"<code>set_camera_position(self, x, y, z)</code>","text":"<p>Set camera position.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>float</code> <p>X coordinate.</p> required <code>y</code> <code>float</code> <p>Y coordinate.</p> required <code>z</code> <code>float</code> <p>Z coordinate.</p> required Source code in <code>anymap_ts/potree.py</code> <pre><code>def set_camera_position(\n    self,\n    x: float,\n    y: float,\n    z: float,\n) -&gt; None:\n    \"\"\"Set camera position.\n\n    Args:\n        x: X coordinate.\n        y: Y coordinate.\n        z: Z coordinate.\n    \"\"\"\n    self.camera_position = [x, y, z]\n    self.call_js_method(\"setCameraPosition\", x=x, y=y, z=z)\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.potree.PotreeViewer.set_camera_target","title":"<code>set_camera_target(self, x, y, z)</code>","text":"<p>Set camera target (look-at point).</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>float</code> <p>X coordinate.</p> required <code>y</code> <code>float</code> <p>Y coordinate.</p> required <code>z</code> <code>float</code> <p>Z coordinate.</p> required Source code in <code>anymap_ts/potree.py</code> <pre><code>def set_camera_target(\n    self,\n    x: float,\n    y: float,\n    z: float,\n) -&gt; None:\n    \"\"\"Set camera target (look-at point).\n\n    Args:\n        x: X coordinate.\n        y: Y coordinate.\n        z: Z coordinate.\n    \"\"\"\n    self.camera_target = [x, y, z]\n    self.call_js_method(\"setCameraTarget\", x=x, y=y, z=z)\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.potree.PotreeViewer.set_edl","title":"<code>set_edl(self, enabled=True, radius=1.4, strength=0.4)</code>","text":"<p>Configure Eye Dome Lighting.</p> <p>Parameters:</p> Name Type Description Default <code>enabled</code> <code>bool</code> <p>Whether to enable EDL.</p> <code>True</code> <code>radius</code> <code>float</code> <p>EDL radius.</p> <code>1.4</code> <code>strength</code> <code>float</code> <p>EDL strength.</p> <code>0.4</code> Source code in <code>anymap_ts/potree.py</code> <pre><code>def set_edl(\n    self,\n    enabled: bool = True,\n    radius: float = 1.4,\n    strength: float = 0.4,\n) -&gt; None:\n    \"\"\"Configure Eye Dome Lighting.\n\n    Args:\n        enabled: Whether to enable EDL.\n        radius: EDL radius.\n        strength: EDL strength.\n    \"\"\"\n    self.edl_enabled = enabled\n    self.edl_radius = radius\n    self.edl_strength = strength\n    self.call_js_method(\n        \"setEDL\",\n        enabled=enabled,\n        radius=radius,\n        strength=strength,\n    )\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.potree.PotreeViewer.set_fov","title":"<code>set_fov(self, fov)</code>","text":"<p>Set field of view.</p> <p>Parameters:</p> Name Type Description Default <code>fov</code> <code>float</code> <p>Field of view in degrees.</p> required Source code in <code>anymap_ts/potree.py</code> <pre><code>def set_fov(self, fov: float) -&gt; None:\n    \"\"\"Set field of view.\n\n    Args:\n        fov: Field of view in degrees.\n    \"\"\"\n    self.fov = fov\n    self.call_js_method(\"setFOV\", fov=fov)\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.potree.PotreeViewer.set_point_budget","title":"<code>set_point_budget(self, budget)</code>","text":"<p>Set the point budget (max points to render).</p> <p>Parameters:</p> Name Type Description Default <code>budget</code> <code>int</code> <p>Maximum number of points.</p> required Source code in <code>anymap_ts/potree.py</code> <pre><code>def set_point_budget(self, budget: int) -&gt; None:\n    \"\"\"Set the point budget (max points to render).\n\n    Args:\n        budget: Maximum number of points.\n    \"\"\"\n    self.point_budget = budget\n    self.call_js_method(\"setPointBudget\", budget=budget)\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.potree.PotreeViewer.set_point_cloud_visibility","title":"<code>set_point_cloud_visibility(self, name, visible)</code>","text":"<p>Set point cloud visibility.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Point cloud name.</p> required <code>visible</code> <code>bool</code> <p>Whether to show the point cloud.</p> required Source code in <code>anymap_ts/potree.py</code> <pre><code>def set_point_cloud_visibility(self, name: str, visible: bool) -&gt; None:\n    \"\"\"Set point cloud visibility.\n\n    Args:\n        name: Point cloud name.\n        visible: Whether to show the point cloud.\n    \"\"\"\n    self.call_js_method(\"setPointCloudVisibility\", name=name, visible=visible)\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.potree.PotreeViewer.set_point_size","title":"<code>set_point_size(self, size)</code>","text":"<p>Set default point size.</p> <p>Parameters:</p> Name Type Description Default <code>size</code> <code>float</code> <p>Point size.</p> required Source code in <code>anymap_ts/potree.py</code> <pre><code>def set_point_size(self, size: float) -&gt; None:\n    \"\"\"Set default point size.\n\n    Args:\n        size: Point size.\n    \"\"\"\n    self.point_size = size\n    self.call_js_method(\"setPointSize\", size=size)\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.utils","title":"<code>utils</code>","text":"<p>Utility functions for anymap-ts.</p>"},{"location":"anymap_ts/#anymap_ts.utils.get_bounds","title":"<code>get_bounds(data)</code>","text":"<p>Calculate bounds from GeoJSON or GeoDataFrame.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>GeoJSON dict or GeoDataFrame</p> required <p>Returns:</p> Type Description <code>Optional[List[float]]</code> <p>[west, south, east, north] bounds or None</p> Source code in <code>anymap_ts/utils.py</code> <pre><code>def get_bounds(data: Any) -&gt; Optional[List[float]]:\n    \"\"\"Calculate bounds from GeoJSON or GeoDataFrame.\n\n    Args:\n        data: GeoJSON dict or GeoDataFrame\n\n    Returns:\n        [west, south, east, north] bounds or None\n    \"\"\"\n    if HAS_GEOPANDAS and isinstance(data, gpd.GeoDataFrame):\n        bounds = data.total_bounds\n        return [bounds[0], bounds[1], bounds[2], bounds[3]]\n\n    if isinstance(data, dict):\n        if HAS_SHAPELY:\n            return _get_geojson_bounds_shapely(data)\n        return _get_geojson_bounds_simple(data)\n\n    return None\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.utils.get_default_paint","title":"<code>get_default_paint(layer_type)</code>","text":"<p>Get default paint properties for a layer type.</p> <p>Parameters:</p> Name Type Description Default <code>layer_type</code> <code>str</code> <p>MapLibre layer type</p> required <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Paint properties dict</p> Source code in <code>anymap_ts/utils.py</code> <pre><code>def get_default_paint(layer_type: str) -&gt; Dict[str, Any]:\n    \"\"\"Get default paint properties for a layer type.\n\n    Args:\n        layer_type: MapLibre layer type\n\n    Returns:\n        Paint properties dict\n    \"\"\"\n    defaults = {\n        \"circle\": {\n            \"circle-radius\": 5,\n            \"circle-color\": \"#3388ff\",\n            \"circle-opacity\": 0.8,\n            \"circle-stroke-width\": 1,\n            \"circle-stroke-color\": \"#ffffff\",\n        },\n        \"line\": {\n            \"line-color\": \"#3388ff\",\n            \"line-width\": 2,\n            \"line-opacity\": 0.8,\n        },\n        \"fill\": {\n            \"fill-color\": \"#3388ff\",\n            \"fill-opacity\": 0.5,\n            \"fill-outline-color\": \"#0000ff\",\n        },\n        \"fill-extrusion\": {\n            \"fill-extrusion-color\": \"#3388ff\",\n            \"fill-extrusion-opacity\": 0.6,\n            \"fill-extrusion-height\": 100,\n        },\n        \"raster\": {\n            \"raster-opacity\": 1,\n        },\n        \"heatmap\": {\n            \"heatmap-opacity\": 0.8,\n        },\n    }\n    return defaults.get(layer_type, {})\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.utils.infer_layer_type","title":"<code>infer_layer_type(geojson)</code>","text":"<p>Infer MapLibre layer type from GeoJSON geometry.</p> <p>Parameters:</p> Name Type Description Default <code>geojson</code> <code>Dict</code> <p>GeoJSON dict</p> required <p>Returns:</p> Type Description <code>str</code> <p>Layer type ('circle', 'line', 'fill')</p> Source code in <code>anymap_ts/utils.py</code> <pre><code>def infer_layer_type(geojson: Dict) -&gt; str:\n    \"\"\"Infer MapLibre layer type from GeoJSON geometry.\n\n    Args:\n        geojson: GeoJSON dict\n\n    Returns:\n        Layer type ('circle', 'line', 'fill')\n    \"\"\"\n    geometry_type = None\n\n    if geojson.get(\"type\") == \"FeatureCollection\":\n        features = geojson.get(\"features\", [])\n        if features:\n            geometry_type = features[0].get(\"geometry\", {}).get(\"type\")\n    elif geojson.get(\"type\") == \"Feature\":\n        geometry_type = geojson.get(\"geometry\", {}).get(\"type\")\n    else:\n        geometry_type = geojson.get(\"type\")\n\n    type_map = {\n        \"Point\": \"circle\",\n        \"MultiPoint\": \"circle\",\n        \"LineString\": \"line\",\n        \"MultiLineString\": \"line\",\n        \"Polygon\": \"fill\",\n        \"MultiPolygon\": \"fill\",\n        \"GeometryCollection\": \"fill\",\n    }\n\n    return type_map.get(geometry_type, \"circle\")\n</code></pre>"},{"location":"anymap_ts/#anymap_ts.utils.to_geojson","title":"<code>to_geojson(data)</code>","text":"<p>Convert various data formats to GeoJSON.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>GeoJSON dict, GeoDataFrame, file path, or URL</p> required <p>Returns:</p> Type Description <code>Dict</code> <p>GeoJSON dict</p> <p>Exceptions:</p> Type Description <code>ValueError</code> <p>If data cannot be converted</p> <code>ImportError</code> <p>If geopandas is required but not installed</p> Source code in <code>anymap_ts/utils.py</code> <pre><code>def to_geojson(data: Any) -&gt; Dict:\n    \"\"\"Convert various data formats to GeoJSON.\n\n    Args:\n        data: GeoJSON dict, GeoDataFrame, file path, or URL\n\n    Returns:\n        GeoJSON dict\n\n    Raises:\n        ValueError: If data cannot be converted\n        ImportError: If geopandas is required but not installed\n    \"\"\"\n    # Already a dict (GeoJSON)\n    if isinstance(data, dict):\n        return data\n\n    # GeoDataFrame\n    if HAS_GEOPANDAS and isinstance(data, gpd.GeoDataFrame):\n        return json.loads(data.to_json())\n\n    # File path or URL\n    if isinstance(data, (str, Path)):\n        path_str = str(data)\n\n        # If it's a URL, return as-is (will be handled by JS)\n        if path_str.startswith((\"http://\", \"https://\")):\n            return {\"type\": \"url\", \"url\": path_str}\n\n        # Read file with geopandas\n        if not HAS_GEOPANDAS:\n            raise ImportError(\n                \"geopandas is required to read vector files. \"\n                \"Install with: pip install anymap-ts[vector]\"\n            )\n\n        gdf = gpd.read_file(path_str)\n        return json.loads(gdf.to_json())\n\n    # Has __geo_interface__ (shapely geometry, etc.)\n    if hasattr(data, \"__geo_interface__\"):\n        geo = data.__geo_interface__\n        if geo.get(\"type\") in (\n            \"Point\",\n            \"LineString\",\n            \"Polygon\",\n            \"MultiPoint\",\n            \"MultiLineString\",\n            \"MultiPolygon\",\n            \"GeometryCollection\",\n        ):\n            return {\"type\": \"Feature\", \"geometry\": geo, \"properties\": {}}\n        return geo\n\n    raise ValueError(f\"Cannot convert {type(data)} to GeoJSON\")\n</code></pre>"},{"location":"base/","title":"base module","text":"<p>Base MapWidget class for all map implementations.</p>"},{"location":"base/#anymap_ts.base.MapWidget","title":"<code> MapWidget            (AnyWidget)         </code>","text":"<p>Base class for interactive map widgets.</p> <p>This class provides the core functionality for Python-JavaScript communication using anywidget's traitlet synchronization system.</p> Source code in <code>anymap_ts/base.py</code> <pre><code>class MapWidget(anywidget.AnyWidget):\n    \"\"\"Base class for interactive map widgets.\n\n    This class provides the core functionality for Python-JavaScript communication\n    using anywidget's traitlet synchronization system.\n    \"\"\"\n\n    # Synchronized traits for map state\n    center = traitlets.List([0.0, 0.0]).tag(sync=True)\n    zoom = traitlets.Float(2.0).tag(sync=True)\n    width = traitlets.Unicode(\"100%\").tag(sync=True)\n    height = traitlets.Unicode(\"400px\").tag(sync=True)\n    style = traitlets.Union([traitlets.Unicode(), traitlets.Dict()]).tag(sync=True)\n    max_pitch = traitlets.Float(85.0).tag(sync=True)\n\n    # JavaScript method call queue\n    _js_calls = traitlets.List([]).tag(sync=True)\n    _js_method_counter = traitlets.Int(0)\n\n    # Events from JavaScript\n    _js_events = traitlets.List([]).tag(sync=True)\n\n    # State persistence for layers, sources, and controls\n    _layers = traitlets.Dict({}).tag(sync=True)\n    _sources = traitlets.Dict({}).tag(sync=True)\n    _controls = traitlets.Dict({}).tag(sync=True)\n\n    # Interaction state\n    clicked = traitlets.Dict({}).tag(sync=True)\n    current_bounds = traitlets.List([]).tag(sync=True)\n    current_center = traitlets.List([]).tag(sync=True)\n    current_zoom = traitlets.Float(0.0).tag(sync=True)\n\n    # Drawing data\n    _draw_data = traitlets.Dict({}).tag(sync=True)\n\n    def __init__(self, **kwargs):\n        \"\"\"Initialize the MapWidget.\n\n        Args:\n            **kwargs: Additional widget arguments\n        \"\"\"\n        super().__init__(**kwargs)\n        self._event_handlers: Dict[str, List[Callable]] = {}\n        self.observe(self._handle_js_events, names=[\"_js_events\"])\n\n    def _handle_js_events(self, change: Dict[str, Any]) -&gt; None:\n        \"\"\"Process events received from JavaScript.\n\n        Args:\n            change: Traitlet change dict\n        \"\"\"\n        events = change.get(\"new\", [])\n        for event in events:\n            event_type = event.get(\"type\")\n            if event_type in self._event_handlers:\n                for handler in self._event_handlers[event_type]:\n                    try:\n                        handler(event.get(\"data\"))\n                    except Exception as e:\n                        print(f\"Error in event handler for {event_type}: {e}\")\n        # Clear processed events\n        self._js_events = []\n\n    def call_js_method(self, method: str, *args, **kwargs) -&gt; None:\n        \"\"\"Queue a JavaScript method call.\n\n        Args:\n            method: Name of the JavaScript method to call\n            *args: Positional arguments for the method\n            **kwargs: Keyword arguments for the method\n        \"\"\"\n        self._js_method_counter += 1\n        call = {\n            \"id\": self._js_method_counter,\n            \"method\": method,\n            \"args\": list(args),\n            \"kwargs\": kwargs,\n        }\n        self._js_calls = self._js_calls + [call]\n\n    def on_map_event(self, event_type: str, handler: Callable) -&gt; None:\n        \"\"\"Register an event handler.\n\n        Args:\n            event_type: Type of event (e.g., 'click', 'moveend')\n            handler: Callback function to handle the event\n        \"\"\"\n        if event_type not in self._event_handlers:\n            self._event_handlers[event_type] = []\n        self._event_handlers[event_type].append(handler)\n\n    def off_map_event(\n        self, event_type: str, handler: Optional[Callable] = None\n    ) -&gt; None:\n        \"\"\"Unregister an event handler.\n\n        Args:\n            event_type: Type of event\n            handler: Specific handler to remove. If None, removes all handlers.\n        \"\"\"\n        if event_type in self._event_handlers:\n            if handler is None:\n                del self._event_handlers[event_type]\n            else:\n                self._event_handlers[event_type] = [\n                    h for h in self._event_handlers[event_type] if h != handler\n                ]\n\n    def set_center(self, lng: float, lat: float) -&gt; None:\n        \"\"\"Set the map center.\n\n        Args:\n            lng: Longitude\n            lat: Latitude\n        \"\"\"\n        self.center = [lng, lat]\n\n    def set_zoom(self, zoom: float) -&gt; None:\n        \"\"\"Set the map zoom level.\n\n        Args:\n            zoom: Zoom level\n        \"\"\"\n        self.zoom = zoom\n\n    def fly_to(\n        self,\n        lng: float,\n        lat: float,\n        zoom: Optional[float] = None,\n        duration: int = 2000,\n    ) -&gt; None:\n        \"\"\"Fly to a location with animation.\n\n        Args:\n            lng: Longitude\n            lat: Latitude\n            zoom: Optional zoom level\n            duration: Animation duration in milliseconds\n        \"\"\"\n        self.call_js_method(\"flyTo\", lng, lat, zoom=zoom, duration=duration)\n\n    def fit_bounds(\n        self,\n        bounds: List[float],\n        padding: int = 50,\n        duration: int = 1000,\n    ) -&gt; None:\n        \"\"\"Fit the map to the given bounds.\n\n        Args:\n            bounds: [west, south, east, north] bounds\n            padding: Padding in pixels\n            duration: Animation duration in milliseconds\n        \"\"\"\n        self.call_js_method(\"fitBounds\", bounds, padding=padding, duration=duration)\n\n    @property\n    def viewstate(self) -&gt; Dict[str, Any]:\n        \"\"\"Get current view state.\"\"\"\n        return {\n            \"center\": self.current_center or self.center,\n            \"zoom\": self.current_zoom or self.zoom,\n            \"bounds\": self.current_bounds,\n        }\n\n    def _generate_html_template(self) -&gt; str:\n        \"\"\"Generate HTML template for standalone export.\n\n        Override in subclasses for library-specific templates.\n        \"\"\"\n        raise NotImplementedError(\"Subclasses must implement _generate_html_template\")\n\n    def to_html(\n        self,\n        filepath: Optional[Union[str, Path]] = None,\n        title: str = \"Interactive Map\",\n    ) -&gt; Optional[str]:\n        \"\"\"Export map to standalone HTML file.\n\n        Args:\n            filepath: Path to save the HTML file. If None, returns HTML string.\n            title: Title for the HTML page.\n\n        Returns:\n            HTML string if filepath is None, otherwise None.\n        \"\"\"\n        html = self._generate_html_template()\n        html = html.replace(\"{{title}}\", title)\n\n        if filepath:\n            Path(filepath).write_text(html, encoding=\"utf-8\")\n            return None\n        return html\n</code></pre>"},{"location":"base/#anymap_ts.base.MapWidget.viewstate","title":"<code>viewstate: Dict[str, Any]</code>  <code>property</code> <code>readonly</code>","text":"<p>Get current view state.</p>"},{"location":"base/#anymap_ts.base.MapWidget.__init__","title":"<code>__init__(self, **kwargs)</code>  <code>special</code>","text":"<p>Initialize the MapWidget.</p> <p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <p>Additional widget arguments</p> <code>{}</code> Source code in <code>anymap_ts/base.py</code> <pre><code>def __init__(self, **kwargs):\n    \"\"\"Initialize the MapWidget.\n\n    Args:\n        **kwargs: Additional widget arguments\n    \"\"\"\n    super().__init__(**kwargs)\n    self._event_handlers: Dict[str, List[Callable]] = {}\n    self.observe(self._handle_js_events, names=[\"_js_events\"])\n</code></pre>"},{"location":"base/#anymap_ts.base.MapWidget.call_js_method","title":"<code>call_js_method(self, method, *args, **kwargs)</code>","text":"<p>Queue a JavaScript method call.</p> <p>Parameters:</p> Name Type Description Default <code>method</code> <code>str</code> <p>Name of the JavaScript method to call</p> required <code>*args</code> <p>Positional arguments for the method</p> <code>()</code> <code>**kwargs</code> <p>Keyword arguments for the method</p> <code>{}</code> Source code in <code>anymap_ts/base.py</code> <pre><code>def call_js_method(self, method: str, *args, **kwargs) -&gt; None:\n    \"\"\"Queue a JavaScript method call.\n\n    Args:\n        method: Name of the JavaScript method to call\n        *args: Positional arguments for the method\n        **kwargs: Keyword arguments for the method\n    \"\"\"\n    self._js_method_counter += 1\n    call = {\n        \"id\": self._js_method_counter,\n        \"method\": method,\n        \"args\": list(args),\n        \"kwargs\": kwargs,\n    }\n    self._js_calls = self._js_calls + [call]\n</code></pre>"},{"location":"base/#anymap_ts.base.MapWidget.fit_bounds","title":"<code>fit_bounds(self, bounds, padding=50, duration=1000)</code>","text":"<p>Fit the map to the given bounds.</p> <p>Parameters:</p> Name Type Description Default <code>bounds</code> <code>List[float]</code> <p>[west, south, east, north] bounds</p> required <code>padding</code> <code>int</code> <p>Padding in pixels</p> <code>50</code> <code>duration</code> <code>int</code> <p>Animation duration in milliseconds</p> <code>1000</code> Source code in <code>anymap_ts/base.py</code> <pre><code>def fit_bounds(\n    self,\n    bounds: List[float],\n    padding: int = 50,\n    duration: int = 1000,\n) -&gt; None:\n    \"\"\"Fit the map to the given bounds.\n\n    Args:\n        bounds: [west, south, east, north] bounds\n        padding: Padding in pixels\n        duration: Animation duration in milliseconds\n    \"\"\"\n    self.call_js_method(\"fitBounds\", bounds, padding=padding, duration=duration)\n</code></pre>"},{"location":"base/#anymap_ts.base.MapWidget.fly_to","title":"<code>fly_to(self, lng, lat, zoom=None, duration=2000)</code>","text":"<p>Fly to a location with animation.</p> <p>Parameters:</p> Name Type Description Default <code>lng</code> <code>float</code> <p>Longitude</p> required <code>lat</code> <code>float</code> <p>Latitude</p> required <code>zoom</code> <code>Optional[float]</code> <p>Optional zoom level</p> <code>None</code> <code>duration</code> <code>int</code> <p>Animation duration in milliseconds</p> <code>2000</code> Source code in <code>anymap_ts/base.py</code> <pre><code>def fly_to(\n    self,\n    lng: float,\n    lat: float,\n    zoom: Optional[float] = None,\n    duration: int = 2000,\n) -&gt; None:\n    \"\"\"Fly to a location with animation.\n\n    Args:\n        lng: Longitude\n        lat: Latitude\n        zoom: Optional zoom level\n        duration: Animation duration in milliseconds\n    \"\"\"\n    self.call_js_method(\"flyTo\", lng, lat, zoom=zoom, duration=duration)\n</code></pre>"},{"location":"base/#anymap_ts.base.MapWidget.off_map_event","title":"<code>off_map_event(self, event_type, handler=None)</code>","text":"<p>Unregister an event handler.</p> <p>Parameters:</p> Name Type Description Default <code>event_type</code> <code>str</code> <p>Type of event</p> required <code>handler</code> <code>Optional[Callable]</code> <p>Specific handler to remove. If None, removes all handlers.</p> <code>None</code> Source code in <code>anymap_ts/base.py</code> <pre><code>def off_map_event(\n    self, event_type: str, handler: Optional[Callable] = None\n) -&gt; None:\n    \"\"\"Unregister an event handler.\n\n    Args:\n        event_type: Type of event\n        handler: Specific handler to remove. If None, removes all handlers.\n    \"\"\"\n    if event_type in self._event_handlers:\n        if handler is None:\n            del self._event_handlers[event_type]\n        else:\n            self._event_handlers[event_type] = [\n                h for h in self._event_handlers[event_type] if h != handler\n            ]\n</code></pre>"},{"location":"base/#anymap_ts.base.MapWidget.on_map_event","title":"<code>on_map_event(self, event_type, handler)</code>","text":"<p>Register an event handler.</p> <p>Parameters:</p> Name Type Description Default <code>event_type</code> <code>str</code> <p>Type of event (e.g., 'click', 'moveend')</p> required <code>handler</code> <code>Callable</code> <p>Callback function to handle the event</p> required Source code in <code>anymap_ts/base.py</code> <pre><code>def on_map_event(self, event_type: str, handler: Callable) -&gt; None:\n    \"\"\"Register an event handler.\n\n    Args:\n        event_type: Type of event (e.g., 'click', 'moveend')\n        handler: Callback function to handle the event\n    \"\"\"\n    if event_type not in self._event_handlers:\n        self._event_handlers[event_type] = []\n    self._event_handlers[event_type].append(handler)\n</code></pre>"},{"location":"base/#anymap_ts.base.MapWidget.set_center","title":"<code>set_center(self, lng, lat)</code>","text":"<p>Set the map center.</p> <p>Parameters:</p> Name Type Description Default <code>lng</code> <code>float</code> <p>Longitude</p> required <code>lat</code> <code>float</code> <p>Latitude</p> required Source code in <code>anymap_ts/base.py</code> <pre><code>def set_center(self, lng: float, lat: float) -&gt; None:\n    \"\"\"Set the map center.\n\n    Args:\n        lng: Longitude\n        lat: Latitude\n    \"\"\"\n    self.center = [lng, lat]\n</code></pre>"},{"location":"base/#anymap_ts.base.MapWidget.set_zoom","title":"<code>set_zoom(self, zoom)</code>","text":"<p>Set the map zoom level.</p> <p>Parameters:</p> Name Type Description Default <code>zoom</code> <code>float</code> <p>Zoom level</p> required Source code in <code>anymap_ts/base.py</code> <pre><code>def set_zoom(self, zoom: float) -&gt; None:\n    \"\"\"Set the map zoom level.\n\n    Args:\n        zoom: Zoom level\n    \"\"\"\n    self.zoom = zoom\n</code></pre>"},{"location":"base/#anymap_ts.base.MapWidget.to_html","title":"<code>to_html(self, filepath=None, title='Interactive Map')</code>","text":"<p>Export map to standalone HTML file.</p> <p>Parameters:</p> Name Type Description Default <code>filepath</code> <code>Optional[Union[str, Path]]</code> <p>Path to save the HTML file. If None, returns HTML string.</p> <code>None</code> <code>title</code> <code>str</code> <p>Title for the HTML page.</p> <code>'Interactive Map'</code> <p>Returns:</p> Type Description <code>Optional[str]</code> <p>HTML string if filepath is None, otherwise None.</p> Source code in <code>anymap_ts/base.py</code> <pre><code>def to_html(\n    self,\n    filepath: Optional[Union[str, Path]] = None,\n    title: str = \"Interactive Map\",\n) -&gt; Optional[str]:\n    \"\"\"Export map to standalone HTML file.\n\n    Args:\n        filepath: Path to save the HTML file. If None, returns HTML string.\n        title: Title for the HTML page.\n\n    Returns:\n        HTML string if filepath is None, otherwise None.\n    \"\"\"\n    html = self._generate_html_template()\n    html = html.replace(\"{{title}}\", title)\n\n    if filepath:\n        Path(filepath).write_text(html, encoding=\"utf-8\")\n        return None\n    return html\n</code></pre>"},{"location":"basemaps/","title":"basemaps module","text":"<p>Basemap provider utilities.</p>"},{"location":"basemaps/#anymap_ts.basemaps.get_basemap_names","title":"<code>get_basemap_names()</code>","text":"<p>Get list of available basemap names.</p> <p>Returns:</p> Type Description <code>list</code> <p>List of basemap provider names</p> Source code in <code>anymap_ts/basemaps.py</code> <pre><code>def get_basemap_names() -&gt; list:\n    \"\"\"Get list of available basemap names.\n\n    Returns:\n        List of basemap provider names\n    \"\"\"\n    return list(xyz.flatten().keys())\n</code></pre>"},{"location":"basemaps/#anymap_ts.basemaps.get_basemap_url","title":"<code>get_basemap_url(name)</code>","text":"<p>Get tile URL and attribution for a named basemap.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Basemap provider name (e.g., \"OpenStreetMap\", \"CartoDB.Positron\")</p> required <p>Returns:</p> Type Description <code>Tuple[str, str]</code> <p>Tuple of (tile_url, attribution)</p> <p>Exceptions:</p> Type Description <code>ValueError</code> <p>If basemap name is not found</p> Source code in <code>anymap_ts/basemaps.py</code> <pre><code>def get_basemap_url(name: str) -&gt; Tuple[str, str]:\n    \"\"\"Get tile URL and attribution for a named basemap.\n\n    Args:\n        name: Basemap provider name (e.g., \"OpenStreetMap\", \"CartoDB.Positron\")\n\n    Returns:\n        Tuple of (tile_url, attribution)\n\n    Raises:\n        ValueError: If basemap name is not found\n    \"\"\"\n    # Handle shortcuts\n    if name in BASEMAP_SHORTCUTS:\n        name = BASEMAP_SHORTCUTS[name]\n\n    # Handle dot notation for nested providers\n    parts = name.split(\".\")\n    provider = xyz\n    for part in parts:\n        provider = getattr(provider, part, None)\n        if provider is None:\n            raise ValueError(f\"Unknown basemap: {name}\")\n\n    url = provider.build_url()\n    attribution = provider.get(\"attribution\", \"\")\n\n    return url, attribution\n</code></pre>"},{"location":"basemaps/#anymap_ts.basemaps.get_maplibre_style","title":"<code>get_maplibre_style(name)</code>","text":"<p>Get MapLibre style URL by name.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Style name (e.g., \"positron\", \"dark-matter\")</p> required <p>Returns:</p> Type Description <code>str</code> <p>Style URL</p> <p>Exceptions:</p> Type Description <code>ValueError</code> <p>If style name is not found</p> Source code in <code>anymap_ts/basemaps.py</code> <pre><code>def get_maplibre_style(name: str) -&gt; str:\n    \"\"\"Get MapLibre style URL by name.\n\n    Args:\n        name: Style name (e.g., \"positron\", \"dark-matter\")\n\n    Returns:\n        Style URL\n\n    Raises:\n        ValueError: If style name is not found\n    \"\"\"\n    name_lower = name.lower().replace(\"_\", \"-\")\n    if name_lower in MAPLIBRE_STYLES:\n        return MAPLIBRE_STYLES[name_lower]\n    # Assume it's already a URL\n    if name.startswith(\"http\"):\n        return name\n    raise ValueError(f\"Unknown MapLibre style: {name}\")\n</code></pre>"},{"location":"cesium/","title":"cesium module","text":"<p>Cesium 3D globe widget implementation.</p>"},{"location":"cesium/#anymap_ts.cesium.CesiumMap","title":"<code> CesiumMap            (MapWidget)         </code>","text":"<p>Interactive 3D globe widget using Cesium.</p> <p>This class provides a Python interface to Cesium for 3D globe visualization with terrain, 3D Tiles, and imagery layer support.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from anymap_ts import CesiumMap\n&gt;&gt;&gt; m = CesiumMap(center=[-122.4, 37.8], zoom=10)\n&gt;&gt;&gt; m.set_terrain()  # Enable Cesium World Terrain\n&gt;&gt;&gt; m.add_3d_tileset(url=\"path/to/tileset.json\")\n&gt;&gt;&gt; m\n</code></pre> Source code in <code>anymap_ts/cesium.py</code> <pre><code>class CesiumMap(MapWidget):\n    \"\"\"Interactive 3D globe widget using Cesium.\n\n    This class provides a Python interface to Cesium for 3D globe\n    visualization with terrain, 3D Tiles, and imagery layer support.\n\n    Example:\n        &gt;&gt;&gt; from anymap_ts import CesiumMap\n        &gt;&gt;&gt; m = CesiumMap(center=[-122.4, 37.8], zoom=10)\n        &gt;&gt;&gt; m.set_terrain()  # Enable Cesium World Terrain\n        &gt;&gt;&gt; m.add_3d_tileset(url=\"path/to/tileset.json\")\n        &gt;&gt;&gt; m\n    \"\"\"\n\n    # ESM module for frontend\n    _esm = STATIC_DIR / \"cesium.js\"\n\n    # Cesium-specific traits\n    access_token = traitlets.Unicode(\"\").tag(sync=True)\n\n    # Camera position traits\n    camera_height = traitlets.Float(10000000).tag(sync=True)\n    heading = traitlets.Float(0.0).tag(sync=True)\n    pitch = traitlets.Float(-90.0).tag(sync=True)\n    roll = traitlets.Float(0.0).tag(sync=True)\n\n    # Terrain\n    terrain_enabled = traitlets.Bool(False).tag(sync=True)\n\n    def __init__(\n        self,\n        center: Tuple[float, float] = (0.0, 0.0),\n        zoom: float = 2.0,\n        width: str = \"100%\",\n        height: str = \"600px\",\n        access_token: Optional[str] = None,\n        terrain: bool = False,\n        **kwargs,\n    ):\n        \"\"\"Initialize a Cesium 3D globe.\n\n        Args:\n            center: Globe center as (longitude, latitude).\n            zoom: Initial zoom level (converted to camera height).\n            width: Widget width as CSS string.\n            height: Widget height as CSS string.\n            access_token: Cesium Ion access token (uses CESIUM_TOKEN env var if not provided).\n            terrain: Whether to enable terrain on initialization.\n            **kwargs: Additional widget arguments.\n        \"\"\"\n        # Get access token from env if not provided\n        if access_token is None:\n            access_token = get_cesium_token()\n\n        super().__init__(\n            center=list(center),\n            zoom=zoom,\n            width=width,\n            height=height,\n            access_token=access_token,\n            terrain_enabled=terrain,\n            **kwargs,\n        )\n\n        # Enable terrain if requested\n        if terrain:\n            self.set_terrain()\n\n    # -------------------------------------------------------------------------\n    # Basemap/Imagery Methods\n    # -------------------------------------------------------------------------\n\n    def add_basemap(\n        self,\n        basemap: str = \"OpenStreetMap\",\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a basemap imagery layer.\n\n        Args:\n            basemap: Name of basemap (e.g., \"OpenStreetMap\", \"Bing\").\n            **kwargs: Additional options.\n        \"\"\"\n        # Common basemap URLs\n        basemap_urls = {\n            \"OpenStreetMap\": \"https://tile.openstreetmap.org/{z}/{x}/{y}.png\",\n            \"CartoDB.Positron\": \"https://a.basemaps.cartocdn.com/light_all/{z}/{x}/{y}.png\",\n            \"CartoDB.DarkMatter\": \"https://a.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}.png\",\n            \"Stamen.Terrain\": \"https://tiles.stadiamaps.com/tiles/stamen_terrain/{z}/{x}/{y}.png\",\n        }\n\n        url = basemap_urls.get(basemap, basemap_urls[\"OpenStreetMap\"])\n\n        self.call_js_method(\"addBasemap\", url, name=basemap, **kwargs)\n\n    def add_imagery_layer(\n        self,\n        url: str,\n        name: Optional[str] = None,\n        layer_type: str = \"xyz\",\n        alpha: float = 1.0,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add an imagery layer.\n\n        Args:\n            url: Imagery URL or service endpoint.\n            name: Layer name.\n            layer_type: Type of imagery ('xyz', 'wms', 'wmts', 'arcgis').\n            alpha: Layer opacity (0-1).\n            **kwargs: Additional options (layers, parameters for WMS, etc.).\n        \"\"\"\n        layer_id = name or f\"imagery-{len(self._layers)}\"\n\n        self.call_js_method(\n            \"addImageryLayer\",\n            url=url,\n            name=layer_id,\n            type=layer_type,\n            alpha=alpha,\n            **kwargs,\n        )\n\n        self._layers = {\n            **self._layers,\n            layer_id: {\"id\": layer_id, \"type\": \"imagery\"},\n        }\n\n    def remove_imagery_layer(self, name: str) -&gt; None:\n        \"\"\"Remove an imagery layer.\n\n        Args:\n            name: Layer name to remove.\n        \"\"\"\n        if name in self._layers:\n            layers = dict(self._layers)\n            del layers[name]\n            self._layers = layers\n        self.call_js_method(\"removeImageryLayer\", name)\n\n    # -------------------------------------------------------------------------\n    # Terrain Methods\n    # -------------------------------------------------------------------------\n\n    def set_terrain(\n        self,\n        url: Optional[str] = None,\n        request_vertex_normals: bool = True,\n        request_water_mask: bool = True,\n    ) -&gt; None:\n        \"\"\"Enable terrain.\n\n        Args:\n            url: Terrain provider URL. If None, uses Cesium World Terrain (requires Ion token).\n            request_vertex_normals: Request vertex normals for lighting.\n            request_water_mask: Request water mask for water effects.\n        \"\"\"\n        self.terrain_enabled = True\n        self.call_js_method(\n            \"setTerrain\",\n            url=url or \"cesium-world-terrain\",\n            requestVertexNormals=request_vertex_normals,\n            requestWaterMask=request_water_mask,\n        )\n\n    def remove_terrain(self) -&gt; None:\n        \"\"\"Disable terrain and use ellipsoid.\"\"\"\n        self.terrain_enabled = False\n        self.call_js_method(\"removeTerrain\")\n\n    # -------------------------------------------------------------------------\n    # 3D Tiles Methods\n    # -------------------------------------------------------------------------\n\n    def add_3d_tileset(\n        self,\n        url: Union[str, int],\n        name: Optional[str] = None,\n        maximum_screen_space_error: float = 16,\n        fly_to: bool = True,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a 3D Tileset.\n\n        Args:\n            url: URL to tileset.json or Cesium Ion asset ID.\n            name: Tileset name.\n            maximum_screen_space_error: Maximum screen space error for LOD.\n            fly_to: Whether to fly to the tileset after loading.\n            **kwargs: Additional options.\n        \"\"\"\n        layer_id = name or f\"tileset-{len(self._layers)}\"\n\n        self.call_js_method(\n            \"add3DTileset\",\n            url=str(url),\n            name=layer_id,\n            maximumScreenSpaceError=maximum_screen_space_error,\n            flyTo=fly_to,\n            **kwargs,\n        )\n\n        self._layers = {\n            **self._layers,\n            layer_id: {\"id\": layer_id, \"type\": \"3dtiles\"},\n        }\n\n    def remove_3d_tileset(self, name: str) -&gt; None:\n        \"\"\"Remove a 3D Tileset.\n\n        Args:\n            name: Tileset name to remove.\n        \"\"\"\n        if name in self._layers:\n            layers = dict(self._layers)\n            del layers[name]\n            self._layers = layers\n        self.call_js_method(\"remove3DTileset\", name)\n\n    # -------------------------------------------------------------------------\n    # GeoJSON Methods\n    # -------------------------------------------------------------------------\n\n    def add_geojson(\n        self,\n        data: Any,\n        name: Optional[str] = None,\n        stroke: str = \"#3388ff\",\n        stroke_width: float = 2,\n        fill: str = \"rgba(51, 136, 255, 0.5)\",\n        clamp_to_ground: bool = True,\n        fly_to: bool = True,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add GeoJSON data.\n\n        Args:\n            data: GeoJSON dict or file path.\n            name: Data source name.\n            stroke: Stroke color.\n            stroke_width: Stroke width.\n            fill: Fill color.\n            clamp_to_ground: Whether to clamp features to terrain.\n            fly_to: Whether to fly to the data after loading.\n            **kwargs: Additional options.\n        \"\"\"\n        geojson = to_geojson(data)\n        layer_id = name or f\"geojson-{len(self._layers)}\"\n\n        self.call_js_method(\n            \"addGeoJSON\",\n            data=geojson,\n            name=layer_id,\n            stroke=stroke,\n            strokeWidth=stroke_width,\n            fill=fill,\n            clampToGround=clamp_to_ground,\n            flyTo=fly_to,\n            **kwargs,\n        )\n\n        self._layers = {\n            **self._layers,\n            layer_id: {\"id\": layer_id, \"type\": \"geojson\"},\n        }\n\n    def remove_data_source(self, name: str) -&gt; None:\n        \"\"\"Remove a data source (GeoJSON, etc.).\n\n        Args:\n            name: Data source name to remove.\n        \"\"\"\n        if name in self._layers:\n            layers = dict(self._layers)\n            del layers[name]\n            self._layers = layers\n        self.call_js_method(\"removeDataSource\", name)\n\n    # -------------------------------------------------------------------------\n    # Camera Methods\n    # -------------------------------------------------------------------------\n\n    def fly_to(\n        self,\n        lng: float,\n        lat: float,\n        height: Optional[float] = None,\n        zoom: Optional[float] = None,\n        heading: float = 0,\n        pitch: float = -90,\n        roll: float = 0,\n        duration: float = 2,\n    ) -&gt; None:\n        \"\"\"Fly to a location.\n\n        Args:\n            lng: Target longitude.\n            lat: Target latitude.\n            height: Camera height in meters (overrides zoom).\n            zoom: Zoom level (converted to height if height not provided).\n            heading: Camera heading in degrees.\n            pitch: Camera pitch in degrees (default -90 = looking down).\n            roll: Camera roll in degrees.\n            duration: Flight duration in seconds.\n        \"\"\"\n        self.call_js_method(\n            \"flyTo\",\n            lng,\n            lat,\n            height=height,\n            zoom=zoom,\n            heading=heading,\n            pitch=pitch,\n            roll=roll,\n            duration=duration,\n        )\n\n    def zoom_to(self, target: str) -&gt; None:\n        \"\"\"Zoom to a layer or data source.\n\n        Args:\n            target: Name of the layer or data source to zoom to.\n        \"\"\"\n        self.call_js_method(\"zoomTo\", target=target)\n\n    def set_camera(\n        self,\n        longitude: float = 0,\n        latitude: float = 0,\n        height: float = 10000000,\n        heading: float = 0,\n        pitch: float = -90,\n        roll: float = 0,\n    ) -&gt; None:\n        \"\"\"Set the camera position immediately (no animation).\n\n        Args:\n            longitude: Camera longitude.\n            latitude: Camera latitude.\n            height: Camera height in meters.\n            heading: Camera heading in degrees.\n            pitch: Camera pitch in degrees.\n            roll: Camera roll in degrees.\n        \"\"\"\n        self.call_js_method(\n            \"setCamera\",\n            longitude=longitude,\n            latitude=latitude,\n            height=height,\n            heading=heading,\n            pitch=pitch,\n            roll=roll,\n        )\n\n    def reset_view(self, duration: float = 2) -&gt; None:\n        \"\"\"Reset camera to home position.\n\n        Args:\n            duration: Animation duration in seconds.\n        \"\"\"\n        self.call_js_method(\"resetView\", duration=duration)\n\n    # -------------------------------------------------------------------------\n    # Layer Management\n    # -------------------------------------------------------------------------\n\n    def set_visibility(self, name: str, visible: bool) -&gt; None:\n        \"\"\"Set layer visibility.\n\n        Args:\n            name: Layer name.\n            visible: Whether layer should be visible.\n        \"\"\"\n        self.call_js_method(\"setVisibility\", name, visible)\n\n    def set_opacity(self, name: str, opacity: float) -&gt; None:\n        \"\"\"Set layer opacity (imagery layers only).\n\n        Args:\n            name: Layer name.\n            opacity: Opacity value (0-1).\n        \"\"\"\n        self.call_js_method(\"setOpacity\", name, opacity)\n\n    # -------------------------------------------------------------------------\n    # HTML Export\n    # -------------------------------------------------------------------------\n\n    def _generate_html_template(self) -&gt; str:\n        \"\"\"Generate standalone HTML for the globe.\"\"\"\n        template_path = Path(__file__).parent / \"templates\" / \"cesium.html\"\n\n        if template_path.exists():\n            template = template_path.read_text(encoding=\"utf-8\")\n        else:\n            template = self._get_default_template()\n\n        state = {\n            \"center\": self.center,\n            \"zoom\": self.zoom,\n            \"access_token\": self.access_token,\n            \"terrain_enabled\": self.terrain_enabled,\n            \"width\": self.width,\n            \"height\": self.height,\n            \"layers\": self._layers,\n            \"js_calls\": self._js_calls,\n        }\n\n        template = template.replace(\"{{state}}\", json.dumps(state, indent=2))\n        template = template.replace(\"{{access_token}}\", self.access_token)\n        return template\n\n    def _get_default_template(self) -&gt; str:\n        \"\"\"Get default HTML template.\"\"\"\n        return \"\"\"&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n    &lt;meta charset=\"utf-8\"&gt;\n    &lt;title&gt;Cesium Globe&lt;/title&gt;\n    &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"&gt;\n    &lt;script src=\"https://cesium.com/downloads/cesiumjs/releases/1.120/Build/Cesium/Cesium.js\"&gt;&lt;/script&gt;\n    &lt;link href=\"https://cesium.com/downloads/cesiumjs/releases/1.120/Build/Cesium/Widgets/widgets.css\" rel=\"stylesheet\"&gt;\n    &lt;style&gt;\n        * { margin: 0; padding: 0; box-sizing: border-box; }\n        html, body { height: 100%; }\n        #cesiumContainer { position: absolute; top: 0; bottom: 0; width: 100%; }\n    &lt;/style&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;div id=\"cesiumContainer\"&gt;&lt;/div&gt;\n    &lt;script&gt;\n        const state = {{state}};\n\n        if (state.access_token) {\n            Cesium.Ion.defaultAccessToken = state.access_token;\n        }\n\n        const viewer = new Cesium.Viewer('cesiumContainer', {\n            baseLayerPicker: false,\n            geocoder: false,\n            homeButton: false,\n            sceneModePicker: false,\n            navigationHelpButton: false,\n            animation: false,\n            timeline: false\n        });\n\n        for (const call of state.js_calls || []) {\n            executeMethod(call.method, call.args, call.kwargs);\n        }\n\n        function executeMethod(method, args, kwargs) {\n            console.log('Executing:', method, args, kwargs);\n        }\n    &lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\"\"\"\n</code></pre>"},{"location":"cesium/#anymap_ts.cesium.CesiumMap.__init__","title":"<code>__init__(self, center=(0.0, 0.0), zoom=2.0, width='100%', height='600px', access_token=None, terrain=False, **kwargs)</code>  <code>special</code>","text":"<p>Initialize a Cesium 3D globe.</p> <p>Parameters:</p> Name Type Description Default <code>center</code> <code>Tuple[float, float]</code> <p>Globe center as (longitude, latitude).</p> <code>(0.0, 0.0)</code> <code>zoom</code> <code>float</code> <p>Initial zoom level (converted to camera height).</p> <code>2.0</code> <code>width</code> <code>str</code> <p>Widget width as CSS string.</p> <code>'100%'</code> <code>height</code> <code>str</code> <p>Widget height as CSS string.</p> <code>'600px'</code> <code>access_token</code> <code>Optional[str]</code> <p>Cesium Ion access token (uses CESIUM_TOKEN env var if not provided).</p> <code>None</code> <code>terrain</code> <code>bool</code> <p>Whether to enable terrain on initialization.</p> <code>False</code> <code>**kwargs</code> <p>Additional widget arguments.</p> <code>{}</code> Source code in <code>anymap_ts/cesium.py</code> <pre><code>def __init__(\n    self,\n    center: Tuple[float, float] = (0.0, 0.0),\n    zoom: float = 2.0,\n    width: str = \"100%\",\n    height: str = \"600px\",\n    access_token: Optional[str] = None,\n    terrain: bool = False,\n    **kwargs,\n):\n    \"\"\"Initialize a Cesium 3D globe.\n\n    Args:\n        center: Globe center as (longitude, latitude).\n        zoom: Initial zoom level (converted to camera height).\n        width: Widget width as CSS string.\n        height: Widget height as CSS string.\n        access_token: Cesium Ion access token (uses CESIUM_TOKEN env var if not provided).\n        terrain: Whether to enable terrain on initialization.\n        **kwargs: Additional widget arguments.\n    \"\"\"\n    # Get access token from env if not provided\n    if access_token is None:\n        access_token = get_cesium_token()\n\n    super().__init__(\n        center=list(center),\n        zoom=zoom,\n        width=width,\n        height=height,\n        access_token=access_token,\n        terrain_enabled=terrain,\n        **kwargs,\n    )\n\n    # Enable terrain if requested\n    if terrain:\n        self.set_terrain()\n</code></pre>"},{"location":"cesium/#anymap_ts.cesium.CesiumMap.add_3d_tileset","title":"<code>add_3d_tileset(self, url, name=None, maximum_screen_space_error=16, fly_to=True, **kwargs)</code>","text":"<p>Add a 3D Tileset.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>Union[str, int]</code> <p>URL to tileset.json or Cesium Ion asset ID.</p> required <code>name</code> <code>Optional[str]</code> <p>Tileset name.</p> <code>None</code> <code>maximum_screen_space_error</code> <code>float</code> <p>Maximum screen space error for LOD.</p> <code>16</code> <code>fly_to</code> <code>bool</code> <p>Whether to fly to the tileset after loading.</p> <code>True</code> <code>**kwargs</code> <p>Additional options.</p> <code>{}</code> Source code in <code>anymap_ts/cesium.py</code> <pre><code>def add_3d_tileset(\n    self,\n    url: Union[str, int],\n    name: Optional[str] = None,\n    maximum_screen_space_error: float = 16,\n    fly_to: bool = True,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a 3D Tileset.\n\n    Args:\n        url: URL to tileset.json or Cesium Ion asset ID.\n        name: Tileset name.\n        maximum_screen_space_error: Maximum screen space error for LOD.\n        fly_to: Whether to fly to the tileset after loading.\n        **kwargs: Additional options.\n    \"\"\"\n    layer_id = name or f\"tileset-{len(self._layers)}\"\n\n    self.call_js_method(\n        \"add3DTileset\",\n        url=str(url),\n        name=layer_id,\n        maximumScreenSpaceError=maximum_screen_space_error,\n        flyTo=fly_to,\n        **kwargs,\n    )\n\n    self._layers = {\n        **self._layers,\n        layer_id: {\"id\": layer_id, \"type\": \"3dtiles\"},\n    }\n</code></pre>"},{"location":"cesium/#anymap_ts.cesium.CesiumMap.add_basemap","title":"<code>add_basemap(self, basemap='OpenStreetMap', **kwargs)</code>","text":"<p>Add a basemap imagery layer.</p> <p>Parameters:</p> Name Type Description Default <code>basemap</code> <code>str</code> <p>Name of basemap (e.g., \"OpenStreetMap\", \"Bing\").</p> <code>'OpenStreetMap'</code> <code>**kwargs</code> <p>Additional options.</p> <code>{}</code> Source code in <code>anymap_ts/cesium.py</code> <pre><code>def add_basemap(\n    self,\n    basemap: str = \"OpenStreetMap\",\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a basemap imagery layer.\n\n    Args:\n        basemap: Name of basemap (e.g., \"OpenStreetMap\", \"Bing\").\n        **kwargs: Additional options.\n    \"\"\"\n    # Common basemap URLs\n    basemap_urls = {\n        \"OpenStreetMap\": \"https://tile.openstreetmap.org/{z}/{x}/{y}.png\",\n        \"CartoDB.Positron\": \"https://a.basemaps.cartocdn.com/light_all/{z}/{x}/{y}.png\",\n        \"CartoDB.DarkMatter\": \"https://a.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}.png\",\n        \"Stamen.Terrain\": \"https://tiles.stadiamaps.com/tiles/stamen_terrain/{z}/{x}/{y}.png\",\n    }\n\n    url = basemap_urls.get(basemap, basemap_urls[\"OpenStreetMap\"])\n\n    self.call_js_method(\"addBasemap\", url, name=basemap, **kwargs)\n</code></pre>"},{"location":"cesium/#anymap_ts.cesium.CesiumMap.add_geojson","title":"<code>add_geojson(self, data, name=None, stroke='#3388ff', stroke_width=2, fill='rgba(51, 136, 255, 0.5)', clamp_to_ground=True, fly_to=True, **kwargs)</code>","text":"<p>Add GeoJSON data.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>GeoJSON dict or file path.</p> required <code>name</code> <code>Optional[str]</code> <p>Data source name.</p> <code>None</code> <code>stroke</code> <code>str</code> <p>Stroke color.</p> <code>'#3388ff'</code> <code>stroke_width</code> <code>float</code> <p>Stroke width.</p> <code>2</code> <code>fill</code> <code>str</code> <p>Fill color.</p> <code>'rgba(51, 136, 255, 0.5)'</code> <code>clamp_to_ground</code> <code>bool</code> <p>Whether to clamp features to terrain.</p> <code>True</code> <code>fly_to</code> <code>bool</code> <p>Whether to fly to the data after loading.</p> <code>True</code> <code>**kwargs</code> <p>Additional options.</p> <code>{}</code> Source code in <code>anymap_ts/cesium.py</code> <pre><code>def add_geojson(\n    self,\n    data: Any,\n    name: Optional[str] = None,\n    stroke: str = \"#3388ff\",\n    stroke_width: float = 2,\n    fill: str = \"rgba(51, 136, 255, 0.5)\",\n    clamp_to_ground: bool = True,\n    fly_to: bool = True,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add GeoJSON data.\n\n    Args:\n        data: GeoJSON dict or file path.\n        name: Data source name.\n        stroke: Stroke color.\n        stroke_width: Stroke width.\n        fill: Fill color.\n        clamp_to_ground: Whether to clamp features to terrain.\n        fly_to: Whether to fly to the data after loading.\n        **kwargs: Additional options.\n    \"\"\"\n    geojson = to_geojson(data)\n    layer_id = name or f\"geojson-{len(self._layers)}\"\n\n    self.call_js_method(\n        \"addGeoJSON\",\n        data=geojson,\n        name=layer_id,\n        stroke=stroke,\n        strokeWidth=stroke_width,\n        fill=fill,\n        clampToGround=clamp_to_ground,\n        flyTo=fly_to,\n        **kwargs,\n    )\n\n    self._layers = {\n        **self._layers,\n        layer_id: {\"id\": layer_id, \"type\": \"geojson\"},\n    }\n</code></pre>"},{"location":"cesium/#anymap_ts.cesium.CesiumMap.add_imagery_layer","title":"<code>add_imagery_layer(self, url, name=None, layer_type='xyz', alpha=1.0, **kwargs)</code>","text":"<p>Add an imagery layer.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>Imagery URL or service endpoint.</p> required <code>name</code> <code>Optional[str]</code> <p>Layer name.</p> <code>None</code> <code>layer_type</code> <code>str</code> <p>Type of imagery ('xyz', 'wms', 'wmts', 'arcgis').</p> <code>'xyz'</code> <code>alpha</code> <code>float</code> <p>Layer opacity (0-1).</p> <code>1.0</code> <code>**kwargs</code> <p>Additional options (layers, parameters for WMS, etc.).</p> <code>{}</code> Source code in <code>anymap_ts/cesium.py</code> <pre><code>def add_imagery_layer(\n    self,\n    url: str,\n    name: Optional[str] = None,\n    layer_type: str = \"xyz\",\n    alpha: float = 1.0,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add an imagery layer.\n\n    Args:\n        url: Imagery URL or service endpoint.\n        name: Layer name.\n        layer_type: Type of imagery ('xyz', 'wms', 'wmts', 'arcgis').\n        alpha: Layer opacity (0-1).\n        **kwargs: Additional options (layers, parameters for WMS, etc.).\n    \"\"\"\n    layer_id = name or f\"imagery-{len(self._layers)}\"\n\n    self.call_js_method(\n        \"addImageryLayer\",\n        url=url,\n        name=layer_id,\n        type=layer_type,\n        alpha=alpha,\n        **kwargs,\n    )\n\n    self._layers = {\n        **self._layers,\n        layer_id: {\"id\": layer_id, \"type\": \"imagery\"},\n    }\n</code></pre>"},{"location":"cesium/#anymap_ts.cesium.CesiumMap.fly_to","title":"<code>fly_to(self, lng, lat, height=None, zoom=None, heading=0, pitch=-90, roll=0, duration=2)</code>","text":"<p>Fly to a location.</p> <p>Parameters:</p> Name Type Description Default <code>lng</code> <code>float</code> <p>Target longitude.</p> required <code>lat</code> <code>float</code> <p>Target latitude.</p> required <code>height</code> <code>Optional[float]</code> <p>Camera height in meters (overrides zoom).</p> <code>None</code> <code>zoom</code> <code>Optional[float]</code> <p>Zoom level (converted to height if height not provided).</p> <code>None</code> <code>heading</code> <code>float</code> <p>Camera heading in degrees.</p> <code>0</code> <code>pitch</code> <code>float</code> <p>Camera pitch in degrees (default -90 = looking down).</p> <code>-90</code> <code>roll</code> <code>float</code> <p>Camera roll in degrees.</p> <code>0</code> <code>duration</code> <code>float</code> <p>Flight duration in seconds.</p> <code>2</code> Source code in <code>anymap_ts/cesium.py</code> <pre><code>def fly_to(\n    self,\n    lng: float,\n    lat: float,\n    height: Optional[float] = None,\n    zoom: Optional[float] = None,\n    heading: float = 0,\n    pitch: float = -90,\n    roll: float = 0,\n    duration: float = 2,\n) -&gt; None:\n    \"\"\"Fly to a location.\n\n    Args:\n        lng: Target longitude.\n        lat: Target latitude.\n        height: Camera height in meters (overrides zoom).\n        zoom: Zoom level (converted to height if height not provided).\n        heading: Camera heading in degrees.\n        pitch: Camera pitch in degrees (default -90 = looking down).\n        roll: Camera roll in degrees.\n        duration: Flight duration in seconds.\n    \"\"\"\n    self.call_js_method(\n        \"flyTo\",\n        lng,\n        lat,\n        height=height,\n        zoom=zoom,\n        heading=heading,\n        pitch=pitch,\n        roll=roll,\n        duration=duration,\n    )\n</code></pre>"},{"location":"cesium/#anymap_ts.cesium.CesiumMap.remove_3d_tileset","title":"<code>remove_3d_tileset(self, name)</code>","text":"<p>Remove a 3D Tileset.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Tileset name to remove.</p> required Source code in <code>anymap_ts/cesium.py</code> <pre><code>def remove_3d_tileset(self, name: str) -&gt; None:\n    \"\"\"Remove a 3D Tileset.\n\n    Args:\n        name: Tileset name to remove.\n    \"\"\"\n    if name in self._layers:\n        layers = dict(self._layers)\n        del layers[name]\n        self._layers = layers\n    self.call_js_method(\"remove3DTileset\", name)\n</code></pre>"},{"location":"cesium/#anymap_ts.cesium.CesiumMap.remove_data_source","title":"<code>remove_data_source(self, name)</code>","text":"<p>Remove a data source (GeoJSON, etc.).</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Data source name to remove.</p> required Source code in <code>anymap_ts/cesium.py</code> <pre><code>def remove_data_source(self, name: str) -&gt; None:\n    \"\"\"Remove a data source (GeoJSON, etc.).\n\n    Args:\n        name: Data source name to remove.\n    \"\"\"\n    if name in self._layers:\n        layers = dict(self._layers)\n        del layers[name]\n        self._layers = layers\n    self.call_js_method(\"removeDataSource\", name)\n</code></pre>"},{"location":"cesium/#anymap_ts.cesium.CesiumMap.remove_imagery_layer","title":"<code>remove_imagery_layer(self, name)</code>","text":"<p>Remove an imagery layer.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Layer name to remove.</p> required Source code in <code>anymap_ts/cesium.py</code> <pre><code>def remove_imagery_layer(self, name: str) -&gt; None:\n    \"\"\"Remove an imagery layer.\n\n    Args:\n        name: Layer name to remove.\n    \"\"\"\n    if name in self._layers:\n        layers = dict(self._layers)\n        del layers[name]\n        self._layers = layers\n    self.call_js_method(\"removeImageryLayer\", name)\n</code></pre>"},{"location":"cesium/#anymap_ts.cesium.CesiumMap.remove_terrain","title":"<code>remove_terrain(self)</code>","text":"<p>Disable terrain and use ellipsoid.</p> Source code in <code>anymap_ts/cesium.py</code> <pre><code>def remove_terrain(self) -&gt; None:\n    \"\"\"Disable terrain and use ellipsoid.\"\"\"\n    self.terrain_enabled = False\n    self.call_js_method(\"removeTerrain\")\n</code></pre>"},{"location":"cesium/#anymap_ts.cesium.CesiumMap.reset_view","title":"<code>reset_view(self, duration=2)</code>","text":"<p>Reset camera to home position.</p> <p>Parameters:</p> Name Type Description Default <code>duration</code> <code>float</code> <p>Animation duration in seconds.</p> <code>2</code> Source code in <code>anymap_ts/cesium.py</code> <pre><code>def reset_view(self, duration: float = 2) -&gt; None:\n    \"\"\"Reset camera to home position.\n\n    Args:\n        duration: Animation duration in seconds.\n    \"\"\"\n    self.call_js_method(\"resetView\", duration=duration)\n</code></pre>"},{"location":"cesium/#anymap_ts.cesium.CesiumMap.set_camera","title":"<code>set_camera(self, longitude=0, latitude=0, height=10000000, heading=0, pitch=-90, roll=0)</code>","text":"<p>Set the camera position immediately (no animation).</p> <p>Parameters:</p> Name Type Description Default <code>longitude</code> <code>float</code> <p>Camera longitude.</p> <code>0</code> <code>latitude</code> <code>float</code> <p>Camera latitude.</p> <code>0</code> <code>height</code> <code>float</code> <p>Camera height in meters.</p> <code>10000000</code> <code>heading</code> <code>float</code> <p>Camera heading in degrees.</p> <code>0</code> <code>pitch</code> <code>float</code> <p>Camera pitch in degrees.</p> <code>-90</code> <code>roll</code> <code>float</code> <p>Camera roll in degrees.</p> <code>0</code> Source code in <code>anymap_ts/cesium.py</code> <pre><code>def set_camera(\n    self,\n    longitude: float = 0,\n    latitude: float = 0,\n    height: float = 10000000,\n    heading: float = 0,\n    pitch: float = -90,\n    roll: float = 0,\n) -&gt; None:\n    \"\"\"Set the camera position immediately (no animation).\n\n    Args:\n        longitude: Camera longitude.\n        latitude: Camera latitude.\n        height: Camera height in meters.\n        heading: Camera heading in degrees.\n        pitch: Camera pitch in degrees.\n        roll: Camera roll in degrees.\n    \"\"\"\n    self.call_js_method(\n        \"setCamera\",\n        longitude=longitude,\n        latitude=latitude,\n        height=height,\n        heading=heading,\n        pitch=pitch,\n        roll=roll,\n    )\n</code></pre>"},{"location":"cesium/#anymap_ts.cesium.CesiumMap.set_opacity","title":"<code>set_opacity(self, name, opacity)</code>","text":"<p>Set layer opacity (imagery layers only).</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Layer name.</p> required <code>opacity</code> <code>float</code> <p>Opacity value (0-1).</p> required Source code in <code>anymap_ts/cesium.py</code> <pre><code>def set_opacity(self, name: str, opacity: float) -&gt; None:\n    \"\"\"Set layer opacity (imagery layers only).\n\n    Args:\n        name: Layer name.\n        opacity: Opacity value (0-1).\n    \"\"\"\n    self.call_js_method(\"setOpacity\", name, opacity)\n</code></pre>"},{"location":"cesium/#anymap_ts.cesium.CesiumMap.set_terrain","title":"<code>set_terrain(self, url=None, request_vertex_normals=True, request_water_mask=True)</code>","text":"<p>Enable terrain.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>Optional[str]</code> <p>Terrain provider URL. If None, uses Cesium World Terrain (requires Ion token).</p> <code>None</code> <code>request_vertex_normals</code> <code>bool</code> <p>Request vertex normals for lighting.</p> <code>True</code> <code>request_water_mask</code> <code>bool</code> <p>Request water mask for water effects.</p> <code>True</code> Source code in <code>anymap_ts/cesium.py</code> <pre><code>def set_terrain(\n    self,\n    url: Optional[str] = None,\n    request_vertex_normals: bool = True,\n    request_water_mask: bool = True,\n) -&gt; None:\n    \"\"\"Enable terrain.\n\n    Args:\n        url: Terrain provider URL. If None, uses Cesium World Terrain (requires Ion token).\n        request_vertex_normals: Request vertex normals for lighting.\n        request_water_mask: Request water mask for water effects.\n    \"\"\"\n    self.terrain_enabled = True\n    self.call_js_method(\n        \"setTerrain\",\n        url=url or \"cesium-world-terrain\",\n        requestVertexNormals=request_vertex_normals,\n        requestWaterMask=request_water_mask,\n    )\n</code></pre>"},{"location":"cesium/#anymap_ts.cesium.CesiumMap.set_visibility","title":"<code>set_visibility(self, name, visible)</code>","text":"<p>Set layer visibility.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Layer name.</p> required <code>visible</code> <code>bool</code> <p>Whether layer should be visible.</p> required Source code in <code>anymap_ts/cesium.py</code> <pre><code>def set_visibility(self, name: str, visible: bool) -&gt; None:\n    \"\"\"Set layer visibility.\n\n    Args:\n        name: Layer name.\n        visible: Whether layer should be visible.\n    \"\"\"\n    self.call_js_method(\"setVisibility\", name, visible)\n</code></pre>"},{"location":"cesium/#anymap_ts.cesium.CesiumMap.zoom_to","title":"<code>zoom_to(self, target)</code>","text":"<p>Zoom to a layer or data source.</p> <p>Parameters:</p> Name Type Description Default <code>target</code> <code>str</code> <p>Name of the layer or data source to zoom to.</p> required Source code in <code>anymap_ts/cesium.py</code> <pre><code>def zoom_to(self, target: str) -&gt; None:\n    \"\"\"Zoom to a layer or data source.\n\n    Args:\n        target: Name of the layer or data source to zoom to.\n    \"\"\"\n    self.call_js_method(\"zoomTo\", target=target)\n</code></pre>"},{"location":"cesium/#anymap_ts.cesium.get_cesium_token","title":"<code>get_cesium_token()</code>","text":"<p>Get Cesium Ion access token from environment variable.</p> <p>Returns:</p> Type Description <code>str</code> <p>Cesium Ion access token or empty string if not set.</p> Source code in <code>anymap_ts/cesium.py</code> <pre><code>def get_cesium_token() -&gt; str:\n    \"\"\"Get Cesium Ion access token from environment variable.\n\n    Returns:\n        Cesium Ion access token or empty string if not set.\n    \"\"\"\n    return os.environ.get(\"CESIUM_TOKEN\", \"\")\n</code></pre>"},{"location":"contributing/","title":"Contributing","text":"<p>Contributions are welcome, and they are greatly appreciated! Every little bit helps, and credit will always be given.</p>"},{"location":"contributing/#types-of-contributions","title":"Types of Contributions","text":""},{"location":"contributing/#report-bugs","title":"Report Bugs","text":"<p>Report bugs at https://github.com/opengeos/anymap-ts/issues.</p> <p>If you are reporting a bug, please include:</p> <ul> <li>Your operating system name and version.</li> <li>Any details about your local setup that might be helpful in troubleshooting.</li> <li>Detailed steps to reproduce the bug.</li> </ul>"},{"location":"contributing/#fix-bugs","title":"Fix Bugs","text":"<p>Look through the GitHub issues for bugs. Anything tagged with \"bug\" and \"help wanted\" is open to whoever wants to implement it.</p>"},{"location":"contributing/#implement-features","title":"Implement Features","text":"<p>Look through the GitHub issues for features. Anything tagged with \"enhancement\" and \"help wanted\" is open to whoever wants to implement it.</p>"},{"location":"contributing/#write-documentation","title":"Write Documentation","text":"<p>anymap-ts could always use more documentation, whether as part of the official docs, in docstrings, or even on the web in blog posts, articles, and such.</p>"},{"location":"contributing/#submit-feedback","title":"Submit Feedback","text":"<p>The best way to send feedback is to file an issue at https://github.com/opengeos/anymap-ts/issues.</p> <p>If you are proposing a feature:</p> <ul> <li>Explain in detail how it would work.</li> <li>Keep the scope as narrow as possible, to make it easier to implement.</li> <li>Remember that this is a volunteer-driven project, and that contributions are welcome.</li> </ul>"},{"location":"contributing/#get-started","title":"Get Started!","text":"<p>Ready to contribute? Here's how to set up anymap-ts for local development.</p> <ol> <li> <p>Fork the anymap-ts repo on GitHub.</p> </li> <li> <p>Clone your fork locally:</p> <pre><code>git clone git@github.com:your_name_here/anymap-ts.git\n</code></pre> </li> <li> <p>Install your local copy into a virtual environment:</p> <pre><code>cd anymap-ts\npip install -e \".[dev]\"\nnpm install --legacy-peer-deps\n</code></pre> </li> <li> <p>Create a branch for local development:</p> <pre><code>git checkout -b name-of-your-bugfix-or-feature\n</code></pre> </li> <li> <p>Make your changes locally.</p> </li> <li> <p>Build the TypeScript code:</p> <pre><code>npm run build:all\n</code></pre> </li> <li> <p>Commit your changes and push your branch to GitHub:</p> <pre><code>git add .\ngit commit -m \"Your detailed description of your changes.\"\ngit push origin name-of-your-bugfix-or-feature\n</code></pre> </li> <li> <p>Submit a pull request through the GitHub website.</p> </li> </ol>"},{"location":"contributing/#pull-request-guidelines","title":"Pull Request Guidelines","text":"<p>Before you submit a pull request, check that it meets these guidelines:</p> <ol> <li>The pull request should include tests if applicable.</li> <li>If the pull request adds functionality, the docs should be updated.</li> <li>The pull request should work for Python 3.9+.</li> </ol>"},{"location":"contributing/#project-structure","title":"Project Structure","text":"<pre><code>anymap-ts/\n\u251c\u2500\u2500 src/                    # TypeScript source\n\u2502   \u251c\u2500\u2500 core/               # Base classes\n\u2502   \u251c\u2500\u2500 maplibre/           # MapLibre implementation\n\u2502   \u251c\u2500\u2500 mapbox/             # Mapbox implementation\n\u2502   \u251c\u2500\u2500 leaflet/            # Leaflet implementation\n\u2502   \u251c\u2500\u2500 openlayers/         # OpenLayers implementation\n\u2502   \u251c\u2500\u2500 deckgl/             # DeckGL implementation\n\u2502   \u251c\u2500\u2500 cesium/             # Cesium implementation\n\u2502   \u2514\u2500\u2500 types/              # Type definitions\n\u251c\u2500\u2500 anymap_ts/              # Python package\n\u2502   \u251c\u2500\u2500 maplibre.py         # MapLibreMap class\n\u2502   \u251c\u2500\u2500 mapbox.py           # MapboxMap class\n\u2502   \u251c\u2500\u2500 leaflet.py          # LeafletMap class\n\u2502   \u251c\u2500\u2500 openlayers.py       # OpenLayersMap class\n\u2502   \u251c\u2500\u2500 deckgl.py           # DeckGLMap class\n\u2502   \u251c\u2500\u2500 cesium.py           # CesiumMap class\n\u2502   \u251c\u2500\u2500 keplergl.py         # KeplerGLMap class\n\u2502   \u251c\u2500\u2500 potree.py           # PotreeViewer class\n\u2502   \u251c\u2500\u2500 static/             # Built JS/CSS\n\u2502   \u2514\u2500\u2500 templates/          # HTML export templates\n\u2514\u2500\u2500 docs/                   # Documentation\n    \u2514\u2500\u2500 notebooks/          # Example notebooks\n</code></pre>"},{"location":"contributing/#build-commands","title":"Build Commands","text":"<pre><code># Build all libraries\nnpm run build:all\n\n# Build specific library\nnpm run build:maplibre\nnpm run build:mapbox\nnpm run build:leaflet\nnpm run build:deckgl\nnpm run build:openlayers\nnpm run build:cesium\n\n# Watch mode\nnpm run watch\n</code></pre>"},{"location":"deckgl/","title":"deckgl module","text":"<p>DeckGL map widget implementation extending MapLibre with deck.gl layers.</p>"},{"location":"deckgl/#anymap_ts.deckgl.DeckGLMap","title":"<code> DeckGLMap            (MapLibreMap)         </code>","text":"<p>Interactive map widget using MapLibre GL JS with deck.gl overlay.</p> <p>This class extends MapLibreMap with deck.gl visualization layer support for GPU-accelerated geospatial visualizations.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from anymap_ts import DeckGLMap\n&gt;&gt;&gt; m = DeckGLMap(center=[-122.4, 37.8], zoom=10)\n&gt;&gt;&gt; m.add_scatterplot_layer(\n...     data=points,\n...     get_position='coordinates',\n...     get_radius=100,\n...     get_fill_color=[255, 0, 0]\n... )\n&gt;&gt;&gt; m\n</code></pre> Source code in <code>anymap_ts/deckgl.py</code> <pre><code>class DeckGLMap(MapLibreMap):\n    \"\"\"Interactive map widget using MapLibre GL JS with deck.gl overlay.\n\n    This class extends MapLibreMap with deck.gl visualization layer support\n    for GPU-accelerated geospatial visualizations.\n\n    Example:\n        &gt;&gt;&gt; from anymap_ts import DeckGLMap\n        &gt;&gt;&gt; m = DeckGLMap(center=[-122.4, 37.8], zoom=10)\n        &gt;&gt;&gt; m.add_scatterplot_layer(\n        ...     data=points,\n        ...     get_position='coordinates',\n        ...     get_radius=100,\n        ...     get_fill_color=[255, 0, 0]\n        ... )\n        &gt;&gt;&gt; m\n    \"\"\"\n\n    # ESM module for frontend (uses DeckGL-enabled version)\n    _esm = STATIC_DIR / \"deckgl.js\"\n\n    # DeckGL layer tracking\n    _deck_layers = traitlets.Dict({}).tag(sync=True)\n\n    def __init__(\n        self,\n        center: Tuple[float, float] = (0.0, 0.0),\n        zoom: float = 2.0,\n        width: str = \"100%\",\n        height: str = \"600px\",\n        style: Union[str, Dict] = \"https://demotiles.maplibre.org/style.json\",\n        bearing: float = 0.0,\n        pitch: float = 0.0,\n        max_pitch: float = 85.0,\n        controls: Optional[Dict[str, Any]] = None,\n        **kwargs,\n    ):\n        \"\"\"Initialize a DeckGL map.\n\n        Args:\n            center: Map center as (longitude, latitude).\n            zoom: Initial zoom level.\n            width: Map width as CSS string.\n            height: Map height as CSS string.\n            style: MapLibre style URL or style object.\n            bearing: Map bearing in degrees.\n            pitch: Map pitch in degrees.\n            max_pitch: Maximum pitch angle in degrees (default: 85).\n            controls: Dict of controls to add (e.g., {\"navigation\": True}).\n            **kwargs: Additional widget arguments.\n        \"\"\"\n        super().__init__(\n            center=center,\n            zoom=zoom,\n            width=width,\n            height=height,\n            style=style,\n            bearing=bearing,\n            pitch=pitch,\n            max_pitch=max_pitch,\n            controls=controls,\n            **kwargs,\n        )\n        self._deck_layers = {}\n\n    # -------------------------------------------------------------------------\n    # DeckGL Scatterplot Layer\n    # -------------------------------------------------------------------------\n\n    def add_scatterplot_layer(\n        self,\n        data: Any,\n        name: Optional[str] = None,\n        get_position: Union[str, Callable] = \"coordinates\",\n        get_radius: Union[float, str, Callable] = 5,\n        get_fill_color: Union[List[int], str, Callable] = None,\n        get_line_color: Union[List[int], str, Callable] = None,\n        radius_scale: float = 1,\n        radius_min_pixels: float = 1,\n        radius_max_pixels: float = 100,\n        line_width_min_pixels: float = 1,\n        stroked: bool = True,\n        filled: bool = True,\n        pickable: bool = True,\n        opacity: float = 0.8,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a scatterplot layer for point visualization.\n\n        Args:\n            data: Array of data objects or GeoJSON.\n            name: Layer ID.\n            get_position: Accessor for point position [lng, lat].\n            get_radius: Accessor for point radius.\n            get_fill_color: Accessor for fill color [r, g, b, a].\n            get_line_color: Accessor for stroke color [r, g, b, a].\n            radius_scale: Global radius multiplier.\n            radius_min_pixels: Minimum radius in pixels.\n            radius_max_pixels: Maximum radius in pixels.\n            line_width_min_pixels: Minimum stroke width.\n            stroked: Whether to draw stroke.\n            filled: Whether to fill points.\n            pickable: Whether layer responds to hover/click.\n            opacity: Layer opacity.\n            **kwargs: Additional layer props.\n        \"\"\"\n        layer_id = name or f\"scatterplot-{len(self._deck_layers)}\"\n        processed_data = self._process_deck_data(data)\n\n        self.call_js_method(\n            \"addScatterplotLayer\",\n            id=layer_id,\n            data=processed_data,\n            getPosition=get_position,\n            getRadius=get_radius,\n            getFillColor=get_fill_color or [51, 136, 255, 200],\n            getLineColor=get_line_color or [255, 255, 255, 255],\n            radiusScale=radius_scale,\n            radiusMinPixels=radius_min_pixels,\n            radiusMaxPixels=radius_max_pixels,\n            lineWidthMinPixels=line_width_min_pixels,\n            stroked=stroked,\n            filled=filled,\n            pickable=pickable,\n            opacity=opacity,\n            **kwargs,\n        )\n\n        self._deck_layers = {\n            **self._deck_layers,\n            layer_id: {\"type\": \"ScatterplotLayer\", \"id\": layer_id},\n        }\n\n    # -------------------------------------------------------------------------\n    # DeckGL Arc Layer\n    # -------------------------------------------------------------------------\n\n    def add_arc_layer(\n        self,\n        data: Any,\n        name: Optional[str] = None,\n        get_source_position: Union[str, Callable] = \"source\",\n        get_target_position: Union[str, Callable] = \"target\",\n        get_source_color: Union[List[int], str, Callable] = None,\n        get_target_color: Union[List[int], str, Callable] = None,\n        get_width: Union[float, str, Callable] = 1,\n        pickable: bool = True,\n        opacity: float = 0.8,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add an arc layer for origin-destination visualization.\n\n        Args:\n            data: Array of data objects with source/target coordinates.\n            name: Layer ID.\n            get_source_position: Accessor for source position [lng, lat].\n            get_target_position: Accessor for target position [lng, lat].\n            get_source_color: Accessor for source color [r, g, b, a].\n            get_target_color: Accessor for target color [r, g, b, a].\n            get_width: Accessor for arc width.\n            pickable: Whether layer responds to hover/click.\n            opacity: Layer opacity.\n            **kwargs: Additional layer props.\n        \"\"\"\n        layer_id = name or f\"arc-{len(self._deck_layers)}\"\n        processed_data = self._process_deck_data(data)\n\n        self.call_js_method(\n            \"addArcLayer\",\n            id=layer_id,\n            data=processed_data,\n            getSourcePosition=get_source_position,\n            getTargetPosition=get_target_position,\n            getSourceColor=get_source_color or [51, 136, 255, 255],\n            getTargetColor=get_target_color or [255, 136, 51, 255],\n            getWidth=get_width,\n            pickable=pickable,\n            opacity=opacity,\n            **kwargs,\n        )\n\n        self._deck_layers = {\n            **self._deck_layers,\n            layer_id: {\"type\": \"ArcLayer\", \"id\": layer_id},\n        }\n\n    # -------------------------------------------------------------------------\n    # DeckGL Point Cloud Layer\n    # -------------------------------------------------------------------------\n\n    def add_point_cloud_layer(\n        self,\n        data: Any,\n        name: Optional[str] = None,\n        get_position: Union[str, Callable] = \"position\",\n        get_color: Union[List[int], str, Callable] = None,\n        get_normal: Union[str, Callable] = None,\n        point_size: float = 2,\n        size_units: str = \"pixels\",\n        coordinate_system: Optional[str] = None,\n        coordinate_origin: Optional[List[float]] = None,\n        pickable: bool = True,\n        opacity: float = 1.0,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a point cloud layer for 3D point visualization.\n\n        Renders large point cloud datasets typically from LiDAR or 3D scanning.\n        Supports both 2D and 3D coordinates with optional normal vectors for\n        lighting effects.\n\n        Args:\n            data: Array of point data with position [x, y, z] coordinates.\n            name: Layer ID. If None, auto-generated.\n            get_position: Accessor for point position [x, y, z].\n            get_color: Accessor for point color [r, g, b, a].\n            get_normal: Accessor for point normal [nx, ny, nz] for lighting.\n            point_size: Point size in size_units.\n            size_units: Units for point_size ('pixels' or 'meters').\n            coordinate_system: Coordinate system ('CARTESIAN', 'METER_OFFSETS',\n                'LNGLAT', 'LNGLAT_OFFSETS').\n            coordinate_origin: Origin for offset coordinate systems [lng, lat, z].\n            pickable: Whether layer responds to hover/click.\n            opacity: Layer opacity (0-1).\n            **kwargs: Additional PointCloudLayer props.\n\n        Example:\n            &gt;&gt;&gt; m = DeckGLMap()\n            &gt;&gt;&gt; points = [\n            ...     {\"position\": [-122.4, 37.8, 100], \"color\": [255, 0, 0]},\n            ...     {\"position\": [-122.5, 37.7, 200], \"color\": [0, 255, 0]},\n            ... ]\n            &gt;&gt;&gt; m.add_point_cloud_layer(\n            ...     data=points,\n            ...     point_size=5,\n            ...     get_color=\"color\"\n            ... )\n        \"\"\"\n        layer_id = name or f\"pointcloud-{len(self._deck_layers)}\"\n        processed_data = self._process_deck_data(data)\n\n        layer_kwargs = {\n            \"id\": layer_id,\n            \"data\": processed_data,\n            \"getPosition\": get_position,\n            \"getColor\": get_color or [255, 255, 255, 255],\n            \"pointSize\": point_size,\n            \"sizeUnits\": size_units,\n            \"pickable\": pickable,\n            \"opacity\": opacity,\n        }\n\n        if get_normal is not None:\n            layer_kwargs[\"getNormal\"] = get_normal\n\n        if coordinate_system is not None:\n            layer_kwargs[\"coordinateSystem\"] = coordinate_system\n\n        if coordinate_origin is not None:\n            layer_kwargs[\"coordinateOrigin\"] = coordinate_origin\n\n        layer_kwargs.update(kwargs)\n        self.call_js_method(\"addPointCloudLayer\", **layer_kwargs)\n\n        self._deck_layers = {\n            **self._deck_layers,\n            layer_id: {\"type\": \"PointCloudLayer\", \"id\": layer_id},\n        }\n\n    # -------------------------------------------------------------------------\n    # DeckGL Path Layer\n    # -------------------------------------------------------------------------\n\n    def add_path_layer(\n        self,\n        data: Any,\n        name: Optional[str] = None,\n        get_path: Union[str, Callable] = \"path\",\n        get_color: Union[List[int], str, Callable] = None,\n        get_width: Union[float, str, Callable] = 1,\n        width_scale: float = 1,\n        width_min_pixels: float = 1,\n        pickable: bool = True,\n        opacity: float = 0.8,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a path layer for polyline visualization.\n\n        Args:\n            data: Array of data objects with path coordinates.\n            name: Layer ID.\n            get_path: Accessor for path coordinates [[lng, lat], ...].\n            get_color: Accessor for path color [r, g, b, a].\n            get_width: Accessor for path width.\n            width_scale: Global width multiplier.\n            width_min_pixels: Minimum width in pixels.\n            pickable: Whether layer responds to hover/click.\n            opacity: Layer opacity.\n            **kwargs: Additional layer props.\n        \"\"\"\n        layer_id = name or f\"path-{len(self._deck_layers)}\"\n        processed_data = self._process_deck_data(data)\n\n        self.call_js_method(\n            \"addPathLayer\",\n            id=layer_id,\n            data=processed_data,\n            getPath=get_path,\n            getColor=get_color or [51, 136, 255, 200],\n            getWidth=get_width,\n            widthScale=width_scale,\n            widthMinPixels=width_min_pixels,\n            pickable=pickable,\n            opacity=opacity,\n            **kwargs,\n        )\n\n        self._deck_layers = {\n            **self._deck_layers,\n            layer_id: {\"type\": \"PathLayer\", \"id\": layer_id},\n        }\n\n    # -------------------------------------------------------------------------\n    # DeckGL Polygon Layer\n    # -------------------------------------------------------------------------\n\n    def add_polygon_layer(\n        self,\n        data: Any,\n        name: Optional[str] = None,\n        get_polygon: Union[str, Callable] = \"polygon\",\n        get_fill_color: Union[List[int], str, Callable] = None,\n        get_line_color: Union[List[int], str, Callable] = None,\n        get_line_width: Union[float, str, Callable] = 1,\n        get_elevation: Union[float, str, Callable] = 0,\n        extruded: bool = False,\n        wireframe: bool = False,\n        filled: bool = True,\n        stroked: bool = True,\n        line_width_min_pixels: float = 1,\n        pickable: bool = True,\n        opacity: float = 0.5,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a polygon layer for filled polygon visualization.\n\n        Args:\n            data: Array of data objects with polygon coordinates.\n            name: Layer ID.\n            get_polygon: Accessor for polygon coordinates.\n            get_fill_color: Accessor for fill color [r, g, b, a].\n            get_line_color: Accessor for stroke color [r, g, b, a].\n            get_line_width: Accessor for stroke width.\n            get_elevation: Accessor for 3D extrusion height.\n            extruded: Whether to render as 3D polygons.\n            wireframe: Whether to render wireframe (extruded only).\n            filled: Whether to fill polygons.\n            stroked: Whether to draw stroke.\n            line_width_min_pixels: Minimum stroke width.\n            pickable: Whether layer responds to hover/click.\n            opacity: Layer opacity.\n            **kwargs: Additional layer props.\n        \"\"\"\n        layer_id = name or f\"polygon-{len(self._deck_layers)}\"\n        processed_data = self._process_deck_data(data)\n\n        self.call_js_method(\n            \"addPolygonLayer\",\n            id=layer_id,\n            data=processed_data,\n            getPolygon=get_polygon,\n            getFillColor=get_fill_color or [51, 136, 255, 128],\n            getLineColor=get_line_color or [0, 0, 255, 255],\n            getLineWidth=get_line_width,\n            getElevation=get_elevation,\n            extruded=extruded,\n            wireframe=wireframe,\n            filled=filled,\n            stroked=stroked,\n            lineWidthMinPixels=line_width_min_pixels,\n            pickable=pickable,\n            opacity=opacity,\n            **kwargs,\n        )\n\n        self._deck_layers = {\n            **self._deck_layers,\n            layer_id: {\"type\": \"PolygonLayer\", \"id\": layer_id},\n        }\n\n    # -------------------------------------------------------------------------\n    # DeckGL Hexagon Layer\n    # -------------------------------------------------------------------------\n\n    def add_hexagon_layer(\n        self,\n        data: Any,\n        name: Optional[str] = None,\n        get_position: Union[str, Callable] = \"coordinates\",\n        radius: float = 1000,\n        elevation_scale: float = 4,\n        extruded: bool = True,\n        color_range: Optional[List[List[int]]] = None,\n        pickable: bool = True,\n        opacity: float = 0.8,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a hexagon layer for hexbin aggregation visualization.\n\n        Args:\n            data: Array of data objects with position coordinates.\n            name: Layer ID.\n            get_position: Accessor for point position [lng, lat].\n            radius: Hexagon radius in meters.\n            elevation_scale: Elevation multiplier for 3D.\n            extruded: Whether to render as 3D hexagons.\n            color_range: Color gradient for aggregation [[r, g, b], ...].\n            pickable: Whether layer responds to hover/click.\n            opacity: Layer opacity.\n            **kwargs: Additional layer props.\n        \"\"\"\n        layer_id = name or f\"hexagon-{len(self._deck_layers)}\"\n        processed_data = self._process_deck_data(data)\n\n        default_color_range = [\n            [1, 152, 189],\n            [73, 227, 206],\n            [216, 254, 181],\n            [254, 237, 177],\n            [254, 173, 84],\n            [209, 55, 78],\n        ]\n\n        self.call_js_method(\n            \"addHexagonLayer\",\n            id=layer_id,\n            data=processed_data,\n            getPosition=get_position,\n            radius=radius,\n            elevationScale=elevation_scale,\n            extruded=extruded,\n            colorRange=color_range or default_color_range,\n            pickable=pickable,\n            opacity=opacity,\n            **kwargs,\n        )\n\n        self._deck_layers = {\n            **self._deck_layers,\n            layer_id: {\"type\": \"HexagonLayer\", \"id\": layer_id},\n        }\n\n    # -------------------------------------------------------------------------\n    # DeckGL Heatmap Layer\n    # -------------------------------------------------------------------------\n\n    def add_heatmap_layer(\n        self,\n        data: Any,\n        name: Optional[str] = None,\n        get_position: Union[str, Callable] = \"coordinates\",\n        get_weight: Union[float, str, Callable] = 1,\n        radius_pixels: float = 30,\n        intensity: float = 1,\n        threshold: float = 0.05,\n        color_range: Optional[List[List[int]]] = None,\n        opacity: float = 1,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a heatmap layer for density visualization.\n\n        Args:\n            data: Array of data objects with position coordinates.\n            name: Layer ID.\n            get_position: Accessor for point position [lng, lat].\n            get_weight: Accessor for point weight.\n            radius_pixels: Influence radius in pixels.\n            intensity: Intensity multiplier.\n            threshold: Minimum density threshold.\n            color_range: Color gradient [[r, g, b, a], ...].\n            opacity: Layer opacity.\n            **kwargs: Additional layer props.\n        \"\"\"\n        layer_id = name or f\"heatmap-{len(self._deck_layers)}\"\n        processed_data = self._process_deck_data(data)\n\n        default_color_range = [\n            [255, 255, 178, 25],\n            [254, 217, 118, 85],\n            [254, 178, 76, 127],\n            [253, 141, 60, 170],\n            [240, 59, 32, 212],\n            [189, 0, 38, 255],\n        ]\n\n        self.call_js_method(\n            \"addHeatmapLayer\",\n            id=layer_id,\n            data=processed_data,\n            getPosition=get_position,\n            getWeight=get_weight,\n            radiusPixels=radius_pixels,\n            intensity=intensity,\n            threshold=threshold,\n            colorRange=color_range or default_color_range,\n            opacity=opacity,\n            **kwargs,\n        )\n\n        self._deck_layers = {\n            **self._deck_layers,\n            layer_id: {\"type\": \"HeatmapLayer\", \"id\": layer_id},\n        }\n\n    # -------------------------------------------------------------------------\n    # DeckGL Grid Layer\n    # -------------------------------------------------------------------------\n\n    def add_grid_layer(\n        self,\n        data: Any,\n        name: Optional[str] = None,\n        get_position: Union[str, Callable] = \"coordinates\",\n        cell_size: float = 200,\n        elevation_scale: float = 4,\n        extruded: bool = True,\n        color_range: Optional[List[List[int]]] = None,\n        pickable: bool = True,\n        opacity: float = 0.8,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a grid layer for square grid aggregation visualization.\n\n        Args:\n            data: Array of data objects with position coordinates.\n            name: Layer ID.\n            get_position: Accessor for point position [lng, lat].\n            cell_size: Grid cell size in meters.\n            elevation_scale: Elevation multiplier for 3D.\n            extruded: Whether to render as 3D cells.\n            color_range: Color gradient [[r, g, b], ...].\n            pickable: Whether layer responds to hover/click.\n            opacity: Layer opacity.\n            **kwargs: Additional layer props.\n        \"\"\"\n        layer_id = name or f\"grid-{len(self._deck_layers)}\"\n        processed_data = self._process_deck_data(data)\n\n        default_color_range = [\n            [1, 152, 189],\n            [73, 227, 206],\n            [216, 254, 181],\n            [254, 237, 177],\n            [254, 173, 84],\n            [209, 55, 78],\n        ]\n\n        self.call_js_method(\n            \"addGridLayer\",\n            id=layer_id,\n            data=processed_data,\n            getPosition=get_position,\n            cellSize=cell_size,\n            elevationScale=elevation_scale,\n            extruded=extruded,\n            colorRange=color_range or default_color_range,\n            pickable=pickable,\n            opacity=opacity,\n            **kwargs,\n        )\n\n        self._deck_layers = {\n            **self._deck_layers,\n            layer_id: {\"type\": \"GridLayer\", \"id\": layer_id},\n        }\n\n    # -------------------------------------------------------------------------\n    # DeckGL Icon Layer\n    # -------------------------------------------------------------------------\n\n    def add_icon_layer(\n        self,\n        data: Any,\n        name: Optional[str] = None,\n        get_position: Union[str, Callable] = \"coordinates\",\n        get_icon: Union[str, Callable] = \"icon\",\n        get_size: Union[float, str, Callable] = 20,\n        get_color: Union[List[int], str, Callable] = None,\n        icon_atlas: Optional[str] = None,\n        icon_mapping: Optional[Dict] = None,\n        pickable: bool = True,\n        opacity: float = 1,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add an icon layer for custom marker visualization.\n\n        Args:\n            data: Array of data objects with position coordinates.\n            name: Layer ID.\n            get_position: Accessor for icon position [lng, lat].\n            get_icon: Accessor for icon name in icon_mapping.\n            get_size: Accessor for icon size.\n            get_color: Accessor for icon tint color [r, g, b, a].\n            icon_atlas: URL to icon atlas image.\n            icon_mapping: Dict mapping icon names to atlas coordinates.\n            pickable: Whether layer responds to hover/click.\n            opacity: Layer opacity.\n            **kwargs: Additional layer props.\n        \"\"\"\n        layer_id = name or f\"icon-{len(self._deck_layers)}\"\n        processed_data = self._process_deck_data(data)\n\n        self.call_js_method(\n            \"addIconLayer\",\n            id=layer_id,\n            data=processed_data,\n            getPosition=get_position,\n            getIcon=get_icon,\n            getSize=get_size,\n            getColor=get_color or [255, 255, 255, 255],\n            iconAtlas=icon_atlas,\n            iconMapping=icon_mapping,\n            pickable=pickable,\n            opacity=opacity,\n            **kwargs,\n        )\n\n        self._deck_layers = {\n            **self._deck_layers,\n            layer_id: {\"type\": \"IconLayer\", \"id\": layer_id},\n        }\n\n    # -------------------------------------------------------------------------\n    # DeckGL Text Layer\n    # -------------------------------------------------------------------------\n\n    def add_text_layer(\n        self,\n        data: Any,\n        name: Optional[str] = None,\n        get_position: Union[str, Callable] = \"coordinates\",\n        get_text: Union[str, Callable] = \"text\",\n        get_size: Union[float, str, Callable] = 12,\n        get_color: Union[List[int], str, Callable] = None,\n        get_angle: Union[float, str, Callable] = 0,\n        text_anchor: str = \"middle\",\n        alignment_baseline: str = \"center\",\n        pickable: bool = True,\n        opacity: float = 1,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a text layer for label visualization.\n\n        Args:\n            data: Array of data objects with position and text.\n            name: Layer ID.\n            get_position: Accessor for text position [lng, lat].\n            get_text: Accessor for text content.\n            get_size: Accessor for text size.\n            get_color: Accessor for text color [r, g, b, a].\n            get_angle: Accessor for text rotation in degrees.\n            text_anchor: Horizontal alignment ('start', 'middle', 'end').\n            alignment_baseline: Vertical alignment ('top', 'center', 'bottom').\n            pickable: Whether layer responds to hover/click.\n            opacity: Layer opacity.\n            **kwargs: Additional layer props.\n        \"\"\"\n        layer_id = name or f\"text-{len(self._deck_layers)}\"\n        processed_data = self._process_deck_data(data)\n\n        self.call_js_method(\n            \"addTextLayer\",\n            id=layer_id,\n            data=processed_data,\n            getPosition=get_position,\n            getText=get_text,\n            getSize=get_size,\n            getColor=get_color or [0, 0, 0, 255],\n            getAngle=get_angle,\n            getTextAnchor=text_anchor,\n            getAlignmentBaseline=alignment_baseline,\n            pickable=pickable,\n            opacity=opacity,\n            **kwargs,\n        )\n\n        self._deck_layers = {\n            **self._deck_layers,\n            layer_id: {\"type\": \"TextLayer\", \"id\": layer_id},\n        }\n\n    # -------------------------------------------------------------------------\n    # DeckGL GeoJSON Layer\n    # -------------------------------------------------------------------------\n\n    def add_geojson_layer(\n        self,\n        data: Any,\n        name: Optional[str] = None,\n        get_fill_color: Union[List[int], str, Callable] = None,\n        get_line_color: Union[List[int], str, Callable] = None,\n        get_line_width: Union[float, str, Callable] = 1,\n        get_point_radius: Union[float, str, Callable] = 5,\n        get_elevation: Union[float, str, Callable] = 0,\n        extruded: bool = False,\n        wireframe: bool = False,\n        filled: bool = True,\n        stroked: bool = True,\n        line_width_min_pixels: float = 1,\n        point_radius_min_pixels: float = 2,\n        pickable: bool = True,\n        opacity: float = 0.8,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a GeoJSON layer for rendering GeoJSON features.\n\n        Args:\n            data: GeoJSON object or URL.\n            name: Layer ID.\n            get_fill_color: Accessor for fill color [r, g, b, a].\n            get_line_color: Accessor for stroke color [r, g, b, a].\n            get_line_width: Accessor for stroke width.\n            get_point_radius: Accessor for point radius.\n            get_elevation: Accessor for 3D extrusion height.\n            extruded: Whether to render as 3D features.\n            wireframe: Whether to render wireframe (extruded only).\n            filled: Whether to fill features.\n            stroked: Whether to draw stroke.\n            line_width_min_pixels: Minimum stroke width.\n            point_radius_min_pixels: Minimum point radius.\n            pickable: Whether layer responds to hover/click.\n            opacity: Layer opacity.\n            **kwargs: Additional layer props.\n        \"\"\"\n        layer_id = name or f\"geojson-{len(self._deck_layers)}\"\n        processed_data = self._process_deck_data(data)\n\n        self.call_js_method(\n            \"addGeoJsonLayer\",\n            id=layer_id,\n            data=processed_data,\n            getFillColor=get_fill_color or [51, 136, 255, 128],\n            getLineColor=get_line_color or [0, 0, 0, 255],\n            getLineWidth=get_line_width,\n            getPointRadius=get_point_radius,\n            getElevation=get_elevation,\n            extruded=extruded,\n            wireframe=wireframe,\n            filled=filled,\n            stroked=stroked,\n            lineWidthMinPixels=line_width_min_pixels,\n            pointRadiusMinPixels=point_radius_min_pixels,\n            pickable=pickable,\n            opacity=opacity,\n            **kwargs,\n        )\n\n        self._deck_layers = {\n            **self._deck_layers,\n            layer_id: {\"type\": \"GeoJsonLayer\", \"id\": layer_id},\n        }\n\n    # -------------------------------------------------------------------------\n    # DeckGL Contour Layer\n    # -------------------------------------------------------------------------\n\n    def add_contour_layer(\n        self,\n        data: Any,\n        name: Optional[str] = None,\n        get_position: Union[str, Callable] = \"coordinates\",\n        get_weight: Union[float, str, Callable] = 1,\n        cell_size: float = 200,\n        contours: Optional[List[Dict]] = None,\n        pickable: bool = True,\n        opacity: float = 1,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a contour layer for isoline visualization.\n\n        Args:\n            data: Array of data objects with position coordinates.\n            name: Layer ID.\n            get_position: Accessor for point position [lng, lat].\n            get_weight: Accessor for point weight.\n            cell_size: Grid cell size for aggregation.\n            contours: Contour definitions [{threshold, color, strokeWidth}, ...].\n            pickable: Whether layer responds to hover/click.\n            opacity: Layer opacity.\n            **kwargs: Additional layer props.\n        \"\"\"\n        layer_id = name or f\"contour-{len(self._deck_layers)}\"\n        processed_data = self._process_deck_data(data)\n\n        default_contours = [\n            {\"threshold\": 1, \"color\": [255, 255, 255], \"strokeWidth\": 1},\n            {\"threshold\": 5, \"color\": [51, 136, 255], \"strokeWidth\": 2},\n            {\"threshold\": 10, \"color\": [0, 0, 255], \"strokeWidth\": 3},\n        ]\n\n        self.call_js_method(\n            \"addContourLayer\",\n            id=layer_id,\n            data=processed_data,\n            getPosition=get_position,\n            getWeight=get_weight,\n            cellSize=cell_size,\n            contours=contours or default_contours,\n            pickable=pickable,\n            opacity=opacity,\n            **kwargs,\n        )\n\n        self._deck_layers = {\n            **self._deck_layers,\n            layer_id: {\"type\": \"ContourLayer\", \"id\": layer_id},\n        }\n\n    # -------------------------------------------------------------------------\n    # DeckGL Screen Grid Layer\n    # -------------------------------------------------------------------------\n\n    def add_screen_grid_layer(\n        self,\n        data: Any,\n        name: Optional[str] = None,\n        get_position: Union[str, Callable] = \"coordinates\",\n        get_weight: Union[float, str, Callable] = 1,\n        cell_size_pixels: float = 50,\n        color_range: Optional[List[List[int]]] = None,\n        pickable: bool = True,\n        opacity: float = 0.8,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a screen grid layer for screen-space grid aggregation.\n\n        Args:\n            data: Array of data objects with position coordinates.\n            name: Layer ID.\n            get_position: Accessor for point position [lng, lat].\n            get_weight: Accessor for point weight.\n            cell_size_pixels: Grid cell size in pixels.\n            color_range: Color gradient [[r, g, b, a], ...].\n            pickable: Whether layer responds to hover/click.\n            opacity: Layer opacity.\n            **kwargs: Additional layer props.\n        \"\"\"\n        layer_id = name or f\"screengrid-{len(self._deck_layers)}\"\n        processed_data = self._process_deck_data(data)\n\n        default_color_range = [\n            [255, 255, 178, 25],\n            [254, 217, 118, 85],\n            [254, 178, 76, 127],\n            [253, 141, 60, 170],\n            [240, 59, 32, 212],\n            [189, 0, 38, 255],\n        ]\n\n        self.call_js_method(\n            \"addScreenGridLayer\",\n            id=layer_id,\n            data=processed_data,\n            getPosition=get_position,\n            getWeight=get_weight,\n            cellSizePixels=cell_size_pixels,\n            colorRange=color_range or default_color_range,\n            pickable=pickable,\n            opacity=opacity,\n            **kwargs,\n        )\n\n        self._deck_layers = {\n            **self._deck_layers,\n            layer_id: {\"type\": \"ScreenGridLayer\", \"id\": layer_id},\n        }\n\n    # -------------------------------------------------------------------------\n    # Generic DeckGL Layer\n    # -------------------------------------------------------------------------\n\n    def add_deckgl_layer(\n        self,\n        layer_type: str,\n        data: Any,\n        name: Optional[str] = None,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a generic deck.gl layer to the map.\n\n        This method provides a flexible way to add any supported deck.gl layer\n        type using a single interface. For commonly used layers, prefer the\n        specific methods (e.g., add_scatterplot_layer) for better IDE support.\n\n        Args:\n            layer_type: The deck.gl layer type. Supported types include:\n                'ScatterplotLayer', 'ArcLayer', 'PathLayer', 'PolygonLayer',\n                'HexagonLayer', 'HeatmapLayer', 'GridLayer', 'IconLayer',\n                'TextLayer', 'GeoJsonLayer', 'ContourLayer', 'ScreenGridLayer',\n                'PointCloudLayer', 'TripsLayer', 'LineLayer'.\n            data: Array of data objects or GeoJSON.\n            name: Layer ID. If None, auto-generated from layer_type.\n            **kwargs: Layer-specific properties passed directly to deck.gl.\n                Common properties include:\n                - opacity: Layer opacity (0-1)\n                - pickable: Whether layer responds to hover/click\n                - getPosition: Accessor for position coordinates\n                - getColor/getFillColor/getLineColor: Color accessors\n\n        Example:\n            &gt;&gt;&gt; m = DeckGLMap()\n            &gt;&gt;&gt; # Add a TripsLayer with animation\n            &gt;&gt;&gt; m.add_deckgl_layer(\n            ...     'TripsLayer',\n            ...     data=trips_data,\n            ...     getPath='waypoints',\n            ...     getTimestamps='timestamps',\n            ...     getColor=[253, 128, 93],\n            ...     trailLength=180,\n            ... )\n            &gt;&gt;&gt; # Add a LineLayer\n            &gt;&gt;&gt; m.add_deckgl_layer(\n            ...     'LineLayer',\n            ...     data=lines_data,\n            ...     getSourcePosition='source',\n            ...     getTargetPosition='target',\n            ...     getColor=[0, 128, 255],\n            ... )\n        \"\"\"\n        # Normalize layer type and create prefix\n        layer_type_clean = layer_type.replace(\"Layer\", \"\")\n        prefix = layer_type_clean.lower()\n        layer_id = name or f\"{prefix}-{len(self._deck_layers)}\"\n        processed_data = self._process_deck_data(data)\n\n        self.call_js_method(\n            \"addDeckGLLayer\",\n            layerType=layer_type,\n            id=layer_id,\n            data=processed_data,\n            **kwargs,\n        )\n\n        self._deck_layers = {\n            **self._deck_layers,\n            layer_id: {\"type\": layer_type, \"id\": layer_id},\n        }\n\n    # -------------------------------------------------------------------------\n    # DeckGL Trips Layer\n    # -------------------------------------------------------------------------\n\n    def add_trips_layer(\n        self,\n        data: Any,\n        name: Optional[str] = None,\n        get_path: Union[str, Callable] = \"waypoints\",\n        get_timestamps: Union[str, Callable] = \"timestamps\",\n        get_color: Union[List[int], str, Callable] = None,\n        width_min_pixels: float = 2,\n        trail_length: float = 180,\n        current_time: float = 0,\n        pickable: bool = True,\n        opacity: float = 0.8,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a trips layer for animated path visualization.\n\n        The TripsLayer renders animated paths showing movement over time,\n        ideal for visualizing vehicle routes, migration patterns, or any\n        time-based trajectory data.\n\n        Args:\n            data: Array of trip objects with waypoints and timestamps.\n            name: Layer ID. If None, auto-generated.\n            get_path: Accessor for waypoint coordinates [[lng, lat], ...].\n            get_timestamps: Accessor for timestamps at each waypoint.\n            get_color: Accessor for trip color [r, g, b] or [r, g, b, a].\n            width_min_pixels: Minimum trail width in pixels.\n            trail_length: Trail length in timestamp units.\n            current_time: Current animation time.\n            pickable: Whether layer responds to hover/click.\n            opacity: Layer opacity (0-1).\n            **kwargs: Additional TripsLayer props.\n\n        Example:\n            &gt;&gt;&gt; m = DeckGLMap()\n            &gt;&gt;&gt; trips = [\n            ...     {\n            ...         \"waypoints\": [[-122.4, 37.8], [-122.5, 37.7], [-122.6, 37.8]],\n            ...         \"timestamps\": [0, 50, 100]\n            ...     }\n            ... ]\n            &gt;&gt;&gt; m.add_trips_layer(\n            ...     data=trips,\n            ...     trail_length=180,\n            ...     current_time=50,\n            ... )\n        \"\"\"\n        layer_id = name or f\"trips-{len(self._deck_layers)}\"\n        processed_data = self._process_deck_data(data)\n\n        self.call_js_method(\n            \"addTripsLayer\",\n            id=layer_id,\n            data=processed_data,\n            getPath=get_path,\n            getTimestamps=get_timestamps,\n            getColor=get_color or [253, 128, 93],\n            widthMinPixels=width_min_pixels,\n            trailLength=trail_length,\n            currentTime=current_time,\n            pickable=pickable,\n            opacity=opacity,\n            **kwargs,\n        )\n\n        self._deck_layers = {\n            **self._deck_layers,\n            layer_id: {\"type\": \"TripsLayer\", \"id\": layer_id},\n        }\n\n    # -------------------------------------------------------------------------\n    # DeckGL Line Layer\n    # -------------------------------------------------------------------------\n\n    def add_line_layer(\n        self,\n        data: Any,\n        name: Optional[str] = None,\n        get_source_position: Union[str, Callable] = \"sourcePosition\",\n        get_target_position: Union[str, Callable] = \"targetPosition\",\n        get_color: Union[List[int], str, Callable] = None,\n        get_width: Union[float, str, Callable] = 1,\n        width_min_pixels: float = 1,\n        pickable: bool = True,\n        opacity: float = 0.8,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a line layer for simple line segment visualization.\n\n        The LineLayer renders straight line segments between source and\n        target positions. Unlike ArcLayer, lines are drawn directly\n        without curvature.\n\n        Args:\n            data: Array of line objects with source/target positions.\n            name: Layer ID. If None, auto-generated.\n            get_source_position: Accessor for source position [lng, lat].\n            get_target_position: Accessor for target position [lng, lat].\n            get_color: Accessor for line color [r, g, b] or [r, g, b, a].\n            get_width: Accessor for line width.\n            width_min_pixels: Minimum line width in pixels.\n            pickable: Whether layer responds to hover/click.\n            opacity: Layer opacity (0-1).\n            **kwargs: Additional LineLayer props.\n\n        Example:\n            &gt;&gt;&gt; m = DeckGLMap()\n            &gt;&gt;&gt; lines = [\n            ...     {\"sourcePosition\": [-122.4, 37.8], \"targetPosition\": [-122.5, 37.7]},\n            ...     {\"sourcePosition\": [-122.5, 37.7], \"targetPosition\": [-122.6, 37.8]},\n            ... ]\n            &gt;&gt;&gt; m.add_line_layer(\n            ...     data=lines,\n            ...     get_color=[0, 128, 255],\n            ...     get_width=2,\n            ... )\n        \"\"\"\n        layer_id = name or f\"line-{len(self._deck_layers)}\"\n        processed_data = self._process_deck_data(data)\n\n        self.call_js_method(\n            \"addLineLayer\",\n            id=layer_id,\n            data=processed_data,\n            getSourcePosition=get_source_position,\n            getTargetPosition=get_target_position,\n            getColor=get_color or [51, 136, 255, 200],\n            getWidth=get_width,\n            widthMinPixels=width_min_pixels,\n            pickable=pickable,\n            opacity=opacity,\n            **kwargs,\n        )\n\n        self._deck_layers = {\n            **self._deck_layers,\n            layer_id: {\"type\": \"LineLayer\", \"id\": layer_id},\n        }\n\n    # -------------------------------------------------------------------------\n    # DeckGL COG Layer\n    # -------------------------------------------------------------------------\n\n    def add_cog_layer(\n        self,\n        url: str,\n        name: Optional[str] = None,\n        opacity: float = 1.0,\n        visible: bool = True,\n        debug: bool = False,\n        debug_opacity: float = 0.25,\n        max_error: float = 0.125,\n        fit_bounds: bool = True,\n        before_id: Optional[str] = None,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a Cloud Optimized GeoTIFF (COG) layer using @developmentseed/deck.gl-geotiff.\n\n        This method renders COG files directly in the browser using GPU-accelerated\n        deck.gl rendering with automatic reprojection support.\n\n        Args:\n            url: URL to the Cloud Optimized GeoTIFF file.\n            name: Layer ID. If None, auto-generated.\n            opacity: Layer opacity (0-1).\n            visible: Whether layer is visible.\n            debug: Show reprojection mesh for debugging.\n            debug_opacity: Opacity of debug mesh (0-1).\n            max_error: Maximum reprojection error in pixels. Lower values\n                create denser mesh for better accuracy.\n            fit_bounds: Whether to fit map to COG bounds after loading.\n            before_id: ID of layer to insert before.\n            **kwargs: Additional COGLayer props.\n\n        Example:\n            &gt;&gt;&gt; m = DeckGLMap()\n            &gt;&gt;&gt; m.add_cog_layer(\n            ...     \"https://example.com/landcover.tif\",\n            ...     name=\"landcover\",\n            ...     opacity=0.8\n            ... )\n        \"\"\"\n        # Use a monotonically increasing counter to avoid ID collisions when layers are removed.\n        counter = getattr(self, \"_cog_layer_counter\", 0)\n        layer_id = name or f\"cog-{counter}\"\n        self._cog_layer_counter = counter + 1\n\n        self.call_js_method(\n            \"addCOGLayer\",\n            id=layer_id,\n            geotiff=url,\n            opacity=opacity,\n            visible=visible,\n            debug=debug,\n            debugOpacity=debug_opacity,\n            maxError=max_error,\n            fitBounds=fit_bounds,\n            beforeId=before_id,\n            **kwargs,\n        )\n\n        self._deck_layers = {\n            **self._deck_layers,\n            layer_id: {\"type\": \"COGLayer\", \"id\": layer_id, \"url\": url},\n        }\n\n    # -------------------------------------------------------------------------\n    # New DeckGL Layer Types\n    # -------------------------------------------------------------------------\n\n    def add_bitmap_layer(\n        self,\n        image: str,\n        bounds: List[float],\n        name: Optional[str] = None,\n        opacity: float = 1.0,\n        visible: bool = True,\n        pickable: bool = False,\n        desaturate: float = 0,\n        transparent_color: Optional[List[int]] = None,\n        tint_color: Optional[List[int]] = None,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a bitmap layer for raster image overlay.\n\n        Args:\n            image: URL or data URI of the image.\n            bounds: Bounding box [west, south, east, north].\n            name: Layer ID.\n            opacity: Layer opacity (0-1).\n            visible: Whether layer is visible.\n            pickable: Whether layer responds to hover/click.\n            desaturate: Desaturation amount (0-1).\n            transparent_color: Color to make transparent [r, g, b, a].\n            tint_color: Color to tint the image [r, g, b].\n            **kwargs: Additional BitmapLayer props.\n        \"\"\"\n        layer_id = name or f\"bitmap-{len(self._deck_layers)}\"\n\n        self.call_js_method(\n            \"addBitmapLayer\",\n            id=layer_id,\n            image=image,\n            bounds=bounds,\n            opacity=opacity,\n            visible=visible,\n            pickable=pickable,\n            desaturate=desaturate,\n            transparentColor=transparent_color or [0, 0, 0, 0],\n            tintColor=tint_color or [255, 255, 255],\n            **kwargs,\n        )\n\n        self._deck_layers = {\n            **self._deck_layers,\n            layer_id: {\"type\": \"BitmapLayer\", \"id\": layer_id},\n        }\n\n    def add_column_layer(\n        self,\n        data: Any,\n        name: Optional[str] = None,\n        get_position: Union[str, Callable] = \"coordinates\",\n        get_fill_color: Union[List[int], str, Callable] = None,\n        get_line_color: Union[List[int], str, Callable] = None,\n        get_elevation: Union[float, str, Callable] = 1000,\n        radius: float = 1000,\n        disk_resolution: int = 20,\n        elevation_scale: float = 1,\n        coverage: float = 1,\n        extruded: bool = True,\n        filled: bool = True,\n        stroked: bool = False,\n        wireframe: bool = False,\n        pickable: bool = True,\n        opacity: float = 0.8,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a column layer for 3D column/bar visualization.\n\n        Args:\n            data: Array of data objects with position coordinates.\n            name: Layer ID.\n            get_position: Accessor for column position [lng, lat].\n            get_fill_color: Accessor for fill color [r, g, b, a].\n            get_line_color: Accessor for stroke color [r, g, b, a].\n            get_elevation: Accessor for column height.\n            radius: Column radius in meters.\n            disk_resolution: Number of sides for column polygon.\n            elevation_scale: Elevation multiplier.\n            coverage: Column coverage (0-1).\n            extruded: Whether to extrude columns.\n            filled: Whether to fill columns.\n            stroked: Whether to stroke columns.\n            wireframe: Whether to render as wireframe.\n            pickable: Whether layer responds to hover/click.\n            opacity: Layer opacity.\n            **kwargs: Additional ColumnLayer props.\n        \"\"\"\n        layer_id = name or f\"column-{len(self._deck_layers)}\"\n        processed_data = self._process_deck_data(data)\n\n        self.call_js_method(\n            \"addColumnLayer\",\n            id=layer_id,\n            data=processed_data,\n            getPosition=get_position,\n            getFillColor=get_fill_color or [255, 140, 0, 200],\n            getLineColor=get_line_color or [0, 0, 0, 255],\n            getElevation=get_elevation,\n            radius=radius,\n            diskResolution=disk_resolution,\n            elevationScale=elevation_scale,\n            coverage=coverage,\n            extruded=extruded,\n            filled=filled,\n            stroked=stroked,\n            wireframe=wireframe,\n            pickable=pickable,\n            opacity=opacity,\n            **kwargs,\n        )\n\n        self._deck_layers = {\n            **self._deck_layers,\n            layer_id: {\"type\": \"ColumnLayer\", \"id\": layer_id},\n        }\n\n    def add_grid_cell_layer(\n        self,\n        data: Any,\n        name: Optional[str] = None,\n        get_position: Union[str, Callable] = \"coordinates\",\n        get_color: Union[List[int], str, Callable] = None,\n        get_elevation: Union[float, str, Callable] = 1000,\n        cell_size: float = 200,\n        coverage: float = 1,\n        elevation_scale: float = 1,\n        extruded: bool = True,\n        pickable: bool = True,\n        opacity: float = 0.8,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a grid cell layer for pre-aggregated grid visualization.\n\n        Args:\n            data: Array of data objects with position coordinates.\n            name: Layer ID.\n            get_position: Accessor for cell position [lng, lat].\n            get_color: Accessor for cell color [r, g, b, a].\n            get_elevation: Accessor for cell height.\n            cell_size: Cell size in meters.\n            coverage: Cell coverage (0-1).\n            elevation_scale: Elevation multiplier.\n            extruded: Whether to extrude cells.\n            pickable: Whether layer responds to hover/click.\n            opacity: Layer opacity.\n            **kwargs: Additional GridCellLayer props.\n        \"\"\"\n        layer_id = name or f\"gridcell-{len(self._deck_layers)}\"\n        processed_data = self._process_deck_data(data)\n\n        self.call_js_method(\n            \"addGridCellLayer\",\n            id=layer_id,\n            data=processed_data,\n            getPosition=get_position,\n            getColor=get_color or [255, 140, 0, 200],\n            getElevation=get_elevation,\n            cellSize=cell_size,\n            coverage=coverage,\n            elevationScale=elevation_scale,\n            extruded=extruded,\n            pickable=pickable,\n            opacity=opacity,\n            **kwargs,\n        )\n\n        self._deck_layers = {\n            **self._deck_layers,\n            layer_id: {\"type\": \"GridCellLayer\", \"id\": layer_id},\n        }\n\n    def add_solid_polygon_layer(\n        self,\n        data: Any,\n        name: Optional[str] = None,\n        get_polygon: Union[str, Callable] = \"polygon\",\n        get_fill_color: Union[List[int], str, Callable] = None,\n        get_line_color: Union[List[int], str, Callable] = None,\n        get_elevation: Union[float, str, Callable] = 0,\n        filled: bool = True,\n        extruded: bool = False,\n        wireframe: bool = False,\n        elevation_scale: float = 1,\n        pickable: bool = True,\n        opacity: float = 0.8,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a solid polygon layer for filled polygon visualization.\n\n        Args:\n            data: Array of data objects with polygon coordinates.\n            name: Layer ID.\n            get_polygon: Accessor for polygon coordinates.\n            get_fill_color: Accessor for fill color [r, g, b, a].\n            get_line_color: Accessor for stroke color [r, g, b, a].\n            get_elevation: Accessor for 3D extrusion height.\n            filled: Whether to fill polygons.\n            extruded: Whether to render as 3D polygons.\n            wireframe: Whether to render wireframe.\n            elevation_scale: Elevation multiplier.\n            pickable: Whether layer responds to hover/click.\n            opacity: Layer opacity.\n            **kwargs: Additional SolidPolygonLayer props.\n        \"\"\"\n        layer_id = name or f\"solidpolygon-{len(self._deck_layers)}\"\n        processed_data = self._process_deck_data(data)\n\n        self.call_js_method(\n            \"addSolidPolygonLayer\",\n            id=layer_id,\n            data=processed_data,\n            getPolygon=get_polygon,\n            getFillColor=get_fill_color or [51, 136, 255, 128],\n            getLineColor=get_line_color or [0, 0, 0, 255],\n            getElevation=get_elevation,\n            filled=filled,\n            extruded=extruded,\n            wireframe=wireframe,\n            elevationScale=elevation_scale,\n            pickable=pickable,\n            opacity=opacity,\n            **kwargs,\n        )\n\n        self._deck_layers = {\n            **self._deck_layers,\n            layer_id: {\"type\": \"SolidPolygonLayer\", \"id\": layer_id},\n        }\n\n    def add_tile_layer(\n        self,\n        data: Union[str, List[str]],\n        name: Optional[str] = None,\n        min_zoom: int = 0,\n        max_zoom: int = 19,\n        tile_size: int = 256,\n        pickable: bool = False,\n        visible: bool = True,\n        opacity: float = 1.0,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a tile layer for raster tile visualization.\n\n        Args:\n            data: Tile URL template with {z}/{x}/{y} placeholders.\n            name: Layer ID.\n            min_zoom: Minimum zoom level.\n            max_zoom: Maximum zoom level.\n            tile_size: Tile size in pixels.\n            pickable: Whether layer responds to hover/click.\n            visible: Whether layer is visible.\n            opacity: Layer opacity (0-1).\n            **kwargs: Additional TileLayer props.\n        \"\"\"\n        layer_id = name or f\"tile-{len(self._deck_layers)}\"\n\n        self.call_js_method(\n            \"addTileLayer\",\n            id=layer_id,\n            data=data,\n            minZoom=min_zoom,\n            maxZoom=max_zoom,\n            tileSize=tile_size,\n            pickable=pickable,\n            visible=visible,\n            opacity=opacity,\n            **kwargs,\n        )\n\n        self._deck_layers = {\n            **self._deck_layers,\n            layer_id: {\"type\": \"TileLayer\", \"id\": layer_id},\n        }\n\n    def add_mvt_layer(\n        self,\n        data: Union[str, List[str]],\n        name: Optional[str] = None,\n        min_zoom: int = 0,\n        max_zoom: int = 14,\n        binary: bool = True,\n        get_fill_color: Union[List[int], str, Callable] = None,\n        get_line_color: Union[List[int], str, Callable] = None,\n        get_line_width: Union[float, str, Callable] = 1,\n        get_point_radius: Union[float, str, Callable] = 5,\n        line_width_min_pixels: float = 1,\n        point_radius_min_pixels: float = 2,\n        pickable: bool = True,\n        visible: bool = True,\n        opacity: float = 1.0,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a Mapbox Vector Tile (MVT) layer.\n\n        Args:\n            data: MVT tile URL template with {z}/{x}/{y} placeholders.\n            name: Layer ID.\n            min_zoom: Minimum zoom level.\n            max_zoom: Maximum zoom level.\n            binary: Whether to use binary format.\n            get_fill_color: Accessor for fill color [r, g, b, a].\n            get_line_color: Accessor for stroke color [r, g, b, a].\n            get_line_width: Accessor for line width.\n            get_point_radius: Accessor for point radius.\n            line_width_min_pixels: Minimum line width in pixels.\n            point_radius_min_pixels: Minimum point radius in pixels.\n            pickable: Whether layer responds to hover/click.\n            visible: Whether layer is visible.\n            opacity: Layer opacity (0-1).\n            **kwargs: Additional MVTLayer props.\n        \"\"\"\n        layer_id = name or f\"mvt-{len(self._deck_layers)}\"\n\n        self.call_js_method(\n            \"addMVTLayer\",\n            id=layer_id,\n            data=data,\n            minZoom=min_zoom,\n            maxZoom=max_zoom,\n            binary=binary,\n            getFillColor=get_fill_color or [51, 136, 255, 128],\n            getLineColor=get_line_color or [0, 0, 0, 255],\n            getLineWidth=get_line_width,\n            getPointRadius=get_point_radius,\n            lineWidthMinPixels=line_width_min_pixels,\n            pointRadiusMinPixels=point_radius_min_pixels,\n            pickable=pickable,\n            visible=visible,\n            opacity=opacity,\n            **kwargs,\n        )\n\n        self._deck_layers = {\n            **self._deck_layers,\n            layer_id: {\"type\": \"MVTLayer\", \"id\": layer_id},\n        }\n\n    def add_tile3d_layer(\n        self,\n        data: str,\n        name: Optional[str] = None,\n        point_size: float = 1,\n        pickable: bool = True,\n        visible: bool = True,\n        opacity: float = 1.0,\n        load_options: Optional[Dict] = None,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a 3D Tiles layer for 3D building/terrain visualization.\n\n        Args:\n            data: URL to tileset.json.\n            name: Layer ID.\n            point_size: Point size for point cloud tiles.\n            pickable: Whether layer responds to hover/click.\n            visible: Whether layer is visible.\n            opacity: Layer opacity (0-1).\n            load_options: Loader options for tile loading.\n            **kwargs: Additional Tile3DLayer props.\n        \"\"\"\n        layer_id = name or f\"tile3d-{len(self._deck_layers)}\"\n\n        self.call_js_method(\n            \"addTile3DLayer\",\n            id=layer_id,\n            data=data,\n            pointSize=point_size,\n            pickable=pickable,\n            visible=visible,\n            opacity=opacity,\n            loadOptions=load_options or {},\n            **kwargs,\n        )\n\n        self._deck_layers = {\n            **self._deck_layers,\n            layer_id: {\"type\": \"Tile3DLayer\", \"id\": layer_id},\n        }\n\n    def add_terrain_layer(\n        self,\n        elevation_data: Union[str, List[str]],\n        name: Optional[str] = None,\n        texture: Optional[str] = None,\n        mesh_max_error: float = 4.0,\n        bounds: Optional[List[float]] = None,\n        elevation_decoder: Optional[Dict] = None,\n        pickable: bool = False,\n        visible: bool = True,\n        opacity: float = 1.0,\n        wireframe: bool = False,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a terrain layer for 3D terrain visualization.\n\n        Args:\n            elevation_data: URL to elevation tiles (e.g., Mapbox terrain).\n            name: Layer ID.\n            texture: URL to texture tiles for terrain surface.\n            mesh_max_error: Maximum mesh error in meters.\n            bounds: Bounding box [west, south, east, north].\n            elevation_decoder: Decoder for elevation data format.\n            pickable: Whether layer responds to hover/click.\n            visible: Whether layer is visible.\n            opacity: Layer opacity (0-1).\n            wireframe: Whether to render as wireframe.\n            **kwargs: Additional TerrainLayer props.\n        \"\"\"\n        layer_id = name or f\"terrain-{len(self._deck_layers)}\"\n\n        default_decoder = {\n            \"rScaler\": 256,\n            \"gScaler\": 1,\n            \"bScaler\": 1 / 256,\n            \"offset\": -32768,\n        }\n\n        self.call_js_method(\n            \"addTerrainLayer\",\n            id=layer_id,\n            elevationData=elevation_data,\n            texture=texture,\n            meshMaxError=mesh_max_error,\n            bounds=bounds,\n            elevationDecoder=elevation_decoder or default_decoder,\n            pickable=pickable,\n            visible=visible,\n            opacity=opacity,\n            wireframe=wireframe,\n            **kwargs,\n        )\n\n        self._deck_layers = {\n            **self._deck_layers,\n            layer_id: {\"type\": \"TerrainLayer\", \"id\": layer_id},\n        }\n\n    def add_great_circle_layer(\n        self,\n        data: Any,\n        name: Optional[str] = None,\n        get_source_position: Union[str, Callable] = \"source\",\n        get_target_position: Union[str, Callable] = \"target\",\n        get_source_color: Union[List[int], str, Callable] = None,\n        get_target_color: Union[List[int], str, Callable] = None,\n        get_width: Union[float, str, Callable] = 1,\n        width_min_pixels: float = 1,\n        width_max_pixels: float = 100,\n        pickable: bool = True,\n        opacity: float = 0.8,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a great circle layer for geodesic arc visualization.\n\n        Args:\n            data: Array of data objects with source/target coordinates.\n            name: Layer ID.\n            get_source_position: Accessor for source position [lng, lat].\n            get_target_position: Accessor for target position [lng, lat].\n            get_source_color: Accessor for source color [r, g, b, a].\n            get_target_color: Accessor for target color [r, g, b, a].\n            get_width: Accessor for line width.\n            width_min_pixels: Minimum line width in pixels.\n            width_max_pixels: Maximum line width in pixels.\n            pickable: Whether layer responds to hover/click.\n            opacity: Layer opacity.\n            **kwargs: Additional GreatCircleLayer props.\n        \"\"\"\n        layer_id = name or f\"greatcircle-{len(self._deck_layers)}\"\n        processed_data = self._process_deck_data(data)\n\n        self.call_js_method(\n            \"addGreatCircleLayer\",\n            id=layer_id,\n            data=processed_data,\n            getSourcePosition=get_source_position,\n            getTargetPosition=get_target_position,\n            getSourceColor=get_source_color or [51, 136, 255, 255],\n            getTargetColor=get_target_color or [255, 136, 51, 255],\n            getWidth=get_width,\n            widthMinPixels=width_min_pixels,\n            widthMaxPixels=width_max_pixels,\n            pickable=pickable,\n            opacity=opacity,\n            **kwargs,\n        )\n\n        self._deck_layers = {\n            **self._deck_layers,\n            layer_id: {\"type\": \"GreatCircleLayer\", \"id\": layer_id},\n        }\n\n    def add_h3_hexagon_layer(\n        self,\n        data: Any,\n        name: Optional[str] = None,\n        get_hexagon: Union[str, Callable] = \"hexagon\",\n        get_fill_color: Union[List[int], str, Callable] = None,\n        get_line_color: Union[List[int], str, Callable] = None,\n        get_elevation: Union[float, str, Callable] = 0,\n        filled: bool = True,\n        stroked: bool = True,\n        extruded: bool = False,\n        wireframe: bool = False,\n        elevation_scale: float = 1,\n        coverage: float = 1,\n        high_precision: bool = False,\n        pickable: bool = True,\n        opacity: float = 0.8,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add an H3 hexagon layer for H3 spatial index visualization.\n\n        Args:\n            data: Array of data objects with H3 index.\n            name: Layer ID.\n            get_hexagon: Accessor for H3 index string.\n            get_fill_color: Accessor for fill color [r, g, b, a].\n            get_line_color: Accessor for stroke color [r, g, b, a].\n            get_elevation: Accessor for 3D extrusion height.\n            filled: Whether to fill hexagons.\n            stroked: Whether to stroke hexagons.\n            extruded: Whether to render as 3D hexagons.\n            wireframe: Whether to render wireframe.\n            elevation_scale: Elevation multiplier.\n            coverage: Hexagon coverage (0-1).\n            high_precision: Use high precision rendering.\n            pickable: Whether layer responds to hover/click.\n            opacity: Layer opacity.\n            **kwargs: Additional H3HexagonLayer props.\n        \"\"\"\n        layer_id = name or f\"h3hexagon-{len(self._deck_layers)}\"\n        processed_data = self._process_deck_data(data)\n\n        self.call_js_method(\n            \"addH3HexagonLayer\",\n            id=layer_id,\n            data=processed_data,\n            getHexagon=get_hexagon,\n            getFillColor=get_fill_color or [51, 136, 255, 128],\n            getLineColor=get_line_color or [0, 0, 0, 255],\n            getElevation=get_elevation,\n            filled=filled,\n            stroked=stroked,\n            extruded=extruded,\n            wireframe=wireframe,\n            elevationScale=elevation_scale,\n            coverage=coverage,\n            highPrecision=high_precision,\n            pickable=pickable,\n            opacity=opacity,\n            **kwargs,\n        )\n\n        self._deck_layers = {\n            **self._deck_layers,\n            layer_id: {\"type\": \"H3HexagonLayer\", \"id\": layer_id},\n        }\n\n    def add_h3_cluster_layer(\n        self,\n        data: Any,\n        name: Optional[str] = None,\n        get_hexagons: Union[str, Callable] = \"hexagons\",\n        get_fill_color: Union[List[int], str, Callable] = None,\n        get_line_color: Union[List[int], str, Callable] = None,\n        get_line_width: Union[float, str, Callable] = 1,\n        filled: bool = True,\n        stroked: bool = True,\n        extruded: bool = False,\n        elevation_scale: float = 1,\n        pickable: bool = True,\n        opacity: float = 0.8,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add an H3 cluster layer for grouped H3 cell visualization.\n\n        Args:\n            data: Array of data objects with H3 index arrays.\n            name: Layer ID.\n            get_hexagons: Accessor for array of H3 index strings.\n            get_fill_color: Accessor for fill color [r, g, b, a].\n            get_line_color: Accessor for stroke color [r, g, b, a].\n            get_line_width: Accessor for line width.\n            filled: Whether to fill clusters.\n            stroked: Whether to stroke clusters.\n            extruded: Whether to render as 3D.\n            elevation_scale: Elevation multiplier.\n            pickable: Whether layer responds to hover/click.\n            opacity: Layer opacity.\n            **kwargs: Additional H3ClusterLayer props.\n        \"\"\"\n        layer_id = name or f\"h3cluster-{len(self._deck_layers)}\"\n        processed_data = self._process_deck_data(data)\n\n        self.call_js_method(\n            \"addH3ClusterLayer\",\n            id=layer_id,\n            data=processed_data,\n            getHexagons=get_hexagons,\n            getFillColor=get_fill_color or [51, 136, 255, 128],\n            getLineColor=get_line_color or [0, 0, 0, 255],\n            getLineWidth=get_line_width,\n            filled=filled,\n            stroked=stroked,\n            extruded=extruded,\n            elevationScale=elevation_scale,\n            pickable=pickable,\n            opacity=opacity,\n            **kwargs,\n        )\n\n        self._deck_layers = {\n            **self._deck_layers,\n            layer_id: {\"type\": \"H3ClusterLayer\", \"id\": layer_id},\n        }\n\n    def add_s2_layer(\n        self,\n        data: Any,\n        name: Optional[str] = None,\n        get_s2_token: Union[str, Callable] = \"s2Token\",\n        get_fill_color: Union[List[int], str, Callable] = None,\n        get_line_color: Union[List[int], str, Callable] = None,\n        get_line_width: Union[float, str, Callable] = 1,\n        get_elevation: Union[float, str, Callable] = 0,\n        filled: bool = True,\n        stroked: bool = True,\n        extruded: bool = False,\n        wireframe: bool = False,\n        elevation_scale: float = 1,\n        pickable: bool = True,\n        opacity: float = 0.8,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add an S2 layer for S2 geometry cell visualization.\n\n        Args:\n            data: Array of data objects with S2 token.\n            name: Layer ID.\n            get_s2_token: Accessor for S2 token string.\n            get_fill_color: Accessor for fill color [r, g, b, a].\n            get_line_color: Accessor for stroke color [r, g, b, a].\n            get_line_width: Accessor for line width.\n            get_elevation: Accessor for 3D extrusion height.\n            filled: Whether to fill cells.\n            stroked: Whether to stroke cells.\n            extruded: Whether to render as 3D.\n            wireframe: Whether to render wireframe.\n            elevation_scale: Elevation multiplier.\n            pickable: Whether layer responds to hover/click.\n            opacity: Layer opacity.\n            **kwargs: Additional S2Layer props.\n        \"\"\"\n        layer_id = name or f\"s2-{len(self._deck_layers)}\"\n        processed_data = self._process_deck_data(data)\n\n        self.call_js_method(\n            \"addS2Layer\",\n            id=layer_id,\n            data=processed_data,\n            getS2Token=get_s2_token,\n            getFillColor=get_fill_color or [51, 136, 255, 128],\n            getLineColor=get_line_color or [0, 0, 0, 255],\n            getLineWidth=get_line_width,\n            getElevation=get_elevation,\n            filled=filled,\n            stroked=stroked,\n            extruded=extruded,\n            wireframe=wireframe,\n            elevationScale=elevation_scale,\n            pickable=pickable,\n            opacity=opacity,\n            **kwargs,\n        )\n\n        self._deck_layers = {\n            **self._deck_layers,\n            layer_id: {\"type\": \"S2Layer\", \"id\": layer_id},\n        }\n\n    def add_quadkey_layer(\n        self,\n        data: Any,\n        name: Optional[str] = None,\n        get_quadkey: Union[str, Callable] = \"quadkey\",\n        get_fill_color: Union[List[int], str, Callable] = None,\n        get_line_color: Union[List[int], str, Callable] = None,\n        get_line_width: Union[float, str, Callable] = 1,\n        get_elevation: Union[float, str, Callable] = 0,\n        filled: bool = True,\n        stroked: bool = True,\n        extruded: bool = False,\n        wireframe: bool = False,\n        elevation_scale: float = 1,\n        pickable: bool = True,\n        opacity: float = 0.8,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a Quadkey layer for Bing Maps tile index visualization.\n\n        Args:\n            data: Array of data objects with quadkey.\n            name: Layer ID.\n            get_quadkey: Accessor for quadkey string.\n            get_fill_color: Accessor for fill color [r, g, b, a].\n            get_line_color: Accessor for stroke color [r, g, b, a].\n            get_line_width: Accessor for line width.\n            get_elevation: Accessor for 3D extrusion height.\n            filled: Whether to fill cells.\n            stroked: Whether to stroke cells.\n            extruded: Whether to render as 3D.\n            wireframe: Whether to render wireframe.\n            elevation_scale: Elevation multiplier.\n            pickable: Whether layer responds to hover/click.\n            opacity: Layer opacity.\n            **kwargs: Additional QuadkeyLayer props.\n        \"\"\"\n        layer_id = name or f\"quadkey-{len(self._deck_layers)}\"\n        processed_data = self._process_deck_data(data)\n\n        self.call_js_method(\n            \"addQuadkeyLayer\",\n            id=layer_id,\n            data=processed_data,\n            getQuadkey=get_quadkey,\n            getFillColor=get_fill_color or [51, 136, 255, 128],\n            getLineColor=get_line_color or [0, 0, 0, 255],\n            getLineWidth=get_line_width,\n            getElevation=get_elevation,\n            filled=filled,\n            stroked=stroked,\n            extruded=extruded,\n            wireframe=wireframe,\n            elevationScale=elevation_scale,\n            pickable=pickable,\n            opacity=opacity,\n            **kwargs,\n        )\n\n        self._deck_layers = {\n            **self._deck_layers,\n            layer_id: {\"type\": \"QuadkeyLayer\", \"id\": layer_id},\n        }\n\n    def add_geohash_layer(\n        self,\n        data: Any,\n        name: Optional[str] = None,\n        get_geohash: Union[str, Callable] = \"geohash\",\n        get_fill_color: Union[List[int], str, Callable] = None,\n        get_line_color: Union[List[int], str, Callable] = None,\n        get_line_width: Union[float, str, Callable] = 1,\n        get_elevation: Union[float, str, Callable] = 0,\n        filled: bool = True,\n        stroked: bool = True,\n        extruded: bool = False,\n        wireframe: bool = False,\n        elevation_scale: float = 1,\n        pickable: bool = True,\n        opacity: float = 0.8,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a Geohash layer for geohash cell visualization.\n\n        Args:\n            data: Array of data objects with geohash.\n            name: Layer ID.\n            get_geohash: Accessor for geohash string.\n            get_fill_color: Accessor for fill color [r, g, b, a].\n            get_line_color: Accessor for stroke color [r, g, b, a].\n            get_line_width: Accessor for line width.\n            get_elevation: Accessor for 3D extrusion height.\n            filled: Whether to fill cells.\n            stroked: Whether to stroke cells.\n            extruded: Whether to render as 3D.\n            wireframe: Whether to render wireframe.\n            elevation_scale: Elevation multiplier.\n            pickable: Whether layer responds to hover/click.\n            opacity: Layer opacity.\n            **kwargs: Additional GeohashLayer props.\n        \"\"\"\n        layer_id = name or f\"geohash-{len(self._deck_layers)}\"\n        processed_data = self._process_deck_data(data)\n\n        self.call_js_method(\n            \"addGeohashLayer\",\n            id=layer_id,\n            data=processed_data,\n            getGeohash=get_geohash,\n            getFillColor=get_fill_color or [51, 136, 255, 128],\n            getLineColor=get_line_color or [0, 0, 0, 255],\n            getLineWidth=get_line_width,\n            getElevation=get_elevation,\n            filled=filled,\n            stroked=stroked,\n            extruded=extruded,\n            wireframe=wireframe,\n            elevationScale=elevation_scale,\n            pickable=pickable,\n            opacity=opacity,\n            **kwargs,\n        )\n\n        self._deck_layers = {\n            **self._deck_layers,\n            layer_id: {\"type\": \"GeohashLayer\", \"id\": layer_id},\n        }\n\n    def add_wms_layer(\n        self,\n        data: str,\n        name: Optional[str] = None,\n        service_type: str = \"wms\",\n        layers: Optional[List[str]] = None,\n        srs: Optional[str] = None,\n        pickable: bool = False,\n        visible: bool = True,\n        opacity: float = 1.0,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a WMS layer for OGC Web Map Service visualization.\n\n        Args:\n            data: WMS base URL.\n            name: Layer ID.\n            service_type: Service type ('wms' or 'template').\n            layers: WMS layer names to request.\n            srs: Spatial reference system (e.g., 'EPSG:4326').\n            pickable: Whether layer responds to hover/click.\n            visible: Whether layer is visible.\n            opacity: Layer opacity (0-1).\n            **kwargs: Additional WMSLayer props.\n        \"\"\"\n        layer_id = name or f\"wms-{len(self._deck_layers)}\"\n\n        self.call_js_method(\n            \"addWMSLayer\",\n            id=layer_id,\n            data=data,\n            serviceType=service_type,\n            layers=layers,\n            srs=srs,\n            pickable=pickable,\n            visible=visible,\n            opacity=opacity,\n            **kwargs,\n        )\n\n        self._deck_layers = {\n            **self._deck_layers,\n            layer_id: {\"type\": \"WMSLayer\", \"id\": layer_id},\n        }\n\n    def add_simple_mesh_layer(\n        self,\n        data: Any,\n        mesh: str,\n        name: Optional[str] = None,\n        texture: Optional[str] = None,\n        get_position: Union[str, Callable] = \"coordinates\",\n        get_color: Union[List[int], str, Callable] = None,\n        get_orientation: Union[str, Callable] = None,\n        get_scale: Union[str, Callable] = None,\n        get_translation: Union[str, Callable] = None,\n        size_scale: float = 1,\n        wireframe: bool = False,\n        pickable: bool = True,\n        opacity: float = 1.0,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a simple mesh layer for 3D mesh visualization.\n\n        Args:\n            data: Array of data objects with position coordinates.\n            mesh: URL to OBJ/glTF mesh file.\n            name: Layer ID.\n            texture: URL to texture image.\n            get_position: Accessor for mesh position [lng, lat, z].\n            get_color: Accessor for mesh color [r, g, b, a].\n            get_orientation: Accessor for mesh orientation [pitch, yaw, roll].\n            get_scale: Accessor for mesh scale [x, y, z].\n            get_translation: Accessor for mesh translation [x, y, z].\n            size_scale: Global size multiplier.\n            wireframe: Whether to render as wireframe.\n            pickable: Whether layer responds to hover/click.\n            opacity: Layer opacity (0-1).\n            **kwargs: Additional SimpleMeshLayer props.\n        \"\"\"\n        layer_id = name or f\"simplemesh-{len(self._deck_layers)}\"\n        processed_data = self._process_deck_data(data)\n\n        layer_kwargs = {\n            \"id\": layer_id,\n            \"data\": processed_data,\n            \"mesh\": mesh,\n            \"getPosition\": get_position,\n            \"getColor\": get_color or [255, 255, 255, 255],\n            \"sizeScale\": size_scale,\n            \"wireframe\": wireframe,\n            \"pickable\": pickable,\n            \"opacity\": opacity,\n        }\n\n        if texture:\n            layer_kwargs[\"texture\"] = texture\n        if get_orientation:\n            layer_kwargs[\"getOrientation\"] = get_orientation\n        if get_scale:\n            layer_kwargs[\"getScale\"] = get_scale\n        if get_translation:\n            layer_kwargs[\"getTranslation\"] = get_translation\n\n        layer_kwargs.update(kwargs)\n        self.call_js_method(\"addSimpleMeshLayer\", **layer_kwargs)\n\n        self._deck_layers = {\n            **self._deck_layers,\n            layer_id: {\"type\": \"SimpleMeshLayer\", \"id\": layer_id},\n        }\n\n    def add_scenegraph_layer(\n        self,\n        data: Any,\n        scenegraph: str,\n        name: Optional[str] = None,\n        get_position: Union[str, Callable] = \"coordinates\",\n        get_color: Union[List[int], str, Callable] = None,\n        get_orientation: Union[str, Callable] = None,\n        get_scale: Union[str, Callable] = None,\n        get_translation: Union[str, Callable] = None,\n        size_scale: float = 1,\n        size_min_pixels: float = 0,\n        size_max_pixels: float = 10000,\n        pickable: bool = True,\n        opacity: float = 1.0,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a scenegraph layer for glTF model visualization.\n\n        Args:\n            data: Array of data objects with position coordinates.\n            scenegraph: URL to glTF/GLB model file.\n            name: Layer ID.\n            get_position: Accessor for model position [lng, lat, z].\n            get_color: Accessor for model tint color [r, g, b, a].\n            get_orientation: Accessor for model orientation [pitch, yaw, roll].\n            get_scale: Accessor for model scale [x, y, z].\n            get_translation: Accessor for model translation [x, y, z].\n            size_scale: Global size multiplier.\n            size_min_pixels: Minimum model size in pixels.\n            size_max_pixels: Maximum model size in pixels.\n            pickable: Whether layer responds to hover/click.\n            opacity: Layer opacity (0-1).\n            **kwargs: Additional ScenegraphLayer props.\n        \"\"\"\n        layer_id = name or f\"scenegraph-{len(self._deck_layers)}\"\n        processed_data = self._process_deck_data(data)\n\n        layer_kwargs = {\n            \"id\": layer_id,\n            \"data\": processed_data,\n            \"scenegraph\": scenegraph,\n            \"getPosition\": get_position,\n            \"getColor\": get_color or [255, 255, 255, 255],\n            \"sizeScale\": size_scale,\n            \"sizeMinPixels\": size_min_pixels,\n            \"sizeMaxPixels\": size_max_pixels,\n            \"pickable\": pickable,\n            \"opacity\": opacity,\n        }\n\n        if get_orientation:\n            layer_kwargs[\"getOrientation\"] = get_orientation\n        if get_scale:\n            layer_kwargs[\"getScale\"] = get_scale\n        if get_translation:\n            layer_kwargs[\"getTranslation\"] = get_translation\n\n        layer_kwargs.update(kwargs)\n        self.call_js_method(\"addScenegraphLayer\", **layer_kwargs)\n\n        self._deck_layers = {\n            **self._deck_layers,\n            layer_id: {\"type\": \"ScenegraphLayer\", \"id\": layer_id},\n        }\n\n    def remove_cog_layer(self, layer_id: str) -&gt; None:\n        \"\"\"Remove a COG layer.\n\n        Args:\n            layer_id: Layer identifier to remove.\n        \"\"\"\n        self.remove_deck_layer(layer_id)\n\n    # -------------------------------------------------------------------------\n    # DeckGL Layer Management\n    # -------------------------------------------------------------------------\n\n    def remove_deck_layer(self, layer_id: str) -&gt; None:\n        \"\"\"Remove a deck.gl layer.\n\n        Args:\n            layer_id: Layer identifier to remove.\n        \"\"\"\n        if layer_id in self._deck_layers:\n            layers = dict(self._deck_layers)\n            del layers[layer_id]\n            self._deck_layers = layers\n        self.call_js_method(\"removeDeckLayer\", layer_id)\n\n    def set_deck_layer_visibility(self, layer_id: str, visible: bool) -&gt; None:\n        \"\"\"Set deck.gl layer visibility.\n\n        Args:\n            layer_id: Layer identifier.\n            visible: Whether layer should be visible.\n        \"\"\"\n        self.call_js_method(\"setDeckLayerVisibility\", layer_id, visible)\n\n    # -------------------------------------------------------------------------\n    # Data Processing Helpers\n    # -------------------------------------------------------------------------\n\n    def _process_deck_data(self, data: Any) -&gt; Any:\n        \"\"\"Process data for deck.gl layers.\n\n        Handles GeoDataFrame, GeoJSON, and list of dicts.\n\n        Args:\n            data: Input data in various formats.\n\n        Returns:\n            Processed data suitable for deck.gl.\n        \"\"\"\n        # Handle GeoDataFrame\n        if hasattr(data, \"__geo_interface__\"):\n            return json.loads(data.to_json())\n\n        # Handle file path\n        if isinstance(data, (str, Path)):\n            path = Path(data)\n            if path.exists() and path.suffix.lower() in [\".geojson\", \".json\"]:\n                with open(path) as f:\n                    return json.load(f)\n            # Could be URL, return as-is\n            return str(data)\n\n        # Handle dict (GeoJSON or config)\n        if isinstance(data, dict):\n            return data\n\n        # Handle list of dicts\n        if isinstance(data, list):\n            return data\n\n        return data\n\n    # -------------------------------------------------------------------------\n    # HTML Export\n    # -------------------------------------------------------------------------\n\n    def _generate_html_template(self) -&gt; str:\n        \"\"\"Generate standalone HTML for the DeckGL map.\"\"\"\n        template_path = Path(__file__).parent / \"templates\" / \"deckgl.html\"\n\n        if template_path.exists():\n            template = template_path.read_text(encoding=\"utf-8\")\n        else:\n            template = self._get_default_template()\n\n        # Serialize state\n        state = {\n            \"center\": self.center,\n            \"zoom\": self.zoom,\n            \"style\": self.style,\n            \"bearing\": self.bearing,\n            \"pitch\": self.pitch,\n            \"width\": self.width,\n            \"height\": self.height,\n            \"layers\": self._layers,\n            \"sources\": self._sources,\n            \"controls\": self._controls,\n            \"deckLayers\": self._deck_layers,\n            \"js_calls\": self._js_calls,\n        }\n\n        template = template.replace(\"{{state}}\", json.dumps(state, indent=2))\n        return template\n</code></pre>"},{"location":"deckgl/#anymap_ts.deckgl.DeckGLMap.__init__","title":"<code>__init__(self, center=(0.0, 0.0), zoom=2.0, width='100%', height='600px', style='https://demotiles.maplibre.org/style.json', bearing=0.0, pitch=0.0, max_pitch=85.0, controls=None, **kwargs)</code>  <code>special</code>","text":"<p>Initialize a DeckGL map.</p> <p>Parameters:</p> Name Type Description Default <code>center</code> <code>Tuple[float, float]</code> <p>Map center as (longitude, latitude).</p> <code>(0.0, 0.0)</code> <code>zoom</code> <code>float</code> <p>Initial zoom level.</p> <code>2.0</code> <code>width</code> <code>str</code> <p>Map width as CSS string.</p> <code>'100%'</code> <code>height</code> <code>str</code> <p>Map height as CSS string.</p> <code>'600px'</code> <code>style</code> <code>Union[str, Dict]</code> <p>MapLibre style URL or style object.</p> <code>'https://demotiles.maplibre.org/style.json'</code> <code>bearing</code> <code>float</code> <p>Map bearing in degrees.</p> <code>0.0</code> <code>pitch</code> <code>float</code> <p>Map pitch in degrees.</p> <code>0.0</code> <code>max_pitch</code> <code>float</code> <p>Maximum pitch angle in degrees (default: 85).</p> <code>85.0</code> <code>controls</code> <code>Optional[Dict[str, Any]]</code> <p>Dict of controls to add (e.g., {\"navigation\": True}).</p> <code>None</code> <code>**kwargs</code> <p>Additional widget arguments.</p> <code>{}</code> Source code in <code>anymap_ts/deckgl.py</code> <pre><code>def __init__(\n    self,\n    center: Tuple[float, float] = (0.0, 0.0),\n    zoom: float = 2.0,\n    width: str = \"100%\",\n    height: str = \"600px\",\n    style: Union[str, Dict] = \"https://demotiles.maplibre.org/style.json\",\n    bearing: float = 0.0,\n    pitch: float = 0.0,\n    max_pitch: float = 85.0,\n    controls: Optional[Dict[str, Any]] = None,\n    **kwargs,\n):\n    \"\"\"Initialize a DeckGL map.\n\n    Args:\n        center: Map center as (longitude, latitude).\n        zoom: Initial zoom level.\n        width: Map width as CSS string.\n        height: Map height as CSS string.\n        style: MapLibre style URL or style object.\n        bearing: Map bearing in degrees.\n        pitch: Map pitch in degrees.\n        max_pitch: Maximum pitch angle in degrees (default: 85).\n        controls: Dict of controls to add (e.g., {\"navigation\": True}).\n        **kwargs: Additional widget arguments.\n    \"\"\"\n    super().__init__(\n        center=center,\n        zoom=zoom,\n        width=width,\n        height=height,\n        style=style,\n        bearing=bearing,\n        pitch=pitch,\n        max_pitch=max_pitch,\n        controls=controls,\n        **kwargs,\n    )\n    self._deck_layers = {}\n</code></pre>"},{"location":"deckgl/#anymap_ts.deckgl.DeckGLMap.add_arc_layer","title":"<code>add_arc_layer(self, data, name=None, get_source_position='source', get_target_position='target', get_source_color=None, get_target_color=None, get_width=1, pickable=True, opacity=0.8, **kwargs)</code>","text":"<p>Add an arc layer for origin-destination visualization.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>Array of data objects with source/target coordinates.</p> required <code>name</code> <code>Optional[str]</code> <p>Layer ID.</p> <code>None</code> <code>get_source_position</code> <code>Union[str, Callable]</code> <p>Accessor for source position [lng, lat].</p> <code>'source'</code> <code>get_target_position</code> <code>Union[str, Callable]</code> <p>Accessor for target position [lng, lat].</p> <code>'target'</code> <code>get_source_color</code> <code>Union[List[int], str, Callable]</code> <p>Accessor for source color [r, g, b, a].</p> <code>None</code> <code>get_target_color</code> <code>Union[List[int], str, Callable]</code> <p>Accessor for target color [r, g, b, a].</p> <code>None</code> <code>get_width</code> <code>Union[float, str, Callable]</code> <p>Accessor for arc width.</p> <code>1</code> <code>pickable</code> <code>bool</code> <p>Whether layer responds to hover/click.</p> <code>True</code> <code>opacity</code> <code>float</code> <p>Layer opacity.</p> <code>0.8</code> <code>**kwargs</code> <p>Additional layer props.</p> <code>{}</code> Source code in <code>anymap_ts/deckgl.py</code> <pre><code>def add_arc_layer(\n    self,\n    data: Any,\n    name: Optional[str] = None,\n    get_source_position: Union[str, Callable] = \"source\",\n    get_target_position: Union[str, Callable] = \"target\",\n    get_source_color: Union[List[int], str, Callable] = None,\n    get_target_color: Union[List[int], str, Callable] = None,\n    get_width: Union[float, str, Callable] = 1,\n    pickable: bool = True,\n    opacity: float = 0.8,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add an arc layer for origin-destination visualization.\n\n    Args:\n        data: Array of data objects with source/target coordinates.\n        name: Layer ID.\n        get_source_position: Accessor for source position [lng, lat].\n        get_target_position: Accessor for target position [lng, lat].\n        get_source_color: Accessor for source color [r, g, b, a].\n        get_target_color: Accessor for target color [r, g, b, a].\n        get_width: Accessor for arc width.\n        pickable: Whether layer responds to hover/click.\n        opacity: Layer opacity.\n        **kwargs: Additional layer props.\n    \"\"\"\n    layer_id = name or f\"arc-{len(self._deck_layers)}\"\n    processed_data = self._process_deck_data(data)\n\n    self.call_js_method(\n        \"addArcLayer\",\n        id=layer_id,\n        data=processed_data,\n        getSourcePosition=get_source_position,\n        getTargetPosition=get_target_position,\n        getSourceColor=get_source_color or [51, 136, 255, 255],\n        getTargetColor=get_target_color or [255, 136, 51, 255],\n        getWidth=get_width,\n        pickable=pickable,\n        opacity=opacity,\n        **kwargs,\n    )\n\n    self._deck_layers = {\n        **self._deck_layers,\n        layer_id: {\"type\": \"ArcLayer\", \"id\": layer_id},\n    }\n</code></pre>"},{"location":"deckgl/#anymap_ts.deckgl.DeckGLMap.add_bitmap_layer","title":"<code>add_bitmap_layer(self, image, bounds, name=None, opacity=1.0, visible=True, pickable=False, desaturate=0, transparent_color=None, tint_color=None, **kwargs)</code>","text":"<p>Add a bitmap layer for raster image overlay.</p> <p>Parameters:</p> Name Type Description Default <code>image</code> <code>str</code> <p>URL or data URI of the image.</p> required <code>bounds</code> <code>List[float]</code> <p>Bounding box [west, south, east, north].</p> required <code>name</code> <code>Optional[str]</code> <p>Layer ID.</p> <code>None</code> <code>opacity</code> <code>float</code> <p>Layer opacity (0-1).</p> <code>1.0</code> <code>visible</code> <code>bool</code> <p>Whether layer is visible.</p> <code>True</code> <code>pickable</code> <code>bool</code> <p>Whether layer responds to hover/click.</p> <code>False</code> <code>desaturate</code> <code>float</code> <p>Desaturation amount (0-1).</p> <code>0</code> <code>transparent_color</code> <code>Optional[List[int]]</code> <p>Color to make transparent [r, g, b, a].</p> <code>None</code> <code>tint_color</code> <code>Optional[List[int]]</code> <p>Color to tint the image [r, g, b].</p> <code>None</code> <code>**kwargs</code> <p>Additional BitmapLayer props.</p> <code>{}</code> Source code in <code>anymap_ts/deckgl.py</code> <pre><code>def add_bitmap_layer(\n    self,\n    image: str,\n    bounds: List[float],\n    name: Optional[str] = None,\n    opacity: float = 1.0,\n    visible: bool = True,\n    pickable: bool = False,\n    desaturate: float = 0,\n    transparent_color: Optional[List[int]] = None,\n    tint_color: Optional[List[int]] = None,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a bitmap layer for raster image overlay.\n\n    Args:\n        image: URL or data URI of the image.\n        bounds: Bounding box [west, south, east, north].\n        name: Layer ID.\n        opacity: Layer opacity (0-1).\n        visible: Whether layer is visible.\n        pickable: Whether layer responds to hover/click.\n        desaturate: Desaturation amount (0-1).\n        transparent_color: Color to make transparent [r, g, b, a].\n        tint_color: Color to tint the image [r, g, b].\n        **kwargs: Additional BitmapLayer props.\n    \"\"\"\n    layer_id = name or f\"bitmap-{len(self._deck_layers)}\"\n\n    self.call_js_method(\n        \"addBitmapLayer\",\n        id=layer_id,\n        image=image,\n        bounds=bounds,\n        opacity=opacity,\n        visible=visible,\n        pickable=pickable,\n        desaturate=desaturate,\n        transparentColor=transparent_color or [0, 0, 0, 0],\n        tintColor=tint_color or [255, 255, 255],\n        **kwargs,\n    )\n\n    self._deck_layers = {\n        **self._deck_layers,\n        layer_id: {\"type\": \"BitmapLayer\", \"id\": layer_id},\n    }\n</code></pre>"},{"location":"deckgl/#anymap_ts.deckgl.DeckGLMap.add_cog_layer","title":"<code>add_cog_layer(self, url, name=None, opacity=1.0, visible=True, debug=False, debug_opacity=0.25, max_error=0.125, fit_bounds=True, before_id=None, **kwargs)</code>","text":"<p>Add a Cloud Optimized GeoTIFF (COG) layer using @developmentseed/deck.gl-geotiff.</p> <p>This method renders COG files directly in the browser using GPU-accelerated deck.gl rendering with automatic reprojection support.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>URL to the Cloud Optimized GeoTIFF file.</p> required <code>name</code> <code>Optional[str]</code> <p>Layer ID. If None, auto-generated.</p> <code>None</code> <code>opacity</code> <code>float</code> <p>Layer opacity (0-1).</p> <code>1.0</code> <code>visible</code> <code>bool</code> <p>Whether layer is visible.</p> <code>True</code> <code>debug</code> <code>bool</code> <p>Show reprojection mesh for debugging.</p> <code>False</code> <code>debug_opacity</code> <code>float</code> <p>Opacity of debug mesh (0-1).</p> <code>0.25</code> <code>max_error</code> <code>float</code> <p>Maximum reprojection error in pixels. Lower values create denser mesh for better accuracy.</p> <code>0.125</code> <code>fit_bounds</code> <code>bool</code> <p>Whether to fit map to COG bounds after loading.</p> <code>True</code> <code>before_id</code> <code>Optional[str]</code> <p>ID of layer to insert before.</p> <code>None</code> <code>**kwargs</code> <p>Additional COGLayer props.</p> <code>{}</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; m = DeckGLMap()\n&gt;&gt;&gt; m.add_cog_layer(\n...     \"https://example.com/landcover.tif\",\n...     name=\"landcover\",\n...     opacity=0.8\n... )\n</code></pre> Source code in <code>anymap_ts/deckgl.py</code> <pre><code>def add_cog_layer(\n    self,\n    url: str,\n    name: Optional[str] = None,\n    opacity: float = 1.0,\n    visible: bool = True,\n    debug: bool = False,\n    debug_opacity: float = 0.25,\n    max_error: float = 0.125,\n    fit_bounds: bool = True,\n    before_id: Optional[str] = None,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a Cloud Optimized GeoTIFF (COG) layer using @developmentseed/deck.gl-geotiff.\n\n    This method renders COG files directly in the browser using GPU-accelerated\n    deck.gl rendering with automatic reprojection support.\n\n    Args:\n        url: URL to the Cloud Optimized GeoTIFF file.\n        name: Layer ID. If None, auto-generated.\n        opacity: Layer opacity (0-1).\n        visible: Whether layer is visible.\n        debug: Show reprojection mesh for debugging.\n        debug_opacity: Opacity of debug mesh (0-1).\n        max_error: Maximum reprojection error in pixels. Lower values\n            create denser mesh for better accuracy.\n        fit_bounds: Whether to fit map to COG bounds after loading.\n        before_id: ID of layer to insert before.\n        **kwargs: Additional COGLayer props.\n\n    Example:\n        &gt;&gt;&gt; m = DeckGLMap()\n        &gt;&gt;&gt; m.add_cog_layer(\n        ...     \"https://example.com/landcover.tif\",\n        ...     name=\"landcover\",\n        ...     opacity=0.8\n        ... )\n    \"\"\"\n    # Use a monotonically increasing counter to avoid ID collisions when layers are removed.\n    counter = getattr(self, \"_cog_layer_counter\", 0)\n    layer_id = name or f\"cog-{counter}\"\n    self._cog_layer_counter = counter + 1\n\n    self.call_js_method(\n        \"addCOGLayer\",\n        id=layer_id,\n        geotiff=url,\n        opacity=opacity,\n        visible=visible,\n        debug=debug,\n        debugOpacity=debug_opacity,\n        maxError=max_error,\n        fitBounds=fit_bounds,\n        beforeId=before_id,\n        **kwargs,\n    )\n\n    self._deck_layers = {\n        **self._deck_layers,\n        layer_id: {\"type\": \"COGLayer\", \"id\": layer_id, \"url\": url},\n    }\n</code></pre>"},{"location":"deckgl/#anymap_ts.deckgl.DeckGLMap.add_column_layer","title":"<code>add_column_layer(self, data, name=None, get_position='coordinates', get_fill_color=None, get_line_color=None, get_elevation=1000, radius=1000, disk_resolution=20, elevation_scale=1, coverage=1, extruded=True, filled=True, stroked=False, wireframe=False, pickable=True, opacity=0.8, **kwargs)</code>","text":"<p>Add a column layer for 3D column/bar visualization.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>Array of data objects with position coordinates.</p> required <code>name</code> <code>Optional[str]</code> <p>Layer ID.</p> <code>None</code> <code>get_position</code> <code>Union[str, Callable]</code> <p>Accessor for column position [lng, lat].</p> <code>'coordinates'</code> <code>get_fill_color</code> <code>Union[List[int], str, Callable]</code> <p>Accessor for fill color [r, g, b, a].</p> <code>None</code> <code>get_line_color</code> <code>Union[List[int], str, Callable]</code> <p>Accessor for stroke color [r, g, b, a].</p> <code>None</code> <code>get_elevation</code> <code>Union[float, str, Callable]</code> <p>Accessor for column height.</p> <code>1000</code> <code>radius</code> <code>float</code> <p>Column radius in meters.</p> <code>1000</code> <code>disk_resolution</code> <code>int</code> <p>Number of sides for column polygon.</p> <code>20</code> <code>elevation_scale</code> <code>float</code> <p>Elevation multiplier.</p> <code>1</code> <code>coverage</code> <code>float</code> <p>Column coverage (0-1).</p> <code>1</code> <code>extruded</code> <code>bool</code> <p>Whether to extrude columns.</p> <code>True</code> <code>filled</code> <code>bool</code> <p>Whether to fill columns.</p> <code>True</code> <code>stroked</code> <code>bool</code> <p>Whether to stroke columns.</p> <code>False</code> <code>wireframe</code> <code>bool</code> <p>Whether to render as wireframe.</p> <code>False</code> <code>pickable</code> <code>bool</code> <p>Whether layer responds to hover/click.</p> <code>True</code> <code>opacity</code> <code>float</code> <p>Layer opacity.</p> <code>0.8</code> <code>**kwargs</code> <p>Additional ColumnLayer props.</p> <code>{}</code> Source code in <code>anymap_ts/deckgl.py</code> <pre><code>def add_column_layer(\n    self,\n    data: Any,\n    name: Optional[str] = None,\n    get_position: Union[str, Callable] = \"coordinates\",\n    get_fill_color: Union[List[int], str, Callable] = None,\n    get_line_color: Union[List[int], str, Callable] = None,\n    get_elevation: Union[float, str, Callable] = 1000,\n    radius: float = 1000,\n    disk_resolution: int = 20,\n    elevation_scale: float = 1,\n    coverage: float = 1,\n    extruded: bool = True,\n    filled: bool = True,\n    stroked: bool = False,\n    wireframe: bool = False,\n    pickable: bool = True,\n    opacity: float = 0.8,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a column layer for 3D column/bar visualization.\n\n    Args:\n        data: Array of data objects with position coordinates.\n        name: Layer ID.\n        get_position: Accessor for column position [lng, lat].\n        get_fill_color: Accessor for fill color [r, g, b, a].\n        get_line_color: Accessor for stroke color [r, g, b, a].\n        get_elevation: Accessor for column height.\n        radius: Column radius in meters.\n        disk_resolution: Number of sides for column polygon.\n        elevation_scale: Elevation multiplier.\n        coverage: Column coverage (0-1).\n        extruded: Whether to extrude columns.\n        filled: Whether to fill columns.\n        stroked: Whether to stroke columns.\n        wireframe: Whether to render as wireframe.\n        pickable: Whether layer responds to hover/click.\n        opacity: Layer opacity.\n        **kwargs: Additional ColumnLayer props.\n    \"\"\"\n    layer_id = name or f\"column-{len(self._deck_layers)}\"\n    processed_data = self._process_deck_data(data)\n\n    self.call_js_method(\n        \"addColumnLayer\",\n        id=layer_id,\n        data=processed_data,\n        getPosition=get_position,\n        getFillColor=get_fill_color or [255, 140, 0, 200],\n        getLineColor=get_line_color or [0, 0, 0, 255],\n        getElevation=get_elevation,\n        radius=radius,\n        diskResolution=disk_resolution,\n        elevationScale=elevation_scale,\n        coverage=coverage,\n        extruded=extruded,\n        filled=filled,\n        stroked=stroked,\n        wireframe=wireframe,\n        pickable=pickable,\n        opacity=opacity,\n        **kwargs,\n    )\n\n    self._deck_layers = {\n        **self._deck_layers,\n        layer_id: {\"type\": \"ColumnLayer\", \"id\": layer_id},\n    }\n</code></pre>"},{"location":"deckgl/#anymap_ts.deckgl.DeckGLMap.add_contour_layer","title":"<code>add_contour_layer(self, data, name=None, get_position='coordinates', get_weight=1, cell_size=200, contours=None, pickable=True, opacity=1, **kwargs)</code>","text":"<p>Add a contour layer for isoline visualization.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>Array of data objects with position coordinates.</p> required <code>name</code> <code>Optional[str]</code> <p>Layer ID.</p> <code>None</code> <code>get_position</code> <code>Union[str, Callable]</code> <p>Accessor for point position [lng, lat].</p> <code>'coordinates'</code> <code>get_weight</code> <code>Union[float, str, Callable]</code> <p>Accessor for point weight.</p> <code>1</code> <code>cell_size</code> <code>float</code> <p>Grid cell size for aggregation.</p> <code>200</code> <code>contours</code> <code>Optional[List[Dict]]</code> <p>Contour definitions [{threshold, color, strokeWidth}, ...].</p> <code>None</code> <code>pickable</code> <code>bool</code> <p>Whether layer responds to hover/click.</p> <code>True</code> <code>opacity</code> <code>float</code> <p>Layer opacity.</p> <code>1</code> <code>**kwargs</code> <p>Additional layer props.</p> <code>{}</code> Source code in <code>anymap_ts/deckgl.py</code> <pre><code>def add_contour_layer(\n    self,\n    data: Any,\n    name: Optional[str] = None,\n    get_position: Union[str, Callable] = \"coordinates\",\n    get_weight: Union[float, str, Callable] = 1,\n    cell_size: float = 200,\n    contours: Optional[List[Dict]] = None,\n    pickable: bool = True,\n    opacity: float = 1,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a contour layer for isoline visualization.\n\n    Args:\n        data: Array of data objects with position coordinates.\n        name: Layer ID.\n        get_position: Accessor for point position [lng, lat].\n        get_weight: Accessor for point weight.\n        cell_size: Grid cell size for aggregation.\n        contours: Contour definitions [{threshold, color, strokeWidth}, ...].\n        pickable: Whether layer responds to hover/click.\n        opacity: Layer opacity.\n        **kwargs: Additional layer props.\n    \"\"\"\n    layer_id = name or f\"contour-{len(self._deck_layers)}\"\n    processed_data = self._process_deck_data(data)\n\n    default_contours = [\n        {\"threshold\": 1, \"color\": [255, 255, 255], \"strokeWidth\": 1},\n        {\"threshold\": 5, \"color\": [51, 136, 255], \"strokeWidth\": 2},\n        {\"threshold\": 10, \"color\": [0, 0, 255], \"strokeWidth\": 3},\n    ]\n\n    self.call_js_method(\n        \"addContourLayer\",\n        id=layer_id,\n        data=processed_data,\n        getPosition=get_position,\n        getWeight=get_weight,\n        cellSize=cell_size,\n        contours=contours or default_contours,\n        pickable=pickable,\n        opacity=opacity,\n        **kwargs,\n    )\n\n    self._deck_layers = {\n        **self._deck_layers,\n        layer_id: {\"type\": \"ContourLayer\", \"id\": layer_id},\n    }\n</code></pre>"},{"location":"deckgl/#anymap_ts.deckgl.DeckGLMap.add_deckgl_layer","title":"<code>add_deckgl_layer(self, layer_type, data, name=None, **kwargs)</code>","text":"<p>Add a generic deck.gl layer to the map.</p> <p>This method provides a flexible way to add any supported deck.gl layer type using a single interface. For commonly used layers, prefer the specific methods (e.g., add_scatterplot_layer) for better IDE support.</p> <p>Parameters:</p> Name Type Description Default <code>layer_type</code> <code>str</code> <p>The deck.gl layer type. Supported types include: 'ScatterplotLayer', 'ArcLayer', 'PathLayer', 'PolygonLayer', 'HexagonLayer', 'HeatmapLayer', 'GridLayer', 'IconLayer', 'TextLayer', 'GeoJsonLayer', 'ContourLayer', 'ScreenGridLayer', 'PointCloudLayer', 'TripsLayer', 'LineLayer'.</p> required <code>data</code> <code>Any</code> <p>Array of data objects or GeoJSON.</p> required <code>name</code> <code>Optional[str]</code> <p>Layer ID. If None, auto-generated from layer_type.</p> <code>None</code> <code>**kwargs</code> <p>Layer-specific properties passed directly to deck.gl. Common properties include: - opacity: Layer opacity (0-1) - pickable: Whether layer responds to hover/click - getPosition: Accessor for position coordinates - getColor/getFillColor/getLineColor: Color accessors</p> <code>{}</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; m = DeckGLMap()\n&gt;&gt;&gt; # Add a TripsLayer with animation\n&gt;&gt;&gt; m.add_deckgl_layer(\n...     'TripsLayer',\n...     data=trips_data,\n...     getPath='waypoints',\n...     getTimestamps='timestamps',\n...     getColor=[253, 128, 93],\n...     trailLength=180,\n... )\n&gt;&gt;&gt; # Add a LineLayer\n&gt;&gt;&gt; m.add_deckgl_layer(\n...     'LineLayer',\n...     data=lines_data,\n...     getSourcePosition='source',\n...     getTargetPosition='target',\n...     getColor=[0, 128, 255],\n... )\n</code></pre> Source code in <code>anymap_ts/deckgl.py</code> <pre><code>def add_deckgl_layer(\n    self,\n    layer_type: str,\n    data: Any,\n    name: Optional[str] = None,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a generic deck.gl layer to the map.\n\n    This method provides a flexible way to add any supported deck.gl layer\n    type using a single interface. For commonly used layers, prefer the\n    specific methods (e.g., add_scatterplot_layer) for better IDE support.\n\n    Args:\n        layer_type: The deck.gl layer type. Supported types include:\n            'ScatterplotLayer', 'ArcLayer', 'PathLayer', 'PolygonLayer',\n            'HexagonLayer', 'HeatmapLayer', 'GridLayer', 'IconLayer',\n            'TextLayer', 'GeoJsonLayer', 'ContourLayer', 'ScreenGridLayer',\n            'PointCloudLayer', 'TripsLayer', 'LineLayer'.\n        data: Array of data objects or GeoJSON.\n        name: Layer ID. If None, auto-generated from layer_type.\n        **kwargs: Layer-specific properties passed directly to deck.gl.\n            Common properties include:\n            - opacity: Layer opacity (0-1)\n            - pickable: Whether layer responds to hover/click\n            - getPosition: Accessor for position coordinates\n            - getColor/getFillColor/getLineColor: Color accessors\n\n    Example:\n        &gt;&gt;&gt; m = DeckGLMap()\n        &gt;&gt;&gt; # Add a TripsLayer with animation\n        &gt;&gt;&gt; m.add_deckgl_layer(\n        ...     'TripsLayer',\n        ...     data=trips_data,\n        ...     getPath='waypoints',\n        ...     getTimestamps='timestamps',\n        ...     getColor=[253, 128, 93],\n        ...     trailLength=180,\n        ... )\n        &gt;&gt;&gt; # Add a LineLayer\n        &gt;&gt;&gt; m.add_deckgl_layer(\n        ...     'LineLayer',\n        ...     data=lines_data,\n        ...     getSourcePosition='source',\n        ...     getTargetPosition='target',\n        ...     getColor=[0, 128, 255],\n        ... )\n    \"\"\"\n    # Normalize layer type and create prefix\n    layer_type_clean = layer_type.replace(\"Layer\", \"\")\n    prefix = layer_type_clean.lower()\n    layer_id = name or f\"{prefix}-{len(self._deck_layers)}\"\n    processed_data = self._process_deck_data(data)\n\n    self.call_js_method(\n        \"addDeckGLLayer\",\n        layerType=layer_type,\n        id=layer_id,\n        data=processed_data,\n        **kwargs,\n    )\n\n    self._deck_layers = {\n        **self._deck_layers,\n        layer_id: {\"type\": layer_type, \"id\": layer_id},\n    }\n</code></pre>"},{"location":"deckgl/#anymap_ts.deckgl.DeckGLMap.add_geohash_layer","title":"<code>add_geohash_layer(self, data, name=None, get_geohash='geohash', get_fill_color=None, get_line_color=None, get_line_width=1, get_elevation=0, filled=True, stroked=True, extruded=False, wireframe=False, elevation_scale=1, pickable=True, opacity=0.8, **kwargs)</code>","text":"<p>Add a Geohash layer for geohash cell visualization.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>Array of data objects with geohash.</p> required <code>name</code> <code>Optional[str]</code> <p>Layer ID.</p> <code>None</code> <code>get_geohash</code> <code>Union[str, Callable]</code> <p>Accessor for geohash string.</p> <code>'geohash'</code> <code>get_fill_color</code> <code>Union[List[int], str, Callable]</code> <p>Accessor for fill color [r, g, b, a].</p> <code>None</code> <code>get_line_color</code> <code>Union[List[int], str, Callable]</code> <p>Accessor for stroke color [r, g, b, a].</p> <code>None</code> <code>get_line_width</code> <code>Union[float, str, Callable]</code> <p>Accessor for line width.</p> <code>1</code> <code>get_elevation</code> <code>Union[float, str, Callable]</code> <p>Accessor for 3D extrusion height.</p> <code>0</code> <code>filled</code> <code>bool</code> <p>Whether to fill cells.</p> <code>True</code> <code>stroked</code> <code>bool</code> <p>Whether to stroke cells.</p> <code>True</code> <code>extruded</code> <code>bool</code> <p>Whether to render as 3D.</p> <code>False</code> <code>wireframe</code> <code>bool</code> <p>Whether to render wireframe.</p> <code>False</code> <code>elevation_scale</code> <code>float</code> <p>Elevation multiplier.</p> <code>1</code> <code>pickable</code> <code>bool</code> <p>Whether layer responds to hover/click.</p> <code>True</code> <code>opacity</code> <code>float</code> <p>Layer opacity.</p> <code>0.8</code> <code>**kwargs</code> <p>Additional GeohashLayer props.</p> <code>{}</code> Source code in <code>anymap_ts/deckgl.py</code> <pre><code>def add_geohash_layer(\n    self,\n    data: Any,\n    name: Optional[str] = None,\n    get_geohash: Union[str, Callable] = \"geohash\",\n    get_fill_color: Union[List[int], str, Callable] = None,\n    get_line_color: Union[List[int], str, Callable] = None,\n    get_line_width: Union[float, str, Callable] = 1,\n    get_elevation: Union[float, str, Callable] = 0,\n    filled: bool = True,\n    stroked: bool = True,\n    extruded: bool = False,\n    wireframe: bool = False,\n    elevation_scale: float = 1,\n    pickable: bool = True,\n    opacity: float = 0.8,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a Geohash layer for geohash cell visualization.\n\n    Args:\n        data: Array of data objects with geohash.\n        name: Layer ID.\n        get_geohash: Accessor for geohash string.\n        get_fill_color: Accessor for fill color [r, g, b, a].\n        get_line_color: Accessor for stroke color [r, g, b, a].\n        get_line_width: Accessor for line width.\n        get_elevation: Accessor for 3D extrusion height.\n        filled: Whether to fill cells.\n        stroked: Whether to stroke cells.\n        extruded: Whether to render as 3D.\n        wireframe: Whether to render wireframe.\n        elevation_scale: Elevation multiplier.\n        pickable: Whether layer responds to hover/click.\n        opacity: Layer opacity.\n        **kwargs: Additional GeohashLayer props.\n    \"\"\"\n    layer_id = name or f\"geohash-{len(self._deck_layers)}\"\n    processed_data = self._process_deck_data(data)\n\n    self.call_js_method(\n        \"addGeohashLayer\",\n        id=layer_id,\n        data=processed_data,\n        getGeohash=get_geohash,\n        getFillColor=get_fill_color or [51, 136, 255, 128],\n        getLineColor=get_line_color or [0, 0, 0, 255],\n        getLineWidth=get_line_width,\n        getElevation=get_elevation,\n        filled=filled,\n        stroked=stroked,\n        extruded=extruded,\n        wireframe=wireframe,\n        elevationScale=elevation_scale,\n        pickable=pickable,\n        opacity=opacity,\n        **kwargs,\n    )\n\n    self._deck_layers = {\n        **self._deck_layers,\n        layer_id: {\"type\": \"GeohashLayer\", \"id\": layer_id},\n    }\n</code></pre>"},{"location":"deckgl/#anymap_ts.deckgl.DeckGLMap.add_geojson_layer","title":"<code>add_geojson_layer(self, data, name=None, get_fill_color=None, get_line_color=None, get_line_width=1, get_point_radius=5, get_elevation=0, extruded=False, wireframe=False, filled=True, stroked=True, line_width_min_pixels=1, point_radius_min_pixels=2, pickable=True, opacity=0.8, **kwargs)</code>","text":"<p>Add a GeoJSON layer for rendering GeoJSON features.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>GeoJSON object or URL.</p> required <code>name</code> <code>Optional[str]</code> <p>Layer ID.</p> <code>None</code> <code>get_fill_color</code> <code>Union[List[int], str, Callable]</code> <p>Accessor for fill color [r, g, b, a].</p> <code>None</code> <code>get_line_color</code> <code>Union[List[int], str, Callable]</code> <p>Accessor for stroke color [r, g, b, a].</p> <code>None</code> <code>get_line_width</code> <code>Union[float, str, Callable]</code> <p>Accessor for stroke width.</p> <code>1</code> <code>get_point_radius</code> <code>Union[float, str, Callable]</code> <p>Accessor for point radius.</p> <code>5</code> <code>get_elevation</code> <code>Union[float, str, Callable]</code> <p>Accessor for 3D extrusion height.</p> <code>0</code> <code>extruded</code> <code>bool</code> <p>Whether to render as 3D features.</p> <code>False</code> <code>wireframe</code> <code>bool</code> <p>Whether to render wireframe (extruded only).</p> <code>False</code> <code>filled</code> <code>bool</code> <p>Whether to fill features.</p> <code>True</code> <code>stroked</code> <code>bool</code> <p>Whether to draw stroke.</p> <code>True</code> <code>line_width_min_pixels</code> <code>float</code> <p>Minimum stroke width.</p> <code>1</code> <code>point_radius_min_pixels</code> <code>float</code> <p>Minimum point radius.</p> <code>2</code> <code>pickable</code> <code>bool</code> <p>Whether layer responds to hover/click.</p> <code>True</code> <code>opacity</code> <code>float</code> <p>Layer opacity.</p> <code>0.8</code> <code>**kwargs</code> <p>Additional layer props.</p> <code>{}</code> Source code in <code>anymap_ts/deckgl.py</code> <pre><code>def add_geojson_layer(\n    self,\n    data: Any,\n    name: Optional[str] = None,\n    get_fill_color: Union[List[int], str, Callable] = None,\n    get_line_color: Union[List[int], str, Callable] = None,\n    get_line_width: Union[float, str, Callable] = 1,\n    get_point_radius: Union[float, str, Callable] = 5,\n    get_elevation: Union[float, str, Callable] = 0,\n    extruded: bool = False,\n    wireframe: bool = False,\n    filled: bool = True,\n    stroked: bool = True,\n    line_width_min_pixels: float = 1,\n    point_radius_min_pixels: float = 2,\n    pickable: bool = True,\n    opacity: float = 0.8,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a GeoJSON layer for rendering GeoJSON features.\n\n    Args:\n        data: GeoJSON object or URL.\n        name: Layer ID.\n        get_fill_color: Accessor for fill color [r, g, b, a].\n        get_line_color: Accessor for stroke color [r, g, b, a].\n        get_line_width: Accessor for stroke width.\n        get_point_radius: Accessor for point radius.\n        get_elevation: Accessor for 3D extrusion height.\n        extruded: Whether to render as 3D features.\n        wireframe: Whether to render wireframe (extruded only).\n        filled: Whether to fill features.\n        stroked: Whether to draw stroke.\n        line_width_min_pixels: Minimum stroke width.\n        point_radius_min_pixels: Minimum point radius.\n        pickable: Whether layer responds to hover/click.\n        opacity: Layer opacity.\n        **kwargs: Additional layer props.\n    \"\"\"\n    layer_id = name or f\"geojson-{len(self._deck_layers)}\"\n    processed_data = self._process_deck_data(data)\n\n    self.call_js_method(\n        \"addGeoJsonLayer\",\n        id=layer_id,\n        data=processed_data,\n        getFillColor=get_fill_color or [51, 136, 255, 128],\n        getLineColor=get_line_color or [0, 0, 0, 255],\n        getLineWidth=get_line_width,\n        getPointRadius=get_point_radius,\n        getElevation=get_elevation,\n        extruded=extruded,\n        wireframe=wireframe,\n        filled=filled,\n        stroked=stroked,\n        lineWidthMinPixels=line_width_min_pixels,\n        pointRadiusMinPixels=point_radius_min_pixels,\n        pickable=pickable,\n        opacity=opacity,\n        **kwargs,\n    )\n\n    self._deck_layers = {\n        **self._deck_layers,\n        layer_id: {\"type\": \"GeoJsonLayer\", \"id\": layer_id},\n    }\n</code></pre>"},{"location":"deckgl/#anymap_ts.deckgl.DeckGLMap.add_great_circle_layer","title":"<code>add_great_circle_layer(self, data, name=None, get_source_position='source', get_target_position='target', get_source_color=None, get_target_color=None, get_width=1, width_min_pixels=1, width_max_pixels=100, pickable=True, opacity=0.8, **kwargs)</code>","text":"<p>Add a great circle layer for geodesic arc visualization.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>Array of data objects with source/target coordinates.</p> required <code>name</code> <code>Optional[str]</code> <p>Layer ID.</p> <code>None</code> <code>get_source_position</code> <code>Union[str, Callable]</code> <p>Accessor for source position [lng, lat].</p> <code>'source'</code> <code>get_target_position</code> <code>Union[str, Callable]</code> <p>Accessor for target position [lng, lat].</p> <code>'target'</code> <code>get_source_color</code> <code>Union[List[int], str, Callable]</code> <p>Accessor for source color [r, g, b, a].</p> <code>None</code> <code>get_target_color</code> <code>Union[List[int], str, Callable]</code> <p>Accessor for target color [r, g, b, a].</p> <code>None</code> <code>get_width</code> <code>Union[float, str, Callable]</code> <p>Accessor for line width.</p> <code>1</code> <code>width_min_pixels</code> <code>float</code> <p>Minimum line width in pixels.</p> <code>1</code> <code>width_max_pixels</code> <code>float</code> <p>Maximum line width in pixels.</p> <code>100</code> <code>pickable</code> <code>bool</code> <p>Whether layer responds to hover/click.</p> <code>True</code> <code>opacity</code> <code>float</code> <p>Layer opacity.</p> <code>0.8</code> <code>**kwargs</code> <p>Additional GreatCircleLayer props.</p> <code>{}</code> Source code in <code>anymap_ts/deckgl.py</code> <pre><code>def add_great_circle_layer(\n    self,\n    data: Any,\n    name: Optional[str] = None,\n    get_source_position: Union[str, Callable] = \"source\",\n    get_target_position: Union[str, Callable] = \"target\",\n    get_source_color: Union[List[int], str, Callable] = None,\n    get_target_color: Union[List[int], str, Callable] = None,\n    get_width: Union[float, str, Callable] = 1,\n    width_min_pixels: float = 1,\n    width_max_pixels: float = 100,\n    pickable: bool = True,\n    opacity: float = 0.8,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a great circle layer for geodesic arc visualization.\n\n    Args:\n        data: Array of data objects with source/target coordinates.\n        name: Layer ID.\n        get_source_position: Accessor for source position [lng, lat].\n        get_target_position: Accessor for target position [lng, lat].\n        get_source_color: Accessor for source color [r, g, b, a].\n        get_target_color: Accessor for target color [r, g, b, a].\n        get_width: Accessor for line width.\n        width_min_pixels: Minimum line width in pixels.\n        width_max_pixels: Maximum line width in pixels.\n        pickable: Whether layer responds to hover/click.\n        opacity: Layer opacity.\n        **kwargs: Additional GreatCircleLayer props.\n    \"\"\"\n    layer_id = name or f\"greatcircle-{len(self._deck_layers)}\"\n    processed_data = self._process_deck_data(data)\n\n    self.call_js_method(\n        \"addGreatCircleLayer\",\n        id=layer_id,\n        data=processed_data,\n        getSourcePosition=get_source_position,\n        getTargetPosition=get_target_position,\n        getSourceColor=get_source_color or [51, 136, 255, 255],\n        getTargetColor=get_target_color or [255, 136, 51, 255],\n        getWidth=get_width,\n        widthMinPixels=width_min_pixels,\n        widthMaxPixels=width_max_pixels,\n        pickable=pickable,\n        opacity=opacity,\n        **kwargs,\n    )\n\n    self._deck_layers = {\n        **self._deck_layers,\n        layer_id: {\"type\": \"GreatCircleLayer\", \"id\": layer_id},\n    }\n</code></pre>"},{"location":"deckgl/#anymap_ts.deckgl.DeckGLMap.add_grid_cell_layer","title":"<code>add_grid_cell_layer(self, data, name=None, get_position='coordinates', get_color=None, get_elevation=1000, cell_size=200, coverage=1, elevation_scale=1, extruded=True, pickable=True, opacity=0.8, **kwargs)</code>","text":"<p>Add a grid cell layer for pre-aggregated grid visualization.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>Array of data objects with position coordinates.</p> required <code>name</code> <code>Optional[str]</code> <p>Layer ID.</p> <code>None</code> <code>get_position</code> <code>Union[str, Callable]</code> <p>Accessor for cell position [lng, lat].</p> <code>'coordinates'</code> <code>get_color</code> <code>Union[List[int], str, Callable]</code> <p>Accessor for cell color [r, g, b, a].</p> <code>None</code> <code>get_elevation</code> <code>Union[float, str, Callable]</code> <p>Accessor for cell height.</p> <code>1000</code> <code>cell_size</code> <code>float</code> <p>Cell size in meters.</p> <code>200</code> <code>coverage</code> <code>float</code> <p>Cell coverage (0-1).</p> <code>1</code> <code>elevation_scale</code> <code>float</code> <p>Elevation multiplier.</p> <code>1</code> <code>extruded</code> <code>bool</code> <p>Whether to extrude cells.</p> <code>True</code> <code>pickable</code> <code>bool</code> <p>Whether layer responds to hover/click.</p> <code>True</code> <code>opacity</code> <code>float</code> <p>Layer opacity.</p> <code>0.8</code> <code>**kwargs</code> <p>Additional GridCellLayer props.</p> <code>{}</code> Source code in <code>anymap_ts/deckgl.py</code> <pre><code>def add_grid_cell_layer(\n    self,\n    data: Any,\n    name: Optional[str] = None,\n    get_position: Union[str, Callable] = \"coordinates\",\n    get_color: Union[List[int], str, Callable] = None,\n    get_elevation: Union[float, str, Callable] = 1000,\n    cell_size: float = 200,\n    coverage: float = 1,\n    elevation_scale: float = 1,\n    extruded: bool = True,\n    pickable: bool = True,\n    opacity: float = 0.8,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a grid cell layer for pre-aggregated grid visualization.\n\n    Args:\n        data: Array of data objects with position coordinates.\n        name: Layer ID.\n        get_position: Accessor for cell position [lng, lat].\n        get_color: Accessor for cell color [r, g, b, a].\n        get_elevation: Accessor for cell height.\n        cell_size: Cell size in meters.\n        coverage: Cell coverage (0-1).\n        elevation_scale: Elevation multiplier.\n        extruded: Whether to extrude cells.\n        pickable: Whether layer responds to hover/click.\n        opacity: Layer opacity.\n        **kwargs: Additional GridCellLayer props.\n    \"\"\"\n    layer_id = name or f\"gridcell-{len(self._deck_layers)}\"\n    processed_data = self._process_deck_data(data)\n\n    self.call_js_method(\n        \"addGridCellLayer\",\n        id=layer_id,\n        data=processed_data,\n        getPosition=get_position,\n        getColor=get_color or [255, 140, 0, 200],\n        getElevation=get_elevation,\n        cellSize=cell_size,\n        coverage=coverage,\n        elevationScale=elevation_scale,\n        extruded=extruded,\n        pickable=pickable,\n        opacity=opacity,\n        **kwargs,\n    )\n\n    self._deck_layers = {\n        **self._deck_layers,\n        layer_id: {\"type\": \"GridCellLayer\", \"id\": layer_id},\n    }\n</code></pre>"},{"location":"deckgl/#anymap_ts.deckgl.DeckGLMap.add_grid_layer","title":"<code>add_grid_layer(self, data, name=None, get_position='coordinates', cell_size=200, elevation_scale=4, extruded=True, color_range=None, pickable=True, opacity=0.8, **kwargs)</code>","text":"<p>Add a grid layer for square grid aggregation visualization.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>Array of data objects with position coordinates.</p> required <code>name</code> <code>Optional[str]</code> <p>Layer ID.</p> <code>None</code> <code>get_position</code> <code>Union[str, Callable]</code> <p>Accessor for point position [lng, lat].</p> <code>'coordinates'</code> <code>cell_size</code> <code>float</code> <p>Grid cell size in meters.</p> <code>200</code> <code>elevation_scale</code> <code>float</code> <p>Elevation multiplier for 3D.</p> <code>4</code> <code>extruded</code> <code>bool</code> <p>Whether to render as 3D cells.</p> <code>True</code> <code>color_range</code> <code>Optional[List[List[int]]]</code> <p>Color gradient [[r, g, b], ...].</p> <code>None</code> <code>pickable</code> <code>bool</code> <p>Whether layer responds to hover/click.</p> <code>True</code> <code>opacity</code> <code>float</code> <p>Layer opacity.</p> <code>0.8</code> <code>**kwargs</code> <p>Additional layer props.</p> <code>{}</code> Source code in <code>anymap_ts/deckgl.py</code> <pre><code>def add_grid_layer(\n    self,\n    data: Any,\n    name: Optional[str] = None,\n    get_position: Union[str, Callable] = \"coordinates\",\n    cell_size: float = 200,\n    elevation_scale: float = 4,\n    extruded: bool = True,\n    color_range: Optional[List[List[int]]] = None,\n    pickable: bool = True,\n    opacity: float = 0.8,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a grid layer for square grid aggregation visualization.\n\n    Args:\n        data: Array of data objects with position coordinates.\n        name: Layer ID.\n        get_position: Accessor for point position [lng, lat].\n        cell_size: Grid cell size in meters.\n        elevation_scale: Elevation multiplier for 3D.\n        extruded: Whether to render as 3D cells.\n        color_range: Color gradient [[r, g, b], ...].\n        pickable: Whether layer responds to hover/click.\n        opacity: Layer opacity.\n        **kwargs: Additional layer props.\n    \"\"\"\n    layer_id = name or f\"grid-{len(self._deck_layers)}\"\n    processed_data = self._process_deck_data(data)\n\n    default_color_range = [\n        [1, 152, 189],\n        [73, 227, 206],\n        [216, 254, 181],\n        [254, 237, 177],\n        [254, 173, 84],\n        [209, 55, 78],\n    ]\n\n    self.call_js_method(\n        \"addGridLayer\",\n        id=layer_id,\n        data=processed_data,\n        getPosition=get_position,\n        cellSize=cell_size,\n        elevationScale=elevation_scale,\n        extruded=extruded,\n        colorRange=color_range or default_color_range,\n        pickable=pickable,\n        opacity=opacity,\n        **kwargs,\n    )\n\n    self._deck_layers = {\n        **self._deck_layers,\n        layer_id: {\"type\": \"GridLayer\", \"id\": layer_id},\n    }\n</code></pre>"},{"location":"deckgl/#anymap_ts.deckgl.DeckGLMap.add_h3_cluster_layer","title":"<code>add_h3_cluster_layer(self, data, name=None, get_hexagons='hexagons', get_fill_color=None, get_line_color=None, get_line_width=1, filled=True, stroked=True, extruded=False, elevation_scale=1, pickable=True, opacity=0.8, **kwargs)</code>","text":"<p>Add an H3 cluster layer for grouped H3 cell visualization.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>Array of data objects with H3 index arrays.</p> required <code>name</code> <code>Optional[str]</code> <p>Layer ID.</p> <code>None</code> <code>get_hexagons</code> <code>Union[str, Callable]</code> <p>Accessor for array of H3 index strings.</p> <code>'hexagons'</code> <code>get_fill_color</code> <code>Union[List[int], str, Callable]</code> <p>Accessor for fill color [r, g, b, a].</p> <code>None</code> <code>get_line_color</code> <code>Union[List[int], str, Callable]</code> <p>Accessor for stroke color [r, g, b, a].</p> <code>None</code> <code>get_line_width</code> <code>Union[float, str, Callable]</code> <p>Accessor for line width.</p> <code>1</code> <code>filled</code> <code>bool</code> <p>Whether to fill clusters.</p> <code>True</code> <code>stroked</code> <code>bool</code> <p>Whether to stroke clusters.</p> <code>True</code> <code>extruded</code> <code>bool</code> <p>Whether to render as 3D.</p> <code>False</code> <code>elevation_scale</code> <code>float</code> <p>Elevation multiplier.</p> <code>1</code> <code>pickable</code> <code>bool</code> <p>Whether layer responds to hover/click.</p> <code>True</code> <code>opacity</code> <code>float</code> <p>Layer opacity.</p> <code>0.8</code> <code>**kwargs</code> <p>Additional H3ClusterLayer props.</p> <code>{}</code> Source code in <code>anymap_ts/deckgl.py</code> <pre><code>def add_h3_cluster_layer(\n    self,\n    data: Any,\n    name: Optional[str] = None,\n    get_hexagons: Union[str, Callable] = \"hexagons\",\n    get_fill_color: Union[List[int], str, Callable] = None,\n    get_line_color: Union[List[int], str, Callable] = None,\n    get_line_width: Union[float, str, Callable] = 1,\n    filled: bool = True,\n    stroked: bool = True,\n    extruded: bool = False,\n    elevation_scale: float = 1,\n    pickable: bool = True,\n    opacity: float = 0.8,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add an H3 cluster layer for grouped H3 cell visualization.\n\n    Args:\n        data: Array of data objects with H3 index arrays.\n        name: Layer ID.\n        get_hexagons: Accessor for array of H3 index strings.\n        get_fill_color: Accessor for fill color [r, g, b, a].\n        get_line_color: Accessor for stroke color [r, g, b, a].\n        get_line_width: Accessor for line width.\n        filled: Whether to fill clusters.\n        stroked: Whether to stroke clusters.\n        extruded: Whether to render as 3D.\n        elevation_scale: Elevation multiplier.\n        pickable: Whether layer responds to hover/click.\n        opacity: Layer opacity.\n        **kwargs: Additional H3ClusterLayer props.\n    \"\"\"\n    layer_id = name or f\"h3cluster-{len(self._deck_layers)}\"\n    processed_data = self._process_deck_data(data)\n\n    self.call_js_method(\n        \"addH3ClusterLayer\",\n        id=layer_id,\n        data=processed_data,\n        getHexagons=get_hexagons,\n        getFillColor=get_fill_color or [51, 136, 255, 128],\n        getLineColor=get_line_color or [0, 0, 0, 255],\n        getLineWidth=get_line_width,\n        filled=filled,\n        stroked=stroked,\n        extruded=extruded,\n        elevationScale=elevation_scale,\n        pickable=pickable,\n        opacity=opacity,\n        **kwargs,\n    )\n\n    self._deck_layers = {\n        **self._deck_layers,\n        layer_id: {\"type\": \"H3ClusterLayer\", \"id\": layer_id},\n    }\n</code></pre>"},{"location":"deckgl/#anymap_ts.deckgl.DeckGLMap.add_h3_hexagon_layer","title":"<code>add_h3_hexagon_layer(self, data, name=None, get_hexagon='hexagon', get_fill_color=None, get_line_color=None, get_elevation=0, filled=True, stroked=True, extruded=False, wireframe=False, elevation_scale=1, coverage=1, high_precision=False, pickable=True, opacity=0.8, **kwargs)</code>","text":"<p>Add an H3 hexagon layer for H3 spatial index visualization.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>Array of data objects with H3 index.</p> required <code>name</code> <code>Optional[str]</code> <p>Layer ID.</p> <code>None</code> <code>get_hexagon</code> <code>Union[str, Callable]</code> <p>Accessor for H3 index string.</p> <code>'hexagon'</code> <code>get_fill_color</code> <code>Union[List[int], str, Callable]</code> <p>Accessor for fill color [r, g, b, a].</p> <code>None</code> <code>get_line_color</code> <code>Union[List[int], str, Callable]</code> <p>Accessor for stroke color [r, g, b, a].</p> <code>None</code> <code>get_elevation</code> <code>Union[float, str, Callable]</code> <p>Accessor for 3D extrusion height.</p> <code>0</code> <code>filled</code> <code>bool</code> <p>Whether to fill hexagons.</p> <code>True</code> <code>stroked</code> <code>bool</code> <p>Whether to stroke hexagons.</p> <code>True</code> <code>extruded</code> <code>bool</code> <p>Whether to render as 3D hexagons.</p> <code>False</code> <code>wireframe</code> <code>bool</code> <p>Whether to render wireframe.</p> <code>False</code> <code>elevation_scale</code> <code>float</code> <p>Elevation multiplier.</p> <code>1</code> <code>coverage</code> <code>float</code> <p>Hexagon coverage (0-1).</p> <code>1</code> <code>high_precision</code> <code>bool</code> <p>Use high precision rendering.</p> <code>False</code> <code>pickable</code> <code>bool</code> <p>Whether layer responds to hover/click.</p> <code>True</code> <code>opacity</code> <code>float</code> <p>Layer opacity.</p> <code>0.8</code> <code>**kwargs</code> <p>Additional H3HexagonLayer props.</p> <code>{}</code> Source code in <code>anymap_ts/deckgl.py</code> <pre><code>def add_h3_hexagon_layer(\n    self,\n    data: Any,\n    name: Optional[str] = None,\n    get_hexagon: Union[str, Callable] = \"hexagon\",\n    get_fill_color: Union[List[int], str, Callable] = None,\n    get_line_color: Union[List[int], str, Callable] = None,\n    get_elevation: Union[float, str, Callable] = 0,\n    filled: bool = True,\n    stroked: bool = True,\n    extruded: bool = False,\n    wireframe: bool = False,\n    elevation_scale: float = 1,\n    coverage: float = 1,\n    high_precision: bool = False,\n    pickable: bool = True,\n    opacity: float = 0.8,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add an H3 hexagon layer for H3 spatial index visualization.\n\n    Args:\n        data: Array of data objects with H3 index.\n        name: Layer ID.\n        get_hexagon: Accessor for H3 index string.\n        get_fill_color: Accessor for fill color [r, g, b, a].\n        get_line_color: Accessor for stroke color [r, g, b, a].\n        get_elevation: Accessor for 3D extrusion height.\n        filled: Whether to fill hexagons.\n        stroked: Whether to stroke hexagons.\n        extruded: Whether to render as 3D hexagons.\n        wireframe: Whether to render wireframe.\n        elevation_scale: Elevation multiplier.\n        coverage: Hexagon coverage (0-1).\n        high_precision: Use high precision rendering.\n        pickable: Whether layer responds to hover/click.\n        opacity: Layer opacity.\n        **kwargs: Additional H3HexagonLayer props.\n    \"\"\"\n    layer_id = name or f\"h3hexagon-{len(self._deck_layers)}\"\n    processed_data = self._process_deck_data(data)\n\n    self.call_js_method(\n        \"addH3HexagonLayer\",\n        id=layer_id,\n        data=processed_data,\n        getHexagon=get_hexagon,\n        getFillColor=get_fill_color or [51, 136, 255, 128],\n        getLineColor=get_line_color or [0, 0, 0, 255],\n        getElevation=get_elevation,\n        filled=filled,\n        stroked=stroked,\n        extruded=extruded,\n        wireframe=wireframe,\n        elevationScale=elevation_scale,\n        coverage=coverage,\n        highPrecision=high_precision,\n        pickable=pickable,\n        opacity=opacity,\n        **kwargs,\n    )\n\n    self._deck_layers = {\n        **self._deck_layers,\n        layer_id: {\"type\": \"H3HexagonLayer\", \"id\": layer_id},\n    }\n</code></pre>"},{"location":"deckgl/#anymap_ts.deckgl.DeckGLMap.add_heatmap_layer","title":"<code>add_heatmap_layer(self, data, name=None, get_position='coordinates', get_weight=1, radius_pixels=30, intensity=1, threshold=0.05, color_range=None, opacity=1, **kwargs)</code>","text":"<p>Add a heatmap layer for density visualization.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>Array of data objects with position coordinates.</p> required <code>name</code> <code>Optional[str]</code> <p>Layer ID.</p> <code>None</code> <code>get_position</code> <code>Union[str, Callable]</code> <p>Accessor for point position [lng, lat].</p> <code>'coordinates'</code> <code>get_weight</code> <code>Union[float, str, Callable]</code> <p>Accessor for point weight.</p> <code>1</code> <code>radius_pixels</code> <code>float</code> <p>Influence radius in pixels.</p> <code>30</code> <code>intensity</code> <code>float</code> <p>Intensity multiplier.</p> <code>1</code> <code>threshold</code> <code>float</code> <p>Minimum density threshold.</p> <code>0.05</code> <code>color_range</code> <code>Optional[List[List[int]]]</code> <p>Color gradient [[r, g, b, a], ...].</p> <code>None</code> <code>opacity</code> <code>float</code> <p>Layer opacity.</p> <code>1</code> <code>**kwargs</code> <p>Additional layer props.</p> <code>{}</code> Source code in <code>anymap_ts/deckgl.py</code> <pre><code>def add_heatmap_layer(\n    self,\n    data: Any,\n    name: Optional[str] = None,\n    get_position: Union[str, Callable] = \"coordinates\",\n    get_weight: Union[float, str, Callable] = 1,\n    radius_pixels: float = 30,\n    intensity: float = 1,\n    threshold: float = 0.05,\n    color_range: Optional[List[List[int]]] = None,\n    opacity: float = 1,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a heatmap layer for density visualization.\n\n    Args:\n        data: Array of data objects with position coordinates.\n        name: Layer ID.\n        get_position: Accessor for point position [lng, lat].\n        get_weight: Accessor for point weight.\n        radius_pixels: Influence radius in pixels.\n        intensity: Intensity multiplier.\n        threshold: Minimum density threshold.\n        color_range: Color gradient [[r, g, b, a], ...].\n        opacity: Layer opacity.\n        **kwargs: Additional layer props.\n    \"\"\"\n    layer_id = name or f\"heatmap-{len(self._deck_layers)}\"\n    processed_data = self._process_deck_data(data)\n\n    default_color_range = [\n        [255, 255, 178, 25],\n        [254, 217, 118, 85],\n        [254, 178, 76, 127],\n        [253, 141, 60, 170],\n        [240, 59, 32, 212],\n        [189, 0, 38, 255],\n    ]\n\n    self.call_js_method(\n        \"addHeatmapLayer\",\n        id=layer_id,\n        data=processed_data,\n        getPosition=get_position,\n        getWeight=get_weight,\n        radiusPixels=radius_pixels,\n        intensity=intensity,\n        threshold=threshold,\n        colorRange=color_range or default_color_range,\n        opacity=opacity,\n        **kwargs,\n    )\n\n    self._deck_layers = {\n        **self._deck_layers,\n        layer_id: {\"type\": \"HeatmapLayer\", \"id\": layer_id},\n    }\n</code></pre>"},{"location":"deckgl/#anymap_ts.deckgl.DeckGLMap.add_hexagon_layer","title":"<code>add_hexagon_layer(self, data, name=None, get_position='coordinates', radius=1000, elevation_scale=4, extruded=True, color_range=None, pickable=True, opacity=0.8, **kwargs)</code>","text":"<p>Add a hexagon layer for hexbin aggregation visualization.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>Array of data objects with position coordinates.</p> required <code>name</code> <code>Optional[str]</code> <p>Layer ID.</p> <code>None</code> <code>get_position</code> <code>Union[str, Callable]</code> <p>Accessor for point position [lng, lat].</p> <code>'coordinates'</code> <code>radius</code> <code>float</code> <p>Hexagon radius in meters.</p> <code>1000</code> <code>elevation_scale</code> <code>float</code> <p>Elevation multiplier for 3D.</p> <code>4</code> <code>extruded</code> <code>bool</code> <p>Whether to render as 3D hexagons.</p> <code>True</code> <code>color_range</code> <code>Optional[List[List[int]]]</code> <p>Color gradient for aggregation [[r, g, b], ...].</p> <code>None</code> <code>pickable</code> <code>bool</code> <p>Whether layer responds to hover/click.</p> <code>True</code> <code>opacity</code> <code>float</code> <p>Layer opacity.</p> <code>0.8</code> <code>**kwargs</code> <p>Additional layer props.</p> <code>{}</code> Source code in <code>anymap_ts/deckgl.py</code> <pre><code>def add_hexagon_layer(\n    self,\n    data: Any,\n    name: Optional[str] = None,\n    get_position: Union[str, Callable] = \"coordinates\",\n    radius: float = 1000,\n    elevation_scale: float = 4,\n    extruded: bool = True,\n    color_range: Optional[List[List[int]]] = None,\n    pickable: bool = True,\n    opacity: float = 0.8,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a hexagon layer for hexbin aggregation visualization.\n\n    Args:\n        data: Array of data objects with position coordinates.\n        name: Layer ID.\n        get_position: Accessor for point position [lng, lat].\n        radius: Hexagon radius in meters.\n        elevation_scale: Elevation multiplier for 3D.\n        extruded: Whether to render as 3D hexagons.\n        color_range: Color gradient for aggregation [[r, g, b], ...].\n        pickable: Whether layer responds to hover/click.\n        opacity: Layer opacity.\n        **kwargs: Additional layer props.\n    \"\"\"\n    layer_id = name or f\"hexagon-{len(self._deck_layers)}\"\n    processed_data = self._process_deck_data(data)\n\n    default_color_range = [\n        [1, 152, 189],\n        [73, 227, 206],\n        [216, 254, 181],\n        [254, 237, 177],\n        [254, 173, 84],\n        [209, 55, 78],\n    ]\n\n    self.call_js_method(\n        \"addHexagonLayer\",\n        id=layer_id,\n        data=processed_data,\n        getPosition=get_position,\n        radius=radius,\n        elevationScale=elevation_scale,\n        extruded=extruded,\n        colorRange=color_range or default_color_range,\n        pickable=pickable,\n        opacity=opacity,\n        **kwargs,\n    )\n\n    self._deck_layers = {\n        **self._deck_layers,\n        layer_id: {\"type\": \"HexagonLayer\", \"id\": layer_id},\n    }\n</code></pre>"},{"location":"deckgl/#anymap_ts.deckgl.DeckGLMap.add_icon_layer","title":"<code>add_icon_layer(self, data, name=None, get_position='coordinates', get_icon='icon', get_size=20, get_color=None, icon_atlas=None, icon_mapping=None, pickable=True, opacity=1, **kwargs)</code>","text":"<p>Add an icon layer for custom marker visualization.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>Array of data objects with position coordinates.</p> required <code>name</code> <code>Optional[str]</code> <p>Layer ID.</p> <code>None</code> <code>get_position</code> <code>Union[str, Callable]</code> <p>Accessor for icon position [lng, lat].</p> <code>'coordinates'</code> <code>get_icon</code> <code>Union[str, Callable]</code> <p>Accessor for icon name in icon_mapping.</p> <code>'icon'</code> <code>get_size</code> <code>Union[float, str, Callable]</code> <p>Accessor for icon size.</p> <code>20</code> <code>get_color</code> <code>Union[List[int], str, Callable]</code> <p>Accessor for icon tint color [r, g, b, a].</p> <code>None</code> <code>icon_atlas</code> <code>Optional[str]</code> <p>URL to icon atlas image.</p> <code>None</code> <code>icon_mapping</code> <code>Optional[Dict]</code> <p>Dict mapping icon names to atlas coordinates.</p> <code>None</code> <code>pickable</code> <code>bool</code> <p>Whether layer responds to hover/click.</p> <code>True</code> <code>opacity</code> <code>float</code> <p>Layer opacity.</p> <code>1</code> <code>**kwargs</code> <p>Additional layer props.</p> <code>{}</code> Source code in <code>anymap_ts/deckgl.py</code> <pre><code>def add_icon_layer(\n    self,\n    data: Any,\n    name: Optional[str] = None,\n    get_position: Union[str, Callable] = \"coordinates\",\n    get_icon: Union[str, Callable] = \"icon\",\n    get_size: Union[float, str, Callable] = 20,\n    get_color: Union[List[int], str, Callable] = None,\n    icon_atlas: Optional[str] = None,\n    icon_mapping: Optional[Dict] = None,\n    pickable: bool = True,\n    opacity: float = 1,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add an icon layer for custom marker visualization.\n\n    Args:\n        data: Array of data objects with position coordinates.\n        name: Layer ID.\n        get_position: Accessor for icon position [lng, lat].\n        get_icon: Accessor for icon name in icon_mapping.\n        get_size: Accessor for icon size.\n        get_color: Accessor for icon tint color [r, g, b, a].\n        icon_atlas: URL to icon atlas image.\n        icon_mapping: Dict mapping icon names to atlas coordinates.\n        pickable: Whether layer responds to hover/click.\n        opacity: Layer opacity.\n        **kwargs: Additional layer props.\n    \"\"\"\n    layer_id = name or f\"icon-{len(self._deck_layers)}\"\n    processed_data = self._process_deck_data(data)\n\n    self.call_js_method(\n        \"addIconLayer\",\n        id=layer_id,\n        data=processed_data,\n        getPosition=get_position,\n        getIcon=get_icon,\n        getSize=get_size,\n        getColor=get_color or [255, 255, 255, 255],\n        iconAtlas=icon_atlas,\n        iconMapping=icon_mapping,\n        pickable=pickable,\n        opacity=opacity,\n        **kwargs,\n    )\n\n    self._deck_layers = {\n        **self._deck_layers,\n        layer_id: {\"type\": \"IconLayer\", \"id\": layer_id},\n    }\n</code></pre>"},{"location":"deckgl/#anymap_ts.deckgl.DeckGLMap.add_line_layer","title":"<code>add_line_layer(self, data, name=None, get_source_position='sourcePosition', get_target_position='targetPosition', get_color=None, get_width=1, width_min_pixels=1, pickable=True, opacity=0.8, **kwargs)</code>","text":"<p>Add a line layer for simple line segment visualization.</p> <p>The LineLayer renders straight line segments between source and target positions. Unlike ArcLayer, lines are drawn directly without curvature.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>Array of line objects with source/target positions.</p> required <code>name</code> <code>Optional[str]</code> <p>Layer ID. If None, auto-generated.</p> <code>None</code> <code>get_source_position</code> <code>Union[str, Callable]</code> <p>Accessor for source position [lng, lat].</p> <code>'sourcePosition'</code> <code>get_target_position</code> <code>Union[str, Callable]</code> <p>Accessor for target position [lng, lat].</p> <code>'targetPosition'</code> <code>get_color</code> <code>Union[List[int], str, Callable]</code> <p>Accessor for line color [r, g, b] or [r, g, b, a].</p> <code>None</code> <code>get_width</code> <code>Union[float, str, Callable]</code> <p>Accessor for line width.</p> <code>1</code> <code>width_min_pixels</code> <code>float</code> <p>Minimum line width in pixels.</p> <code>1</code> <code>pickable</code> <code>bool</code> <p>Whether layer responds to hover/click.</p> <code>True</code> <code>opacity</code> <code>float</code> <p>Layer opacity (0-1).</p> <code>0.8</code> <code>**kwargs</code> <p>Additional LineLayer props.</p> <code>{}</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; m = DeckGLMap()\n&gt;&gt;&gt; lines = [\n...     {\"sourcePosition\": [-122.4, 37.8], \"targetPosition\": [-122.5, 37.7]},\n...     {\"sourcePosition\": [-122.5, 37.7], \"targetPosition\": [-122.6, 37.8]},\n... ]\n&gt;&gt;&gt; m.add_line_layer(\n...     data=lines,\n...     get_color=[0, 128, 255],\n...     get_width=2,\n... )\n</code></pre> Source code in <code>anymap_ts/deckgl.py</code> <pre><code>def add_line_layer(\n    self,\n    data: Any,\n    name: Optional[str] = None,\n    get_source_position: Union[str, Callable] = \"sourcePosition\",\n    get_target_position: Union[str, Callable] = \"targetPosition\",\n    get_color: Union[List[int], str, Callable] = None,\n    get_width: Union[float, str, Callable] = 1,\n    width_min_pixels: float = 1,\n    pickable: bool = True,\n    opacity: float = 0.8,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a line layer for simple line segment visualization.\n\n    The LineLayer renders straight line segments between source and\n    target positions. Unlike ArcLayer, lines are drawn directly\n    without curvature.\n\n    Args:\n        data: Array of line objects with source/target positions.\n        name: Layer ID. If None, auto-generated.\n        get_source_position: Accessor for source position [lng, lat].\n        get_target_position: Accessor for target position [lng, lat].\n        get_color: Accessor for line color [r, g, b] or [r, g, b, a].\n        get_width: Accessor for line width.\n        width_min_pixels: Minimum line width in pixels.\n        pickable: Whether layer responds to hover/click.\n        opacity: Layer opacity (0-1).\n        **kwargs: Additional LineLayer props.\n\n    Example:\n        &gt;&gt;&gt; m = DeckGLMap()\n        &gt;&gt;&gt; lines = [\n        ...     {\"sourcePosition\": [-122.4, 37.8], \"targetPosition\": [-122.5, 37.7]},\n        ...     {\"sourcePosition\": [-122.5, 37.7], \"targetPosition\": [-122.6, 37.8]},\n        ... ]\n        &gt;&gt;&gt; m.add_line_layer(\n        ...     data=lines,\n        ...     get_color=[0, 128, 255],\n        ...     get_width=2,\n        ... )\n    \"\"\"\n    layer_id = name or f\"line-{len(self._deck_layers)}\"\n    processed_data = self._process_deck_data(data)\n\n    self.call_js_method(\n        \"addLineLayer\",\n        id=layer_id,\n        data=processed_data,\n        getSourcePosition=get_source_position,\n        getTargetPosition=get_target_position,\n        getColor=get_color or [51, 136, 255, 200],\n        getWidth=get_width,\n        widthMinPixels=width_min_pixels,\n        pickable=pickable,\n        opacity=opacity,\n        **kwargs,\n    )\n\n    self._deck_layers = {\n        **self._deck_layers,\n        layer_id: {\"type\": \"LineLayer\", \"id\": layer_id},\n    }\n</code></pre>"},{"location":"deckgl/#anymap_ts.deckgl.DeckGLMap.add_mvt_layer","title":"<code>add_mvt_layer(self, data, name=None, min_zoom=0, max_zoom=14, binary=True, get_fill_color=None, get_line_color=None, get_line_width=1, get_point_radius=5, line_width_min_pixels=1, point_radius_min_pixels=2, pickable=True, visible=True, opacity=1.0, **kwargs)</code>","text":"<p>Add a Mapbox Vector Tile (MVT) layer.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Union[str, List[str]]</code> <p>MVT tile URL template with {z}/{x}/{y} placeholders.</p> required <code>name</code> <code>Optional[str]</code> <p>Layer ID.</p> <code>None</code> <code>min_zoom</code> <code>int</code> <p>Minimum zoom level.</p> <code>0</code> <code>max_zoom</code> <code>int</code> <p>Maximum zoom level.</p> <code>14</code> <code>binary</code> <code>bool</code> <p>Whether to use binary format.</p> <code>True</code> <code>get_fill_color</code> <code>Union[List[int], str, Callable]</code> <p>Accessor for fill color [r, g, b, a].</p> <code>None</code> <code>get_line_color</code> <code>Union[List[int], str, Callable]</code> <p>Accessor for stroke color [r, g, b, a].</p> <code>None</code> <code>get_line_width</code> <code>Union[float, str, Callable]</code> <p>Accessor for line width.</p> <code>1</code> <code>get_point_radius</code> <code>Union[float, str, Callable]</code> <p>Accessor for point radius.</p> <code>5</code> <code>line_width_min_pixels</code> <code>float</code> <p>Minimum line width in pixels.</p> <code>1</code> <code>point_radius_min_pixels</code> <code>float</code> <p>Minimum point radius in pixels.</p> <code>2</code> <code>pickable</code> <code>bool</code> <p>Whether layer responds to hover/click.</p> <code>True</code> <code>visible</code> <code>bool</code> <p>Whether layer is visible.</p> <code>True</code> <code>opacity</code> <code>float</code> <p>Layer opacity (0-1).</p> <code>1.0</code> <code>**kwargs</code> <p>Additional MVTLayer props.</p> <code>{}</code> Source code in <code>anymap_ts/deckgl.py</code> <pre><code>def add_mvt_layer(\n    self,\n    data: Union[str, List[str]],\n    name: Optional[str] = None,\n    min_zoom: int = 0,\n    max_zoom: int = 14,\n    binary: bool = True,\n    get_fill_color: Union[List[int], str, Callable] = None,\n    get_line_color: Union[List[int], str, Callable] = None,\n    get_line_width: Union[float, str, Callable] = 1,\n    get_point_radius: Union[float, str, Callable] = 5,\n    line_width_min_pixels: float = 1,\n    point_radius_min_pixels: float = 2,\n    pickable: bool = True,\n    visible: bool = True,\n    opacity: float = 1.0,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a Mapbox Vector Tile (MVT) layer.\n\n    Args:\n        data: MVT tile URL template with {z}/{x}/{y} placeholders.\n        name: Layer ID.\n        min_zoom: Minimum zoom level.\n        max_zoom: Maximum zoom level.\n        binary: Whether to use binary format.\n        get_fill_color: Accessor for fill color [r, g, b, a].\n        get_line_color: Accessor for stroke color [r, g, b, a].\n        get_line_width: Accessor for line width.\n        get_point_radius: Accessor for point radius.\n        line_width_min_pixels: Minimum line width in pixels.\n        point_radius_min_pixels: Minimum point radius in pixels.\n        pickable: Whether layer responds to hover/click.\n        visible: Whether layer is visible.\n        opacity: Layer opacity (0-1).\n        **kwargs: Additional MVTLayer props.\n    \"\"\"\n    layer_id = name or f\"mvt-{len(self._deck_layers)}\"\n\n    self.call_js_method(\n        \"addMVTLayer\",\n        id=layer_id,\n        data=data,\n        minZoom=min_zoom,\n        maxZoom=max_zoom,\n        binary=binary,\n        getFillColor=get_fill_color or [51, 136, 255, 128],\n        getLineColor=get_line_color or [0, 0, 0, 255],\n        getLineWidth=get_line_width,\n        getPointRadius=get_point_radius,\n        lineWidthMinPixels=line_width_min_pixels,\n        pointRadiusMinPixels=point_radius_min_pixels,\n        pickable=pickable,\n        visible=visible,\n        opacity=opacity,\n        **kwargs,\n    )\n\n    self._deck_layers = {\n        **self._deck_layers,\n        layer_id: {\"type\": \"MVTLayer\", \"id\": layer_id},\n    }\n</code></pre>"},{"location":"deckgl/#anymap_ts.deckgl.DeckGLMap.add_path_layer","title":"<code>add_path_layer(self, data, name=None, get_path='path', get_color=None, get_width=1, width_scale=1, width_min_pixels=1, pickable=True, opacity=0.8, **kwargs)</code>","text":"<p>Add a path layer for polyline visualization.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>Array of data objects with path coordinates.</p> required <code>name</code> <code>Optional[str]</code> <p>Layer ID.</p> <code>None</code> <code>get_path</code> <code>Union[str, Callable]</code> <p>Accessor for path coordinates [[lng, lat], ...].</p> <code>'path'</code> <code>get_color</code> <code>Union[List[int], str, Callable]</code> <p>Accessor for path color [r, g, b, a].</p> <code>None</code> <code>get_width</code> <code>Union[float, str, Callable]</code> <p>Accessor for path width.</p> <code>1</code> <code>width_scale</code> <code>float</code> <p>Global width multiplier.</p> <code>1</code> <code>width_min_pixels</code> <code>float</code> <p>Minimum width in pixels.</p> <code>1</code> <code>pickable</code> <code>bool</code> <p>Whether layer responds to hover/click.</p> <code>True</code> <code>opacity</code> <code>float</code> <p>Layer opacity.</p> <code>0.8</code> <code>**kwargs</code> <p>Additional layer props.</p> <code>{}</code> Source code in <code>anymap_ts/deckgl.py</code> <pre><code>def add_path_layer(\n    self,\n    data: Any,\n    name: Optional[str] = None,\n    get_path: Union[str, Callable] = \"path\",\n    get_color: Union[List[int], str, Callable] = None,\n    get_width: Union[float, str, Callable] = 1,\n    width_scale: float = 1,\n    width_min_pixels: float = 1,\n    pickable: bool = True,\n    opacity: float = 0.8,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a path layer for polyline visualization.\n\n    Args:\n        data: Array of data objects with path coordinates.\n        name: Layer ID.\n        get_path: Accessor for path coordinates [[lng, lat], ...].\n        get_color: Accessor for path color [r, g, b, a].\n        get_width: Accessor for path width.\n        width_scale: Global width multiplier.\n        width_min_pixels: Minimum width in pixels.\n        pickable: Whether layer responds to hover/click.\n        opacity: Layer opacity.\n        **kwargs: Additional layer props.\n    \"\"\"\n    layer_id = name or f\"path-{len(self._deck_layers)}\"\n    processed_data = self._process_deck_data(data)\n\n    self.call_js_method(\n        \"addPathLayer\",\n        id=layer_id,\n        data=processed_data,\n        getPath=get_path,\n        getColor=get_color or [51, 136, 255, 200],\n        getWidth=get_width,\n        widthScale=width_scale,\n        widthMinPixels=width_min_pixels,\n        pickable=pickable,\n        opacity=opacity,\n        **kwargs,\n    )\n\n    self._deck_layers = {\n        **self._deck_layers,\n        layer_id: {\"type\": \"PathLayer\", \"id\": layer_id},\n    }\n</code></pre>"},{"location":"deckgl/#anymap_ts.deckgl.DeckGLMap.add_point_cloud_layer","title":"<code>add_point_cloud_layer(self, data, name=None, get_position='position', get_color=None, get_normal=None, point_size=2, size_units='pixels', coordinate_system=None, coordinate_origin=None, pickable=True, opacity=1.0, **kwargs)</code>","text":"<p>Add a point cloud layer for 3D point visualization.</p> <p>Renders large point cloud datasets typically from LiDAR or 3D scanning. Supports both 2D and 3D coordinates with optional normal vectors for lighting effects.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>Array of point data with position [x, y, z] coordinates.</p> required <code>name</code> <code>Optional[str]</code> <p>Layer ID. If None, auto-generated.</p> <code>None</code> <code>get_position</code> <code>Union[str, Callable]</code> <p>Accessor for point position [x, y, z].</p> <code>'position'</code> <code>get_color</code> <code>Union[List[int], str, Callable]</code> <p>Accessor for point color [r, g, b, a].</p> <code>None</code> <code>get_normal</code> <code>Union[str, Callable]</code> <p>Accessor for point normal [nx, ny, nz] for lighting.</p> <code>None</code> <code>point_size</code> <code>float</code> <p>Point size in size_units.</p> <code>2</code> <code>size_units</code> <code>str</code> <p>Units for point_size ('pixels' or 'meters').</p> <code>'pixels'</code> <code>coordinate_system</code> <code>Optional[str]</code> <p>Coordinate system ('CARTESIAN', 'METER_OFFSETS', 'LNGLAT', 'LNGLAT_OFFSETS').</p> <code>None</code> <code>coordinate_origin</code> <code>Optional[List[float]]</code> <p>Origin for offset coordinate systems [lng, lat, z].</p> <code>None</code> <code>pickable</code> <code>bool</code> <p>Whether layer responds to hover/click.</p> <code>True</code> <code>opacity</code> <code>float</code> <p>Layer opacity (0-1).</p> <code>1.0</code> <code>**kwargs</code> <p>Additional PointCloudLayer props.</p> <code>{}</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; m = DeckGLMap()\n&gt;&gt;&gt; points = [\n...     {\"position\": [-122.4, 37.8, 100], \"color\": [255, 0, 0]},\n...     {\"position\": [-122.5, 37.7, 200], \"color\": [0, 255, 0]},\n... ]\n&gt;&gt;&gt; m.add_point_cloud_layer(\n...     data=points,\n...     point_size=5,\n...     get_color=\"color\"\n... )\n</code></pre> Source code in <code>anymap_ts/deckgl.py</code> <pre><code>def add_point_cloud_layer(\n    self,\n    data: Any,\n    name: Optional[str] = None,\n    get_position: Union[str, Callable] = \"position\",\n    get_color: Union[List[int], str, Callable] = None,\n    get_normal: Union[str, Callable] = None,\n    point_size: float = 2,\n    size_units: str = \"pixels\",\n    coordinate_system: Optional[str] = None,\n    coordinate_origin: Optional[List[float]] = None,\n    pickable: bool = True,\n    opacity: float = 1.0,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a point cloud layer for 3D point visualization.\n\n    Renders large point cloud datasets typically from LiDAR or 3D scanning.\n    Supports both 2D and 3D coordinates with optional normal vectors for\n    lighting effects.\n\n    Args:\n        data: Array of point data with position [x, y, z] coordinates.\n        name: Layer ID. If None, auto-generated.\n        get_position: Accessor for point position [x, y, z].\n        get_color: Accessor for point color [r, g, b, a].\n        get_normal: Accessor for point normal [nx, ny, nz] for lighting.\n        point_size: Point size in size_units.\n        size_units: Units for point_size ('pixels' or 'meters').\n        coordinate_system: Coordinate system ('CARTESIAN', 'METER_OFFSETS',\n            'LNGLAT', 'LNGLAT_OFFSETS').\n        coordinate_origin: Origin for offset coordinate systems [lng, lat, z].\n        pickable: Whether layer responds to hover/click.\n        opacity: Layer opacity (0-1).\n        **kwargs: Additional PointCloudLayer props.\n\n    Example:\n        &gt;&gt;&gt; m = DeckGLMap()\n        &gt;&gt;&gt; points = [\n        ...     {\"position\": [-122.4, 37.8, 100], \"color\": [255, 0, 0]},\n        ...     {\"position\": [-122.5, 37.7, 200], \"color\": [0, 255, 0]},\n        ... ]\n        &gt;&gt;&gt; m.add_point_cloud_layer(\n        ...     data=points,\n        ...     point_size=5,\n        ...     get_color=\"color\"\n        ... )\n    \"\"\"\n    layer_id = name or f\"pointcloud-{len(self._deck_layers)}\"\n    processed_data = self._process_deck_data(data)\n\n    layer_kwargs = {\n        \"id\": layer_id,\n        \"data\": processed_data,\n        \"getPosition\": get_position,\n        \"getColor\": get_color or [255, 255, 255, 255],\n        \"pointSize\": point_size,\n        \"sizeUnits\": size_units,\n        \"pickable\": pickable,\n        \"opacity\": opacity,\n    }\n\n    if get_normal is not None:\n        layer_kwargs[\"getNormal\"] = get_normal\n\n    if coordinate_system is not None:\n        layer_kwargs[\"coordinateSystem\"] = coordinate_system\n\n    if coordinate_origin is not None:\n        layer_kwargs[\"coordinateOrigin\"] = coordinate_origin\n\n    layer_kwargs.update(kwargs)\n    self.call_js_method(\"addPointCloudLayer\", **layer_kwargs)\n\n    self._deck_layers = {\n        **self._deck_layers,\n        layer_id: {\"type\": \"PointCloudLayer\", \"id\": layer_id},\n    }\n</code></pre>"},{"location":"deckgl/#anymap_ts.deckgl.DeckGLMap.add_polygon_layer","title":"<code>add_polygon_layer(self, data, name=None, get_polygon='polygon', get_fill_color=None, get_line_color=None, get_line_width=1, get_elevation=0, extruded=False, wireframe=False, filled=True, stroked=True, line_width_min_pixels=1, pickable=True, opacity=0.5, **kwargs)</code>","text":"<p>Add a polygon layer for filled polygon visualization.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>Array of data objects with polygon coordinates.</p> required <code>name</code> <code>Optional[str]</code> <p>Layer ID.</p> <code>None</code> <code>get_polygon</code> <code>Union[str, Callable]</code> <p>Accessor for polygon coordinates.</p> <code>'polygon'</code> <code>get_fill_color</code> <code>Union[List[int], str, Callable]</code> <p>Accessor for fill color [r, g, b, a].</p> <code>None</code> <code>get_line_color</code> <code>Union[List[int], str, Callable]</code> <p>Accessor for stroke color [r, g, b, a].</p> <code>None</code> <code>get_line_width</code> <code>Union[float, str, Callable]</code> <p>Accessor for stroke width.</p> <code>1</code> <code>get_elevation</code> <code>Union[float, str, Callable]</code> <p>Accessor for 3D extrusion height.</p> <code>0</code> <code>extruded</code> <code>bool</code> <p>Whether to render as 3D polygons.</p> <code>False</code> <code>wireframe</code> <code>bool</code> <p>Whether to render wireframe (extruded only).</p> <code>False</code> <code>filled</code> <code>bool</code> <p>Whether to fill polygons.</p> <code>True</code> <code>stroked</code> <code>bool</code> <p>Whether to draw stroke.</p> <code>True</code> <code>line_width_min_pixels</code> <code>float</code> <p>Minimum stroke width.</p> <code>1</code> <code>pickable</code> <code>bool</code> <p>Whether layer responds to hover/click.</p> <code>True</code> <code>opacity</code> <code>float</code> <p>Layer opacity.</p> <code>0.5</code> <code>**kwargs</code> <p>Additional layer props.</p> <code>{}</code> Source code in <code>anymap_ts/deckgl.py</code> <pre><code>def add_polygon_layer(\n    self,\n    data: Any,\n    name: Optional[str] = None,\n    get_polygon: Union[str, Callable] = \"polygon\",\n    get_fill_color: Union[List[int], str, Callable] = None,\n    get_line_color: Union[List[int], str, Callable] = None,\n    get_line_width: Union[float, str, Callable] = 1,\n    get_elevation: Union[float, str, Callable] = 0,\n    extruded: bool = False,\n    wireframe: bool = False,\n    filled: bool = True,\n    stroked: bool = True,\n    line_width_min_pixels: float = 1,\n    pickable: bool = True,\n    opacity: float = 0.5,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a polygon layer for filled polygon visualization.\n\n    Args:\n        data: Array of data objects with polygon coordinates.\n        name: Layer ID.\n        get_polygon: Accessor for polygon coordinates.\n        get_fill_color: Accessor for fill color [r, g, b, a].\n        get_line_color: Accessor for stroke color [r, g, b, a].\n        get_line_width: Accessor for stroke width.\n        get_elevation: Accessor for 3D extrusion height.\n        extruded: Whether to render as 3D polygons.\n        wireframe: Whether to render wireframe (extruded only).\n        filled: Whether to fill polygons.\n        stroked: Whether to draw stroke.\n        line_width_min_pixels: Minimum stroke width.\n        pickable: Whether layer responds to hover/click.\n        opacity: Layer opacity.\n        **kwargs: Additional layer props.\n    \"\"\"\n    layer_id = name or f\"polygon-{len(self._deck_layers)}\"\n    processed_data = self._process_deck_data(data)\n\n    self.call_js_method(\n        \"addPolygonLayer\",\n        id=layer_id,\n        data=processed_data,\n        getPolygon=get_polygon,\n        getFillColor=get_fill_color or [51, 136, 255, 128],\n        getLineColor=get_line_color or [0, 0, 255, 255],\n        getLineWidth=get_line_width,\n        getElevation=get_elevation,\n        extruded=extruded,\n        wireframe=wireframe,\n        filled=filled,\n        stroked=stroked,\n        lineWidthMinPixels=line_width_min_pixels,\n        pickable=pickable,\n        opacity=opacity,\n        **kwargs,\n    )\n\n    self._deck_layers = {\n        **self._deck_layers,\n        layer_id: {\"type\": \"PolygonLayer\", \"id\": layer_id},\n    }\n</code></pre>"},{"location":"deckgl/#anymap_ts.deckgl.DeckGLMap.add_quadkey_layer","title":"<code>add_quadkey_layer(self, data, name=None, get_quadkey='quadkey', get_fill_color=None, get_line_color=None, get_line_width=1, get_elevation=0, filled=True, stroked=True, extruded=False, wireframe=False, elevation_scale=1, pickable=True, opacity=0.8, **kwargs)</code>","text":"<p>Add a Quadkey layer for Bing Maps tile index visualization.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>Array of data objects with quadkey.</p> required <code>name</code> <code>Optional[str]</code> <p>Layer ID.</p> <code>None</code> <code>get_quadkey</code> <code>Union[str, Callable]</code> <p>Accessor for quadkey string.</p> <code>'quadkey'</code> <code>get_fill_color</code> <code>Union[List[int], str, Callable]</code> <p>Accessor for fill color [r, g, b, a].</p> <code>None</code> <code>get_line_color</code> <code>Union[List[int], str, Callable]</code> <p>Accessor for stroke color [r, g, b, a].</p> <code>None</code> <code>get_line_width</code> <code>Union[float, str, Callable]</code> <p>Accessor for line width.</p> <code>1</code> <code>get_elevation</code> <code>Union[float, str, Callable]</code> <p>Accessor for 3D extrusion height.</p> <code>0</code> <code>filled</code> <code>bool</code> <p>Whether to fill cells.</p> <code>True</code> <code>stroked</code> <code>bool</code> <p>Whether to stroke cells.</p> <code>True</code> <code>extruded</code> <code>bool</code> <p>Whether to render as 3D.</p> <code>False</code> <code>wireframe</code> <code>bool</code> <p>Whether to render wireframe.</p> <code>False</code> <code>elevation_scale</code> <code>float</code> <p>Elevation multiplier.</p> <code>1</code> <code>pickable</code> <code>bool</code> <p>Whether layer responds to hover/click.</p> <code>True</code> <code>opacity</code> <code>float</code> <p>Layer opacity.</p> <code>0.8</code> <code>**kwargs</code> <p>Additional QuadkeyLayer props.</p> <code>{}</code> Source code in <code>anymap_ts/deckgl.py</code> <pre><code>def add_quadkey_layer(\n    self,\n    data: Any,\n    name: Optional[str] = None,\n    get_quadkey: Union[str, Callable] = \"quadkey\",\n    get_fill_color: Union[List[int], str, Callable] = None,\n    get_line_color: Union[List[int], str, Callable] = None,\n    get_line_width: Union[float, str, Callable] = 1,\n    get_elevation: Union[float, str, Callable] = 0,\n    filled: bool = True,\n    stroked: bool = True,\n    extruded: bool = False,\n    wireframe: bool = False,\n    elevation_scale: float = 1,\n    pickable: bool = True,\n    opacity: float = 0.8,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a Quadkey layer for Bing Maps tile index visualization.\n\n    Args:\n        data: Array of data objects with quadkey.\n        name: Layer ID.\n        get_quadkey: Accessor for quadkey string.\n        get_fill_color: Accessor for fill color [r, g, b, a].\n        get_line_color: Accessor for stroke color [r, g, b, a].\n        get_line_width: Accessor for line width.\n        get_elevation: Accessor for 3D extrusion height.\n        filled: Whether to fill cells.\n        stroked: Whether to stroke cells.\n        extruded: Whether to render as 3D.\n        wireframe: Whether to render wireframe.\n        elevation_scale: Elevation multiplier.\n        pickable: Whether layer responds to hover/click.\n        opacity: Layer opacity.\n        **kwargs: Additional QuadkeyLayer props.\n    \"\"\"\n    layer_id = name or f\"quadkey-{len(self._deck_layers)}\"\n    processed_data = self._process_deck_data(data)\n\n    self.call_js_method(\n        \"addQuadkeyLayer\",\n        id=layer_id,\n        data=processed_data,\n        getQuadkey=get_quadkey,\n        getFillColor=get_fill_color or [51, 136, 255, 128],\n        getLineColor=get_line_color or [0, 0, 0, 255],\n        getLineWidth=get_line_width,\n        getElevation=get_elevation,\n        filled=filled,\n        stroked=stroked,\n        extruded=extruded,\n        wireframe=wireframe,\n        elevationScale=elevation_scale,\n        pickable=pickable,\n        opacity=opacity,\n        **kwargs,\n    )\n\n    self._deck_layers = {\n        **self._deck_layers,\n        layer_id: {\"type\": \"QuadkeyLayer\", \"id\": layer_id},\n    }\n</code></pre>"},{"location":"deckgl/#anymap_ts.deckgl.DeckGLMap.add_s2_layer","title":"<code>add_s2_layer(self, data, name=None, get_s2_token='s2Token', get_fill_color=None, get_line_color=None, get_line_width=1, get_elevation=0, filled=True, stroked=True, extruded=False, wireframe=False, elevation_scale=1, pickable=True, opacity=0.8, **kwargs)</code>","text":"<p>Add an S2 layer for S2 geometry cell visualization.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>Array of data objects with S2 token.</p> required <code>name</code> <code>Optional[str]</code> <p>Layer ID.</p> <code>None</code> <code>get_s2_token</code> <code>Union[str, Callable]</code> <p>Accessor for S2 token string.</p> <code>'s2Token'</code> <code>get_fill_color</code> <code>Union[List[int], str, Callable]</code> <p>Accessor for fill color [r, g, b, a].</p> <code>None</code> <code>get_line_color</code> <code>Union[List[int], str, Callable]</code> <p>Accessor for stroke color [r, g, b, a].</p> <code>None</code> <code>get_line_width</code> <code>Union[float, str, Callable]</code> <p>Accessor for line width.</p> <code>1</code> <code>get_elevation</code> <code>Union[float, str, Callable]</code> <p>Accessor for 3D extrusion height.</p> <code>0</code> <code>filled</code> <code>bool</code> <p>Whether to fill cells.</p> <code>True</code> <code>stroked</code> <code>bool</code> <p>Whether to stroke cells.</p> <code>True</code> <code>extruded</code> <code>bool</code> <p>Whether to render as 3D.</p> <code>False</code> <code>wireframe</code> <code>bool</code> <p>Whether to render wireframe.</p> <code>False</code> <code>elevation_scale</code> <code>float</code> <p>Elevation multiplier.</p> <code>1</code> <code>pickable</code> <code>bool</code> <p>Whether layer responds to hover/click.</p> <code>True</code> <code>opacity</code> <code>float</code> <p>Layer opacity.</p> <code>0.8</code> <code>**kwargs</code> <p>Additional S2Layer props.</p> <code>{}</code> Source code in <code>anymap_ts/deckgl.py</code> <pre><code>def add_s2_layer(\n    self,\n    data: Any,\n    name: Optional[str] = None,\n    get_s2_token: Union[str, Callable] = \"s2Token\",\n    get_fill_color: Union[List[int], str, Callable] = None,\n    get_line_color: Union[List[int], str, Callable] = None,\n    get_line_width: Union[float, str, Callable] = 1,\n    get_elevation: Union[float, str, Callable] = 0,\n    filled: bool = True,\n    stroked: bool = True,\n    extruded: bool = False,\n    wireframe: bool = False,\n    elevation_scale: float = 1,\n    pickable: bool = True,\n    opacity: float = 0.8,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add an S2 layer for S2 geometry cell visualization.\n\n    Args:\n        data: Array of data objects with S2 token.\n        name: Layer ID.\n        get_s2_token: Accessor for S2 token string.\n        get_fill_color: Accessor for fill color [r, g, b, a].\n        get_line_color: Accessor for stroke color [r, g, b, a].\n        get_line_width: Accessor for line width.\n        get_elevation: Accessor for 3D extrusion height.\n        filled: Whether to fill cells.\n        stroked: Whether to stroke cells.\n        extruded: Whether to render as 3D.\n        wireframe: Whether to render wireframe.\n        elevation_scale: Elevation multiplier.\n        pickable: Whether layer responds to hover/click.\n        opacity: Layer opacity.\n        **kwargs: Additional S2Layer props.\n    \"\"\"\n    layer_id = name or f\"s2-{len(self._deck_layers)}\"\n    processed_data = self._process_deck_data(data)\n\n    self.call_js_method(\n        \"addS2Layer\",\n        id=layer_id,\n        data=processed_data,\n        getS2Token=get_s2_token,\n        getFillColor=get_fill_color or [51, 136, 255, 128],\n        getLineColor=get_line_color or [0, 0, 0, 255],\n        getLineWidth=get_line_width,\n        getElevation=get_elevation,\n        filled=filled,\n        stroked=stroked,\n        extruded=extruded,\n        wireframe=wireframe,\n        elevationScale=elevation_scale,\n        pickable=pickable,\n        opacity=opacity,\n        **kwargs,\n    )\n\n    self._deck_layers = {\n        **self._deck_layers,\n        layer_id: {\"type\": \"S2Layer\", \"id\": layer_id},\n    }\n</code></pre>"},{"location":"deckgl/#anymap_ts.deckgl.DeckGLMap.add_scatterplot_layer","title":"<code>add_scatterplot_layer(self, data, name=None, get_position='coordinates', get_radius=5, get_fill_color=None, get_line_color=None, radius_scale=1, radius_min_pixels=1, radius_max_pixels=100, line_width_min_pixels=1, stroked=True, filled=True, pickable=True, opacity=0.8, **kwargs)</code>","text":"<p>Add a scatterplot layer for point visualization.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>Array of data objects or GeoJSON.</p> required <code>name</code> <code>Optional[str]</code> <p>Layer ID.</p> <code>None</code> <code>get_position</code> <code>Union[str, Callable]</code> <p>Accessor for point position [lng, lat].</p> <code>'coordinates'</code> <code>get_radius</code> <code>Union[float, str, Callable]</code> <p>Accessor for point radius.</p> <code>5</code> <code>get_fill_color</code> <code>Union[List[int], str, Callable]</code> <p>Accessor for fill color [r, g, b, a].</p> <code>None</code> <code>get_line_color</code> <code>Union[List[int], str, Callable]</code> <p>Accessor for stroke color [r, g, b, a].</p> <code>None</code> <code>radius_scale</code> <code>float</code> <p>Global radius multiplier.</p> <code>1</code> <code>radius_min_pixels</code> <code>float</code> <p>Minimum radius in pixels.</p> <code>1</code> <code>radius_max_pixels</code> <code>float</code> <p>Maximum radius in pixels.</p> <code>100</code> <code>line_width_min_pixels</code> <code>float</code> <p>Minimum stroke width.</p> <code>1</code> <code>stroked</code> <code>bool</code> <p>Whether to draw stroke.</p> <code>True</code> <code>filled</code> <code>bool</code> <p>Whether to fill points.</p> <code>True</code> <code>pickable</code> <code>bool</code> <p>Whether layer responds to hover/click.</p> <code>True</code> <code>opacity</code> <code>float</code> <p>Layer opacity.</p> <code>0.8</code> <code>**kwargs</code> <p>Additional layer props.</p> <code>{}</code> Source code in <code>anymap_ts/deckgl.py</code> <pre><code>def add_scatterplot_layer(\n    self,\n    data: Any,\n    name: Optional[str] = None,\n    get_position: Union[str, Callable] = \"coordinates\",\n    get_radius: Union[float, str, Callable] = 5,\n    get_fill_color: Union[List[int], str, Callable] = None,\n    get_line_color: Union[List[int], str, Callable] = None,\n    radius_scale: float = 1,\n    radius_min_pixels: float = 1,\n    radius_max_pixels: float = 100,\n    line_width_min_pixels: float = 1,\n    stroked: bool = True,\n    filled: bool = True,\n    pickable: bool = True,\n    opacity: float = 0.8,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a scatterplot layer for point visualization.\n\n    Args:\n        data: Array of data objects or GeoJSON.\n        name: Layer ID.\n        get_position: Accessor for point position [lng, lat].\n        get_radius: Accessor for point radius.\n        get_fill_color: Accessor for fill color [r, g, b, a].\n        get_line_color: Accessor for stroke color [r, g, b, a].\n        radius_scale: Global radius multiplier.\n        radius_min_pixels: Minimum radius in pixels.\n        radius_max_pixels: Maximum radius in pixels.\n        line_width_min_pixels: Minimum stroke width.\n        stroked: Whether to draw stroke.\n        filled: Whether to fill points.\n        pickable: Whether layer responds to hover/click.\n        opacity: Layer opacity.\n        **kwargs: Additional layer props.\n    \"\"\"\n    layer_id = name or f\"scatterplot-{len(self._deck_layers)}\"\n    processed_data = self._process_deck_data(data)\n\n    self.call_js_method(\n        \"addScatterplotLayer\",\n        id=layer_id,\n        data=processed_data,\n        getPosition=get_position,\n        getRadius=get_radius,\n        getFillColor=get_fill_color or [51, 136, 255, 200],\n        getLineColor=get_line_color or [255, 255, 255, 255],\n        radiusScale=radius_scale,\n        radiusMinPixels=radius_min_pixels,\n        radiusMaxPixels=radius_max_pixels,\n        lineWidthMinPixels=line_width_min_pixels,\n        stroked=stroked,\n        filled=filled,\n        pickable=pickable,\n        opacity=opacity,\n        **kwargs,\n    )\n\n    self._deck_layers = {\n        **self._deck_layers,\n        layer_id: {\"type\": \"ScatterplotLayer\", \"id\": layer_id},\n    }\n</code></pre>"},{"location":"deckgl/#anymap_ts.deckgl.DeckGLMap.add_scenegraph_layer","title":"<code>add_scenegraph_layer(self, data, scenegraph, name=None, get_position='coordinates', get_color=None, get_orientation=None, get_scale=None, get_translation=None, size_scale=1, size_min_pixels=0, size_max_pixels=10000, pickable=True, opacity=1.0, **kwargs)</code>","text":"<p>Add a scenegraph layer for glTF model visualization.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>Array of data objects with position coordinates.</p> required <code>scenegraph</code> <code>str</code> <p>URL to glTF/GLB model file.</p> required <code>name</code> <code>Optional[str]</code> <p>Layer ID.</p> <code>None</code> <code>get_position</code> <code>Union[str, Callable]</code> <p>Accessor for model position [lng, lat, z].</p> <code>'coordinates'</code> <code>get_color</code> <code>Union[List[int], str, Callable]</code> <p>Accessor for model tint color [r, g, b, a].</p> <code>None</code> <code>get_orientation</code> <code>Union[str, Callable]</code> <p>Accessor for model orientation [pitch, yaw, roll].</p> <code>None</code> <code>get_scale</code> <code>Union[str, Callable]</code> <p>Accessor for model scale [x, y, z].</p> <code>None</code> <code>get_translation</code> <code>Union[str, Callable]</code> <p>Accessor for model translation [x, y, z].</p> <code>None</code> <code>size_scale</code> <code>float</code> <p>Global size multiplier.</p> <code>1</code> <code>size_min_pixels</code> <code>float</code> <p>Minimum model size in pixels.</p> <code>0</code> <code>size_max_pixels</code> <code>float</code> <p>Maximum model size in pixels.</p> <code>10000</code> <code>pickable</code> <code>bool</code> <p>Whether layer responds to hover/click.</p> <code>True</code> <code>opacity</code> <code>float</code> <p>Layer opacity (0-1).</p> <code>1.0</code> <code>**kwargs</code> <p>Additional ScenegraphLayer props.</p> <code>{}</code> Source code in <code>anymap_ts/deckgl.py</code> <pre><code>def add_scenegraph_layer(\n    self,\n    data: Any,\n    scenegraph: str,\n    name: Optional[str] = None,\n    get_position: Union[str, Callable] = \"coordinates\",\n    get_color: Union[List[int], str, Callable] = None,\n    get_orientation: Union[str, Callable] = None,\n    get_scale: Union[str, Callable] = None,\n    get_translation: Union[str, Callable] = None,\n    size_scale: float = 1,\n    size_min_pixels: float = 0,\n    size_max_pixels: float = 10000,\n    pickable: bool = True,\n    opacity: float = 1.0,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a scenegraph layer for glTF model visualization.\n\n    Args:\n        data: Array of data objects with position coordinates.\n        scenegraph: URL to glTF/GLB model file.\n        name: Layer ID.\n        get_position: Accessor for model position [lng, lat, z].\n        get_color: Accessor for model tint color [r, g, b, a].\n        get_orientation: Accessor for model orientation [pitch, yaw, roll].\n        get_scale: Accessor for model scale [x, y, z].\n        get_translation: Accessor for model translation [x, y, z].\n        size_scale: Global size multiplier.\n        size_min_pixels: Minimum model size in pixels.\n        size_max_pixels: Maximum model size in pixels.\n        pickable: Whether layer responds to hover/click.\n        opacity: Layer opacity (0-1).\n        **kwargs: Additional ScenegraphLayer props.\n    \"\"\"\n    layer_id = name or f\"scenegraph-{len(self._deck_layers)}\"\n    processed_data = self._process_deck_data(data)\n\n    layer_kwargs = {\n        \"id\": layer_id,\n        \"data\": processed_data,\n        \"scenegraph\": scenegraph,\n        \"getPosition\": get_position,\n        \"getColor\": get_color or [255, 255, 255, 255],\n        \"sizeScale\": size_scale,\n        \"sizeMinPixels\": size_min_pixels,\n        \"sizeMaxPixels\": size_max_pixels,\n        \"pickable\": pickable,\n        \"opacity\": opacity,\n    }\n\n    if get_orientation:\n        layer_kwargs[\"getOrientation\"] = get_orientation\n    if get_scale:\n        layer_kwargs[\"getScale\"] = get_scale\n    if get_translation:\n        layer_kwargs[\"getTranslation\"] = get_translation\n\n    layer_kwargs.update(kwargs)\n    self.call_js_method(\"addScenegraphLayer\", **layer_kwargs)\n\n    self._deck_layers = {\n        **self._deck_layers,\n        layer_id: {\"type\": \"ScenegraphLayer\", \"id\": layer_id},\n    }\n</code></pre>"},{"location":"deckgl/#anymap_ts.deckgl.DeckGLMap.add_screen_grid_layer","title":"<code>add_screen_grid_layer(self, data, name=None, get_position='coordinates', get_weight=1, cell_size_pixels=50, color_range=None, pickable=True, opacity=0.8, **kwargs)</code>","text":"<p>Add a screen grid layer for screen-space grid aggregation.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>Array of data objects with position coordinates.</p> required <code>name</code> <code>Optional[str]</code> <p>Layer ID.</p> <code>None</code> <code>get_position</code> <code>Union[str, Callable]</code> <p>Accessor for point position [lng, lat].</p> <code>'coordinates'</code> <code>get_weight</code> <code>Union[float, str, Callable]</code> <p>Accessor for point weight.</p> <code>1</code> <code>cell_size_pixels</code> <code>float</code> <p>Grid cell size in pixels.</p> <code>50</code> <code>color_range</code> <code>Optional[List[List[int]]]</code> <p>Color gradient [[r, g, b, a], ...].</p> <code>None</code> <code>pickable</code> <code>bool</code> <p>Whether layer responds to hover/click.</p> <code>True</code> <code>opacity</code> <code>float</code> <p>Layer opacity.</p> <code>0.8</code> <code>**kwargs</code> <p>Additional layer props.</p> <code>{}</code> Source code in <code>anymap_ts/deckgl.py</code> <pre><code>def add_screen_grid_layer(\n    self,\n    data: Any,\n    name: Optional[str] = None,\n    get_position: Union[str, Callable] = \"coordinates\",\n    get_weight: Union[float, str, Callable] = 1,\n    cell_size_pixels: float = 50,\n    color_range: Optional[List[List[int]]] = None,\n    pickable: bool = True,\n    opacity: float = 0.8,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a screen grid layer for screen-space grid aggregation.\n\n    Args:\n        data: Array of data objects with position coordinates.\n        name: Layer ID.\n        get_position: Accessor for point position [lng, lat].\n        get_weight: Accessor for point weight.\n        cell_size_pixels: Grid cell size in pixels.\n        color_range: Color gradient [[r, g, b, a], ...].\n        pickable: Whether layer responds to hover/click.\n        opacity: Layer opacity.\n        **kwargs: Additional layer props.\n    \"\"\"\n    layer_id = name or f\"screengrid-{len(self._deck_layers)}\"\n    processed_data = self._process_deck_data(data)\n\n    default_color_range = [\n        [255, 255, 178, 25],\n        [254, 217, 118, 85],\n        [254, 178, 76, 127],\n        [253, 141, 60, 170],\n        [240, 59, 32, 212],\n        [189, 0, 38, 255],\n    ]\n\n    self.call_js_method(\n        \"addScreenGridLayer\",\n        id=layer_id,\n        data=processed_data,\n        getPosition=get_position,\n        getWeight=get_weight,\n        cellSizePixels=cell_size_pixels,\n        colorRange=color_range or default_color_range,\n        pickable=pickable,\n        opacity=opacity,\n        **kwargs,\n    )\n\n    self._deck_layers = {\n        **self._deck_layers,\n        layer_id: {\"type\": \"ScreenGridLayer\", \"id\": layer_id},\n    }\n</code></pre>"},{"location":"deckgl/#anymap_ts.deckgl.DeckGLMap.add_simple_mesh_layer","title":"<code>add_simple_mesh_layer(self, data, mesh, name=None, texture=None, get_position='coordinates', get_color=None, get_orientation=None, get_scale=None, get_translation=None, size_scale=1, wireframe=False, pickable=True, opacity=1.0, **kwargs)</code>","text":"<p>Add a simple mesh layer for 3D mesh visualization.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>Array of data objects with position coordinates.</p> required <code>mesh</code> <code>str</code> <p>URL to OBJ/glTF mesh file.</p> required <code>name</code> <code>Optional[str]</code> <p>Layer ID.</p> <code>None</code> <code>texture</code> <code>Optional[str]</code> <p>URL to texture image.</p> <code>None</code> <code>get_position</code> <code>Union[str, Callable]</code> <p>Accessor for mesh position [lng, lat, z].</p> <code>'coordinates'</code> <code>get_color</code> <code>Union[List[int], str, Callable]</code> <p>Accessor for mesh color [r, g, b, a].</p> <code>None</code> <code>get_orientation</code> <code>Union[str, Callable]</code> <p>Accessor for mesh orientation [pitch, yaw, roll].</p> <code>None</code> <code>get_scale</code> <code>Union[str, Callable]</code> <p>Accessor for mesh scale [x, y, z].</p> <code>None</code> <code>get_translation</code> <code>Union[str, Callable]</code> <p>Accessor for mesh translation [x, y, z].</p> <code>None</code> <code>size_scale</code> <code>float</code> <p>Global size multiplier.</p> <code>1</code> <code>wireframe</code> <code>bool</code> <p>Whether to render as wireframe.</p> <code>False</code> <code>pickable</code> <code>bool</code> <p>Whether layer responds to hover/click.</p> <code>True</code> <code>opacity</code> <code>float</code> <p>Layer opacity (0-1).</p> <code>1.0</code> <code>**kwargs</code> <p>Additional SimpleMeshLayer props.</p> <code>{}</code> Source code in <code>anymap_ts/deckgl.py</code> <pre><code>def add_simple_mesh_layer(\n    self,\n    data: Any,\n    mesh: str,\n    name: Optional[str] = None,\n    texture: Optional[str] = None,\n    get_position: Union[str, Callable] = \"coordinates\",\n    get_color: Union[List[int], str, Callable] = None,\n    get_orientation: Union[str, Callable] = None,\n    get_scale: Union[str, Callable] = None,\n    get_translation: Union[str, Callable] = None,\n    size_scale: float = 1,\n    wireframe: bool = False,\n    pickable: bool = True,\n    opacity: float = 1.0,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a simple mesh layer for 3D mesh visualization.\n\n    Args:\n        data: Array of data objects with position coordinates.\n        mesh: URL to OBJ/glTF mesh file.\n        name: Layer ID.\n        texture: URL to texture image.\n        get_position: Accessor for mesh position [lng, lat, z].\n        get_color: Accessor for mesh color [r, g, b, a].\n        get_orientation: Accessor for mesh orientation [pitch, yaw, roll].\n        get_scale: Accessor for mesh scale [x, y, z].\n        get_translation: Accessor for mesh translation [x, y, z].\n        size_scale: Global size multiplier.\n        wireframe: Whether to render as wireframe.\n        pickable: Whether layer responds to hover/click.\n        opacity: Layer opacity (0-1).\n        **kwargs: Additional SimpleMeshLayer props.\n    \"\"\"\n    layer_id = name or f\"simplemesh-{len(self._deck_layers)}\"\n    processed_data = self._process_deck_data(data)\n\n    layer_kwargs = {\n        \"id\": layer_id,\n        \"data\": processed_data,\n        \"mesh\": mesh,\n        \"getPosition\": get_position,\n        \"getColor\": get_color or [255, 255, 255, 255],\n        \"sizeScale\": size_scale,\n        \"wireframe\": wireframe,\n        \"pickable\": pickable,\n        \"opacity\": opacity,\n    }\n\n    if texture:\n        layer_kwargs[\"texture\"] = texture\n    if get_orientation:\n        layer_kwargs[\"getOrientation\"] = get_orientation\n    if get_scale:\n        layer_kwargs[\"getScale\"] = get_scale\n    if get_translation:\n        layer_kwargs[\"getTranslation\"] = get_translation\n\n    layer_kwargs.update(kwargs)\n    self.call_js_method(\"addSimpleMeshLayer\", **layer_kwargs)\n\n    self._deck_layers = {\n        **self._deck_layers,\n        layer_id: {\"type\": \"SimpleMeshLayer\", \"id\": layer_id},\n    }\n</code></pre>"},{"location":"deckgl/#anymap_ts.deckgl.DeckGLMap.add_solid_polygon_layer","title":"<code>add_solid_polygon_layer(self, data, name=None, get_polygon='polygon', get_fill_color=None, get_line_color=None, get_elevation=0, filled=True, extruded=False, wireframe=False, elevation_scale=1, pickable=True, opacity=0.8, **kwargs)</code>","text":"<p>Add a solid polygon layer for filled polygon visualization.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>Array of data objects with polygon coordinates.</p> required <code>name</code> <code>Optional[str]</code> <p>Layer ID.</p> <code>None</code> <code>get_polygon</code> <code>Union[str, Callable]</code> <p>Accessor for polygon coordinates.</p> <code>'polygon'</code> <code>get_fill_color</code> <code>Union[List[int], str, Callable]</code> <p>Accessor for fill color [r, g, b, a].</p> <code>None</code> <code>get_line_color</code> <code>Union[List[int], str, Callable]</code> <p>Accessor for stroke color [r, g, b, a].</p> <code>None</code> <code>get_elevation</code> <code>Union[float, str, Callable]</code> <p>Accessor for 3D extrusion height.</p> <code>0</code> <code>filled</code> <code>bool</code> <p>Whether to fill polygons.</p> <code>True</code> <code>extruded</code> <code>bool</code> <p>Whether to render as 3D polygons.</p> <code>False</code> <code>wireframe</code> <code>bool</code> <p>Whether to render wireframe.</p> <code>False</code> <code>elevation_scale</code> <code>float</code> <p>Elevation multiplier.</p> <code>1</code> <code>pickable</code> <code>bool</code> <p>Whether layer responds to hover/click.</p> <code>True</code> <code>opacity</code> <code>float</code> <p>Layer opacity.</p> <code>0.8</code> <code>**kwargs</code> <p>Additional SolidPolygonLayer props.</p> <code>{}</code> Source code in <code>anymap_ts/deckgl.py</code> <pre><code>def add_solid_polygon_layer(\n    self,\n    data: Any,\n    name: Optional[str] = None,\n    get_polygon: Union[str, Callable] = \"polygon\",\n    get_fill_color: Union[List[int], str, Callable] = None,\n    get_line_color: Union[List[int], str, Callable] = None,\n    get_elevation: Union[float, str, Callable] = 0,\n    filled: bool = True,\n    extruded: bool = False,\n    wireframe: bool = False,\n    elevation_scale: float = 1,\n    pickable: bool = True,\n    opacity: float = 0.8,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a solid polygon layer for filled polygon visualization.\n\n    Args:\n        data: Array of data objects with polygon coordinates.\n        name: Layer ID.\n        get_polygon: Accessor for polygon coordinates.\n        get_fill_color: Accessor for fill color [r, g, b, a].\n        get_line_color: Accessor for stroke color [r, g, b, a].\n        get_elevation: Accessor for 3D extrusion height.\n        filled: Whether to fill polygons.\n        extruded: Whether to render as 3D polygons.\n        wireframe: Whether to render wireframe.\n        elevation_scale: Elevation multiplier.\n        pickable: Whether layer responds to hover/click.\n        opacity: Layer opacity.\n        **kwargs: Additional SolidPolygonLayer props.\n    \"\"\"\n    layer_id = name or f\"solidpolygon-{len(self._deck_layers)}\"\n    processed_data = self._process_deck_data(data)\n\n    self.call_js_method(\n        \"addSolidPolygonLayer\",\n        id=layer_id,\n        data=processed_data,\n        getPolygon=get_polygon,\n        getFillColor=get_fill_color or [51, 136, 255, 128],\n        getLineColor=get_line_color or [0, 0, 0, 255],\n        getElevation=get_elevation,\n        filled=filled,\n        extruded=extruded,\n        wireframe=wireframe,\n        elevationScale=elevation_scale,\n        pickable=pickable,\n        opacity=opacity,\n        **kwargs,\n    )\n\n    self._deck_layers = {\n        **self._deck_layers,\n        layer_id: {\"type\": \"SolidPolygonLayer\", \"id\": layer_id},\n    }\n</code></pre>"},{"location":"deckgl/#anymap_ts.deckgl.DeckGLMap.add_terrain_layer","title":"<code>add_terrain_layer(self, elevation_data, name=None, texture=None, mesh_max_error=4.0, bounds=None, elevation_decoder=None, pickable=False, visible=True, opacity=1.0, wireframe=False, **kwargs)</code>","text":"<p>Add a terrain layer for 3D terrain visualization.</p> <p>Parameters:</p> Name Type Description Default <code>elevation_data</code> <code>Union[str, List[str]]</code> <p>URL to elevation tiles (e.g., Mapbox terrain).</p> required <code>name</code> <code>Optional[str]</code> <p>Layer ID.</p> <code>None</code> <code>texture</code> <code>Optional[str]</code> <p>URL to texture tiles for terrain surface.</p> <code>None</code> <code>mesh_max_error</code> <code>float</code> <p>Maximum mesh error in meters.</p> <code>4.0</code> <code>bounds</code> <code>Optional[List[float]]</code> <p>Bounding box [west, south, east, north].</p> <code>None</code> <code>elevation_decoder</code> <code>Optional[Dict]</code> <p>Decoder for elevation data format.</p> <code>None</code> <code>pickable</code> <code>bool</code> <p>Whether layer responds to hover/click.</p> <code>False</code> <code>visible</code> <code>bool</code> <p>Whether layer is visible.</p> <code>True</code> <code>opacity</code> <code>float</code> <p>Layer opacity (0-1).</p> <code>1.0</code> <code>wireframe</code> <code>bool</code> <p>Whether to render as wireframe.</p> <code>False</code> <code>**kwargs</code> <p>Additional TerrainLayer props.</p> <code>{}</code> Source code in <code>anymap_ts/deckgl.py</code> <pre><code>def add_terrain_layer(\n    self,\n    elevation_data: Union[str, List[str]],\n    name: Optional[str] = None,\n    texture: Optional[str] = None,\n    mesh_max_error: float = 4.0,\n    bounds: Optional[List[float]] = None,\n    elevation_decoder: Optional[Dict] = None,\n    pickable: bool = False,\n    visible: bool = True,\n    opacity: float = 1.0,\n    wireframe: bool = False,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a terrain layer for 3D terrain visualization.\n\n    Args:\n        elevation_data: URL to elevation tiles (e.g., Mapbox terrain).\n        name: Layer ID.\n        texture: URL to texture tiles for terrain surface.\n        mesh_max_error: Maximum mesh error in meters.\n        bounds: Bounding box [west, south, east, north].\n        elevation_decoder: Decoder for elevation data format.\n        pickable: Whether layer responds to hover/click.\n        visible: Whether layer is visible.\n        opacity: Layer opacity (0-1).\n        wireframe: Whether to render as wireframe.\n        **kwargs: Additional TerrainLayer props.\n    \"\"\"\n    layer_id = name or f\"terrain-{len(self._deck_layers)}\"\n\n    default_decoder = {\n        \"rScaler\": 256,\n        \"gScaler\": 1,\n        \"bScaler\": 1 / 256,\n        \"offset\": -32768,\n    }\n\n    self.call_js_method(\n        \"addTerrainLayer\",\n        id=layer_id,\n        elevationData=elevation_data,\n        texture=texture,\n        meshMaxError=mesh_max_error,\n        bounds=bounds,\n        elevationDecoder=elevation_decoder or default_decoder,\n        pickable=pickable,\n        visible=visible,\n        opacity=opacity,\n        wireframe=wireframe,\n        **kwargs,\n    )\n\n    self._deck_layers = {\n        **self._deck_layers,\n        layer_id: {\"type\": \"TerrainLayer\", \"id\": layer_id},\n    }\n</code></pre>"},{"location":"deckgl/#anymap_ts.deckgl.DeckGLMap.add_text_layer","title":"<code>add_text_layer(self, data, name=None, get_position='coordinates', get_text='text', get_size=12, get_color=None, get_angle=0, text_anchor='middle', alignment_baseline='center', pickable=True, opacity=1, **kwargs)</code>","text":"<p>Add a text layer for label visualization.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>Array of data objects with position and text.</p> required <code>name</code> <code>Optional[str]</code> <p>Layer ID.</p> <code>None</code> <code>get_position</code> <code>Union[str, Callable]</code> <p>Accessor for text position [lng, lat].</p> <code>'coordinates'</code> <code>get_text</code> <code>Union[str, Callable]</code> <p>Accessor for text content.</p> <code>'text'</code> <code>get_size</code> <code>Union[float, str, Callable]</code> <p>Accessor for text size.</p> <code>12</code> <code>get_color</code> <code>Union[List[int], str, Callable]</code> <p>Accessor for text color [r, g, b, a].</p> <code>None</code> <code>get_angle</code> <code>Union[float, str, Callable]</code> <p>Accessor for text rotation in degrees.</p> <code>0</code> <code>text_anchor</code> <code>str</code> <p>Horizontal alignment ('start', 'middle', 'end').</p> <code>'middle'</code> <code>alignment_baseline</code> <code>str</code> <p>Vertical alignment ('top', 'center', 'bottom').</p> <code>'center'</code> <code>pickable</code> <code>bool</code> <p>Whether layer responds to hover/click.</p> <code>True</code> <code>opacity</code> <code>float</code> <p>Layer opacity.</p> <code>1</code> <code>**kwargs</code> <p>Additional layer props.</p> <code>{}</code> Source code in <code>anymap_ts/deckgl.py</code> <pre><code>def add_text_layer(\n    self,\n    data: Any,\n    name: Optional[str] = None,\n    get_position: Union[str, Callable] = \"coordinates\",\n    get_text: Union[str, Callable] = \"text\",\n    get_size: Union[float, str, Callable] = 12,\n    get_color: Union[List[int], str, Callable] = None,\n    get_angle: Union[float, str, Callable] = 0,\n    text_anchor: str = \"middle\",\n    alignment_baseline: str = \"center\",\n    pickable: bool = True,\n    opacity: float = 1,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a text layer for label visualization.\n\n    Args:\n        data: Array of data objects with position and text.\n        name: Layer ID.\n        get_position: Accessor for text position [lng, lat].\n        get_text: Accessor for text content.\n        get_size: Accessor for text size.\n        get_color: Accessor for text color [r, g, b, a].\n        get_angle: Accessor for text rotation in degrees.\n        text_anchor: Horizontal alignment ('start', 'middle', 'end').\n        alignment_baseline: Vertical alignment ('top', 'center', 'bottom').\n        pickable: Whether layer responds to hover/click.\n        opacity: Layer opacity.\n        **kwargs: Additional layer props.\n    \"\"\"\n    layer_id = name or f\"text-{len(self._deck_layers)}\"\n    processed_data = self._process_deck_data(data)\n\n    self.call_js_method(\n        \"addTextLayer\",\n        id=layer_id,\n        data=processed_data,\n        getPosition=get_position,\n        getText=get_text,\n        getSize=get_size,\n        getColor=get_color or [0, 0, 0, 255],\n        getAngle=get_angle,\n        getTextAnchor=text_anchor,\n        getAlignmentBaseline=alignment_baseline,\n        pickable=pickable,\n        opacity=opacity,\n        **kwargs,\n    )\n\n    self._deck_layers = {\n        **self._deck_layers,\n        layer_id: {\"type\": \"TextLayer\", \"id\": layer_id},\n    }\n</code></pre>"},{"location":"deckgl/#anymap_ts.deckgl.DeckGLMap.add_tile3d_layer","title":"<code>add_tile3d_layer(self, data, name=None, point_size=1, pickable=True, visible=True, opacity=1.0, load_options=None, **kwargs)</code>","text":"<p>Add a 3D Tiles layer for 3D building/terrain visualization.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>str</code> <p>URL to tileset.json.</p> required <code>name</code> <code>Optional[str]</code> <p>Layer ID.</p> <code>None</code> <code>point_size</code> <code>float</code> <p>Point size for point cloud tiles.</p> <code>1</code> <code>pickable</code> <code>bool</code> <p>Whether layer responds to hover/click.</p> <code>True</code> <code>visible</code> <code>bool</code> <p>Whether layer is visible.</p> <code>True</code> <code>opacity</code> <code>float</code> <p>Layer opacity (0-1).</p> <code>1.0</code> <code>load_options</code> <code>Optional[Dict]</code> <p>Loader options for tile loading.</p> <code>None</code> <code>**kwargs</code> <p>Additional Tile3DLayer props.</p> <code>{}</code> Source code in <code>anymap_ts/deckgl.py</code> <pre><code>def add_tile3d_layer(\n    self,\n    data: str,\n    name: Optional[str] = None,\n    point_size: float = 1,\n    pickable: bool = True,\n    visible: bool = True,\n    opacity: float = 1.0,\n    load_options: Optional[Dict] = None,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a 3D Tiles layer for 3D building/terrain visualization.\n\n    Args:\n        data: URL to tileset.json.\n        name: Layer ID.\n        point_size: Point size for point cloud tiles.\n        pickable: Whether layer responds to hover/click.\n        visible: Whether layer is visible.\n        opacity: Layer opacity (0-1).\n        load_options: Loader options for tile loading.\n        **kwargs: Additional Tile3DLayer props.\n    \"\"\"\n    layer_id = name or f\"tile3d-{len(self._deck_layers)}\"\n\n    self.call_js_method(\n        \"addTile3DLayer\",\n        id=layer_id,\n        data=data,\n        pointSize=point_size,\n        pickable=pickable,\n        visible=visible,\n        opacity=opacity,\n        loadOptions=load_options or {},\n        **kwargs,\n    )\n\n    self._deck_layers = {\n        **self._deck_layers,\n        layer_id: {\"type\": \"Tile3DLayer\", \"id\": layer_id},\n    }\n</code></pre>"},{"location":"deckgl/#anymap_ts.deckgl.DeckGLMap.add_tile_layer","title":"<code>add_tile_layer(self, data, name=None, min_zoom=0, max_zoom=19, tile_size=256, pickable=False, visible=True, opacity=1.0, **kwargs)</code>","text":"<p>Add a tile layer for raster tile visualization.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Union[str, List[str]]</code> <p>Tile URL template with {z}/{x}/{y} placeholders.</p> required <code>name</code> <code>Optional[str]</code> <p>Layer ID.</p> <code>None</code> <code>min_zoom</code> <code>int</code> <p>Minimum zoom level.</p> <code>0</code> <code>max_zoom</code> <code>int</code> <p>Maximum zoom level.</p> <code>19</code> <code>tile_size</code> <code>int</code> <p>Tile size in pixels.</p> <code>256</code> <code>pickable</code> <code>bool</code> <p>Whether layer responds to hover/click.</p> <code>False</code> <code>visible</code> <code>bool</code> <p>Whether layer is visible.</p> <code>True</code> <code>opacity</code> <code>float</code> <p>Layer opacity (0-1).</p> <code>1.0</code> <code>**kwargs</code> <p>Additional TileLayer props.</p> <code>{}</code> Source code in <code>anymap_ts/deckgl.py</code> <pre><code>def add_tile_layer(\n    self,\n    data: Union[str, List[str]],\n    name: Optional[str] = None,\n    min_zoom: int = 0,\n    max_zoom: int = 19,\n    tile_size: int = 256,\n    pickable: bool = False,\n    visible: bool = True,\n    opacity: float = 1.0,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a tile layer for raster tile visualization.\n\n    Args:\n        data: Tile URL template with {z}/{x}/{y} placeholders.\n        name: Layer ID.\n        min_zoom: Minimum zoom level.\n        max_zoom: Maximum zoom level.\n        tile_size: Tile size in pixels.\n        pickable: Whether layer responds to hover/click.\n        visible: Whether layer is visible.\n        opacity: Layer opacity (0-1).\n        **kwargs: Additional TileLayer props.\n    \"\"\"\n    layer_id = name or f\"tile-{len(self._deck_layers)}\"\n\n    self.call_js_method(\n        \"addTileLayer\",\n        id=layer_id,\n        data=data,\n        minZoom=min_zoom,\n        maxZoom=max_zoom,\n        tileSize=tile_size,\n        pickable=pickable,\n        visible=visible,\n        opacity=opacity,\n        **kwargs,\n    )\n\n    self._deck_layers = {\n        **self._deck_layers,\n        layer_id: {\"type\": \"TileLayer\", \"id\": layer_id},\n    }\n</code></pre>"},{"location":"deckgl/#anymap_ts.deckgl.DeckGLMap.add_trips_layer","title":"<code>add_trips_layer(self, data, name=None, get_path='waypoints', get_timestamps='timestamps', get_color=None, width_min_pixels=2, trail_length=180, current_time=0, pickable=True, opacity=0.8, **kwargs)</code>","text":"<p>Add a trips layer for animated path visualization.</p> <p>The TripsLayer renders animated paths showing movement over time, ideal for visualizing vehicle routes, migration patterns, or any time-based trajectory data.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>Array of trip objects with waypoints and timestamps.</p> required <code>name</code> <code>Optional[str]</code> <p>Layer ID. If None, auto-generated.</p> <code>None</code> <code>get_path</code> <code>Union[str, Callable]</code> <p>Accessor for waypoint coordinates [[lng, lat], ...].</p> <code>'waypoints'</code> <code>get_timestamps</code> <code>Union[str, Callable]</code> <p>Accessor for timestamps at each waypoint.</p> <code>'timestamps'</code> <code>get_color</code> <code>Union[List[int], str, Callable]</code> <p>Accessor for trip color [r, g, b] or [r, g, b, a].</p> <code>None</code> <code>width_min_pixels</code> <code>float</code> <p>Minimum trail width in pixels.</p> <code>2</code> <code>trail_length</code> <code>float</code> <p>Trail length in timestamp units.</p> <code>180</code> <code>current_time</code> <code>float</code> <p>Current animation time.</p> <code>0</code> <code>pickable</code> <code>bool</code> <p>Whether layer responds to hover/click.</p> <code>True</code> <code>opacity</code> <code>float</code> <p>Layer opacity (0-1).</p> <code>0.8</code> <code>**kwargs</code> <p>Additional TripsLayer props.</p> <code>{}</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; m = DeckGLMap()\n&gt;&gt;&gt; trips = [\n...     {\n...         \"waypoints\": [[-122.4, 37.8], [-122.5, 37.7], [-122.6, 37.8]],\n...         \"timestamps\": [0, 50, 100]\n...     }\n... ]\n&gt;&gt;&gt; m.add_trips_layer(\n...     data=trips,\n...     trail_length=180,\n...     current_time=50,\n... )\n</code></pre> Source code in <code>anymap_ts/deckgl.py</code> <pre><code>def add_trips_layer(\n    self,\n    data: Any,\n    name: Optional[str] = None,\n    get_path: Union[str, Callable] = \"waypoints\",\n    get_timestamps: Union[str, Callable] = \"timestamps\",\n    get_color: Union[List[int], str, Callable] = None,\n    width_min_pixels: float = 2,\n    trail_length: float = 180,\n    current_time: float = 0,\n    pickable: bool = True,\n    opacity: float = 0.8,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a trips layer for animated path visualization.\n\n    The TripsLayer renders animated paths showing movement over time,\n    ideal for visualizing vehicle routes, migration patterns, or any\n    time-based trajectory data.\n\n    Args:\n        data: Array of trip objects with waypoints and timestamps.\n        name: Layer ID. If None, auto-generated.\n        get_path: Accessor for waypoint coordinates [[lng, lat], ...].\n        get_timestamps: Accessor for timestamps at each waypoint.\n        get_color: Accessor for trip color [r, g, b] or [r, g, b, a].\n        width_min_pixels: Minimum trail width in pixels.\n        trail_length: Trail length in timestamp units.\n        current_time: Current animation time.\n        pickable: Whether layer responds to hover/click.\n        opacity: Layer opacity (0-1).\n        **kwargs: Additional TripsLayer props.\n\n    Example:\n        &gt;&gt;&gt; m = DeckGLMap()\n        &gt;&gt;&gt; trips = [\n        ...     {\n        ...         \"waypoints\": [[-122.4, 37.8], [-122.5, 37.7], [-122.6, 37.8]],\n        ...         \"timestamps\": [0, 50, 100]\n        ...     }\n        ... ]\n        &gt;&gt;&gt; m.add_trips_layer(\n        ...     data=trips,\n        ...     trail_length=180,\n        ...     current_time=50,\n        ... )\n    \"\"\"\n    layer_id = name or f\"trips-{len(self._deck_layers)}\"\n    processed_data = self._process_deck_data(data)\n\n    self.call_js_method(\n        \"addTripsLayer\",\n        id=layer_id,\n        data=processed_data,\n        getPath=get_path,\n        getTimestamps=get_timestamps,\n        getColor=get_color or [253, 128, 93],\n        widthMinPixels=width_min_pixels,\n        trailLength=trail_length,\n        currentTime=current_time,\n        pickable=pickable,\n        opacity=opacity,\n        **kwargs,\n    )\n\n    self._deck_layers = {\n        **self._deck_layers,\n        layer_id: {\"type\": \"TripsLayer\", \"id\": layer_id},\n    }\n</code></pre>"},{"location":"deckgl/#anymap_ts.deckgl.DeckGLMap.add_wms_layer","title":"<code>add_wms_layer(self, data, name=None, service_type='wms', layers=None, srs=None, pickable=False, visible=True, opacity=1.0, **kwargs)</code>","text":"<p>Add a WMS layer for OGC Web Map Service visualization.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>str</code> <p>WMS base URL.</p> required <code>name</code> <code>Optional[str]</code> <p>Layer ID.</p> <code>None</code> <code>service_type</code> <code>str</code> <p>Service type ('wms' or 'template').</p> <code>'wms'</code> <code>layers</code> <code>Optional[List[str]]</code> <p>WMS layer names to request.</p> <code>None</code> <code>srs</code> <code>Optional[str]</code> <p>Spatial reference system (e.g., 'EPSG:4326').</p> <code>None</code> <code>pickable</code> <code>bool</code> <p>Whether layer responds to hover/click.</p> <code>False</code> <code>visible</code> <code>bool</code> <p>Whether layer is visible.</p> <code>True</code> <code>opacity</code> <code>float</code> <p>Layer opacity (0-1).</p> <code>1.0</code> <code>**kwargs</code> <p>Additional WMSLayer props.</p> <code>{}</code> Source code in <code>anymap_ts/deckgl.py</code> <pre><code>def add_wms_layer(\n    self,\n    data: str,\n    name: Optional[str] = None,\n    service_type: str = \"wms\",\n    layers: Optional[List[str]] = None,\n    srs: Optional[str] = None,\n    pickable: bool = False,\n    visible: bool = True,\n    opacity: float = 1.0,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a WMS layer for OGC Web Map Service visualization.\n\n    Args:\n        data: WMS base URL.\n        name: Layer ID.\n        service_type: Service type ('wms' or 'template').\n        layers: WMS layer names to request.\n        srs: Spatial reference system (e.g., 'EPSG:4326').\n        pickable: Whether layer responds to hover/click.\n        visible: Whether layer is visible.\n        opacity: Layer opacity (0-1).\n        **kwargs: Additional WMSLayer props.\n    \"\"\"\n    layer_id = name or f\"wms-{len(self._deck_layers)}\"\n\n    self.call_js_method(\n        \"addWMSLayer\",\n        id=layer_id,\n        data=data,\n        serviceType=service_type,\n        layers=layers,\n        srs=srs,\n        pickable=pickable,\n        visible=visible,\n        opacity=opacity,\n        **kwargs,\n    )\n\n    self._deck_layers = {\n        **self._deck_layers,\n        layer_id: {\"type\": \"WMSLayer\", \"id\": layer_id},\n    }\n</code></pre>"},{"location":"deckgl/#anymap_ts.deckgl.DeckGLMap.remove_cog_layer","title":"<code>remove_cog_layer(self, layer_id)</code>","text":"<p>Remove a COG layer.</p> <p>Parameters:</p> Name Type Description Default <code>layer_id</code> <code>str</code> <p>Layer identifier to remove.</p> required Source code in <code>anymap_ts/deckgl.py</code> <pre><code>def remove_cog_layer(self, layer_id: str) -&gt; None:\n    \"\"\"Remove a COG layer.\n\n    Args:\n        layer_id: Layer identifier to remove.\n    \"\"\"\n    self.remove_deck_layer(layer_id)\n</code></pre>"},{"location":"deckgl/#anymap_ts.deckgl.DeckGLMap.remove_deck_layer","title":"<code>remove_deck_layer(self, layer_id)</code>","text":"<p>Remove a deck.gl layer.</p> <p>Parameters:</p> Name Type Description Default <code>layer_id</code> <code>str</code> <p>Layer identifier to remove.</p> required Source code in <code>anymap_ts/deckgl.py</code> <pre><code>def remove_deck_layer(self, layer_id: str) -&gt; None:\n    \"\"\"Remove a deck.gl layer.\n\n    Args:\n        layer_id: Layer identifier to remove.\n    \"\"\"\n    if layer_id in self._deck_layers:\n        layers = dict(self._deck_layers)\n        del layers[layer_id]\n        self._deck_layers = layers\n    self.call_js_method(\"removeDeckLayer\", layer_id)\n</code></pre>"},{"location":"deckgl/#anymap_ts.deckgl.DeckGLMap.set_deck_layer_visibility","title":"<code>set_deck_layer_visibility(self, layer_id, visible)</code>","text":"<p>Set deck.gl layer visibility.</p> <p>Parameters:</p> Name Type Description Default <code>layer_id</code> <code>str</code> <p>Layer identifier.</p> required <code>visible</code> <code>bool</code> <p>Whether layer should be visible.</p> required Source code in <code>anymap_ts/deckgl.py</code> <pre><code>def set_deck_layer_visibility(self, layer_id: str, visible: bool) -&gt; None:\n    \"\"\"Set deck.gl layer visibility.\n\n    Args:\n        layer_id: Layer identifier.\n        visible: Whether layer should be visible.\n    \"\"\"\n    self.call_js_method(\"setDeckLayerVisibility\", layer_id, visible)\n</code></pre>"},{"location":"installation/","title":"Installation","text":""},{"location":"installation/#stable-release","title":"Stable release","text":"<p>To install anymap-ts from PyPI, run this command in your terminal:</p> <pre><code>pip install anymap-ts\n</code></pre> <p>To install anymap-ts from conda-forge, run this command in your terminal:</p> <pre><code>conda install -c conda-forge anymap-ts\n</code></pre>"},{"location":"installation/#from-sources","title":"From sources","text":"<p>To install anymap-ts from sources, run this command in your terminal:</p> <pre><code>pip install git+https://github.com/opengeos/anymap-ts\n</code></pre>"},{"location":"installation/#optional-dependencies","title":"Optional dependencies","text":"<pre><code># For vector data support (GeoDataFrame)\npip install anymap-ts[vector]\n\n# For local raster support (localtileserver)\npip install anymap-ts[raster]\n\n# All optional dependencies\npip install anymap-ts[all]\n</code></pre>"},{"location":"installation/#development-installation","title":"Development installation","text":"<pre><code>git clone https://github.com/opengeos/anymap-ts.git\ncd anymap-ts\npip install -e \".[dev]\"\n</code></pre>"},{"location":"installation/#environment-variables","title":"Environment Variables","text":"Variable Library Description <code>MAPBOX_TOKEN</code> Mapbox, KeplerGL Mapbox access token <code>CESIUM_TOKEN</code> Cesium Cesium Ion access token"},{"location":"keplergl/","title":"keplergl module","text":"<p>KeplerGL map widget implementation.</p> <p>KeplerGL is loaded via CDN since it's React-based and requires complex setup. This implementation provides a Python wrapper with data management capabilities.</p>"},{"location":"keplergl/#anymap_ts.keplergl.KeplerGLMap","title":"<code> KeplerGLMap            (MapWidget)         </code>","text":"<p>Interactive map widget using KeplerGL.</p> <p>KeplerGL is a powerful data visualization tool built on top of deck.gl. This class provides a Python interface for adding data and configuring the KeplerGL visualization.</p> <p>Note: KeplerGL is loaded from CDN due to its React-based architecture.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from anymap_ts import KeplerGLMap\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; m = KeplerGLMap()\n&gt;&gt;&gt; df = pd.DataFrame({\n...     'lat': [37.7749, 37.8044],\n...     'lng': [-122.4194, -122.2712],\n...     'value': [100, 200]\n... })\n&gt;&gt;&gt; m.add_data(df, name='points')\n&gt;&gt;&gt; m\n</code></pre> Source code in <code>anymap_ts/keplergl.py</code> <pre><code>class KeplerGLMap(MapWidget):\n    \"\"\"Interactive map widget using KeplerGL.\n\n    KeplerGL is a powerful data visualization tool built on top of deck.gl.\n    This class provides a Python interface for adding data and configuring\n    the KeplerGL visualization.\n\n    Note: KeplerGL is loaded from CDN due to its React-based architecture.\n\n    Example:\n        &gt;&gt;&gt; from anymap_ts import KeplerGLMap\n        &gt;&gt;&gt; import pandas as pd\n        &gt;&gt;&gt; m = KeplerGLMap()\n        &gt;&gt;&gt; df = pd.DataFrame({\n        ...     'lat': [37.7749, 37.8044],\n        ...     'lng': [-122.4194, -122.2712],\n        ...     'value': [100, 200]\n        ... })\n        &gt;&gt;&gt; m.add_data(df, name='points')\n        &gt;&gt;&gt; m\n    \"\"\"\n\n    # ESM module for frontend\n    _esm = STATIC_DIR / \"keplergl.js\"\n\n    # KeplerGL-specific traits\n    config = traitlets.Dict({}).tag(sync=True)\n    datasets = traitlets.Dict({}).tag(sync=True)\n    read_only = traitlets.Bool(False).tag(sync=True)\n    show_data_table = traitlets.Bool(True).tag(sync=True)\n\n    # Mapbox token for basemaps\n    mapbox_token = traitlets.Unicode(\"\").tag(sync=True)\n\n    def __init__(\n        self,\n        center: Tuple[float, float] = (-122.4, 37.8),\n        zoom: float = 10.0,\n        width: str = \"100%\",\n        height: str = \"600px\",\n        config: Optional[Dict] = None,\n        read_only: bool = False,\n        show_data_table: bool = True,\n        mapbox_token: Optional[str] = None,\n        **kwargs,\n    ):\n        \"\"\"Initialize a KeplerGL map.\n\n        Args:\n            center: Map center as (longitude, latitude).\n            zoom: Initial zoom level.\n            width: Widget width as CSS string.\n            height: Widget height as CSS string.\n            config: KeplerGL configuration dict.\n            read_only: Whether the UI is read-only.\n            show_data_table: Whether to show the data table panel.\n            mapbox_token: Mapbox access token for basemaps.\n            **kwargs: Additional widget arguments.\n        \"\"\"\n        import os\n\n        if mapbox_token is None:\n            mapbox_token = os.environ.get(\"MAPBOX_TOKEN\", \"\")\n\n        super().__init__(\n            center=list(center),\n            zoom=zoom,\n            width=width,\n            height=height,\n            config=config or {},\n            read_only=read_only,\n            show_data_table=show_data_table,\n            mapbox_token=mapbox_token,\n            **kwargs,\n        )\n        self.datasets = {}\n\n    # -------------------------------------------------------------------------\n    # Data Methods\n    # -------------------------------------------------------------------------\n\n    def add_data(\n        self,\n        data: Any,\n        name: Optional[str] = None,\n    ) -&gt; None:\n        \"\"\"Add data to the map.\n\n        Args:\n            data: Data to add (DataFrame, GeoDataFrame, dict, or file path).\n            name: Dataset name/label.\n        \"\"\"\n        dataset_id = name or f\"data_{uuid.uuid4().hex[:8]}\"\n        processed_data = self._process_data(data)\n\n        self.datasets = {\n            **self.datasets,\n            dataset_id: {\n                \"info\": {\n                    \"id\": dataset_id,\n                    \"label\": dataset_id,\n                },\n                \"data\": processed_data,\n            },\n        }\n\n        self.call_js_method(\n            \"addData\",\n            dataId=dataset_id,\n            data=processed_data,\n        )\n\n    def _process_data(self, data: Any) -&gt; Dict:\n        \"\"\"Process data into KeplerGL format.\n\n        Args:\n            data: Input data.\n\n        Returns:\n            Processed data dict with fields and rows.\n        \"\"\"\n        # Handle DataFrame\n        if hasattr(data, \"to_dict\"):\n            # Check if it's a GeoDataFrame\n            if hasattr(data, \"geometry\"):\n                # Convert to GeoJSON for geometry columns\n                geojson = json.loads(data.to_json())\n                return {\n                    \"type\": \"geojson\",\n                    \"data\": geojson,\n                }\n            else:\n                # Regular DataFrame\n                fields = []\n                for col in data.columns:\n                    dtype = str(data[col].dtype)\n                    if \"int\" in dtype:\n                        field_type = \"integer\"\n                    elif \"float\" in dtype:\n                        field_type = \"real\"\n                    elif \"datetime\" in dtype:\n                        field_type = \"timestamp\"\n                    elif \"bool\" in dtype:\n                        field_type = \"boolean\"\n                    else:\n                        field_type = \"string\"\n\n                    fields.append({\"name\": col, \"type\": field_type})\n\n                # Convert to list of lists\n                rows = data.values.tolist()\n\n                return {\n                    \"fields\": fields,\n                    \"rows\": rows,\n                }\n\n        # Handle dict (assume it's already GeoJSON or processed)\n        if isinstance(data, dict):\n            if \"type\" in data and data[\"type\"] in [\n                \"FeatureCollection\",\n                \"Feature\",\n                \"Point\",\n                \"LineString\",\n                \"Polygon\",\n                \"MultiPoint\",\n                \"MultiLineString\",\n                \"MultiPolygon\",\n            ]:\n                return {\"type\": \"geojson\", \"data\": data}\n            return data\n\n        # Handle file path\n        if isinstance(data, (str, Path)):\n            path = Path(data)\n            if path.exists():\n                if path.suffix.lower() in [\".geojson\", \".json\"]:\n                    with open(path) as f:\n                        geojson = json.load(f)\n                    return {\"type\": \"geojson\", \"data\": geojson}\n                elif path.suffix.lower() == \".csv\":\n                    try:\n                        import pandas as pd\n\n                        df = pd.read_csv(path)\n                        return self._process_data(df)\n                    except ImportError:\n                        raise ImportError(\n                            \"pandas is required to load CSV files. \"\n                            \"Install with: pip install pandas\"\n                        )\n\n        return data\n\n    def remove_data(self, name: str) -&gt; None:\n        \"\"\"Remove a dataset.\n\n        Args:\n            name: Dataset name to remove.\n        \"\"\"\n        if name in self.datasets:\n            datasets = dict(self.datasets)\n            del datasets[name]\n            self.datasets = datasets\n        self.call_js_method(\"removeData\", dataId=name)\n\n    # -------------------------------------------------------------------------\n    # Configuration Methods\n    # -------------------------------------------------------------------------\n\n    def set_config(self, config: Dict) -&gt; None:\n        \"\"\"Set the KeplerGL configuration.\n\n        Args:\n            config: Configuration dict.\n        \"\"\"\n        self.config = config\n        self.call_js_method(\"setConfig\", config=config)\n\n    def get_config(self) -&gt; Dict:\n        \"\"\"Get the current KeplerGL configuration.\n\n        Returns:\n            Configuration dict.\n        \"\"\"\n        return self.config\n\n    def save_config(self, filepath: Union[str, Path]) -&gt; None:\n        \"\"\"Save configuration to a JSON file.\n\n        Args:\n            filepath: Path to save the configuration.\n        \"\"\"\n        with open(filepath, \"w\") as f:\n            json.dump(self.config, f, indent=2)\n\n    def load_config(self, filepath: Union[str, Path]) -&gt; None:\n        \"\"\"Load configuration from a JSON file.\n\n        Args:\n            filepath: Path to the configuration file.\n        \"\"\"\n        with open(filepath) as f:\n            config = json.load(f)\n        self.set_config(config)\n\n    # -------------------------------------------------------------------------\n    # Filter Methods\n    # -------------------------------------------------------------------------\n\n    def add_filter(\n        self,\n        data_id: str,\n        field: str,\n        filter_type: str = \"range\",\n        value: Optional[Any] = None,\n    ) -&gt; None:\n        \"\"\"Add a filter to the visualization.\n\n        Args:\n            data_id: Dataset ID to filter.\n            field: Field name to filter on.\n            filter_type: Type of filter ('range', 'select', 'time').\n            value: Filter value(s).\n        \"\"\"\n        filter_config = {\n            \"dataId\": [data_id],\n            \"name\": [field],\n            \"type\": filter_type,\n        }\n        if value is not None:\n            filter_config[\"value\"] = value\n\n        self.call_js_method(\"addFilter\", filter=filter_config)\n\n    # -------------------------------------------------------------------------\n    # Layer Methods\n    # -------------------------------------------------------------------------\n\n    def add_layer(\n        self,\n        layer_type: str,\n        data_id: str,\n        columns: Dict[str, str],\n        label: Optional[str] = None,\n        color: Optional[List[int]] = None,\n        vis_config: Optional[Dict] = None,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a layer to the visualization.\n\n        Args:\n            layer_type: Layer type ('point', 'arc', 'line', 'hexagon', 'heatmap', etc.).\n            data_id: Dataset ID for the layer.\n            columns: Column mapping (e.g., {'lat': 'latitude', 'lng': 'longitude'}).\n            label: Layer label.\n            color: Layer color as [r, g, b].\n            vis_config: Visual configuration.\n            **kwargs: Additional layer options.\n        \"\"\"\n        layer_config = {\n            \"type\": layer_type,\n            \"config\": {\n                \"dataId\": data_id,\n                \"label\": label or f\"{layer_type}_layer\",\n                \"columns\": columns,\n                \"isVisible\": True,\n            },\n        }\n        if color:\n            layer_config[\"config\"][\"color\"] = color\n        if vis_config:\n            layer_config[\"config\"][\"visConfig\"] = vis_config\n\n        layer_config[\"config\"].update(kwargs)\n\n        self.call_js_method(\"addLayer\", layer=layer_config)\n\n    # -------------------------------------------------------------------------\n    # View Methods\n    # -------------------------------------------------------------------------\n\n    def fly_to(\n        self,\n        lng: float,\n        lat: float,\n        zoom: Optional[float] = None,\n    ) -&gt; None:\n        \"\"\"Fly to a location.\n\n        Args:\n            lng: Target longitude.\n            lat: Target latitude.\n            zoom: Target zoom level.\n        \"\"\"\n        self.center = [lng, lat]\n        if zoom is not None:\n            self.zoom = zoom\n        self.call_js_method(\"flyTo\", lng=lng, lat=lat, zoom=zoom or self.zoom)\n\n    # -------------------------------------------------------------------------\n    # HTML Export\n    # -------------------------------------------------------------------------\n\n    def _generate_html_template(self) -&gt; str:\n        \"\"\"Generate standalone HTML for KeplerGL.\"\"\"\n        template_path = Path(__file__).parent / \"templates\" / \"keplergl.html\"\n\n        if template_path.exists():\n            template = template_path.read_text(encoding=\"utf-8\")\n        else:\n            template = self._get_default_template()\n\n        state = {\n            \"center\": self.center,\n            \"zoom\": self.zoom,\n            \"config\": self.config,\n            \"datasets\": self.datasets,\n            \"read_only\": self.read_only,\n            \"mapbox_token\": self.mapbox_token,\n            \"width\": self.width,\n            \"height\": self.height,\n            \"js_calls\": self._js_calls,\n        }\n\n        template = template.replace(\"{{state}}\", json.dumps(state, indent=2))\n        return template\n\n    def _get_default_template(self) -&gt; str:\n        \"\"\"Get default HTML template.\"\"\"\n        return \"\"\"&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n    &lt;meta charset=\"utf-8\"&gt;\n    &lt;title&gt;KeplerGL Map&lt;/title&gt;\n    &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"&gt;\n    &lt;style&gt;\n        * { margin: 0; padding: 0; box-sizing: border-box; }\n        html, body { height: 100%; }\n        #app { position: absolute; top: 0; bottom: 0; width: 100%; }\n    &lt;/style&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;div id=\"app\"&gt;&lt;/div&gt;\n    &lt;script&gt;\n        const state = {{state}};\n        // KeplerGL requires React/Redux setup - simplified placeholder\n        document.getElementById('app').innerHTML = '&lt;p&gt;KeplerGL visualization requires full React setup. Use Jupyter widget for interactive visualization.&lt;/p&gt;';\n    &lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\"\"\"\n\n    def _repr_html_(self) -&gt; str:\n        \"\"\"Return HTML representation for Jupyter (uses iframe with CDN KeplerGL).\"\"\"\n        state = {\n            \"center\": self.center,\n            \"zoom\": self.zoom,\n            \"config\": self.config,\n            \"datasets\": self.datasets,\n            \"mapbox_token\": self.mapbox_token,\n        }\n\n        html = f\"\"\"\n        &lt;iframe\n            srcdoc='\n            &lt;!DOCTYPE html&gt;\n            &lt;html&gt;\n            &lt;head&gt;\n                &lt;meta charset=\"utf-8\"&gt;\n                &lt;script src=\"https://unpkg.com/react@16.8.4/umd/react.production.min.js\"&gt;&lt;/script&gt;\n                &lt;script src=\"https://unpkg.com/react-dom@16.8.4/umd/react-dom.production.min.js\"&gt;&lt;/script&gt;\n                &lt;script src=\"https://unpkg.com/kepler.gl@3.0.0/umd/keplergl.min.js\"&gt;&lt;/script&gt;\n                &lt;link href=\"https://unpkg.com/kepler.gl@3.0.0/umd/keplergl.min.css\" rel=\"stylesheet\" /&gt;\n                &lt;style&gt;\n                    body {{ margin: 0; padding: 0; overflow: hidden; }}\n                    #app {{ width: 100vw; height: 100vh; }}\n                &lt;/style&gt;\n            &lt;/head&gt;\n            &lt;body&gt;\n                &lt;div id=\"app\"&gt;&lt;/div&gt;\n                &lt;script&gt;\n                    const state = {json.dumps(state)};\n                    // KeplerGL requires complex React setup\n                    document.getElementById(\"app\").innerHTML = \"KeplerGL widget - use anywidget interface for full interactivity\";\n                &lt;/script&gt;\n            &lt;/body&gt;\n            &lt;/html&gt;\n            '\n            width=\"{self.width}\"\n            height=\"{self.height}\"\n            frameborder=\"0\"\n        &gt;&lt;/iframe&gt;\n        \"\"\"\n        return html\n</code></pre>"},{"location":"keplergl/#anymap_ts.keplergl.KeplerGLMap.__init__","title":"<code>__init__(self, center=(-122.4, 37.8), zoom=10.0, width='100%', height='600px', config=None, read_only=False, show_data_table=True, mapbox_token=None, **kwargs)</code>  <code>special</code>","text":"<p>Initialize a KeplerGL map.</p> <p>Parameters:</p> Name Type Description Default <code>center</code> <code>Tuple[float, float]</code> <p>Map center as (longitude, latitude).</p> <code>(-122.4, 37.8)</code> <code>zoom</code> <code>float</code> <p>Initial zoom level.</p> <code>10.0</code> <code>width</code> <code>str</code> <p>Widget width as CSS string.</p> <code>'100%'</code> <code>height</code> <code>str</code> <p>Widget height as CSS string.</p> <code>'600px'</code> <code>config</code> <code>Optional[Dict]</code> <p>KeplerGL configuration dict.</p> <code>None</code> <code>read_only</code> <code>bool</code> <p>Whether the UI is read-only.</p> <code>False</code> <code>show_data_table</code> <code>bool</code> <p>Whether to show the data table panel.</p> <code>True</code> <code>mapbox_token</code> <code>Optional[str]</code> <p>Mapbox access token for basemaps.</p> <code>None</code> <code>**kwargs</code> <p>Additional widget arguments.</p> <code>{}</code> Source code in <code>anymap_ts/keplergl.py</code> <pre><code>def __init__(\n    self,\n    center: Tuple[float, float] = (-122.4, 37.8),\n    zoom: float = 10.0,\n    width: str = \"100%\",\n    height: str = \"600px\",\n    config: Optional[Dict] = None,\n    read_only: bool = False,\n    show_data_table: bool = True,\n    mapbox_token: Optional[str] = None,\n    **kwargs,\n):\n    \"\"\"Initialize a KeplerGL map.\n\n    Args:\n        center: Map center as (longitude, latitude).\n        zoom: Initial zoom level.\n        width: Widget width as CSS string.\n        height: Widget height as CSS string.\n        config: KeplerGL configuration dict.\n        read_only: Whether the UI is read-only.\n        show_data_table: Whether to show the data table panel.\n        mapbox_token: Mapbox access token for basemaps.\n        **kwargs: Additional widget arguments.\n    \"\"\"\n    import os\n\n    if mapbox_token is None:\n        mapbox_token = os.environ.get(\"MAPBOX_TOKEN\", \"\")\n\n    super().__init__(\n        center=list(center),\n        zoom=zoom,\n        width=width,\n        height=height,\n        config=config or {},\n        read_only=read_only,\n        show_data_table=show_data_table,\n        mapbox_token=mapbox_token,\n        **kwargs,\n    )\n    self.datasets = {}\n</code></pre>"},{"location":"keplergl/#anymap_ts.keplergl.KeplerGLMap.add_data","title":"<code>add_data(self, data, name=None)</code>","text":"<p>Add data to the map.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>Data to add (DataFrame, GeoDataFrame, dict, or file path).</p> required <code>name</code> <code>Optional[str]</code> <p>Dataset name/label.</p> <code>None</code> Source code in <code>anymap_ts/keplergl.py</code> <pre><code>def add_data(\n    self,\n    data: Any,\n    name: Optional[str] = None,\n) -&gt; None:\n    \"\"\"Add data to the map.\n\n    Args:\n        data: Data to add (DataFrame, GeoDataFrame, dict, or file path).\n        name: Dataset name/label.\n    \"\"\"\n    dataset_id = name or f\"data_{uuid.uuid4().hex[:8]}\"\n    processed_data = self._process_data(data)\n\n    self.datasets = {\n        **self.datasets,\n        dataset_id: {\n            \"info\": {\n                \"id\": dataset_id,\n                \"label\": dataset_id,\n            },\n            \"data\": processed_data,\n        },\n    }\n\n    self.call_js_method(\n        \"addData\",\n        dataId=dataset_id,\n        data=processed_data,\n    )\n</code></pre>"},{"location":"keplergl/#anymap_ts.keplergl.KeplerGLMap.add_filter","title":"<code>add_filter(self, data_id, field, filter_type='range', value=None)</code>","text":"<p>Add a filter to the visualization.</p> <p>Parameters:</p> Name Type Description Default <code>data_id</code> <code>str</code> <p>Dataset ID to filter.</p> required <code>field</code> <code>str</code> <p>Field name to filter on.</p> required <code>filter_type</code> <code>str</code> <p>Type of filter ('range', 'select', 'time').</p> <code>'range'</code> <code>value</code> <code>Optional[Any]</code> <p>Filter value(s).</p> <code>None</code> Source code in <code>anymap_ts/keplergl.py</code> <pre><code>def add_filter(\n    self,\n    data_id: str,\n    field: str,\n    filter_type: str = \"range\",\n    value: Optional[Any] = None,\n) -&gt; None:\n    \"\"\"Add a filter to the visualization.\n\n    Args:\n        data_id: Dataset ID to filter.\n        field: Field name to filter on.\n        filter_type: Type of filter ('range', 'select', 'time').\n        value: Filter value(s).\n    \"\"\"\n    filter_config = {\n        \"dataId\": [data_id],\n        \"name\": [field],\n        \"type\": filter_type,\n    }\n    if value is not None:\n        filter_config[\"value\"] = value\n\n    self.call_js_method(\"addFilter\", filter=filter_config)\n</code></pre>"},{"location":"keplergl/#anymap_ts.keplergl.KeplerGLMap.add_layer","title":"<code>add_layer(self, layer_type, data_id, columns, label=None, color=None, vis_config=None, **kwargs)</code>","text":"<p>Add a layer to the visualization.</p> <p>Parameters:</p> Name Type Description Default <code>layer_type</code> <code>str</code> <p>Layer type ('point', 'arc', 'line', 'hexagon', 'heatmap', etc.).</p> required <code>data_id</code> <code>str</code> <p>Dataset ID for the layer.</p> required <code>columns</code> <code>Dict[str, str]</code> <p>Column mapping (e.g., {'lat': 'latitude', 'lng': 'longitude'}).</p> required <code>label</code> <code>Optional[str]</code> <p>Layer label.</p> <code>None</code> <code>color</code> <code>Optional[List[int]]</code> <p>Layer color as [r, g, b].</p> <code>None</code> <code>vis_config</code> <code>Optional[Dict]</code> <p>Visual configuration.</p> <code>None</code> <code>**kwargs</code> <p>Additional layer options.</p> <code>{}</code> Source code in <code>anymap_ts/keplergl.py</code> <pre><code>def add_layer(\n    self,\n    layer_type: str,\n    data_id: str,\n    columns: Dict[str, str],\n    label: Optional[str] = None,\n    color: Optional[List[int]] = None,\n    vis_config: Optional[Dict] = None,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a layer to the visualization.\n\n    Args:\n        layer_type: Layer type ('point', 'arc', 'line', 'hexagon', 'heatmap', etc.).\n        data_id: Dataset ID for the layer.\n        columns: Column mapping (e.g., {'lat': 'latitude', 'lng': 'longitude'}).\n        label: Layer label.\n        color: Layer color as [r, g, b].\n        vis_config: Visual configuration.\n        **kwargs: Additional layer options.\n    \"\"\"\n    layer_config = {\n        \"type\": layer_type,\n        \"config\": {\n            \"dataId\": data_id,\n            \"label\": label or f\"{layer_type}_layer\",\n            \"columns\": columns,\n            \"isVisible\": True,\n        },\n    }\n    if color:\n        layer_config[\"config\"][\"color\"] = color\n    if vis_config:\n        layer_config[\"config\"][\"visConfig\"] = vis_config\n\n    layer_config[\"config\"].update(kwargs)\n\n    self.call_js_method(\"addLayer\", layer=layer_config)\n</code></pre>"},{"location":"keplergl/#anymap_ts.keplergl.KeplerGLMap.fly_to","title":"<code>fly_to(self, lng, lat, zoom=None)</code>","text":"<p>Fly to a location.</p> <p>Parameters:</p> Name Type Description Default <code>lng</code> <code>float</code> <p>Target longitude.</p> required <code>lat</code> <code>float</code> <p>Target latitude.</p> required <code>zoom</code> <code>Optional[float]</code> <p>Target zoom level.</p> <code>None</code> Source code in <code>anymap_ts/keplergl.py</code> <pre><code>def fly_to(\n    self,\n    lng: float,\n    lat: float,\n    zoom: Optional[float] = None,\n) -&gt; None:\n    \"\"\"Fly to a location.\n\n    Args:\n        lng: Target longitude.\n        lat: Target latitude.\n        zoom: Target zoom level.\n    \"\"\"\n    self.center = [lng, lat]\n    if zoom is not None:\n        self.zoom = zoom\n    self.call_js_method(\"flyTo\", lng=lng, lat=lat, zoom=zoom or self.zoom)\n</code></pre>"},{"location":"keplergl/#anymap_ts.keplergl.KeplerGLMap.get_config","title":"<code>get_config(self)</code>","text":"<p>Get the current KeplerGL configuration.</p> <p>Returns:</p> Type Description <code>Dict</code> <p>Configuration dict.</p> Source code in <code>anymap_ts/keplergl.py</code> <pre><code>def get_config(self) -&gt; Dict:\n    \"\"\"Get the current KeplerGL configuration.\n\n    Returns:\n        Configuration dict.\n    \"\"\"\n    return self.config\n</code></pre>"},{"location":"keplergl/#anymap_ts.keplergl.KeplerGLMap.load_config","title":"<code>load_config(self, filepath)</code>","text":"<p>Load configuration from a JSON file.</p> <p>Parameters:</p> Name Type Description Default <code>filepath</code> <code>Union[str, Path]</code> <p>Path to the configuration file.</p> required Source code in <code>anymap_ts/keplergl.py</code> <pre><code>def load_config(self, filepath: Union[str, Path]) -&gt; None:\n    \"\"\"Load configuration from a JSON file.\n\n    Args:\n        filepath: Path to the configuration file.\n    \"\"\"\n    with open(filepath) as f:\n        config = json.load(f)\n    self.set_config(config)\n</code></pre>"},{"location":"keplergl/#anymap_ts.keplergl.KeplerGLMap.remove_data","title":"<code>remove_data(self, name)</code>","text":"<p>Remove a dataset.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Dataset name to remove.</p> required Source code in <code>anymap_ts/keplergl.py</code> <pre><code>def remove_data(self, name: str) -&gt; None:\n    \"\"\"Remove a dataset.\n\n    Args:\n        name: Dataset name to remove.\n    \"\"\"\n    if name in self.datasets:\n        datasets = dict(self.datasets)\n        del datasets[name]\n        self.datasets = datasets\n    self.call_js_method(\"removeData\", dataId=name)\n</code></pre>"},{"location":"keplergl/#anymap_ts.keplergl.KeplerGLMap.save_config","title":"<code>save_config(self, filepath)</code>","text":"<p>Save configuration to a JSON file.</p> <p>Parameters:</p> Name Type Description Default <code>filepath</code> <code>Union[str, Path]</code> <p>Path to save the configuration.</p> required Source code in <code>anymap_ts/keplergl.py</code> <pre><code>def save_config(self, filepath: Union[str, Path]) -&gt; None:\n    \"\"\"Save configuration to a JSON file.\n\n    Args:\n        filepath: Path to save the configuration.\n    \"\"\"\n    with open(filepath, \"w\") as f:\n        json.dump(self.config, f, indent=2)\n</code></pre>"},{"location":"keplergl/#anymap_ts.keplergl.KeplerGLMap.set_config","title":"<code>set_config(self, config)</code>","text":"<p>Set the KeplerGL configuration.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>Dict</code> <p>Configuration dict.</p> required Source code in <code>anymap_ts/keplergl.py</code> <pre><code>def set_config(self, config: Dict) -&gt; None:\n    \"\"\"Set the KeplerGL configuration.\n\n    Args:\n        config: Configuration dict.\n    \"\"\"\n    self.config = config\n    self.call_js_method(\"setConfig\", config=config)\n</code></pre>"},{"location":"leaflet/","title":"leaflet module","text":"<p>Leaflet map widget implementation.</p>"},{"location":"leaflet/#anymap_ts.leaflet.LeafletMap","title":"<code> LeafletMap            (MapWidget)         </code>","text":"<p>Interactive map widget using Leaflet.</p> <p>This class provides a Python interface to Leaflet maps with full bidirectional communication through anywidget.</p> <p>Note</p> <p>Leaflet uses [lat, lng] order internally, but this class accepts [lng, lat] for consistency with other map libraries.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from anymap_ts import LeafletMap\n&gt;&gt;&gt; m = LeafletMap(center=[-122.4, 37.8], zoom=10)\n&gt;&gt;&gt; m.add_basemap(\"OpenStreetMap\")\n&gt;&gt;&gt; m\n</code></pre> Source code in <code>anymap_ts/leaflet.py</code> <pre><code>class LeafletMap(MapWidget):\n    \"\"\"Interactive map widget using Leaflet.\n\n    This class provides a Python interface to Leaflet maps with\n    full bidirectional communication through anywidget.\n\n    Note:\n        Leaflet uses [lat, lng] order internally, but this class\n        accepts [lng, lat] for consistency with other map libraries.\n\n    Example:\n        &gt;&gt;&gt; from anymap_ts import LeafletMap\n        &gt;&gt;&gt; m = LeafletMap(center=[-122.4, 37.8], zoom=10)\n        &gt;&gt;&gt; m.add_basemap(\"OpenStreetMap\")\n        &gt;&gt;&gt; m\n    \"\"\"\n\n    # ESM module for frontend\n    _esm = STATIC_DIR / \"leaflet.js\"\n    _css = STATIC_DIR / \"leaflet.css\"\n\n    # Layer tracking\n    _layer_dict = traitlets.Dict({}).tag(sync=True)\n\n    def __init__(\n        self,\n        center: Tuple[float, float] = (0.0, 0.0),\n        zoom: float = 2.0,\n        width: str = \"100%\",\n        height: str = \"600px\",\n        controls: Optional[Dict[str, Any]] = None,\n        **kwargs,\n    ):\n        \"\"\"Initialize a Leaflet map.\n\n        Args:\n            center: Map center as (longitude, latitude).\n            zoom: Initial zoom level.\n            width: Map width as CSS string.\n            height: Map height as CSS string.\n            controls: Dict of controls to add (e.g., {\"zoom\": True}).\n            **kwargs: Additional widget arguments.\n        \"\"\"\n        super().__init__(\n            center=list(center),\n            zoom=zoom,\n            width=width,\n            height=height,\n            style=\"\",  # Leaflet doesn't use style URLs\n            **kwargs,\n        )\n\n        # Initialize layer dictionary\n        self._layer_dict = {\"Background\": []}\n\n        # Add default controls\n        if controls is None:\n            controls = {\"zoom\": True, \"scale\": True}\n\n        for control_name, config in controls.items():\n            if config:\n                self.add_control(\n                    control_name, **(config if isinstance(config, dict) else {})\n                )\n\n    # -------------------------------------------------------------------------\n    # Basemap Methods\n    # -------------------------------------------------------------------------\n\n    def add_basemap(\n        self,\n        basemap: str = \"OpenStreetMap\",\n        attribution: Optional[str] = None,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a basemap layer.\n\n        Args:\n            basemap: Name of basemap provider (e.g., \"OpenStreetMap\", \"CartoDB.Positron\").\n            attribution: Custom attribution text.\n            **kwargs: Additional options.\n        \"\"\"\n        try:\n            url, default_attribution = get_basemap_url(basemap)\n        except (ValueError, KeyError):\n            url = basemap\n            default_attribution = \"\"\n\n        self.call_js_method(\n            \"addBasemap\",\n            url,\n            attribution=attribution or default_attribution,\n            name=basemap,\n            **kwargs,\n        )\n\n        # Track in layer dict\n        basemaps = self._layer_dict.get(\"Basemaps\", [])\n        if basemap not in basemaps:\n            self._layer_dict = {\n                **self._layer_dict,\n                \"Basemaps\": basemaps + [basemap],\n            }\n\n    # -------------------------------------------------------------------------\n    # Vector Data Methods\n    # -------------------------------------------------------------------------\n\n    def add_vector(\n        self,\n        data: Any,\n        style: Optional[Dict] = None,\n        name: Optional[str] = None,\n        fit_bounds: bool = True,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add vector data to the map.\n\n        Supports GeoJSON, GeoDataFrame, or file paths to vector formats.\n\n        Args:\n            data: GeoJSON dict, GeoDataFrame, or path to vector file.\n            style: Leaflet style properties.\n            name: Layer name.\n            fit_bounds: Whether to fit map to data bounds.\n            **kwargs: Additional layer options.\n        \"\"\"\n        geojson = to_geojson(data)\n\n        # Handle URL data\n        if geojson.get(\"type\") == \"url\":\n            self.add_geojson(\n                geojson[\"url\"],\n                style=style,\n                name=name,\n                fit_bounds=fit_bounds,\n                **kwargs,\n            )\n            return\n\n        layer_id = name or f\"vector-{len(self._layers)}\"\n\n        # Get default style if not provided\n        if style is None:\n            layer_type = _infer_leaflet_type(geojson)\n            style = _get_default_style(layer_type)\n\n        # Get bounds\n        bounds = get_bounds(data) if fit_bounds else None\n\n        # Call JavaScript\n        self.call_js_method(\n            \"addGeoJSON\",\n            data=geojson,\n            name=layer_id,\n            style=style,\n            fitBounds=fit_bounds,\n            bounds=bounds,\n            **kwargs,\n        )\n\n        # Track layer\n        self._layers = {\n            **self._layers,\n            layer_id: {\n                \"id\": layer_id,\n                \"type\": \"geojson\",\n                \"style\": style,\n            },\n        }\n\n    def add_geojson(\n        self,\n        data: Union[str, Dict],\n        style: Optional[Dict] = None,\n        name: Optional[str] = None,\n        fit_bounds: bool = True,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add GeoJSON data to the map.\n\n        Args:\n            data: GeoJSON dict or URL to GeoJSON file.\n            style: Leaflet style properties.\n            name: Layer name.\n            fit_bounds: Whether to fit map to data bounds.\n            **kwargs: Additional layer options.\n        \"\"\"\n        self.add_vector(\n            data,\n            style=style,\n            name=name,\n            fit_bounds=fit_bounds,\n            **kwargs,\n        )\n\n    # -------------------------------------------------------------------------\n    # Raster Data Methods\n    # -------------------------------------------------------------------------\n\n    def add_tile_layer(\n        self,\n        url: str,\n        name: Optional[str] = None,\n        attribution: str = \"\",\n        min_zoom: int = 0,\n        max_zoom: int = 22,\n        opacity: float = 1.0,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add an XYZ tile layer.\n\n        Args:\n            url: Tile URL template with {x}, {y}, {z} placeholders.\n            name: Layer name.\n            attribution: Attribution text.\n            min_zoom: Minimum zoom level.\n            max_zoom: Maximum zoom level.\n            opacity: Layer opacity.\n            **kwargs: Additional options.\n        \"\"\"\n        layer_id = name or f\"tiles-{len(self._layers)}\"\n\n        self.call_js_method(\n            \"addTileLayer\",\n            url,\n            name=layer_id,\n            attribution=attribution,\n            minZoom=min_zoom,\n            maxZoom=max_zoom,\n            opacity=opacity,\n            **kwargs,\n        )\n\n        # Track layer\n        self._layers = {\n            **self._layers,\n            layer_id: {\n                \"id\": layer_id,\n                \"type\": \"tile\",\n            },\n        }\n\n    # -------------------------------------------------------------------------\n    # Layer Management\n    # -------------------------------------------------------------------------\n\n    def remove_layer(self, layer_id: str) -&gt; None:\n        \"\"\"Remove a layer from the map.\n\n        Args:\n            layer_id: Layer identifier to remove.\n        \"\"\"\n        if layer_id in self._layers:\n            layers = dict(self._layers)\n            del layers[layer_id]\n            self._layers = layers\n        self.call_js_method(\"removeLayer\", layer_id)\n\n    def set_visibility(self, layer_id: str, visible: bool) -&gt; None:\n        \"\"\"Set layer visibility.\n\n        Args:\n            layer_id: Layer identifier.\n            visible: Whether layer should be visible.\n        \"\"\"\n        self.call_js_method(\"setVisibility\", layer_id, visible)\n\n    def set_opacity(self, layer_id: str, opacity: float) -&gt; None:\n        \"\"\"Set layer opacity.\n\n        Args:\n            layer_id: Layer identifier.\n            opacity: Opacity value between 0 and 1.\n        \"\"\"\n        self.call_js_method(\"setOpacity\", layer_id, opacity)\n\n    # -------------------------------------------------------------------------\n    # Controls\n    # -------------------------------------------------------------------------\n\n    def add_control(\n        self,\n        control_type: str,\n        position: str = \"topright\",\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a map control.\n\n        Args:\n            control_type: Type of control ('zoom', 'scale', 'attribution', 'layers').\n            position: Control position ('topleft', 'topright', 'bottomleft', 'bottomright').\n            **kwargs: Control-specific options.\n        \"\"\"\n        # Convert position format\n        position_map = {\n            \"top-left\": \"topleft\",\n            \"top-right\": \"topright\",\n            \"bottom-left\": \"bottomleft\",\n            \"bottom-right\": \"bottomright\",\n        }\n        pos = position_map.get(position, position)\n\n        self.call_js_method(\"addControl\", control_type, position=pos, **kwargs)\n        self._controls = {\n            **self._controls,\n            control_type: {\"type\": control_type, \"position\": pos, **kwargs},\n        }\n\n    def remove_control(self, control_type: str) -&gt; None:\n        \"\"\"Remove a map control.\n\n        Args:\n            control_type: Type of control to remove.\n        \"\"\"\n        self.call_js_method(\"removeControl\", control_type)\n        if control_type in self._controls:\n            controls = dict(self._controls)\n            del controls[control_type]\n            self._controls = controls\n\n    def add_layer_control(\n        self,\n        position: str = \"topright\",\n        collapsed: bool = True,\n    ) -&gt; None:\n        \"\"\"Add a layer control for toggling layer visibility.\n\n        Args:\n            position: Control position.\n            collapsed: Whether control starts collapsed.\n        \"\"\"\n        self.add_control(\"layers\", position=position, collapsed=collapsed)\n\n    # -------------------------------------------------------------------------\n    # Markers\n    # -------------------------------------------------------------------------\n\n    def add_marker(\n        self,\n        lng: float,\n        lat: float,\n        popup: Optional[str] = None,\n        marker_id: Optional[str] = None,\n    ) -&gt; None:\n        \"\"\"Add a marker to the map.\n\n        Args:\n            lng: Longitude.\n            lat: Latitude.\n            popup: HTML content for popup.\n            marker_id: Unique marker ID.\n        \"\"\"\n        self.call_js_method(\"addMarker\", lng, lat, popup=popup, id=marker_id)\n\n    def remove_marker(self, marker_id: str) -&gt; None:\n        \"\"\"Remove a marker from the map.\n\n        Args:\n            marker_id: Marker ID to remove.\n        \"\"\"\n        self.call_js_method(\"removeMarker\", marker_id)\n\n    # -------------------------------------------------------------------------\n    # HTML Export\n    # -------------------------------------------------------------------------\n\n    def _generate_html_template(self) -&gt; str:\n        \"\"\"Generate standalone HTML for the map.\"\"\"\n        template_path = Path(__file__).parent / \"templates\" / \"leaflet.html\"\n\n        if template_path.exists():\n            template = template_path.read_text(encoding=\"utf-8\")\n        else:\n            template = self._get_default_template()\n\n        # Serialize state\n        state = {\n            \"center\": self.center,\n            \"zoom\": self.zoom,\n            \"width\": self.width,\n            \"height\": self.height,\n            \"layers\": self._layers,\n            \"controls\": self._controls,\n            \"js_calls\": self._js_calls,\n        }\n\n        template = template.replace(\"{{state}}\", json.dumps(state, indent=2))\n        return template\n\n    def _get_default_template(self) -&gt; str:\n        \"\"\"Get default HTML template.\"\"\"\n        return \"\"\"&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n    &lt;meta charset=\"utf-8\"&gt;\n    &lt;title&gt;{{title}}&lt;/title&gt;\n    &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"&gt;\n    &lt;link rel=\"stylesheet\" href=\"https://unpkg.com/leaflet@1.9.4/dist/leaflet.css\" /&gt;\n    &lt;script src=\"https://unpkg.com/leaflet@1.9.4/dist/leaflet.js\"&gt;&lt;/script&gt;\n    &lt;style&gt;\n        body { margin: 0; padding: 0; }\n        #map { position: absolute; top: 0; bottom: 0; width: 100%; }\n    &lt;/style&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;div id=\"map\"&gt;&lt;/div&gt;\n    &lt;script&gt;\n        const state = {{state}};\n\n        // Note: Leaflet uses [lat, lng], but we store [lng, lat]\n        const map = L.map('map').setView([state.center[1], state.center[0]], state.zoom);\n\n        // Replay JS calls\n        for (const call of state.js_calls || []) {\n            try {\n                executeMethod(call.method, call.args, call.kwargs);\n            } catch (e) {\n                console.error('Error executing', call.method, e);\n            }\n        }\n\n        function executeMethod(method, args, kwargs) {\n            switch (method) {\n                case 'addBasemap':\n                case 'addTileLayer':\n                    const url = args[0];\n                    L.tileLayer(url, {\n                        attribution: kwargs.attribution || '',\n                        maxZoom: kwargs.maxZoom || 22,\n                        minZoom: kwargs.minZoom || 0,\n                        opacity: kwargs.opacity || 1\n                    }).addTo(map);\n                    break;\n\n                case 'addGeoJSON':\n                    const geojson = kwargs.data;\n                    const style = kwargs.style || {\n                        color: '#3388ff',\n                        weight: 2,\n                        opacity: 0.8,\n                        fillOpacity: 0.5\n                    };\n                    const layer = L.geoJSON(geojson, {\n                        style: style,\n                        pointToLayer: (feature, latlng) =&gt; L.circleMarker(latlng, style)\n                    }).addTo(map);\n\n                    if (kwargs.fitBounds) {\n                        map.fitBounds(layer.getBounds(), { padding: [50, 50] });\n                    }\n                    break;\n\n                case 'addControl':\n                    const controlType = args[0];\n                    const position = kwargs.position || 'topright';\n                    if (controlType === 'zoom' || controlType === 'navigation') {\n                        L.control.zoom({ position }).addTo(map);\n                    } else if (controlType === 'scale') {\n                        L.control.scale({ position, imperial: false }).addTo(map);\n                    }\n                    break;\n\n                case 'addMarker':\n                    const [lng, lat] = args;\n                    const marker = L.marker([lat, lng]).addTo(map);\n                    if (kwargs.popup) {\n                        marker.bindPopup(kwargs.popup);\n                    }\n                    break;\n\n                case 'flyTo':\n                    map.flyTo([args[1], args[0]], kwargs.zoom || map.getZoom(), {\n                        duration: (kwargs.duration || 2000) / 1000\n                    });\n                    break;\n\n                case 'fitBounds':\n                    const bounds = args[0];\n                    map.fitBounds([\n                        [bounds[1], bounds[0]],\n                        [bounds[3], bounds[2]]\n                    ], { padding: [kwargs.padding || 50, kwargs.padding || 50] });\n                    break;\n\n                default:\n                    console.log('Unknown method:', method);\n            }\n        }\n    &lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\"\"\"\n</code></pre>"},{"location":"leaflet/#anymap_ts.leaflet.LeafletMap.__init__","title":"<code>__init__(self, center=(0.0, 0.0), zoom=2.0, width='100%', height='600px', controls=None, **kwargs)</code>  <code>special</code>","text":"<p>Initialize a Leaflet map.</p> <p>Parameters:</p> Name Type Description Default <code>center</code> <code>Tuple[float, float]</code> <p>Map center as (longitude, latitude).</p> <code>(0.0, 0.0)</code> <code>zoom</code> <code>float</code> <p>Initial zoom level.</p> <code>2.0</code> <code>width</code> <code>str</code> <p>Map width as CSS string.</p> <code>'100%'</code> <code>height</code> <code>str</code> <p>Map height as CSS string.</p> <code>'600px'</code> <code>controls</code> <code>Optional[Dict[str, Any]]</code> <p>Dict of controls to add (e.g., {\"zoom\": True}).</p> <code>None</code> <code>**kwargs</code> <p>Additional widget arguments.</p> <code>{}</code> Source code in <code>anymap_ts/leaflet.py</code> <pre><code>def __init__(\n    self,\n    center: Tuple[float, float] = (0.0, 0.0),\n    zoom: float = 2.0,\n    width: str = \"100%\",\n    height: str = \"600px\",\n    controls: Optional[Dict[str, Any]] = None,\n    **kwargs,\n):\n    \"\"\"Initialize a Leaflet map.\n\n    Args:\n        center: Map center as (longitude, latitude).\n        zoom: Initial zoom level.\n        width: Map width as CSS string.\n        height: Map height as CSS string.\n        controls: Dict of controls to add (e.g., {\"zoom\": True}).\n        **kwargs: Additional widget arguments.\n    \"\"\"\n    super().__init__(\n        center=list(center),\n        zoom=zoom,\n        width=width,\n        height=height,\n        style=\"\",  # Leaflet doesn't use style URLs\n        **kwargs,\n    )\n\n    # Initialize layer dictionary\n    self._layer_dict = {\"Background\": []}\n\n    # Add default controls\n    if controls is None:\n        controls = {\"zoom\": True, \"scale\": True}\n\n    for control_name, config in controls.items():\n        if config:\n            self.add_control(\n                control_name, **(config if isinstance(config, dict) else {})\n            )\n</code></pre>"},{"location":"leaflet/#anymap_ts.leaflet.LeafletMap.add_basemap","title":"<code>add_basemap(self, basemap='OpenStreetMap', attribution=None, **kwargs)</code>","text":"<p>Add a basemap layer.</p> <p>Parameters:</p> Name Type Description Default <code>basemap</code> <code>str</code> <p>Name of basemap provider (e.g., \"OpenStreetMap\", \"CartoDB.Positron\").</p> <code>'OpenStreetMap'</code> <code>attribution</code> <code>Optional[str]</code> <p>Custom attribution text.</p> <code>None</code> <code>**kwargs</code> <p>Additional options.</p> <code>{}</code> Source code in <code>anymap_ts/leaflet.py</code> <pre><code>def add_basemap(\n    self,\n    basemap: str = \"OpenStreetMap\",\n    attribution: Optional[str] = None,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a basemap layer.\n\n    Args:\n        basemap: Name of basemap provider (e.g., \"OpenStreetMap\", \"CartoDB.Positron\").\n        attribution: Custom attribution text.\n        **kwargs: Additional options.\n    \"\"\"\n    try:\n        url, default_attribution = get_basemap_url(basemap)\n    except (ValueError, KeyError):\n        url = basemap\n        default_attribution = \"\"\n\n    self.call_js_method(\n        \"addBasemap\",\n        url,\n        attribution=attribution or default_attribution,\n        name=basemap,\n        **kwargs,\n    )\n\n    # Track in layer dict\n    basemaps = self._layer_dict.get(\"Basemaps\", [])\n    if basemap not in basemaps:\n        self._layer_dict = {\n            **self._layer_dict,\n            \"Basemaps\": basemaps + [basemap],\n        }\n</code></pre>"},{"location":"leaflet/#anymap_ts.leaflet.LeafletMap.add_control","title":"<code>add_control(self, control_type, position='topright', **kwargs)</code>","text":"<p>Add a map control.</p> <p>Parameters:</p> Name Type Description Default <code>control_type</code> <code>str</code> <p>Type of control ('zoom', 'scale', 'attribution', 'layers').</p> required <code>position</code> <code>str</code> <p>Control position ('topleft', 'topright', 'bottomleft', 'bottomright').</p> <code>'topright'</code> <code>**kwargs</code> <p>Control-specific options.</p> <code>{}</code> Source code in <code>anymap_ts/leaflet.py</code> <pre><code>def add_control(\n    self,\n    control_type: str,\n    position: str = \"topright\",\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a map control.\n\n    Args:\n        control_type: Type of control ('zoom', 'scale', 'attribution', 'layers').\n        position: Control position ('topleft', 'topright', 'bottomleft', 'bottomright').\n        **kwargs: Control-specific options.\n    \"\"\"\n    # Convert position format\n    position_map = {\n        \"top-left\": \"topleft\",\n        \"top-right\": \"topright\",\n        \"bottom-left\": \"bottomleft\",\n        \"bottom-right\": \"bottomright\",\n    }\n    pos = position_map.get(position, position)\n\n    self.call_js_method(\"addControl\", control_type, position=pos, **kwargs)\n    self._controls = {\n        **self._controls,\n        control_type: {\"type\": control_type, \"position\": pos, **kwargs},\n    }\n</code></pre>"},{"location":"leaflet/#anymap_ts.leaflet.LeafletMap.add_geojson","title":"<code>add_geojson(self, data, style=None, name=None, fit_bounds=True, **kwargs)</code>","text":"<p>Add GeoJSON data to the map.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Union[str, Dict]</code> <p>GeoJSON dict or URL to GeoJSON file.</p> required <code>style</code> <code>Optional[Dict]</code> <p>Leaflet style properties.</p> <code>None</code> <code>name</code> <code>Optional[str]</code> <p>Layer name.</p> <code>None</code> <code>fit_bounds</code> <code>bool</code> <p>Whether to fit map to data bounds.</p> <code>True</code> <code>**kwargs</code> <p>Additional layer options.</p> <code>{}</code> Source code in <code>anymap_ts/leaflet.py</code> <pre><code>def add_geojson(\n    self,\n    data: Union[str, Dict],\n    style: Optional[Dict] = None,\n    name: Optional[str] = None,\n    fit_bounds: bool = True,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add GeoJSON data to the map.\n\n    Args:\n        data: GeoJSON dict or URL to GeoJSON file.\n        style: Leaflet style properties.\n        name: Layer name.\n        fit_bounds: Whether to fit map to data bounds.\n        **kwargs: Additional layer options.\n    \"\"\"\n    self.add_vector(\n        data,\n        style=style,\n        name=name,\n        fit_bounds=fit_bounds,\n        **kwargs,\n    )\n</code></pre>"},{"location":"leaflet/#anymap_ts.leaflet.LeafletMap.add_layer_control","title":"<code>add_layer_control(self, position='topright', collapsed=True)</code>","text":"<p>Add a layer control for toggling layer visibility.</p> <p>Parameters:</p> Name Type Description Default <code>position</code> <code>str</code> <p>Control position.</p> <code>'topright'</code> <code>collapsed</code> <code>bool</code> <p>Whether control starts collapsed.</p> <code>True</code> Source code in <code>anymap_ts/leaflet.py</code> <pre><code>def add_layer_control(\n    self,\n    position: str = \"topright\",\n    collapsed: bool = True,\n) -&gt; None:\n    \"\"\"Add a layer control for toggling layer visibility.\n\n    Args:\n        position: Control position.\n        collapsed: Whether control starts collapsed.\n    \"\"\"\n    self.add_control(\"layers\", position=position, collapsed=collapsed)\n</code></pre>"},{"location":"leaflet/#anymap_ts.leaflet.LeafletMap.add_marker","title":"<code>add_marker(self, lng, lat, popup=None, marker_id=None)</code>","text":"<p>Add a marker to the map.</p> <p>Parameters:</p> Name Type Description Default <code>lng</code> <code>float</code> <p>Longitude.</p> required <code>lat</code> <code>float</code> <p>Latitude.</p> required <code>popup</code> <code>Optional[str]</code> <p>HTML content for popup.</p> <code>None</code> <code>marker_id</code> <code>Optional[str]</code> <p>Unique marker ID.</p> <code>None</code> Source code in <code>anymap_ts/leaflet.py</code> <pre><code>def add_marker(\n    self,\n    lng: float,\n    lat: float,\n    popup: Optional[str] = None,\n    marker_id: Optional[str] = None,\n) -&gt; None:\n    \"\"\"Add a marker to the map.\n\n    Args:\n        lng: Longitude.\n        lat: Latitude.\n        popup: HTML content for popup.\n        marker_id: Unique marker ID.\n    \"\"\"\n    self.call_js_method(\"addMarker\", lng, lat, popup=popup, id=marker_id)\n</code></pre>"},{"location":"leaflet/#anymap_ts.leaflet.LeafletMap.add_tile_layer","title":"<code>add_tile_layer(self, url, name=None, attribution='', min_zoom=0, max_zoom=22, opacity=1.0, **kwargs)</code>","text":"<p>Add an XYZ tile layer.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>Tile URL template with {x}, {y}, {z} placeholders.</p> required <code>name</code> <code>Optional[str]</code> <p>Layer name.</p> <code>None</code> <code>attribution</code> <code>str</code> <p>Attribution text.</p> <code>''</code> <code>min_zoom</code> <code>int</code> <p>Minimum zoom level.</p> <code>0</code> <code>max_zoom</code> <code>int</code> <p>Maximum zoom level.</p> <code>22</code> <code>opacity</code> <code>float</code> <p>Layer opacity.</p> <code>1.0</code> <code>**kwargs</code> <p>Additional options.</p> <code>{}</code> Source code in <code>anymap_ts/leaflet.py</code> <pre><code>def add_tile_layer(\n    self,\n    url: str,\n    name: Optional[str] = None,\n    attribution: str = \"\",\n    min_zoom: int = 0,\n    max_zoom: int = 22,\n    opacity: float = 1.0,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add an XYZ tile layer.\n\n    Args:\n        url: Tile URL template with {x}, {y}, {z} placeholders.\n        name: Layer name.\n        attribution: Attribution text.\n        min_zoom: Minimum zoom level.\n        max_zoom: Maximum zoom level.\n        opacity: Layer opacity.\n        **kwargs: Additional options.\n    \"\"\"\n    layer_id = name or f\"tiles-{len(self._layers)}\"\n\n    self.call_js_method(\n        \"addTileLayer\",\n        url,\n        name=layer_id,\n        attribution=attribution,\n        minZoom=min_zoom,\n        maxZoom=max_zoom,\n        opacity=opacity,\n        **kwargs,\n    )\n\n    # Track layer\n    self._layers = {\n        **self._layers,\n        layer_id: {\n            \"id\": layer_id,\n            \"type\": \"tile\",\n        },\n    }\n</code></pre>"},{"location":"leaflet/#anymap_ts.leaflet.LeafletMap.add_vector","title":"<code>add_vector(self, data, style=None, name=None, fit_bounds=True, **kwargs)</code>","text":"<p>Add vector data to the map.</p> <p>Supports GeoJSON, GeoDataFrame, or file paths to vector formats.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>GeoJSON dict, GeoDataFrame, or path to vector file.</p> required <code>style</code> <code>Optional[Dict]</code> <p>Leaflet style properties.</p> <code>None</code> <code>name</code> <code>Optional[str]</code> <p>Layer name.</p> <code>None</code> <code>fit_bounds</code> <code>bool</code> <p>Whether to fit map to data bounds.</p> <code>True</code> <code>**kwargs</code> <p>Additional layer options.</p> <code>{}</code> Source code in <code>anymap_ts/leaflet.py</code> <pre><code>def add_vector(\n    self,\n    data: Any,\n    style: Optional[Dict] = None,\n    name: Optional[str] = None,\n    fit_bounds: bool = True,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add vector data to the map.\n\n    Supports GeoJSON, GeoDataFrame, or file paths to vector formats.\n\n    Args:\n        data: GeoJSON dict, GeoDataFrame, or path to vector file.\n        style: Leaflet style properties.\n        name: Layer name.\n        fit_bounds: Whether to fit map to data bounds.\n        **kwargs: Additional layer options.\n    \"\"\"\n    geojson = to_geojson(data)\n\n    # Handle URL data\n    if geojson.get(\"type\") == \"url\":\n        self.add_geojson(\n            geojson[\"url\"],\n            style=style,\n            name=name,\n            fit_bounds=fit_bounds,\n            **kwargs,\n        )\n        return\n\n    layer_id = name or f\"vector-{len(self._layers)}\"\n\n    # Get default style if not provided\n    if style is None:\n        layer_type = _infer_leaflet_type(geojson)\n        style = _get_default_style(layer_type)\n\n    # Get bounds\n    bounds = get_bounds(data) if fit_bounds else None\n\n    # Call JavaScript\n    self.call_js_method(\n        \"addGeoJSON\",\n        data=geojson,\n        name=layer_id,\n        style=style,\n        fitBounds=fit_bounds,\n        bounds=bounds,\n        **kwargs,\n    )\n\n    # Track layer\n    self._layers = {\n        **self._layers,\n        layer_id: {\n            \"id\": layer_id,\n            \"type\": \"geojson\",\n            \"style\": style,\n        },\n    }\n</code></pre>"},{"location":"leaflet/#anymap_ts.leaflet.LeafletMap.remove_control","title":"<code>remove_control(self, control_type)</code>","text":"<p>Remove a map control.</p> <p>Parameters:</p> Name Type Description Default <code>control_type</code> <code>str</code> <p>Type of control to remove.</p> required Source code in <code>anymap_ts/leaflet.py</code> <pre><code>def remove_control(self, control_type: str) -&gt; None:\n    \"\"\"Remove a map control.\n\n    Args:\n        control_type: Type of control to remove.\n    \"\"\"\n    self.call_js_method(\"removeControl\", control_type)\n    if control_type in self._controls:\n        controls = dict(self._controls)\n        del controls[control_type]\n        self._controls = controls\n</code></pre>"},{"location":"leaflet/#anymap_ts.leaflet.LeafletMap.remove_layer","title":"<code>remove_layer(self, layer_id)</code>","text":"<p>Remove a layer from the map.</p> <p>Parameters:</p> Name Type Description Default <code>layer_id</code> <code>str</code> <p>Layer identifier to remove.</p> required Source code in <code>anymap_ts/leaflet.py</code> <pre><code>def remove_layer(self, layer_id: str) -&gt; None:\n    \"\"\"Remove a layer from the map.\n\n    Args:\n        layer_id: Layer identifier to remove.\n    \"\"\"\n    if layer_id in self._layers:\n        layers = dict(self._layers)\n        del layers[layer_id]\n        self._layers = layers\n    self.call_js_method(\"removeLayer\", layer_id)\n</code></pre>"},{"location":"leaflet/#anymap_ts.leaflet.LeafletMap.remove_marker","title":"<code>remove_marker(self, marker_id)</code>","text":"<p>Remove a marker from the map.</p> <p>Parameters:</p> Name Type Description Default <code>marker_id</code> <code>str</code> <p>Marker ID to remove.</p> required Source code in <code>anymap_ts/leaflet.py</code> <pre><code>def remove_marker(self, marker_id: str) -&gt; None:\n    \"\"\"Remove a marker from the map.\n\n    Args:\n        marker_id: Marker ID to remove.\n    \"\"\"\n    self.call_js_method(\"removeMarker\", marker_id)\n</code></pre>"},{"location":"leaflet/#anymap_ts.leaflet.LeafletMap.set_opacity","title":"<code>set_opacity(self, layer_id, opacity)</code>","text":"<p>Set layer opacity.</p> <p>Parameters:</p> Name Type Description Default <code>layer_id</code> <code>str</code> <p>Layer identifier.</p> required <code>opacity</code> <code>float</code> <p>Opacity value between 0 and 1.</p> required Source code in <code>anymap_ts/leaflet.py</code> <pre><code>def set_opacity(self, layer_id: str, opacity: float) -&gt; None:\n    \"\"\"Set layer opacity.\n\n    Args:\n        layer_id: Layer identifier.\n        opacity: Opacity value between 0 and 1.\n    \"\"\"\n    self.call_js_method(\"setOpacity\", layer_id, opacity)\n</code></pre>"},{"location":"leaflet/#anymap_ts.leaflet.LeafletMap.set_visibility","title":"<code>set_visibility(self, layer_id, visible)</code>","text":"<p>Set layer visibility.</p> <p>Parameters:</p> Name Type Description Default <code>layer_id</code> <code>str</code> <p>Layer identifier.</p> required <code>visible</code> <code>bool</code> <p>Whether layer should be visible.</p> required Source code in <code>anymap_ts/leaflet.py</code> <pre><code>def set_visibility(self, layer_id: str, visible: bool) -&gt; None:\n    \"\"\"Set layer visibility.\n\n    Args:\n        layer_id: Layer identifier.\n        visible: Whether layer should be visible.\n    \"\"\"\n    self.call_js_method(\"setVisibility\", layer_id, visible)\n</code></pre>"},{"location":"mapbox/","title":"mapbox module","text":"<p>Mapbox GL JS map widget implementation.</p>"},{"location":"mapbox/#anymap_ts.mapbox.MapboxMap","title":"<code> MapboxMap            (MapWidget)         </code>","text":"<p>Interactive map widget using Mapbox GL JS.</p> <p>This class provides a Python interface to Mapbox GL JS maps with full bidirectional communication through anywidget.</p> <p>Note</p> <p>Requires a Mapbox access token. Set via MAPBOX_TOKEN environment variable or pass directly to the constructor.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from anymap_ts import MapboxMap\n&gt;&gt;&gt; m = MapboxMap(center=[-122.4, 37.8], zoom=10)\n&gt;&gt;&gt; m.add_basemap(\"mapbox://styles/mapbox/streets-v12\")\n&gt;&gt;&gt; m\n</code></pre> Source code in <code>anymap_ts/mapbox.py</code> <pre><code>class MapboxMap(MapWidget):\n    \"\"\"Interactive map widget using Mapbox GL JS.\n\n    This class provides a Python interface to Mapbox GL JS maps with\n    full bidirectional communication through anywidget.\n\n    Note:\n        Requires a Mapbox access token. Set via MAPBOX_TOKEN environment\n        variable or pass directly to the constructor.\n\n    Example:\n        &gt;&gt;&gt; from anymap_ts import MapboxMap\n        &gt;&gt;&gt; m = MapboxMap(center=[-122.4, 37.8], zoom=10)\n        &gt;&gt;&gt; m.add_basemap(\"mapbox://styles/mapbox/streets-v12\")\n        &gt;&gt;&gt; m\n    \"\"\"\n\n    # ESM module for frontend\n    _esm = STATIC_DIR / \"mapbox.js\"\n    _css = STATIC_DIR / \"mapbox.css\"\n\n    # Mapbox-specific traits\n    access_token = traitlets.Unicode(\"\").tag(sync=True)\n    bearing = traitlets.Float(0.0).tag(sync=True)\n    pitch = traitlets.Float(0.0).tag(sync=True)\n    antialias = traitlets.Bool(True).tag(sync=True)\n    double_click_zoom = traitlets.Bool(True).tag(sync=True)\n\n    # Layer tracking\n    _layer_dict = traitlets.Dict({}).tag(sync=True)\n\n    def __init__(\n        self,\n        center: Tuple[float, float] = (0.0, 0.0),\n        zoom: float = 2.0,\n        width: str = \"100%\",\n        height: str = \"600px\",\n        style: str = \"mapbox://styles/mapbox/streets-v12\",\n        bearing: float = 0.0,\n        pitch: float = 0.0,\n        max_pitch: float = 85.0,\n        access_token: Optional[str] = None,\n        controls: Optional[Dict[str, Any]] = None,\n        **kwargs,\n    ):\n        \"\"\"Initialize a Mapbox map.\n\n        Args:\n            center: Map center as (longitude, latitude).\n            zoom: Initial zoom level.\n            width: Map width as CSS string.\n            height: Map height as CSS string.\n            style: Mapbox style URL (e.g., \"mapbox://styles/mapbox/streets-v12\").\n            bearing: Map bearing in degrees.\n            pitch: Map pitch in degrees.\n            max_pitch: Maximum pitch angle in degrees (default: 85).\n            access_token: Mapbox access token. If None, reads from MAPBOX_TOKEN env var.\n            controls: Dict of controls to add (e.g., {\"navigation\": True}).\n            **kwargs: Additional widget arguments.\n        \"\"\"\n        # Get access token\n        token = access_token or get_mapbox_token()\n        if not token:\n            print(\n                \"Warning: No Mapbox access token provided. \"\n                \"Set MAPBOX_TOKEN environment variable or pass access_token parameter.\"\n            )\n\n        super().__init__(\n            center=list(center),\n            zoom=zoom,\n            width=width,\n            height=height,\n            style=style,\n            bearing=bearing,\n            pitch=pitch,\n            max_pitch=max_pitch,\n            access_token=token,\n            **kwargs,\n        )\n\n        # Initialize layer dictionary\n        self._layer_dict = {\"Background\": []}\n\n        # Add default controls\n        if controls is None:\n            controls = {\"navigation\": True, \"fullscreen\": True}\n\n        for control_name, config in controls.items():\n            if config:\n                self.add_control(\n                    control_name, **(config if isinstance(config, dict) else {})\n                )\n\n    def set_access_token(self, token: str) -&gt; None:\n        \"\"\"Set the Mapbox access token.\n\n        Args:\n            token: Mapbox access token.\n        \"\"\"\n        self.access_token = token\n\n    # -------------------------------------------------------------------------\n    # Basemap Methods\n    # -------------------------------------------------------------------------\n\n    def add_basemap(\n        self,\n        basemap: str = \"mapbox://styles/mapbox/streets-v12\",\n        attribution: Optional[str] = None,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a basemap layer.\n\n        For Mapbox styles, use the style URL format:\n        - \"mapbox://styles/mapbox/streets-v12\"\n        - \"mapbox://styles/mapbox/satellite-v9\"\n        - \"mapbox://styles/mapbox/satellite-streets-v12\"\n        - \"mapbox://styles/mapbox/light-v11\"\n        - \"mapbox://styles/mapbox/dark-v11\"\n        - \"mapbox://styles/mapbox/outdoors-v12\"\n\n        Or use XYZ tile URLs for custom basemaps.\n\n        Args:\n            basemap: Mapbox style URL or XYZ tile URL.\n            attribution: Custom attribution text.\n            **kwargs: Additional options.\n        \"\"\"\n        # If it's a Mapbox style URL, set it as the map style\n        if basemap.startswith(\"mapbox://\"):\n            self.style = basemap\n            return\n\n        # Otherwise, treat as XYZ tile URL\n        try:\n            url, default_attribution = get_basemap_url(basemap)\n        except (ValueError, KeyError):\n            url = basemap\n            default_attribution = \"\"\n\n        self.call_js_method(\n            \"addBasemap\",\n            url,\n            attribution=attribution or default_attribution,\n            name=basemap,\n            **kwargs,\n        )\n\n        # Track in layer dict\n        basemaps = self._layer_dict.get(\"Basemaps\", [])\n        if basemap not in basemaps:\n            self._layer_dict = {\n                **self._layer_dict,\n                \"Basemaps\": basemaps + [basemap],\n            }\n\n    # -------------------------------------------------------------------------\n    # Vector Data Methods\n    # -------------------------------------------------------------------------\n\n    def add_vector(\n        self,\n        data: Any,\n        layer_type: Optional[str] = None,\n        paint: Optional[Dict] = None,\n        name: Optional[str] = None,\n        fit_bounds: bool = True,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add vector data to the map.\n\n        Supports GeoJSON, GeoDataFrame, or file paths to vector formats.\n\n        Args:\n            data: GeoJSON dict, GeoDataFrame, or path to vector file.\n            layer_type: Mapbox layer type ('circle', 'line', 'fill', 'symbol').\n            paint: Mapbox paint properties.\n            name: Layer name.\n            fit_bounds: Whether to fit map to data bounds.\n            **kwargs: Additional layer options.\n        \"\"\"\n        geojson = to_geojson(data)\n\n        # Handle URL data\n        if geojson.get(\"type\") == \"url\":\n            self.add_geojson(\n                geojson[\"url\"],\n                layer_type=layer_type,\n                paint=paint,\n                name=name,\n                fit_bounds=fit_bounds,\n                **kwargs,\n            )\n            return\n\n        layer_id = name or f\"vector-{len(self._layers)}\"\n\n        # Infer layer type if not specified\n        if layer_type is None:\n            layer_type = infer_layer_type(geojson)\n\n        # Get default paint if not provided\n        if paint is None:\n            paint = get_default_paint(layer_type)\n\n        # Get bounds\n        bounds = get_bounds(data) if fit_bounds else None\n\n        # Call JavaScript\n        self.call_js_method(\n            \"addGeoJSON\",\n            data=geojson,\n            name=layer_id,\n            layerType=layer_type,\n            paint=paint,\n            fitBounds=fit_bounds,\n            bounds=bounds,\n            **kwargs,\n        )\n\n        # Track layer\n        self._layers = {\n            **self._layers,\n            layer_id: {\n                \"id\": layer_id,\n                \"type\": layer_type,\n                \"source\": f\"{layer_id}-source\",\n                \"paint\": paint,\n            },\n        }\n\n    def add_geojson(\n        self,\n        data: Union[str, Dict],\n        layer_type: Optional[str] = None,\n        paint: Optional[Dict] = None,\n        name: Optional[str] = None,\n        fit_bounds: bool = True,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add GeoJSON data to the map.\n\n        Args:\n            data: GeoJSON dict or URL to GeoJSON file.\n            layer_type: Mapbox layer type.\n            paint: Mapbox paint properties.\n            name: Layer name.\n            fit_bounds: Whether to fit map to data bounds.\n            **kwargs: Additional layer options.\n        \"\"\"\n        self.add_vector(\n            data,\n            layer_type=layer_type,\n            paint=paint,\n            name=name,\n            fit_bounds=fit_bounds,\n            **kwargs,\n        )\n\n    # -------------------------------------------------------------------------\n    # Raster Data Methods\n    # -------------------------------------------------------------------------\n\n    def add_tile_layer(\n        self,\n        url: str,\n        name: Optional[str] = None,\n        attribution: str = \"\",\n        min_zoom: int = 0,\n        max_zoom: int = 22,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add an XYZ tile layer.\n\n        Args:\n            url: Tile URL template with {x}, {y}, {z} placeholders.\n            name: Layer name.\n            attribution: Attribution text.\n            min_zoom: Minimum zoom level.\n            max_zoom: Maximum zoom level.\n            **kwargs: Additional options.\n        \"\"\"\n        layer_id = name or f\"tiles-{len(self._layers)}\"\n\n        self.call_js_method(\n            \"addTileLayer\",\n            url,\n            name=layer_id,\n            attribution=attribution,\n            minZoom=min_zoom,\n            maxZoom=max_zoom,\n            **kwargs,\n        )\n\n        # Track layer\n        self._layers = {\n            **self._layers,\n            layer_id: {\n                \"id\": layer_id,\n                \"type\": \"raster\",\n                \"source\": f\"{layer_id}-source\",\n            },\n        }\n\n    # -------------------------------------------------------------------------\n    # COG Layer (deck.gl)\n    # -------------------------------------------------------------------------\n\n    def add_cog_layer(\n        self,\n        url: str,\n        name: Optional[str] = None,\n        opacity: float = 1.0,\n        visible: bool = True,\n        debug: bool = False,\n        debug_opacity: float = 0.25,\n        max_error: float = 0.125,\n        fit_bounds: bool = True,\n        before_id: Optional[str] = None,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a Cloud Optimized GeoTIFF (COG) layer using deck.gl-raster.\n\n        This method renders COG files directly in the browser using GPU-accelerated\n        deck.gl rendering with automatic reprojection support.\n\n        Args:\n            url: URL to the Cloud Optimized GeoTIFF file.\n            name: Layer ID. If None, auto-generated.\n            opacity: Layer opacity (0-1).\n            visible: Whether layer is visible.\n            debug: Show reprojection mesh for debugging.\n            debug_opacity: Opacity of debug mesh (0-1).\n            max_error: Maximum reprojection error in pixels. Lower values\n                create denser mesh for better accuracy.\n            fit_bounds: Whether to fit map to COG bounds after loading.\n            before_id: ID of layer to insert before.\n            **kwargs: Additional COGLayer props.\n\n        Example:\n            &gt;&gt;&gt; from anymap_ts import MapboxMap\n            &gt;&gt;&gt; m = MapboxMap()\n            &gt;&gt;&gt; m.add_cog_layer(\n            ...     \"https://example.com/landcover.tif\",\n            ...     name=\"landcover\",\n            ...     opacity=0.8\n            ... )\n        \"\"\"\n        layer_id = name or f\"cog-{len(self._layers)}\"\n\n        self.call_js_method(\n            \"addCOGLayer\",\n            id=layer_id,\n            geotiff=url,\n            opacity=opacity,\n            visible=visible,\n            debug=debug,\n            debugOpacity=debug_opacity,\n            maxError=max_error,\n            fitBounds=fit_bounds,\n            beforeId=before_id,\n            **kwargs,\n        )\n\n        self._layers = {\n            **self._layers,\n            layer_id: {\n                \"id\": layer_id,\n                \"type\": \"cog\",\n                \"url\": url,\n            },\n        }\n\n    def remove_cog_layer(self, layer_id: str) -&gt; None:\n        \"\"\"Remove a COG layer.\n\n        Args:\n            layer_id: Layer identifier to remove.\n        \"\"\"\n        if layer_id in self._layers:\n            layers = dict(self._layers)\n            del layers[layer_id]\n            self._layers = layers\n        self.call_js_method(\"removeCOGLayer\", layer_id)\n\n    # -------------------------------------------------------------------------\n    # Arc Layer (deck.gl)\n    # -------------------------------------------------------------------------\n\n    def add_arc_layer(\n        self,\n        data: Any,\n        name: Optional[str] = None,\n        get_source_position: Union[str, Any] = \"source\",\n        get_target_position: Union[str, Any] = \"target\",\n        get_source_color: Optional[List[int]] = None,\n        get_target_color: Optional[List[int]] = None,\n        get_width: Union[float, str] = 1,\n        get_height: float = 1,\n        great_circle: bool = False,\n        pickable: bool = True,\n        opacity: float = 0.8,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add an arc layer for origin-destination visualization using deck.gl.\n\n        Arc layers are ideal for visualizing connections between locations,\n        such as flight routes, migration patterns, or network flows.\n\n        Args:\n            data: Array of data objects with source/target coordinates.\n                Each object should have source and target positions.\n            name: Layer ID. If None, auto-generated.\n            get_source_position: Accessor for source position [lng, lat].\n                Can be a string (property name) or a value.\n            get_target_position: Accessor for target position [lng, lat].\n                Can be a string (property name) or a value.\n            get_source_color: Source end color as [r, g, b, a].\n                Default: [51, 136, 255, 255] (blue).\n            get_target_color: Target end color as [r, g, b, a].\n                Default: [255, 136, 51, 255] (orange).\n            get_width: Arc width in pixels. Can be a number or accessor.\n            get_height: Arc height multiplier. Higher values create more curved arcs.\n            great_circle: Whether to draw arcs along great circles.\n            pickable: Whether layer responds to hover/click events.\n            opacity: Layer opacity (0-1).\n            **kwargs: Additional ArcLayer props.\n\n        Example:\n            &gt;&gt;&gt; from anymap_ts import MapboxMap\n            &gt;&gt;&gt; m = MapboxMap()\n            &gt;&gt;&gt; arcs = [\n            ...     {\"source\": [-122.4, 37.8], \"target\": [-73.9, 40.7]},\n            ...     {\"source\": [-122.4, 37.8], \"target\": [-0.1, 51.5]},\n            ... ]\n            &gt;&gt;&gt; m.add_arc_layer(arcs, name=\"flights\")\n        \"\"\"\n        layer_id = name or f\"arc-{len(self._layers)}\"\n        processed_data = self._process_deck_data(data)\n\n        self.call_js_method(\n            \"addArcLayer\",\n            id=layer_id,\n            data=processed_data,\n            getSourcePosition=get_source_position,\n            getTargetPosition=get_target_position,\n            getSourceColor=get_source_color or [51, 136, 255, 255],\n            getTargetColor=get_target_color or [255, 136, 51, 255],\n            getWidth=get_width,\n            getHeight=get_height,\n            greatCircle=great_circle,\n            pickable=pickable,\n            opacity=opacity,\n            **kwargs,\n        )\n\n        self._layers = {\n            **self._layers,\n            layer_id: {\n                \"id\": layer_id,\n                \"type\": \"arc\",\n            },\n        }\n\n    def remove_arc_layer(self, layer_id: str) -&gt; None:\n        \"\"\"Remove an arc layer.\n\n        Args:\n            layer_id: Layer identifier to remove.\n        \"\"\"\n        if layer_id in self._layers:\n            layers = dict(self._layers)\n            del layers[layer_id]\n            self._layers = layers\n        self.call_js_method(\"removeArcLayer\", layer_id)\n\n    # -------------------------------------------------------------------------\n    # PointCloud Layer (deck.gl)\n    # -------------------------------------------------------------------------\n\n    def add_point_cloud_layer(\n        self,\n        data: Any,\n        name: Optional[str] = None,\n        get_position: Union[str, Any] = \"position\",\n        get_color: Optional[Union[List[int], str]] = None,\n        get_normal: Optional[Union[str, Any]] = None,\n        point_size: float = 2,\n        size_units: str = \"pixels\",\n        pickable: bool = True,\n        opacity: float = 1.0,\n        material: bool = True,\n        coordinate_system: Optional[int] = None,\n        coordinate_origin: Optional[List[float]] = None,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a point cloud layer for 3D point visualization using deck.gl.\n\n        Point cloud layers render large collections of 3D points, ideal for\n        LiDAR data, photogrammetry outputs, or any 3D point dataset.\n\n        Args:\n            data: Array of point data with positions. Each point should have\n                x, y, z coordinates (or position array).\n            name: Layer ID. If None, auto-generated.\n            get_position: Accessor for point position [x, y, z].\n                Can be a string (property name) or a value.\n            get_color: Accessor or value for point color [r, g, b, a].\n                Default: [255, 255, 255, 255] (white).\n            get_normal: Accessor for point normal [nx, ny, nz] for lighting.\n                Default: [0, 0, 1] (pointing up).\n            point_size: Point size in pixels or meters (depends on size_units).\n            size_units: Size units: 'pixels', 'meters', or 'common'.\n            pickable: Whether layer responds to hover/click events.\n            opacity: Layer opacity (0-1).\n            material: Whether to enable lighting effects.\n            coordinate_system: Coordinate system for positions.\n            coordinate_origin: Origin for coordinate system [x, y, z].\n            **kwargs: Additional PointCloudLayer props.\n\n        Example:\n            &gt;&gt;&gt; from anymap_ts import MapboxMap\n            &gt;&gt;&gt; m = MapboxMap(pitch=45)\n            &gt;&gt;&gt; points = [\n            ...     {\"position\": [-122.4, 37.8, 100], \"color\": [255, 0, 0, 255]},\n            ...     {\"position\": [-122.3, 37.7, 200], \"color\": [0, 255, 0, 255]},\n            ... ]\n            &gt;&gt;&gt; m.add_point_cloud_layer(points, point_size=5)\n        \"\"\"\n        layer_id = name or f\"pointcloud-{len(self._layers)}\"\n        processed_data = self._process_deck_data(data)\n\n        self.call_js_method(\n            \"addPointCloudLayer\",\n            id=layer_id,\n            data=processed_data,\n            getPosition=get_position,\n            getColor=get_color or [255, 255, 255, 255],\n            getNormal=get_normal,\n            pointSize=point_size,\n            sizeUnits=size_units,\n            pickable=pickable,\n            opacity=opacity,\n            material=material,\n            coordinateSystem=coordinate_system,\n            coordinateOrigin=coordinate_origin,\n            **kwargs,\n        )\n\n        self._layers = {\n            **self._layers,\n            layer_id: {\n                \"id\": layer_id,\n                \"type\": \"pointcloud\",\n            },\n        }\n\n    def remove_point_cloud_layer(self, layer_id: str) -&gt; None:\n        \"\"\"Remove a point cloud layer.\n\n        Args:\n            layer_id: Layer identifier to remove.\n        \"\"\"\n        if layer_id in self._layers:\n            layers = dict(self._layers)\n            del layers[layer_id]\n            self._layers = layers\n        self.call_js_method(\"removePointCloudLayer\", layer_id)\n\n    # -------------------------------------------------------------------------\n    # LiDAR Layers (maplibre-gl-lidar)\n    # -------------------------------------------------------------------------\n\n    def add_lidar_control(\n        self,\n        position: str = \"top-right\",\n        collapsed: bool = True,\n        title: str = \"LiDAR Viewer\",\n        point_size: float = 2,\n        opacity: float = 1.0,\n        color_scheme: str = \"elevation\",\n        use_percentile: bool = True,\n        point_budget: int = 1000000,\n        pickable: bool = False,\n        auto_zoom: bool = True,\n        copc_loading_mode: Optional[str] = None,\n        streaming_point_budget: int = 5000000,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add an interactive LiDAR control panel.\n\n        The LiDAR control provides a UI panel for loading, visualizing, and\n        styling LiDAR point cloud files (LAS, LAZ, COPC formats).\n\n        Args:\n            position: Control position ('top-left', 'top-right', 'bottom-left', 'bottom-right').\n            collapsed: Whether the panel starts collapsed.\n            title: Title displayed on the panel.\n            point_size: Point size in pixels.\n            opacity: Layer opacity (0-1).\n            color_scheme: Color scheme ('elevation', 'intensity', 'classification', 'rgb').\n            use_percentile: Use 2-98% percentile for color scaling.\n            point_budget: Maximum number of points to display.\n            pickable: Enable hover/click interactions.\n            auto_zoom: Auto-zoom to point cloud after loading.\n            copc_loading_mode: COPC loading mode ('full' or 'dynamic').\n            streaming_point_budget: Point budget for streaming mode.\n            **kwargs: Additional control options.\n\n        Example:\n            &gt;&gt;&gt; from anymap_ts import MapboxMap\n            &gt;&gt;&gt; m = MapboxMap(pitch=60)\n            &gt;&gt;&gt; m.add_lidar_control(color_scheme=\"classification\", pickable=True)\n        \"\"\"\n        self.call_js_method(\n            \"addLidarControl\",\n            position=position,\n            collapsed=collapsed,\n            title=title,\n            pointSize=point_size,\n            opacity=opacity,\n            colorScheme=color_scheme,\n            usePercentile=use_percentile,\n            pointBudget=point_budget,\n            pickable=pickable,\n            autoZoom=auto_zoom,\n            copcLoadingMode=copc_loading_mode,\n            streamingPointBudget=streaming_point_budget,\n            **kwargs,\n        )\n        self._controls = {\n            **self._controls,\n            \"lidar-control\": {\"position\": position, \"collapsed\": collapsed},\n        }\n\n    def add_lidar_layer(\n        self,\n        source: Union[str, Path],\n        name: Optional[str] = None,\n        color_scheme: str = \"elevation\",\n        point_size: float = 2,\n        opacity: float = 1.0,\n        pickable: bool = True,\n        auto_zoom: bool = True,\n        streaming_mode: bool = True,\n        point_budget: int = 1000000,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Load and display a LiDAR file from URL or local path.\n\n        Supports LAS, LAZ, and COPC (Cloud-Optimized Point Cloud) formats.\n        For local files, the file is read and sent as base64 to JavaScript.\n        For URLs, the data is loaded directly via streaming when possible.\n\n        Args:\n            source: URL or local file path to the LiDAR file.\n            name: Layer identifier. If None, auto-generated.\n            color_scheme: Color scheme ('elevation', 'intensity', 'classification', 'rgb').\n            point_size: Point size in pixels.\n            opacity: Layer opacity (0-1).\n            pickable: Enable hover/click interactions.\n            auto_zoom: Auto-zoom to point cloud after loading.\n            streaming_mode: Use streaming mode for large COPC files.\n            point_budget: Maximum number of points to display.\n            **kwargs: Additional layer options.\n\n        Example:\n            &gt;&gt;&gt; from anymap_ts import MapboxMap\n            &gt;&gt;&gt; m = MapboxMap(center=[-123.07, 44.05], zoom=14, pitch=60)\n            &gt;&gt;&gt; m.add_lidar_layer(\n            ...     source=\"https://s3.amazonaws.com/hobu-lidar/autzen-classified.copc.laz\",\n            ...     name=\"autzen\",\n            ...     color_scheme=\"classification\",\n            ... )\n        \"\"\"\n        import base64\n\n        layer_id = name or f\"lidar-{len(self._layers)}\"\n\n        # Check if source is a local file\n        source_path = Path(source) if isinstance(source, (str, Path)) else None\n        is_local = source_path is not None and source_path.exists()\n\n        if is_local:\n            # Read local file and encode as base64\n            with open(source_path, \"rb\") as f:\n                file_data = f.read()\n            source_b64 = base64.b64encode(file_data).decode(\"utf-8\")\n\n            self.call_js_method(\n                \"addLidarLayer\",\n                source=source_b64,\n                name=layer_id,\n                isBase64=True,\n                filename=source_path.name,\n                colorScheme=color_scheme,\n                pointSize=point_size,\n                opacity=opacity,\n                pickable=pickable,\n                autoZoom=auto_zoom,\n                streamingMode=streaming_mode,\n                pointBudget=point_budget,\n                **kwargs,\n            )\n        else:\n            # Load from URL\n            self.call_js_method(\n                \"addLidarLayer\",\n                source=str(source),\n                name=layer_id,\n                isBase64=False,\n                colorScheme=color_scheme,\n                pointSize=point_size,\n                opacity=opacity,\n                pickable=pickable,\n                autoZoom=auto_zoom,\n                streamingMode=streaming_mode,\n                pointBudget=point_budget,\n                **kwargs,\n            )\n\n        self._layers = {\n            **self._layers,\n            layer_id: {\n                \"id\": layer_id,\n                \"type\": \"lidar\",\n                \"source\": str(source),\n            },\n        }\n\n    def remove_lidar_layer(self, layer_id: Optional[str] = None) -&gt; None:\n        \"\"\"Remove a LiDAR layer.\n\n        Args:\n            layer_id: Layer identifier to remove. If None, removes all LiDAR layers.\n        \"\"\"\n        if layer_id:\n            if layer_id in self._layers:\n                layers = dict(self._layers)\n                del layers[layer_id]\n                self._layers = layers\n            self.call_js_method(\"removeLidarLayer\", id=layer_id)\n        else:\n            # Remove all lidar layers\n            layers = dict(self._layers)\n            self._layers = {k: v for k, v in layers.items() if v.get(\"type\") != \"lidar\"}\n            self.call_js_method(\"removeLidarLayer\")\n\n    def set_lidar_color_scheme(self, color_scheme: str) -&gt; None:\n        \"\"\"Set the LiDAR color scheme.\n\n        Args:\n            color_scheme: Color scheme ('elevation', 'intensity', 'classification', 'rgb').\n        \"\"\"\n        self.call_js_method(\"setLidarColorScheme\", colorScheme=color_scheme)\n\n    def set_lidar_point_size(self, point_size: float) -&gt; None:\n        \"\"\"Set the LiDAR point size.\n\n        Args:\n            point_size: Point size in pixels.\n        \"\"\"\n        self.call_js_method(\"setLidarPointSize\", pointSize=point_size)\n\n    def set_lidar_opacity(self, opacity: float) -&gt; None:\n        \"\"\"Set the LiDAR layer opacity.\n\n        Args:\n            opacity: Opacity value between 0 and 1.\n        \"\"\"\n        self.call_js_method(\"setLidarOpacity\", opacity=opacity)\n\n    def _process_deck_data(self, data: Any) -&gt; Any:\n        \"\"\"Process data for deck.gl layers.\n\n        Handles GeoDataFrame, file paths, GeoJSON, and list of dicts.\n\n        Args:\n            data: Input data in various formats.\n\n        Returns:\n            Processed data suitable for deck.gl layers.\n        \"\"\"\n        # Handle GeoDataFrame\n        if hasattr(data, \"__geo_interface__\"):\n            return data.__geo_interface__\n\n        # Handle file paths\n        if isinstance(data, (str, Path)):\n            path = Path(data)\n            if path.exists():\n                try:\n                    import geopandas as gpd\n\n                    gdf = gpd.read_file(path)\n                    return gdf.__geo_interface__\n                except ImportError:\n                    pass\n\n        # Return as-is for lists, dicts, etc.\n        return data\n\n    # -------------------------------------------------------------------------\n    # Terrain Methods (Mapbox-specific)\n    # -------------------------------------------------------------------------\n\n    def add_terrain(\n        self, exaggeration: float = 1.0, source: str = \"mapbox-dem\"\n    ) -&gt; None:\n        \"\"\"Add 3D terrain to the map.\n\n        Args:\n            exaggeration: Terrain exaggeration factor.\n            source: Terrain source ID.\n        \"\"\"\n        self.call_js_method(\"addTerrain\", source=source, exaggeration=exaggeration)\n\n    def remove_terrain(self) -&gt; None:\n        \"\"\"Remove 3D terrain from the map.\"\"\"\n        self.call_js_method(\"removeTerrain\")\n\n    # -------------------------------------------------------------------------\n    # Layer Management\n    # -------------------------------------------------------------------------\n\n    def add_layer(\n        self,\n        layer_id: str,\n        layer_type: str,\n        source: Union[str, Dict],\n        paint: Optional[Dict] = None,\n        layout: Optional[Dict] = None,\n        before_id: Optional[str] = None,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a generic layer to the map.\n\n        Args:\n            layer_id: Unique layer identifier.\n            layer_type: Mapbox layer type.\n            source: Source ID or source configuration dict.\n            paint: Paint properties.\n            layout: Layout properties.\n            before_id: ID of layer to insert before.\n            **kwargs: Additional layer options.\n        \"\"\"\n        layer_config = {\n            \"id\": layer_id,\n            \"type\": layer_type,\n            \"paint\": paint or {},\n            \"layout\": layout or {},\n            **kwargs,\n        }\n\n        if isinstance(source, str):\n            layer_config[\"source\"] = source\n        else:\n            source_id = f\"{layer_id}-source\"\n            self._sources = {**self._sources, source_id: source}\n            self.call_js_method(\"addSource\", source_id, **source)\n            layer_config[\"source\"] = source_id\n\n        self._layers = {**self._layers, layer_id: layer_config}\n        self.call_js_method(\"addLayer\", beforeId=before_id, **layer_config)\n\n    def remove_layer(self, layer_id: str) -&gt; None:\n        \"\"\"Remove a layer from the map.\n\n        Args:\n            layer_id: Layer identifier to remove.\n        \"\"\"\n        if layer_id in self._layers:\n            layers = dict(self._layers)\n            del layers[layer_id]\n            self._layers = layers\n        self.call_js_method(\"removeLayer\", layer_id)\n\n    def set_visibility(self, layer_id: str, visible: bool) -&gt; None:\n        \"\"\"Set layer visibility.\n\n        Args:\n            layer_id: Layer identifier.\n            visible: Whether layer should be visible.\n        \"\"\"\n        self.call_js_method(\"setVisibility\", layer_id, visible)\n\n    def set_opacity(self, layer_id: str, opacity: float) -&gt; None:\n        \"\"\"Set layer opacity.\n\n        Args:\n            layer_id: Layer identifier.\n            opacity: Opacity value between 0 and 1.\n        \"\"\"\n        self.call_js_method(\"setOpacity\", layer_id, opacity)\n\n    # -------------------------------------------------------------------------\n    # Controls\n    # -------------------------------------------------------------------------\n\n    def add_control(\n        self,\n        control_type: str,\n        position: str = \"top-right\",\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a map control.\n\n        Args:\n            control_type: Type of control ('navigation', 'scale', 'fullscreen', etc.).\n            position: Control position.\n            **kwargs: Control-specific options.\n        \"\"\"\n        self.call_js_method(\"addControl\", control_type, position=position, **kwargs)\n        self._controls = {\n            **self._controls,\n            control_type: {\"type\": control_type, \"position\": position, **kwargs},\n        }\n\n    def remove_control(self, control_type: str) -&gt; None:\n        \"\"\"Remove a map control.\n\n        Args:\n            control_type: Type of control to remove.\n        \"\"\"\n        self.call_js_method(\"removeControl\", control_type)\n        if control_type in self._controls:\n            controls = dict(self._controls)\n            del controls[control_type]\n            self._controls = controls\n\n    # -------------------------------------------------------------------------\n    # Markers\n    # -------------------------------------------------------------------------\n\n    def add_marker(\n        self,\n        lng: float,\n        lat: float,\n        color: str = \"#3388ff\",\n        popup: Optional[str] = None,\n        marker_id: Optional[str] = None,\n    ) -&gt; None:\n        \"\"\"Add a marker to the map.\n\n        Args:\n            lng: Longitude.\n            lat: Latitude.\n            color: Marker color.\n            popup: HTML content for popup.\n            marker_id: Unique marker ID.\n        \"\"\"\n        self.call_js_method(\n            \"addMarker\", lng, lat, color=color, popup=popup, id=marker_id\n        )\n\n    def remove_marker(self, marker_id: str) -&gt; None:\n        \"\"\"Remove a marker from the map.\n\n        Args:\n            marker_id: Marker ID to remove.\n        \"\"\"\n        self.call_js_method(\"removeMarker\", marker_id)\n\n    # -------------------------------------------------------------------------\n    # HTML Export\n    # -------------------------------------------------------------------------\n\n    def _generate_html_template(self) -&gt; str:\n        \"\"\"Generate standalone HTML for the map.\"\"\"\n        template_path = Path(__file__).parent / \"templates\" / \"mapbox.html\"\n\n        if template_path.exists():\n            template = template_path.read_text(encoding=\"utf-8\")\n        else:\n            template = self._get_default_template()\n\n        # Serialize state\n        state = {\n            \"center\": self.center,\n            \"zoom\": self.zoom,\n            \"style\": self.style,\n            \"bearing\": self.bearing,\n            \"pitch\": self.pitch,\n            \"width\": self.width,\n            \"height\": self.height,\n            \"layers\": self._layers,\n            \"sources\": self._sources,\n            \"controls\": self._controls,\n            \"js_calls\": self._js_calls,\n            \"access_token\": self.access_token,\n        }\n\n        template = template.replace(\"{{state}}\", json.dumps(state, indent=2))\n        return template\n\n    def _get_default_template(self) -&gt; str:\n        \"\"\"Get default HTML template.\"\"\"\n        return \"\"\"&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n    &lt;meta charset=\"utf-8\"&gt;\n    &lt;title&gt;{{title}}&lt;/title&gt;\n    &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"&gt;\n    &lt;script src=\"https://api.mapbox.com/mapbox-gl-js/v3.0.0/mapbox-gl.js\"&gt;&lt;/script&gt;\n    &lt;link href=\"https://api.mapbox.com/mapbox-gl-js/v3.0.0/mapbox-gl.css\" rel=\"stylesheet\" /&gt;\n    &lt;style&gt;\n        body { margin: 0; padding: 0; }\n        #map { position: absolute; top: 0; bottom: 0; width: 100%; }\n    &lt;/style&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;div id=\"map\"&gt;&lt;/div&gt;\n    &lt;script&gt;\n        const state = {{state}};\n\n        mapboxgl.accessToken = state.access_token;\n\n        const map = new mapboxgl.Map({\n            container: 'map',\n            style: state.style,\n            center: state.center,\n            zoom: state.zoom,\n            bearing: state.bearing || 0,\n            pitch: state.pitch || 0\n        });\n\n        map.on('load', function() {\n            // Replay JS calls\n            for (const call of state.js_calls || []) {\n                try {\n                    executeMethod(call.method, call.args, call.kwargs);\n                } catch (e) {\n                    console.error('Error executing', call.method, e);\n                }\n            }\n        });\n\n        function executeMethod(method, args, kwargs) {\n            switch (method) {\n                case 'addBasemap':\n                    const url = args[0];\n                    const name = kwargs.name || 'basemap';\n                    const sourceId = 'basemap-' + name;\n                    if (!map.getSource(sourceId)) {\n                        map.addSource(sourceId, {\n                            type: 'raster',\n                            tiles: [url],\n                            tileSize: 256,\n                            attribution: kwargs.attribution || ''\n                        });\n                    }\n                    if (!map.getLayer(sourceId)) {\n                        map.addLayer({\n                            id: sourceId,\n                            type: 'raster',\n                            source: sourceId\n                        });\n                    }\n                    break;\n\n                case 'addGeoJSON':\n                    const layerName = kwargs.name;\n                    const sourceIdGeo = layerName + '-source';\n                    if (!map.getSource(sourceIdGeo)) {\n                        map.addSource(sourceIdGeo, {\n                            type: 'geojson',\n                            data: kwargs.data\n                        });\n                    }\n                    if (!map.getLayer(layerName)) {\n                        map.addLayer({\n                            id: layerName,\n                            type: kwargs.layerType || 'circle',\n                            source: sourceIdGeo,\n                            paint: kwargs.paint || {}\n                        });\n                    }\n                    if (kwargs.fitBounds &amp;&amp; kwargs.bounds) {\n                        map.fitBounds([\n                            [kwargs.bounds[0], kwargs.bounds[1]],\n                            [kwargs.bounds[2], kwargs.bounds[3]]\n                        ], { padding: 50 });\n                    }\n                    break;\n\n                case 'addTileLayer':\n                    const tileUrl = args[0];\n                    const tileName = kwargs.name;\n                    const tileSourceId = tileName + '-source';\n                    if (!map.getSource(tileSourceId)) {\n                        map.addSource(tileSourceId, {\n                            type: 'raster',\n                            tiles: [tileUrl],\n                            tileSize: 256,\n                            attribution: kwargs.attribution || ''\n                        });\n                    }\n                    if (!map.getLayer(tileName)) {\n                        map.addLayer({\n                            id: tileName,\n                            type: 'raster',\n                            source: tileSourceId\n                        });\n                    }\n                    break;\n\n                case 'addControl':\n                    const controlType = args[0];\n                    const position = kwargs.position || 'top-right';\n                    let control;\n                    switch (controlType) {\n                        case 'navigation':\n                            control = new mapboxgl.NavigationControl();\n                            break;\n                        case 'scale':\n                            control = new mapboxgl.ScaleControl();\n                            break;\n                        case 'fullscreen':\n                            control = new mapboxgl.FullscreenControl();\n                            break;\n                    }\n                    if (control) {\n                        map.addControl(control, position);\n                    }\n                    break;\n\n                case 'addTerrain':\n                    const terrainSource = kwargs.source || 'mapbox-dem';\n                    if (!map.getSource(terrainSource)) {\n                        map.addSource(terrainSource, {\n                            type: 'raster-dem',\n                            url: 'mapbox://mapbox.mapbox-terrain-dem-v1',\n                            tileSize: 512,\n                            maxzoom: 14\n                        });\n                    }\n                    map.setTerrain({ source: terrainSource, exaggeration: kwargs.exaggeration || 1 });\n                    break;\n\n                case 'removeTerrain':\n                    map.setTerrain(null);\n                    break;\n\n                case 'flyTo':\n                    map.flyTo({\n                        center: [args[0], args[1]],\n                        zoom: kwargs.zoom,\n                        duration: kwargs.duration || 2000\n                    });\n                    break;\n\n                case 'fitBounds':\n                    const bounds = args[0];\n                    map.fitBounds([\n                        [bounds[0], bounds[1]],\n                        [bounds[2], bounds[3]]\n                    ], {\n                        padding: kwargs.padding || 50,\n                        duration: kwargs.duration || 1000\n                    });\n                    break;\n\n                case 'addMarker':\n                    new mapboxgl.Marker({ color: kwargs.color || '#3388ff' })\n                        .setLngLat([args[0], args[1]])\n                        .addTo(map);\n                    break;\n\n                default:\n                    console.log('Unknown method:', method);\n            }\n        }\n    &lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\"\"\"\n</code></pre>"},{"location":"mapbox/#anymap_ts.mapbox.MapboxMap.__init__","title":"<code>__init__(self, center=(0.0, 0.0), zoom=2.0, width='100%', height='600px', style='mapbox://styles/mapbox/streets-v12', bearing=0.0, pitch=0.0, max_pitch=85.0, access_token=None, controls=None, **kwargs)</code>  <code>special</code>","text":"<p>Initialize a Mapbox map.</p> <p>Parameters:</p> Name Type Description Default <code>center</code> <code>Tuple[float, float]</code> <p>Map center as (longitude, latitude).</p> <code>(0.0, 0.0)</code> <code>zoom</code> <code>float</code> <p>Initial zoom level.</p> <code>2.0</code> <code>width</code> <code>str</code> <p>Map width as CSS string.</p> <code>'100%'</code> <code>height</code> <code>str</code> <p>Map height as CSS string.</p> <code>'600px'</code> <code>style</code> <code>str</code> <p>Mapbox style URL (e.g., \"mapbox://styles/mapbox/streets-v12\").</p> <code>'mapbox://styles/mapbox/streets-v12'</code> <code>bearing</code> <code>float</code> <p>Map bearing in degrees.</p> <code>0.0</code> <code>pitch</code> <code>float</code> <p>Map pitch in degrees.</p> <code>0.0</code> <code>max_pitch</code> <code>float</code> <p>Maximum pitch angle in degrees (default: 85).</p> <code>85.0</code> <code>access_token</code> <code>Optional[str]</code> <p>Mapbox access token. If None, reads from MAPBOX_TOKEN env var.</p> <code>None</code> <code>controls</code> <code>Optional[Dict[str, Any]]</code> <p>Dict of controls to add (e.g., {\"navigation\": True}).</p> <code>None</code> <code>**kwargs</code> <p>Additional widget arguments.</p> <code>{}</code> Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def __init__(\n    self,\n    center: Tuple[float, float] = (0.0, 0.0),\n    zoom: float = 2.0,\n    width: str = \"100%\",\n    height: str = \"600px\",\n    style: str = \"mapbox://styles/mapbox/streets-v12\",\n    bearing: float = 0.0,\n    pitch: float = 0.0,\n    max_pitch: float = 85.0,\n    access_token: Optional[str] = None,\n    controls: Optional[Dict[str, Any]] = None,\n    **kwargs,\n):\n    \"\"\"Initialize a Mapbox map.\n\n    Args:\n        center: Map center as (longitude, latitude).\n        zoom: Initial zoom level.\n        width: Map width as CSS string.\n        height: Map height as CSS string.\n        style: Mapbox style URL (e.g., \"mapbox://styles/mapbox/streets-v12\").\n        bearing: Map bearing in degrees.\n        pitch: Map pitch in degrees.\n        max_pitch: Maximum pitch angle in degrees (default: 85).\n        access_token: Mapbox access token. If None, reads from MAPBOX_TOKEN env var.\n        controls: Dict of controls to add (e.g., {\"navigation\": True}).\n        **kwargs: Additional widget arguments.\n    \"\"\"\n    # Get access token\n    token = access_token or get_mapbox_token()\n    if not token:\n        print(\n            \"Warning: No Mapbox access token provided. \"\n            \"Set MAPBOX_TOKEN environment variable or pass access_token parameter.\"\n        )\n\n    super().__init__(\n        center=list(center),\n        zoom=zoom,\n        width=width,\n        height=height,\n        style=style,\n        bearing=bearing,\n        pitch=pitch,\n        max_pitch=max_pitch,\n        access_token=token,\n        **kwargs,\n    )\n\n    # Initialize layer dictionary\n    self._layer_dict = {\"Background\": []}\n\n    # Add default controls\n    if controls is None:\n        controls = {\"navigation\": True, \"fullscreen\": True}\n\n    for control_name, config in controls.items():\n        if config:\n            self.add_control(\n                control_name, **(config if isinstance(config, dict) else {})\n            )\n</code></pre>"},{"location":"mapbox/#anymap_ts.mapbox.MapboxMap.add_arc_layer","title":"<code>add_arc_layer(self, data, name=None, get_source_position='source', get_target_position='target', get_source_color=None, get_target_color=None, get_width=1, get_height=1, great_circle=False, pickable=True, opacity=0.8, **kwargs)</code>","text":"<p>Add an arc layer for origin-destination visualization using deck.gl.</p> <p>Arc layers are ideal for visualizing connections between locations, such as flight routes, migration patterns, or network flows.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>Array of data objects with source/target coordinates. Each object should have source and target positions.</p> required <code>name</code> <code>Optional[str]</code> <p>Layer ID. If None, auto-generated.</p> <code>None</code> <code>get_source_position</code> <code>Union[str, Any]</code> <p>Accessor for source position [lng, lat]. Can be a string (property name) or a value.</p> <code>'source'</code> <code>get_target_position</code> <code>Union[str, Any]</code> <p>Accessor for target position [lng, lat]. Can be a string (property name) or a value.</p> <code>'target'</code> <code>get_source_color</code> <code>Optional[List[int]]</code> <p>Source end color as [r, g, b, a]. Default: [51, 136, 255, 255] (blue).</p> <code>None</code> <code>get_target_color</code> <code>Optional[List[int]]</code> <p>Target end color as [r, g, b, a]. Default: [255, 136, 51, 255] (orange).</p> <code>None</code> <code>get_width</code> <code>Union[float, str]</code> <p>Arc width in pixels. Can be a number or accessor.</p> <code>1</code> <code>get_height</code> <code>float</code> <p>Arc height multiplier. Higher values create more curved arcs.</p> <code>1</code> <code>great_circle</code> <code>bool</code> <p>Whether to draw arcs along great circles.</p> <code>False</code> <code>pickable</code> <code>bool</code> <p>Whether layer responds to hover/click events.</p> <code>True</code> <code>opacity</code> <code>float</code> <p>Layer opacity (0-1).</p> <code>0.8</code> <code>**kwargs</code> <p>Additional ArcLayer props.</p> <code>{}</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from anymap_ts import MapboxMap\n&gt;&gt;&gt; m = MapboxMap()\n&gt;&gt;&gt; arcs = [\n...     {\"source\": [-122.4, 37.8], \"target\": [-73.9, 40.7]},\n...     {\"source\": [-122.4, 37.8], \"target\": [-0.1, 51.5]},\n... ]\n&gt;&gt;&gt; m.add_arc_layer(arcs, name=\"flights\")\n</code></pre> Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def add_arc_layer(\n    self,\n    data: Any,\n    name: Optional[str] = None,\n    get_source_position: Union[str, Any] = \"source\",\n    get_target_position: Union[str, Any] = \"target\",\n    get_source_color: Optional[List[int]] = None,\n    get_target_color: Optional[List[int]] = None,\n    get_width: Union[float, str] = 1,\n    get_height: float = 1,\n    great_circle: bool = False,\n    pickable: bool = True,\n    opacity: float = 0.8,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add an arc layer for origin-destination visualization using deck.gl.\n\n    Arc layers are ideal for visualizing connections between locations,\n    such as flight routes, migration patterns, or network flows.\n\n    Args:\n        data: Array of data objects with source/target coordinates.\n            Each object should have source and target positions.\n        name: Layer ID. If None, auto-generated.\n        get_source_position: Accessor for source position [lng, lat].\n            Can be a string (property name) or a value.\n        get_target_position: Accessor for target position [lng, lat].\n            Can be a string (property name) or a value.\n        get_source_color: Source end color as [r, g, b, a].\n            Default: [51, 136, 255, 255] (blue).\n        get_target_color: Target end color as [r, g, b, a].\n            Default: [255, 136, 51, 255] (orange).\n        get_width: Arc width in pixels. Can be a number or accessor.\n        get_height: Arc height multiplier. Higher values create more curved arcs.\n        great_circle: Whether to draw arcs along great circles.\n        pickable: Whether layer responds to hover/click events.\n        opacity: Layer opacity (0-1).\n        **kwargs: Additional ArcLayer props.\n\n    Example:\n        &gt;&gt;&gt; from anymap_ts import MapboxMap\n        &gt;&gt;&gt; m = MapboxMap()\n        &gt;&gt;&gt; arcs = [\n        ...     {\"source\": [-122.4, 37.8], \"target\": [-73.9, 40.7]},\n        ...     {\"source\": [-122.4, 37.8], \"target\": [-0.1, 51.5]},\n        ... ]\n        &gt;&gt;&gt; m.add_arc_layer(arcs, name=\"flights\")\n    \"\"\"\n    layer_id = name or f\"arc-{len(self._layers)}\"\n    processed_data = self._process_deck_data(data)\n\n    self.call_js_method(\n        \"addArcLayer\",\n        id=layer_id,\n        data=processed_data,\n        getSourcePosition=get_source_position,\n        getTargetPosition=get_target_position,\n        getSourceColor=get_source_color or [51, 136, 255, 255],\n        getTargetColor=get_target_color or [255, 136, 51, 255],\n        getWidth=get_width,\n        getHeight=get_height,\n        greatCircle=great_circle,\n        pickable=pickable,\n        opacity=opacity,\n        **kwargs,\n    )\n\n    self._layers = {\n        **self._layers,\n        layer_id: {\n            \"id\": layer_id,\n            \"type\": \"arc\",\n        },\n    }\n</code></pre>"},{"location":"mapbox/#anymap_ts.mapbox.MapboxMap.add_basemap","title":"<code>add_basemap(self, basemap='mapbox://styles/mapbox/streets-v12', attribution=None, **kwargs)</code>","text":"<p>Add a basemap layer.</p> <p>For Mapbox styles, use the style URL format: - \"mapbox://styles/mapbox/streets-v12\" - \"mapbox://styles/mapbox/satellite-v9\" - \"mapbox://styles/mapbox/satellite-streets-v12\" - \"mapbox://styles/mapbox/light-v11\" - \"mapbox://styles/mapbox/dark-v11\" - \"mapbox://styles/mapbox/outdoors-v12\"</p> <p>Or use XYZ tile URLs for custom basemaps.</p> <p>Parameters:</p> Name Type Description Default <code>basemap</code> <code>str</code> <p>Mapbox style URL or XYZ tile URL.</p> <code>'mapbox://styles/mapbox/streets-v12'</code> <code>attribution</code> <code>Optional[str]</code> <p>Custom attribution text.</p> <code>None</code> <code>**kwargs</code> <p>Additional options.</p> <code>{}</code> Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def add_basemap(\n    self,\n    basemap: str = \"mapbox://styles/mapbox/streets-v12\",\n    attribution: Optional[str] = None,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a basemap layer.\n\n    For Mapbox styles, use the style URL format:\n    - \"mapbox://styles/mapbox/streets-v12\"\n    - \"mapbox://styles/mapbox/satellite-v9\"\n    - \"mapbox://styles/mapbox/satellite-streets-v12\"\n    - \"mapbox://styles/mapbox/light-v11\"\n    - \"mapbox://styles/mapbox/dark-v11\"\n    - \"mapbox://styles/mapbox/outdoors-v12\"\n\n    Or use XYZ tile URLs for custom basemaps.\n\n    Args:\n        basemap: Mapbox style URL or XYZ tile URL.\n        attribution: Custom attribution text.\n        **kwargs: Additional options.\n    \"\"\"\n    # If it's a Mapbox style URL, set it as the map style\n    if basemap.startswith(\"mapbox://\"):\n        self.style = basemap\n        return\n\n    # Otherwise, treat as XYZ tile URL\n    try:\n        url, default_attribution = get_basemap_url(basemap)\n    except (ValueError, KeyError):\n        url = basemap\n        default_attribution = \"\"\n\n    self.call_js_method(\n        \"addBasemap\",\n        url,\n        attribution=attribution or default_attribution,\n        name=basemap,\n        **kwargs,\n    )\n\n    # Track in layer dict\n    basemaps = self._layer_dict.get(\"Basemaps\", [])\n    if basemap not in basemaps:\n        self._layer_dict = {\n            **self._layer_dict,\n            \"Basemaps\": basemaps + [basemap],\n        }\n</code></pre>"},{"location":"mapbox/#anymap_ts.mapbox.MapboxMap.add_cog_layer","title":"<code>add_cog_layer(self, url, name=None, opacity=1.0, visible=True, debug=False, debug_opacity=0.25, max_error=0.125, fit_bounds=True, before_id=None, **kwargs)</code>","text":"<p>Add a Cloud Optimized GeoTIFF (COG) layer using deck.gl-raster.</p> <p>This method renders COG files directly in the browser using GPU-accelerated deck.gl rendering with automatic reprojection support.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>URL to the Cloud Optimized GeoTIFF file.</p> required <code>name</code> <code>Optional[str]</code> <p>Layer ID. If None, auto-generated.</p> <code>None</code> <code>opacity</code> <code>float</code> <p>Layer opacity (0-1).</p> <code>1.0</code> <code>visible</code> <code>bool</code> <p>Whether layer is visible.</p> <code>True</code> <code>debug</code> <code>bool</code> <p>Show reprojection mesh for debugging.</p> <code>False</code> <code>debug_opacity</code> <code>float</code> <p>Opacity of debug mesh (0-1).</p> <code>0.25</code> <code>max_error</code> <code>float</code> <p>Maximum reprojection error in pixels. Lower values create denser mesh for better accuracy.</p> <code>0.125</code> <code>fit_bounds</code> <code>bool</code> <p>Whether to fit map to COG bounds after loading.</p> <code>True</code> <code>before_id</code> <code>Optional[str]</code> <p>ID of layer to insert before.</p> <code>None</code> <code>**kwargs</code> <p>Additional COGLayer props.</p> <code>{}</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from anymap_ts import MapboxMap\n&gt;&gt;&gt; m = MapboxMap()\n&gt;&gt;&gt; m.add_cog_layer(\n...     \"https://example.com/landcover.tif\",\n...     name=\"landcover\",\n...     opacity=0.8\n... )\n</code></pre> Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def add_cog_layer(\n    self,\n    url: str,\n    name: Optional[str] = None,\n    opacity: float = 1.0,\n    visible: bool = True,\n    debug: bool = False,\n    debug_opacity: float = 0.25,\n    max_error: float = 0.125,\n    fit_bounds: bool = True,\n    before_id: Optional[str] = None,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a Cloud Optimized GeoTIFF (COG) layer using deck.gl-raster.\n\n    This method renders COG files directly in the browser using GPU-accelerated\n    deck.gl rendering with automatic reprojection support.\n\n    Args:\n        url: URL to the Cloud Optimized GeoTIFF file.\n        name: Layer ID. If None, auto-generated.\n        opacity: Layer opacity (0-1).\n        visible: Whether layer is visible.\n        debug: Show reprojection mesh for debugging.\n        debug_opacity: Opacity of debug mesh (0-1).\n        max_error: Maximum reprojection error in pixels. Lower values\n            create denser mesh for better accuracy.\n        fit_bounds: Whether to fit map to COG bounds after loading.\n        before_id: ID of layer to insert before.\n        **kwargs: Additional COGLayer props.\n\n    Example:\n        &gt;&gt;&gt; from anymap_ts import MapboxMap\n        &gt;&gt;&gt; m = MapboxMap()\n        &gt;&gt;&gt; m.add_cog_layer(\n        ...     \"https://example.com/landcover.tif\",\n        ...     name=\"landcover\",\n        ...     opacity=0.8\n        ... )\n    \"\"\"\n    layer_id = name or f\"cog-{len(self._layers)}\"\n\n    self.call_js_method(\n        \"addCOGLayer\",\n        id=layer_id,\n        geotiff=url,\n        opacity=opacity,\n        visible=visible,\n        debug=debug,\n        debugOpacity=debug_opacity,\n        maxError=max_error,\n        fitBounds=fit_bounds,\n        beforeId=before_id,\n        **kwargs,\n    )\n\n    self._layers = {\n        **self._layers,\n        layer_id: {\n            \"id\": layer_id,\n            \"type\": \"cog\",\n            \"url\": url,\n        },\n    }\n</code></pre>"},{"location":"mapbox/#anymap_ts.mapbox.MapboxMap.add_control","title":"<code>add_control(self, control_type, position='top-right', **kwargs)</code>","text":"<p>Add a map control.</p> <p>Parameters:</p> Name Type Description Default <code>control_type</code> <code>str</code> <p>Type of control ('navigation', 'scale', 'fullscreen', etc.).</p> required <code>position</code> <code>str</code> <p>Control position.</p> <code>'top-right'</code> <code>**kwargs</code> <p>Control-specific options.</p> <code>{}</code> Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def add_control(\n    self,\n    control_type: str,\n    position: str = \"top-right\",\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a map control.\n\n    Args:\n        control_type: Type of control ('navigation', 'scale', 'fullscreen', etc.).\n        position: Control position.\n        **kwargs: Control-specific options.\n    \"\"\"\n    self.call_js_method(\"addControl\", control_type, position=position, **kwargs)\n    self._controls = {\n        **self._controls,\n        control_type: {\"type\": control_type, \"position\": position, **kwargs},\n    }\n</code></pre>"},{"location":"mapbox/#anymap_ts.mapbox.MapboxMap.add_geojson","title":"<code>add_geojson(self, data, layer_type=None, paint=None, name=None, fit_bounds=True, **kwargs)</code>","text":"<p>Add GeoJSON data to the map.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Union[str, Dict]</code> <p>GeoJSON dict or URL to GeoJSON file.</p> required <code>layer_type</code> <code>Optional[str]</code> <p>Mapbox layer type.</p> <code>None</code> <code>paint</code> <code>Optional[Dict]</code> <p>Mapbox paint properties.</p> <code>None</code> <code>name</code> <code>Optional[str]</code> <p>Layer name.</p> <code>None</code> <code>fit_bounds</code> <code>bool</code> <p>Whether to fit map to data bounds.</p> <code>True</code> <code>**kwargs</code> <p>Additional layer options.</p> <code>{}</code> Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def add_geojson(\n    self,\n    data: Union[str, Dict],\n    layer_type: Optional[str] = None,\n    paint: Optional[Dict] = None,\n    name: Optional[str] = None,\n    fit_bounds: bool = True,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add GeoJSON data to the map.\n\n    Args:\n        data: GeoJSON dict or URL to GeoJSON file.\n        layer_type: Mapbox layer type.\n        paint: Mapbox paint properties.\n        name: Layer name.\n        fit_bounds: Whether to fit map to data bounds.\n        **kwargs: Additional layer options.\n    \"\"\"\n    self.add_vector(\n        data,\n        layer_type=layer_type,\n        paint=paint,\n        name=name,\n        fit_bounds=fit_bounds,\n        **kwargs,\n    )\n</code></pre>"},{"location":"mapbox/#anymap_ts.mapbox.MapboxMap.add_layer","title":"<code>add_layer(self, layer_id, layer_type, source, paint=None, layout=None, before_id=None, **kwargs)</code>","text":"<p>Add a generic layer to the map.</p> <p>Parameters:</p> Name Type Description Default <code>layer_id</code> <code>str</code> <p>Unique layer identifier.</p> required <code>layer_type</code> <code>str</code> <p>Mapbox layer type.</p> required <code>source</code> <code>Union[str, Dict]</code> <p>Source ID or source configuration dict.</p> required <code>paint</code> <code>Optional[Dict]</code> <p>Paint properties.</p> <code>None</code> <code>layout</code> <code>Optional[Dict]</code> <p>Layout properties.</p> <code>None</code> <code>before_id</code> <code>Optional[str]</code> <p>ID of layer to insert before.</p> <code>None</code> <code>**kwargs</code> <p>Additional layer options.</p> <code>{}</code> Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def add_layer(\n    self,\n    layer_id: str,\n    layer_type: str,\n    source: Union[str, Dict],\n    paint: Optional[Dict] = None,\n    layout: Optional[Dict] = None,\n    before_id: Optional[str] = None,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a generic layer to the map.\n\n    Args:\n        layer_id: Unique layer identifier.\n        layer_type: Mapbox layer type.\n        source: Source ID or source configuration dict.\n        paint: Paint properties.\n        layout: Layout properties.\n        before_id: ID of layer to insert before.\n        **kwargs: Additional layer options.\n    \"\"\"\n    layer_config = {\n        \"id\": layer_id,\n        \"type\": layer_type,\n        \"paint\": paint or {},\n        \"layout\": layout or {},\n        **kwargs,\n    }\n\n    if isinstance(source, str):\n        layer_config[\"source\"] = source\n    else:\n        source_id = f\"{layer_id}-source\"\n        self._sources = {**self._sources, source_id: source}\n        self.call_js_method(\"addSource\", source_id, **source)\n        layer_config[\"source\"] = source_id\n\n    self._layers = {**self._layers, layer_id: layer_config}\n    self.call_js_method(\"addLayer\", beforeId=before_id, **layer_config)\n</code></pre>"},{"location":"mapbox/#anymap_ts.mapbox.MapboxMap.add_lidar_control","title":"<code>add_lidar_control(self, position='top-right', collapsed=True, title='LiDAR Viewer', point_size=2, opacity=1.0, color_scheme='elevation', use_percentile=True, point_budget=1000000, pickable=False, auto_zoom=True, copc_loading_mode=None, streaming_point_budget=5000000, **kwargs)</code>","text":"<p>Add an interactive LiDAR control panel.</p> <p>The LiDAR control provides a UI panel for loading, visualizing, and styling LiDAR point cloud files (LAS, LAZ, COPC formats).</p> <p>Parameters:</p> Name Type Description Default <code>position</code> <code>str</code> <p>Control position ('top-left', 'top-right', 'bottom-left', 'bottom-right').</p> <code>'top-right'</code> <code>collapsed</code> <code>bool</code> <p>Whether the panel starts collapsed.</p> <code>True</code> <code>title</code> <code>str</code> <p>Title displayed on the panel.</p> <code>'LiDAR Viewer'</code> <code>point_size</code> <code>float</code> <p>Point size in pixels.</p> <code>2</code> <code>opacity</code> <code>float</code> <p>Layer opacity (0-1).</p> <code>1.0</code> <code>color_scheme</code> <code>str</code> <p>Color scheme ('elevation', 'intensity', 'classification', 'rgb').</p> <code>'elevation'</code> <code>use_percentile</code> <code>bool</code> <p>Use 2-98% percentile for color scaling.</p> <code>True</code> <code>point_budget</code> <code>int</code> <p>Maximum number of points to display.</p> <code>1000000</code> <code>pickable</code> <code>bool</code> <p>Enable hover/click interactions.</p> <code>False</code> <code>auto_zoom</code> <code>bool</code> <p>Auto-zoom to point cloud after loading.</p> <code>True</code> <code>copc_loading_mode</code> <code>Optional[str]</code> <p>COPC loading mode ('full' or 'dynamic').</p> <code>None</code> <code>streaming_point_budget</code> <code>int</code> <p>Point budget for streaming mode.</p> <code>5000000</code> <code>**kwargs</code> <p>Additional control options.</p> <code>{}</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from anymap_ts import MapboxMap\n&gt;&gt;&gt; m = MapboxMap(pitch=60)\n&gt;&gt;&gt; m.add_lidar_control(color_scheme=\"classification\", pickable=True)\n</code></pre> Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def add_lidar_control(\n    self,\n    position: str = \"top-right\",\n    collapsed: bool = True,\n    title: str = \"LiDAR Viewer\",\n    point_size: float = 2,\n    opacity: float = 1.0,\n    color_scheme: str = \"elevation\",\n    use_percentile: bool = True,\n    point_budget: int = 1000000,\n    pickable: bool = False,\n    auto_zoom: bool = True,\n    copc_loading_mode: Optional[str] = None,\n    streaming_point_budget: int = 5000000,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add an interactive LiDAR control panel.\n\n    The LiDAR control provides a UI panel for loading, visualizing, and\n    styling LiDAR point cloud files (LAS, LAZ, COPC formats).\n\n    Args:\n        position: Control position ('top-left', 'top-right', 'bottom-left', 'bottom-right').\n        collapsed: Whether the panel starts collapsed.\n        title: Title displayed on the panel.\n        point_size: Point size in pixels.\n        opacity: Layer opacity (0-1).\n        color_scheme: Color scheme ('elevation', 'intensity', 'classification', 'rgb').\n        use_percentile: Use 2-98% percentile for color scaling.\n        point_budget: Maximum number of points to display.\n        pickable: Enable hover/click interactions.\n        auto_zoom: Auto-zoom to point cloud after loading.\n        copc_loading_mode: COPC loading mode ('full' or 'dynamic').\n        streaming_point_budget: Point budget for streaming mode.\n        **kwargs: Additional control options.\n\n    Example:\n        &gt;&gt;&gt; from anymap_ts import MapboxMap\n        &gt;&gt;&gt; m = MapboxMap(pitch=60)\n        &gt;&gt;&gt; m.add_lidar_control(color_scheme=\"classification\", pickable=True)\n    \"\"\"\n    self.call_js_method(\n        \"addLidarControl\",\n        position=position,\n        collapsed=collapsed,\n        title=title,\n        pointSize=point_size,\n        opacity=opacity,\n        colorScheme=color_scheme,\n        usePercentile=use_percentile,\n        pointBudget=point_budget,\n        pickable=pickable,\n        autoZoom=auto_zoom,\n        copcLoadingMode=copc_loading_mode,\n        streamingPointBudget=streaming_point_budget,\n        **kwargs,\n    )\n    self._controls = {\n        **self._controls,\n        \"lidar-control\": {\"position\": position, \"collapsed\": collapsed},\n    }\n</code></pre>"},{"location":"mapbox/#anymap_ts.mapbox.MapboxMap.add_lidar_layer","title":"<code>add_lidar_layer(self, source, name=None, color_scheme='elevation', point_size=2, opacity=1.0, pickable=True, auto_zoom=True, streaming_mode=True, point_budget=1000000, **kwargs)</code>","text":"<p>Load and display a LiDAR file from URL or local path.</p> <p>Supports LAS, LAZ, and COPC (Cloud-Optimized Point Cloud) formats. For local files, the file is read and sent as base64 to JavaScript. For URLs, the data is loaded directly via streaming when possible.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>Union[str, Path]</code> <p>URL or local file path to the LiDAR file.</p> required <code>name</code> <code>Optional[str]</code> <p>Layer identifier. If None, auto-generated.</p> <code>None</code> <code>color_scheme</code> <code>str</code> <p>Color scheme ('elevation', 'intensity', 'classification', 'rgb').</p> <code>'elevation'</code> <code>point_size</code> <code>float</code> <p>Point size in pixels.</p> <code>2</code> <code>opacity</code> <code>float</code> <p>Layer opacity (0-1).</p> <code>1.0</code> <code>pickable</code> <code>bool</code> <p>Enable hover/click interactions.</p> <code>True</code> <code>auto_zoom</code> <code>bool</code> <p>Auto-zoom to point cloud after loading.</p> <code>True</code> <code>streaming_mode</code> <code>bool</code> <p>Use streaming mode for large COPC files.</p> <code>True</code> <code>point_budget</code> <code>int</code> <p>Maximum number of points to display.</p> <code>1000000</code> <code>**kwargs</code> <p>Additional layer options.</p> <code>{}</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from anymap_ts import MapboxMap\n&gt;&gt;&gt; m = MapboxMap(center=[-123.07, 44.05], zoom=14, pitch=60)\n&gt;&gt;&gt; m.add_lidar_layer(\n...     source=\"https://s3.amazonaws.com/hobu-lidar/autzen-classified.copc.laz\",\n...     name=\"autzen\",\n...     color_scheme=\"classification\",\n... )\n</code></pre> Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def add_lidar_layer(\n    self,\n    source: Union[str, Path],\n    name: Optional[str] = None,\n    color_scheme: str = \"elevation\",\n    point_size: float = 2,\n    opacity: float = 1.0,\n    pickable: bool = True,\n    auto_zoom: bool = True,\n    streaming_mode: bool = True,\n    point_budget: int = 1000000,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Load and display a LiDAR file from URL or local path.\n\n    Supports LAS, LAZ, and COPC (Cloud-Optimized Point Cloud) formats.\n    For local files, the file is read and sent as base64 to JavaScript.\n    For URLs, the data is loaded directly via streaming when possible.\n\n    Args:\n        source: URL or local file path to the LiDAR file.\n        name: Layer identifier. If None, auto-generated.\n        color_scheme: Color scheme ('elevation', 'intensity', 'classification', 'rgb').\n        point_size: Point size in pixels.\n        opacity: Layer opacity (0-1).\n        pickable: Enable hover/click interactions.\n        auto_zoom: Auto-zoom to point cloud after loading.\n        streaming_mode: Use streaming mode for large COPC files.\n        point_budget: Maximum number of points to display.\n        **kwargs: Additional layer options.\n\n    Example:\n        &gt;&gt;&gt; from anymap_ts import MapboxMap\n        &gt;&gt;&gt; m = MapboxMap(center=[-123.07, 44.05], zoom=14, pitch=60)\n        &gt;&gt;&gt; m.add_lidar_layer(\n        ...     source=\"https://s3.amazonaws.com/hobu-lidar/autzen-classified.copc.laz\",\n        ...     name=\"autzen\",\n        ...     color_scheme=\"classification\",\n        ... )\n    \"\"\"\n    import base64\n\n    layer_id = name or f\"lidar-{len(self._layers)}\"\n\n    # Check if source is a local file\n    source_path = Path(source) if isinstance(source, (str, Path)) else None\n    is_local = source_path is not None and source_path.exists()\n\n    if is_local:\n        # Read local file and encode as base64\n        with open(source_path, \"rb\") as f:\n            file_data = f.read()\n        source_b64 = base64.b64encode(file_data).decode(\"utf-8\")\n\n        self.call_js_method(\n            \"addLidarLayer\",\n            source=source_b64,\n            name=layer_id,\n            isBase64=True,\n            filename=source_path.name,\n            colorScheme=color_scheme,\n            pointSize=point_size,\n            opacity=opacity,\n            pickable=pickable,\n            autoZoom=auto_zoom,\n            streamingMode=streaming_mode,\n            pointBudget=point_budget,\n            **kwargs,\n        )\n    else:\n        # Load from URL\n        self.call_js_method(\n            \"addLidarLayer\",\n            source=str(source),\n            name=layer_id,\n            isBase64=False,\n            colorScheme=color_scheme,\n            pointSize=point_size,\n            opacity=opacity,\n            pickable=pickable,\n            autoZoom=auto_zoom,\n            streamingMode=streaming_mode,\n            pointBudget=point_budget,\n            **kwargs,\n        )\n\n    self._layers = {\n        **self._layers,\n        layer_id: {\n            \"id\": layer_id,\n            \"type\": \"lidar\",\n            \"source\": str(source),\n        },\n    }\n</code></pre>"},{"location":"mapbox/#anymap_ts.mapbox.MapboxMap.add_marker","title":"<code>add_marker(self, lng, lat, color='#3388ff', popup=None, marker_id=None)</code>","text":"<p>Add a marker to the map.</p> <p>Parameters:</p> Name Type Description Default <code>lng</code> <code>float</code> <p>Longitude.</p> required <code>lat</code> <code>float</code> <p>Latitude.</p> required <code>color</code> <code>str</code> <p>Marker color.</p> <code>'#3388ff'</code> <code>popup</code> <code>Optional[str]</code> <p>HTML content for popup.</p> <code>None</code> <code>marker_id</code> <code>Optional[str]</code> <p>Unique marker ID.</p> <code>None</code> Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def add_marker(\n    self,\n    lng: float,\n    lat: float,\n    color: str = \"#3388ff\",\n    popup: Optional[str] = None,\n    marker_id: Optional[str] = None,\n) -&gt; None:\n    \"\"\"Add a marker to the map.\n\n    Args:\n        lng: Longitude.\n        lat: Latitude.\n        color: Marker color.\n        popup: HTML content for popup.\n        marker_id: Unique marker ID.\n    \"\"\"\n    self.call_js_method(\n        \"addMarker\", lng, lat, color=color, popup=popup, id=marker_id\n    )\n</code></pre>"},{"location":"mapbox/#anymap_ts.mapbox.MapboxMap.add_point_cloud_layer","title":"<code>add_point_cloud_layer(self, data, name=None, get_position='position', get_color=None, get_normal=None, point_size=2, size_units='pixels', pickable=True, opacity=1.0, material=True, coordinate_system=None, coordinate_origin=None, **kwargs)</code>","text":"<p>Add a point cloud layer for 3D point visualization using deck.gl.</p> <p>Point cloud layers render large collections of 3D points, ideal for LiDAR data, photogrammetry outputs, or any 3D point dataset.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>Array of point data with positions. Each point should have x, y, z coordinates (or position array).</p> required <code>name</code> <code>Optional[str]</code> <p>Layer ID. If None, auto-generated.</p> <code>None</code> <code>get_position</code> <code>Union[str, Any]</code> <p>Accessor for point position [x, y, z]. Can be a string (property name) or a value.</p> <code>'position'</code> <code>get_color</code> <code>Optional[Union[List[int], str]]</code> <p>Accessor or value for point color [r, g, b, a]. Default: [255, 255, 255, 255] (white).</p> <code>None</code> <code>get_normal</code> <code>Optional[Union[str, Any]]</code> <p>Accessor for point normal [nx, ny, nz] for lighting. Default: [0, 0, 1] (pointing up).</p> <code>None</code> <code>point_size</code> <code>float</code> <p>Point size in pixels or meters (depends on size_units).</p> <code>2</code> <code>size_units</code> <code>str</code> <p>Size units: 'pixels', 'meters', or 'common'.</p> <code>'pixels'</code> <code>pickable</code> <code>bool</code> <p>Whether layer responds to hover/click events.</p> <code>True</code> <code>opacity</code> <code>float</code> <p>Layer opacity (0-1).</p> <code>1.0</code> <code>material</code> <code>bool</code> <p>Whether to enable lighting effects.</p> <code>True</code> <code>coordinate_system</code> <code>Optional[int]</code> <p>Coordinate system for positions.</p> <code>None</code> <code>coordinate_origin</code> <code>Optional[List[float]]</code> <p>Origin for coordinate system [x, y, z].</p> <code>None</code> <code>**kwargs</code> <p>Additional PointCloudLayer props.</p> <code>{}</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from anymap_ts import MapboxMap\n&gt;&gt;&gt; m = MapboxMap(pitch=45)\n&gt;&gt;&gt; points = [\n...     {\"position\": [-122.4, 37.8, 100], \"color\": [255, 0, 0, 255]},\n...     {\"position\": [-122.3, 37.7, 200], \"color\": [0, 255, 0, 255]},\n... ]\n&gt;&gt;&gt; m.add_point_cloud_layer(points, point_size=5)\n</code></pre> Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def add_point_cloud_layer(\n    self,\n    data: Any,\n    name: Optional[str] = None,\n    get_position: Union[str, Any] = \"position\",\n    get_color: Optional[Union[List[int], str]] = None,\n    get_normal: Optional[Union[str, Any]] = None,\n    point_size: float = 2,\n    size_units: str = \"pixels\",\n    pickable: bool = True,\n    opacity: float = 1.0,\n    material: bool = True,\n    coordinate_system: Optional[int] = None,\n    coordinate_origin: Optional[List[float]] = None,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a point cloud layer for 3D point visualization using deck.gl.\n\n    Point cloud layers render large collections of 3D points, ideal for\n    LiDAR data, photogrammetry outputs, or any 3D point dataset.\n\n    Args:\n        data: Array of point data with positions. Each point should have\n            x, y, z coordinates (or position array).\n        name: Layer ID. If None, auto-generated.\n        get_position: Accessor for point position [x, y, z].\n            Can be a string (property name) or a value.\n        get_color: Accessor or value for point color [r, g, b, a].\n            Default: [255, 255, 255, 255] (white).\n        get_normal: Accessor for point normal [nx, ny, nz] for lighting.\n            Default: [0, 0, 1] (pointing up).\n        point_size: Point size in pixels or meters (depends on size_units).\n        size_units: Size units: 'pixels', 'meters', or 'common'.\n        pickable: Whether layer responds to hover/click events.\n        opacity: Layer opacity (0-1).\n        material: Whether to enable lighting effects.\n        coordinate_system: Coordinate system for positions.\n        coordinate_origin: Origin for coordinate system [x, y, z].\n        **kwargs: Additional PointCloudLayer props.\n\n    Example:\n        &gt;&gt;&gt; from anymap_ts import MapboxMap\n        &gt;&gt;&gt; m = MapboxMap(pitch=45)\n        &gt;&gt;&gt; points = [\n        ...     {\"position\": [-122.4, 37.8, 100], \"color\": [255, 0, 0, 255]},\n        ...     {\"position\": [-122.3, 37.7, 200], \"color\": [0, 255, 0, 255]},\n        ... ]\n        &gt;&gt;&gt; m.add_point_cloud_layer(points, point_size=5)\n    \"\"\"\n    layer_id = name or f\"pointcloud-{len(self._layers)}\"\n    processed_data = self._process_deck_data(data)\n\n    self.call_js_method(\n        \"addPointCloudLayer\",\n        id=layer_id,\n        data=processed_data,\n        getPosition=get_position,\n        getColor=get_color or [255, 255, 255, 255],\n        getNormal=get_normal,\n        pointSize=point_size,\n        sizeUnits=size_units,\n        pickable=pickable,\n        opacity=opacity,\n        material=material,\n        coordinateSystem=coordinate_system,\n        coordinateOrigin=coordinate_origin,\n        **kwargs,\n    )\n\n    self._layers = {\n        **self._layers,\n        layer_id: {\n            \"id\": layer_id,\n            \"type\": \"pointcloud\",\n        },\n    }\n</code></pre>"},{"location":"mapbox/#anymap_ts.mapbox.MapboxMap.add_terrain","title":"<code>add_terrain(self, exaggeration=1.0, source='mapbox-dem')</code>","text":"<p>Add 3D terrain to the map.</p> <p>Parameters:</p> Name Type Description Default <code>exaggeration</code> <code>float</code> <p>Terrain exaggeration factor.</p> <code>1.0</code> <code>source</code> <code>str</code> <p>Terrain source ID.</p> <code>'mapbox-dem'</code> Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def add_terrain(\n    self, exaggeration: float = 1.0, source: str = \"mapbox-dem\"\n) -&gt; None:\n    \"\"\"Add 3D terrain to the map.\n\n    Args:\n        exaggeration: Terrain exaggeration factor.\n        source: Terrain source ID.\n    \"\"\"\n    self.call_js_method(\"addTerrain\", source=source, exaggeration=exaggeration)\n</code></pre>"},{"location":"mapbox/#anymap_ts.mapbox.MapboxMap.add_tile_layer","title":"<code>add_tile_layer(self, url, name=None, attribution='', min_zoom=0, max_zoom=22, **kwargs)</code>","text":"<p>Add an XYZ tile layer.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>Tile URL template with {x}, {y}, {z} placeholders.</p> required <code>name</code> <code>Optional[str]</code> <p>Layer name.</p> <code>None</code> <code>attribution</code> <code>str</code> <p>Attribution text.</p> <code>''</code> <code>min_zoom</code> <code>int</code> <p>Minimum zoom level.</p> <code>0</code> <code>max_zoom</code> <code>int</code> <p>Maximum zoom level.</p> <code>22</code> <code>**kwargs</code> <p>Additional options.</p> <code>{}</code> Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def add_tile_layer(\n    self,\n    url: str,\n    name: Optional[str] = None,\n    attribution: str = \"\",\n    min_zoom: int = 0,\n    max_zoom: int = 22,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add an XYZ tile layer.\n\n    Args:\n        url: Tile URL template with {x}, {y}, {z} placeholders.\n        name: Layer name.\n        attribution: Attribution text.\n        min_zoom: Minimum zoom level.\n        max_zoom: Maximum zoom level.\n        **kwargs: Additional options.\n    \"\"\"\n    layer_id = name or f\"tiles-{len(self._layers)}\"\n\n    self.call_js_method(\n        \"addTileLayer\",\n        url,\n        name=layer_id,\n        attribution=attribution,\n        minZoom=min_zoom,\n        maxZoom=max_zoom,\n        **kwargs,\n    )\n\n    # Track layer\n    self._layers = {\n        **self._layers,\n        layer_id: {\n            \"id\": layer_id,\n            \"type\": \"raster\",\n            \"source\": f\"{layer_id}-source\",\n        },\n    }\n</code></pre>"},{"location":"mapbox/#anymap_ts.mapbox.MapboxMap.add_vector","title":"<code>add_vector(self, data, layer_type=None, paint=None, name=None, fit_bounds=True, **kwargs)</code>","text":"<p>Add vector data to the map.</p> <p>Supports GeoJSON, GeoDataFrame, or file paths to vector formats.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>GeoJSON dict, GeoDataFrame, or path to vector file.</p> required <code>layer_type</code> <code>Optional[str]</code> <p>Mapbox layer type ('circle', 'line', 'fill', 'symbol').</p> <code>None</code> <code>paint</code> <code>Optional[Dict]</code> <p>Mapbox paint properties.</p> <code>None</code> <code>name</code> <code>Optional[str]</code> <p>Layer name.</p> <code>None</code> <code>fit_bounds</code> <code>bool</code> <p>Whether to fit map to data bounds.</p> <code>True</code> <code>**kwargs</code> <p>Additional layer options.</p> <code>{}</code> Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def add_vector(\n    self,\n    data: Any,\n    layer_type: Optional[str] = None,\n    paint: Optional[Dict] = None,\n    name: Optional[str] = None,\n    fit_bounds: bool = True,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add vector data to the map.\n\n    Supports GeoJSON, GeoDataFrame, or file paths to vector formats.\n\n    Args:\n        data: GeoJSON dict, GeoDataFrame, or path to vector file.\n        layer_type: Mapbox layer type ('circle', 'line', 'fill', 'symbol').\n        paint: Mapbox paint properties.\n        name: Layer name.\n        fit_bounds: Whether to fit map to data bounds.\n        **kwargs: Additional layer options.\n    \"\"\"\n    geojson = to_geojson(data)\n\n    # Handle URL data\n    if geojson.get(\"type\") == \"url\":\n        self.add_geojson(\n            geojson[\"url\"],\n            layer_type=layer_type,\n            paint=paint,\n            name=name,\n            fit_bounds=fit_bounds,\n            **kwargs,\n        )\n        return\n\n    layer_id = name or f\"vector-{len(self._layers)}\"\n\n    # Infer layer type if not specified\n    if layer_type is None:\n        layer_type = infer_layer_type(geojson)\n\n    # Get default paint if not provided\n    if paint is None:\n        paint = get_default_paint(layer_type)\n\n    # Get bounds\n    bounds = get_bounds(data) if fit_bounds else None\n\n    # Call JavaScript\n    self.call_js_method(\n        \"addGeoJSON\",\n        data=geojson,\n        name=layer_id,\n        layerType=layer_type,\n        paint=paint,\n        fitBounds=fit_bounds,\n        bounds=bounds,\n        **kwargs,\n    )\n\n    # Track layer\n    self._layers = {\n        **self._layers,\n        layer_id: {\n            \"id\": layer_id,\n            \"type\": layer_type,\n            \"source\": f\"{layer_id}-source\",\n            \"paint\": paint,\n        },\n    }\n</code></pre>"},{"location":"mapbox/#anymap_ts.mapbox.MapboxMap.remove_arc_layer","title":"<code>remove_arc_layer(self, layer_id)</code>","text":"<p>Remove an arc layer.</p> <p>Parameters:</p> Name Type Description Default <code>layer_id</code> <code>str</code> <p>Layer identifier to remove.</p> required Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def remove_arc_layer(self, layer_id: str) -&gt; None:\n    \"\"\"Remove an arc layer.\n\n    Args:\n        layer_id: Layer identifier to remove.\n    \"\"\"\n    if layer_id in self._layers:\n        layers = dict(self._layers)\n        del layers[layer_id]\n        self._layers = layers\n    self.call_js_method(\"removeArcLayer\", layer_id)\n</code></pre>"},{"location":"mapbox/#anymap_ts.mapbox.MapboxMap.remove_cog_layer","title":"<code>remove_cog_layer(self, layer_id)</code>","text":"<p>Remove a COG layer.</p> <p>Parameters:</p> Name Type Description Default <code>layer_id</code> <code>str</code> <p>Layer identifier to remove.</p> required Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def remove_cog_layer(self, layer_id: str) -&gt; None:\n    \"\"\"Remove a COG layer.\n\n    Args:\n        layer_id: Layer identifier to remove.\n    \"\"\"\n    if layer_id in self._layers:\n        layers = dict(self._layers)\n        del layers[layer_id]\n        self._layers = layers\n    self.call_js_method(\"removeCOGLayer\", layer_id)\n</code></pre>"},{"location":"mapbox/#anymap_ts.mapbox.MapboxMap.remove_control","title":"<code>remove_control(self, control_type)</code>","text":"<p>Remove a map control.</p> <p>Parameters:</p> Name Type Description Default <code>control_type</code> <code>str</code> <p>Type of control to remove.</p> required Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def remove_control(self, control_type: str) -&gt; None:\n    \"\"\"Remove a map control.\n\n    Args:\n        control_type: Type of control to remove.\n    \"\"\"\n    self.call_js_method(\"removeControl\", control_type)\n    if control_type in self._controls:\n        controls = dict(self._controls)\n        del controls[control_type]\n        self._controls = controls\n</code></pre>"},{"location":"mapbox/#anymap_ts.mapbox.MapboxMap.remove_layer","title":"<code>remove_layer(self, layer_id)</code>","text":"<p>Remove a layer from the map.</p> <p>Parameters:</p> Name Type Description Default <code>layer_id</code> <code>str</code> <p>Layer identifier to remove.</p> required Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def remove_layer(self, layer_id: str) -&gt; None:\n    \"\"\"Remove a layer from the map.\n\n    Args:\n        layer_id: Layer identifier to remove.\n    \"\"\"\n    if layer_id in self._layers:\n        layers = dict(self._layers)\n        del layers[layer_id]\n        self._layers = layers\n    self.call_js_method(\"removeLayer\", layer_id)\n</code></pre>"},{"location":"mapbox/#anymap_ts.mapbox.MapboxMap.remove_lidar_layer","title":"<code>remove_lidar_layer(self, layer_id=None)</code>","text":"<p>Remove a LiDAR layer.</p> <p>Parameters:</p> Name Type Description Default <code>layer_id</code> <code>Optional[str]</code> <p>Layer identifier to remove. If None, removes all LiDAR layers.</p> <code>None</code> Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def remove_lidar_layer(self, layer_id: Optional[str] = None) -&gt; None:\n    \"\"\"Remove a LiDAR layer.\n\n    Args:\n        layer_id: Layer identifier to remove. If None, removes all LiDAR layers.\n    \"\"\"\n    if layer_id:\n        if layer_id in self._layers:\n            layers = dict(self._layers)\n            del layers[layer_id]\n            self._layers = layers\n        self.call_js_method(\"removeLidarLayer\", id=layer_id)\n    else:\n        # Remove all lidar layers\n        layers = dict(self._layers)\n        self._layers = {k: v for k, v in layers.items() if v.get(\"type\") != \"lidar\"}\n        self.call_js_method(\"removeLidarLayer\")\n</code></pre>"},{"location":"mapbox/#anymap_ts.mapbox.MapboxMap.remove_marker","title":"<code>remove_marker(self, marker_id)</code>","text":"<p>Remove a marker from the map.</p> <p>Parameters:</p> Name Type Description Default <code>marker_id</code> <code>str</code> <p>Marker ID to remove.</p> required Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def remove_marker(self, marker_id: str) -&gt; None:\n    \"\"\"Remove a marker from the map.\n\n    Args:\n        marker_id: Marker ID to remove.\n    \"\"\"\n    self.call_js_method(\"removeMarker\", marker_id)\n</code></pre>"},{"location":"mapbox/#anymap_ts.mapbox.MapboxMap.remove_point_cloud_layer","title":"<code>remove_point_cloud_layer(self, layer_id)</code>","text":"<p>Remove a point cloud layer.</p> <p>Parameters:</p> Name Type Description Default <code>layer_id</code> <code>str</code> <p>Layer identifier to remove.</p> required Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def remove_point_cloud_layer(self, layer_id: str) -&gt; None:\n    \"\"\"Remove a point cloud layer.\n\n    Args:\n        layer_id: Layer identifier to remove.\n    \"\"\"\n    if layer_id in self._layers:\n        layers = dict(self._layers)\n        del layers[layer_id]\n        self._layers = layers\n    self.call_js_method(\"removePointCloudLayer\", layer_id)\n</code></pre>"},{"location":"mapbox/#anymap_ts.mapbox.MapboxMap.remove_terrain","title":"<code>remove_terrain(self)</code>","text":"<p>Remove 3D terrain from the map.</p> Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def remove_terrain(self) -&gt; None:\n    \"\"\"Remove 3D terrain from the map.\"\"\"\n    self.call_js_method(\"removeTerrain\")\n</code></pre>"},{"location":"mapbox/#anymap_ts.mapbox.MapboxMap.set_access_token","title":"<code>set_access_token(self, token)</code>","text":"<p>Set the Mapbox access token.</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>str</code> <p>Mapbox access token.</p> required Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def set_access_token(self, token: str) -&gt; None:\n    \"\"\"Set the Mapbox access token.\n\n    Args:\n        token: Mapbox access token.\n    \"\"\"\n    self.access_token = token\n</code></pre>"},{"location":"mapbox/#anymap_ts.mapbox.MapboxMap.set_lidar_color_scheme","title":"<code>set_lidar_color_scheme(self, color_scheme)</code>","text":"<p>Set the LiDAR color scheme.</p> <p>Parameters:</p> Name Type Description Default <code>color_scheme</code> <code>str</code> <p>Color scheme ('elevation', 'intensity', 'classification', 'rgb').</p> required Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def set_lidar_color_scheme(self, color_scheme: str) -&gt; None:\n    \"\"\"Set the LiDAR color scheme.\n\n    Args:\n        color_scheme: Color scheme ('elevation', 'intensity', 'classification', 'rgb').\n    \"\"\"\n    self.call_js_method(\"setLidarColorScheme\", colorScheme=color_scheme)\n</code></pre>"},{"location":"mapbox/#anymap_ts.mapbox.MapboxMap.set_lidar_opacity","title":"<code>set_lidar_opacity(self, opacity)</code>","text":"<p>Set the LiDAR layer opacity.</p> <p>Parameters:</p> Name Type Description Default <code>opacity</code> <code>float</code> <p>Opacity value between 0 and 1.</p> required Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def set_lidar_opacity(self, opacity: float) -&gt; None:\n    \"\"\"Set the LiDAR layer opacity.\n\n    Args:\n        opacity: Opacity value between 0 and 1.\n    \"\"\"\n    self.call_js_method(\"setLidarOpacity\", opacity=opacity)\n</code></pre>"},{"location":"mapbox/#anymap_ts.mapbox.MapboxMap.set_lidar_point_size","title":"<code>set_lidar_point_size(self, point_size)</code>","text":"<p>Set the LiDAR point size.</p> <p>Parameters:</p> Name Type Description Default <code>point_size</code> <code>float</code> <p>Point size in pixels.</p> required Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def set_lidar_point_size(self, point_size: float) -&gt; None:\n    \"\"\"Set the LiDAR point size.\n\n    Args:\n        point_size: Point size in pixels.\n    \"\"\"\n    self.call_js_method(\"setLidarPointSize\", pointSize=point_size)\n</code></pre>"},{"location":"mapbox/#anymap_ts.mapbox.MapboxMap.set_opacity","title":"<code>set_opacity(self, layer_id, opacity)</code>","text":"<p>Set layer opacity.</p> <p>Parameters:</p> Name Type Description Default <code>layer_id</code> <code>str</code> <p>Layer identifier.</p> required <code>opacity</code> <code>float</code> <p>Opacity value between 0 and 1.</p> required Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def set_opacity(self, layer_id: str, opacity: float) -&gt; None:\n    \"\"\"Set layer opacity.\n\n    Args:\n        layer_id: Layer identifier.\n        opacity: Opacity value between 0 and 1.\n    \"\"\"\n    self.call_js_method(\"setOpacity\", layer_id, opacity)\n</code></pre>"},{"location":"mapbox/#anymap_ts.mapbox.MapboxMap.set_visibility","title":"<code>set_visibility(self, layer_id, visible)</code>","text":"<p>Set layer visibility.</p> <p>Parameters:</p> Name Type Description Default <code>layer_id</code> <code>str</code> <p>Layer identifier.</p> required <code>visible</code> <code>bool</code> <p>Whether layer should be visible.</p> required Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def set_visibility(self, layer_id: str, visible: bool) -&gt; None:\n    \"\"\"Set layer visibility.\n\n    Args:\n        layer_id: Layer identifier.\n        visible: Whether layer should be visible.\n    \"\"\"\n    self.call_js_method(\"setVisibility\", layer_id, visible)\n</code></pre>"},{"location":"mapbox/#anymap_ts.mapbox.get_mapbox_token","title":"<code>get_mapbox_token()</code>","text":"<p>Get Mapbox access token from environment variable.</p> <p>Returns:</p> Type Description <code>str</code> <p>Mapbox access token string, or empty string if not set.</p> Source code in <code>anymap_ts/mapbox.py</code> <pre><code>def get_mapbox_token() -&gt; str:\n    \"\"\"Get Mapbox access token from environment variable.\n\n    Returns:\n        Mapbox access token string, or empty string if not set.\n    \"\"\"\n    return os.environ.get(\"MAPBOX_TOKEN\", \"\")\n</code></pre>"},{"location":"maplibre/","title":"maplibre module","text":"<p>MapLibre GL JS map widget implementation.</p>"},{"location":"maplibre/#anymap_ts.maplibre.MapLibreMap","title":"<code> MapLibreMap            (MapWidget)         </code>","text":"<p>Interactive map widget using MapLibre GL JS.</p> <p>This class provides a Python interface to MapLibre GL JS maps with full bidirectional communication through anywidget.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from anymap_ts import Map\n&gt;&gt;&gt; m = Map(center=[-122.4, 37.8], zoom=10)\n&gt;&gt;&gt; m.add_basemap(\"OpenStreetMap\")\n&gt;&gt;&gt; m\n</code></pre> Source code in <code>anymap_ts/maplibre.py</code> <pre><code>class MapLibreMap(MapWidget):\n    \"\"\"Interactive map widget using MapLibre GL JS.\n\n    This class provides a Python interface to MapLibre GL JS maps with\n    full bidirectional communication through anywidget.\n\n    Example:\n        &gt;&gt;&gt; from anymap_ts import Map\n        &gt;&gt;&gt; m = Map(center=[-122.4, 37.8], zoom=10)\n        &gt;&gt;&gt; m.add_basemap(\"OpenStreetMap\")\n        &gt;&gt;&gt; m\n    \"\"\"\n\n    # ESM module for frontend\n    _esm = STATIC_DIR / \"maplibre.js\"\n    _css = STATIC_DIR / \"maplibre.css\"\n\n    # MapLibre-specific traits\n    bearing = traitlets.Float(0.0).tag(sync=True)\n    pitch = traitlets.Float(0.0).tag(sync=True)\n    antialias = traitlets.Bool(True).tag(sync=True)\n    double_click_zoom = traitlets.Bool(True).tag(sync=True)\n\n    # Layer tracking\n    _layer_dict = traitlets.Dict({}).tag(sync=True)\n\n    def __init__(\n        self,\n        center: Tuple[float, float] = (0.0, 0.0),\n        zoom: float = 2.0,\n        width: str = \"100%\",\n        height: str = \"700px\",\n        style: Union[\n            str, Dict\n        ] = \"https://basemaps.cartocdn.com/gl/positron-gl-style/style.json\",\n        bearing: float = 0.0,\n        pitch: float = 0.0,\n        max_pitch: float = 85.0,\n        controls: Optional[Dict[str, Any]] = None,\n        **kwargs,\n    ):\n        \"\"\"Initialize a MapLibre map.\n\n        Args:\n            center: Map center as (longitude, latitude).\n            zoom: Initial zoom level.\n            width: Map width as CSS string.\n            height: Map height as CSS string. Default is \"700px\".\n            style: MapLibre style URL or style object. Default is \"https://basemaps.cartocdn.com/gl/positron-gl-style/style.json\".\n            bearing: Map bearing in degrees.\n            pitch: Map pitch in degrees.\n            max_pitch: Maximum pitch angle in degrees (default: 85).\n            controls: Dict of controls to add. If None, defaults to\n                {\"layer-control\": True, \"control-grid\": True}.\n                Use {\"layer-control\": {\"collapsed\": True}} for custom options.\n            **kwargs: Additional widget arguments.\n        \"\"\"\n        # Handle style shortcuts\n        if isinstance(style, str) and not style.startswith(\"http\"):\n            try:\n                style = get_maplibre_style(style)\n            except ValueError:\n                pass  # Use as-is\n\n        super().__init__(\n            center=list(center),\n            zoom=zoom,\n            width=width,\n            height=height,\n            style=style,\n            bearing=bearing,\n            pitch=pitch,\n            max_pitch=max_pitch,\n            **kwargs,\n        )\n\n        # Initialize layer dictionary\n        self._layer_dict = {\"Background\": []}\n\n        # Add default controls\n        if controls is None:\n            controls = {\n                \"layer-control\": True,\n                \"control-grid\": True,\n            }\n\n        for control_name, config in controls.items():\n            if config:\n                if control_name == \"layer-control\":\n                    self.add_layer_control(\n                        **(config if isinstance(config, dict) else {})\n                    )\n                elif control_name == \"control-grid\":\n                    self.add_control_grid(\n                        **(config if isinstance(config, dict) else {})\n                    )\n                else:\n                    self.add_control(\n                        control_name, **(config if isinstance(config, dict) else {})\n                    )\n\n    # -------------------------------------------------------------------------\n    # Basemap Methods\n    # -------------------------------------------------------------------------\n\n    def add_basemap(\n        self,\n        basemap: str = \"OpenStreetMap\",\n        attribution: Optional[str] = None,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a basemap layer.\n\n        Args:\n            basemap: Name of basemap provider (e.g., \"OpenStreetMap\", \"CartoDB.Positron\")\n            attribution: Custom attribution text\n            **kwargs: Additional options\n        \"\"\"\n        url, default_attribution = get_basemap_url(basemap)\n        self.call_js_method(\n            \"addBasemap\",\n            url,\n            attribution=attribution or default_attribution,\n            name=basemap,\n            **kwargs,\n        )\n\n        # Track in layer dict\n        basemaps = self._layer_dict.get(\"Basemaps\", [])\n        if basemap not in basemaps:\n            self._layer_dict = {\n                **self._layer_dict,\n                \"Basemaps\": basemaps + [basemap],\n            }\n\n    # -------------------------------------------------------------------------\n    # Vector Data Methods\n    # -------------------------------------------------------------------------\n\n    def add_vector(\n        self,\n        data: Any,\n        layer_type: Optional[str] = None,\n        paint: Optional[Dict] = None,\n        name: Optional[str] = None,\n        fit_bounds: bool = True,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add vector data to the map.\n\n        Supports GeoJSON, GeoDataFrame, or file paths to vector formats.\n\n        Args:\n            data: GeoJSON dict, GeoDataFrame, or path to vector file\n            layer_type: MapLibre layer type ('circle', 'line', 'fill', 'symbol')\n            paint: MapLibre paint properties\n            name: Layer name\n            fit_bounds: Whether to fit map to data bounds\n            **kwargs: Additional layer options\n        \"\"\"\n        geojson = to_geojson(data)\n\n        # Handle URL data\n        if geojson.get(\"type\") == \"url\":\n            self.add_geojson(\n                geojson[\"url\"],\n                layer_type=layer_type,\n                paint=paint,\n                name=name,\n                fit_bounds=fit_bounds,\n                **kwargs,\n            )\n            return\n\n        layer_id = name or f\"vector-{len(self._layers)}\"\n\n        # Infer layer type if not specified\n        if layer_type is None:\n            layer_type = infer_layer_type(geojson)\n\n        # Get default paint if not provided\n        if paint is None:\n            paint = get_default_paint(layer_type)\n\n        # Get bounds\n        bounds = get_bounds(data) if fit_bounds else None\n\n        # Call JavaScript\n        self.call_js_method(\n            \"addGeoJSON\",\n            data=geojson,\n            name=layer_id,\n            layerType=layer_type,\n            paint=paint,\n            fitBounds=fit_bounds,\n            bounds=bounds,\n            **kwargs,\n        )\n\n        # Track layer\n        self._layers = {\n            **self._layers,\n            layer_id: {\n                \"id\": layer_id,\n                \"type\": layer_type,\n                \"source\": f\"{layer_id}-source\",\n                \"paint\": paint,\n            },\n        }\n\n    def add_geojson(\n        self,\n        data: Union[str, Dict],\n        layer_type: Optional[str] = None,\n        paint: Optional[Dict] = None,\n        name: Optional[str] = None,\n        fit_bounds: bool = True,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add GeoJSON data to the map.\n\n        Args:\n            data: GeoJSON dict or URL to GeoJSON file\n            layer_type: MapLibre layer type\n            paint: MapLibre paint properties\n            name: Layer name\n            fit_bounds: Whether to fit map to data bounds\n            **kwargs: Additional layer options\n        \"\"\"\n        self.add_vector(\n            data,\n            layer_type=layer_type,\n            paint=paint,\n            name=name,\n            fit_bounds=fit_bounds,\n            **kwargs,\n        )\n\n    # -------------------------------------------------------------------------\n    # Raster Data Methods\n    # -------------------------------------------------------------------------\n\n    def add_raster(\n        self,\n        source: str,\n        name: Optional[str] = None,\n        attribution: str = \"\",\n        indexes: Optional[List[int]] = None,\n        colormap: Optional[str] = None,\n        vmin: Optional[float] = None,\n        vmax: Optional[float] = None,\n        nodata: Optional[float] = None,\n        fit_bounds: bool = True,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a raster layer from a local file using localtileserver.\n\n        Args:\n            source: Path to local raster file\n            name: Layer name\n            attribution: Attribution text\n            indexes: Band indexes to use\n            colormap: Colormap name\n            vmin: Minimum value for colormap\n            vmax: Maximum value for colormap\n            nodata: NoData value\n            fit_bounds: Whether to fit map to raster bounds\n            **kwargs: Additional options\n        \"\"\"\n        try:\n            from localtileserver import TileClient\n        except ImportError:\n            raise ImportError(\n                \"localtileserver is required for local raster support. \"\n                \"Install with: pip install anymap-ts[raster]\"\n            )\n\n        client = TileClient(source)\n\n        # Build tile URL with parameters\n        tile_url = client.get_tile_url()\n        if indexes:\n            tile_url = client.get_tile_url(indexes=indexes)\n        if colormap:\n            tile_url = client.get_tile_url(colormap=colormap)\n        if vmin is not None or vmax is not None:\n            tile_url = client.get_tile_url(\n                vmin=vmin or client.min, vmax=vmax or client.max\n            )\n        if nodata is not None:\n            tile_url = client.get_tile_url(nodata=nodata)\n\n        layer_name = name or Path(source).stem\n\n        self.add_tile_layer(\n            tile_url,\n            name=layer_name,\n            attribution=attribution,\n            **kwargs,\n        )\n\n        # Fit bounds if requested\n        if fit_bounds:\n            bounds = client.bounds()\n            if bounds:\n                self.fit_bounds([bounds[0], bounds[1], bounds[2], bounds[3]])\n\n    def add_tile_layer(\n        self,\n        url: str,\n        name: Optional[str] = None,\n        attribution: str = \"\",\n        min_zoom: int = 0,\n        max_zoom: int = 22,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add an XYZ tile layer.\n\n        Args:\n            url: Tile URL template with {x}, {y}, {z} placeholders\n            name: Layer name\n            attribution: Attribution text\n            min_zoom: Minimum zoom level\n            max_zoom: Maximum zoom level\n            **kwargs: Additional options\n        \"\"\"\n        layer_id = name or f\"tiles-{len(self._layers)}\"\n\n        self.call_js_method(\n            \"addTileLayer\",\n            url,\n            name=layer_id,\n            attribution=attribution,\n            minZoom=min_zoom,\n            maxZoom=max_zoom,\n            **kwargs,\n        )\n\n        # Track layer\n        self._layers = {\n            **self._layers,\n            layer_id: {\n                \"id\": layer_id,\n                \"type\": \"raster\",\n                \"source\": f\"{layer_id}-source\",\n            },\n        }\n\n    # -------------------------------------------------------------------------\n    # COG Layer (deck.gl)\n    # -------------------------------------------------------------------------\n\n    def add_cog_layer(\n        self,\n        url: str,\n        name: Optional[str] = None,\n        opacity: float = 1.0,\n        visible: bool = True,\n        debug: bool = False,\n        debug_opacity: float = 0.25,\n        max_error: float = 0.125,\n        fit_bounds: bool = True,\n        before_id: Optional[str] = None,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a Cloud Optimized GeoTIFF (COG) layer using @developmentseed/deck.gl-geotiff.\n\n        This method renders COG files directly in the browser using GPU-accelerated\n        deck.gl-geotiff rendering with automatic reprojection support.\n\n        Args:\n            url: URL to the Cloud Optimized GeoTIFF file.\n            name: Layer ID. If None, auto-generated.\n            opacity: Layer opacity (0-1).\n            visible: Whether layer is visible.\n            debug: Show reprojection mesh for debugging.\n            debug_opacity: Opacity of debug mesh (0-1).\n            max_error: Maximum reprojection error in pixels. Lower values\n                create denser mesh for better accuracy.\n            fit_bounds: Whether to fit map to COG bounds after loading.\n            before_id: ID of layer to insert before.\n            **kwargs: Additional COGLayer props.\n\n        Example:\n            &gt;&gt;&gt; from anymap_ts import Map\n            &gt;&gt;&gt; m = Map()\n            &gt;&gt;&gt; m.add_cog_layer(\n            ...     \"https://example.com/landcover.tif\",\n            ...     name=\"landcover\",\n            ...     opacity=0.8\n            ... )\n        \"\"\"\n        layer_id = name or f\"cog-{len(self._layers)}\"\n\n        self.call_js_method(\n            \"addCOGLayer\",\n            id=layer_id,\n            geotiff=url,\n            opacity=opacity,\n            visible=visible,\n            debug=debug,\n            debugOpacity=debug_opacity,\n            maxError=max_error,\n            fitBounds=fit_bounds,\n            beforeId=before_id,\n            **kwargs,\n        )\n\n        self._layers = {\n            **self._layers,\n            layer_id: {\n                \"id\": layer_id,\n                \"type\": \"cog\",\n                \"url\": url,\n            },\n        }\n\n    def remove_cog_layer(self, layer_id: str) -&gt; None:\n        \"\"\"Remove a COG layer.\n\n        Args:\n            layer_id: Layer identifier to remove.\n        \"\"\"\n        if layer_id in self._layers:\n            layers = dict(self._layers)\n            del layers[layer_id]\n            self._layers = layers\n        self.call_js_method(\"removeCOGLayer\", layer_id)\n\n    # -------------------------------------------------------------------------\n    # Zarr Layer (@carbonplan/zarr-layer)\n    # -------------------------------------------------------------------------\n\n    def add_zarr_layer(\n        self,\n        url: str,\n        variable: str,\n        name: Optional[str] = None,\n        colormap: Optional[List[str]] = None,\n        clim: Optional[Tuple[float, float]] = None,\n        opacity: float = 1.0,\n        selector: Optional[Dict[str, Any]] = None,\n        minzoom: int = 0,\n        maxzoom: int = 22,\n        fill_value: Optional[float] = None,\n        spatial_dimensions: Optional[Dict[str, str]] = None,\n        zarr_version: Optional[int] = None,\n        bounds: Optional[List[float]] = None,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a Zarr dataset layer for visualizing multidimensional array data.\n\n        This method renders Zarr pyramid datasets directly in the browser using\n        GPU-accelerated WebGL rendering via @carbonplan/zarr-layer.\n\n        Args:\n            url: URL to the Zarr store (pyramid format recommended).\n            variable: Variable name in the Zarr dataset to visualize.\n            name: Layer ID. If None, auto-generated.\n            colormap: List of hex color strings for visualization.\n                Example: ['#0000ff', '#ffff00', '#ff0000'] (blue-yellow-red).\n                Default: ['#000000', '#ffffff'] (black to white).\n            clim: Color range as (min, max) tuple.\n                Default: (0, 100).\n            opacity: Layer opacity (0-1).\n            selector: Dimension selector for multi-dimensional data.\n                Example: {\"month\": 4} to select 4th month.\n            minzoom: Minimum zoom level for rendering.\n            maxzoom: Maximum zoom level for rendering.\n            fill_value: No-data value (auto-detected from metadata if not set).\n            spatial_dimensions: Custom spatial dimension names.\n                Example: {\"lat\": \"y\", \"lon\": \"x\"} for non-standard names.\n            zarr_version: Zarr format version (2 or 3). Auto-detected if not set.\n            bounds: Explicit spatial bounds [xMin, yMin, xMax, yMax].\n                Units depend on CRS: degrees for EPSG:4326, meters for EPSG:3857.\n            **kwargs: Additional ZarrLayer props.\n\n        Example:\n            &gt;&gt;&gt; from anymap_ts import Map\n            &gt;&gt;&gt; m = Map()\n            &gt;&gt;&gt; m.add_zarr_layer(\n            ...     \"https://example.com/climate.zarr\",\n            ...     variable=\"temperature\",\n            ...     clim=(270, 310),\n            ...     colormap=['#0000ff', '#ffff00', '#ff0000'],\n            ...     selector={\"month\": 7}\n            ... )\n        \"\"\"\n        layer_id = name or f\"zarr-{len(self._layers)}\"\n\n        self.call_js_method(\n            \"addZarrLayer\",\n            id=layer_id,\n            source=url,\n            variable=variable,\n            colormap=colormap or [\"#000000\", \"#ffffff\"],\n            clim=list(clim) if clim else [0, 100],\n            opacity=opacity,\n            selector=selector or {},\n            minzoom=minzoom,\n            maxzoom=maxzoom,\n            fillValue=fill_value,\n            spatialDimensions=spatial_dimensions,\n            zarrVersion=zarr_version,\n            bounds=bounds,\n            **kwargs,\n        )\n\n        self._layers = {\n            **self._layers,\n            layer_id: {\n                \"id\": layer_id,\n                \"type\": \"zarr\",\n                \"url\": url,\n                \"variable\": variable,\n            },\n        }\n\n    def remove_zarr_layer(self, layer_id: str) -&gt; None:\n        \"\"\"Remove a Zarr layer.\n\n        Args:\n            layer_id: Layer identifier to remove.\n        \"\"\"\n        if layer_id in self._layers:\n            layers = dict(self._layers)\n            del layers[layer_id]\n            self._layers = layers\n        self.call_js_method(\"removeZarrLayer\", layer_id)\n\n    def update_zarr_layer(\n        self,\n        layer_id: str,\n        selector: Optional[Dict[str, Any]] = None,\n        clim: Optional[Tuple[float, float]] = None,\n        colormap: Optional[List[str]] = None,\n        opacity: Optional[float] = None,\n    ) -&gt; None:\n        \"\"\"Update a Zarr layer's properties dynamically.\n\n        Args:\n            layer_id: Layer identifier.\n            selector: New dimension selector.\n            clim: New color range.\n            colormap: New colormap.\n            opacity: New opacity value (0-1).\n        \"\"\"\n        update_kwargs: Dict[str, Any] = {\"id\": layer_id}\n        if selector is not None:\n            update_kwargs[\"selector\"] = selector\n        if clim is not None:\n            update_kwargs[\"clim\"] = list(clim)\n        if colormap is not None:\n            update_kwargs[\"colormap\"] = colormap\n        if opacity is not None:\n            update_kwargs[\"opacity\"] = opacity\n        self.call_js_method(\"updateZarrLayer\", **update_kwargs)\n\n    # -------------------------------------------------------------------------\n    # Arc Layer (deck.gl)\n    # -------------------------------------------------------------------------\n\n    def add_arc_layer(\n        self,\n        data: Any,\n        name: Optional[str] = None,\n        get_source_position: Union[str, Any] = \"source\",\n        get_target_position: Union[str, Any] = \"target\",\n        get_source_color: Optional[List[int]] = None,\n        get_target_color: Optional[List[int]] = None,\n        get_width: Union[float, str] = 1,\n        get_height: float = 1,\n        great_circle: bool = False,\n        pickable: bool = True,\n        opacity: float = 0.8,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add an arc layer for origin-destination visualization using deck.gl.\n\n        Arc layers are ideal for visualizing connections between locations,\n        such as flight routes, migration patterns, or network flows.\n\n        Args:\n            data: Array of data objects with source/target coordinates.\n                Each object should have source and target positions.\n            name: Layer ID. If None, auto-generated.\n            get_source_position: Accessor for source position [lng, lat].\n                Can be a string (property name) or a value.\n            get_target_position: Accessor for target position [lng, lat].\n                Can be a string (property name) or a value.\n            get_source_color: Source end color as [r, g, b, a].\n                Default: [51, 136, 255, 255] (blue).\n            get_target_color: Target end color as [r, g, b, a].\n                Default: [255, 136, 51, 255] (orange).\n            get_width: Arc width in pixels. Can be a number or accessor.\n            get_height: Arc height multiplier. Higher values create more curved arcs.\n            great_circle: Whether to draw arcs along great circles.\n            pickable: Whether layer responds to hover/click events.\n            opacity: Layer opacity (0-1).\n            **kwargs: Additional ArcLayer props.\n\n        Example:\n            &gt;&gt;&gt; from anymap_ts import MapLibreMap\n            &gt;&gt;&gt; m = MapLibreMap()\n            &gt;&gt;&gt; arcs = [\n            ...     {\"source\": [-122.4, 37.8], \"target\": [-73.9, 40.7]},\n            ...     {\"source\": [-122.4, 37.8], \"target\": [-0.1, 51.5]},\n            ... ]\n            &gt;&gt;&gt; m.add_arc_layer(arcs, name=\"flights\")\n        \"\"\"\n        layer_id = name or f\"arc-{len(self._layers)}\"\n        processed_data = self._process_deck_data(data)\n\n        self.call_js_method(\n            \"addArcLayer\",\n            id=layer_id,\n            data=processed_data,\n            getSourcePosition=get_source_position,\n            getTargetPosition=get_target_position,\n            getSourceColor=get_source_color or [51, 136, 255, 255],\n            getTargetColor=get_target_color or [255, 136, 51, 255],\n            getWidth=get_width,\n            getHeight=get_height,\n            greatCircle=great_circle,\n            pickable=pickable,\n            opacity=opacity,\n            **kwargs,\n        )\n\n        self._layers = {\n            **self._layers,\n            layer_id: {\n                \"id\": layer_id,\n                \"type\": \"arc\",\n            },\n        }\n\n    def remove_arc_layer(self, layer_id: str) -&gt; None:\n        \"\"\"Remove an arc layer.\n\n        Args:\n            layer_id: Layer identifier to remove.\n        \"\"\"\n        if layer_id in self._layers:\n            layers = dict(self._layers)\n            del layers[layer_id]\n            self._layers = layers\n        self.call_js_method(\"removeArcLayer\", layer_id)\n\n    # -------------------------------------------------------------------------\n    # PointCloud Layer (deck.gl)\n    # -------------------------------------------------------------------------\n\n    def add_point_cloud_layer(\n        self,\n        data: Any,\n        name: Optional[str] = None,\n        get_position: Union[str, Any] = \"position\",\n        get_color: Optional[Union[List[int], str]] = None,\n        get_normal: Optional[Union[str, Any]] = None,\n        point_size: float = 2,\n        size_units: str = \"pixels\",\n        pickable: bool = True,\n        opacity: float = 1.0,\n        material: bool = True,\n        coordinate_system: Optional[int] = None,\n        coordinate_origin: Optional[List[float]] = None,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a point cloud layer for 3D point visualization using deck.gl.\n\n        Point cloud layers render large collections of 3D points, ideal for\n        LiDAR data, photogrammetry outputs, or any 3D point dataset.\n\n        Args:\n            data: Array of point data with positions. Each point should have\n                x, y, z coordinates (or position array).\n            name: Layer ID. If None, auto-generated.\n            get_position: Accessor for point position [x, y, z].\n                Can be a string (property name) or a value.\n            get_color: Accessor or value for point color [r, g, b, a].\n                Default: [255, 255, 255, 255] (white).\n            get_normal: Accessor for point normal [nx, ny, nz] for lighting.\n                Default: [0, 0, 1] (pointing up).\n            point_size: Point size in pixels or meters (depends on size_units).\n            size_units: Size units: 'pixels', 'meters', or 'common'.\n            pickable: Whether layer responds to hover/click events.\n            opacity: Layer opacity (0-1).\n            material: Whether to enable lighting effects.\n            coordinate_system: Coordinate system for positions.\n            coordinate_origin: Origin for coordinate system [x, y, z].\n            **kwargs: Additional PointCloudLayer props.\n\n        Example:\n            &gt;&gt;&gt; from anymap_ts import MapLibreMap\n            &gt;&gt;&gt; import numpy as np\n            &gt;&gt;&gt; m = MapLibreMap(pitch=45)\n            &gt;&gt;&gt; points = [\n            ...     {\"position\": [-122.4, 37.8, 100], \"color\": [255, 0, 0, 255]},\n            ...     {\"position\": [-122.3, 37.7, 200], \"color\": [0, 255, 0, 255]},\n            ... ]\n            &gt;&gt;&gt; m.add_point_cloud_layer(points, point_size=5)\n        \"\"\"\n        layer_id = name or f\"pointcloud-{len(self._layers)}\"\n        processed_data = self._process_deck_data(data)\n\n        self.call_js_method(\n            \"addPointCloudLayer\",\n            id=layer_id,\n            data=processed_data,\n            getPosition=get_position,\n            getColor=get_color or [255, 255, 255, 255],\n            getNormal=get_normal,\n            pointSize=point_size,\n            sizeUnits=size_units,\n            pickable=pickable,\n            opacity=opacity,\n            material=material,\n            coordinateSystem=coordinate_system,\n            coordinateOrigin=coordinate_origin,\n            **kwargs,\n        )\n\n        self._layers = {\n            **self._layers,\n            layer_id: {\n                \"id\": layer_id,\n                \"type\": \"pointcloud\",\n            },\n        }\n\n    def remove_point_cloud_layer(self, layer_id: str) -&gt; None:\n        \"\"\"Remove a point cloud layer.\n\n        Args:\n            layer_id: Layer identifier to remove.\n        \"\"\"\n        if layer_id in self._layers:\n            layers = dict(self._layers)\n            del layers[layer_id]\n            self._layers = layers\n        self.call_js_method(\"removePointCloudLayer\", layer_id)\n\n    # -------------------------------------------------------------------------\n    # LiDAR Layers (maplibre-gl-lidar)\n    # -------------------------------------------------------------------------\n\n    def add_lidar_control(\n        self,\n        position: str = \"top-right\",\n        collapsed: bool = True,\n        title: str = \"LiDAR Viewer\",\n        point_size: float = 2,\n        opacity: float = 1.0,\n        color_scheme: str = \"elevation\",\n        use_percentile: bool = True,\n        point_budget: int = 1000000,\n        pickable: bool = False,\n        auto_zoom: bool = True,\n        copc_loading_mode: Optional[str] = None,\n        streaming_point_budget: int = 5000000,\n        panel_max_height: int = 600,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add an interactive LiDAR control panel.\n\n        The LiDAR control provides a UI panel for loading, visualizing, and\n        styling LiDAR point cloud files (LAS, LAZ, COPC formats).\n\n        Args:\n            position: Control position ('top-left', 'top-right', 'bottom-left', 'bottom-right').\n            collapsed: Whether the panel starts collapsed.\n            title: Title displayed on the panel.\n            point_size: Point size in pixels.\n            opacity: Layer opacity (0-1).\n            color_scheme: Color scheme ('elevation', 'intensity', 'classification', 'rgb').\n            use_percentile: Use 2-98% percentile for color scaling.\n            point_budget: Maximum number of points to display.\n            pickable: Enable hover/click interactions.\n            auto_zoom: Auto-zoom to point cloud after loading.\n            copc_loading_mode: COPC loading mode ('full' or 'dynamic').\n            streaming_point_budget: Point budget for streaming mode.\n            panel_max_height: Maximum height of the panel in pixels.\n            **kwargs: Additional control options.\n\n        Example:\n            &gt;&gt;&gt; from anymap_ts import MapLibreMap\n            &gt;&gt;&gt; m = MapLibreMap(pitch=60)\n            &gt;&gt;&gt; m.add_lidar_control(color_scheme=\"classification\", pickable=True)\n        \"\"\"\n        self.call_js_method(\n            \"addLidarControl\",\n            position=position,\n            collapsed=collapsed,\n            title=title,\n            pointSize=point_size,\n            opacity=opacity,\n            colorScheme=color_scheme,\n            usePercentile=use_percentile,\n            pointBudget=point_budget,\n            pickable=pickable,\n            autoZoom=auto_zoom,\n            copcLoadingMode=copc_loading_mode,\n            streamingPointBudget=streaming_point_budget,\n            panelMaxHeight=panel_max_height,\n            **kwargs,\n        )\n        self._controls = {\n            **self._controls,\n            \"lidar-control\": {\"position\": position, \"collapsed\": collapsed},\n        }\n\n    def add_lidar_layer(\n        self,\n        source: Union[str, Path],\n        name: Optional[str] = None,\n        color_scheme: str = \"elevation\",\n        point_size: float = 2,\n        opacity: float = 1.0,\n        pickable: bool = True,\n        auto_zoom: bool = True,\n        streaming_mode: bool = True,\n        point_budget: int = 1000000,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Load and display a LiDAR file from URL or local path.\n\n        Supports LAS, LAZ, and COPC (Cloud-Optimized Point Cloud) formats.\n        For local files, the file is read and sent as base64 to JavaScript.\n        For URLs, the data is loaded directly via streaming when possible.\n\n        Args:\n            source: URL or local file path to the LiDAR file.\n            name: Layer identifier. If None, auto-generated.\n            color_scheme: Color scheme ('elevation', 'intensity', 'classification', 'rgb').\n            point_size: Point size in pixels.\n            opacity: Layer opacity (0-1).\n            pickable: Enable hover/click interactions.\n            auto_zoom: Auto-zoom to point cloud after loading.\n            streaming_mode: Use streaming mode for large COPC files.\n            point_budget: Maximum number of points to display.\n            **kwargs: Additional layer options.\n\n        Example:\n            &gt;&gt;&gt; from anymap_ts import MapLibreMap\n            &gt;&gt;&gt; m = MapLibreMap(center=[-123.07, 44.05], zoom=14, pitch=60)\n            &gt;&gt;&gt; m.add_lidar_layer(\n            ...     source=\"https://s3.amazonaws.com/hobu-lidar/autzen-classified.copc.laz\",\n            ...     name=\"autzen\",\n            ...     color_scheme=\"classification\",\n            ... )\n        \"\"\"\n        layer_id = name or f\"lidar-{len(self._layers)}\"\n\n        # Check if source is a local file\n        source_path = Path(source) if isinstance(source, (str, Path)) else None\n        is_local = source_path is not None and source_path.exists()\n\n        if is_local:\n            # Read local file and encode as base64\n            import base64\n\n            with open(source_path, \"rb\") as f:\n                file_data = f.read()\n            source_b64 = base64.b64encode(file_data).decode(\"utf-8\")\n\n            self.call_js_method(\n                \"addLidarLayer\",\n                source=source_b64,\n                name=layer_id,\n                isBase64=True,\n                filename=source_path.name,\n                colorScheme=color_scheme,\n                pointSize=point_size,\n                opacity=opacity,\n                pickable=pickable,\n                autoZoom=auto_zoom,\n                streamingMode=streaming_mode,\n                pointBudget=point_budget,\n                **kwargs,\n            )\n        else:\n            # Load from URL\n            self.call_js_method(\n                \"addLidarLayer\",\n                source=str(source),\n                name=layer_id,\n                isBase64=False,\n                colorScheme=color_scheme,\n                pointSize=point_size,\n                opacity=opacity,\n                pickable=pickable,\n                autoZoom=auto_zoom,\n                streamingMode=streaming_mode,\n                pointBudget=point_budget,\n                **kwargs,\n            )\n\n        self._layers = {\n            **self._layers,\n            layer_id: {\n                \"id\": layer_id,\n                \"type\": \"lidar\",\n                \"source\": str(source),\n            },\n        }\n\n    def remove_lidar_layer(self, layer_id: Optional[str] = None) -&gt; None:\n        \"\"\"Remove a LiDAR layer.\n\n        Args:\n            layer_id: Layer identifier to remove. If None, removes all LiDAR layers.\n        \"\"\"\n        if layer_id:\n            if layer_id in self._layers:\n                layers = dict(self._layers)\n                del layers[layer_id]\n                self._layers = layers\n            self.call_js_method(\"removeLidarLayer\", id=layer_id)\n        else:\n            # Remove all lidar layers\n            layers = dict(self._layers)\n            self._layers = {k: v for k, v in layers.items() if v.get(\"type\") != \"lidar\"}\n            self.call_js_method(\"removeLidarLayer\")\n\n    def set_lidar_color_scheme(self, color_scheme: str) -&gt; None:\n        \"\"\"Set the LiDAR color scheme.\n\n        Args:\n            color_scheme: Color scheme ('elevation', 'intensity', 'classification', 'rgb').\n        \"\"\"\n        self.call_js_method(\"setLidarColorScheme\", colorScheme=color_scheme)\n\n    def set_lidar_point_size(self, point_size: float) -&gt; None:\n        \"\"\"Set the LiDAR point size.\n\n        Args:\n            point_size: Point size in pixels.\n        \"\"\"\n        self.call_js_method(\"setLidarPointSize\", pointSize=point_size)\n\n    def set_lidar_opacity(self, opacity: float) -&gt; None:\n        \"\"\"Set the LiDAR layer opacity.\n\n        Args:\n            opacity: Opacity value between 0 and 1.\n        \"\"\"\n        self.call_js_method(\"setLidarOpacity\", opacity=opacity)\n\n    # -------------------------------------------------------------------------\n    # maplibre-gl-components UI Controls\n    # -------------------------------------------------------------------------\n\n    def add_pmtiles_control(\n        self,\n        position: str = \"top-right\",\n        collapsed: bool = True,\n        default_url: Optional[str] = None,\n        load_default_url: bool = False,\n        default_opacity: float = 1.0,\n        default_fill_color: str = \"steelblue\",\n        default_line_color: str = \"#333\",\n        default_pickable: bool = True,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a PMTiles layer control for loading PMTiles files via UI.\n\n        This provides an interactive panel for users to enter PMTiles URLs\n        and visualize vector or raster tile data.\n\n        Args:\n            position: Control position ('top-left', 'top-right', 'bottom-left', 'bottom-right').\n            collapsed: Whether the panel starts collapsed.\n            default_url: Default PMTiles URL to pre-fill.\n            load_default_url: Whether to auto-load the default URL.\n            default_opacity: Default layer opacity (0-1).\n            default_fill_color: Default fill color for vector polygons.\n            default_line_color: Default line color for vector lines.\n            default_pickable: Whether features are clickable by default.\n            **kwargs: Additional control options.\n\n        Example:\n            &gt;&gt;&gt; from anymap_ts import MapLibreMap\n            &gt;&gt;&gt; m = MapLibreMap()\n            &gt;&gt;&gt; m.add_pmtiles_control(\n            ...     default_url=\"https://pmtiles.io/protomaps(vector)ODbL_firenze.pmtiles\",\n            ...     load_default_url=True\n            ... )\n        \"\"\"\n        self.call_js_method(\n            \"addPMTilesControl\",\n            position=position,\n            collapsed=collapsed,\n            defaultUrl=default_url or \"\",\n            loadDefaultUrl=load_default_url,\n            defaultOpacity=default_opacity,\n            defaultFillColor=default_fill_color,\n            defaultLineColor=default_line_color,\n            defaultPickable=default_pickable,\n            **kwargs,\n        )\n        self._controls = {\n            **self._controls,\n            \"pmtiles-control\": {\"position\": position, \"collapsed\": collapsed},\n        }\n\n    def add_cog_control(\n        self,\n        position: str = \"top-right\",\n        collapsed: bool = True,\n        default_url: Optional[str] = None,\n        load_default_url: bool = False,\n        default_opacity: float = 1.0,\n        default_colormap: str = \"viridis\",\n        default_bands: str = \"1\",\n        default_rescale_min: float = 0,\n        default_rescale_max: float = 255,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a COG layer control for loading Cloud Optimized GeoTIFFs via UI.\n\n        This provides an interactive panel for users to enter COG URLs\n        and configure visualization parameters like colormap and rescaling.\n\n        Args:\n            position: Control position ('top-left', 'top-right', 'bottom-left', 'bottom-right').\n            collapsed: Whether the panel starts collapsed.\n            default_url: Default COG URL to pre-fill.\n            load_default_url: Whether to auto-load the default URL.\n            default_opacity: Default layer opacity (0-1).\n            default_colormap: Default colormap name.\n            default_bands: Default bands (e.g., '1' or '1,2,3').\n            default_rescale_min: Default minimum value for rescaling.\n            default_rescale_max: Default maximum value for rescaling.\n            **kwargs: Additional control options.\n\n        Example:\n            &gt;&gt;&gt; from anymap_ts import MapLibreMap\n            &gt;&gt;&gt; m = MapLibreMap()\n            &gt;&gt;&gt; m.add_cog_control(\n            ...     default_url=\"https://example.com/cog.tif\",\n            ...     default_colormap=\"terrain\"\n            ... )\n        \"\"\"\n        self.call_js_method(\n            \"addCogControl\",\n            position=position,\n            collapsed=collapsed,\n            defaultUrl=default_url or \"\",\n            loadDefaultUrl=load_default_url,\n            defaultOpacity=default_opacity,\n            defaultColormap=default_colormap,\n            defaultBands=default_bands,\n            defaultRescaleMin=default_rescale_min,\n            defaultRescaleMax=default_rescale_max,\n            **kwargs,\n        )\n        self._controls = {\n            **self._controls,\n            \"cog-control\": {\"position\": position, \"collapsed\": collapsed},\n        }\n\n    def add_zarr_control(\n        self,\n        position: str = \"top-right\",\n        collapsed: bool = True,\n        default_url: Optional[str] = None,\n        load_default_url: bool = False,\n        default_opacity: float = 1.0,\n        default_variable: str = \"\",\n        default_clim: Optional[Tuple[float, float]] = None,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a Zarr layer control for loading Zarr datasets via UI.\n\n        This provides an interactive panel for users to enter Zarr URLs\n        and configure visualization parameters.\n\n        Args:\n            position: Control position ('top-left', 'top-right', 'bottom-left', 'bottom-right').\n            collapsed: Whether the panel starts collapsed.\n            default_url: Default Zarr URL to pre-fill.\n            load_default_url: Whether to auto-load the default URL.\n            default_opacity: Default layer opacity (0-1).\n            default_variable: Default variable name.\n            default_clim: Default color limits (min, max).\n            **kwargs: Additional control options.\n\n        Example:\n            &gt;&gt;&gt; from anymap_ts import MapLibreMap\n            &gt;&gt;&gt; m = MapLibreMap()\n            &gt;&gt;&gt; m.add_zarr_control(\n            ...     default_url=\"https://example.com/data.zarr\",\n            ...     default_variable=\"temperature\"\n            ... )\n        \"\"\"\n        self.call_js_method(\n            \"addZarrControl\",\n            position=position,\n            collapsed=collapsed,\n            defaultUrl=default_url or \"\",\n            loadDefaultUrl=load_default_url,\n            defaultOpacity=default_opacity,\n            defaultVariable=default_variable,\n            defaultClim=list(default_clim) if default_clim else [0, 1],\n            **kwargs,\n        )\n        self._controls = {\n            **self._controls,\n            \"zarr-control\": {\"position\": position, \"collapsed\": collapsed},\n        }\n\n    def add_vector_control(\n        self,\n        position: str = \"top-right\",\n        collapsed: bool = True,\n        default_url: Optional[str] = None,\n        load_default_url: bool = False,\n        default_opacity: float = 1.0,\n        default_fill_color: str = \"#3388ff\",\n        default_stroke_color: str = \"#3388ff\",\n        fit_bounds: bool = True,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a vector layer control for loading vector datasets from URLs.\n\n        This provides an interactive panel for users to enter URLs to\n        GeoJSON, GeoParquet, or FlatGeobuf datasets.\n\n        Args:\n            position: Control position ('top-left', 'top-right', 'bottom-left', 'bottom-right').\n            collapsed: Whether the panel starts collapsed.\n            default_url: Default vector URL to pre-fill.\n            load_default_url: Whether to auto-load the default URL.\n            default_opacity: Default layer opacity (0-1).\n            default_fill_color: Default fill color for polygons.\n            default_stroke_color: Default stroke color for lines/outlines.\n            fit_bounds: Whether to fit map to loaded data bounds.\n            **kwargs: Additional control options.\n\n        Example:\n            &gt;&gt;&gt; from anymap_ts import MapLibreMap\n            &gt;&gt;&gt; m = MapLibreMap()\n            &gt;&gt;&gt; m.add_vector_control(\n            ...     default_url=\"https://example.com/data.geojson\",\n            ...     default_fill_color=\"#ff0000\"\n            ... )\n        \"\"\"\n        self.call_js_method(\n            \"addVectorControl\",\n            position=position,\n            collapsed=collapsed,\n            defaultUrl=default_url or \"\",\n            loadDefaultUrl=load_default_url,\n            defaultOpacity=default_opacity,\n            defaultFillColor=default_fill_color,\n            defaultStrokeColor=default_stroke_color,\n            fitBounds=fit_bounds,\n            **kwargs,\n        )\n        self._controls = {\n            **self._controls,\n            \"vector-control\": {\"position\": position, \"collapsed\": collapsed},\n        }\n\n    def add_control_grid(\n        self,\n        position: str = \"top-right\",\n        default_controls: Optional[List[str]] = None,\n        exclude: Optional[List[str]] = None,\n        rows: Optional[int] = None,\n        columns: Optional[int] = None,\n        collapsed: bool = True,\n        collapsible: bool = True,\n        title: str = \"\",\n        show_row_column_controls: bool = True,\n        gap: int = 2,\n        basemap_style_url: Optional[str] = None,\n        exclude_layers: Optional[List[str]] = None,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a ControlGrid with all default tools or a custom subset.\n\n        The ControlGrid provides a collapsible toolbar with up to 26 built-in\n        controls (search, basemap, terrain, measure, draw, etc.) in a\n        configurable grid layout.\n\n        Args:\n            position: Control position ('top-left', 'top-right', 'bottom-left',\n                'bottom-right').\n            default_controls: Explicit list of control names to include. If None,\n                all 26 default controls are used (minus any in ``exclude``).\n                Valid names: 'globe', 'fullscreen', 'north', 'terrain', 'search',\n                'viewState', 'inspect', 'vectorDataset', 'basemap', 'measure',\n                'geoEditor', 'bookmark', 'print', 'minimap', 'swipe',\n                'streetView', 'addVector', 'cogLayer', 'zarrLayer',\n                'pmtilesLayer', 'stacLayer', 'stacSearch', 'planetaryComputer',\n                'gaussianSplat', 'lidar', 'usgsLidar'.\n            exclude: Controls to remove from the default set. Ignored when\n                ``default_controls`` is provided.\n            rows: Number of grid rows (auto-calculated if None).\n            columns: Number of grid columns (auto-calculated if None).\n            collapsed: Whether the grid starts collapsed. Default True.\n            collapsible: Whether the grid can be collapsed. Default True.\n            title: Optional header title for the grid.\n            show_row_column_controls: Show row/column input fields. Default True.\n            gap: Gap between grid cells in pixels. Default 2.\n            basemap_style_url: Basemap style URL for SwipeControl layer grouping.\n                If None, the current map style is used automatically.\n            exclude_layers: Layer ID patterns to exclude from SwipeControl\n                (e.g., 'measure-*', 'gl-draw-*'). If None, sensible defaults\n                are applied.\n            **kwargs: Additional ControlGrid options.\n\n        Example:\n            &gt;&gt;&gt; from anymap_ts import MapLibreMap\n            &gt;&gt;&gt; m = MapLibreMap()\n            &gt;&gt;&gt; m.add_control_grid()  # All 26 controls\n            &gt;&gt;&gt; # Or with customization:\n            &gt;&gt;&gt; m.add_control_grid(\n            ...     exclude=[\"minimap\", \"streetView\"],\n            ...     collapsed=True,\n            ... )\n        \"\"\"\n        js_kwargs: Dict[str, Any] = {\n            \"position\": position,\n            \"collapsed\": collapsed,\n            \"collapsible\": collapsible,\n            \"showRowColumnControls\": show_row_column_controls,\n            \"gap\": gap,\n            **kwargs,\n        }\n        if default_controls is not None:\n            js_kwargs[\"defaultControls\"] = default_controls\n        if exclude is not None:\n            js_kwargs[\"exclude\"] = exclude\n        if rows is not None:\n            js_kwargs[\"rows\"] = rows\n        if columns is not None:\n            js_kwargs[\"columns\"] = columns\n        if title:\n            js_kwargs[\"title\"] = title\n        if basemap_style_url is not None:\n            js_kwargs[\"basemapStyleUrl\"] = basemap_style_url\n        if exclude_layers is not None:\n            js_kwargs[\"excludeLayers\"] = exclude_layers\n\n        self.call_js_method(\"addControlGrid\", **js_kwargs)\n        self._controls = {\n            **self._controls,\n            \"control-grid\": {\"position\": position, \"collapsed\": collapsed},\n        }\n\n    def _process_deck_data(self, data: Any) -&gt; Any:\n        \"\"\"Process data for deck.gl layers.\n\n        Handles GeoDataFrame, file paths, GeoJSON, and list of dicts.\n\n        Args:\n            data: Input data in various formats.\n\n        Returns:\n            Processed data suitable for deck.gl layers.\n        \"\"\"\n        # Handle GeoDataFrame\n        if hasattr(data, \"__geo_interface__\"):\n            return data.__geo_interface__\n\n        # Handle file paths\n        if isinstance(data, (str, Path)):\n            path = Path(data)\n            if path.exists():\n                try:\n                    import geopandas as gpd\n\n                    gdf = gpd.read_file(path)\n                    return gdf.__geo_interface__\n                except ImportError:\n                    pass\n\n        # Return as-is for lists, dicts, etc.\n        return data\n\n    # -------------------------------------------------------------------------\n    # Layer Management\n    # -------------------------------------------------------------------------\n\n    def add_layer(\n        self,\n        layer_id: str,\n        layer_type: str,\n        source: Union[str, Dict],\n        paint: Optional[Dict] = None,\n        layout: Optional[Dict] = None,\n        before_id: Optional[str] = None,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a generic layer to the map.\n\n        Args:\n            layer_id: Unique layer identifier\n            layer_type: MapLibre layer type\n            source: Source ID or source configuration dict\n            paint: Paint properties\n            layout: Layout properties\n            before_id: ID of layer to insert before\n            **kwargs: Additional layer options\n        \"\"\"\n        layer_config = {\n            \"id\": layer_id,\n            \"type\": layer_type,\n            \"paint\": paint or {},\n            \"layout\": layout or {},\n            **kwargs,\n        }\n\n        if isinstance(source, str):\n            layer_config[\"source\"] = source\n        else:\n            source_id = f\"{layer_id}-source\"\n            self._sources = {**self._sources, source_id: source}\n            self.call_js_method(\"addSource\", source_id, **source)\n            layer_config[\"source\"] = source_id\n\n        self._layers = {**self._layers, layer_id: layer_config}\n        self.call_js_method(\"addLayer\", beforeId=before_id, **layer_config)\n\n    def remove_layer(self, layer_id: str) -&gt; None:\n        \"\"\"Remove a layer from the map.\n\n        Args:\n            layer_id: Layer identifier to remove\n        \"\"\"\n        if layer_id in self._layers:\n            layers = dict(self._layers)\n            del layers[layer_id]\n            self._layers = layers\n        self.call_js_method(\"removeLayer\", layer_id)\n\n    def set_visibility(self, layer_id: str, visible: bool) -&gt; None:\n        \"\"\"Set layer visibility.\n\n        Args:\n            layer_id: Layer identifier\n            visible: Whether layer should be visible\n        \"\"\"\n        self.call_js_method(\"setVisibility\", layer_id, visible)\n\n    def set_opacity(self, layer_id: str, opacity: float) -&gt; None:\n        \"\"\"Set layer opacity.\n\n        Args:\n            layer_id: Layer identifier\n            opacity: Opacity value between 0 and 1\n        \"\"\"\n        self.call_js_method(\"setOpacity\", layer_id, opacity)\n\n    # -------------------------------------------------------------------------\n    # Controls\n    # -------------------------------------------------------------------------\n\n    def add_control(\n        self,\n        control_type: str,\n        position: str = \"top-right\",\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a map control.\n\n        Args:\n            control_type: Type of control ('navigation', 'scale', 'fullscreen', etc.)\n            position: Control position\n            **kwargs: Control-specific options\n        \"\"\"\n        self.call_js_method(\"addControl\", control_type, position=position, **kwargs)\n        self._controls = {\n            **self._controls,\n            control_type: {\"type\": control_type, \"position\": position, **kwargs},\n        }\n\n    def remove_control(self, control_type: str) -&gt; None:\n        \"\"\"Remove a map control.\n\n        Args:\n            control_type: Type of control to remove\n        \"\"\"\n        self.call_js_method(\"removeControl\", control_type)\n        if control_type in self._controls:\n            controls = dict(self._controls)\n            del controls[control_type]\n            self._controls = controls\n\n    def add_layer_control(\n        self,\n        layers: Optional[List[str]] = None,\n        position: str = \"top-right\",\n        collapsed: bool = True,\n    ) -&gt; None:\n        \"\"\"Add a layer visibility control.\n\n        Uses maplibre-gl-layer-control for layer toggling and opacity.\n\n        Args:\n            layers: List of layer IDs to include (None = all layers)\n            position: Control position\n            collapsed: Whether control starts collapsed\n        \"\"\"\n        if layers is None:\n            layers = list(self._layers.keys())\n\n        self.call_js_method(\n            \"addLayerControl\",\n            layers=layers,\n            position=position,\n            collapsed=collapsed,\n        )\n        self._controls = {\n            **self._controls,\n            \"layer-control\": {\"layers\": layers, \"position\": position},\n        }\n\n    # -------------------------------------------------------------------------\n    # Drawing\n    # -------------------------------------------------------------------------\n\n    def add_draw_control(\n        self,\n        position: str = \"top-right\",\n        draw_modes: Optional[List[str]] = None,\n        edit_modes: Optional[List[str]] = None,\n        collapsed: bool = False,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a drawing control using maplibre-gl-geo-editor.\n\n        Args:\n            position: Control position\n            draw_modes: Drawing modes to enable (e.g., ['polygon', 'line', 'marker'])\n            edit_modes: Edit modes to enable (e.g., ['select', 'drag', 'delete'])\n            collapsed: Whether control starts collapsed\n            **kwargs: Additional geo-editor options\n        \"\"\"\n        if draw_modes is None:\n            draw_modes = [\"polygon\", \"line\", \"rectangle\", \"circle\", \"marker\"]\n        if edit_modes is None:\n            edit_modes = [\"select\", \"drag\", \"change\", \"rotate\", \"delete\"]\n\n        self.call_js_method(\n            \"addDrawControl\",\n            position=position,\n            drawModes=draw_modes,\n            editModes=edit_modes,\n            collapsed=collapsed,\n            **kwargs,\n        )\n        self._controls = {\n            **self._controls,\n            \"draw-control\": {\n                \"position\": position,\n                \"drawModes\": draw_modes,\n                \"editModes\": edit_modes,\n            },\n        }\n\n    def get_draw_data(self) -&gt; Dict:\n        \"\"\"Get the current drawn features as GeoJSON.\n\n        Returns:\n            GeoJSON FeatureCollection of drawn features\n        \"\"\"\n        self.call_js_method(\"getDrawData\")\n        # Small delay to allow JS to update the trait\n        import time\n\n        time.sleep(0.1)\n        return self._draw_data or {\"type\": \"FeatureCollection\", \"features\": []}\n\n    @property\n    def draw_data(self) -&gt; Dict:\n        \"\"\"Property to access current draw data.\"\"\"\n        return self._draw_data or {\"type\": \"FeatureCollection\", \"features\": []}\n\n    def load_draw_data(self, geojson: Dict) -&gt; None:\n        \"\"\"Load GeoJSON features into the drawing layer.\n\n        Args:\n            geojson: GeoJSON FeatureCollection to load\n        \"\"\"\n        self._draw_data = geojson\n        self.call_js_method(\"loadDrawData\", geojson)\n\n    def clear_draw_data(self) -&gt; None:\n        \"\"\"Clear all drawn features.\"\"\"\n        self._draw_data = {\"type\": \"FeatureCollection\", \"features\": []}\n        self.call_js_method(\"clearDrawData\")\n\n    def save_draw_data(\n        self,\n        filepath: Union[str, Path],\n        driver: Optional[str] = None,\n    ) -&gt; None:\n        \"\"\"Save drawn features to a file.\n\n        Args:\n            filepath: Path to save file\n            driver: Output driver (auto-detected from extension if not provided)\n\n        Raises:\n            ImportError: If geopandas is not installed\n        \"\"\"\n        try:\n            import geopandas as gpd\n        except ImportError:\n            raise ImportError(\n                \"geopandas is required to save draw data. \"\n                \"Install with: pip install anymap-ts[vector]\"\n            )\n\n        data = self.get_draw_data()\n        if not data.get(\"features\"):\n            print(\"No features to save\")\n            return\n\n        gdf = gpd.GeoDataFrame.from_features(data[\"features\"])\n        filepath = Path(filepath)\n\n        # Infer driver from extension\n        if driver is None:\n            ext = filepath.suffix.lower()\n            driver_map = {\n                \".geojson\": \"GeoJSON\",\n                \".json\": \"GeoJSON\",\n                \".shp\": \"ESRI Shapefile\",\n                \".gpkg\": \"GPKG\",\n            }\n            driver = driver_map.get(ext, \"GeoJSON\")\n\n        gdf.to_file(filepath, driver=driver)\n\n    # -------------------------------------------------------------------------\n    # HTML Export\n    # -------------------------------------------------------------------------\n\n    def _generate_html_template(self) -&gt; str:\n        \"\"\"Generate standalone HTML for the map.\"\"\"\n        template_path = Path(__file__).parent / \"templates\" / \"maplibre.html\"\n\n        if template_path.exists():\n            template = template_path.read_text(encoding=\"utf-8\")\n        else:\n            template = self._get_default_template()\n\n        # Serialize state\n        state = {\n            \"center\": self.center,\n            \"zoom\": self.zoom,\n            \"style\": self.style,\n            \"bearing\": self.bearing,\n            \"pitch\": self.pitch,\n            \"width\": self.width,\n            \"height\": self.height,\n            \"layers\": self._layers,\n            \"sources\": self._sources,\n            \"controls\": self._controls,\n            \"js_calls\": self._js_calls,\n        }\n\n        template = template.replace(\"{{state}}\", json.dumps(state, indent=2))\n        return template\n\n    def _get_default_template(self) -&gt; str:\n        \"\"\"Get default HTML template.\"\"\"\n        return \"\"\"&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n    &lt;meta charset=\"utf-8\"&gt;\n    &lt;title&gt;{{title}}&lt;/title&gt;\n    &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"&gt;\n    &lt;script src=\"https://unpkg.com/maplibre-gl@5/dist/maplibre-gl.js\"&gt;&lt;/script&gt;\n    &lt;link href=\"https://unpkg.com/maplibre-gl@5/dist/maplibre-gl.css\" rel=\"stylesheet\" /&gt;\n    &lt;style&gt;\n        body { margin: 0; padding: 0; }\n        #map { position: absolute; top: 0; bottom: 0; width: 100%; }\n    &lt;/style&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;div id=\"map\"&gt;&lt;/div&gt;\n    &lt;script&gt;\n        const state = {{state}};\n\n        const map = new maplibregl.Map({\n            container: 'map',\n            style: state.style,\n            center: state.center,\n            zoom: state.zoom,\n            bearing: state.bearing || 0,\n            pitch: state.pitch || 0\n        });\n\n        map.on('load', function() {\n            // Replay JS calls\n            for (const call of state.js_calls || []) {\n                try {\n                    executeMethod(call.method, call.args, call.kwargs);\n                } catch (e) {\n                    console.error('Error executing', call.method, e);\n                }\n            }\n        });\n\n        function executeMethod(method, args, kwargs) {\n            switch (method) {\n                case 'addBasemap':\n                    const url = args[0];\n                    const name = kwargs.name || 'basemap';\n                    const sourceId = 'basemap-' + name;\n                    if (!map.getSource(sourceId)) {\n                        map.addSource(sourceId, {\n                            type: 'raster',\n                            tiles: [url],\n                            tileSize: 256,\n                            attribution: kwargs.attribution || ''\n                        });\n                    }\n                    if (!map.getLayer(sourceId)) {\n                        map.addLayer({\n                            id: sourceId,\n                            type: 'raster',\n                            source: sourceId\n                        });\n                    }\n                    break;\n\n                case 'addGeoJSON':\n                    const layerName = kwargs.name;\n                    const sourceIdGeo = layerName + '-source';\n                    if (!map.getSource(sourceIdGeo)) {\n                        map.addSource(sourceIdGeo, {\n                            type: 'geojson',\n                            data: kwargs.data\n                        });\n                    }\n                    if (!map.getLayer(layerName)) {\n                        map.addLayer({\n                            id: layerName,\n                            type: kwargs.layerType || 'circle',\n                            source: sourceIdGeo,\n                            paint: kwargs.paint || {}\n                        });\n                    }\n                    if (kwargs.fitBounds &amp;&amp; kwargs.bounds) {\n                        map.fitBounds([\n                            [kwargs.bounds[0], kwargs.bounds[1]],\n                            [kwargs.bounds[2], kwargs.bounds[3]]\n                        ], { padding: 50 });\n                    }\n                    break;\n\n                case 'addTileLayer':\n                    const tileUrl = args[0];\n                    const tileName = kwargs.name;\n                    const tileSourceId = tileName + '-source';\n                    if (!map.getSource(tileSourceId)) {\n                        map.addSource(tileSourceId, {\n                            type: 'raster',\n                            tiles: [tileUrl],\n                            tileSize: 256,\n                            attribution: kwargs.attribution || ''\n                        });\n                    }\n                    if (!map.getLayer(tileName)) {\n                        map.addLayer({\n                            id: tileName,\n                            type: 'raster',\n                            source: tileSourceId\n                        });\n                    }\n                    break;\n\n                case 'addControl':\n                    const controlType = args[0];\n                    const position = kwargs.position || 'top-right';\n                    let control;\n                    switch (controlType) {\n                        case 'navigation':\n                            control = new maplibregl.NavigationControl();\n                            break;\n                        case 'scale':\n                            control = new maplibregl.ScaleControl();\n                            break;\n                        case 'fullscreen':\n                            control = new maplibregl.FullscreenControl();\n                            break;\n                    }\n                    if (control) {\n                        map.addControl(control, position);\n                    }\n                    break;\n\n                case 'flyTo':\n                    map.flyTo({\n                        center: [args[0], args[1]],\n                        zoom: kwargs.zoom,\n                        duration: kwargs.duration || 2000\n                    });\n                    break;\n\n                case 'fitBounds':\n                    const bounds = args[0];\n                    map.fitBounds([\n                        [bounds[0], bounds[1]],\n                        [bounds[2], bounds[3]]\n                    ], {\n                        padding: kwargs.padding || 50,\n                        duration: kwargs.duration || 1000\n                    });\n                    break;\n\n                default:\n                    console.log('Unknown method:', method);\n            }\n        }\n    &lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\"\"\"\n</code></pre>"},{"location":"maplibre/#anymap_ts.maplibre.MapLibreMap.draw_data","title":"<code>draw_data: Dict</code>  <code>property</code> <code>readonly</code>","text":"<p>Property to access current draw data.</p>"},{"location":"maplibre/#anymap_ts.maplibre.MapLibreMap.__init__","title":"<code>__init__(self, center=(0.0, 0.0), zoom=2.0, width='100%', height='700px', style='https://basemaps.cartocdn.com/gl/positron-gl-style/style.json', bearing=0.0, pitch=0.0, max_pitch=85.0, controls=None, **kwargs)</code>  <code>special</code>","text":"<p>Initialize a MapLibre map.</p> <p>Parameters:</p> Name Type Description Default <code>center</code> <code>Tuple[float, float]</code> <p>Map center as (longitude, latitude).</p> <code>(0.0, 0.0)</code> <code>zoom</code> <code>float</code> <p>Initial zoom level.</p> <code>2.0</code> <code>width</code> <code>str</code> <p>Map width as CSS string.</p> <code>'100%'</code> <code>height</code> <code>str</code> <p>Map height as CSS string. Default is \"700px\".</p> <code>'700px'</code> <code>style</code> <code>Union[str, Dict]</code> <p>MapLibre style URL or style object. Default is \"https://basemaps.cartocdn.com/gl/positron-gl-style/style.json\".</p> <code>'https://basemaps.cartocdn.com/gl/positron-gl-style/style.json'</code> <code>bearing</code> <code>float</code> <p>Map bearing in degrees.</p> <code>0.0</code> <code>pitch</code> <code>float</code> <p>Map pitch in degrees.</p> <code>0.0</code> <code>max_pitch</code> <code>float</code> <p>Maximum pitch angle in degrees (default: 85).</p> <code>85.0</code> <code>controls</code> <code>Optional[Dict[str, Any]]</code> <p>Dict of controls to add. If None, defaults to {\"layer-control\": True, \"control-grid\": True}. Use {\"layer-control\": {\"collapsed\": True}} for custom options.</p> <code>None</code> <code>**kwargs</code> <p>Additional widget arguments.</p> <code>{}</code> Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def __init__(\n    self,\n    center: Tuple[float, float] = (0.0, 0.0),\n    zoom: float = 2.0,\n    width: str = \"100%\",\n    height: str = \"700px\",\n    style: Union[\n        str, Dict\n    ] = \"https://basemaps.cartocdn.com/gl/positron-gl-style/style.json\",\n    bearing: float = 0.0,\n    pitch: float = 0.0,\n    max_pitch: float = 85.0,\n    controls: Optional[Dict[str, Any]] = None,\n    **kwargs,\n):\n    \"\"\"Initialize a MapLibre map.\n\n    Args:\n        center: Map center as (longitude, latitude).\n        zoom: Initial zoom level.\n        width: Map width as CSS string.\n        height: Map height as CSS string. Default is \"700px\".\n        style: MapLibre style URL or style object. Default is \"https://basemaps.cartocdn.com/gl/positron-gl-style/style.json\".\n        bearing: Map bearing in degrees.\n        pitch: Map pitch in degrees.\n        max_pitch: Maximum pitch angle in degrees (default: 85).\n        controls: Dict of controls to add. If None, defaults to\n            {\"layer-control\": True, \"control-grid\": True}.\n            Use {\"layer-control\": {\"collapsed\": True}} for custom options.\n        **kwargs: Additional widget arguments.\n    \"\"\"\n    # Handle style shortcuts\n    if isinstance(style, str) and not style.startswith(\"http\"):\n        try:\n            style = get_maplibre_style(style)\n        except ValueError:\n            pass  # Use as-is\n\n    super().__init__(\n        center=list(center),\n        zoom=zoom,\n        width=width,\n        height=height,\n        style=style,\n        bearing=bearing,\n        pitch=pitch,\n        max_pitch=max_pitch,\n        **kwargs,\n    )\n\n    # Initialize layer dictionary\n    self._layer_dict = {\"Background\": []}\n\n    # Add default controls\n    if controls is None:\n        controls = {\n            \"layer-control\": True,\n            \"control-grid\": True,\n        }\n\n    for control_name, config in controls.items():\n        if config:\n            if control_name == \"layer-control\":\n                self.add_layer_control(\n                    **(config if isinstance(config, dict) else {})\n                )\n            elif control_name == \"control-grid\":\n                self.add_control_grid(\n                    **(config if isinstance(config, dict) else {})\n                )\n            else:\n                self.add_control(\n                    control_name, **(config if isinstance(config, dict) else {})\n                )\n</code></pre>"},{"location":"maplibre/#anymap_ts.maplibre.MapLibreMap.add_arc_layer","title":"<code>add_arc_layer(self, data, name=None, get_source_position='source', get_target_position='target', get_source_color=None, get_target_color=None, get_width=1, get_height=1, great_circle=False, pickable=True, opacity=0.8, **kwargs)</code>","text":"<p>Add an arc layer for origin-destination visualization using deck.gl.</p> <p>Arc layers are ideal for visualizing connections between locations, such as flight routes, migration patterns, or network flows.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>Array of data objects with source/target coordinates. Each object should have source and target positions.</p> required <code>name</code> <code>Optional[str]</code> <p>Layer ID. If None, auto-generated.</p> <code>None</code> <code>get_source_position</code> <code>Union[str, Any]</code> <p>Accessor for source position [lng, lat]. Can be a string (property name) or a value.</p> <code>'source'</code> <code>get_target_position</code> <code>Union[str, Any]</code> <p>Accessor for target position [lng, lat]. Can be a string (property name) or a value.</p> <code>'target'</code> <code>get_source_color</code> <code>Optional[List[int]]</code> <p>Source end color as [r, g, b, a]. Default: [51, 136, 255, 255] (blue).</p> <code>None</code> <code>get_target_color</code> <code>Optional[List[int]]</code> <p>Target end color as [r, g, b, a]. Default: [255, 136, 51, 255] (orange).</p> <code>None</code> <code>get_width</code> <code>Union[float, str]</code> <p>Arc width in pixels. Can be a number or accessor.</p> <code>1</code> <code>get_height</code> <code>float</code> <p>Arc height multiplier. Higher values create more curved arcs.</p> <code>1</code> <code>great_circle</code> <code>bool</code> <p>Whether to draw arcs along great circles.</p> <code>False</code> <code>pickable</code> <code>bool</code> <p>Whether layer responds to hover/click events.</p> <code>True</code> <code>opacity</code> <code>float</code> <p>Layer opacity (0-1).</p> <code>0.8</code> <code>**kwargs</code> <p>Additional ArcLayer props.</p> <code>{}</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from anymap_ts import MapLibreMap\n&gt;&gt;&gt; m = MapLibreMap()\n&gt;&gt;&gt; arcs = [\n...     {\"source\": [-122.4, 37.8], \"target\": [-73.9, 40.7]},\n...     {\"source\": [-122.4, 37.8], \"target\": [-0.1, 51.5]},\n... ]\n&gt;&gt;&gt; m.add_arc_layer(arcs, name=\"flights\")\n</code></pre> Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def add_arc_layer(\n    self,\n    data: Any,\n    name: Optional[str] = None,\n    get_source_position: Union[str, Any] = \"source\",\n    get_target_position: Union[str, Any] = \"target\",\n    get_source_color: Optional[List[int]] = None,\n    get_target_color: Optional[List[int]] = None,\n    get_width: Union[float, str] = 1,\n    get_height: float = 1,\n    great_circle: bool = False,\n    pickable: bool = True,\n    opacity: float = 0.8,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add an arc layer for origin-destination visualization using deck.gl.\n\n    Arc layers are ideal for visualizing connections between locations,\n    such as flight routes, migration patterns, or network flows.\n\n    Args:\n        data: Array of data objects with source/target coordinates.\n            Each object should have source and target positions.\n        name: Layer ID. If None, auto-generated.\n        get_source_position: Accessor for source position [lng, lat].\n            Can be a string (property name) or a value.\n        get_target_position: Accessor for target position [lng, lat].\n            Can be a string (property name) or a value.\n        get_source_color: Source end color as [r, g, b, a].\n            Default: [51, 136, 255, 255] (blue).\n        get_target_color: Target end color as [r, g, b, a].\n            Default: [255, 136, 51, 255] (orange).\n        get_width: Arc width in pixels. Can be a number or accessor.\n        get_height: Arc height multiplier. Higher values create more curved arcs.\n        great_circle: Whether to draw arcs along great circles.\n        pickable: Whether layer responds to hover/click events.\n        opacity: Layer opacity (0-1).\n        **kwargs: Additional ArcLayer props.\n\n    Example:\n        &gt;&gt;&gt; from anymap_ts import MapLibreMap\n        &gt;&gt;&gt; m = MapLibreMap()\n        &gt;&gt;&gt; arcs = [\n        ...     {\"source\": [-122.4, 37.8], \"target\": [-73.9, 40.7]},\n        ...     {\"source\": [-122.4, 37.8], \"target\": [-0.1, 51.5]},\n        ... ]\n        &gt;&gt;&gt; m.add_arc_layer(arcs, name=\"flights\")\n    \"\"\"\n    layer_id = name or f\"arc-{len(self._layers)}\"\n    processed_data = self._process_deck_data(data)\n\n    self.call_js_method(\n        \"addArcLayer\",\n        id=layer_id,\n        data=processed_data,\n        getSourcePosition=get_source_position,\n        getTargetPosition=get_target_position,\n        getSourceColor=get_source_color or [51, 136, 255, 255],\n        getTargetColor=get_target_color or [255, 136, 51, 255],\n        getWidth=get_width,\n        getHeight=get_height,\n        greatCircle=great_circle,\n        pickable=pickable,\n        opacity=opacity,\n        **kwargs,\n    )\n\n    self._layers = {\n        **self._layers,\n        layer_id: {\n            \"id\": layer_id,\n            \"type\": \"arc\",\n        },\n    }\n</code></pre>"},{"location":"maplibre/#anymap_ts.maplibre.MapLibreMap.add_basemap","title":"<code>add_basemap(self, basemap='OpenStreetMap', attribution=None, **kwargs)</code>","text":"<p>Add a basemap layer.</p> <p>Parameters:</p> Name Type Description Default <code>basemap</code> <code>str</code> <p>Name of basemap provider (e.g., \"OpenStreetMap\", \"CartoDB.Positron\")</p> <code>'OpenStreetMap'</code> <code>attribution</code> <code>Optional[str]</code> <p>Custom attribution text</p> <code>None</code> <code>**kwargs</code> <p>Additional options</p> <code>{}</code> Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def add_basemap(\n    self,\n    basemap: str = \"OpenStreetMap\",\n    attribution: Optional[str] = None,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a basemap layer.\n\n    Args:\n        basemap: Name of basemap provider (e.g., \"OpenStreetMap\", \"CartoDB.Positron\")\n        attribution: Custom attribution text\n        **kwargs: Additional options\n    \"\"\"\n    url, default_attribution = get_basemap_url(basemap)\n    self.call_js_method(\n        \"addBasemap\",\n        url,\n        attribution=attribution or default_attribution,\n        name=basemap,\n        **kwargs,\n    )\n\n    # Track in layer dict\n    basemaps = self._layer_dict.get(\"Basemaps\", [])\n    if basemap not in basemaps:\n        self._layer_dict = {\n            **self._layer_dict,\n            \"Basemaps\": basemaps + [basemap],\n        }\n</code></pre>"},{"location":"maplibre/#anymap_ts.maplibre.MapLibreMap.add_cog_control","title":"<code>add_cog_control(self, position='top-right', collapsed=True, default_url=None, load_default_url=False, default_opacity=1.0, default_colormap='viridis', default_bands='1', default_rescale_min=0, default_rescale_max=255, **kwargs)</code>","text":"<p>Add a COG layer control for loading Cloud Optimized GeoTIFFs via UI.</p> <p>This provides an interactive panel for users to enter COG URLs and configure visualization parameters like colormap and rescaling.</p> <p>Parameters:</p> Name Type Description Default <code>position</code> <code>str</code> <p>Control position ('top-left', 'top-right', 'bottom-left', 'bottom-right').</p> <code>'top-right'</code> <code>collapsed</code> <code>bool</code> <p>Whether the panel starts collapsed.</p> <code>True</code> <code>default_url</code> <code>Optional[str]</code> <p>Default COG URL to pre-fill.</p> <code>None</code> <code>load_default_url</code> <code>bool</code> <p>Whether to auto-load the default URL.</p> <code>False</code> <code>default_opacity</code> <code>float</code> <p>Default layer opacity (0-1).</p> <code>1.0</code> <code>default_colormap</code> <code>str</code> <p>Default colormap name.</p> <code>'viridis'</code> <code>default_bands</code> <code>str</code> <p>Default bands (e.g., '1' or '1,2,3').</p> <code>'1'</code> <code>default_rescale_min</code> <code>float</code> <p>Default minimum value for rescaling.</p> <code>0</code> <code>default_rescale_max</code> <code>float</code> <p>Default maximum value for rescaling.</p> <code>255</code> <code>**kwargs</code> <p>Additional control options.</p> <code>{}</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from anymap_ts import MapLibreMap\n&gt;&gt;&gt; m = MapLibreMap()\n&gt;&gt;&gt; m.add_cog_control(\n...     default_url=\"https://example.com/cog.tif\",\n...     default_colormap=\"terrain\"\n... )\n</code></pre> Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def add_cog_control(\n    self,\n    position: str = \"top-right\",\n    collapsed: bool = True,\n    default_url: Optional[str] = None,\n    load_default_url: bool = False,\n    default_opacity: float = 1.0,\n    default_colormap: str = \"viridis\",\n    default_bands: str = \"1\",\n    default_rescale_min: float = 0,\n    default_rescale_max: float = 255,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a COG layer control for loading Cloud Optimized GeoTIFFs via UI.\n\n    This provides an interactive panel for users to enter COG URLs\n    and configure visualization parameters like colormap and rescaling.\n\n    Args:\n        position: Control position ('top-left', 'top-right', 'bottom-left', 'bottom-right').\n        collapsed: Whether the panel starts collapsed.\n        default_url: Default COG URL to pre-fill.\n        load_default_url: Whether to auto-load the default URL.\n        default_opacity: Default layer opacity (0-1).\n        default_colormap: Default colormap name.\n        default_bands: Default bands (e.g., '1' or '1,2,3').\n        default_rescale_min: Default minimum value for rescaling.\n        default_rescale_max: Default maximum value for rescaling.\n        **kwargs: Additional control options.\n\n    Example:\n        &gt;&gt;&gt; from anymap_ts import MapLibreMap\n        &gt;&gt;&gt; m = MapLibreMap()\n        &gt;&gt;&gt; m.add_cog_control(\n        ...     default_url=\"https://example.com/cog.tif\",\n        ...     default_colormap=\"terrain\"\n        ... )\n    \"\"\"\n    self.call_js_method(\n        \"addCogControl\",\n        position=position,\n        collapsed=collapsed,\n        defaultUrl=default_url or \"\",\n        loadDefaultUrl=load_default_url,\n        defaultOpacity=default_opacity,\n        defaultColormap=default_colormap,\n        defaultBands=default_bands,\n        defaultRescaleMin=default_rescale_min,\n        defaultRescaleMax=default_rescale_max,\n        **kwargs,\n    )\n    self._controls = {\n        **self._controls,\n        \"cog-control\": {\"position\": position, \"collapsed\": collapsed},\n    }\n</code></pre>"},{"location":"maplibre/#anymap_ts.maplibre.MapLibreMap.add_cog_layer","title":"<code>add_cog_layer(self, url, name=None, opacity=1.0, visible=True, debug=False, debug_opacity=0.25, max_error=0.125, fit_bounds=True, before_id=None, **kwargs)</code>","text":"<p>Add a Cloud Optimized GeoTIFF (COG) layer using @developmentseed/deck.gl-geotiff.</p> <p>This method renders COG files directly in the browser using GPU-accelerated deck.gl-geotiff rendering with automatic reprojection support.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>URL to the Cloud Optimized GeoTIFF file.</p> required <code>name</code> <code>Optional[str]</code> <p>Layer ID. If None, auto-generated.</p> <code>None</code> <code>opacity</code> <code>float</code> <p>Layer opacity (0-1).</p> <code>1.0</code> <code>visible</code> <code>bool</code> <p>Whether layer is visible.</p> <code>True</code> <code>debug</code> <code>bool</code> <p>Show reprojection mesh for debugging.</p> <code>False</code> <code>debug_opacity</code> <code>float</code> <p>Opacity of debug mesh (0-1).</p> <code>0.25</code> <code>max_error</code> <code>float</code> <p>Maximum reprojection error in pixels. Lower values create denser mesh for better accuracy.</p> <code>0.125</code> <code>fit_bounds</code> <code>bool</code> <p>Whether to fit map to COG bounds after loading.</p> <code>True</code> <code>before_id</code> <code>Optional[str]</code> <p>ID of layer to insert before.</p> <code>None</code> <code>**kwargs</code> <p>Additional COGLayer props.</p> <code>{}</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from anymap_ts import Map\n&gt;&gt;&gt; m = Map()\n&gt;&gt;&gt; m.add_cog_layer(\n...     \"https://example.com/landcover.tif\",\n...     name=\"landcover\",\n...     opacity=0.8\n... )\n</code></pre> Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def add_cog_layer(\n    self,\n    url: str,\n    name: Optional[str] = None,\n    opacity: float = 1.0,\n    visible: bool = True,\n    debug: bool = False,\n    debug_opacity: float = 0.25,\n    max_error: float = 0.125,\n    fit_bounds: bool = True,\n    before_id: Optional[str] = None,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a Cloud Optimized GeoTIFF (COG) layer using @developmentseed/deck.gl-geotiff.\n\n    This method renders COG files directly in the browser using GPU-accelerated\n    deck.gl-geotiff rendering with automatic reprojection support.\n\n    Args:\n        url: URL to the Cloud Optimized GeoTIFF file.\n        name: Layer ID. If None, auto-generated.\n        opacity: Layer opacity (0-1).\n        visible: Whether layer is visible.\n        debug: Show reprojection mesh for debugging.\n        debug_opacity: Opacity of debug mesh (0-1).\n        max_error: Maximum reprojection error in pixels. Lower values\n            create denser mesh for better accuracy.\n        fit_bounds: Whether to fit map to COG bounds after loading.\n        before_id: ID of layer to insert before.\n        **kwargs: Additional COGLayer props.\n\n    Example:\n        &gt;&gt;&gt; from anymap_ts import Map\n        &gt;&gt;&gt; m = Map()\n        &gt;&gt;&gt; m.add_cog_layer(\n        ...     \"https://example.com/landcover.tif\",\n        ...     name=\"landcover\",\n        ...     opacity=0.8\n        ... )\n    \"\"\"\n    layer_id = name or f\"cog-{len(self._layers)}\"\n\n    self.call_js_method(\n        \"addCOGLayer\",\n        id=layer_id,\n        geotiff=url,\n        opacity=opacity,\n        visible=visible,\n        debug=debug,\n        debugOpacity=debug_opacity,\n        maxError=max_error,\n        fitBounds=fit_bounds,\n        beforeId=before_id,\n        **kwargs,\n    )\n\n    self._layers = {\n        **self._layers,\n        layer_id: {\n            \"id\": layer_id,\n            \"type\": \"cog\",\n            \"url\": url,\n        },\n    }\n</code></pre>"},{"location":"maplibre/#anymap_ts.maplibre.MapLibreMap.add_control","title":"<code>add_control(self, control_type, position='top-right', **kwargs)</code>","text":"<p>Add a map control.</p> <p>Parameters:</p> Name Type Description Default <code>control_type</code> <code>str</code> <p>Type of control ('navigation', 'scale', 'fullscreen', etc.)</p> required <code>position</code> <code>str</code> <p>Control position</p> <code>'top-right'</code> <code>**kwargs</code> <p>Control-specific options</p> <code>{}</code> Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def add_control(\n    self,\n    control_type: str,\n    position: str = \"top-right\",\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a map control.\n\n    Args:\n        control_type: Type of control ('navigation', 'scale', 'fullscreen', etc.)\n        position: Control position\n        **kwargs: Control-specific options\n    \"\"\"\n    self.call_js_method(\"addControl\", control_type, position=position, **kwargs)\n    self._controls = {\n        **self._controls,\n        control_type: {\"type\": control_type, \"position\": position, **kwargs},\n    }\n</code></pre>"},{"location":"maplibre/#anymap_ts.maplibre.MapLibreMap.add_control_grid","title":"<code>add_control_grid(self, position='top-right', default_controls=None, exclude=None, rows=None, columns=None, collapsed=True, collapsible=True, title='', show_row_column_controls=True, gap=2, basemap_style_url=None, exclude_layers=None, **kwargs)</code>","text":"<p>Add a ControlGrid with all default tools or a custom subset.</p> <p>The ControlGrid provides a collapsible toolbar with up to 26 built-in controls (search, basemap, terrain, measure, draw, etc.) in a configurable grid layout.</p> <p>Parameters:</p> Name Type Description Default <code>position</code> <code>str</code> <p>Control position ('top-left', 'top-right', 'bottom-left', 'bottom-right').</p> <code>'top-right'</code> <code>default_controls</code> <code>Optional[List[str]]</code> <p>Explicit list of control names to include. If None, all 26 default controls are used (minus any in <code>exclude</code>). Valid names: 'globe', 'fullscreen', 'north', 'terrain', 'search', 'viewState', 'inspect', 'vectorDataset', 'basemap', 'measure', 'geoEditor', 'bookmark', 'print', 'minimap', 'swipe', 'streetView', 'addVector', 'cogLayer', 'zarrLayer', 'pmtilesLayer', 'stacLayer', 'stacSearch', 'planetaryComputer', 'gaussianSplat', 'lidar', 'usgsLidar'.</p> <code>None</code> <code>exclude</code> <code>Optional[List[str]]</code> <p>Controls to remove from the default set. Ignored when <code>default_controls</code> is provided.</p> <code>None</code> <code>rows</code> <code>Optional[int]</code> <p>Number of grid rows (auto-calculated if None).</p> <code>None</code> <code>columns</code> <code>Optional[int]</code> <p>Number of grid columns (auto-calculated if None).</p> <code>None</code> <code>collapsed</code> <code>bool</code> <p>Whether the grid starts collapsed. Default True.</p> <code>True</code> <code>collapsible</code> <code>bool</code> <p>Whether the grid can be collapsed. Default True.</p> <code>True</code> <code>title</code> <code>str</code> <p>Optional header title for the grid.</p> <code>''</code> <code>show_row_column_controls</code> <code>bool</code> <p>Show row/column input fields. Default True.</p> <code>True</code> <code>gap</code> <code>int</code> <p>Gap between grid cells in pixels. Default 2.</p> <code>2</code> <code>basemap_style_url</code> <code>Optional[str]</code> <p>Basemap style URL for SwipeControl layer grouping. If None, the current map style is used automatically.</p> <code>None</code> <code>exclude_layers</code> <code>Optional[List[str]]</code> <p>Layer ID patterns to exclude from SwipeControl (e.g., 'measure-', 'gl-draw-'). If None, sensible defaults are applied.</p> <code>None</code> <code>**kwargs</code> <p>Additional ControlGrid options.</p> <code>{}</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from anymap_ts import MapLibreMap\n&gt;&gt;&gt; m = MapLibreMap()\n&gt;&gt;&gt; m.add_control_grid()  # All 26 controls\n&gt;&gt;&gt; # Or with customization:\n&gt;&gt;&gt; m.add_control_grid(\n...     exclude=[\"minimap\", \"streetView\"],\n...     collapsed=True,\n... )\n</code></pre> Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def add_control_grid(\n    self,\n    position: str = \"top-right\",\n    default_controls: Optional[List[str]] = None,\n    exclude: Optional[List[str]] = None,\n    rows: Optional[int] = None,\n    columns: Optional[int] = None,\n    collapsed: bool = True,\n    collapsible: bool = True,\n    title: str = \"\",\n    show_row_column_controls: bool = True,\n    gap: int = 2,\n    basemap_style_url: Optional[str] = None,\n    exclude_layers: Optional[List[str]] = None,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a ControlGrid with all default tools or a custom subset.\n\n    The ControlGrid provides a collapsible toolbar with up to 26 built-in\n    controls (search, basemap, terrain, measure, draw, etc.) in a\n    configurable grid layout.\n\n    Args:\n        position: Control position ('top-left', 'top-right', 'bottom-left',\n            'bottom-right').\n        default_controls: Explicit list of control names to include. If None,\n            all 26 default controls are used (minus any in ``exclude``).\n            Valid names: 'globe', 'fullscreen', 'north', 'terrain', 'search',\n            'viewState', 'inspect', 'vectorDataset', 'basemap', 'measure',\n            'geoEditor', 'bookmark', 'print', 'minimap', 'swipe',\n            'streetView', 'addVector', 'cogLayer', 'zarrLayer',\n            'pmtilesLayer', 'stacLayer', 'stacSearch', 'planetaryComputer',\n            'gaussianSplat', 'lidar', 'usgsLidar'.\n        exclude: Controls to remove from the default set. Ignored when\n            ``default_controls`` is provided.\n        rows: Number of grid rows (auto-calculated if None).\n        columns: Number of grid columns (auto-calculated if None).\n        collapsed: Whether the grid starts collapsed. Default True.\n        collapsible: Whether the grid can be collapsed. Default True.\n        title: Optional header title for the grid.\n        show_row_column_controls: Show row/column input fields. Default True.\n        gap: Gap between grid cells in pixels. Default 2.\n        basemap_style_url: Basemap style URL for SwipeControl layer grouping.\n            If None, the current map style is used automatically.\n        exclude_layers: Layer ID patterns to exclude from SwipeControl\n            (e.g., 'measure-*', 'gl-draw-*'). If None, sensible defaults\n            are applied.\n        **kwargs: Additional ControlGrid options.\n\n    Example:\n        &gt;&gt;&gt; from anymap_ts import MapLibreMap\n        &gt;&gt;&gt; m = MapLibreMap()\n        &gt;&gt;&gt; m.add_control_grid()  # All 26 controls\n        &gt;&gt;&gt; # Or with customization:\n        &gt;&gt;&gt; m.add_control_grid(\n        ...     exclude=[\"minimap\", \"streetView\"],\n        ...     collapsed=True,\n        ... )\n    \"\"\"\n    js_kwargs: Dict[str, Any] = {\n        \"position\": position,\n        \"collapsed\": collapsed,\n        \"collapsible\": collapsible,\n        \"showRowColumnControls\": show_row_column_controls,\n        \"gap\": gap,\n        **kwargs,\n    }\n    if default_controls is not None:\n        js_kwargs[\"defaultControls\"] = default_controls\n    if exclude is not None:\n        js_kwargs[\"exclude\"] = exclude\n    if rows is not None:\n        js_kwargs[\"rows\"] = rows\n    if columns is not None:\n        js_kwargs[\"columns\"] = columns\n    if title:\n        js_kwargs[\"title\"] = title\n    if basemap_style_url is not None:\n        js_kwargs[\"basemapStyleUrl\"] = basemap_style_url\n    if exclude_layers is not None:\n        js_kwargs[\"excludeLayers\"] = exclude_layers\n\n    self.call_js_method(\"addControlGrid\", **js_kwargs)\n    self._controls = {\n        **self._controls,\n        \"control-grid\": {\"position\": position, \"collapsed\": collapsed},\n    }\n</code></pre>"},{"location":"maplibre/#anymap_ts.maplibre.MapLibreMap.add_draw_control","title":"<code>add_draw_control(self, position='top-right', draw_modes=None, edit_modes=None, collapsed=False, **kwargs)</code>","text":"<p>Add a drawing control using maplibre-gl-geo-editor.</p> <p>Parameters:</p> Name Type Description Default <code>position</code> <code>str</code> <p>Control position</p> <code>'top-right'</code> <code>draw_modes</code> <code>Optional[List[str]]</code> <p>Drawing modes to enable (e.g., ['polygon', 'line', 'marker'])</p> <code>None</code> <code>edit_modes</code> <code>Optional[List[str]]</code> <p>Edit modes to enable (e.g., ['select', 'drag', 'delete'])</p> <code>None</code> <code>collapsed</code> <code>bool</code> <p>Whether control starts collapsed</p> <code>False</code> <code>**kwargs</code> <p>Additional geo-editor options</p> <code>{}</code> Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def add_draw_control(\n    self,\n    position: str = \"top-right\",\n    draw_modes: Optional[List[str]] = None,\n    edit_modes: Optional[List[str]] = None,\n    collapsed: bool = False,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a drawing control using maplibre-gl-geo-editor.\n\n    Args:\n        position: Control position\n        draw_modes: Drawing modes to enable (e.g., ['polygon', 'line', 'marker'])\n        edit_modes: Edit modes to enable (e.g., ['select', 'drag', 'delete'])\n        collapsed: Whether control starts collapsed\n        **kwargs: Additional geo-editor options\n    \"\"\"\n    if draw_modes is None:\n        draw_modes = [\"polygon\", \"line\", \"rectangle\", \"circle\", \"marker\"]\n    if edit_modes is None:\n        edit_modes = [\"select\", \"drag\", \"change\", \"rotate\", \"delete\"]\n\n    self.call_js_method(\n        \"addDrawControl\",\n        position=position,\n        drawModes=draw_modes,\n        editModes=edit_modes,\n        collapsed=collapsed,\n        **kwargs,\n    )\n    self._controls = {\n        **self._controls,\n        \"draw-control\": {\n            \"position\": position,\n            \"drawModes\": draw_modes,\n            \"editModes\": edit_modes,\n        },\n    }\n</code></pre>"},{"location":"maplibre/#anymap_ts.maplibre.MapLibreMap.add_geojson","title":"<code>add_geojson(self, data, layer_type=None, paint=None, name=None, fit_bounds=True, **kwargs)</code>","text":"<p>Add GeoJSON data to the map.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Union[str, Dict]</code> <p>GeoJSON dict or URL to GeoJSON file</p> required <code>layer_type</code> <code>Optional[str]</code> <p>MapLibre layer type</p> <code>None</code> <code>paint</code> <code>Optional[Dict]</code> <p>MapLibre paint properties</p> <code>None</code> <code>name</code> <code>Optional[str]</code> <p>Layer name</p> <code>None</code> <code>fit_bounds</code> <code>bool</code> <p>Whether to fit map to data bounds</p> <code>True</code> <code>**kwargs</code> <p>Additional layer options</p> <code>{}</code> Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def add_geojson(\n    self,\n    data: Union[str, Dict],\n    layer_type: Optional[str] = None,\n    paint: Optional[Dict] = None,\n    name: Optional[str] = None,\n    fit_bounds: bool = True,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add GeoJSON data to the map.\n\n    Args:\n        data: GeoJSON dict or URL to GeoJSON file\n        layer_type: MapLibre layer type\n        paint: MapLibre paint properties\n        name: Layer name\n        fit_bounds: Whether to fit map to data bounds\n        **kwargs: Additional layer options\n    \"\"\"\n    self.add_vector(\n        data,\n        layer_type=layer_type,\n        paint=paint,\n        name=name,\n        fit_bounds=fit_bounds,\n        **kwargs,\n    )\n</code></pre>"},{"location":"maplibre/#anymap_ts.maplibre.MapLibreMap.add_layer","title":"<code>add_layer(self, layer_id, layer_type, source, paint=None, layout=None, before_id=None, **kwargs)</code>","text":"<p>Add a generic layer to the map.</p> <p>Parameters:</p> Name Type Description Default <code>layer_id</code> <code>str</code> <p>Unique layer identifier</p> required <code>layer_type</code> <code>str</code> <p>MapLibre layer type</p> required <code>source</code> <code>Union[str, Dict]</code> <p>Source ID or source configuration dict</p> required <code>paint</code> <code>Optional[Dict]</code> <p>Paint properties</p> <code>None</code> <code>layout</code> <code>Optional[Dict]</code> <p>Layout properties</p> <code>None</code> <code>before_id</code> <code>Optional[str]</code> <p>ID of layer to insert before</p> <code>None</code> <code>**kwargs</code> <p>Additional layer options</p> <code>{}</code> Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def add_layer(\n    self,\n    layer_id: str,\n    layer_type: str,\n    source: Union[str, Dict],\n    paint: Optional[Dict] = None,\n    layout: Optional[Dict] = None,\n    before_id: Optional[str] = None,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a generic layer to the map.\n\n    Args:\n        layer_id: Unique layer identifier\n        layer_type: MapLibre layer type\n        source: Source ID or source configuration dict\n        paint: Paint properties\n        layout: Layout properties\n        before_id: ID of layer to insert before\n        **kwargs: Additional layer options\n    \"\"\"\n    layer_config = {\n        \"id\": layer_id,\n        \"type\": layer_type,\n        \"paint\": paint or {},\n        \"layout\": layout or {},\n        **kwargs,\n    }\n\n    if isinstance(source, str):\n        layer_config[\"source\"] = source\n    else:\n        source_id = f\"{layer_id}-source\"\n        self._sources = {**self._sources, source_id: source}\n        self.call_js_method(\"addSource\", source_id, **source)\n        layer_config[\"source\"] = source_id\n\n    self._layers = {**self._layers, layer_id: layer_config}\n    self.call_js_method(\"addLayer\", beforeId=before_id, **layer_config)\n</code></pre>"},{"location":"maplibre/#anymap_ts.maplibre.MapLibreMap.add_layer_control","title":"<code>add_layer_control(self, layers=None, position='top-right', collapsed=True)</code>","text":"<p>Add a layer visibility control.</p> <p>Uses maplibre-gl-layer-control for layer toggling and opacity.</p> <p>Parameters:</p> Name Type Description Default <code>layers</code> <code>Optional[List[str]]</code> <p>List of layer IDs to include (None = all layers)</p> <code>None</code> <code>position</code> <code>str</code> <p>Control position</p> <code>'top-right'</code> <code>collapsed</code> <code>bool</code> <p>Whether control starts collapsed</p> <code>True</code> Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def add_layer_control(\n    self,\n    layers: Optional[List[str]] = None,\n    position: str = \"top-right\",\n    collapsed: bool = True,\n) -&gt; None:\n    \"\"\"Add a layer visibility control.\n\n    Uses maplibre-gl-layer-control for layer toggling and opacity.\n\n    Args:\n        layers: List of layer IDs to include (None = all layers)\n        position: Control position\n        collapsed: Whether control starts collapsed\n    \"\"\"\n    if layers is None:\n        layers = list(self._layers.keys())\n\n    self.call_js_method(\n        \"addLayerControl\",\n        layers=layers,\n        position=position,\n        collapsed=collapsed,\n    )\n    self._controls = {\n        **self._controls,\n        \"layer-control\": {\"layers\": layers, \"position\": position},\n    }\n</code></pre>"},{"location":"maplibre/#anymap_ts.maplibre.MapLibreMap.add_lidar_control","title":"<code>add_lidar_control(self, position='top-right', collapsed=True, title='LiDAR Viewer', point_size=2, opacity=1.0, color_scheme='elevation', use_percentile=True, point_budget=1000000, pickable=False, auto_zoom=True, copc_loading_mode=None, streaming_point_budget=5000000, panel_max_height=600, **kwargs)</code>","text":"<p>Add an interactive LiDAR control panel.</p> <p>The LiDAR control provides a UI panel for loading, visualizing, and styling LiDAR point cloud files (LAS, LAZ, COPC formats).</p> <p>Parameters:</p> Name Type Description Default <code>position</code> <code>str</code> <p>Control position ('top-left', 'top-right', 'bottom-left', 'bottom-right').</p> <code>'top-right'</code> <code>collapsed</code> <code>bool</code> <p>Whether the panel starts collapsed.</p> <code>True</code> <code>title</code> <code>str</code> <p>Title displayed on the panel.</p> <code>'LiDAR Viewer'</code> <code>point_size</code> <code>float</code> <p>Point size in pixels.</p> <code>2</code> <code>opacity</code> <code>float</code> <p>Layer opacity (0-1).</p> <code>1.0</code> <code>color_scheme</code> <code>str</code> <p>Color scheme ('elevation', 'intensity', 'classification', 'rgb').</p> <code>'elevation'</code> <code>use_percentile</code> <code>bool</code> <p>Use 2-98% percentile for color scaling.</p> <code>True</code> <code>point_budget</code> <code>int</code> <p>Maximum number of points to display.</p> <code>1000000</code> <code>pickable</code> <code>bool</code> <p>Enable hover/click interactions.</p> <code>False</code> <code>auto_zoom</code> <code>bool</code> <p>Auto-zoom to point cloud after loading.</p> <code>True</code> <code>copc_loading_mode</code> <code>Optional[str]</code> <p>COPC loading mode ('full' or 'dynamic').</p> <code>None</code> <code>streaming_point_budget</code> <code>int</code> <p>Point budget for streaming mode.</p> <code>5000000</code> <code>panel_max_height</code> <code>int</code> <p>Maximum height of the panel in pixels.</p> <code>600</code> <code>**kwargs</code> <p>Additional control options.</p> <code>{}</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from anymap_ts import MapLibreMap\n&gt;&gt;&gt; m = MapLibreMap(pitch=60)\n&gt;&gt;&gt; m.add_lidar_control(color_scheme=\"classification\", pickable=True)\n</code></pre> Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def add_lidar_control(\n    self,\n    position: str = \"top-right\",\n    collapsed: bool = True,\n    title: str = \"LiDAR Viewer\",\n    point_size: float = 2,\n    opacity: float = 1.0,\n    color_scheme: str = \"elevation\",\n    use_percentile: bool = True,\n    point_budget: int = 1000000,\n    pickable: bool = False,\n    auto_zoom: bool = True,\n    copc_loading_mode: Optional[str] = None,\n    streaming_point_budget: int = 5000000,\n    panel_max_height: int = 600,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add an interactive LiDAR control panel.\n\n    The LiDAR control provides a UI panel for loading, visualizing, and\n    styling LiDAR point cloud files (LAS, LAZ, COPC formats).\n\n    Args:\n        position: Control position ('top-left', 'top-right', 'bottom-left', 'bottom-right').\n        collapsed: Whether the panel starts collapsed.\n        title: Title displayed on the panel.\n        point_size: Point size in pixels.\n        opacity: Layer opacity (0-1).\n        color_scheme: Color scheme ('elevation', 'intensity', 'classification', 'rgb').\n        use_percentile: Use 2-98% percentile for color scaling.\n        point_budget: Maximum number of points to display.\n        pickable: Enable hover/click interactions.\n        auto_zoom: Auto-zoom to point cloud after loading.\n        copc_loading_mode: COPC loading mode ('full' or 'dynamic').\n        streaming_point_budget: Point budget for streaming mode.\n        panel_max_height: Maximum height of the panel in pixels.\n        **kwargs: Additional control options.\n\n    Example:\n        &gt;&gt;&gt; from anymap_ts import MapLibreMap\n        &gt;&gt;&gt; m = MapLibreMap(pitch=60)\n        &gt;&gt;&gt; m.add_lidar_control(color_scheme=\"classification\", pickable=True)\n    \"\"\"\n    self.call_js_method(\n        \"addLidarControl\",\n        position=position,\n        collapsed=collapsed,\n        title=title,\n        pointSize=point_size,\n        opacity=opacity,\n        colorScheme=color_scheme,\n        usePercentile=use_percentile,\n        pointBudget=point_budget,\n        pickable=pickable,\n        autoZoom=auto_zoom,\n        copcLoadingMode=copc_loading_mode,\n        streamingPointBudget=streaming_point_budget,\n        panelMaxHeight=panel_max_height,\n        **kwargs,\n    )\n    self._controls = {\n        **self._controls,\n        \"lidar-control\": {\"position\": position, \"collapsed\": collapsed},\n    }\n</code></pre>"},{"location":"maplibre/#anymap_ts.maplibre.MapLibreMap.add_lidar_layer","title":"<code>add_lidar_layer(self, source, name=None, color_scheme='elevation', point_size=2, opacity=1.0, pickable=True, auto_zoom=True, streaming_mode=True, point_budget=1000000, **kwargs)</code>","text":"<p>Load and display a LiDAR file from URL or local path.</p> <p>Supports LAS, LAZ, and COPC (Cloud-Optimized Point Cloud) formats. For local files, the file is read and sent as base64 to JavaScript. For URLs, the data is loaded directly via streaming when possible.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>Union[str, Path]</code> <p>URL or local file path to the LiDAR file.</p> required <code>name</code> <code>Optional[str]</code> <p>Layer identifier. If None, auto-generated.</p> <code>None</code> <code>color_scheme</code> <code>str</code> <p>Color scheme ('elevation', 'intensity', 'classification', 'rgb').</p> <code>'elevation'</code> <code>point_size</code> <code>float</code> <p>Point size in pixels.</p> <code>2</code> <code>opacity</code> <code>float</code> <p>Layer opacity (0-1).</p> <code>1.0</code> <code>pickable</code> <code>bool</code> <p>Enable hover/click interactions.</p> <code>True</code> <code>auto_zoom</code> <code>bool</code> <p>Auto-zoom to point cloud after loading.</p> <code>True</code> <code>streaming_mode</code> <code>bool</code> <p>Use streaming mode for large COPC files.</p> <code>True</code> <code>point_budget</code> <code>int</code> <p>Maximum number of points to display.</p> <code>1000000</code> <code>**kwargs</code> <p>Additional layer options.</p> <code>{}</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from anymap_ts import MapLibreMap\n&gt;&gt;&gt; m = MapLibreMap(center=[-123.07, 44.05], zoom=14, pitch=60)\n&gt;&gt;&gt; m.add_lidar_layer(\n...     source=\"https://s3.amazonaws.com/hobu-lidar/autzen-classified.copc.laz\",\n...     name=\"autzen\",\n...     color_scheme=\"classification\",\n... )\n</code></pre> Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def add_lidar_layer(\n    self,\n    source: Union[str, Path],\n    name: Optional[str] = None,\n    color_scheme: str = \"elevation\",\n    point_size: float = 2,\n    opacity: float = 1.0,\n    pickable: bool = True,\n    auto_zoom: bool = True,\n    streaming_mode: bool = True,\n    point_budget: int = 1000000,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Load and display a LiDAR file from URL or local path.\n\n    Supports LAS, LAZ, and COPC (Cloud-Optimized Point Cloud) formats.\n    For local files, the file is read and sent as base64 to JavaScript.\n    For URLs, the data is loaded directly via streaming when possible.\n\n    Args:\n        source: URL or local file path to the LiDAR file.\n        name: Layer identifier. If None, auto-generated.\n        color_scheme: Color scheme ('elevation', 'intensity', 'classification', 'rgb').\n        point_size: Point size in pixels.\n        opacity: Layer opacity (0-1).\n        pickable: Enable hover/click interactions.\n        auto_zoom: Auto-zoom to point cloud after loading.\n        streaming_mode: Use streaming mode for large COPC files.\n        point_budget: Maximum number of points to display.\n        **kwargs: Additional layer options.\n\n    Example:\n        &gt;&gt;&gt; from anymap_ts import MapLibreMap\n        &gt;&gt;&gt; m = MapLibreMap(center=[-123.07, 44.05], zoom=14, pitch=60)\n        &gt;&gt;&gt; m.add_lidar_layer(\n        ...     source=\"https://s3.amazonaws.com/hobu-lidar/autzen-classified.copc.laz\",\n        ...     name=\"autzen\",\n        ...     color_scheme=\"classification\",\n        ... )\n    \"\"\"\n    layer_id = name or f\"lidar-{len(self._layers)}\"\n\n    # Check if source is a local file\n    source_path = Path(source) if isinstance(source, (str, Path)) else None\n    is_local = source_path is not None and source_path.exists()\n\n    if is_local:\n        # Read local file and encode as base64\n        import base64\n\n        with open(source_path, \"rb\") as f:\n            file_data = f.read()\n        source_b64 = base64.b64encode(file_data).decode(\"utf-8\")\n\n        self.call_js_method(\n            \"addLidarLayer\",\n            source=source_b64,\n            name=layer_id,\n            isBase64=True,\n            filename=source_path.name,\n            colorScheme=color_scheme,\n            pointSize=point_size,\n            opacity=opacity,\n            pickable=pickable,\n            autoZoom=auto_zoom,\n            streamingMode=streaming_mode,\n            pointBudget=point_budget,\n            **kwargs,\n        )\n    else:\n        # Load from URL\n        self.call_js_method(\n            \"addLidarLayer\",\n            source=str(source),\n            name=layer_id,\n            isBase64=False,\n            colorScheme=color_scheme,\n            pointSize=point_size,\n            opacity=opacity,\n            pickable=pickable,\n            autoZoom=auto_zoom,\n            streamingMode=streaming_mode,\n            pointBudget=point_budget,\n            **kwargs,\n        )\n\n    self._layers = {\n        **self._layers,\n        layer_id: {\n            \"id\": layer_id,\n            \"type\": \"lidar\",\n            \"source\": str(source),\n        },\n    }\n</code></pre>"},{"location":"maplibre/#anymap_ts.maplibre.MapLibreMap.add_pmtiles_control","title":"<code>add_pmtiles_control(self, position='top-right', collapsed=True, default_url=None, load_default_url=False, default_opacity=1.0, default_fill_color='steelblue', default_line_color='#333', default_pickable=True, **kwargs)</code>","text":"<p>Add a PMTiles layer control for loading PMTiles files via UI.</p> <p>This provides an interactive panel for users to enter PMTiles URLs and visualize vector or raster tile data.</p> <p>Parameters:</p> Name Type Description Default <code>position</code> <code>str</code> <p>Control position ('top-left', 'top-right', 'bottom-left', 'bottom-right').</p> <code>'top-right'</code> <code>collapsed</code> <code>bool</code> <p>Whether the panel starts collapsed.</p> <code>True</code> <code>default_url</code> <code>Optional[str]</code> <p>Default PMTiles URL to pre-fill.</p> <code>None</code> <code>load_default_url</code> <code>bool</code> <p>Whether to auto-load the default URL.</p> <code>False</code> <code>default_opacity</code> <code>float</code> <p>Default layer opacity (0-1).</p> <code>1.0</code> <code>default_fill_color</code> <code>str</code> <p>Default fill color for vector polygons.</p> <code>'steelblue'</code> <code>default_line_color</code> <code>str</code> <p>Default line color for vector lines.</p> <code>'#333'</code> <code>default_pickable</code> <code>bool</code> <p>Whether features are clickable by default.</p> <code>True</code> <code>**kwargs</code> <p>Additional control options.</p> <code>{}</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from anymap_ts import MapLibreMap\n&gt;&gt;&gt; m = MapLibreMap()\n&gt;&gt;&gt; m.add_pmtiles_control(\n...     default_url=\"https://pmtiles.io/protomaps(vector)ODbL_firenze.pmtiles\",\n...     load_default_url=True\n... )\n</code></pre> Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def add_pmtiles_control(\n    self,\n    position: str = \"top-right\",\n    collapsed: bool = True,\n    default_url: Optional[str] = None,\n    load_default_url: bool = False,\n    default_opacity: float = 1.0,\n    default_fill_color: str = \"steelblue\",\n    default_line_color: str = \"#333\",\n    default_pickable: bool = True,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a PMTiles layer control for loading PMTiles files via UI.\n\n    This provides an interactive panel for users to enter PMTiles URLs\n    and visualize vector or raster tile data.\n\n    Args:\n        position: Control position ('top-left', 'top-right', 'bottom-left', 'bottom-right').\n        collapsed: Whether the panel starts collapsed.\n        default_url: Default PMTiles URL to pre-fill.\n        load_default_url: Whether to auto-load the default URL.\n        default_opacity: Default layer opacity (0-1).\n        default_fill_color: Default fill color for vector polygons.\n        default_line_color: Default line color for vector lines.\n        default_pickable: Whether features are clickable by default.\n        **kwargs: Additional control options.\n\n    Example:\n        &gt;&gt;&gt; from anymap_ts import MapLibreMap\n        &gt;&gt;&gt; m = MapLibreMap()\n        &gt;&gt;&gt; m.add_pmtiles_control(\n        ...     default_url=\"https://pmtiles.io/protomaps(vector)ODbL_firenze.pmtiles\",\n        ...     load_default_url=True\n        ... )\n    \"\"\"\n    self.call_js_method(\n        \"addPMTilesControl\",\n        position=position,\n        collapsed=collapsed,\n        defaultUrl=default_url or \"\",\n        loadDefaultUrl=load_default_url,\n        defaultOpacity=default_opacity,\n        defaultFillColor=default_fill_color,\n        defaultLineColor=default_line_color,\n        defaultPickable=default_pickable,\n        **kwargs,\n    )\n    self._controls = {\n        **self._controls,\n        \"pmtiles-control\": {\"position\": position, \"collapsed\": collapsed},\n    }\n</code></pre>"},{"location":"maplibre/#anymap_ts.maplibre.MapLibreMap.add_point_cloud_layer","title":"<code>add_point_cloud_layer(self, data, name=None, get_position='position', get_color=None, get_normal=None, point_size=2, size_units='pixels', pickable=True, opacity=1.0, material=True, coordinate_system=None, coordinate_origin=None, **kwargs)</code>","text":"<p>Add a point cloud layer for 3D point visualization using deck.gl.</p> <p>Point cloud layers render large collections of 3D points, ideal for LiDAR data, photogrammetry outputs, or any 3D point dataset.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>Array of point data with positions. Each point should have x, y, z coordinates (or position array).</p> required <code>name</code> <code>Optional[str]</code> <p>Layer ID. If None, auto-generated.</p> <code>None</code> <code>get_position</code> <code>Union[str, Any]</code> <p>Accessor for point position [x, y, z]. Can be a string (property name) or a value.</p> <code>'position'</code> <code>get_color</code> <code>Optional[Union[List[int], str]]</code> <p>Accessor or value for point color [r, g, b, a]. Default: [255, 255, 255, 255] (white).</p> <code>None</code> <code>get_normal</code> <code>Optional[Union[str, Any]]</code> <p>Accessor for point normal [nx, ny, nz] for lighting. Default: [0, 0, 1] (pointing up).</p> <code>None</code> <code>point_size</code> <code>float</code> <p>Point size in pixels or meters (depends on size_units).</p> <code>2</code> <code>size_units</code> <code>str</code> <p>Size units: 'pixels', 'meters', or 'common'.</p> <code>'pixels'</code> <code>pickable</code> <code>bool</code> <p>Whether layer responds to hover/click events.</p> <code>True</code> <code>opacity</code> <code>float</code> <p>Layer opacity (0-1).</p> <code>1.0</code> <code>material</code> <code>bool</code> <p>Whether to enable lighting effects.</p> <code>True</code> <code>coordinate_system</code> <code>Optional[int]</code> <p>Coordinate system for positions.</p> <code>None</code> <code>coordinate_origin</code> <code>Optional[List[float]]</code> <p>Origin for coordinate system [x, y, z].</p> <code>None</code> <code>**kwargs</code> <p>Additional PointCloudLayer props.</p> <code>{}</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from anymap_ts import MapLibreMap\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; m = MapLibreMap(pitch=45)\n&gt;&gt;&gt; points = [\n...     {\"position\": [-122.4, 37.8, 100], \"color\": [255, 0, 0, 255]},\n...     {\"position\": [-122.3, 37.7, 200], \"color\": [0, 255, 0, 255]},\n... ]\n&gt;&gt;&gt; m.add_point_cloud_layer(points, point_size=5)\n</code></pre> Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def add_point_cloud_layer(\n    self,\n    data: Any,\n    name: Optional[str] = None,\n    get_position: Union[str, Any] = \"position\",\n    get_color: Optional[Union[List[int], str]] = None,\n    get_normal: Optional[Union[str, Any]] = None,\n    point_size: float = 2,\n    size_units: str = \"pixels\",\n    pickable: bool = True,\n    opacity: float = 1.0,\n    material: bool = True,\n    coordinate_system: Optional[int] = None,\n    coordinate_origin: Optional[List[float]] = None,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a point cloud layer for 3D point visualization using deck.gl.\n\n    Point cloud layers render large collections of 3D points, ideal for\n    LiDAR data, photogrammetry outputs, or any 3D point dataset.\n\n    Args:\n        data: Array of point data with positions. Each point should have\n            x, y, z coordinates (or position array).\n        name: Layer ID. If None, auto-generated.\n        get_position: Accessor for point position [x, y, z].\n            Can be a string (property name) or a value.\n        get_color: Accessor or value for point color [r, g, b, a].\n            Default: [255, 255, 255, 255] (white).\n        get_normal: Accessor for point normal [nx, ny, nz] for lighting.\n            Default: [0, 0, 1] (pointing up).\n        point_size: Point size in pixels or meters (depends on size_units).\n        size_units: Size units: 'pixels', 'meters', or 'common'.\n        pickable: Whether layer responds to hover/click events.\n        opacity: Layer opacity (0-1).\n        material: Whether to enable lighting effects.\n        coordinate_system: Coordinate system for positions.\n        coordinate_origin: Origin for coordinate system [x, y, z].\n        **kwargs: Additional PointCloudLayer props.\n\n    Example:\n        &gt;&gt;&gt; from anymap_ts import MapLibreMap\n        &gt;&gt;&gt; import numpy as np\n        &gt;&gt;&gt; m = MapLibreMap(pitch=45)\n        &gt;&gt;&gt; points = [\n        ...     {\"position\": [-122.4, 37.8, 100], \"color\": [255, 0, 0, 255]},\n        ...     {\"position\": [-122.3, 37.7, 200], \"color\": [0, 255, 0, 255]},\n        ... ]\n        &gt;&gt;&gt; m.add_point_cloud_layer(points, point_size=5)\n    \"\"\"\n    layer_id = name or f\"pointcloud-{len(self._layers)}\"\n    processed_data = self._process_deck_data(data)\n\n    self.call_js_method(\n        \"addPointCloudLayer\",\n        id=layer_id,\n        data=processed_data,\n        getPosition=get_position,\n        getColor=get_color or [255, 255, 255, 255],\n        getNormal=get_normal,\n        pointSize=point_size,\n        sizeUnits=size_units,\n        pickable=pickable,\n        opacity=opacity,\n        material=material,\n        coordinateSystem=coordinate_system,\n        coordinateOrigin=coordinate_origin,\n        **kwargs,\n    )\n\n    self._layers = {\n        **self._layers,\n        layer_id: {\n            \"id\": layer_id,\n            \"type\": \"pointcloud\",\n        },\n    }\n</code></pre>"},{"location":"maplibre/#anymap_ts.maplibre.MapLibreMap.add_raster","title":"<code>add_raster(self, source, name=None, attribution='', indexes=None, colormap=None, vmin=None, vmax=None, nodata=None, fit_bounds=True, **kwargs)</code>","text":"<p>Add a raster layer from a local file using localtileserver.</p> <p>Parameters:</p> Name Type Description Default <code>source</code> <code>str</code> <p>Path to local raster file</p> required <code>name</code> <code>Optional[str]</code> <p>Layer name</p> <code>None</code> <code>attribution</code> <code>str</code> <p>Attribution text</p> <code>''</code> <code>indexes</code> <code>Optional[List[int]]</code> <p>Band indexes to use</p> <code>None</code> <code>colormap</code> <code>Optional[str]</code> <p>Colormap name</p> <code>None</code> <code>vmin</code> <code>Optional[float]</code> <p>Minimum value for colormap</p> <code>None</code> <code>vmax</code> <code>Optional[float]</code> <p>Maximum value for colormap</p> <code>None</code> <code>nodata</code> <code>Optional[float]</code> <p>NoData value</p> <code>None</code> <code>fit_bounds</code> <code>bool</code> <p>Whether to fit map to raster bounds</p> <code>True</code> <code>**kwargs</code> <p>Additional options</p> <code>{}</code> Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def add_raster(\n    self,\n    source: str,\n    name: Optional[str] = None,\n    attribution: str = \"\",\n    indexes: Optional[List[int]] = None,\n    colormap: Optional[str] = None,\n    vmin: Optional[float] = None,\n    vmax: Optional[float] = None,\n    nodata: Optional[float] = None,\n    fit_bounds: bool = True,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a raster layer from a local file using localtileserver.\n\n    Args:\n        source: Path to local raster file\n        name: Layer name\n        attribution: Attribution text\n        indexes: Band indexes to use\n        colormap: Colormap name\n        vmin: Minimum value for colormap\n        vmax: Maximum value for colormap\n        nodata: NoData value\n        fit_bounds: Whether to fit map to raster bounds\n        **kwargs: Additional options\n    \"\"\"\n    try:\n        from localtileserver import TileClient\n    except ImportError:\n        raise ImportError(\n            \"localtileserver is required for local raster support. \"\n            \"Install with: pip install anymap-ts[raster]\"\n        )\n\n    client = TileClient(source)\n\n    # Build tile URL with parameters\n    tile_url = client.get_tile_url()\n    if indexes:\n        tile_url = client.get_tile_url(indexes=indexes)\n    if colormap:\n        tile_url = client.get_tile_url(colormap=colormap)\n    if vmin is not None or vmax is not None:\n        tile_url = client.get_tile_url(\n            vmin=vmin or client.min, vmax=vmax or client.max\n        )\n    if nodata is not None:\n        tile_url = client.get_tile_url(nodata=nodata)\n\n    layer_name = name or Path(source).stem\n\n    self.add_tile_layer(\n        tile_url,\n        name=layer_name,\n        attribution=attribution,\n        **kwargs,\n    )\n\n    # Fit bounds if requested\n    if fit_bounds:\n        bounds = client.bounds()\n        if bounds:\n            self.fit_bounds([bounds[0], bounds[1], bounds[2], bounds[3]])\n</code></pre>"},{"location":"maplibre/#anymap_ts.maplibre.MapLibreMap.add_tile_layer","title":"<code>add_tile_layer(self, url, name=None, attribution='', min_zoom=0, max_zoom=22, **kwargs)</code>","text":"<p>Add an XYZ tile layer.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>Tile URL template with {x}, {y}, {z} placeholders</p> required <code>name</code> <code>Optional[str]</code> <p>Layer name</p> <code>None</code> <code>attribution</code> <code>str</code> <p>Attribution text</p> <code>''</code> <code>min_zoom</code> <code>int</code> <p>Minimum zoom level</p> <code>0</code> <code>max_zoom</code> <code>int</code> <p>Maximum zoom level</p> <code>22</code> <code>**kwargs</code> <p>Additional options</p> <code>{}</code> Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def add_tile_layer(\n    self,\n    url: str,\n    name: Optional[str] = None,\n    attribution: str = \"\",\n    min_zoom: int = 0,\n    max_zoom: int = 22,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add an XYZ tile layer.\n\n    Args:\n        url: Tile URL template with {x}, {y}, {z} placeholders\n        name: Layer name\n        attribution: Attribution text\n        min_zoom: Minimum zoom level\n        max_zoom: Maximum zoom level\n        **kwargs: Additional options\n    \"\"\"\n    layer_id = name or f\"tiles-{len(self._layers)}\"\n\n    self.call_js_method(\n        \"addTileLayer\",\n        url,\n        name=layer_id,\n        attribution=attribution,\n        minZoom=min_zoom,\n        maxZoom=max_zoom,\n        **kwargs,\n    )\n\n    # Track layer\n    self._layers = {\n        **self._layers,\n        layer_id: {\n            \"id\": layer_id,\n            \"type\": \"raster\",\n            \"source\": f\"{layer_id}-source\",\n        },\n    }\n</code></pre>"},{"location":"maplibre/#anymap_ts.maplibre.MapLibreMap.add_vector","title":"<code>add_vector(self, data, layer_type=None, paint=None, name=None, fit_bounds=True, **kwargs)</code>","text":"<p>Add vector data to the map.</p> <p>Supports GeoJSON, GeoDataFrame, or file paths to vector formats.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>GeoJSON dict, GeoDataFrame, or path to vector file</p> required <code>layer_type</code> <code>Optional[str]</code> <p>MapLibre layer type ('circle', 'line', 'fill', 'symbol')</p> <code>None</code> <code>paint</code> <code>Optional[Dict]</code> <p>MapLibre paint properties</p> <code>None</code> <code>name</code> <code>Optional[str]</code> <p>Layer name</p> <code>None</code> <code>fit_bounds</code> <code>bool</code> <p>Whether to fit map to data bounds</p> <code>True</code> <code>**kwargs</code> <p>Additional layer options</p> <code>{}</code> Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def add_vector(\n    self,\n    data: Any,\n    layer_type: Optional[str] = None,\n    paint: Optional[Dict] = None,\n    name: Optional[str] = None,\n    fit_bounds: bool = True,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add vector data to the map.\n\n    Supports GeoJSON, GeoDataFrame, or file paths to vector formats.\n\n    Args:\n        data: GeoJSON dict, GeoDataFrame, or path to vector file\n        layer_type: MapLibre layer type ('circle', 'line', 'fill', 'symbol')\n        paint: MapLibre paint properties\n        name: Layer name\n        fit_bounds: Whether to fit map to data bounds\n        **kwargs: Additional layer options\n    \"\"\"\n    geojson = to_geojson(data)\n\n    # Handle URL data\n    if geojson.get(\"type\") == \"url\":\n        self.add_geojson(\n            geojson[\"url\"],\n            layer_type=layer_type,\n            paint=paint,\n            name=name,\n            fit_bounds=fit_bounds,\n            **kwargs,\n        )\n        return\n\n    layer_id = name or f\"vector-{len(self._layers)}\"\n\n    # Infer layer type if not specified\n    if layer_type is None:\n        layer_type = infer_layer_type(geojson)\n\n    # Get default paint if not provided\n    if paint is None:\n        paint = get_default_paint(layer_type)\n\n    # Get bounds\n    bounds = get_bounds(data) if fit_bounds else None\n\n    # Call JavaScript\n    self.call_js_method(\n        \"addGeoJSON\",\n        data=geojson,\n        name=layer_id,\n        layerType=layer_type,\n        paint=paint,\n        fitBounds=fit_bounds,\n        bounds=bounds,\n        **kwargs,\n    )\n\n    # Track layer\n    self._layers = {\n        **self._layers,\n        layer_id: {\n            \"id\": layer_id,\n            \"type\": layer_type,\n            \"source\": f\"{layer_id}-source\",\n            \"paint\": paint,\n        },\n    }\n</code></pre>"},{"location":"maplibre/#anymap_ts.maplibre.MapLibreMap.add_vector_control","title":"<code>add_vector_control(self, position='top-right', collapsed=True, default_url=None, load_default_url=False, default_opacity=1.0, default_fill_color='#3388ff', default_stroke_color='#3388ff', fit_bounds=True, **kwargs)</code>","text":"<p>Add a vector layer control for loading vector datasets from URLs.</p> <p>This provides an interactive panel for users to enter URLs to GeoJSON, GeoParquet, or FlatGeobuf datasets.</p> <p>Parameters:</p> Name Type Description Default <code>position</code> <code>str</code> <p>Control position ('top-left', 'top-right', 'bottom-left', 'bottom-right').</p> <code>'top-right'</code> <code>collapsed</code> <code>bool</code> <p>Whether the panel starts collapsed.</p> <code>True</code> <code>default_url</code> <code>Optional[str]</code> <p>Default vector URL to pre-fill.</p> <code>None</code> <code>load_default_url</code> <code>bool</code> <p>Whether to auto-load the default URL.</p> <code>False</code> <code>default_opacity</code> <code>float</code> <p>Default layer opacity (0-1).</p> <code>1.0</code> <code>default_fill_color</code> <code>str</code> <p>Default fill color for polygons.</p> <code>'#3388ff'</code> <code>default_stroke_color</code> <code>str</code> <p>Default stroke color for lines/outlines.</p> <code>'#3388ff'</code> <code>fit_bounds</code> <code>bool</code> <p>Whether to fit map to loaded data bounds.</p> <code>True</code> <code>**kwargs</code> <p>Additional control options.</p> <code>{}</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from anymap_ts import MapLibreMap\n&gt;&gt;&gt; m = MapLibreMap()\n&gt;&gt;&gt; m.add_vector_control(\n...     default_url=\"https://example.com/data.geojson\",\n...     default_fill_color=\"#ff0000\"\n... )\n</code></pre> Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def add_vector_control(\n    self,\n    position: str = \"top-right\",\n    collapsed: bool = True,\n    default_url: Optional[str] = None,\n    load_default_url: bool = False,\n    default_opacity: float = 1.0,\n    default_fill_color: str = \"#3388ff\",\n    default_stroke_color: str = \"#3388ff\",\n    fit_bounds: bool = True,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a vector layer control for loading vector datasets from URLs.\n\n    This provides an interactive panel for users to enter URLs to\n    GeoJSON, GeoParquet, or FlatGeobuf datasets.\n\n    Args:\n        position: Control position ('top-left', 'top-right', 'bottom-left', 'bottom-right').\n        collapsed: Whether the panel starts collapsed.\n        default_url: Default vector URL to pre-fill.\n        load_default_url: Whether to auto-load the default URL.\n        default_opacity: Default layer opacity (0-1).\n        default_fill_color: Default fill color for polygons.\n        default_stroke_color: Default stroke color for lines/outlines.\n        fit_bounds: Whether to fit map to loaded data bounds.\n        **kwargs: Additional control options.\n\n    Example:\n        &gt;&gt;&gt; from anymap_ts import MapLibreMap\n        &gt;&gt;&gt; m = MapLibreMap()\n        &gt;&gt;&gt; m.add_vector_control(\n        ...     default_url=\"https://example.com/data.geojson\",\n        ...     default_fill_color=\"#ff0000\"\n        ... )\n    \"\"\"\n    self.call_js_method(\n        \"addVectorControl\",\n        position=position,\n        collapsed=collapsed,\n        defaultUrl=default_url or \"\",\n        loadDefaultUrl=load_default_url,\n        defaultOpacity=default_opacity,\n        defaultFillColor=default_fill_color,\n        defaultStrokeColor=default_stroke_color,\n        fitBounds=fit_bounds,\n        **kwargs,\n    )\n    self._controls = {\n        **self._controls,\n        \"vector-control\": {\"position\": position, \"collapsed\": collapsed},\n    }\n</code></pre>"},{"location":"maplibre/#anymap_ts.maplibre.MapLibreMap.add_zarr_control","title":"<code>add_zarr_control(self, position='top-right', collapsed=True, default_url=None, load_default_url=False, default_opacity=1.0, default_variable='', default_clim=None, **kwargs)</code>","text":"<p>Add a Zarr layer control for loading Zarr datasets via UI.</p> <p>This provides an interactive panel for users to enter Zarr URLs and configure visualization parameters.</p> <p>Parameters:</p> Name Type Description Default <code>position</code> <code>str</code> <p>Control position ('top-left', 'top-right', 'bottom-left', 'bottom-right').</p> <code>'top-right'</code> <code>collapsed</code> <code>bool</code> <p>Whether the panel starts collapsed.</p> <code>True</code> <code>default_url</code> <code>Optional[str]</code> <p>Default Zarr URL to pre-fill.</p> <code>None</code> <code>load_default_url</code> <code>bool</code> <p>Whether to auto-load the default URL.</p> <code>False</code> <code>default_opacity</code> <code>float</code> <p>Default layer opacity (0-1).</p> <code>1.0</code> <code>default_variable</code> <code>str</code> <p>Default variable name.</p> <code>''</code> <code>default_clim</code> <code>Optional[Tuple[float, float]]</code> <p>Default color limits (min, max).</p> <code>None</code> <code>**kwargs</code> <p>Additional control options.</p> <code>{}</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from anymap_ts import MapLibreMap\n&gt;&gt;&gt; m = MapLibreMap()\n&gt;&gt;&gt; m.add_zarr_control(\n...     default_url=\"https://example.com/data.zarr\",\n...     default_variable=\"temperature\"\n... )\n</code></pre> Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def add_zarr_control(\n    self,\n    position: str = \"top-right\",\n    collapsed: bool = True,\n    default_url: Optional[str] = None,\n    load_default_url: bool = False,\n    default_opacity: float = 1.0,\n    default_variable: str = \"\",\n    default_clim: Optional[Tuple[float, float]] = None,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a Zarr layer control for loading Zarr datasets via UI.\n\n    This provides an interactive panel for users to enter Zarr URLs\n    and configure visualization parameters.\n\n    Args:\n        position: Control position ('top-left', 'top-right', 'bottom-left', 'bottom-right').\n        collapsed: Whether the panel starts collapsed.\n        default_url: Default Zarr URL to pre-fill.\n        load_default_url: Whether to auto-load the default URL.\n        default_opacity: Default layer opacity (0-1).\n        default_variable: Default variable name.\n        default_clim: Default color limits (min, max).\n        **kwargs: Additional control options.\n\n    Example:\n        &gt;&gt;&gt; from anymap_ts import MapLibreMap\n        &gt;&gt;&gt; m = MapLibreMap()\n        &gt;&gt;&gt; m.add_zarr_control(\n        ...     default_url=\"https://example.com/data.zarr\",\n        ...     default_variable=\"temperature\"\n        ... )\n    \"\"\"\n    self.call_js_method(\n        \"addZarrControl\",\n        position=position,\n        collapsed=collapsed,\n        defaultUrl=default_url or \"\",\n        loadDefaultUrl=load_default_url,\n        defaultOpacity=default_opacity,\n        defaultVariable=default_variable,\n        defaultClim=list(default_clim) if default_clim else [0, 1],\n        **kwargs,\n    )\n    self._controls = {\n        **self._controls,\n        \"zarr-control\": {\"position\": position, \"collapsed\": collapsed},\n    }\n</code></pre>"},{"location":"maplibre/#anymap_ts.maplibre.MapLibreMap.add_zarr_layer","title":"<code>add_zarr_layer(self, url, variable, name=None, colormap=None, clim=None, opacity=1.0, selector=None, minzoom=0, maxzoom=22, fill_value=None, spatial_dimensions=None, zarr_version=None, bounds=None, **kwargs)</code>","text":"<p>Add a Zarr dataset layer for visualizing multidimensional array data.</p> <p>This method renders Zarr pyramid datasets directly in the browser using GPU-accelerated WebGL rendering via @carbonplan/zarr-layer.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>URL to the Zarr store (pyramid format recommended).</p> required <code>variable</code> <code>str</code> <p>Variable name in the Zarr dataset to visualize.</p> required <code>name</code> <code>Optional[str]</code> <p>Layer ID. If None, auto-generated.</p> <code>None</code> <code>colormap</code> <code>Optional[List[str]]</code> <p>List of hex color strings for visualization. Example: ['#0000ff', '#ffff00', '#ff0000'] (blue-yellow-red). Default: ['#000000', '#ffffff'] (black to white).</p> <code>None</code> <code>clim</code> <code>Optional[Tuple[float, float]]</code> <p>Color range as (min, max) tuple. Default: (0, 100).</p> <code>None</code> <code>opacity</code> <code>float</code> <p>Layer opacity (0-1).</p> <code>1.0</code> <code>selector</code> <code>Optional[Dict[str, Any]]</code> <p>Dimension selector for multi-dimensional data. Example: {\"month\": 4} to select 4th month.</p> <code>None</code> <code>minzoom</code> <code>int</code> <p>Minimum zoom level for rendering.</p> <code>0</code> <code>maxzoom</code> <code>int</code> <p>Maximum zoom level for rendering.</p> <code>22</code> <code>fill_value</code> <code>Optional[float]</code> <p>No-data value (auto-detected from metadata if not set).</p> <code>None</code> <code>spatial_dimensions</code> <code>Optional[Dict[str, str]]</code> <p>Custom spatial dimension names. Example: {\"lat\": \"y\", \"lon\": \"x\"} for non-standard names.</p> <code>None</code> <code>zarr_version</code> <code>Optional[int]</code> <p>Zarr format version (2 or 3). Auto-detected if not set.</p> <code>None</code> <code>bounds</code> <code>Optional[List[float]]</code> <p>Explicit spatial bounds [xMin, yMin, xMax, yMax]. Units depend on CRS: degrees for EPSG:4326, meters for EPSG:3857.</p> <code>None</code> <code>**kwargs</code> <p>Additional ZarrLayer props.</p> <code>{}</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from anymap_ts import Map\n&gt;&gt;&gt; m = Map()\n&gt;&gt;&gt; m.add_zarr_layer(\n...     \"https://example.com/climate.zarr\",\n...     variable=\"temperature\",\n...     clim=(270, 310),\n...     colormap=['#0000ff', '#ffff00', '#ff0000'],\n...     selector={\"month\": 7}\n... )\n</code></pre> Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def add_zarr_layer(\n    self,\n    url: str,\n    variable: str,\n    name: Optional[str] = None,\n    colormap: Optional[List[str]] = None,\n    clim: Optional[Tuple[float, float]] = None,\n    opacity: float = 1.0,\n    selector: Optional[Dict[str, Any]] = None,\n    minzoom: int = 0,\n    maxzoom: int = 22,\n    fill_value: Optional[float] = None,\n    spatial_dimensions: Optional[Dict[str, str]] = None,\n    zarr_version: Optional[int] = None,\n    bounds: Optional[List[float]] = None,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a Zarr dataset layer for visualizing multidimensional array data.\n\n    This method renders Zarr pyramid datasets directly in the browser using\n    GPU-accelerated WebGL rendering via @carbonplan/zarr-layer.\n\n    Args:\n        url: URL to the Zarr store (pyramid format recommended).\n        variable: Variable name in the Zarr dataset to visualize.\n        name: Layer ID. If None, auto-generated.\n        colormap: List of hex color strings for visualization.\n            Example: ['#0000ff', '#ffff00', '#ff0000'] (blue-yellow-red).\n            Default: ['#000000', '#ffffff'] (black to white).\n        clim: Color range as (min, max) tuple.\n            Default: (0, 100).\n        opacity: Layer opacity (0-1).\n        selector: Dimension selector for multi-dimensional data.\n            Example: {\"month\": 4} to select 4th month.\n        minzoom: Minimum zoom level for rendering.\n        maxzoom: Maximum zoom level for rendering.\n        fill_value: No-data value (auto-detected from metadata if not set).\n        spatial_dimensions: Custom spatial dimension names.\n            Example: {\"lat\": \"y\", \"lon\": \"x\"} for non-standard names.\n        zarr_version: Zarr format version (2 or 3). Auto-detected if not set.\n        bounds: Explicit spatial bounds [xMin, yMin, xMax, yMax].\n            Units depend on CRS: degrees for EPSG:4326, meters for EPSG:3857.\n        **kwargs: Additional ZarrLayer props.\n\n    Example:\n        &gt;&gt;&gt; from anymap_ts import Map\n        &gt;&gt;&gt; m = Map()\n        &gt;&gt;&gt; m.add_zarr_layer(\n        ...     \"https://example.com/climate.zarr\",\n        ...     variable=\"temperature\",\n        ...     clim=(270, 310),\n        ...     colormap=['#0000ff', '#ffff00', '#ff0000'],\n        ...     selector={\"month\": 7}\n        ... )\n    \"\"\"\n    layer_id = name or f\"zarr-{len(self._layers)}\"\n\n    self.call_js_method(\n        \"addZarrLayer\",\n        id=layer_id,\n        source=url,\n        variable=variable,\n        colormap=colormap or [\"#000000\", \"#ffffff\"],\n        clim=list(clim) if clim else [0, 100],\n        opacity=opacity,\n        selector=selector or {},\n        minzoom=minzoom,\n        maxzoom=maxzoom,\n        fillValue=fill_value,\n        spatialDimensions=spatial_dimensions,\n        zarrVersion=zarr_version,\n        bounds=bounds,\n        **kwargs,\n    )\n\n    self._layers = {\n        **self._layers,\n        layer_id: {\n            \"id\": layer_id,\n            \"type\": \"zarr\",\n            \"url\": url,\n            \"variable\": variable,\n        },\n    }\n</code></pre>"},{"location":"maplibre/#anymap_ts.maplibre.MapLibreMap.clear_draw_data","title":"<code>clear_draw_data(self)</code>","text":"<p>Clear all drawn features.</p> Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def clear_draw_data(self) -&gt; None:\n    \"\"\"Clear all drawn features.\"\"\"\n    self._draw_data = {\"type\": \"FeatureCollection\", \"features\": []}\n    self.call_js_method(\"clearDrawData\")\n</code></pre>"},{"location":"maplibre/#anymap_ts.maplibre.MapLibreMap.get_draw_data","title":"<code>get_draw_data(self)</code>","text":"<p>Get the current drawn features as GeoJSON.</p> <p>Returns:</p> Type Description <code>Dict</code> <p>GeoJSON FeatureCollection of drawn features</p> Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def get_draw_data(self) -&gt; Dict:\n    \"\"\"Get the current drawn features as GeoJSON.\n\n    Returns:\n        GeoJSON FeatureCollection of drawn features\n    \"\"\"\n    self.call_js_method(\"getDrawData\")\n    # Small delay to allow JS to update the trait\n    import time\n\n    time.sleep(0.1)\n    return self._draw_data or {\"type\": \"FeatureCollection\", \"features\": []}\n</code></pre>"},{"location":"maplibre/#anymap_ts.maplibre.MapLibreMap.load_draw_data","title":"<code>load_draw_data(self, geojson)</code>","text":"<p>Load GeoJSON features into the drawing layer.</p> <p>Parameters:</p> Name Type Description Default <code>geojson</code> <code>Dict</code> <p>GeoJSON FeatureCollection to load</p> required Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def load_draw_data(self, geojson: Dict) -&gt; None:\n    \"\"\"Load GeoJSON features into the drawing layer.\n\n    Args:\n        geojson: GeoJSON FeatureCollection to load\n    \"\"\"\n    self._draw_data = geojson\n    self.call_js_method(\"loadDrawData\", geojson)\n</code></pre>"},{"location":"maplibre/#anymap_ts.maplibre.MapLibreMap.remove_arc_layer","title":"<code>remove_arc_layer(self, layer_id)</code>","text":"<p>Remove an arc layer.</p> <p>Parameters:</p> Name Type Description Default <code>layer_id</code> <code>str</code> <p>Layer identifier to remove.</p> required Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def remove_arc_layer(self, layer_id: str) -&gt; None:\n    \"\"\"Remove an arc layer.\n\n    Args:\n        layer_id: Layer identifier to remove.\n    \"\"\"\n    if layer_id in self._layers:\n        layers = dict(self._layers)\n        del layers[layer_id]\n        self._layers = layers\n    self.call_js_method(\"removeArcLayer\", layer_id)\n</code></pre>"},{"location":"maplibre/#anymap_ts.maplibre.MapLibreMap.remove_cog_layer","title":"<code>remove_cog_layer(self, layer_id)</code>","text":"<p>Remove a COG layer.</p> <p>Parameters:</p> Name Type Description Default <code>layer_id</code> <code>str</code> <p>Layer identifier to remove.</p> required Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def remove_cog_layer(self, layer_id: str) -&gt; None:\n    \"\"\"Remove a COG layer.\n\n    Args:\n        layer_id: Layer identifier to remove.\n    \"\"\"\n    if layer_id in self._layers:\n        layers = dict(self._layers)\n        del layers[layer_id]\n        self._layers = layers\n    self.call_js_method(\"removeCOGLayer\", layer_id)\n</code></pre>"},{"location":"maplibre/#anymap_ts.maplibre.MapLibreMap.remove_control","title":"<code>remove_control(self, control_type)</code>","text":"<p>Remove a map control.</p> <p>Parameters:</p> Name Type Description Default <code>control_type</code> <code>str</code> <p>Type of control to remove</p> required Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def remove_control(self, control_type: str) -&gt; None:\n    \"\"\"Remove a map control.\n\n    Args:\n        control_type: Type of control to remove\n    \"\"\"\n    self.call_js_method(\"removeControl\", control_type)\n    if control_type in self._controls:\n        controls = dict(self._controls)\n        del controls[control_type]\n        self._controls = controls\n</code></pre>"},{"location":"maplibre/#anymap_ts.maplibre.MapLibreMap.remove_layer","title":"<code>remove_layer(self, layer_id)</code>","text":"<p>Remove a layer from the map.</p> <p>Parameters:</p> Name Type Description Default <code>layer_id</code> <code>str</code> <p>Layer identifier to remove</p> required Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def remove_layer(self, layer_id: str) -&gt; None:\n    \"\"\"Remove a layer from the map.\n\n    Args:\n        layer_id: Layer identifier to remove\n    \"\"\"\n    if layer_id in self._layers:\n        layers = dict(self._layers)\n        del layers[layer_id]\n        self._layers = layers\n    self.call_js_method(\"removeLayer\", layer_id)\n</code></pre>"},{"location":"maplibre/#anymap_ts.maplibre.MapLibreMap.remove_lidar_layer","title":"<code>remove_lidar_layer(self, layer_id=None)</code>","text":"<p>Remove a LiDAR layer.</p> <p>Parameters:</p> Name Type Description Default <code>layer_id</code> <code>Optional[str]</code> <p>Layer identifier to remove. If None, removes all LiDAR layers.</p> <code>None</code> Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def remove_lidar_layer(self, layer_id: Optional[str] = None) -&gt; None:\n    \"\"\"Remove a LiDAR layer.\n\n    Args:\n        layer_id: Layer identifier to remove. If None, removes all LiDAR layers.\n    \"\"\"\n    if layer_id:\n        if layer_id in self._layers:\n            layers = dict(self._layers)\n            del layers[layer_id]\n            self._layers = layers\n        self.call_js_method(\"removeLidarLayer\", id=layer_id)\n    else:\n        # Remove all lidar layers\n        layers = dict(self._layers)\n        self._layers = {k: v for k, v in layers.items() if v.get(\"type\") != \"lidar\"}\n        self.call_js_method(\"removeLidarLayer\")\n</code></pre>"},{"location":"maplibre/#anymap_ts.maplibre.MapLibreMap.remove_point_cloud_layer","title":"<code>remove_point_cloud_layer(self, layer_id)</code>","text":"<p>Remove a point cloud layer.</p> <p>Parameters:</p> Name Type Description Default <code>layer_id</code> <code>str</code> <p>Layer identifier to remove.</p> required Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def remove_point_cloud_layer(self, layer_id: str) -&gt; None:\n    \"\"\"Remove a point cloud layer.\n\n    Args:\n        layer_id: Layer identifier to remove.\n    \"\"\"\n    if layer_id in self._layers:\n        layers = dict(self._layers)\n        del layers[layer_id]\n        self._layers = layers\n    self.call_js_method(\"removePointCloudLayer\", layer_id)\n</code></pre>"},{"location":"maplibre/#anymap_ts.maplibre.MapLibreMap.remove_zarr_layer","title":"<code>remove_zarr_layer(self, layer_id)</code>","text":"<p>Remove a Zarr layer.</p> <p>Parameters:</p> Name Type Description Default <code>layer_id</code> <code>str</code> <p>Layer identifier to remove.</p> required Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def remove_zarr_layer(self, layer_id: str) -&gt; None:\n    \"\"\"Remove a Zarr layer.\n\n    Args:\n        layer_id: Layer identifier to remove.\n    \"\"\"\n    if layer_id in self._layers:\n        layers = dict(self._layers)\n        del layers[layer_id]\n        self._layers = layers\n    self.call_js_method(\"removeZarrLayer\", layer_id)\n</code></pre>"},{"location":"maplibre/#anymap_ts.maplibre.MapLibreMap.save_draw_data","title":"<code>save_draw_data(self, filepath, driver=None)</code>","text":"<p>Save drawn features to a file.</p> <p>Parameters:</p> Name Type Description Default <code>filepath</code> <code>Union[str, Path]</code> <p>Path to save file</p> required <code>driver</code> <code>Optional[str]</code> <p>Output driver (auto-detected from extension if not provided)</p> <code>None</code> <p>Exceptions:</p> Type Description <code>ImportError</code> <p>If geopandas is not installed</p> Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def save_draw_data(\n    self,\n    filepath: Union[str, Path],\n    driver: Optional[str] = None,\n) -&gt; None:\n    \"\"\"Save drawn features to a file.\n\n    Args:\n        filepath: Path to save file\n        driver: Output driver (auto-detected from extension if not provided)\n\n    Raises:\n        ImportError: If geopandas is not installed\n    \"\"\"\n    try:\n        import geopandas as gpd\n    except ImportError:\n        raise ImportError(\n            \"geopandas is required to save draw data. \"\n            \"Install with: pip install anymap-ts[vector]\"\n        )\n\n    data = self.get_draw_data()\n    if not data.get(\"features\"):\n        print(\"No features to save\")\n        return\n\n    gdf = gpd.GeoDataFrame.from_features(data[\"features\"])\n    filepath = Path(filepath)\n\n    # Infer driver from extension\n    if driver is None:\n        ext = filepath.suffix.lower()\n        driver_map = {\n            \".geojson\": \"GeoJSON\",\n            \".json\": \"GeoJSON\",\n            \".shp\": \"ESRI Shapefile\",\n            \".gpkg\": \"GPKG\",\n        }\n        driver = driver_map.get(ext, \"GeoJSON\")\n\n    gdf.to_file(filepath, driver=driver)\n</code></pre>"},{"location":"maplibre/#anymap_ts.maplibre.MapLibreMap.set_lidar_color_scheme","title":"<code>set_lidar_color_scheme(self, color_scheme)</code>","text":"<p>Set the LiDAR color scheme.</p> <p>Parameters:</p> Name Type Description Default <code>color_scheme</code> <code>str</code> <p>Color scheme ('elevation', 'intensity', 'classification', 'rgb').</p> required Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def set_lidar_color_scheme(self, color_scheme: str) -&gt; None:\n    \"\"\"Set the LiDAR color scheme.\n\n    Args:\n        color_scheme: Color scheme ('elevation', 'intensity', 'classification', 'rgb').\n    \"\"\"\n    self.call_js_method(\"setLidarColorScheme\", colorScheme=color_scheme)\n</code></pre>"},{"location":"maplibre/#anymap_ts.maplibre.MapLibreMap.set_lidar_opacity","title":"<code>set_lidar_opacity(self, opacity)</code>","text":"<p>Set the LiDAR layer opacity.</p> <p>Parameters:</p> Name Type Description Default <code>opacity</code> <code>float</code> <p>Opacity value between 0 and 1.</p> required Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def set_lidar_opacity(self, opacity: float) -&gt; None:\n    \"\"\"Set the LiDAR layer opacity.\n\n    Args:\n        opacity: Opacity value between 0 and 1.\n    \"\"\"\n    self.call_js_method(\"setLidarOpacity\", opacity=opacity)\n</code></pre>"},{"location":"maplibre/#anymap_ts.maplibre.MapLibreMap.set_lidar_point_size","title":"<code>set_lidar_point_size(self, point_size)</code>","text":"<p>Set the LiDAR point size.</p> <p>Parameters:</p> Name Type Description Default <code>point_size</code> <code>float</code> <p>Point size in pixels.</p> required Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def set_lidar_point_size(self, point_size: float) -&gt; None:\n    \"\"\"Set the LiDAR point size.\n\n    Args:\n        point_size: Point size in pixels.\n    \"\"\"\n    self.call_js_method(\"setLidarPointSize\", pointSize=point_size)\n</code></pre>"},{"location":"maplibre/#anymap_ts.maplibre.MapLibreMap.set_opacity","title":"<code>set_opacity(self, layer_id, opacity)</code>","text":"<p>Set layer opacity.</p> <p>Parameters:</p> Name Type Description Default <code>layer_id</code> <code>str</code> <p>Layer identifier</p> required <code>opacity</code> <code>float</code> <p>Opacity value between 0 and 1</p> required Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def set_opacity(self, layer_id: str, opacity: float) -&gt; None:\n    \"\"\"Set layer opacity.\n\n    Args:\n        layer_id: Layer identifier\n        opacity: Opacity value between 0 and 1\n    \"\"\"\n    self.call_js_method(\"setOpacity\", layer_id, opacity)\n</code></pre>"},{"location":"maplibre/#anymap_ts.maplibre.MapLibreMap.set_visibility","title":"<code>set_visibility(self, layer_id, visible)</code>","text":"<p>Set layer visibility.</p> <p>Parameters:</p> Name Type Description Default <code>layer_id</code> <code>str</code> <p>Layer identifier</p> required <code>visible</code> <code>bool</code> <p>Whether layer should be visible</p> required Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def set_visibility(self, layer_id: str, visible: bool) -&gt; None:\n    \"\"\"Set layer visibility.\n\n    Args:\n        layer_id: Layer identifier\n        visible: Whether layer should be visible\n    \"\"\"\n    self.call_js_method(\"setVisibility\", layer_id, visible)\n</code></pre>"},{"location":"maplibre/#anymap_ts.maplibre.MapLibreMap.update_zarr_layer","title":"<code>update_zarr_layer(self, layer_id, selector=None, clim=None, colormap=None, opacity=None)</code>","text":"<p>Update a Zarr layer's properties dynamically.</p> <p>Parameters:</p> Name Type Description Default <code>layer_id</code> <code>str</code> <p>Layer identifier.</p> required <code>selector</code> <code>Optional[Dict[str, Any]]</code> <p>New dimension selector.</p> <code>None</code> <code>clim</code> <code>Optional[Tuple[float, float]]</code> <p>New color range.</p> <code>None</code> <code>colormap</code> <code>Optional[List[str]]</code> <p>New colormap.</p> <code>None</code> <code>opacity</code> <code>Optional[float]</code> <p>New opacity value (0-1).</p> <code>None</code> Source code in <code>anymap_ts/maplibre.py</code> <pre><code>def update_zarr_layer(\n    self,\n    layer_id: str,\n    selector: Optional[Dict[str, Any]] = None,\n    clim: Optional[Tuple[float, float]] = None,\n    colormap: Optional[List[str]] = None,\n    opacity: Optional[float] = None,\n) -&gt; None:\n    \"\"\"Update a Zarr layer's properties dynamically.\n\n    Args:\n        layer_id: Layer identifier.\n        selector: New dimension selector.\n        clim: New color range.\n        colormap: New colormap.\n        opacity: New opacity value (0-1).\n    \"\"\"\n    update_kwargs: Dict[str, Any] = {\"id\": layer_id}\n    if selector is not None:\n        update_kwargs[\"selector\"] = selector\n    if clim is not None:\n        update_kwargs[\"clim\"] = list(clim)\n    if colormap is not None:\n        update_kwargs[\"colormap\"] = colormap\n    if opacity is not None:\n        update_kwargs[\"opacity\"] = opacity\n    self.call_js_method(\"updateZarrLayer\", **update_kwargs)\n</code></pre>"},{"location":"openlayers/","title":"openlayers module","text":"<p>OpenLayers map widget implementation.</p>"},{"location":"openlayers/#anymap_ts.openlayers.OpenLayersMap","title":"<code> OpenLayersMap            (MapWidget)         </code>","text":"<p>Interactive map widget using OpenLayers.</p> <p>This class provides a Python interface to OpenLayers maps with full bidirectional communication through anywidget. OpenLayers excels at WMS/WMTS support and projection handling.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from anymap_ts import OpenLayersMap\n&gt;&gt;&gt; m = OpenLayersMap(center=[-122.4, 37.8], zoom=10)\n&gt;&gt;&gt; m.add_basemap(\"OpenStreetMap\")\n&gt;&gt;&gt; m.add_wms_layer(\n...     url=\"https://example.com/wms\",\n...     layers=\"layer_name\",\n...     name=\"WMS Layer\"\n... )\n&gt;&gt;&gt; m\n</code></pre> Source code in <code>anymap_ts/openlayers.py</code> <pre><code>class OpenLayersMap(MapWidget):\n    \"\"\"Interactive map widget using OpenLayers.\n\n    This class provides a Python interface to OpenLayers maps with\n    full bidirectional communication through anywidget. OpenLayers\n    excels at WMS/WMTS support and projection handling.\n\n    Example:\n        &gt;&gt;&gt; from anymap_ts import OpenLayersMap\n        &gt;&gt;&gt; m = OpenLayersMap(center=[-122.4, 37.8], zoom=10)\n        &gt;&gt;&gt; m.add_basemap(\"OpenStreetMap\")\n        &gt;&gt;&gt; m.add_wms_layer(\n        ...     url=\"https://example.com/wms\",\n        ...     layers=\"layer_name\",\n        ...     name=\"WMS Layer\"\n        ... )\n        &gt;&gt;&gt; m\n    \"\"\"\n\n    # ESM module for frontend\n    _esm = STATIC_DIR / \"openlayers.js\"\n\n    # OpenLayers-specific traits\n    projection = traitlets.Unicode(\"EPSG:3857\").tag(sync=True)\n    rotation = traitlets.Float(0.0).tag(sync=True)\n\n    # Layer tracking\n    _layer_dict = traitlets.Dict({}).tag(sync=True)\n\n    def __init__(\n        self,\n        center: Tuple[float, float] = (0.0, 0.0),\n        zoom: float = 2.0,\n        width: str = \"100%\",\n        height: str = \"600px\",\n        projection: str = \"EPSG:3857\",\n        rotation: float = 0.0,\n        controls: Optional[Dict[str, Any]] = None,\n        **kwargs,\n    ):\n        \"\"\"Initialize an OpenLayers map.\n\n        Args:\n            center: Map center as (longitude, latitude).\n            zoom: Initial zoom level.\n            width: Map width as CSS string.\n            height: Map height as CSS string.\n            projection: Map projection (default EPSG:3857).\n            rotation: Map rotation in radians.\n            controls: Dict of controls to add.\n            **kwargs: Additional widget arguments.\n        \"\"\"\n        super().__init__(\n            center=list(center),\n            zoom=zoom,\n            width=width,\n            height=height,\n            projection=projection,\n            rotation=rotation,\n            **kwargs,\n        )\n\n        # Initialize layer dictionary\n        self._layer_dict = {\"Background\": []}\n\n        # Add default controls\n        if controls is None:\n            controls = {\"zoom\": True, \"attribution\": True}\n\n        for control_name, config in controls.items():\n            if config:\n                self.add_control(\n                    control_name, **(config if isinstance(config, dict) else {})\n                )\n\n    # -------------------------------------------------------------------------\n    # Basemap Methods\n    # -------------------------------------------------------------------------\n\n    def add_basemap(\n        self,\n        basemap: str = \"OpenStreetMap\",\n        attribution: Optional[str] = None,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a basemap layer.\n\n        Args:\n            basemap: Name of basemap provider (e.g., \"OpenStreetMap\", \"CartoDB.Positron\").\n            attribution: Custom attribution text.\n            **kwargs: Additional options.\n        \"\"\"\n        url, default_attribution = get_basemap_url(basemap)\n        self.call_js_method(\n            \"addBasemap\",\n            url,\n            attribution=attribution or default_attribution,\n            name=basemap,\n            **kwargs,\n        )\n\n        basemaps = self._layer_dict.get(\"Basemaps\", [])\n        if basemap not in basemaps:\n            self._layer_dict = {\n                **self._layer_dict,\n                \"Basemaps\": basemaps + [basemap],\n            }\n\n    # -------------------------------------------------------------------------\n    # Tile Layer Methods\n    # -------------------------------------------------------------------------\n\n    def add_tile_layer(\n        self,\n        url: str,\n        name: Optional[str] = None,\n        attribution: str = \"\",\n        min_zoom: int = 0,\n        max_zoom: int = 22,\n        opacity: float = 1.0,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add an XYZ tile layer.\n\n        Args:\n            url: Tile URL template with {x}, {y}, {z} placeholders.\n            name: Layer name.\n            attribution: Attribution text.\n            min_zoom: Minimum zoom level.\n            max_zoom: Maximum zoom level.\n            opacity: Layer opacity.\n            **kwargs: Additional options.\n        \"\"\"\n        layer_id = name or f\"tiles-{len(self._layers)}\"\n\n        self.call_js_method(\n            \"addTileLayer\",\n            url,\n            name=layer_id,\n            attribution=attribution,\n            minZoom=min_zoom,\n            maxZoom=max_zoom,\n            opacity=opacity,\n            **kwargs,\n        )\n\n        self._layers = {\n            **self._layers,\n            layer_id: {\"id\": layer_id, \"type\": \"tile\"},\n        }\n\n    # -------------------------------------------------------------------------\n    # Vector Data Methods\n    # -------------------------------------------------------------------------\n\n    def add_vector(\n        self,\n        data: Any,\n        name: Optional[str] = None,\n        style: Optional[Dict] = None,\n        fit_bounds: bool = True,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add vector data to the map.\n\n        Args:\n            data: GeoJSON dict, GeoDataFrame, or path to vector file.\n            name: Layer name.\n            style: Style configuration dict.\n            fit_bounds: Whether to fit map to data bounds.\n            **kwargs: Additional layer options.\n        \"\"\"\n        geojson = to_geojson(data)\n        layer_id = name or f\"vector-{len(self._layers)}\"\n\n        if style is None:\n            style = self._get_default_style(geojson)\n\n        self.call_js_method(\n            \"addGeoJSON\",\n            data=geojson,\n            name=layer_id,\n            style=style,\n            fitBounds=fit_bounds,\n            **kwargs,\n        )\n\n        self._layers = {\n            **self._layers,\n            layer_id: {\"id\": layer_id, \"type\": \"vector\"},\n        }\n\n    def add_geojson(\n        self,\n        data: Union[str, Dict],\n        name: Optional[str] = None,\n        style: Optional[Dict] = None,\n        fit_bounds: bool = True,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add GeoJSON data to the map.\n\n        Args:\n            data: GeoJSON dict or URL to GeoJSON file.\n            name: Layer name.\n            style: Style configuration dict.\n            fit_bounds: Whether to fit map to data bounds.\n            **kwargs: Additional layer options.\n        \"\"\"\n        self.add_vector(\n            data,\n            name=name,\n            style=style,\n            fit_bounds=fit_bounds,\n            **kwargs,\n        )\n\n    def _get_default_style(self, geojson: Dict) -&gt; Dict:\n        \"\"\"Get default style based on geometry type.\n\n        Args:\n            geojson: GeoJSON data.\n\n        Returns:\n            Style configuration dict.\n        \"\"\"\n        geom_type = self._infer_geom_type(geojson)\n\n        if geom_type in [\"Point\", \"MultiPoint\"]:\n            return {\n                \"fillColor\": \"rgba(51, 136, 255, 0.8)\",\n                \"strokeColor\": \"#ffffff\",\n                \"strokeWidth\": 2,\n                \"radius\": 6,\n            }\n        elif geom_type in [\"LineString\", \"MultiLineString\"]:\n            return {\n                \"strokeColor\": \"#3388ff\",\n                \"strokeWidth\": 3,\n            }\n        else:  # Polygon, MultiPolygon\n            return {\n                \"fillColor\": \"rgba(51, 136, 255, 0.5)\",\n                \"strokeColor\": \"#3388ff\",\n                \"strokeWidth\": 2,\n            }\n\n    def _infer_geom_type(self, geojson: Dict) -&gt; str:\n        \"\"\"Infer geometry type from GeoJSON.\n\n        Args:\n            geojson: GeoJSON data.\n\n        Returns:\n            Geometry type string.\n        \"\"\"\n        if geojson.get(\"type\") == \"FeatureCollection\":\n            features = geojson.get(\"features\", [])\n            if features:\n                return features[0].get(\"geometry\", {}).get(\"type\", \"Point\")\n        elif geojson.get(\"type\") == \"Feature\":\n            return geojson.get(\"geometry\", {}).get(\"type\", \"Point\")\n        return \"Point\"\n\n    # -------------------------------------------------------------------------\n    # WMS/WMTS Methods\n    # -------------------------------------------------------------------------\n\n    def add_wms_layer(\n        self,\n        url: str,\n        layers: str,\n        name: Optional[str] = None,\n        format: str = \"image/png\",\n        transparent: bool = True,\n        server_type: Optional[str] = None,\n        attribution: str = \"\",\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a WMS tile layer.\n\n        Args:\n            url: WMS service URL.\n            layers: Comma-separated layer names.\n            name: Layer name for the map.\n            format: Image format (default: image/png).\n            transparent: Whether to request transparent images.\n            server_type: Server type ('mapserver', 'geoserver', 'qgis').\n            attribution: Attribution text.\n            **kwargs: Additional WMS parameters.\n        \"\"\"\n        layer_id = name or f\"wms-{len(self._layers)}\"\n\n        self.call_js_method(\n            \"addWMSLayer\",\n            url=url,\n            layers=layers,\n            name=layer_id,\n            format=format,\n            transparent=transparent,\n            serverType=server_type,\n            attribution=attribution,\n            **kwargs,\n        )\n\n        self._layers = {\n            **self._layers,\n            layer_id: {\"id\": layer_id, \"type\": \"wms\"},\n        }\n\n    def add_image_wms_layer(\n        self,\n        url: str,\n        layers: str,\n        name: Optional[str] = None,\n        format: str = \"image/png\",\n        transparent: bool = True,\n        server_type: Optional[str] = None,\n        attribution: str = \"\",\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a single-image WMS layer (not tiled).\n\n        Args:\n            url: WMS service URL.\n            layers: Comma-separated layer names.\n            name: Layer name for the map.\n            format: Image format (default: image/png).\n            transparent: Whether to request transparent images.\n            server_type: Server type ('mapserver', 'geoserver', 'qgis').\n            attribution: Attribution text.\n            **kwargs: Additional WMS parameters.\n        \"\"\"\n        layer_id = name or f\"imagewms-{len(self._layers)}\"\n\n        self.call_js_method(\n            \"addImageWMSLayer\",\n            url=url,\n            layers=layers,\n            name=layer_id,\n            format=format,\n            transparent=transparent,\n            serverType=server_type,\n            attribution=attribution,\n            **kwargs,\n        )\n\n        self._layers = {\n            **self._layers,\n            layer_id: {\"id\": layer_id, \"type\": \"imagewms\"},\n        }\n\n    # -------------------------------------------------------------------------\n    # Layer Management\n    # -------------------------------------------------------------------------\n\n    def remove_layer(self, layer_id: str) -&gt; None:\n        \"\"\"Remove a layer from the map.\n\n        Args:\n            layer_id: Layer identifier to remove.\n        \"\"\"\n        if layer_id in self._layers:\n            layers = dict(self._layers)\n            del layers[layer_id]\n            self._layers = layers\n        self.call_js_method(\"removeLayer\", layer_id)\n\n    def set_visibility(self, layer_id: str, visible: bool) -&gt; None:\n        \"\"\"Set layer visibility.\n\n        Args:\n            layer_id: Layer identifier.\n            visible: Whether layer should be visible.\n        \"\"\"\n        self.call_js_method(\"setVisibility\", layer_id, visible)\n\n    def set_opacity(self, layer_id: str, opacity: float) -&gt; None:\n        \"\"\"Set layer opacity.\n\n        Args:\n            layer_id: Layer identifier.\n            opacity: Opacity value between 0 and 1.\n        \"\"\"\n        self.call_js_method(\"setOpacity\", layer_id, opacity)\n\n    # -------------------------------------------------------------------------\n    # Controls\n    # -------------------------------------------------------------------------\n\n    def add_control(\n        self,\n        control_type: str,\n        position: str = \"top-right\",\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a map control.\n\n        Args:\n            control_type: Type of control ('zoom', 'scale', 'fullscreen', etc.).\n            position: Control position.\n            **kwargs: Control-specific options.\n        \"\"\"\n        self.call_js_method(\"addControl\", control_type, position=position, **kwargs)\n        self._controls = {\n            **self._controls,\n            control_type: {\"type\": control_type, \"position\": position, **kwargs},\n        }\n\n    def remove_control(self, control_type: str) -&gt; None:\n        \"\"\"Remove a map control.\n\n        Args:\n            control_type: Type of control to remove.\n        \"\"\"\n        self.call_js_method(\"removeControl\", control_type)\n        if control_type in self._controls:\n            controls = dict(self._controls)\n            del controls[control_type]\n            self._controls = controls\n\n    # -------------------------------------------------------------------------\n    # Navigation\n    # -------------------------------------------------------------------------\n\n    def set_center(self, lng: float, lat: float) -&gt; None:\n        \"\"\"Set the map center.\n\n        Args:\n            lng: Longitude.\n            lat: Latitude.\n        \"\"\"\n        self.center = [lng, lat]\n        self.call_js_method(\"setCenter\", lng, lat)\n\n    def set_zoom(self, zoom: float) -&gt; None:\n        \"\"\"Set the map zoom level.\n\n        Args:\n            zoom: Zoom level.\n        \"\"\"\n        self.zoom = zoom\n        self.call_js_method(\"setZoom\", zoom)\n\n    def fly_to(\n        self,\n        lng: float,\n        lat: float,\n        zoom: Optional[float] = None,\n        duration: int = 2000,\n    ) -&gt; None:\n        \"\"\"Animate to a new location.\n\n        Args:\n            lng: Target longitude.\n            lat: Target latitude.\n            zoom: Target zoom level (optional).\n            duration: Animation duration in milliseconds.\n        \"\"\"\n        self.call_js_method(\n            \"flyTo\", lng, lat, zoom=zoom or self.zoom, duration=duration\n        )\n\n    def fit_bounds(\n        self,\n        bounds: List[float],\n        padding: int = 50,\n        duration: int = 1000,\n    ) -&gt; None:\n        \"\"\"Fit the map to bounds.\n\n        Args:\n            bounds: Bounds as [minLng, minLat, maxLng, maxLat].\n            padding: Padding in pixels.\n            duration: Animation duration in milliseconds.\n        \"\"\"\n        self.call_js_method(\"fitBounds\", bounds, padding=padding, duration=duration)\n\n    def fit_extent(\n        self,\n        extent: List[float],\n        padding: int = 50,\n        duration: int = 1000,\n    ) -&gt; None:\n        \"\"\"Fit the map to an extent (in map projection).\n\n        Args:\n            extent: Extent as [minX, minY, maxX, maxY] in map projection.\n            padding: Padding in pixels.\n            duration: Animation duration in milliseconds.\n        \"\"\"\n        self.call_js_method(\"fitExtent\", extent, padding=padding, duration=duration)\n\n    # -------------------------------------------------------------------------\n    # Markers\n    # -------------------------------------------------------------------------\n\n    def add_marker(\n        self,\n        lng: float,\n        lat: float,\n        popup: Optional[str] = None,\n        color: str = \"#3388ff\",\n        name: Optional[str] = None,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Add a marker to the map.\n\n        Args:\n            lng: Marker longitude.\n            lat: Marker latitude.\n            popup: Popup content (HTML string).\n            color: Marker color.\n            name: Marker identifier.\n            **kwargs: Additional options.\n        \"\"\"\n        marker_id = name or f\"marker-{len(self._layers)}\"\n        self.call_js_method(\n            \"addMarker\",\n            lng,\n            lat,\n            popup=popup,\n            color=color,\n            id=marker_id,\n            **kwargs,\n        )\n\n    # -------------------------------------------------------------------------\n    # HTML Export\n    # -------------------------------------------------------------------------\n\n    def _generate_html_template(self) -&gt; str:\n        \"\"\"Generate standalone HTML for the map.\"\"\"\n        template_path = Path(__file__).parent / \"templates\" / \"openlayers.html\"\n\n        if template_path.exists():\n            template = template_path.read_text(encoding=\"utf-8\")\n        else:\n            template = self._get_default_template()\n\n        state = {\n            \"center\": self.center,\n            \"zoom\": self.zoom,\n            \"projection\": self.projection,\n            \"rotation\": self.rotation,\n            \"width\": self.width,\n            \"height\": self.height,\n            \"layers\": self._layers,\n            \"controls\": self._controls,\n            \"js_calls\": self._js_calls,\n        }\n\n        template = template.replace(\"{{state}}\", json.dumps(state, indent=2))\n        return template\n\n    def _get_default_template(self) -&gt; str:\n        \"\"\"Get default HTML template.\"\"\"\n        return \"\"\"&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n    &lt;meta charset=\"utf-8\"&gt;\n    &lt;title&gt;OpenLayers Map&lt;/title&gt;\n    &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"&gt;\n    &lt;link rel=\"stylesheet\" href=\"https://cdn.jsdelivr.net/npm/ol@v10.0.0/ol.css\"&gt;\n    &lt;script src=\"https://cdn.jsdelivr.net/npm/ol@v10.0.0/dist/ol.js\"&gt;&lt;/script&gt;\n    &lt;style&gt;\n        * { margin: 0; padding: 0; box-sizing: border-box; }\n        html, body { height: 100%; }\n        #map { position: absolute; top: 0; bottom: 0; width: 100%; }\n    &lt;/style&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;div id=\"map\"&gt;&lt;/div&gt;\n    &lt;script&gt;\n        const state = {{state}};\n\n        const map = new ol.Map({\n            target: 'map',\n            view: new ol.View({\n                center: ol.proj.fromLonLat(state.center),\n                zoom: state.zoom\n            })\n        });\n\n        for (const call of state.js_calls || []) {\n            executeMethod(call.method, call.args, call.kwargs);\n        }\n\n        function executeMethod(method, args, kwargs) {\n            console.log('Executing:', method, args, kwargs);\n        }\n    &lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\"\"\"\n</code></pre>"},{"location":"openlayers/#anymap_ts.openlayers.OpenLayersMap.__init__","title":"<code>__init__(self, center=(0.0, 0.0), zoom=2.0, width='100%', height='600px', projection='EPSG:3857', rotation=0.0, controls=None, **kwargs)</code>  <code>special</code>","text":"<p>Initialize an OpenLayers map.</p> <p>Parameters:</p> Name Type Description Default <code>center</code> <code>Tuple[float, float]</code> <p>Map center as (longitude, latitude).</p> <code>(0.0, 0.0)</code> <code>zoom</code> <code>float</code> <p>Initial zoom level.</p> <code>2.0</code> <code>width</code> <code>str</code> <p>Map width as CSS string.</p> <code>'100%'</code> <code>height</code> <code>str</code> <p>Map height as CSS string.</p> <code>'600px'</code> <code>projection</code> <code>str</code> <p>Map projection (default EPSG:3857).</p> <code>'EPSG:3857'</code> <code>rotation</code> <code>float</code> <p>Map rotation in radians.</p> <code>0.0</code> <code>controls</code> <code>Optional[Dict[str, Any]]</code> <p>Dict of controls to add.</p> <code>None</code> <code>**kwargs</code> <p>Additional widget arguments.</p> <code>{}</code> Source code in <code>anymap_ts/openlayers.py</code> <pre><code>def __init__(\n    self,\n    center: Tuple[float, float] = (0.0, 0.0),\n    zoom: float = 2.0,\n    width: str = \"100%\",\n    height: str = \"600px\",\n    projection: str = \"EPSG:3857\",\n    rotation: float = 0.0,\n    controls: Optional[Dict[str, Any]] = None,\n    **kwargs,\n):\n    \"\"\"Initialize an OpenLayers map.\n\n    Args:\n        center: Map center as (longitude, latitude).\n        zoom: Initial zoom level.\n        width: Map width as CSS string.\n        height: Map height as CSS string.\n        projection: Map projection (default EPSG:3857).\n        rotation: Map rotation in radians.\n        controls: Dict of controls to add.\n        **kwargs: Additional widget arguments.\n    \"\"\"\n    super().__init__(\n        center=list(center),\n        zoom=zoom,\n        width=width,\n        height=height,\n        projection=projection,\n        rotation=rotation,\n        **kwargs,\n    )\n\n    # Initialize layer dictionary\n    self._layer_dict = {\"Background\": []}\n\n    # Add default controls\n    if controls is None:\n        controls = {\"zoom\": True, \"attribution\": True}\n\n    for control_name, config in controls.items():\n        if config:\n            self.add_control(\n                control_name, **(config if isinstance(config, dict) else {})\n            )\n</code></pre>"},{"location":"openlayers/#anymap_ts.openlayers.OpenLayersMap.add_basemap","title":"<code>add_basemap(self, basemap='OpenStreetMap', attribution=None, **kwargs)</code>","text":"<p>Add a basemap layer.</p> <p>Parameters:</p> Name Type Description Default <code>basemap</code> <code>str</code> <p>Name of basemap provider (e.g., \"OpenStreetMap\", \"CartoDB.Positron\").</p> <code>'OpenStreetMap'</code> <code>attribution</code> <code>Optional[str]</code> <p>Custom attribution text.</p> <code>None</code> <code>**kwargs</code> <p>Additional options.</p> <code>{}</code> Source code in <code>anymap_ts/openlayers.py</code> <pre><code>def add_basemap(\n    self,\n    basemap: str = \"OpenStreetMap\",\n    attribution: Optional[str] = None,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a basemap layer.\n\n    Args:\n        basemap: Name of basemap provider (e.g., \"OpenStreetMap\", \"CartoDB.Positron\").\n        attribution: Custom attribution text.\n        **kwargs: Additional options.\n    \"\"\"\n    url, default_attribution = get_basemap_url(basemap)\n    self.call_js_method(\n        \"addBasemap\",\n        url,\n        attribution=attribution or default_attribution,\n        name=basemap,\n        **kwargs,\n    )\n\n    basemaps = self._layer_dict.get(\"Basemaps\", [])\n    if basemap not in basemaps:\n        self._layer_dict = {\n            **self._layer_dict,\n            \"Basemaps\": basemaps + [basemap],\n        }\n</code></pre>"},{"location":"openlayers/#anymap_ts.openlayers.OpenLayersMap.add_control","title":"<code>add_control(self, control_type, position='top-right', **kwargs)</code>","text":"<p>Add a map control.</p> <p>Parameters:</p> Name Type Description Default <code>control_type</code> <code>str</code> <p>Type of control ('zoom', 'scale', 'fullscreen', etc.).</p> required <code>position</code> <code>str</code> <p>Control position.</p> <code>'top-right'</code> <code>**kwargs</code> <p>Control-specific options.</p> <code>{}</code> Source code in <code>anymap_ts/openlayers.py</code> <pre><code>def add_control(\n    self,\n    control_type: str,\n    position: str = \"top-right\",\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a map control.\n\n    Args:\n        control_type: Type of control ('zoom', 'scale', 'fullscreen', etc.).\n        position: Control position.\n        **kwargs: Control-specific options.\n    \"\"\"\n    self.call_js_method(\"addControl\", control_type, position=position, **kwargs)\n    self._controls = {\n        **self._controls,\n        control_type: {\"type\": control_type, \"position\": position, **kwargs},\n    }\n</code></pre>"},{"location":"openlayers/#anymap_ts.openlayers.OpenLayersMap.add_geojson","title":"<code>add_geojson(self, data, name=None, style=None, fit_bounds=True, **kwargs)</code>","text":"<p>Add GeoJSON data to the map.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Union[str, Dict]</code> <p>GeoJSON dict or URL to GeoJSON file.</p> required <code>name</code> <code>Optional[str]</code> <p>Layer name.</p> <code>None</code> <code>style</code> <code>Optional[Dict]</code> <p>Style configuration dict.</p> <code>None</code> <code>fit_bounds</code> <code>bool</code> <p>Whether to fit map to data bounds.</p> <code>True</code> <code>**kwargs</code> <p>Additional layer options.</p> <code>{}</code> Source code in <code>anymap_ts/openlayers.py</code> <pre><code>def add_geojson(\n    self,\n    data: Union[str, Dict],\n    name: Optional[str] = None,\n    style: Optional[Dict] = None,\n    fit_bounds: bool = True,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add GeoJSON data to the map.\n\n    Args:\n        data: GeoJSON dict or URL to GeoJSON file.\n        name: Layer name.\n        style: Style configuration dict.\n        fit_bounds: Whether to fit map to data bounds.\n        **kwargs: Additional layer options.\n    \"\"\"\n    self.add_vector(\n        data,\n        name=name,\n        style=style,\n        fit_bounds=fit_bounds,\n        **kwargs,\n    )\n</code></pre>"},{"location":"openlayers/#anymap_ts.openlayers.OpenLayersMap.add_image_wms_layer","title":"<code>add_image_wms_layer(self, url, layers, name=None, format='image/png', transparent=True, server_type=None, attribution='', **kwargs)</code>","text":"<p>Add a single-image WMS layer (not tiled).</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>WMS service URL.</p> required <code>layers</code> <code>str</code> <p>Comma-separated layer names.</p> required <code>name</code> <code>Optional[str]</code> <p>Layer name for the map.</p> <code>None</code> <code>format</code> <code>str</code> <p>Image format (default: image/png).</p> <code>'image/png'</code> <code>transparent</code> <code>bool</code> <p>Whether to request transparent images.</p> <code>True</code> <code>server_type</code> <code>Optional[str]</code> <p>Server type ('mapserver', 'geoserver', 'qgis').</p> <code>None</code> <code>attribution</code> <code>str</code> <p>Attribution text.</p> <code>''</code> <code>**kwargs</code> <p>Additional WMS parameters.</p> <code>{}</code> Source code in <code>anymap_ts/openlayers.py</code> <pre><code>def add_image_wms_layer(\n    self,\n    url: str,\n    layers: str,\n    name: Optional[str] = None,\n    format: str = \"image/png\",\n    transparent: bool = True,\n    server_type: Optional[str] = None,\n    attribution: str = \"\",\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a single-image WMS layer (not tiled).\n\n    Args:\n        url: WMS service URL.\n        layers: Comma-separated layer names.\n        name: Layer name for the map.\n        format: Image format (default: image/png).\n        transparent: Whether to request transparent images.\n        server_type: Server type ('mapserver', 'geoserver', 'qgis').\n        attribution: Attribution text.\n        **kwargs: Additional WMS parameters.\n    \"\"\"\n    layer_id = name or f\"imagewms-{len(self._layers)}\"\n\n    self.call_js_method(\n        \"addImageWMSLayer\",\n        url=url,\n        layers=layers,\n        name=layer_id,\n        format=format,\n        transparent=transparent,\n        serverType=server_type,\n        attribution=attribution,\n        **kwargs,\n    )\n\n    self._layers = {\n        **self._layers,\n        layer_id: {\"id\": layer_id, \"type\": \"imagewms\"},\n    }\n</code></pre>"},{"location":"openlayers/#anymap_ts.openlayers.OpenLayersMap.add_marker","title":"<code>add_marker(self, lng, lat, popup=None, color='#3388ff', name=None, **kwargs)</code>","text":"<p>Add a marker to the map.</p> <p>Parameters:</p> Name Type Description Default <code>lng</code> <code>float</code> <p>Marker longitude.</p> required <code>lat</code> <code>float</code> <p>Marker latitude.</p> required <code>popup</code> <code>Optional[str]</code> <p>Popup content (HTML string).</p> <code>None</code> <code>color</code> <code>str</code> <p>Marker color.</p> <code>'#3388ff'</code> <code>name</code> <code>Optional[str]</code> <p>Marker identifier.</p> <code>None</code> <code>**kwargs</code> <p>Additional options.</p> <code>{}</code> Source code in <code>anymap_ts/openlayers.py</code> <pre><code>def add_marker(\n    self,\n    lng: float,\n    lat: float,\n    popup: Optional[str] = None,\n    color: str = \"#3388ff\",\n    name: Optional[str] = None,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a marker to the map.\n\n    Args:\n        lng: Marker longitude.\n        lat: Marker latitude.\n        popup: Popup content (HTML string).\n        color: Marker color.\n        name: Marker identifier.\n        **kwargs: Additional options.\n    \"\"\"\n    marker_id = name or f\"marker-{len(self._layers)}\"\n    self.call_js_method(\n        \"addMarker\",\n        lng,\n        lat,\n        popup=popup,\n        color=color,\n        id=marker_id,\n        **kwargs,\n    )\n</code></pre>"},{"location":"openlayers/#anymap_ts.openlayers.OpenLayersMap.add_tile_layer","title":"<code>add_tile_layer(self, url, name=None, attribution='', min_zoom=0, max_zoom=22, opacity=1.0, **kwargs)</code>","text":"<p>Add an XYZ tile layer.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>Tile URL template with {x}, {y}, {z} placeholders.</p> required <code>name</code> <code>Optional[str]</code> <p>Layer name.</p> <code>None</code> <code>attribution</code> <code>str</code> <p>Attribution text.</p> <code>''</code> <code>min_zoom</code> <code>int</code> <p>Minimum zoom level.</p> <code>0</code> <code>max_zoom</code> <code>int</code> <p>Maximum zoom level.</p> <code>22</code> <code>opacity</code> <code>float</code> <p>Layer opacity.</p> <code>1.0</code> <code>**kwargs</code> <p>Additional options.</p> <code>{}</code> Source code in <code>anymap_ts/openlayers.py</code> <pre><code>def add_tile_layer(\n    self,\n    url: str,\n    name: Optional[str] = None,\n    attribution: str = \"\",\n    min_zoom: int = 0,\n    max_zoom: int = 22,\n    opacity: float = 1.0,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add an XYZ tile layer.\n\n    Args:\n        url: Tile URL template with {x}, {y}, {z} placeholders.\n        name: Layer name.\n        attribution: Attribution text.\n        min_zoom: Minimum zoom level.\n        max_zoom: Maximum zoom level.\n        opacity: Layer opacity.\n        **kwargs: Additional options.\n    \"\"\"\n    layer_id = name or f\"tiles-{len(self._layers)}\"\n\n    self.call_js_method(\n        \"addTileLayer\",\n        url,\n        name=layer_id,\n        attribution=attribution,\n        minZoom=min_zoom,\n        maxZoom=max_zoom,\n        opacity=opacity,\n        **kwargs,\n    )\n\n    self._layers = {\n        **self._layers,\n        layer_id: {\"id\": layer_id, \"type\": \"tile\"},\n    }\n</code></pre>"},{"location":"openlayers/#anymap_ts.openlayers.OpenLayersMap.add_vector","title":"<code>add_vector(self, data, name=None, style=None, fit_bounds=True, **kwargs)</code>","text":"<p>Add vector data to the map.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>GeoJSON dict, GeoDataFrame, or path to vector file.</p> required <code>name</code> <code>Optional[str]</code> <p>Layer name.</p> <code>None</code> <code>style</code> <code>Optional[Dict]</code> <p>Style configuration dict.</p> <code>None</code> <code>fit_bounds</code> <code>bool</code> <p>Whether to fit map to data bounds.</p> <code>True</code> <code>**kwargs</code> <p>Additional layer options.</p> <code>{}</code> Source code in <code>anymap_ts/openlayers.py</code> <pre><code>def add_vector(\n    self,\n    data: Any,\n    name: Optional[str] = None,\n    style: Optional[Dict] = None,\n    fit_bounds: bool = True,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add vector data to the map.\n\n    Args:\n        data: GeoJSON dict, GeoDataFrame, or path to vector file.\n        name: Layer name.\n        style: Style configuration dict.\n        fit_bounds: Whether to fit map to data bounds.\n        **kwargs: Additional layer options.\n    \"\"\"\n    geojson = to_geojson(data)\n    layer_id = name or f\"vector-{len(self._layers)}\"\n\n    if style is None:\n        style = self._get_default_style(geojson)\n\n    self.call_js_method(\n        \"addGeoJSON\",\n        data=geojson,\n        name=layer_id,\n        style=style,\n        fitBounds=fit_bounds,\n        **kwargs,\n    )\n\n    self._layers = {\n        **self._layers,\n        layer_id: {\"id\": layer_id, \"type\": \"vector\"},\n    }\n</code></pre>"},{"location":"openlayers/#anymap_ts.openlayers.OpenLayersMap.add_wms_layer","title":"<code>add_wms_layer(self, url, layers, name=None, format='image/png', transparent=True, server_type=None, attribution='', **kwargs)</code>","text":"<p>Add a WMS tile layer.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>WMS service URL.</p> required <code>layers</code> <code>str</code> <p>Comma-separated layer names.</p> required <code>name</code> <code>Optional[str]</code> <p>Layer name for the map.</p> <code>None</code> <code>format</code> <code>str</code> <p>Image format (default: image/png).</p> <code>'image/png'</code> <code>transparent</code> <code>bool</code> <p>Whether to request transparent images.</p> <code>True</code> <code>server_type</code> <code>Optional[str]</code> <p>Server type ('mapserver', 'geoserver', 'qgis').</p> <code>None</code> <code>attribution</code> <code>str</code> <p>Attribution text.</p> <code>''</code> <code>**kwargs</code> <p>Additional WMS parameters.</p> <code>{}</code> Source code in <code>anymap_ts/openlayers.py</code> <pre><code>def add_wms_layer(\n    self,\n    url: str,\n    layers: str,\n    name: Optional[str] = None,\n    format: str = \"image/png\",\n    transparent: bool = True,\n    server_type: Optional[str] = None,\n    attribution: str = \"\",\n    **kwargs,\n) -&gt; None:\n    \"\"\"Add a WMS tile layer.\n\n    Args:\n        url: WMS service URL.\n        layers: Comma-separated layer names.\n        name: Layer name for the map.\n        format: Image format (default: image/png).\n        transparent: Whether to request transparent images.\n        server_type: Server type ('mapserver', 'geoserver', 'qgis').\n        attribution: Attribution text.\n        **kwargs: Additional WMS parameters.\n    \"\"\"\n    layer_id = name or f\"wms-{len(self._layers)}\"\n\n    self.call_js_method(\n        \"addWMSLayer\",\n        url=url,\n        layers=layers,\n        name=layer_id,\n        format=format,\n        transparent=transparent,\n        serverType=server_type,\n        attribution=attribution,\n        **kwargs,\n    )\n\n    self._layers = {\n        **self._layers,\n        layer_id: {\"id\": layer_id, \"type\": \"wms\"},\n    }\n</code></pre>"},{"location":"openlayers/#anymap_ts.openlayers.OpenLayersMap.fit_bounds","title":"<code>fit_bounds(self, bounds, padding=50, duration=1000)</code>","text":"<p>Fit the map to bounds.</p> <p>Parameters:</p> Name Type Description Default <code>bounds</code> <code>List[float]</code> <p>Bounds as [minLng, minLat, maxLng, maxLat].</p> required <code>padding</code> <code>int</code> <p>Padding in pixels.</p> <code>50</code> <code>duration</code> <code>int</code> <p>Animation duration in milliseconds.</p> <code>1000</code> Source code in <code>anymap_ts/openlayers.py</code> <pre><code>def fit_bounds(\n    self,\n    bounds: List[float],\n    padding: int = 50,\n    duration: int = 1000,\n) -&gt; None:\n    \"\"\"Fit the map to bounds.\n\n    Args:\n        bounds: Bounds as [minLng, minLat, maxLng, maxLat].\n        padding: Padding in pixels.\n        duration: Animation duration in milliseconds.\n    \"\"\"\n    self.call_js_method(\"fitBounds\", bounds, padding=padding, duration=duration)\n</code></pre>"},{"location":"openlayers/#anymap_ts.openlayers.OpenLayersMap.fit_extent","title":"<code>fit_extent(self, extent, padding=50, duration=1000)</code>","text":"<p>Fit the map to an extent (in map projection).</p> <p>Parameters:</p> Name Type Description Default <code>extent</code> <code>List[float]</code> <p>Extent as [minX, minY, maxX, maxY] in map projection.</p> required <code>padding</code> <code>int</code> <p>Padding in pixels.</p> <code>50</code> <code>duration</code> <code>int</code> <p>Animation duration in milliseconds.</p> <code>1000</code> Source code in <code>anymap_ts/openlayers.py</code> <pre><code>def fit_extent(\n    self,\n    extent: List[float],\n    padding: int = 50,\n    duration: int = 1000,\n) -&gt; None:\n    \"\"\"Fit the map to an extent (in map projection).\n\n    Args:\n        extent: Extent as [minX, minY, maxX, maxY] in map projection.\n        padding: Padding in pixels.\n        duration: Animation duration in milliseconds.\n    \"\"\"\n    self.call_js_method(\"fitExtent\", extent, padding=padding, duration=duration)\n</code></pre>"},{"location":"openlayers/#anymap_ts.openlayers.OpenLayersMap.fly_to","title":"<code>fly_to(self, lng, lat, zoom=None, duration=2000)</code>","text":"<p>Animate to a new location.</p> <p>Parameters:</p> Name Type Description Default <code>lng</code> <code>float</code> <p>Target longitude.</p> required <code>lat</code> <code>float</code> <p>Target latitude.</p> required <code>zoom</code> <code>Optional[float]</code> <p>Target zoom level (optional).</p> <code>None</code> <code>duration</code> <code>int</code> <p>Animation duration in milliseconds.</p> <code>2000</code> Source code in <code>anymap_ts/openlayers.py</code> <pre><code>def fly_to(\n    self,\n    lng: float,\n    lat: float,\n    zoom: Optional[float] = None,\n    duration: int = 2000,\n) -&gt; None:\n    \"\"\"Animate to a new location.\n\n    Args:\n        lng: Target longitude.\n        lat: Target latitude.\n        zoom: Target zoom level (optional).\n        duration: Animation duration in milliseconds.\n    \"\"\"\n    self.call_js_method(\n        \"flyTo\", lng, lat, zoom=zoom or self.zoom, duration=duration\n    )\n</code></pre>"},{"location":"openlayers/#anymap_ts.openlayers.OpenLayersMap.remove_control","title":"<code>remove_control(self, control_type)</code>","text":"<p>Remove a map control.</p> <p>Parameters:</p> Name Type Description Default <code>control_type</code> <code>str</code> <p>Type of control to remove.</p> required Source code in <code>anymap_ts/openlayers.py</code> <pre><code>def remove_control(self, control_type: str) -&gt; None:\n    \"\"\"Remove a map control.\n\n    Args:\n        control_type: Type of control to remove.\n    \"\"\"\n    self.call_js_method(\"removeControl\", control_type)\n    if control_type in self._controls:\n        controls = dict(self._controls)\n        del controls[control_type]\n        self._controls = controls\n</code></pre>"},{"location":"openlayers/#anymap_ts.openlayers.OpenLayersMap.remove_layer","title":"<code>remove_layer(self, layer_id)</code>","text":"<p>Remove a layer from the map.</p> <p>Parameters:</p> Name Type Description Default <code>layer_id</code> <code>str</code> <p>Layer identifier to remove.</p> required Source code in <code>anymap_ts/openlayers.py</code> <pre><code>def remove_layer(self, layer_id: str) -&gt; None:\n    \"\"\"Remove a layer from the map.\n\n    Args:\n        layer_id: Layer identifier to remove.\n    \"\"\"\n    if layer_id in self._layers:\n        layers = dict(self._layers)\n        del layers[layer_id]\n        self._layers = layers\n    self.call_js_method(\"removeLayer\", layer_id)\n</code></pre>"},{"location":"openlayers/#anymap_ts.openlayers.OpenLayersMap.set_center","title":"<code>set_center(self, lng, lat)</code>","text":"<p>Set the map center.</p> <p>Parameters:</p> Name Type Description Default <code>lng</code> <code>float</code> <p>Longitude.</p> required <code>lat</code> <code>float</code> <p>Latitude.</p> required Source code in <code>anymap_ts/openlayers.py</code> <pre><code>def set_center(self, lng: float, lat: float) -&gt; None:\n    \"\"\"Set the map center.\n\n    Args:\n        lng: Longitude.\n        lat: Latitude.\n    \"\"\"\n    self.center = [lng, lat]\n    self.call_js_method(\"setCenter\", lng, lat)\n</code></pre>"},{"location":"openlayers/#anymap_ts.openlayers.OpenLayersMap.set_opacity","title":"<code>set_opacity(self, layer_id, opacity)</code>","text":"<p>Set layer opacity.</p> <p>Parameters:</p> Name Type Description Default <code>layer_id</code> <code>str</code> <p>Layer identifier.</p> required <code>opacity</code> <code>float</code> <p>Opacity value between 0 and 1.</p> required Source code in <code>anymap_ts/openlayers.py</code> <pre><code>def set_opacity(self, layer_id: str, opacity: float) -&gt; None:\n    \"\"\"Set layer opacity.\n\n    Args:\n        layer_id: Layer identifier.\n        opacity: Opacity value between 0 and 1.\n    \"\"\"\n    self.call_js_method(\"setOpacity\", layer_id, opacity)\n</code></pre>"},{"location":"openlayers/#anymap_ts.openlayers.OpenLayersMap.set_visibility","title":"<code>set_visibility(self, layer_id, visible)</code>","text":"<p>Set layer visibility.</p> <p>Parameters:</p> Name Type Description Default <code>layer_id</code> <code>str</code> <p>Layer identifier.</p> required <code>visible</code> <code>bool</code> <p>Whether layer should be visible.</p> required Source code in <code>anymap_ts/openlayers.py</code> <pre><code>def set_visibility(self, layer_id: str, visible: bool) -&gt; None:\n    \"\"\"Set layer visibility.\n\n    Args:\n        layer_id: Layer identifier.\n        visible: Whether layer should be visible.\n    \"\"\"\n    self.call_js_method(\"setVisibility\", layer_id, visible)\n</code></pre>"},{"location":"openlayers/#anymap_ts.openlayers.OpenLayersMap.set_zoom","title":"<code>set_zoom(self, zoom)</code>","text":"<p>Set the map zoom level.</p> <p>Parameters:</p> Name Type Description Default <code>zoom</code> <code>float</code> <p>Zoom level.</p> required Source code in <code>anymap_ts/openlayers.py</code> <pre><code>def set_zoom(self, zoom: float) -&gt; None:\n    \"\"\"Set the map zoom level.\n\n    Args:\n        zoom: Zoom level.\n    \"\"\"\n    self.zoom = zoom\n    self.call_js_method(\"setZoom\", zoom)\n</code></pre>"},{"location":"potree/","title":"potree module","text":"<p>Potree point cloud viewer widget implementation.</p> <p>Potree is loaded via CDN since it's a complex Three.js-based viewer. This implementation provides a Python wrapper for point cloud visualization.</p>"},{"location":"potree/#anymap_ts.potree.PotreeViewer","title":"<code> PotreeViewer            (MapWidget)         </code>","text":"<p>Interactive point cloud viewer using Potree.</p> <p>Potree is a WebGL-based point cloud renderer for large-scale LiDAR datasets. This class provides a Python interface for loading and visualizing point clouds.</p> <p>Note: Potree is loaded from CDN due to its complex Three.js dependencies.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from anymap_ts import PotreeViewer\n&gt;&gt;&gt; viewer = PotreeViewer()\n&gt;&gt;&gt; viewer.load_point_cloud(\"path/to/pointcloud/cloud.js\")\n&gt;&gt;&gt; viewer\n</code></pre> Source code in <code>anymap_ts/potree.py</code> <pre><code>class PotreeViewer(MapWidget):\n    \"\"\"Interactive point cloud viewer using Potree.\n\n    Potree is a WebGL-based point cloud renderer for large-scale LiDAR\n    datasets. This class provides a Python interface for loading and\n    visualizing point clouds.\n\n    Note: Potree is loaded from CDN due to its complex Three.js dependencies.\n\n    Example:\n        &gt;&gt;&gt; from anymap_ts import PotreeViewer\n        &gt;&gt;&gt; viewer = PotreeViewer()\n        &gt;&gt;&gt; viewer.load_point_cloud(\"path/to/pointcloud/cloud.js\")\n        &gt;&gt;&gt; viewer\n    \"\"\"\n\n    # ESM module for frontend\n    _esm = STATIC_DIR / \"potree.js\"\n\n    # Potree-specific traits\n    point_budget = traitlets.Int(1000000).tag(sync=True)\n    point_size = traitlets.Float(1.0).tag(sync=True)\n    fov = traitlets.Float(60.0).tag(sync=True)\n    background = traitlets.Unicode(\"#000000\").tag(sync=True)\n\n    # EDL (Eye Dome Lighting) settings\n    edl_enabled = traitlets.Bool(True).tag(sync=True)\n    edl_radius = traitlets.Float(1.4).tag(sync=True)\n    edl_strength = traitlets.Float(0.4).tag(sync=True)\n\n    # Point clouds\n    point_clouds = traitlets.Dict({}).tag(sync=True)\n\n    # Camera\n    camera_position = traitlets.List([0, 0, 100]).tag(sync=True)\n    camera_target = traitlets.List([0, 0, 0]).tag(sync=True)\n\n    def __init__(\n        self,\n        width: str = \"100%\",\n        height: str = \"600px\",\n        point_budget: int = 1000000,\n        point_size: float = 1.0,\n        fov: float = 60.0,\n        background: str = \"#000000\",\n        edl_enabled: bool = True,\n        **kwargs,\n    ):\n        \"\"\"Initialize a Potree viewer.\n\n        Args:\n            width: Widget width as CSS string.\n            height: Widget height as CSS string.\n            point_budget: Maximum number of points to render.\n            point_size: Default point size.\n            fov: Field of view in degrees.\n            background: Background color (hex string).\n            edl_enabled: Enable Eye Dome Lighting.\n            **kwargs: Additional widget arguments.\n        \"\"\"\n        # Potree doesn't use center/zoom like maps\n        super().__init__(\n            center=[0, 0],\n            zoom=1,\n            width=width,\n            height=height,\n            point_budget=point_budget,\n            point_size=point_size,\n            fov=fov,\n            background=background,\n            edl_enabled=edl_enabled,\n            **kwargs,\n        )\n        self.point_clouds = {}\n\n    # -------------------------------------------------------------------------\n    # Point Cloud Methods\n    # -------------------------------------------------------------------------\n\n    def load_point_cloud(\n        self,\n        url: str,\n        name: Optional[str] = None,\n        visible: bool = True,\n        point_size: Optional[float] = None,\n        point_size_type: str = \"adaptive\",\n        shape: str = \"circle\",\n        color: Optional[str] = None,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Load a point cloud.\n\n        Args:\n            url: URL to point cloud (Potree format or LAZ/LAS via Entwine).\n            name: Point cloud name.\n            visible: Whether point cloud is visible.\n            point_size: Point size (overrides default).\n            point_size_type: 'fixed', 'attenuated', or 'adaptive'.\n            shape: Point shape ('square', 'circle', 'paraboloid').\n            color: Point color (hex string or None for native colors).\n            **kwargs: Additional material options.\n        \"\"\"\n        cloud_id = name or f\"pointcloud_{len(self.point_clouds)}\"\n\n        self.point_clouds = {\n            **self.point_clouds,\n            cloud_id: {\n                \"url\": url,\n                \"name\": cloud_id,\n                \"visible\": visible,\n                \"material\": {\n                    \"size\": point_size or self.point_size,\n                    \"pointSizeType\": point_size_type,\n                    \"shape\": shape,\n                    \"color\": color,\n                    **kwargs,\n                },\n            },\n        }\n\n        self.call_js_method(\n            \"loadPointCloud\",\n            url=url,\n            name=cloud_id,\n            visible=visible,\n            material={\n                \"size\": point_size or self.point_size,\n                \"pointSizeType\": point_size_type,\n                \"shape\": shape,\n                \"color\": color,\n                **kwargs,\n            },\n        )\n\n    def remove_point_cloud(self, name: str) -&gt; None:\n        \"\"\"Remove a point cloud.\n\n        Args:\n            name: Point cloud name to remove.\n        \"\"\"\n        if name in self.point_clouds:\n            clouds = dict(self.point_clouds)\n            del clouds[name]\n            self.point_clouds = clouds\n        self.call_js_method(\"removePointCloud\", name=name)\n\n    def set_point_cloud_visibility(self, name: str, visible: bool) -&gt; None:\n        \"\"\"Set point cloud visibility.\n\n        Args:\n            name: Point cloud name.\n            visible: Whether to show the point cloud.\n        \"\"\"\n        self.call_js_method(\"setPointCloudVisibility\", name=name, visible=visible)\n\n    # -------------------------------------------------------------------------\n    # Camera Methods\n    # -------------------------------------------------------------------------\n\n    def set_camera_position(\n        self,\n        x: float,\n        y: float,\n        z: float,\n    ) -&gt; None:\n        \"\"\"Set camera position.\n\n        Args:\n            x: X coordinate.\n            y: Y coordinate.\n            z: Z coordinate.\n        \"\"\"\n        self.camera_position = [x, y, z]\n        self.call_js_method(\"setCameraPosition\", x=x, y=y, z=z)\n\n    def set_camera_target(\n        self,\n        x: float,\n        y: float,\n        z: float,\n    ) -&gt; None:\n        \"\"\"Set camera target (look-at point).\n\n        Args:\n            x: X coordinate.\n            y: Y coordinate.\n            z: Z coordinate.\n        \"\"\"\n        self.camera_target = [x, y, z]\n        self.call_js_method(\"setCameraTarget\", x=x, y=y, z=z)\n\n    def fly_to_point_cloud(self, name: Optional[str] = None) -&gt; None:\n        \"\"\"Fly to a point cloud or all point clouds.\n\n        Args:\n            name: Point cloud name (None for all).\n        \"\"\"\n        self.call_js_method(\"flyToPointCloud\", name=name)\n\n    def reset_camera(self) -&gt; None:\n        \"\"\"Reset camera to default view.\"\"\"\n        self.call_js_method(\"resetCamera\")\n\n    # -------------------------------------------------------------------------\n    # Visualization Settings\n    # -------------------------------------------------------------------------\n\n    def set_point_budget(self, budget: int) -&gt; None:\n        \"\"\"Set the point budget (max points to render).\n\n        Args:\n            budget: Maximum number of points.\n        \"\"\"\n        self.point_budget = budget\n        self.call_js_method(\"setPointBudget\", budget=budget)\n\n    def set_point_size(self, size: float) -&gt; None:\n        \"\"\"Set default point size.\n\n        Args:\n            size: Point size.\n        \"\"\"\n        self.point_size = size\n        self.call_js_method(\"setPointSize\", size=size)\n\n    def set_fov(self, fov: float) -&gt; None:\n        \"\"\"Set field of view.\n\n        Args:\n            fov: Field of view in degrees.\n        \"\"\"\n        self.fov = fov\n        self.call_js_method(\"setFOV\", fov=fov)\n\n    def set_background(self, color: str) -&gt; None:\n        \"\"\"Set background color.\n\n        Args:\n            color: Background color (hex string).\n        \"\"\"\n        self.background = color\n        self.call_js_method(\"setBackground\", color=color)\n\n    def set_edl(\n        self,\n        enabled: bool = True,\n        radius: float = 1.4,\n        strength: float = 0.4,\n    ) -&gt; None:\n        \"\"\"Configure Eye Dome Lighting.\n\n        Args:\n            enabled: Whether to enable EDL.\n            radius: EDL radius.\n            strength: EDL strength.\n        \"\"\"\n        self.edl_enabled = enabled\n        self.edl_radius = radius\n        self.edl_strength = strength\n        self.call_js_method(\n            \"setEDL\",\n            enabled=enabled,\n            radius=radius,\n            strength=strength,\n        )\n\n    # -------------------------------------------------------------------------\n    # Measurement Tools\n    # -------------------------------------------------------------------------\n\n    def add_measurement_tool(self, tool_type: str = \"distance\") -&gt; None:\n        \"\"\"Add a measurement tool.\n\n        Args:\n            tool_type: Type of measurement ('point', 'distance', 'area', 'angle', 'height', 'profile').\n        \"\"\"\n        self.call_js_method(\"addMeasurementTool\", type=tool_type)\n\n    def clear_measurements(self) -&gt; None:\n        \"\"\"Clear all measurements.\"\"\"\n        self.call_js_method(\"clearMeasurements\")\n\n    # -------------------------------------------------------------------------\n    # Clipping\n    # -------------------------------------------------------------------------\n\n    def add_clipping_volume(\n        self,\n        volume_type: str = \"box\",\n        position: Optional[Tuple[float, float, float]] = None,\n        scale: Optional[Tuple[float, float, float]] = None,\n    ) -&gt; None:\n        \"\"\"Add a clipping volume.\n\n        Args:\n            volume_type: Type of volume ('box', 'polygon', 'plane').\n            position: Volume position (x, y, z).\n            scale: Volume scale (x, y, z).\n        \"\"\"\n        self.call_js_method(\n            \"addClippingVolume\",\n            type=volume_type,\n            position=list(position) if position else None,\n            scale=list(scale) if scale else None,\n        )\n\n    def clear_clipping_volumes(self) -&gt; None:\n        \"\"\"Clear all clipping volumes.\"\"\"\n        self.call_js_method(\"clearClippingVolumes\")\n\n    # -------------------------------------------------------------------------\n    # Annotations\n    # -------------------------------------------------------------------------\n\n    def add_annotation(\n        self,\n        position: Tuple[float, float, float],\n        title: str,\n        description: str = \"\",\n        camera_position: Optional[Tuple[float, float, float]] = None,\n        camera_target: Optional[Tuple[float, float, float]] = None,\n    ) -&gt; None:\n        \"\"\"Add an annotation.\n\n        Args:\n            position: Annotation position (x, y, z).\n            title: Annotation title.\n            description: Annotation description.\n            camera_position: Camera position when focused.\n            camera_target: Camera target when focused.\n        \"\"\"\n        self.call_js_method(\n            \"addAnnotation\",\n            position=list(position),\n            title=title,\n            description=description,\n            cameraPosition=list(camera_position) if camera_position else None,\n            cameraTarget=list(camera_target) if camera_target else None,\n        )\n\n    def clear_annotations(self) -&gt; None:\n        \"\"\"Clear all annotations.\"\"\"\n        self.call_js_method(\"clearAnnotations\")\n\n    # -------------------------------------------------------------------------\n    # HTML Export\n    # -------------------------------------------------------------------------\n\n    def _generate_html_template(self) -&gt; str:\n        \"\"\"Generate standalone HTML for Potree viewer.\"\"\"\n        template_path = Path(__file__).parent / \"templates\" / \"potree.html\"\n\n        if template_path.exists():\n            template = template_path.read_text(encoding=\"utf-8\")\n        else:\n            template = self._get_default_template()\n\n        state = {\n            \"point_budget\": self.point_budget,\n            \"point_size\": self.point_size,\n            \"fov\": self.fov,\n            \"background\": self.background,\n            \"edl_enabled\": self.edl_enabled,\n            \"edl_radius\": self.edl_radius,\n            \"edl_strength\": self.edl_strength,\n            \"point_clouds\": self.point_clouds,\n            \"camera_position\": self.camera_position,\n            \"camera_target\": self.camera_target,\n            \"width\": self.width,\n            \"height\": self.height,\n            \"js_calls\": self._js_calls,\n        }\n\n        template = template.replace(\"{{state}}\", json.dumps(state, indent=2))\n        return template\n\n    def _get_default_template(self) -&gt; str:\n        \"\"\"Get default HTML template.\"\"\"\n        return \"\"\"&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n    &lt;meta charset=\"utf-8\"&gt;\n    &lt;title&gt;Potree Viewer&lt;/title&gt;\n    &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"&gt;\n    &lt;style&gt;\n        * { margin: 0; padding: 0; box-sizing: border-box; }\n        html, body { height: 100%; overflow: hidden; }\n        #potree_render_area { position: absolute; top: 0; bottom: 0; width: 100%; }\n    &lt;/style&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    &lt;div id=\"potree_render_area\"&gt;&lt;/div&gt;\n    &lt;script&gt;\n        const state = {{state}};\n        document.getElementById('potree_render_area').innerHTML = '&lt;p style=\"color: white; padding: 20px;\"&gt;Potree viewer requires Potree library. Point clouds: ' + Object.keys(state.point_clouds || {}).length + '&lt;/p&gt;';\n    &lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\"\"\"\n</code></pre>"},{"location":"potree/#anymap_ts.potree.PotreeViewer.__init__","title":"<code>__init__(self, width='100%', height='600px', point_budget=1000000, point_size=1.0, fov=60.0, background='#000000', edl_enabled=True, **kwargs)</code>  <code>special</code>","text":"<p>Initialize a Potree viewer.</p> <p>Parameters:</p> Name Type Description Default <code>width</code> <code>str</code> <p>Widget width as CSS string.</p> <code>'100%'</code> <code>height</code> <code>str</code> <p>Widget height as CSS string.</p> <code>'600px'</code> <code>point_budget</code> <code>int</code> <p>Maximum number of points to render.</p> <code>1000000</code> <code>point_size</code> <code>float</code> <p>Default point size.</p> <code>1.0</code> <code>fov</code> <code>float</code> <p>Field of view in degrees.</p> <code>60.0</code> <code>background</code> <code>str</code> <p>Background color (hex string).</p> <code>'#000000'</code> <code>edl_enabled</code> <code>bool</code> <p>Enable Eye Dome Lighting.</p> <code>True</code> <code>**kwargs</code> <p>Additional widget arguments.</p> <code>{}</code> Source code in <code>anymap_ts/potree.py</code> <pre><code>def __init__(\n    self,\n    width: str = \"100%\",\n    height: str = \"600px\",\n    point_budget: int = 1000000,\n    point_size: float = 1.0,\n    fov: float = 60.0,\n    background: str = \"#000000\",\n    edl_enabled: bool = True,\n    **kwargs,\n):\n    \"\"\"Initialize a Potree viewer.\n\n    Args:\n        width: Widget width as CSS string.\n        height: Widget height as CSS string.\n        point_budget: Maximum number of points to render.\n        point_size: Default point size.\n        fov: Field of view in degrees.\n        background: Background color (hex string).\n        edl_enabled: Enable Eye Dome Lighting.\n        **kwargs: Additional widget arguments.\n    \"\"\"\n    # Potree doesn't use center/zoom like maps\n    super().__init__(\n        center=[0, 0],\n        zoom=1,\n        width=width,\n        height=height,\n        point_budget=point_budget,\n        point_size=point_size,\n        fov=fov,\n        background=background,\n        edl_enabled=edl_enabled,\n        **kwargs,\n    )\n    self.point_clouds = {}\n</code></pre>"},{"location":"potree/#anymap_ts.potree.PotreeViewer.add_annotation","title":"<code>add_annotation(self, position, title, description='', camera_position=None, camera_target=None)</code>","text":"<p>Add an annotation.</p> <p>Parameters:</p> Name Type Description Default <code>position</code> <code>Tuple[float, float, float]</code> <p>Annotation position (x, y, z).</p> required <code>title</code> <code>str</code> <p>Annotation title.</p> required <code>description</code> <code>str</code> <p>Annotation description.</p> <code>''</code> <code>camera_position</code> <code>Optional[Tuple[float, float, float]]</code> <p>Camera position when focused.</p> <code>None</code> <code>camera_target</code> <code>Optional[Tuple[float, float, float]]</code> <p>Camera target when focused.</p> <code>None</code> Source code in <code>anymap_ts/potree.py</code> <pre><code>def add_annotation(\n    self,\n    position: Tuple[float, float, float],\n    title: str,\n    description: str = \"\",\n    camera_position: Optional[Tuple[float, float, float]] = None,\n    camera_target: Optional[Tuple[float, float, float]] = None,\n) -&gt; None:\n    \"\"\"Add an annotation.\n\n    Args:\n        position: Annotation position (x, y, z).\n        title: Annotation title.\n        description: Annotation description.\n        camera_position: Camera position when focused.\n        camera_target: Camera target when focused.\n    \"\"\"\n    self.call_js_method(\n        \"addAnnotation\",\n        position=list(position),\n        title=title,\n        description=description,\n        cameraPosition=list(camera_position) if camera_position else None,\n        cameraTarget=list(camera_target) if camera_target else None,\n    )\n</code></pre>"},{"location":"potree/#anymap_ts.potree.PotreeViewer.add_clipping_volume","title":"<code>add_clipping_volume(self, volume_type='box', position=None, scale=None)</code>","text":"<p>Add a clipping volume.</p> <p>Parameters:</p> Name Type Description Default <code>volume_type</code> <code>str</code> <p>Type of volume ('box', 'polygon', 'plane').</p> <code>'box'</code> <code>position</code> <code>Optional[Tuple[float, float, float]]</code> <p>Volume position (x, y, z).</p> <code>None</code> <code>scale</code> <code>Optional[Tuple[float, float, float]]</code> <p>Volume scale (x, y, z).</p> <code>None</code> Source code in <code>anymap_ts/potree.py</code> <pre><code>def add_clipping_volume(\n    self,\n    volume_type: str = \"box\",\n    position: Optional[Tuple[float, float, float]] = None,\n    scale: Optional[Tuple[float, float, float]] = None,\n) -&gt; None:\n    \"\"\"Add a clipping volume.\n\n    Args:\n        volume_type: Type of volume ('box', 'polygon', 'plane').\n        position: Volume position (x, y, z).\n        scale: Volume scale (x, y, z).\n    \"\"\"\n    self.call_js_method(\n        \"addClippingVolume\",\n        type=volume_type,\n        position=list(position) if position else None,\n        scale=list(scale) if scale else None,\n    )\n</code></pre>"},{"location":"potree/#anymap_ts.potree.PotreeViewer.add_measurement_tool","title":"<code>add_measurement_tool(self, tool_type='distance')</code>","text":"<p>Add a measurement tool.</p> <p>Parameters:</p> Name Type Description Default <code>tool_type</code> <code>str</code> <p>Type of measurement ('point', 'distance', 'area', 'angle', 'height', 'profile').</p> <code>'distance'</code> Source code in <code>anymap_ts/potree.py</code> <pre><code>def add_measurement_tool(self, tool_type: str = \"distance\") -&gt; None:\n    \"\"\"Add a measurement tool.\n\n    Args:\n        tool_type: Type of measurement ('point', 'distance', 'area', 'angle', 'height', 'profile').\n    \"\"\"\n    self.call_js_method(\"addMeasurementTool\", type=tool_type)\n</code></pre>"},{"location":"potree/#anymap_ts.potree.PotreeViewer.clear_annotations","title":"<code>clear_annotations(self)</code>","text":"<p>Clear all annotations.</p> Source code in <code>anymap_ts/potree.py</code> <pre><code>def clear_annotations(self) -&gt; None:\n    \"\"\"Clear all annotations.\"\"\"\n    self.call_js_method(\"clearAnnotations\")\n</code></pre>"},{"location":"potree/#anymap_ts.potree.PotreeViewer.clear_clipping_volumes","title":"<code>clear_clipping_volumes(self)</code>","text":"<p>Clear all clipping volumes.</p> Source code in <code>anymap_ts/potree.py</code> <pre><code>def clear_clipping_volumes(self) -&gt; None:\n    \"\"\"Clear all clipping volumes.\"\"\"\n    self.call_js_method(\"clearClippingVolumes\")\n</code></pre>"},{"location":"potree/#anymap_ts.potree.PotreeViewer.clear_measurements","title":"<code>clear_measurements(self)</code>","text":"<p>Clear all measurements.</p> Source code in <code>anymap_ts/potree.py</code> <pre><code>def clear_measurements(self) -&gt; None:\n    \"\"\"Clear all measurements.\"\"\"\n    self.call_js_method(\"clearMeasurements\")\n</code></pre>"},{"location":"potree/#anymap_ts.potree.PotreeViewer.fly_to_point_cloud","title":"<code>fly_to_point_cloud(self, name=None)</code>","text":"<p>Fly to a point cloud or all point clouds.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>Optional[str]</code> <p>Point cloud name (None for all).</p> <code>None</code> Source code in <code>anymap_ts/potree.py</code> <pre><code>def fly_to_point_cloud(self, name: Optional[str] = None) -&gt; None:\n    \"\"\"Fly to a point cloud or all point clouds.\n\n    Args:\n        name: Point cloud name (None for all).\n    \"\"\"\n    self.call_js_method(\"flyToPointCloud\", name=name)\n</code></pre>"},{"location":"potree/#anymap_ts.potree.PotreeViewer.load_point_cloud","title":"<code>load_point_cloud(self, url, name=None, visible=True, point_size=None, point_size_type='adaptive', shape='circle', color=None, **kwargs)</code>","text":"<p>Load a point cloud.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>URL to point cloud (Potree format or LAZ/LAS via Entwine).</p> required <code>name</code> <code>Optional[str]</code> <p>Point cloud name.</p> <code>None</code> <code>visible</code> <code>bool</code> <p>Whether point cloud is visible.</p> <code>True</code> <code>point_size</code> <code>Optional[float]</code> <p>Point size (overrides default).</p> <code>None</code> <code>point_size_type</code> <code>str</code> <p>'fixed', 'attenuated', or 'adaptive'.</p> <code>'adaptive'</code> <code>shape</code> <code>str</code> <p>Point shape ('square', 'circle', 'paraboloid').</p> <code>'circle'</code> <code>color</code> <code>Optional[str]</code> <p>Point color (hex string or None for native colors).</p> <code>None</code> <code>**kwargs</code> <p>Additional material options.</p> <code>{}</code> Source code in <code>anymap_ts/potree.py</code> <pre><code>def load_point_cloud(\n    self,\n    url: str,\n    name: Optional[str] = None,\n    visible: bool = True,\n    point_size: Optional[float] = None,\n    point_size_type: str = \"adaptive\",\n    shape: str = \"circle\",\n    color: Optional[str] = None,\n    **kwargs,\n) -&gt; None:\n    \"\"\"Load a point cloud.\n\n    Args:\n        url: URL to point cloud (Potree format or LAZ/LAS via Entwine).\n        name: Point cloud name.\n        visible: Whether point cloud is visible.\n        point_size: Point size (overrides default).\n        point_size_type: 'fixed', 'attenuated', or 'adaptive'.\n        shape: Point shape ('square', 'circle', 'paraboloid').\n        color: Point color (hex string or None for native colors).\n        **kwargs: Additional material options.\n    \"\"\"\n    cloud_id = name or f\"pointcloud_{len(self.point_clouds)}\"\n\n    self.point_clouds = {\n        **self.point_clouds,\n        cloud_id: {\n            \"url\": url,\n            \"name\": cloud_id,\n            \"visible\": visible,\n            \"material\": {\n                \"size\": point_size or self.point_size,\n                \"pointSizeType\": point_size_type,\n                \"shape\": shape,\n                \"color\": color,\n                **kwargs,\n            },\n        },\n    }\n\n    self.call_js_method(\n        \"loadPointCloud\",\n        url=url,\n        name=cloud_id,\n        visible=visible,\n        material={\n            \"size\": point_size or self.point_size,\n            \"pointSizeType\": point_size_type,\n            \"shape\": shape,\n            \"color\": color,\n            **kwargs,\n        },\n    )\n</code></pre>"},{"location":"potree/#anymap_ts.potree.PotreeViewer.remove_point_cloud","title":"<code>remove_point_cloud(self, name)</code>","text":"<p>Remove a point cloud.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Point cloud name to remove.</p> required Source code in <code>anymap_ts/potree.py</code> <pre><code>def remove_point_cloud(self, name: str) -&gt; None:\n    \"\"\"Remove a point cloud.\n\n    Args:\n        name: Point cloud name to remove.\n    \"\"\"\n    if name in self.point_clouds:\n        clouds = dict(self.point_clouds)\n        del clouds[name]\n        self.point_clouds = clouds\n    self.call_js_method(\"removePointCloud\", name=name)\n</code></pre>"},{"location":"potree/#anymap_ts.potree.PotreeViewer.reset_camera","title":"<code>reset_camera(self)</code>","text":"<p>Reset camera to default view.</p> Source code in <code>anymap_ts/potree.py</code> <pre><code>def reset_camera(self) -&gt; None:\n    \"\"\"Reset camera to default view.\"\"\"\n    self.call_js_method(\"resetCamera\")\n</code></pre>"},{"location":"potree/#anymap_ts.potree.PotreeViewer.set_background","title":"<code>set_background(self, color)</code>","text":"<p>Set background color.</p> <p>Parameters:</p> Name Type Description Default <code>color</code> <code>str</code> <p>Background color (hex string).</p> required Source code in <code>anymap_ts/potree.py</code> <pre><code>def set_background(self, color: str) -&gt; None:\n    \"\"\"Set background color.\n\n    Args:\n        color: Background color (hex string).\n    \"\"\"\n    self.background = color\n    self.call_js_method(\"setBackground\", color=color)\n</code></pre>"},{"location":"potree/#anymap_ts.potree.PotreeViewer.set_camera_position","title":"<code>set_camera_position(self, x, y, z)</code>","text":"<p>Set camera position.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>float</code> <p>X coordinate.</p> required <code>y</code> <code>float</code> <p>Y coordinate.</p> required <code>z</code> <code>float</code> <p>Z coordinate.</p> required Source code in <code>anymap_ts/potree.py</code> <pre><code>def set_camera_position(\n    self,\n    x: float,\n    y: float,\n    z: float,\n) -&gt; None:\n    \"\"\"Set camera position.\n\n    Args:\n        x: X coordinate.\n        y: Y coordinate.\n        z: Z coordinate.\n    \"\"\"\n    self.camera_position = [x, y, z]\n    self.call_js_method(\"setCameraPosition\", x=x, y=y, z=z)\n</code></pre>"},{"location":"potree/#anymap_ts.potree.PotreeViewer.set_camera_target","title":"<code>set_camera_target(self, x, y, z)</code>","text":"<p>Set camera target (look-at point).</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>float</code> <p>X coordinate.</p> required <code>y</code> <code>float</code> <p>Y coordinate.</p> required <code>z</code> <code>float</code> <p>Z coordinate.</p> required Source code in <code>anymap_ts/potree.py</code> <pre><code>def set_camera_target(\n    self,\n    x: float,\n    y: float,\n    z: float,\n) -&gt; None:\n    \"\"\"Set camera target (look-at point).\n\n    Args:\n        x: X coordinate.\n        y: Y coordinate.\n        z: Z coordinate.\n    \"\"\"\n    self.camera_target = [x, y, z]\n    self.call_js_method(\"setCameraTarget\", x=x, y=y, z=z)\n</code></pre>"},{"location":"potree/#anymap_ts.potree.PotreeViewer.set_edl","title":"<code>set_edl(self, enabled=True, radius=1.4, strength=0.4)</code>","text":"<p>Configure Eye Dome Lighting.</p> <p>Parameters:</p> Name Type Description Default <code>enabled</code> <code>bool</code> <p>Whether to enable EDL.</p> <code>True</code> <code>radius</code> <code>float</code> <p>EDL radius.</p> <code>1.4</code> <code>strength</code> <code>float</code> <p>EDL strength.</p> <code>0.4</code> Source code in <code>anymap_ts/potree.py</code> <pre><code>def set_edl(\n    self,\n    enabled: bool = True,\n    radius: float = 1.4,\n    strength: float = 0.4,\n) -&gt; None:\n    \"\"\"Configure Eye Dome Lighting.\n\n    Args:\n        enabled: Whether to enable EDL.\n        radius: EDL radius.\n        strength: EDL strength.\n    \"\"\"\n    self.edl_enabled = enabled\n    self.edl_radius = radius\n    self.edl_strength = strength\n    self.call_js_method(\n        \"setEDL\",\n        enabled=enabled,\n        radius=radius,\n        strength=strength,\n    )\n</code></pre>"},{"location":"potree/#anymap_ts.potree.PotreeViewer.set_fov","title":"<code>set_fov(self, fov)</code>","text":"<p>Set field of view.</p> <p>Parameters:</p> Name Type Description Default <code>fov</code> <code>float</code> <p>Field of view in degrees.</p> required Source code in <code>anymap_ts/potree.py</code> <pre><code>def set_fov(self, fov: float) -&gt; None:\n    \"\"\"Set field of view.\n\n    Args:\n        fov: Field of view in degrees.\n    \"\"\"\n    self.fov = fov\n    self.call_js_method(\"setFOV\", fov=fov)\n</code></pre>"},{"location":"potree/#anymap_ts.potree.PotreeViewer.set_point_budget","title":"<code>set_point_budget(self, budget)</code>","text":"<p>Set the point budget (max points to render).</p> <p>Parameters:</p> Name Type Description Default <code>budget</code> <code>int</code> <p>Maximum number of points.</p> required Source code in <code>anymap_ts/potree.py</code> <pre><code>def set_point_budget(self, budget: int) -&gt; None:\n    \"\"\"Set the point budget (max points to render).\n\n    Args:\n        budget: Maximum number of points.\n    \"\"\"\n    self.point_budget = budget\n    self.call_js_method(\"setPointBudget\", budget=budget)\n</code></pre>"},{"location":"potree/#anymap_ts.potree.PotreeViewer.set_point_cloud_visibility","title":"<code>set_point_cloud_visibility(self, name, visible)</code>","text":"<p>Set point cloud visibility.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Point cloud name.</p> required <code>visible</code> <code>bool</code> <p>Whether to show the point cloud.</p> required Source code in <code>anymap_ts/potree.py</code> <pre><code>def set_point_cloud_visibility(self, name: str, visible: bool) -&gt; None:\n    \"\"\"Set point cloud visibility.\n\n    Args:\n        name: Point cloud name.\n        visible: Whether to show the point cloud.\n    \"\"\"\n    self.call_js_method(\"setPointCloudVisibility\", name=name, visible=visible)\n</code></pre>"},{"location":"potree/#anymap_ts.potree.PotreeViewer.set_point_size","title":"<code>set_point_size(self, size)</code>","text":"<p>Set default point size.</p> <p>Parameters:</p> Name Type Description Default <code>size</code> <code>float</code> <p>Point size.</p> required Source code in <code>anymap_ts/potree.py</code> <pre><code>def set_point_size(self, size: float) -&gt; None:\n    \"\"\"Set default point size.\n\n    Args:\n        size: Point size.\n    \"\"\"\n    self.point_size = size\n    self.call_js_method(\"setPointSize\", size=size)\n</code></pre>"},{"location":"usage/","title":"Usage","text":""},{"location":"usage/#map-classes","title":"Map Classes","text":"Class Base Library Key Features <code>Map</code> / <code>MapLibreMap</code> MapLibre GL JS Vector tiles, drawing, layer control <code>MapboxMap</code> Mapbox GL JS 3D terrain, Mapbox styles <code>LeafletMap</code> Leaflet Lightweight, plugins <code>OpenLayersMap</code> OpenLayers WMS/WMTS, projections <code>DeckGLMap</code> DeckGL + MapLibre GPU layers, aggregations <code>CesiumMap</code> Cesium 3D globe, terrain, 3D Tiles <code>KeplerGLMap</code> KeplerGL Data exploration UI <code>PotreeViewer</code> Potree Point cloud visualization"},{"location":"usage/#maplibre-gl-js-default","title":"MapLibre GL JS (Default)","text":"<pre><code>from anymap_ts import Map\n\n# Create a map centered on a location\nm = Map(center=[-122.4, 37.8], zoom=10)\nm.add_basemap(\"OpenStreetMap\")\nm.add_draw_control()\nm\n</code></pre>"},{"location":"usage/#mapbox-gl-js","title":"Mapbox GL JS","text":"<pre><code>import os\nfrom anymap_ts import MapboxMap\n\n# Set your Mapbox token (or use MAPBOX_TOKEN env var)\nm = MapboxMap(center=[-122.4, 37.8], zoom=10)\nm.add_basemap(\"OpenStreetMap\")\nm\n</code></pre>"},{"location":"usage/#leaflet","title":"Leaflet","text":"<pre><code>from anymap_ts import LeafletMap\n\nm = LeafletMap(center=[-122.4, 37.8], zoom=10)\nm.add_basemap(\"OpenStreetMap\")\nm.add_marker(-122.4194, 37.7749, popup=\"San Francisco\")\nm\n</code></pre>"},{"location":"usage/#openlayers","title":"OpenLayers","text":"<pre><code>from anymap_ts import OpenLayersMap\n\nm = OpenLayersMap(center=[-122.4, 37.8], zoom=10)\nm.add_basemap(\"OpenStreetMap\")\n\n# Add WMS layer\nm.add_wms_layer(\n    url=\"https://example.com/wms\",\n    layers=\"layer_name\",\n    name=\"WMS Layer\"\n)\nm\n</code></pre>"},{"location":"usage/#deckgl","title":"DeckGL","text":"<pre><code>from anymap_ts import DeckGLMap\n\nm = DeckGLMap(center=[-122.4, 37.8], zoom=10)\nm.add_basemap(\"CartoDB.DarkMatter\")\n\n# Add scatterplot layer\npoints = [{\"coordinates\": [-122.4, 37.8], \"value\": 100}]\nm.add_scatterplot_layer(data=points, get_radius=100)\n\n# Add hexagon aggregation\nm.add_hexagon_layer(data=points, radius=500, extruded=True)\nm\n</code></pre>"},{"location":"usage/#cesium-3d-globe","title":"Cesium (3D Globe)","text":"<pre><code>from anymap_ts import CesiumMap\n\n# Set CESIUM_TOKEN env var for terrain/3D Tiles\nm = CesiumMap(center=[-122.4, 37.8], zoom=10)\nm.add_basemap(\"OpenStreetMap\")\nm.set_terrain()  # Enable Cesium World Terrain\nm.fly_to(-122.4194, 37.7749, height=50000, heading=45, pitch=-45)\nm\n</code></pre>"},{"location":"usage/#keplergl","title":"KeplerGL","text":"<pre><code>from anymap_ts import KeplerGLMap\nimport pandas as pd\n\nm = KeplerGLMap(center=[-122.4, 37.8], zoom=10)\n\n# Add DataFrame data\ndf = pd.DataFrame({\n    'latitude': [37.7749, 37.8044],\n    'longitude': [-122.4194, -122.2712],\n    'value': [100, 200]\n})\nm.add_data(df, name='points')\nm\n</code></pre>"},{"location":"usage/#potree-point-clouds","title":"Potree (Point Clouds)","text":"<pre><code>from anymap_ts import PotreeViewer\n\nviewer = PotreeViewer(\n    point_budget=1000000,\n    edl_enabled=True\n)\nviewer.load_point_cloud(\"path/to/pointcloud/cloud.js\", name=\"lidar\")\nviewer\n</code></pre>"},{"location":"usage/#common-methods","title":"Common Methods","text":"Method Description <code>add_basemap(name)</code> Add a basemap layer <code>add_vector(data, name)</code> Add vector data (GeoJSON/GeoDataFrame) <code>add_geojson(data, name)</code> Add GeoJSON data <code>add_tile_layer(url, name)</code> Add XYZ tile layer <code>fly_to(lng, lat, zoom)</code> Fly to location <code>fit_bounds(bounds)</code> Fit map to bounds <code>set_visibility(layer, visible)</code> Set layer visibility <code>set_opacity(layer, opacity)</code> Set layer opacity <code>to_html(filepath)</code> Export to HTML"},{"location":"usage/#add-vector-data","title":"Add Vector Data","text":"<pre><code>geojson = {\n    \"type\": \"FeatureCollection\",\n    \"features\": [\n        {\n            \"type\": \"Feature\",\n            \"geometry\": {\"type\": \"Point\", \"coordinates\": [-122.4, 37.8]},\n            \"properties\": {\"name\": \"San Francisco\"}\n        }\n    ]\n}\n\n# Works with MapLibre, Mapbox, Leaflet, OpenLayers\nm.add_vector(geojson, name=\"points\")\n\n# Or with GeoDataFrame (requires geopandas)\nimport geopandas as gpd\ngdf = gpd.read_file(\"path/to/data.geojson\")\nm.add_vector(gdf, name=\"polygons\")\n</code></pre>"},{"location":"usage/#map-navigation","title":"Map Navigation","text":"<pre><code># Fly to location with animation\nm.fly_to(-122.4, 37.8, zoom=14)\n\n# Fit to bounds [west, south, east, north]\nm.fit_bounds([-123, 37, -122, 38])\n</code></pre>"},{"location":"usage/#export-to-html","title":"Export to HTML","text":"<pre><code># All map types support HTML export\nm.to_html(\"map.html\", title=\"My Map\")\n</code></pre>"},{"location":"utils/","title":"utils module","text":"<p>Utility functions for anymap-ts.</p>"},{"location":"utils/#anymap_ts.utils.get_bounds","title":"<code>get_bounds(data)</code>","text":"<p>Calculate bounds from GeoJSON or GeoDataFrame.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>GeoJSON dict or GeoDataFrame</p> required <p>Returns:</p> Type Description <code>Optional[List[float]]</code> <p>[west, south, east, north] bounds or None</p> Source code in <code>anymap_ts/utils.py</code> <pre><code>def get_bounds(data: Any) -&gt; Optional[List[float]]:\n    \"\"\"Calculate bounds from GeoJSON or GeoDataFrame.\n\n    Args:\n        data: GeoJSON dict or GeoDataFrame\n\n    Returns:\n        [west, south, east, north] bounds or None\n    \"\"\"\n    if HAS_GEOPANDAS and isinstance(data, gpd.GeoDataFrame):\n        bounds = data.total_bounds\n        return [bounds[0], bounds[1], bounds[2], bounds[3]]\n\n    if isinstance(data, dict):\n        if HAS_SHAPELY:\n            return _get_geojson_bounds_shapely(data)\n        return _get_geojson_bounds_simple(data)\n\n    return None\n</code></pre>"},{"location":"utils/#anymap_ts.utils.get_default_paint","title":"<code>get_default_paint(layer_type)</code>","text":"<p>Get default paint properties for a layer type.</p> <p>Parameters:</p> Name Type Description Default <code>layer_type</code> <code>str</code> <p>MapLibre layer type</p> required <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Paint properties dict</p> Source code in <code>anymap_ts/utils.py</code> <pre><code>def get_default_paint(layer_type: str) -&gt; Dict[str, Any]:\n    \"\"\"Get default paint properties for a layer type.\n\n    Args:\n        layer_type: MapLibre layer type\n\n    Returns:\n        Paint properties dict\n    \"\"\"\n    defaults = {\n        \"circle\": {\n            \"circle-radius\": 5,\n            \"circle-color\": \"#3388ff\",\n            \"circle-opacity\": 0.8,\n            \"circle-stroke-width\": 1,\n            \"circle-stroke-color\": \"#ffffff\",\n        },\n        \"line\": {\n            \"line-color\": \"#3388ff\",\n            \"line-width\": 2,\n            \"line-opacity\": 0.8,\n        },\n        \"fill\": {\n            \"fill-color\": \"#3388ff\",\n            \"fill-opacity\": 0.5,\n            \"fill-outline-color\": \"#0000ff\",\n        },\n        \"fill-extrusion\": {\n            \"fill-extrusion-color\": \"#3388ff\",\n            \"fill-extrusion-opacity\": 0.6,\n            \"fill-extrusion-height\": 100,\n        },\n        \"raster\": {\n            \"raster-opacity\": 1,\n        },\n        \"heatmap\": {\n            \"heatmap-opacity\": 0.8,\n        },\n    }\n    return defaults.get(layer_type, {})\n</code></pre>"},{"location":"utils/#anymap_ts.utils.infer_layer_type","title":"<code>infer_layer_type(geojson)</code>","text":"<p>Infer MapLibre layer type from GeoJSON geometry.</p> <p>Parameters:</p> Name Type Description Default <code>geojson</code> <code>Dict</code> <p>GeoJSON dict</p> required <p>Returns:</p> Type Description <code>str</code> <p>Layer type ('circle', 'line', 'fill')</p> Source code in <code>anymap_ts/utils.py</code> <pre><code>def infer_layer_type(geojson: Dict) -&gt; str:\n    \"\"\"Infer MapLibre layer type from GeoJSON geometry.\n\n    Args:\n        geojson: GeoJSON dict\n\n    Returns:\n        Layer type ('circle', 'line', 'fill')\n    \"\"\"\n    geometry_type = None\n\n    if geojson.get(\"type\") == \"FeatureCollection\":\n        features = geojson.get(\"features\", [])\n        if features:\n            geometry_type = features[0].get(\"geometry\", {}).get(\"type\")\n    elif geojson.get(\"type\") == \"Feature\":\n        geometry_type = geojson.get(\"geometry\", {}).get(\"type\")\n    else:\n        geometry_type = geojson.get(\"type\")\n\n    type_map = {\n        \"Point\": \"circle\",\n        \"MultiPoint\": \"circle\",\n        \"LineString\": \"line\",\n        \"MultiLineString\": \"line\",\n        \"Polygon\": \"fill\",\n        \"MultiPolygon\": \"fill\",\n        \"GeometryCollection\": \"fill\",\n    }\n\n    return type_map.get(geometry_type, \"circle\")\n</code></pre>"},{"location":"utils/#anymap_ts.utils.to_geojson","title":"<code>to_geojson(data)</code>","text":"<p>Convert various data formats to GeoJSON.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Any</code> <p>GeoJSON dict, GeoDataFrame, file path, or URL</p> required <p>Returns:</p> Type Description <code>Dict</code> <p>GeoJSON dict</p> <p>Exceptions:</p> Type Description <code>ValueError</code> <p>If data cannot be converted</p> <code>ImportError</code> <p>If geopandas is required but not installed</p> Source code in <code>anymap_ts/utils.py</code> <pre><code>def to_geojson(data: Any) -&gt; Dict:\n    \"\"\"Convert various data formats to GeoJSON.\n\n    Args:\n        data: GeoJSON dict, GeoDataFrame, file path, or URL\n\n    Returns:\n        GeoJSON dict\n\n    Raises:\n        ValueError: If data cannot be converted\n        ImportError: If geopandas is required but not installed\n    \"\"\"\n    # Already a dict (GeoJSON)\n    if isinstance(data, dict):\n        return data\n\n    # GeoDataFrame\n    if HAS_GEOPANDAS and isinstance(data, gpd.GeoDataFrame):\n        return json.loads(data.to_json())\n\n    # File path or URL\n    if isinstance(data, (str, Path)):\n        path_str = str(data)\n\n        # If it's a URL, return as-is (will be handled by JS)\n        if path_str.startswith((\"http://\", \"https://\")):\n            return {\"type\": \"url\", \"url\": path_str}\n\n        # Read file with geopandas\n        if not HAS_GEOPANDAS:\n            raise ImportError(\n                \"geopandas is required to read vector files. \"\n                \"Install with: pip install anymap-ts[vector]\"\n            )\n\n        gdf = gpd.read_file(path_str)\n        return json.loads(gdf.to_json())\n\n    # Has __geo_interface__ (shapely geometry, etc.)\n    if hasattr(data, \"__geo_interface__\"):\n        geo = data.__geo_interface__\n        if geo.get(\"type\") in (\n            \"Point\",\n            \"LineString\",\n            \"Polygon\",\n            \"MultiPoint\",\n            \"MultiLineString\",\n            \"MultiPolygon\",\n            \"GeometryCollection\",\n        ):\n            return {\"type\": \"Feature\", \"geometry\": geo, \"properties\": {}}\n        return geo\n\n    raise ValueError(f\"Cannot convert {type(data)} to GeoJSON\")\n</code></pre>"},{"location":"notebooks/arc_layer/","title":"Arc layer","text":"In\u00a0[\u00a0]: Copied! <pre>from anymap_ts import MapLibreMap\n\n# Sample flight data from San Francisco to major cities\nflights = [\n    {\n        \"source\": [-122.4194, 37.7749],\n        \"target\": [-73.9857, 40.7484],\n        \"name\": \"SF to NYC\",\n    },\n    {\n        \"source\": [-122.4194, 37.7749],\n        \"target\": [-87.6298, 41.8781],\n        \"name\": \"SF to Chicago\",\n    },\n    {\n        \"source\": [-122.4194, 37.7749],\n        \"target\": [-118.2437, 34.0522],\n        \"name\": \"SF to LA\",\n    },\n    {\n        \"source\": [-122.4194, 37.7749],\n        \"target\": [-95.3698, 29.7604],\n        \"name\": \"SF to Houston\",\n    },\n    {\n        \"source\": [-122.4194, 37.7749],\n        \"target\": [-80.1918, 25.7617],\n        \"name\": \"SF to Miami\",\n    },\n]\n\nm = MapLibreMap(center=[-98.5795, 39.8283], zoom=3, pitch=30)\nm.add_basemap(\"CartoDB.DarkMatter\")\nm.add_arc_layer(\n    data=flights,\n    name=\"flights\",\n    get_source_color=[0, 128, 255, 255],\n    get_target_color=[255, 128, 0, 255],\n    get_width=2,\n    opacity=0.8,\n)\nm\n</pre> from anymap_ts import MapLibreMap  # Sample flight data from San Francisco to major cities flights = [     {         \"source\": [-122.4194, 37.7749],         \"target\": [-73.9857, 40.7484],         \"name\": \"SF to NYC\",     },     {         \"source\": [-122.4194, 37.7749],         \"target\": [-87.6298, 41.8781],         \"name\": \"SF to Chicago\",     },     {         \"source\": [-122.4194, 37.7749],         \"target\": [-118.2437, 34.0522],         \"name\": \"SF to LA\",     },     {         \"source\": [-122.4194, 37.7749],         \"target\": [-95.3698, 29.7604],         \"name\": \"SF to Houston\",     },     {         \"source\": [-122.4194, 37.7749],         \"target\": [-80.1918, 25.7617],         \"name\": \"SF to Miami\",     }, ]  m = MapLibreMap(center=[-98.5795, 39.8283], zoom=3, pitch=30) m.add_basemap(\"CartoDB.DarkMatter\") m.add_arc_layer(     data=flights,     name=\"flights\",     get_source_color=[0, 128, 255, 255],     get_target_color=[255, 128, 0, 255],     get_width=2,     opacity=0.8, ) m In\u00a0[\u00a0]: Copied! <pre># International flights using great circle paths\ninternational_flights = [\n    {\n        \"source\": [-122.4194, 37.7749],\n        \"target\": [139.6917, 35.6895],\n        \"name\": \"SF to Tokyo\",\n    },\n    {\n        \"source\": [-122.4194, 37.7749],\n        \"target\": [-0.1276, 51.5074],\n        \"name\": \"SF to London\",\n    },\n    {\n        \"source\": [-122.4194, 37.7749],\n        \"target\": [2.3522, 48.8566],\n        \"name\": \"SF to Paris\",\n    },\n    {\n        \"source\": [-122.4194, 37.7749],\n        \"target\": [151.2093, -33.8688],\n        \"name\": \"SF to Sydney\",\n    },\n]\n\nm2 = MapLibreMap(center=[-122.4, 20], zoom=1, pitch=20)\nm2.add_basemap(\"CartoDB.DarkMatter\")\nm2.add_arc_layer(\n    data=international_flights,\n    name=\"international\",\n    get_source_color=[255, 215, 0, 255],\n    get_target_color=[255, 69, 0, 255],\n    get_width=3,\n    great_circle=True,\n    get_height=1,\n)\nm2\n</pre> # International flights using great circle paths international_flights = [     {         \"source\": [-122.4194, 37.7749],         \"target\": [139.6917, 35.6895],         \"name\": \"SF to Tokyo\",     },     {         \"source\": [-122.4194, 37.7749],         \"target\": [-0.1276, 51.5074],         \"name\": \"SF to London\",     },     {         \"source\": [-122.4194, 37.7749],         \"target\": [2.3522, 48.8566],         \"name\": \"SF to Paris\",     },     {         \"source\": [-122.4194, 37.7749],         \"target\": [151.2093, -33.8688],         \"name\": \"SF to Sydney\",     }, ]  m2 = MapLibreMap(center=[-122.4, 20], zoom=1, pitch=20) m2.add_basemap(\"CartoDB.DarkMatter\") m2.add_arc_layer(     data=international_flights,     name=\"international\",     get_source_color=[255, 215, 0, 255],     get_target_color=[255, 69, 0, 255],     get_width=3,     great_circle=True,     get_height=1, ) m2 In\u00a0[\u00a0]: Copied! <pre>from anymap_ts import DeckGLMap\n\n# Bay Area commute patterns\ncommutes = [\n    {\"source\": [-122.2712, 37.8044], \"target\": [-122.4194, 37.7749], \"volume\": 5000},\n    {\"source\": [-122.0308, 37.3382], \"target\": [-122.4194, 37.7749], \"volume\": 3000},\n    {\"source\": [-121.8853, 37.3387], \"target\": [-122.4194, 37.7749], \"volume\": 4000},\n    {\"source\": [-122.4783, 37.8199], \"target\": [-122.4194, 37.7749], \"volume\": 2500},\n    {\"source\": [-122.1561, 37.4419], \"target\": [-122.4194, 37.7749], \"volume\": 3500},\n]\n\nm3 = DeckGLMap(center=[-122.2, 37.6], zoom=9, pitch=45)\nm3.add_basemap(\"CartoDB.DarkMatter\")\nm3.add_arc_layer(\n    data=commutes,\n    name=\"commutes\",\n    get_source_color=[51, 136, 255, 255],\n    get_target_color=[255, 136, 51, 255],\n    get_width=2,\n    opacity=0.7,\n)\nm3\n</pre> from anymap_ts import DeckGLMap  # Bay Area commute patterns commutes = [     {\"source\": [-122.2712, 37.8044], \"target\": [-122.4194, 37.7749], \"volume\": 5000},     {\"source\": [-122.0308, 37.3382], \"target\": [-122.4194, 37.7749], \"volume\": 3000},     {\"source\": [-121.8853, 37.3387], \"target\": [-122.4194, 37.7749], \"volume\": 4000},     {\"source\": [-122.4783, 37.8199], \"target\": [-122.4194, 37.7749], \"volume\": 2500},     {\"source\": [-122.1561, 37.4419], \"target\": [-122.4194, 37.7749], \"volume\": 3500}, ]  m3 = DeckGLMap(center=[-122.2, 37.6], zoom=9, pitch=45) m3.add_basemap(\"CartoDB.DarkMatter\") m3.add_arc_layer(     data=commutes,     name=\"commutes\",     get_source_color=[51, 136, 255, 255],     get_target_color=[255, 136, 51, 255],     get_width=2,     opacity=0.7, ) m3 In\u00a0[\u00a0]: Copied! <pre># Multiple arc layers with layer control\nm4 = MapLibreMap(center=[-98.5795, 39.8283], zoom=3)\nm4.add_basemap(\"CartoDB.DarkMatter\")\n\n# Add domestic flights\nm4.add_arc_layer(\n    data=flights,\n    name=\"arc-domestic\",\n    get_source_color=[0, 200, 100, 255],\n    get_target_color=[100, 200, 0, 255],\n    get_width=2,\n)\n\n# Add international flights\nm4.add_arc_layer(\n    data=international_flights,\n    name=\"arc-international\",\n    get_source_color=[255, 100, 100, 255],\n    get_target_color=[100, 100, 255, 255],\n    get_width=2,\n    great_circle=True,\n)\n\n# Add layer control to manage arc layers\nm4.add_layer_control()\nm4\n</pre> # Multiple arc layers with layer control m4 = MapLibreMap(center=[-98.5795, 39.8283], zoom=3) m4.add_basemap(\"CartoDB.DarkMatter\")  # Add domestic flights m4.add_arc_layer(     data=flights,     name=\"arc-domestic\",     get_source_color=[0, 200, 100, 255],     get_target_color=[100, 200, 0, 255],     get_width=2, )  # Add international flights m4.add_arc_layer(     data=international_flights,     name=\"arc-international\",     get_source_color=[255, 100, 100, 255],     get_target_color=[100, 100, 255, 255],     get_width=2,     great_circle=True, )  # Add layer control to manage arc layers m4.add_layer_control() m4 In\u00a0[\u00a0]: Copied! <pre># Remove a specific arc layer\nm4.remove_arc_layer(\"arc-domestic\")\n</pre> # Remove a specific arc layer m4.remove_arc_layer(\"arc-domestic\") In\u00a0[\u00a0]: Copied! <pre>m.to_html(\"arc_layer_example.html\")\n</pre> m.to_html(\"arc_layer_example.html\")"},{"location":"notebooks/arc_layer/#arc-layer-example","title":"Arc Layer Example\u00b6","text":"<p>This notebook demonstrates the DeckGL ArcLayer for visualizing origin-destination data.</p> <p>Arc layers are ideal for:</p> <ul> <li>Flight routes and migration patterns</li> <li>Transportation networks</li> <li>Supply chain visualization</li> <li>Any origin-destination flow data</li> </ul>"},{"location":"notebooks/arc_layer/#basic-arc-layer-with-maplibre","title":"Basic Arc Layer with MapLibre\u00b6","text":""},{"location":"notebooks/arc_layer/#arc-layer-with-great-circle-routing","title":"Arc Layer with Great Circle Routing\u00b6","text":""},{"location":"notebooks/arc_layer/#arc-layer-with-deckglmap","title":"Arc Layer with DeckGLMap\u00b6","text":""},{"location":"notebooks/arc_layer/#arc-layer-with-layer-control","title":"Arc Layer with Layer Control\u00b6","text":""},{"location":"notebooks/arc_layer/#remove-arc-layer","title":"Remove Arc Layer\u00b6","text":""},{"location":"notebooks/arc_layer/#export-to-html","title":"Export to HTML\u00b6","text":""},{"location":"notebooks/bitmap_layer/","title":"Bitmap layer","text":"In\u00a0[\u00a0]: Copied! <pre>from anymap_ts import DeckGLMap\n</pre> from anymap_ts import DeckGLMap In\u00a0[\u00a0]: Copied! <pre>m = DeckGLMap(center=[-122.4, 37.8], zoom=10)\nm.add_basemap(\"CartoDB.DarkMatter\")\n\n# Add a bitmap layer with a sample image\nm.add_bitmap_layer(\n    image=\"https://tile.openstreetmap.org/10/163/395.png\",\n    bounds=[-122.6, 37.6, -122.2, 38.0],\n    opacity=0.8,\n)\nm\n</pre> m = DeckGLMap(center=[-122.4, 37.8], zoom=10) m.add_basemap(\"CartoDB.DarkMatter\")  # Add a bitmap layer with a sample image m.add_bitmap_layer(     image=\"https://tile.openstreetmap.org/10/163/395.png\",     bounds=[-122.6, 37.6, -122.2, 38.0],     opacity=0.8, ) m In\u00a0[\u00a0]: Copied! <pre>m.to_html(\"bitmap_layer_example.html\")\n</pre> m.to_html(\"bitmap_layer_example.html\")"},{"location":"notebooks/bitmap_layer/#bitmap-layer-example","title":"Bitmap Layer Example\u00b6","text":"<p>Display raster images as map overlays using deck.gl BitmapLayer.</p>"},{"location":"notebooks/bitmap_layer/#create-a-map-with-a-bitmap-overlay","title":"Create a map with a bitmap overlay\u00b6","text":""},{"location":"notebooks/bitmap_layer/#export-to-html","title":"Export to HTML\u00b6","text":""},{"location":"notebooks/cesium/","title":"Cesium","text":"In\u00a0[\u00a0]: Copied! <pre>from anymap_ts import CesiumMap\n\n# Create a Cesium globe (uses CESIUM_TOKEN env var)\nm = CesiumMap(center=[-122.4, 37.8], zoom=10)\nm.add_basemap(\"OpenStreetMap\")\nm\n</pre> from anymap_ts import CesiumMap  # Create a Cesium globe (uses CESIUM_TOKEN env var) m = CesiumMap(center=[-122.4, 37.8], zoom=10) m.add_basemap(\"OpenStreetMap\") m In\u00a0[\u00a0]: Copied! <pre># Enable terrain (requires Cesium Ion token)\n# m.set_terrain()\n</pre> # Enable terrain (requires Cesium Ion token) # m.set_terrain() In\u00a0[\u00a0]: Copied! <pre># Add GeoJSON\ngeojson = {\n    \"type\": \"FeatureCollection\",\n    \"features\": [\n        {\n            \"type\": \"Feature\",\n            \"geometry\": {\"type\": \"Point\", \"coordinates\": [-122.4194, 37.7749]},\n            \"properties\": {\"name\": \"San Francisco\"},\n        },\n        {\n            \"type\": \"Feature\",\n            \"geometry\": {\n                \"type\": \"Polygon\",\n                \"coordinates\": [\n                    [\n                        [-122.5, 37.7],\n                        [-122.3, 37.7],\n                        [-122.3, 37.9],\n                        [-122.5, 37.9],\n                        [-122.5, 37.7],\n                    ]\n                ],\n            },\n            \"properties\": {\"name\": \"Area\"},\n        },\n    ],\n}\n\nm.add_geojson(geojson, name=\"features\", stroke=\"#ff0000\", fill=\"rgba(255,0,0,0.3)\")\n</pre> # Add GeoJSON geojson = {     \"type\": \"FeatureCollection\",     \"features\": [         {             \"type\": \"Feature\",             \"geometry\": {\"type\": \"Point\", \"coordinates\": [-122.4194, 37.7749]},             \"properties\": {\"name\": \"San Francisco\"},         },         {             \"type\": \"Feature\",             \"geometry\": {                 \"type\": \"Polygon\",                 \"coordinates\": [                     [                         [-122.5, 37.7],                         [-122.3, 37.7],                         [-122.3, 37.9],                         [-122.5, 37.9],                         [-122.5, 37.7],                     ]                 ],             },             \"properties\": {\"name\": \"Area\"},         },     ], }  m.add_geojson(geojson, name=\"features\", stroke=\"#ff0000\", fill=\"rgba(255,0,0,0.3)\") In\u00a0[\u00a0]: Copied! <pre># Fly to a location with camera orientation\nm.fly_to(-122.4194, 37.7749, height=50000, heading=45, pitch=-45)\n</pre> # Fly to a location with camera orientation m.fly_to(-122.4194, 37.7749, height=50000, heading=45, pitch=-45) In\u00a0[\u00a0]: Copied! <pre># Reset to home view\nm.reset_view()\n</pre> # Reset to home view m.reset_view() In\u00a0[\u00a0]: Copied! <pre># Add 3D Tileset (requires Cesium Ion token and asset ID)\n# m.add_3d_tileset(url=\"your_ion_asset_id\", name=\"buildings\")\n</pre> # Add 3D Tileset (requires Cesium Ion token and asset ID) # m.add_3d_tileset(url=\"your_ion_asset_id\", name=\"buildings\") In\u00a0[\u00a0]: Copied! <pre># Export to HTML\nm.to_html(\"cesium_example.html\")\n</pre> # Export to HTML m.to_html(\"cesium_example.html\")"},{"location":"notebooks/cesium/#cesium-example","title":"Cesium Example\u00b6","text":"<p>This notebook demonstrates the Cesium integration in anymap-ts.</p> <p>Cesium is a powerful 3D globe visualization library with terrain and 3D Tiles support.</p> <p>Note: Some features like Cesium World Terrain require a Cesium Ion access token. Set the <code>CESIUM_TOKEN</code> environment variable.</p>"},{"location":"notebooks/cog_layer/","title":"Cog layer","text":"In\u00a0[\u00a0]: Copied! <pre>from anymap_ts import Map\n\n# NLCD 2024 Land Cover COG (Continental US)\nCOG_URL = \"https://s3.us-east-1.amazonaws.com/ds-deck.gl-raster-public/cog/Annual_NLCD_LndCov_2024_CU_C1V1.tif\"\n\n# Create a MapLibre map\nm = Map(center=[-98.5, 39.8], zoom=4, style=\"dark-matter\")\n\n# Add the COG layer - the map will automatically fit to the COG bounds\nm.add_cog_layer(COG_URL, name=\"nlcd-landcover\", opacity=1.0)\n\nm\n</pre> from anymap_ts import Map  # NLCD 2024 Land Cover COG (Continental US) COG_URL = \"https://s3.us-east-1.amazonaws.com/ds-deck.gl-raster-public/cog/Annual_NLCD_LndCov_2024_CU_C1V1.tif\"  # Create a MapLibre map m = Map(center=[-98.5, 39.8], zoom=4, style=\"dark-matter\")  # Add the COG layer - the map will automatically fit to the COG bounds m.add_cog_layer(COG_URL, name=\"nlcd-landcover\", opacity=1.0)  m In\u00a0[\u00a0]: Copied! <pre>from anymap_ts import DeckGLMap\n\n# Create a DeckGL map\nm2 = DeckGLMap(center=[-98.5, 39.8], zoom=4, style=\"dark-matter\")\n\n# Add the COG layer with debug mode to visualize the reprojection mesh\nm2.add_cog_layer(\n    COG_URL,\n    name=\"nlcd-landcover-debug\",\n    debug=True,  # Show the reprojection mesh\n    debug_opacity=0.25,\n)\n\nm2\n</pre> from anymap_ts import DeckGLMap  # Create a DeckGL map m2 = DeckGLMap(center=[-98.5, 39.8], zoom=4, style=\"dark-matter\")  # Add the COG layer with debug mode to visualize the reprojection mesh m2.add_cog_layer(     COG_URL,     name=\"nlcd-landcover-debug\",     debug=True,  # Show the reprojection mesh     debug_opacity=0.25, )  m2 In\u00a0[\u00a0]: Copied! <pre>import os\nfrom anymap_ts import MapboxMap\n\n# Create a Mapbox map (requires MAPBOX_TOKEN environment variable)\n# Skip if no token is set\nif os.environ.get(\"MAPBOX_TOKEN\"):\n    m3 = MapboxMap(\n        center=[-98.5, 39.8], zoom=4, style=\"mapbox://styles/mapbox/dark-v11\"\n    )\n\n    # Add the COG layer\n    m3.add_cog_layer(COG_URL, name=\"nlcd-landcover-mapbox\", opacity=0.9)\n\n    display(m3)\nelse:\n    print(\"Set MAPBOX_TOKEN environment variable to use Mapbox maps\")\n</pre> import os from anymap_ts import MapboxMap  # Create a Mapbox map (requires MAPBOX_TOKEN environment variable) # Skip if no token is set if os.environ.get(\"MAPBOX_TOKEN\"):     m3 = MapboxMap(         center=[-98.5, 39.8], zoom=4, style=\"mapbox://styles/mapbox/dark-v11\"     )      # Add the COG layer     m3.add_cog_layer(COG_URL, name=\"nlcd-landcover-mapbox\", opacity=0.9)      display(m3) else:     print(\"Set MAPBOX_TOKEN environment variable to use Mapbox maps\") In\u00a0[\u00a0]: Copied! <pre># Export to standalone HTML\nm.to_html(\"cog_layer_example.html\")\nprint(\"Exported to cog_layer_example.html\")\n</pre> # Export to standalone HTML m.to_html(\"cog_layer_example.html\") print(\"Exported to cog_layer_example.html\")"},{"location":"notebooks/cog_layer/#cog-layer-example","title":"COG Layer Example\u00b6","text":"<p>This notebook demonstrates how to visualize Cloud Optimized GeoTIFFs (COGs) using the @developmentseed/deck.gl-geotiff package.</p> <p>The COG layer provides GPU-accelerated rendering with automatic reprojection support, allowing you to visualize large raster datasets directly in the browser without server-side processing.</p>"},{"location":"notebooks/cog_layer/#maplibre-example","title":"MapLibre Example\u00b6","text":"<p>The <code>add_cog_layer</code> method is available on the MapLibre Map class. It uses deck.gl overlay to render COG files.</p>"},{"location":"notebooks/cog_layer/#deckgl-example","title":"DeckGL Example\u00b6","text":"<p>The DeckGL map class also supports COG layers with additional debug options.</p>"},{"location":"notebooks/cog_layer/#mapbox-example","title":"Mapbox Example\u00b6","text":"<p>The Mapbox map class also supports COG layers (requires a Mapbox access token).</p>"},{"location":"notebooks/cog_layer/#configuration-options","title":"Configuration Options\u00b6","text":"<p>The <code>add_cog_layer</code> method supports several configuration options:</p> Parameter Type Default Description <code>url</code> str required URL to the Cloud Optimized GeoTIFF file <code>name</code> str auto Layer identifier <code>opacity</code> float 1.0 Layer opacity (0-1) <code>visible</code> bool True Whether layer is visible <code>debug</code> bool False Show reprojection mesh for debugging <code>debug_opacity</code> float 0.25 Opacity of debug mesh <code>max_error</code> float 0.125 Maximum reprojection error in pixels <code>fit_bounds</code> bool True Fit map to COG bounds after loading <code>before_id</code> str None ID of layer to insert before"},{"location":"notebooks/cog_layer/#about-the-dataset","title":"About the Dataset\u00b6","text":"<p>The example uses the NLCD 2024 Land Cover dataset:</p> <ul> <li>Coverage: Continental United States</li> <li>Resolution: 30 meters</li> <li>Source: USGS National Land Cover Database</li> <li>Format: Cloud Optimized GeoTIFF (COG)</li> </ul> <p>The dataset classifies land cover into categories including:</p> <ul> <li>Developed areas (open space, low/medium/high intensity)</li> <li>Forest (deciduous, evergreen, mixed)</li> <li>Agricultural (pasture, crops)</li> <li>Wetlands</li> <li>Water bodies</li> <li>And more...</li> </ul>"},{"location":"notebooks/column_layer/","title":"Column layer","text":"In\u00a0[\u00a0]: Copied! <pre>import random\nfrom anymap_ts import DeckGLMap\n</pre> import random from anymap_ts import DeckGLMap In\u00a0[\u00a0]: Copied! <pre># Generate random column data around San Francisco\ncolumns = [\n    {\n        \"coordinates\": [\n            -122.4 + (random.random() - 0.5) * 0.3,\n            37.8 + (random.random() - 0.5) * 0.3,\n        ],\n        \"value\": random.randint(500, 5000),\n    }\n    for _ in range(100)\n]\n</pre> # Generate random column data around San Francisco columns = [     {         \"coordinates\": [             -122.4 + (random.random() - 0.5) * 0.3,             37.8 + (random.random() - 0.5) * 0.3,         ],         \"value\": random.randint(500, 5000),     }     for _ in range(100) ] In\u00a0[\u00a0]: Copied! <pre>m = DeckGLMap(center=[-122.4, 37.8], zoom=11, pitch=45, bearing=-17)\nm.add_basemap(\"CartoDB.DarkMatter\")\n\nm.add_column_layer(\n    data=columns,\n    get_position=\"coordinates\",\n    get_elevation=\"value\",\n    radius=200,\n    elevation_scale=1,\n    extruded=True,\n    get_fill_color=[255, 140, 0, 200],\n    opacity=0.8,\n)\nm\n</pre> m = DeckGLMap(center=[-122.4, 37.8], zoom=11, pitch=45, bearing=-17) m.add_basemap(\"CartoDB.DarkMatter\")  m.add_column_layer(     data=columns,     get_position=\"coordinates\",     get_elevation=\"value\",     radius=200,     elevation_scale=1,     extruded=True,     get_fill_color=[255, 140, 0, 200],     opacity=0.8, ) m In\u00a0[\u00a0]: Copied! <pre>m.to_html(\"column_layer_example.html\")\n</pre> m.to_html(\"column_layer_example.html\")"},{"location":"notebooks/column_layer/#column-layer-example","title":"Column Layer Example\u00b6","text":"<p>3D column/bar visualization using deck.gl ColumnLayer.</p>"},{"location":"notebooks/column_layer/#generate-sample-data","title":"Generate sample data\u00b6","text":""},{"location":"notebooks/column_layer/#create-map-with-column-layer","title":"Create map with column layer\u00b6","text":""},{"location":"notebooks/column_layer/#export-to-html","title":"Export to HTML\u00b6","text":""},{"location":"notebooks/contour_layer/","title":"Contour layer","text":"In\u00a0[\u00a0]: Copied! <pre>import random\nfrom anymap_ts import DeckGLMap\n\n\n# Generate clustered points around San Francisco for density visualization\ndef generate_clustered_points(count=1000):\n    clusters = [\n        {\"center\": [-122.4194, 37.7749], \"spread\": 0.02, \"weight\": 1.5},  # Downtown SF\n        {\"center\": [-122.2711, 37.8044], \"spread\": 0.015, \"weight\": 1.2},  # Oakland\n        {\"center\": [-122.2727, 37.8716], \"spread\": 0.01, \"weight\": 1.0},  # Berkeley\n        {\n            \"center\": [-122.4098, 37.7855],\n            \"spread\": 0.008,\n            \"weight\": 2.0,\n        },  # Union Square\n    ]\n\n    points = []\n    for _ in range(count):\n        cluster = random.choice(clusters)\n        import math\n\n        angle = random.random() * math.pi * 2\n        radius = random.random() * cluster[\"spread\"]\n        lng = cluster[\"center\"][0] + math.cos(angle) * radius\n        lat = cluster[\"center\"][1] + math.sin(angle) * radius\n        points.append(\n            {\n                \"coordinates\": [lng, lat],\n                \"weight\": random.random() * cluster[\"weight\"] + 0.5,\n            }\n        )\n    return points\n\n\npoints = generate_clustered_points()\n\n# Basic contour thresholds\ncontours = [\n    {\"threshold\": 1, \"color\": [255, 255, 178], \"strokeWidth\": 1},\n    {\"threshold\": 5, \"color\": [254, 178, 76], \"strokeWidth\": 2},\n    {\"threshold\": 10, \"color\": [240, 59, 32], \"strokeWidth\": 3},\n]\n\nm = DeckGLMap(center=[-122.35, 37.8], zoom=11)\nm.add_basemap(\"CartoDB.DarkMatter\")\nm.add_contour_layer(\n    data=points,\n    name=\"contour-basic\",\n    get_position=\"coordinates\",\n    contours=contours,\n    cell_size=200,\n)\nm\n</pre> import random from anymap_ts import DeckGLMap   # Generate clustered points around San Francisco for density visualization def generate_clustered_points(count=1000):     clusters = [         {\"center\": [-122.4194, 37.7749], \"spread\": 0.02, \"weight\": 1.5},  # Downtown SF         {\"center\": [-122.2711, 37.8044], \"spread\": 0.015, \"weight\": 1.2},  # Oakland         {\"center\": [-122.2727, 37.8716], \"spread\": 0.01, \"weight\": 1.0},  # Berkeley         {             \"center\": [-122.4098, 37.7855],             \"spread\": 0.008,             \"weight\": 2.0,         },  # Union Square     ]      points = []     for _ in range(count):         cluster = random.choice(clusters)         import math          angle = random.random() * math.pi * 2         radius = random.random() * cluster[\"spread\"]         lng = cluster[\"center\"][0] + math.cos(angle) * radius         lat = cluster[\"center\"][1] + math.sin(angle) * radius         points.append(             {                 \"coordinates\": [lng, lat],                 \"weight\": random.random() * cluster[\"weight\"] + 0.5,             }         )     return points   points = generate_clustered_points()  # Basic contour thresholds contours = [     {\"threshold\": 1, \"color\": [255, 255, 178], \"strokeWidth\": 1},     {\"threshold\": 5, \"color\": [254, 178, 76], \"strokeWidth\": 2},     {\"threshold\": 10, \"color\": [240, 59, 32], \"strokeWidth\": 3}, ]  m = DeckGLMap(center=[-122.35, 37.8], zoom=11) m.add_basemap(\"CartoDB.DarkMatter\") m.add_contour_layer(     data=points,     name=\"contour-basic\",     get_position=\"coordinates\",     contours=contours,     cell_size=200, ) m In\u00a0[\u00a0]: Copied! <pre># More detailed contour thresholds (yellow to red gradient)\ndetailed_contours = [\n    {\"threshold\": 1, \"color\": [255, 255, 178], \"strokeWidth\": 1},\n    {\"threshold\": 5, \"color\": [254, 217, 118], \"strokeWidth\": 1},\n    {\"threshold\": 10, \"color\": [254, 178, 76], \"strokeWidth\": 2},\n    {\"threshold\": 20, \"color\": [253, 141, 60], \"strokeWidth\": 2},\n    {\"threshold\": 40, \"color\": [252, 78, 42], \"strokeWidth\": 3},\n    {\"threshold\": 60, \"color\": [227, 26, 28], \"strokeWidth\": 3},\n    {\"threshold\": 80, \"color\": [189, 0, 38], \"strokeWidth\": 4},\n]\n\nm2 = DeckGLMap(center=[-122.35, 37.8], zoom=11)\nm2.add_basemap(\"CartoDB.DarkMatter\")\nm2.add_contour_layer(\n    data=points,\n    name=\"contour-detailed\",\n    get_position=\"coordinates\",\n    contours=detailed_contours,\n    cell_size=200,\n)\nm2\n</pre> # More detailed contour thresholds (yellow to red gradient) detailed_contours = [     {\"threshold\": 1, \"color\": [255, 255, 178], \"strokeWidth\": 1},     {\"threshold\": 5, \"color\": [254, 217, 118], \"strokeWidth\": 1},     {\"threshold\": 10, \"color\": [254, 178, 76], \"strokeWidth\": 2},     {\"threshold\": 20, \"color\": [253, 141, 60], \"strokeWidth\": 2},     {\"threshold\": 40, \"color\": [252, 78, 42], \"strokeWidth\": 3},     {\"threshold\": 60, \"color\": [227, 26, 28], \"strokeWidth\": 3},     {\"threshold\": 80, \"color\": [189, 0, 38], \"strokeWidth\": 4}, ]  m2 = DeckGLMap(center=[-122.35, 37.8], zoom=11) m2.add_basemap(\"CartoDB.DarkMatter\") m2.add_contour_layer(     data=points,     name=\"contour-detailed\",     get_position=\"coordinates\",     contours=detailed_contours,     cell_size=200, ) m2 In\u00a0[\u00a0]: Copied! <pre>m3 = DeckGLMap(center=[-122.35, 37.8], zoom=11)\nm3.add_basemap(\"CartoDB.DarkMatter\")\nm3.add_contour_layer(\n    data=points,\n    name=\"contour-weighted\",\n    get_position=\"coordinates\",\n    get_weight=\"weight\",\n    contours=detailed_contours,\n    cell_size=200,\n    aggregation=\"SUM\",\n)\nm3\n</pre> m3 = DeckGLMap(center=[-122.35, 37.8], zoom=11) m3.add_basemap(\"CartoDB.DarkMatter\") m3.add_contour_layer(     data=points,     name=\"contour-weighted\",     get_position=\"coordinates\",     get_weight=\"weight\",     contours=detailed_contours,     cell_size=200,     aggregation=\"SUM\", ) m3 In\u00a0[\u00a0]: Copied! <pre># Blue contours for comparison\nblue_contours = [\n    {\"threshold\": 1, \"color\": [200, 220, 255], \"strokeWidth\": 1},\n    {\"threshold\": 5, \"color\": [150, 180, 255], \"strokeWidth\": 1},\n    {\"threshold\": 10, \"color\": [100, 140, 255], \"strokeWidth\": 2},\n    {\"threshold\": 20, \"color\": [50, 100, 255], \"strokeWidth\": 2},\n    {\"threshold\": 40, \"color\": [0, 60, 200], \"strokeWidth\": 3},\n]\n\nm4 = DeckGLMap(center=[-122.35, 37.8], zoom=11)\nm4.add_basemap(\"CartoDB.DarkMatter\")\n\nm4.add_contour_layer(\n    data=points,\n    name=\"contour-heat\",\n    get_position=\"coordinates\",\n    get_weight=\"weight\",\n    contours=detailed_contours,\n    cell_size=200,\n)\n\nm4.add_contour_layer(\n    data=points,\n    name=\"contour-cool\",\n    get_position=\"coordinates\",\n    get_weight=\"weight\",\n    contours=blue_contours,\n    cell_size=300,\n    visible=False,\n)\n\nm4.add_layer_control()\nm4\n</pre> # Blue contours for comparison blue_contours = [     {\"threshold\": 1, \"color\": [200, 220, 255], \"strokeWidth\": 1},     {\"threshold\": 5, \"color\": [150, 180, 255], \"strokeWidth\": 1},     {\"threshold\": 10, \"color\": [100, 140, 255], \"strokeWidth\": 2},     {\"threshold\": 20, \"color\": [50, 100, 255], \"strokeWidth\": 2},     {\"threshold\": 40, \"color\": [0, 60, 200], \"strokeWidth\": 3}, ]  m4 = DeckGLMap(center=[-122.35, 37.8], zoom=11) m4.add_basemap(\"CartoDB.DarkMatter\")  m4.add_contour_layer(     data=points,     name=\"contour-heat\",     get_position=\"coordinates\",     get_weight=\"weight\",     contours=detailed_contours,     cell_size=200, )  m4.add_contour_layer(     data=points,     name=\"contour-cool\",     get_position=\"coordinates\",     get_weight=\"weight\",     contours=blue_contours,     cell_size=300,     visible=False, )  m4.add_layer_control() m4 In\u00a0[\u00a0]: Copied! <pre>m5 = DeckGLMap(center=[-122.35, 37.8], zoom=11)\nm5.add_basemap(\"CartoDB.DarkMatter\")\n\nm5.add_deckgl_layer(\n    layer_type=\"ContourLayer\",\n    data=points,\n    name=\"contour-generic\",\n    getPosition=\"coordinates\",\n    getWeight=\"weight\",\n    contours=detailed_contours,\n    cellSize=200,\n    aggregation=\"SUM\",\n    pickable=True,\n)\nm5\n</pre> m5 = DeckGLMap(center=[-122.35, 37.8], zoom=11) m5.add_basemap(\"CartoDB.DarkMatter\")  m5.add_deckgl_layer(     layer_type=\"ContourLayer\",     data=points,     name=\"contour-generic\",     getPosition=\"coordinates\",     getWeight=\"weight\",     contours=detailed_contours,     cellSize=200,     aggregation=\"SUM\",     pickable=True, ) m5 In\u00a0[\u00a0]: Copied! <pre>m2.to_html(\"contour_layer_example.html\")\n</pre> m2.to_html(\"contour_layer_example.html\")"},{"location":"notebooks/contour_layer/#contour-layer-example","title":"Contour Layer Example\u00b6","text":"<p>This notebook demonstrates the DeckGL ContourLayer for visualizing density isolines from point data.</p>"},{"location":"notebooks/contour_layer/#basic-contour-layer","title":"Basic Contour Layer\u00b6","text":""},{"location":"notebooks/contour_layer/#contour-with-custom-thresholds-and-colors","title":"Contour with Custom Thresholds and Colors\u00b6","text":""},{"location":"notebooks/contour_layer/#contour-with-weighted-data","title":"Contour with Weighted Data\u00b6","text":""},{"location":"notebooks/contour_layer/#contour-layer-with-layer-control","title":"Contour Layer with Layer Control\u00b6","text":""},{"location":"notebooks/contour_layer/#using-the-generic-add_deckgl_layer-method","title":"Using the Generic add_deckgl_layer Method\u00b6","text":""},{"location":"notebooks/contour_layer/#export-to-html","title":"Export to HTML\u00b6","text":""},{"location":"notebooks/control_grid/","title":"Control grid","text":"In\u00a0[\u00a0]: Copied! <pre>from anymap_ts import MapLibreMap\n</pre> from anymap_ts import MapLibreMap In\u00a0[\u00a0]: Copied! <pre>m = MapLibreMap(center=[-98, 38.5], zoom=4)\nm.add_control_grid()\nm\n</pre> m = MapLibreMap(center=[-98, 38.5], zoom=4) m.add_control_grid() m In\u00a0[\u00a0]: Copied! <pre>m = MapLibreMap(center=[-98, 38.5], zoom=4)\nm.add_control_grid(exclude=[\"minimap\", \"streetView\", \"gaussianSplat\"])\nm\n</pre> m = MapLibreMap(center=[-98, 38.5], zoom=4) m.add_control_grid(exclude=[\"minimap\", \"streetView\", \"gaussianSplat\"]) m In\u00a0[\u00a0]: Copied! <pre>m = MapLibreMap(center=[-98, 38.5], zoom=4)\nm.add_control_grid(\n    default_controls=[\n        \"fullscreen\",\n        \"globe\",\n        \"terrain\",\n        \"search\",\n        \"basemap\",\n        \"measure\",\n        \"bookmark\",\n        \"print\",\n        \"inspect\",\n    ],\n)\nm\n</pre> m = MapLibreMap(center=[-98, 38.5], zoom=4) m.add_control_grid(     default_controls=[         \"fullscreen\",         \"globe\",         \"terrain\",         \"search\",         \"basemap\",         \"measure\",         \"bookmark\",         \"print\",         \"inspect\",     ], ) m In\u00a0[\u00a0]: Copied! <pre>m = MapLibreMap(center=[-98, 38.5], zoom=4)\nm.add_control_grid(\n    default_controls=[\n        \"fullscreen\",\n        \"globe\",\n        \"terrain\",\n        \"search\",\n        \"basemap\",\n        \"measure\",\n    ],\n    rows=2,\n    columns=3,\n    collapsed=False,\n)\nm\n</pre> m = MapLibreMap(center=[-98, 38.5], zoom=4) m.add_control_grid(     default_controls=[         \"fullscreen\",         \"globe\",         \"terrain\",         \"search\",         \"basemap\",         \"measure\",     ],     rows=2,     columns=3,     collapsed=False, ) m"},{"location":"notebooks/control_grid/#control-grid","title":"Control Grid\u00b6","text":"<p>This notebook demonstrates the <code>add_control_grid()</code> method, which adds a collapsible toolbar with up to 26 built-in controls (search, basemap, terrain, measure, draw, etc.) in a configurable grid layout.</p>"},{"location":"notebooks/control_grid/#all-default-controls","title":"All Default Controls\u00b6","text":"<p>Add all 26 controls with a single call. The grid dimensions are auto-calculated.</p>"},{"location":"notebooks/control_grid/#exclude-specific-controls","title":"Exclude Specific Controls\u00b6","text":"<p>Use the <code>exclude</code> parameter to remove controls you don't need.</p>"},{"location":"notebooks/control_grid/#select-specific-controls","title":"Select Specific Controls\u00b6","text":"<p>Use <code>default_controls</code> to include only the controls you want.</p>"},{"location":"notebooks/control_grid/#custom-grid-layout","title":"Custom Grid Layout\u00b6","text":"<p>Specify rows and columns for a custom grid shape.</p>"},{"location":"notebooks/deckgl/","title":"Deckgl","text":"In\u00a0[\u00a0]: Copied! <pre>from anymap_ts import DeckGLMap\n\n# Create a DeckGL map\nm = DeckGLMap(center=[-122.4, 37.8], zoom=10)\nm.add_basemap(\"CartoDB.DarkMatter\")\nm\n</pre> from anymap_ts import DeckGLMap  # Create a DeckGL map m = DeckGLMap(center=[-122.4, 37.8], zoom=10) m.add_basemap(\"CartoDB.DarkMatter\") m In\u00a0[\u00a0]: Copied! <pre># Generate sample point data\nimport random\n\npoints = [\n    {\n        \"coordinates\": [\n            -122.4 + random.uniform(-0.2, 0.2),\n            37.8 + random.uniform(-0.2, 0.2),\n        ],\n        \"value\": random.randint(1, 100),\n    }\n    for _ in range(1000)\n]\n\n# Add scatterplot layer\nm.add_scatterplot_layer(\n    data=points, name=\"scatterplot\", get_radius=100, get_fill_color=[255, 140, 0, 200]\n)\n</pre> # Generate sample point data import random  points = [     {         \"coordinates\": [             -122.4 + random.uniform(-0.2, 0.2),             37.8 + random.uniform(-0.2, 0.2),         ],         \"value\": random.randint(1, 100),     }     for _ in range(1000) ]  # Add scatterplot layer m.add_scatterplot_layer(     data=points, name=\"scatterplot\", get_radius=100, get_fill_color=[255, 140, 0, 200] ) In\u00a0[\u00a0]: Copied! <pre># Add hexagon aggregation layer\nm.add_hexagon_layer(\n    data=points, name=\"hexagons\", radius=500, elevation_scale=10, extruded=True\n)\n</pre> # Add hexagon aggregation layer m.add_hexagon_layer(     data=points, name=\"hexagons\", radius=500, elevation_scale=10, extruded=True ) In\u00a0[\u00a0]: Copied! <pre># Add heatmap layer\nm2 = DeckGLMap(center=[-122.4, 37.8], zoom=11)\nm2.add_basemap(\"CartoDB.DarkMatter\")\nm2.add_heatmap_layer(data=points, name=\"heatmap\", radius_pixels=50, intensity=1)\nm2\n</pre> # Add heatmap layer m2 = DeckGLMap(center=[-122.4, 37.8], zoom=11) m2.add_basemap(\"CartoDB.DarkMatter\") m2.add_heatmap_layer(data=points, name=\"heatmap\", radius_pixels=50, intensity=1) m2 In\u00a0[\u00a0]: Copied! <pre># Add arc layer for connections\narcs = [\n    {\"source\": [-122.4194, 37.7749], \"target\": [-122.2712, 37.8044]},\n    {\"source\": [-122.4194, 37.7749], \"target\": [-122.0308, 37.3382]},\n    {\"source\": [-122.2712, 37.8044], \"target\": [-121.8853, 37.3387]},\n]\n\nm3 = DeckGLMap(center=[-122.2, 37.6], zoom=9)\nm3.add_basemap(\"CartoDB.DarkMatter\")\nm3.add_arc_layer(\n    data=arcs,\n    name=\"connections\",\n    get_source_color=[0, 128, 255],\n    get_target_color=[255, 0, 128],\n)\nm3\n</pre> # Add arc layer for connections arcs = [     {\"source\": [-122.4194, 37.7749], \"target\": [-122.2712, 37.8044]},     {\"source\": [-122.4194, 37.7749], \"target\": [-122.0308, 37.3382]},     {\"source\": [-122.2712, 37.8044], \"target\": [-121.8853, 37.3387]}, ]  m3 = DeckGLMap(center=[-122.2, 37.6], zoom=9) m3.add_basemap(\"CartoDB.DarkMatter\") m3.add_arc_layer(     data=arcs,     name=\"connections\",     get_source_color=[0, 128, 255],     get_target_color=[255, 0, 128], ) m3 In\u00a0[\u00a0]: Copied! <pre># Export to HTML\nm.to_html(\"deckgl_example.html\")\n</pre> # Export to HTML m.to_html(\"deckgl_example.html\")"},{"location":"notebooks/deckgl/#deckgl-example","title":"DeckGL Example\u00b6","text":"<p>This notebook demonstrates the DeckGL integration in anymap-ts.</p> <p>DeckGL provides GPU-accelerated visualization layers on top of MapLibre GL JS.</p>"},{"location":"notebooks/geohash_layer/","title":"Geohash layer","text":"In\u00a0[\u00a0]: Copied! <pre>from anymap_ts import DeckGLMap\n</pre> from anymap_ts import DeckGLMap In\u00a0[\u00a0]: Copied! <pre># Sample geohash data (around San Francisco area, precision 5)\ngeohash_data = [\n    {\"geohash\": \"9q8yy\", \"value\": 150},\n    {\"geohash\": \"9q8yz\", \"value\": 200},\n    {\"geohash\": \"9q8yv\", \"value\": 180},\n    {\"geohash\": \"9q8yw\", \"value\": 250},\n    {\"geohash\": \"9q8yx\", \"value\": 300},\n    {\"geohash\": \"9q8yu\", \"value\": 220},\n    {\"geohash\": \"9q8yt\", \"value\": 190},\n    {\"geohash\": \"9q8ys\", \"value\": 280},\n    {\"geohash\": \"9q8yr\", \"value\": 170},\n    {\"geohash\": \"9q8yq\", \"value\": 230},\n]\n</pre> # Sample geohash data (around San Francisco area, precision 5) geohash_data = [     {\"geohash\": \"9q8yy\", \"value\": 150},     {\"geohash\": \"9q8yz\", \"value\": 200},     {\"geohash\": \"9q8yv\", \"value\": 180},     {\"geohash\": \"9q8yw\", \"value\": 250},     {\"geohash\": \"9q8yx\", \"value\": 300},     {\"geohash\": \"9q8yu\", \"value\": 220},     {\"geohash\": \"9q8yt\", \"value\": 190},     {\"geohash\": \"9q8ys\", \"value\": 280},     {\"geohash\": \"9q8yr\", \"value\": 170},     {\"geohash\": \"9q8yq\", \"value\": 230}, ] In\u00a0[\u00a0]: Copied! <pre>m = DeckGLMap(center=[-122.4, 37.75], zoom=10, pitch=45)\nm.add_basemap(\"CartoDB.DarkMatter\")\n\nm.add_geohash_layer(\n    data=geohash_data,\n    get_geohash=\"geohash\",\n    get_fill_color=[100, 200, 100, 180],\n    get_elevation=\"value\",\n    extruded=True,\n    elevation_scale=100,\n    pickable=True,\n)\nm\n</pre> m = DeckGLMap(center=[-122.4, 37.75], zoom=10, pitch=45) m.add_basemap(\"CartoDB.DarkMatter\")  m.add_geohash_layer(     data=geohash_data,     get_geohash=\"geohash\",     get_fill_color=[100, 200, 100, 180],     get_elevation=\"value\",     extruded=True,     elevation_scale=100,     pickable=True, ) m In\u00a0[\u00a0]: Copied! <pre>m.to_html(\"geohash_layer_example.html\")\n</pre> m.to_html(\"geohash_layer_example.html\")"},{"location":"notebooks/geohash_layer/#geohash-layer-example","title":"Geohash Layer Example\u00b6","text":"<p>Geohash spatial indexing visualization using deck.gl GeohashLayer.</p>"},{"location":"notebooks/geohash_layer/#define-geohash-data","title":"Define geohash data\u00b6","text":""},{"location":"notebooks/geohash_layer/#create-map-with-geohash-layer","title":"Create map with geohash layer\u00b6","text":""},{"location":"notebooks/geohash_layer/#export-to-html","title":"Export to HTML\u00b6","text":""},{"location":"notebooks/geojson_layer/","title":"Geojson layer","text":"In\u00a0[\u00a0]: Copied! <pre>from anymap_ts import DeckGLMap\n\n# GeoJSON FeatureCollection with mixed geometry types\ngeojson_data = {\n    \"type\": \"FeatureCollection\",\n    \"features\": [\n        # Points - Landmarks\n        {\n            \"type\": \"Feature\",\n            \"geometry\": {\"type\": \"Point\", \"coordinates\": [-122.4194, 37.7749]},\n            \"properties\": {\"name\": \"San Francisco City Hall\", \"type\": \"landmark\"},\n        },\n        {\n            \"type\": \"Feature\",\n            \"geometry\": {\"type\": \"Point\", \"coordinates\": [-122.4862, 37.8199]},\n            \"properties\": {\"name\": \"Golden Gate Bridge\", \"type\": \"landmark\"},\n        },\n        # LineStrings - Routes\n        {\n            \"type\": \"Feature\",\n            \"geometry\": {\n                \"type\": \"LineString\",\n                \"coordinates\": [\n                    [-122.4194, 37.7749],\n                    [-122.4100, 37.7855],\n                    [-122.3894, 37.7866],\n                ],\n            },\n            \"properties\": {\"name\": \"Market Street Route\", \"type\": \"route\"},\n        },\n        # Polygons - Neighborhoods\n        {\n            \"type\": \"Feature\",\n            \"geometry\": {\n                \"type\": \"Polygon\",\n                \"coordinates\": [\n                    [\n                        [-122.415, 37.795],\n                        [-122.395, 37.795],\n                        [-122.395, 37.780],\n                        [-122.415, 37.780],\n                        [-122.415, 37.795],\n                    ]\n                ],\n            },\n            \"properties\": {\n                \"name\": \"Downtown\",\n                \"type\": \"neighborhood\",\n                \"elevation\": 500,\n            },\n        },\n    ],\n}\n\nm = DeckGLMap(center=[-122.42, 37.79], zoom=12)\nm.add_basemap(\"CartoDB.DarkMatter\")\nm.add_geojson_layer(\n    data=geojson_data,\n    name=\"geojson-basic\",\n    get_fill_color=[100, 150, 255, 150],\n    get_line_color=[255, 255, 255, 200],\n    point_radius_min_pixels=5,\n)\nm\n</pre> from anymap_ts import DeckGLMap  # GeoJSON FeatureCollection with mixed geometry types geojson_data = {     \"type\": \"FeatureCollection\",     \"features\": [         # Points - Landmarks         {             \"type\": \"Feature\",             \"geometry\": {\"type\": \"Point\", \"coordinates\": [-122.4194, 37.7749]},             \"properties\": {\"name\": \"San Francisco City Hall\", \"type\": \"landmark\"},         },         {             \"type\": \"Feature\",             \"geometry\": {\"type\": \"Point\", \"coordinates\": [-122.4862, 37.8199]},             \"properties\": {\"name\": \"Golden Gate Bridge\", \"type\": \"landmark\"},         },         # LineStrings - Routes         {             \"type\": \"Feature\",             \"geometry\": {                 \"type\": \"LineString\",                 \"coordinates\": [                     [-122.4194, 37.7749],                     [-122.4100, 37.7855],                     [-122.3894, 37.7866],                 ],             },             \"properties\": {\"name\": \"Market Street Route\", \"type\": \"route\"},         },         # Polygons - Neighborhoods         {             \"type\": \"Feature\",             \"geometry\": {                 \"type\": \"Polygon\",                 \"coordinates\": [                     [                         [-122.415, 37.795],                         [-122.395, 37.795],                         [-122.395, 37.780],                         [-122.415, 37.780],                         [-122.415, 37.795],                     ]                 ],             },             \"properties\": {                 \"name\": \"Downtown\",                 \"type\": \"neighborhood\",                 \"elevation\": 500,             },         },     ], }  m = DeckGLMap(center=[-122.42, 37.79], zoom=12) m.add_basemap(\"CartoDB.DarkMatter\") m.add_geojson_layer(     data=geojson_data,     name=\"geojson-basic\",     get_fill_color=[100, 150, 255, 150],     get_line_color=[255, 255, 255, 200],     point_radius_min_pixels=5, ) m In\u00a0[\u00a0]: Copied! <pre># More detailed GeoJSON with elevation data\ngeojson_3d = {\n    \"type\": \"FeatureCollection\",\n    \"features\": [\n        {\n            \"type\": \"Feature\",\n            \"geometry\": {\n                \"type\": \"Polygon\",\n                \"coordinates\": [\n                    [\n                        [-122.415, 37.795],\n                        [-122.395, 37.795],\n                        [-122.395, 37.780],\n                        [-122.415, 37.780],\n                        [-122.415, 37.795],\n                    ]\n                ],\n            },\n            \"properties\": {\"name\": \"Downtown\", \"elevation\": 500},\n        },\n        {\n            \"type\": \"Feature\",\n            \"geometry\": {\n                \"type\": \"Polygon\",\n                \"coordinates\": [\n                    [\n                        [-122.430, 37.780],\n                        [-122.415, 37.780],\n                        [-122.415, 37.765],\n                        [-122.430, 37.765],\n                        [-122.430, 37.780],\n                    ]\n                ],\n            },\n            \"properties\": {\"name\": \"Mission\", \"elevation\": 400},\n        },\n        {\n            \"type\": \"Feature\",\n            \"geometry\": {\n                \"type\": \"Polygon\",\n                \"coordinates\": [\n                    [\n                        [-122.420, 37.810],\n                        [-122.405, 37.810],\n                        [-122.405, 37.798],\n                        [-122.420, 37.798],\n                        [-122.420, 37.810],\n                    ]\n                ],\n            },\n            \"properties\": {\"name\": \"North Beach\", \"elevation\": 300},\n        },\n    ],\n}\n\nm2 = DeckGLMap(center=[-122.42, 37.79], zoom=12, pitch=45, bearing=-17)\nm2.add_basemap(\"CartoDB.DarkMatter\")\nm2.add_geojson_layer(\n    data=geojson_3d,\n    name=\"geojson-3d\",\n    get_fill_color=[255, 100, 100, 180],\n    extruded=True,\n    get_elevation=\"elevation\",\n)\nm2\n</pre> # More detailed GeoJSON with elevation data geojson_3d = {     \"type\": \"FeatureCollection\",     \"features\": [         {             \"type\": \"Feature\",             \"geometry\": {                 \"type\": \"Polygon\",                 \"coordinates\": [                     [                         [-122.415, 37.795],                         [-122.395, 37.795],                         [-122.395, 37.780],                         [-122.415, 37.780],                         [-122.415, 37.795],                     ]                 ],             },             \"properties\": {\"name\": \"Downtown\", \"elevation\": 500},         },         {             \"type\": \"Feature\",             \"geometry\": {                 \"type\": \"Polygon\",                 \"coordinates\": [                     [                         [-122.430, 37.780],                         [-122.415, 37.780],                         [-122.415, 37.765],                         [-122.430, 37.765],                         [-122.430, 37.780],                     ]                 ],             },             \"properties\": {\"name\": \"Mission\", \"elevation\": 400},         },         {             \"type\": \"Feature\",             \"geometry\": {                 \"type\": \"Polygon\",                 \"coordinates\": [                     [                         [-122.420, 37.810],                         [-122.405, 37.810],                         [-122.405, 37.798],                         [-122.420, 37.798],                         [-122.420, 37.810],                     ]                 ],             },             \"properties\": {\"name\": \"North Beach\", \"elevation\": 300},         },     ], }  m2 = DeckGLMap(center=[-122.42, 37.79], zoom=12, pitch=45, bearing=-17) m2.add_basemap(\"CartoDB.DarkMatter\") m2.add_geojson_layer(     data=geojson_3d,     name=\"geojson-3d\",     get_fill_color=[255, 100, 100, 180],     extruded=True,     get_elevation=\"elevation\", ) m2 In\u00a0[\u00a0]: Copied! <pre># Separate GeoJSON for points and polygons\npoints_geojson = {\n    \"type\": \"FeatureCollection\",\n    \"features\": [\n        {\n            \"type\": \"Feature\",\n            \"geometry\": {\"type\": \"Point\", \"coordinates\": [-122.4194, 37.7749]},\n            \"properties\": {\"name\": \"City Hall\"},\n        },\n        {\n            \"type\": \"Feature\",\n            \"geometry\": {\"type\": \"Point\", \"coordinates\": [-122.4862, 37.8199]},\n            \"properties\": {\"name\": \"Golden Gate\"},\n        },\n        {\n            \"type\": \"Feature\",\n            \"geometry\": {\"type\": \"Point\", \"coordinates\": [-122.4534, 37.8083]},\n            \"properties\": {\"name\": \"Alcatraz\"},\n        },\n    ],\n}\n\nlines_geojson = {\n    \"type\": \"FeatureCollection\",\n    \"features\": [\n        {\n            \"type\": \"Feature\",\n            \"geometry\": {\n                \"type\": \"LineString\",\n                \"coordinates\": [\n                    [-122.4194, 37.7749],\n                    [-122.4100, 37.7855],\n                    [-122.3894, 37.7866],\n                ],\n            },\n            \"properties\": {\"name\": \"Route 1\"},\n        },\n        {\n            \"type\": \"Feature\",\n            \"geometry\": {\n                \"type\": \"LineString\",\n                \"coordinates\": [\n                    [-122.4862, 37.8199],\n                    [-122.4700, 37.8080],\n                    [-122.4534, 37.8083],\n                ],\n            },\n            \"properties\": {\"name\": \"Route 2\"},\n        },\n    ],\n}\n\nm3 = DeckGLMap(center=[-122.42, 37.79], zoom=12)\nm3.add_basemap(\"CartoDB.DarkMatter\")\n\nm3.add_geojson_layer(\n    data=points_geojson,\n    name=\"geojson-points\",\n    get_fill_color=[255, 100, 100, 255],\n    point_radius_min_pixels=8,\n)\n\nm3.add_geojson_layer(\n    data=lines_geojson,\n    name=\"geojson-lines\",\n    get_line_color=[100, 200, 255, 255],\n    line_width_min_pixels=3,\n)\n\nm3.add_geojson_layer(\n    data=geojson_3d,\n    name=\"geojson-polygons\",\n    get_fill_color=[100, 255, 150, 150],\n)\n\nm3.add_layer_control()\nm3\n</pre> # Separate GeoJSON for points and polygons points_geojson = {     \"type\": \"FeatureCollection\",     \"features\": [         {             \"type\": \"Feature\",             \"geometry\": {\"type\": \"Point\", \"coordinates\": [-122.4194, 37.7749]},             \"properties\": {\"name\": \"City Hall\"},         },         {             \"type\": \"Feature\",             \"geometry\": {\"type\": \"Point\", \"coordinates\": [-122.4862, 37.8199]},             \"properties\": {\"name\": \"Golden Gate\"},         },         {             \"type\": \"Feature\",             \"geometry\": {\"type\": \"Point\", \"coordinates\": [-122.4534, 37.8083]},             \"properties\": {\"name\": \"Alcatraz\"},         },     ], }  lines_geojson = {     \"type\": \"FeatureCollection\",     \"features\": [         {             \"type\": \"Feature\",             \"geometry\": {                 \"type\": \"LineString\",                 \"coordinates\": [                     [-122.4194, 37.7749],                     [-122.4100, 37.7855],                     [-122.3894, 37.7866],                 ],             },             \"properties\": {\"name\": \"Route 1\"},         },         {             \"type\": \"Feature\",             \"geometry\": {                 \"type\": \"LineString\",                 \"coordinates\": [                     [-122.4862, 37.8199],                     [-122.4700, 37.8080],                     [-122.4534, 37.8083],                 ],             },             \"properties\": {\"name\": \"Route 2\"},         },     ], }  m3 = DeckGLMap(center=[-122.42, 37.79], zoom=12) m3.add_basemap(\"CartoDB.DarkMatter\")  m3.add_geojson_layer(     data=points_geojson,     name=\"geojson-points\",     get_fill_color=[255, 100, 100, 255],     point_radius_min_pixels=8, )  m3.add_geojson_layer(     data=lines_geojson,     name=\"geojson-lines\",     get_line_color=[100, 200, 255, 255],     line_width_min_pixels=3, )  m3.add_geojson_layer(     data=geojson_3d,     name=\"geojson-polygons\",     get_fill_color=[100, 255, 150, 150], )  m3.add_layer_control() m3 In\u00a0[\u00a0]: Copied! <pre>m4 = DeckGLMap(center=[-122.42, 37.79], zoom=12, pitch=30)\nm4.add_basemap(\"CartoDB.DarkMatter\")\n\nm4.add_deckgl_layer(\n    layer_type=\"GeoJsonLayer\",\n    data=geojson_data,\n    name=\"geojson-generic\",\n    getFillColor=[138, 43, 226, 180],\n    getLineColor=[255, 255, 255, 200],\n    pointRadiusMinPixels=5,\n    lineWidthMinPixels=2,\n    stroked=True,\n    filled=True,\n    pickable=True,\n)\nm4\n</pre> m4 = DeckGLMap(center=[-122.42, 37.79], zoom=12, pitch=30) m4.add_basemap(\"CartoDB.DarkMatter\")  m4.add_deckgl_layer(     layer_type=\"GeoJsonLayer\",     data=geojson_data,     name=\"geojson-generic\",     getFillColor=[138, 43, 226, 180],     getLineColor=[255, 255, 255, 200],     pointRadiusMinPixels=5,     lineWidthMinPixels=2,     stroked=True,     filled=True,     pickable=True, ) m4 In\u00a0[\u00a0]: Copied! <pre>m3.to_html(\"geojson_layer_example.html\")\n</pre> m3.to_html(\"geojson_layer_example.html\")"},{"location":"notebooks/geojson_layer/#geojson-layer-example","title":"GeoJSON Layer Example\u00b6","text":"<p>This notebook demonstrates the DeckGL GeoJsonLayer for rendering GeoJSON features with mixed geometry types (Points, LineStrings, Polygons).</p>"},{"location":"notebooks/geojson_layer/#basic-geojson-layer","title":"Basic GeoJSON Layer\u00b6","text":""},{"location":"notebooks/geojson_layer/#geojson-with-3d-extrusion","title":"GeoJSON with 3D Extrusion\u00b6","text":""},{"location":"notebooks/geojson_layer/#multiple-geojson-layers-with-layer-control","title":"Multiple GeoJSON Layers with Layer Control\u00b6","text":""},{"location":"notebooks/geojson_layer/#using-the-generic-add_deckgl_layer-method","title":"Using the Generic add_deckgl_layer Method\u00b6","text":""},{"location":"notebooks/geojson_layer/#export-to-html","title":"Export to HTML\u00b6","text":""},{"location":"notebooks/great_circle_layer/","title":"Great circle layer","text":"In\u00a0[\u00a0]: Copied! <pre>from anymap_ts import DeckGLMap\n</pre> from anymap_ts import DeckGLMap In\u00a0[\u00a0]: Copied! <pre># Flight routes from San Francisco to major cities\nflight_routes = [\n    {\"source\": [-122.4, 37.8], \"target\": [-0.1, 51.5], \"name\": \"SFO -&gt; London\"},\n    {\"source\": [-122.4, 37.8], \"target\": [139.7, 35.7], \"name\": \"SFO -&gt; Tokyo\"},\n    {\"source\": [-122.4, 37.8], \"target\": [2.3, 48.9], \"name\": \"SFO -&gt; Paris\"},\n    {\"source\": [-122.4, 37.8], \"target\": [114.2, 22.3], \"name\": \"SFO -&gt; Hong Kong\"},\n    {\"source\": [-122.4, 37.8], \"target\": [151.2, -33.9], \"name\": \"SFO -&gt; Sydney\"},\n    {\"source\": [-122.4, 37.8], \"target\": [-43.2, -22.9], \"name\": \"SFO -&gt; Rio\"},\n    {\"source\": [-122.4, 37.8], \"target\": [37.6, 55.8], \"name\": \"SFO -&gt; Moscow\"},\n    {\"source\": [-122.4, 37.8], \"target\": [28.0, -26.2], \"name\": \"SFO -&gt; Johannesburg\"},\n]\n</pre> # Flight routes from San Francisco to major cities flight_routes = [     {\"source\": [-122.4, 37.8], \"target\": [-0.1, 51.5], \"name\": \"SFO -&gt; London\"},     {\"source\": [-122.4, 37.8], \"target\": [139.7, 35.7], \"name\": \"SFO -&gt; Tokyo\"},     {\"source\": [-122.4, 37.8], \"target\": [2.3, 48.9], \"name\": \"SFO -&gt; Paris\"},     {\"source\": [-122.4, 37.8], \"target\": [114.2, 22.3], \"name\": \"SFO -&gt; Hong Kong\"},     {\"source\": [-122.4, 37.8], \"target\": [151.2, -33.9], \"name\": \"SFO -&gt; Sydney\"},     {\"source\": [-122.4, 37.8], \"target\": [-43.2, -22.9], \"name\": \"SFO -&gt; Rio\"},     {\"source\": [-122.4, 37.8], \"target\": [37.6, 55.8], \"name\": \"SFO -&gt; Moscow\"},     {\"source\": [-122.4, 37.8], \"target\": [28.0, -26.2], \"name\": \"SFO -&gt; Johannesburg\"}, ] In\u00a0[\u00a0]: Copied! <pre>m = DeckGLMap(center=[-30, 30], zoom=1.5)\nm.add_basemap(\"CartoDB.DarkMatter\")\n\nm.add_great_circle_layer(\n    data=flight_routes,\n    get_source_position=\"source\",\n    get_target_position=\"target\",\n    get_source_color=[0, 200, 255, 255],\n    get_target_color=[255, 100, 100, 255],\n    get_width=2,\n    width_min_pixels=2,\n    opacity=0.8,\n)\nm\n</pre> m = DeckGLMap(center=[-30, 30], zoom=1.5) m.add_basemap(\"CartoDB.DarkMatter\")  m.add_great_circle_layer(     data=flight_routes,     get_source_position=\"source\",     get_target_position=\"target\",     get_source_color=[0, 200, 255, 255],     get_target_color=[255, 100, 100, 255],     get_width=2,     width_min_pixels=2,     opacity=0.8, ) m In\u00a0[\u00a0]: Copied! <pre>m.to_html(\"great_circle_layer_example.html\")\n</pre> m.to_html(\"great_circle_layer_example.html\")"},{"location":"notebooks/great_circle_layer/#great-circle-layer-example","title":"Great Circle Layer Example\u00b6","text":"<p>Geodesic arcs connecting locations using deck.gl GreatCircleLayer.</p>"},{"location":"notebooks/great_circle_layer/#define-flight-routes","title":"Define flight routes\u00b6","text":""},{"location":"notebooks/great_circle_layer/#create-map-with-great-circle-layer","title":"Create map with great circle layer\u00b6","text":""},{"location":"notebooks/great_circle_layer/#export-to-html","title":"Export to HTML\u00b6","text":""},{"location":"notebooks/gridcell_layer/","title":"Gridcell layer","text":"In\u00a0[\u00a0]: Copied! <pre>import random\nfrom anymap_ts import DeckGLMap\n</pre> import random from anymap_ts import DeckGLMap In\u00a0[\u00a0]: Copied! <pre># Generate a grid of cells\ngrid_cells = []\ncenter_lng, center_lat = -122.4, 37.8\ngrid_size = 10\n\nfor i in range(grid_size):\n    for j in range(grid_size):\n        grid_cells.append(\n            {\n                \"position\": [\n                    center_lng + (i - grid_size / 2) * 0.003,\n                    center_lat + (j - grid_size / 2) * 0.003,\n                ],\n                \"elevation\": random.randint(100, 1000),\n                \"color\": [\n                    random.randint(100, 255),\n                    random.randint(100, 255),\n                    255,\n                    200,\n                ],\n            }\n        )\n</pre> # Generate a grid of cells grid_cells = [] center_lng, center_lat = -122.4, 37.8 grid_size = 10  for i in range(grid_size):     for j in range(grid_size):         grid_cells.append(             {                 \"position\": [                     center_lng + (i - grid_size / 2) * 0.003,                     center_lat + (j - grid_size / 2) * 0.003,                 ],                 \"elevation\": random.randint(100, 1000),                 \"color\": [                     random.randint(100, 255),                     random.randint(100, 255),                     255,                     200,                 ],             }         ) In\u00a0[\u00a0]: Copied! <pre>m = DeckGLMap(center=[-122.4, 37.8], zoom=12, pitch=45, bearing=-17)\nm.add_basemap(\"CartoDB.DarkMatter\")\n\nm.add_grid_cell_layer(\n    data=grid_cells,\n    get_position=\"position\",\n    get_elevation=\"elevation\",\n    get_fill_color=\"color\",\n    cell_size=200,\n    extruded=True,\n    elevation_scale=1,\n    pickable=True,\n)\nm\n</pre> m = DeckGLMap(center=[-122.4, 37.8], zoom=12, pitch=45, bearing=-17) m.add_basemap(\"CartoDB.DarkMatter\")  m.add_grid_cell_layer(     data=grid_cells,     get_position=\"position\",     get_elevation=\"elevation\",     get_fill_color=\"color\",     cell_size=200,     extruded=True,     elevation_scale=1,     pickable=True, ) m In\u00a0[\u00a0]: Copied! <pre>m.to_html(\"gridcell_layer_example.html\")\n</pre> m.to_html(\"gridcell_layer_example.html\")"},{"location":"notebooks/gridcell_layer/#grid-cell-layer-example","title":"Grid Cell Layer Example\u00b6","text":"<p>Regular grid cell visualization using deck.gl GridCellLayer.</p>"},{"location":"notebooks/gridcell_layer/#generate-grid-cell-data","title":"Generate grid cell data\u00b6","text":""},{"location":"notebooks/gridcell_layer/#create-map-with-grid-cell-layer","title":"Create map with grid cell layer\u00b6","text":""},{"location":"notebooks/gridcell_layer/#export-to-html","title":"Export to HTML\u00b6","text":""},{"location":"notebooks/h3_cluster_layer/","title":"H3 cluster layer","text":"In\u00a0[\u00a0]: Copied! <pre>from anymap_ts import DeckGLMap\n</pre> from anymap_ts import DeckGLMap In\u00a0[\u00a0]: Copied! <pre># Sample H3 cluster data (groups of H3 hexagons)\nh3_cluster_data = [\n    {\n        \"hexIds\": [\"852830827ffffff\", \"85283082fffffff\", \"852830877ffffff\"],\n        \"value\": 150,\n    },\n    {\n        \"hexIds\": [\"8528308a7ffffff\", \"8528308afffffff\", \"8528308b7ffffff\"],\n        \"value\": 200,\n    },\n    {\n        \"hexIds\": [\"852830957ffffff\", \"85283095fffffff\", \"852830967ffffff\"],\n        \"value\": 250,\n    },\n    {\n        \"hexIds\": [\"8528309c7ffffff\", \"8528309cfffffff\", \"8528309d7ffffff\"],\n        \"value\": 180,\n    },\n]\n</pre> # Sample H3 cluster data (groups of H3 hexagons) h3_cluster_data = [     {         \"hexIds\": [\"852830827ffffff\", \"85283082fffffff\", \"852830877ffffff\"],         \"value\": 150,     },     {         \"hexIds\": [\"8528308a7ffffff\", \"8528308afffffff\", \"8528308b7ffffff\"],         \"value\": 200,     },     {         \"hexIds\": [\"852830957ffffff\", \"85283095fffffff\", \"852830967ffffff\"],         \"value\": 250,     },     {         \"hexIds\": [\"8528309c7ffffff\", \"8528309cfffffff\", \"8528309d7ffffff\"],         \"value\": 180,     }, ] In\u00a0[\u00a0]: Copied! <pre>m = DeckGLMap(center=[-122.4, 37.75], zoom=9, pitch=45)\nm.add_basemap(\"CartoDB.DarkMatter\")\n\nm.add_h3_cluster_layer(\n    data=h3_cluster_data,\n    get_hexagons=\"hexIds\",\n    get_fill_color=[255, 100, 100, 180],\n    get_elevation=\"value\",\n    extruded=True,\n    elevation_scale=20,\n    pickable=True,\n)\nm\n</pre> m = DeckGLMap(center=[-122.4, 37.75], zoom=9, pitch=45) m.add_basemap(\"CartoDB.DarkMatter\")  m.add_h3_cluster_layer(     data=h3_cluster_data,     get_hexagons=\"hexIds\",     get_fill_color=[255, 100, 100, 180],     get_elevation=\"value\",     extruded=True,     elevation_scale=20,     pickable=True, ) m In\u00a0[\u00a0]: Copied! <pre>m.to_html(\"h3_cluster_layer_example.html\")\n</pre> m.to_html(\"h3_cluster_layer_example.html\")"},{"location":"notebooks/h3_cluster_layer/#h3-cluster-layer-example","title":"H3 Cluster Layer Example\u00b6","text":"<p>H3 hexagon clustering visualization using deck.gl H3ClusterLayer.</p>"},{"location":"notebooks/h3_cluster_layer/#define-h3-cluster-data","title":"Define H3 cluster data\u00b6","text":""},{"location":"notebooks/h3_cluster_layer/#create-map-with-h3-cluster-layer","title":"Create map with H3 cluster layer\u00b6","text":""},{"location":"notebooks/h3_cluster_layer/#export-to-html","title":"Export to HTML\u00b6","text":""},{"location":"notebooks/h3_hexagon_layer/","title":"H3 hexagon layer","text":"In\u00a0[\u00a0]: Copied! <pre>from anymap_ts import DeckGLMap\n</pre> from anymap_ts import DeckGLMap In\u00a0[\u00a0]: Copied! <pre># Sample H3 hexagon data around San Francisco (resolution 7)\nh3_data = [\n    {\"hexagon\": \"872830828ffffff\", \"value\": 100},\n    {\"hexagon\": \"87283082affffff\", \"value\": 200},\n    {\"hexagon\": \"87283082bffffff\", \"value\": 150},\n    {\"hexagon\": \"872830829ffffff\", \"value\": 300},\n    {\"hexagon\": \"87283095affffff\", \"value\": 250},\n    {\"hexagon\": \"87283095bffffff\", \"value\": 180},\n    {\"hexagon\": \"872830958ffffff\", \"value\": 220},\n    {\"hexagon\": \"872830959ffffff\", \"value\": 270},\n    {\"hexagon\": \"8728309caffffff\", \"value\": 190},\n    {\"hexagon\": \"8728309cbffffff\", \"value\": 240},\n    {\"hexagon\": \"8728309c8ffffff\", \"value\": 160},\n    {\"hexagon\": \"8728309c9ffffff\", \"value\": 310},\n]\n</pre> # Sample H3 hexagon data around San Francisco (resolution 7) h3_data = [     {\"hexagon\": \"872830828ffffff\", \"value\": 100},     {\"hexagon\": \"87283082affffff\", \"value\": 200},     {\"hexagon\": \"87283082bffffff\", \"value\": 150},     {\"hexagon\": \"872830829ffffff\", \"value\": 300},     {\"hexagon\": \"87283095affffff\", \"value\": 250},     {\"hexagon\": \"87283095bffffff\", \"value\": 180},     {\"hexagon\": \"872830958ffffff\", \"value\": 220},     {\"hexagon\": \"872830959ffffff\", \"value\": 270},     {\"hexagon\": \"8728309caffffff\", \"value\": 190},     {\"hexagon\": \"8728309cbffffff\", \"value\": 240},     {\"hexagon\": \"8728309c8ffffff\", \"value\": 160},     {\"hexagon\": \"8728309c9ffffff\", \"value\": 310}, ] In\u00a0[\u00a0]: Copied! <pre>m = DeckGLMap(center=[-122.4, 37.75], zoom=10, pitch=45)\nm.add_basemap(\"CartoDB.DarkMatter\")\n\nm.add_h3_hexagon_layer(\n    data=h3_data,\n    get_hexagon=\"hexagon\",\n    get_fill_color=[51, 136, 255, 128],\n    get_line_color=[255, 255, 255, 100],\n    get_elevation=\"value\",\n    extruded=True,\n    elevation_scale=20,\n    opacity=0.8,\n)\nm\n</pre> m = DeckGLMap(center=[-122.4, 37.75], zoom=10, pitch=45) m.add_basemap(\"CartoDB.DarkMatter\")  m.add_h3_hexagon_layer(     data=h3_data,     get_hexagon=\"hexagon\",     get_fill_color=[51, 136, 255, 128],     get_line_color=[255, 255, 255, 100],     get_elevation=\"value\",     extruded=True,     elevation_scale=20,     opacity=0.8, ) m In\u00a0[\u00a0]: Copied! <pre>m.to_html(\"h3_hexagon_layer_example.html\")\n</pre> m.to_html(\"h3_hexagon_layer_example.html\")"},{"location":"notebooks/h3_hexagon_layer/#h3-hexagon-layer-example","title":"H3 Hexagon Layer Example\u00b6","text":"<p>Visualize data using Uber's H3 spatial indexing system.</p>"},{"location":"notebooks/h3_hexagon_layer/#sample-h3-data","title":"Sample H3 data\u00b6","text":""},{"location":"notebooks/h3_hexagon_layer/#create-map-with-h3-hexagon-layer","title":"Create map with H3 hexagon layer\u00b6","text":""},{"location":"notebooks/h3_hexagon_layer/#export-to-html","title":"Export to HTML\u00b6","text":""},{"location":"notebooks/heatmap_layer/","title":"Heatmap layer","text":"In\u00a0[\u00a0]: Copied! <pre>import random\nfrom anymap_ts import DeckGLMap\n\n# Generate random points around San Francisco\npoints = [\n    {\n        \"coordinates\": [\n            -122.4 + random.uniform(-0.3, 0.3),\n            37.8 + random.uniform(-0.3, 0.3),\n        ]\n    }\n    for _ in range(2000)\n]\n\nm = DeckGLMap(center=[-122.4, 37.8], zoom=11)\nm.add_basemap(\"CartoDB.DarkMatter\")\nm.add_heatmap_layer(\n    data=points,\n    name=\"heatmap-basic\",\n    get_position=\"coordinates\",\n    radius_pixels=50,\n    intensity=1,\n    threshold=0.05,\n    opacity=1,\n)\nm\n</pre> import random from anymap_ts import DeckGLMap  # Generate random points around San Francisco points = [     {         \"coordinates\": [             -122.4 + random.uniform(-0.3, 0.3),             37.8 + random.uniform(-0.3, 0.3),         ]     }     for _ in range(2000) ]  m = DeckGLMap(center=[-122.4, 37.8], zoom=11) m.add_basemap(\"CartoDB.DarkMatter\") m.add_heatmap_layer(     data=points,     name=\"heatmap-basic\",     get_position=\"coordinates\",     radius_pixels=50,     intensity=1,     threshold=0.05,     opacity=1, ) m In\u00a0[\u00a0]: Copied! <pre>custom_colors = [\n    [255, 255, 178, 25],\n    [254, 217, 118, 85],\n    [254, 178, 76, 127],\n    [253, 141, 60, 170],\n    [240, 59, 32, 212],\n    [189, 0, 38, 255],\n]\n\nm2 = DeckGLMap(center=[-122.4, 37.8], zoom=11)\nm2.add_basemap(\"CartoDB.DarkMatter\")\nm2.add_heatmap_layer(\n    data=points,\n    name=\"heatmap-custom\",\n    get_position=\"coordinates\",\n    radius_pixels=40,\n    intensity=1.2,\n    color_range=custom_colors,\n)\nm2\n</pre> custom_colors = [     [255, 255, 178, 25],     [254, 217, 118, 85],     [254, 178, 76, 127],     [253, 141, 60, 170],     [240, 59, 32, 212],     [189, 0, 38, 255], ]  m2 = DeckGLMap(center=[-122.4, 37.8], zoom=11) m2.add_basemap(\"CartoDB.DarkMatter\") m2.add_heatmap_layer(     data=points,     name=\"heatmap-custom\",     get_position=\"coordinates\",     radius_pixels=40,     intensity=1.2,     color_range=custom_colors, ) m2 In\u00a0[\u00a0]: Copied! <pre># Points with weight values\nweighted_points = [\n    {\n        \"coordinates\": [\n            -122.4 + random.uniform(-0.3, 0.3),\n            37.8 + random.uniform(-0.3, 0.3),\n        ],\n        \"weight\": random.random(),\n    }\n    for _ in range(2000)\n]\n\nm3 = DeckGLMap(center=[-122.4, 37.8], zoom=11)\nm3.add_basemap(\"CartoDB.DarkMatter\")\nm3.add_heatmap_layer(\n    data=weighted_points,\n    name=\"heatmap-weighted\",\n    get_position=\"coordinates\",\n    get_weight=\"weight\",\n    radius_pixels=35,\n    intensity=1,\n)\nm3\n</pre> # Points with weight values weighted_points = [     {         \"coordinates\": [             -122.4 + random.uniform(-0.3, 0.3),             37.8 + random.uniform(-0.3, 0.3),         ],         \"weight\": random.random(),     }     for _ in range(2000) ]  m3 = DeckGLMap(center=[-122.4, 37.8], zoom=11) m3.add_basemap(\"CartoDB.DarkMatter\") m3.add_heatmap_layer(     data=weighted_points,     name=\"heatmap-weighted\",     get_position=\"coordinates\",     get_weight=\"weight\",     radius_pixels=35,     intensity=1, ) m3 In\u00a0[\u00a0]: Copied! <pre>m4 = DeckGLMap(center=[-122.4, 37.8], zoom=11)\nm4.add_basemap(\"CartoDB.DarkMatter\")\nm4.add_heatmap_layer(\n    data=points,\n    name=\"heatmap-density\",\n    get_position=\"coordinates\",\n    radius_pixels=50,\n)\nm4.add_layer_control()\nm4\n</pre> m4 = DeckGLMap(center=[-122.4, 37.8], zoom=11) m4.add_basemap(\"CartoDB.DarkMatter\") m4.add_heatmap_layer(     data=points,     name=\"heatmap-density\",     get_position=\"coordinates\",     radius_pixels=50, ) m4.add_layer_control() m4 In\u00a0[\u00a0]: Copied! <pre>m5 = DeckGLMap(center=[-122.4, 37.8], zoom=11)\nm5.add_basemap(\"CartoDB.DarkMatter\")\nm5.add_deckgl_layer(\n    layer_type=\"HeatmapLayer\",\n    data=points,\n    name=\"heatmap-generic\",\n    getPosition=\"coordinates\",\n    radiusPixels=45,\n    intensity=1,\n    threshold=0.05,\n)\nm5\n</pre> m5 = DeckGLMap(center=[-122.4, 37.8], zoom=11) m5.add_basemap(\"CartoDB.DarkMatter\") m5.add_deckgl_layer(     layer_type=\"HeatmapLayer\",     data=points,     name=\"heatmap-generic\",     getPosition=\"coordinates\",     radiusPixels=45,     intensity=1,     threshold=0.05, ) m5 In\u00a0[\u00a0]: Copied! <pre>m.to_html(\"heatmap_layer_example.html\")\n</pre> m.to_html(\"heatmap_layer_example.html\")"},{"location":"notebooks/heatmap_layer/#heatmap-layer-example","title":"Heatmap Layer Example\u00b6","text":"<p>This notebook demonstrates the DeckGL HeatmapLayer for density visualization.</p>"},{"location":"notebooks/heatmap_layer/#basic-heatmap-layer","title":"Basic Heatmap Layer\u00b6","text":""},{"location":"notebooks/heatmap_layer/#heatmap-with-custom-color-range","title":"Heatmap with Custom Color Range\u00b6","text":""},{"location":"notebooks/heatmap_layer/#heatmap-with-weighted-points","title":"Heatmap with Weighted Points\u00b6","text":""},{"location":"notebooks/heatmap_layer/#heatmap-with-layer-control","title":"Heatmap with Layer Control\u00b6","text":""},{"location":"notebooks/heatmap_layer/#using-the-generic-add_deckgl_layer-method","title":"Using the Generic add_deckgl_layer Method\u00b6","text":""},{"location":"notebooks/heatmap_layer/#export-to-html","title":"Export to HTML\u00b6","text":""},{"location":"notebooks/hexagon_layer/","title":"Hexagon layer","text":"In\u00a0[\u00a0]: Copied! <pre>import random\nfrom anymap_ts import DeckGLMap\n\n# Generate random points around San Francisco\npoints = [\n    {\n        \"coordinates\": [\n            -122.4 + random.uniform(-0.3, 0.3),\n            37.8 + random.uniform(-0.3, 0.3),\n        ]\n    }\n    for _ in range(2000)\n]\n\nm = DeckGLMap(center=[-122.4, 37.8], zoom=10, pitch=45)\nm.add_basemap(\"CartoDB.DarkMatter\")\nm.add_hexagon_layer(\n    data=points,\n    name=\"hexagon-basic\",\n    get_position=\"coordinates\",\n    radius=500,\n    elevation_scale=4,\n    extruded=True,\n    opacity=0.8,\n)\nm\n</pre> import random from anymap_ts import DeckGLMap  # Generate random points around San Francisco points = [     {         \"coordinates\": [             -122.4 + random.uniform(-0.3, 0.3),             37.8 + random.uniform(-0.3, 0.3),         ]     }     for _ in range(2000) ]  m = DeckGLMap(center=[-122.4, 37.8], zoom=10, pitch=45) m.add_basemap(\"CartoDB.DarkMatter\") m.add_hexagon_layer(     data=points,     name=\"hexagon-basic\",     get_position=\"coordinates\",     radius=500,     elevation_scale=4,     extruded=True,     opacity=0.8, ) m In\u00a0[\u00a0]: Copied! <pre>m2 = DeckGLMap(center=[-122.4, 37.8], zoom=10)\nm2.add_basemap(\"CartoDB.DarkMatter\")\nm2.add_hexagon_layer(\n    data=points,\n    name=\"hexagon-flat\",\n    get_position=\"coordinates\",\n    radius=400,\n    extruded=False,\n    opacity=0.7,\n)\nm2\n</pre> m2 = DeckGLMap(center=[-122.4, 37.8], zoom=10) m2.add_basemap(\"CartoDB.DarkMatter\") m2.add_hexagon_layer(     data=points,     name=\"hexagon-flat\",     get_position=\"coordinates\",     radius=400,     extruded=False,     opacity=0.7, ) m2 In\u00a0[\u00a0]: Copied! <pre>custom_colors = [\n    [68, 1, 84],\n    [72, 40, 120],\n    [62, 74, 137],\n    [49, 104, 142],\n    [38, 130, 142],\n    [53, 183, 121],\n    [109, 205, 89],\n    [180, 222, 44],\n    [253, 231, 37],\n]\n\nm3 = DeckGLMap(center=[-122.4, 37.8], zoom=10, pitch=50)\nm3.add_basemap(\"CartoDB.DarkMatter\")\nm3.add_hexagon_layer(\n    data=points,\n    name=\"hexagon-custom-colors\",\n    get_position=\"coordinates\",\n    radius=600,\n    elevation_scale=6,\n    extruded=True,\n    color_range=custom_colors,\n    opacity=0.9,\n)\nm3\n</pre> custom_colors = [     [68, 1, 84],     [72, 40, 120],     [62, 74, 137],     [49, 104, 142],     [38, 130, 142],     [53, 183, 121],     [109, 205, 89],     [180, 222, 44],     [253, 231, 37], ]  m3 = DeckGLMap(center=[-122.4, 37.8], zoom=10, pitch=50) m3.add_basemap(\"CartoDB.DarkMatter\") m3.add_hexagon_layer(     data=points,     name=\"hexagon-custom-colors\",     get_position=\"coordinates\",     radius=600,     elevation_scale=6,     extruded=True,     color_range=custom_colors,     opacity=0.9, ) m3 In\u00a0[\u00a0]: Copied! <pre>m4 = DeckGLMap(center=[-122.4, 37.8], zoom=10, pitch=40)\nm4.add_basemap(\"CartoDB.DarkMatter\")\nm4.add_hexagon_layer(\n    data=points,\n    name=\"hexagon-density\",\n    get_position=\"coordinates\",\n    radius=500,\n    elevation_scale=5,\n    extruded=True,\n)\nm4.add_layer_control()\nm4\n</pre> m4 = DeckGLMap(center=[-122.4, 37.8], zoom=10, pitch=40) m4.add_basemap(\"CartoDB.DarkMatter\") m4.add_hexagon_layer(     data=points,     name=\"hexagon-density\",     get_position=\"coordinates\",     radius=500,     elevation_scale=5,     extruded=True, ) m4.add_layer_control() m4 In\u00a0[\u00a0]: Copied! <pre>m5 = DeckGLMap(center=[-122.4, 37.8], zoom=10, pitch=45)\nm5.add_basemap(\"CartoDB.DarkMatter\")\nm5.add_deckgl_layer(\n    layer_type=\"HexagonLayer\",\n    data=points,\n    name=\"hexagon-generic\",\n    getPosition=\"coordinates\",\n    radius=500,\n    elevationScale=5,\n    extruded=True,\n    opacity=0.8,\n)\nm5\n</pre> m5 = DeckGLMap(center=[-122.4, 37.8], zoom=10, pitch=45) m5.add_basemap(\"CartoDB.DarkMatter\") m5.add_deckgl_layer(     layer_type=\"HexagonLayer\",     data=points,     name=\"hexagon-generic\",     getPosition=\"coordinates\",     radius=500,     elevationScale=5,     extruded=True,     opacity=0.8, ) m5 In\u00a0[\u00a0]: Copied! <pre>m.to_html(\"hexagon_layer_example.html\")\n</pre> m.to_html(\"hexagon_layer_example.html\")"},{"location":"notebooks/hexagon_layer/#hexagon-layer-example","title":"Hexagon Layer Example\u00b6","text":"<p>This notebook demonstrates the DeckGL HexagonLayer for hexagonal binning and aggregation.</p>"},{"location":"notebooks/hexagon_layer/#basic-hexagon-layer","title":"Basic Hexagon Layer\u00b6","text":""},{"location":"notebooks/hexagon_layer/#flat-hexagon-layer-no-extrusion","title":"Flat Hexagon Layer (No Extrusion)\u00b6","text":""},{"location":"notebooks/hexagon_layer/#custom-color-range","title":"Custom Color Range\u00b6","text":""},{"location":"notebooks/hexagon_layer/#hexagon-layer-with-layer-control","title":"Hexagon Layer with Layer Control\u00b6","text":""},{"location":"notebooks/hexagon_layer/#using-the-generic-add_deckgl_layer-method","title":"Using the Generic add_deckgl_layer Method\u00b6","text":""},{"location":"notebooks/hexagon_layer/#export-to-html","title":"Export to HTML\u00b6","text":""},{"location":"notebooks/icon_layer/","title":"Icon layer","text":"In\u00a0[\u00a0]: Copied! <pre>from anymap_ts import DeckGLMap\n\n# POI locations around San Francisco\npois = [\n    {\n        \"coordinates\": [-122.4098, 37.7855],\n        \"name\": \"Restaurant A\",\n        \"icon\": \"marker\",\n        \"size\": 40,\n    },\n    {\n        \"coordinates\": [-122.4150, 37.7820],\n        \"name\": \"Restaurant B\",\n        \"icon\": \"marker\",\n        \"size\": 35,\n    },\n    {\n        \"coordinates\": [-122.4200, 37.7890],\n        \"name\": \"Hotel A\",\n        \"icon\": \"marker\",\n        \"size\": 50,\n    },\n    {\n        \"coordinates\": [-122.4180, 37.7920],\n        \"name\": \"Hotel B\",\n        \"icon\": \"marker\",\n        \"size\": 55,\n    },\n    {\n        \"coordinates\": [-122.4194, 37.7749],\n        \"name\": \"City Hall\",\n        \"icon\": \"marker\",\n        \"size\": 60,\n    },\n    {\n        \"coordinates\": [-122.4534, 37.8083],\n        \"name\": \"Fishermans Wharf\",\n        \"icon\": \"marker\",\n        \"size\": 55,\n    },\n]\n\n# Using a public icon atlas URL (Mapbox Maki icons)\nicon_atlas = (\n    \"https://raw.githubusercontent.com/visgl/deck.gl-data/master/website/icon-atlas.png\"\n)\nicon_mapping = {\n    \"marker\": {\n        \"x\": 0,\n        \"y\": 0,\n        \"width\": 128,\n        \"height\": 128,\n        \"anchorY\": 128,\n        \"mask\": True,\n    }\n}\n\nm = DeckGLMap(center=[-122.42, 37.79], zoom=13)\nm.add_basemap(\"CartoDB.DarkMatter\")\nm.add_icon_layer(\n    data=pois,\n    name=\"icon-basic\",\n    get_position=\"coordinates\",\n    get_icon=\"icon\",\n    get_size=\"size\",\n    icon_atlas=icon_atlas,\n    icon_mapping=icon_mapping,\n    get_color=[255, 100, 100],\n    size_min_pixels=20,\n    size_max_pixels=80,\n)\nm\n</pre> from anymap_ts import DeckGLMap  # POI locations around San Francisco pois = [     {         \"coordinates\": [-122.4098, 37.7855],         \"name\": \"Restaurant A\",         \"icon\": \"marker\",         \"size\": 40,     },     {         \"coordinates\": [-122.4150, 37.7820],         \"name\": \"Restaurant B\",         \"icon\": \"marker\",         \"size\": 35,     },     {         \"coordinates\": [-122.4200, 37.7890],         \"name\": \"Hotel A\",         \"icon\": \"marker\",         \"size\": 50,     },     {         \"coordinates\": [-122.4180, 37.7920],         \"name\": \"Hotel B\",         \"icon\": \"marker\",         \"size\": 55,     },     {         \"coordinates\": [-122.4194, 37.7749],         \"name\": \"City Hall\",         \"icon\": \"marker\",         \"size\": 60,     },     {         \"coordinates\": [-122.4534, 37.8083],         \"name\": \"Fishermans Wharf\",         \"icon\": \"marker\",         \"size\": 55,     }, ]  # Using a public icon atlas URL (Mapbox Maki icons) icon_atlas = (     \"https://raw.githubusercontent.com/visgl/deck.gl-data/master/website/icon-atlas.png\" ) icon_mapping = {     \"marker\": {         \"x\": 0,         \"y\": 0,         \"width\": 128,         \"height\": 128,         \"anchorY\": 128,         \"mask\": True,     } }  m = DeckGLMap(center=[-122.42, 37.79], zoom=13) m.add_basemap(\"CartoDB.DarkMatter\") m.add_icon_layer(     data=pois,     name=\"icon-basic\",     get_position=\"coordinates\",     get_icon=\"icon\",     get_size=\"size\",     icon_atlas=icon_atlas,     icon_mapping=icon_mapping,     get_color=[255, 100, 100],     size_min_pixels=20,     size_max_pixels=80, ) m In\u00a0[\u00a0]: Copied! <pre># POIs with category-based coloring\nrestaurants = [\n    {\n        \"coordinates\": [-122.4098, 37.7855],\n        \"name\": \"Restaurant A\",\n        \"icon\": \"marker\",\n        \"size\": 40,\n        \"color\": [255, 100, 100],\n    },\n    {\n        \"coordinates\": [-122.4150, 37.7820],\n        \"name\": \"Restaurant B\",\n        \"icon\": \"marker\",\n        \"size\": 35,\n        \"color\": [255, 100, 100],\n    },\n    {\n        \"coordinates\": [-122.4200, 37.7890],\n        \"name\": \"Restaurant C\",\n        \"icon\": \"marker\",\n        \"size\": 45,\n        \"color\": [255, 100, 100],\n    },\n]\n\nhotels = [\n    {\n        \"coordinates\": [-122.4100, 37.7880],\n        \"name\": \"Hotel A\",\n        \"icon\": \"marker\",\n        \"size\": 50,\n        \"color\": [100, 150, 255],\n    },\n    {\n        \"coordinates\": [-122.4180, 37.7920],\n        \"name\": \"Hotel B\",\n        \"icon\": \"marker\",\n        \"size\": 55,\n        \"color\": [100, 150, 255],\n    },\n]\n\nattractions = [\n    {\n        \"coordinates\": [-122.4194, 37.7749],\n        \"name\": \"City Hall\",\n        \"icon\": \"marker\",\n        \"size\": 60,\n        \"color\": [100, 255, 150],\n    },\n    {\n        \"coordinates\": [-122.4534, 37.8083],\n        \"name\": \"Fishermans Wharf\",\n        \"icon\": \"marker\",\n        \"size\": 55,\n        \"color\": [100, 255, 150],\n    },\n    {\n        \"coordinates\": [-122.4862, 37.8199],\n        \"name\": \"Golden Gate View\",\n        \"icon\": \"marker\",\n        \"size\": 65,\n        \"color\": [100, 255, 150],\n    },\n]\n\nall_pois = restaurants + hotels + attractions\n\nm2 = DeckGLMap(center=[-122.42, 37.79], zoom=12)\nm2.add_basemap(\"CartoDB.DarkMatter\")\nm2.add_icon_layer(\n    data=all_pois,\n    name=\"icon-colored\",\n    get_position=\"coordinates\",\n    get_icon=\"icon\",\n    get_size=\"size\",\n    icon_atlas=icon_atlas,\n    icon_mapping=icon_mapping,\n    get_color=\"color\",\n    size_min_pixels=20,\n)\nm2\n</pre> # POIs with category-based coloring restaurants = [     {         \"coordinates\": [-122.4098, 37.7855],         \"name\": \"Restaurant A\",         \"icon\": \"marker\",         \"size\": 40,         \"color\": [255, 100, 100],     },     {         \"coordinates\": [-122.4150, 37.7820],         \"name\": \"Restaurant B\",         \"icon\": \"marker\",         \"size\": 35,         \"color\": [255, 100, 100],     },     {         \"coordinates\": [-122.4200, 37.7890],         \"name\": \"Restaurant C\",         \"icon\": \"marker\",         \"size\": 45,         \"color\": [255, 100, 100],     }, ]  hotels = [     {         \"coordinates\": [-122.4100, 37.7880],         \"name\": \"Hotel A\",         \"icon\": \"marker\",         \"size\": 50,         \"color\": [100, 150, 255],     },     {         \"coordinates\": [-122.4180, 37.7920],         \"name\": \"Hotel B\",         \"icon\": \"marker\",         \"size\": 55,         \"color\": [100, 150, 255],     }, ]  attractions = [     {         \"coordinates\": [-122.4194, 37.7749],         \"name\": \"City Hall\",         \"icon\": \"marker\",         \"size\": 60,         \"color\": [100, 255, 150],     },     {         \"coordinates\": [-122.4534, 37.8083],         \"name\": \"Fishermans Wharf\",         \"icon\": \"marker\",         \"size\": 55,         \"color\": [100, 255, 150],     },     {         \"coordinates\": [-122.4862, 37.8199],         \"name\": \"Golden Gate View\",         \"icon\": \"marker\",         \"size\": 65,         \"color\": [100, 255, 150],     }, ]  all_pois = restaurants + hotels + attractions  m2 = DeckGLMap(center=[-122.42, 37.79], zoom=12) m2.add_basemap(\"CartoDB.DarkMatter\") m2.add_icon_layer(     data=all_pois,     name=\"icon-colored\",     get_position=\"coordinates\",     get_icon=\"icon\",     get_size=\"size\",     icon_atlas=icon_atlas,     icon_mapping=icon_mapping,     get_color=\"color\",     size_min_pixels=20, ) m2 In\u00a0[\u00a0]: Copied! <pre>m3 = DeckGLMap(center=[-122.42, 37.79], zoom=12)\nm3.add_basemap(\"CartoDB.DarkMatter\")\n\nm3.add_icon_layer(\n    data=restaurants,\n    name=\"icon-restaurants\",\n    get_position=\"coordinates\",\n    get_icon=\"icon\",\n    get_size=\"size\",\n    icon_atlas=icon_atlas,\n    icon_mapping=icon_mapping,\n    get_color=[255, 100, 100],\n)\n\nm3.add_icon_layer(\n    data=hotels,\n    name=\"icon-hotels\",\n    get_position=\"coordinates\",\n    get_icon=\"icon\",\n    get_size=\"size\",\n    icon_atlas=icon_atlas,\n    icon_mapping=icon_mapping,\n    get_color=[100, 150, 255],\n)\n\nm3.add_icon_layer(\n    data=attractions,\n    name=\"icon-attractions\",\n    get_position=\"coordinates\",\n    get_icon=\"icon\",\n    get_size=\"size\",\n    icon_atlas=icon_atlas,\n    icon_mapping=icon_mapping,\n    get_color=[100, 255, 150],\n)\n\nm3.add_layer_control()\nm3\n</pre> m3 = DeckGLMap(center=[-122.42, 37.79], zoom=12) m3.add_basemap(\"CartoDB.DarkMatter\")  m3.add_icon_layer(     data=restaurants,     name=\"icon-restaurants\",     get_position=\"coordinates\",     get_icon=\"icon\",     get_size=\"size\",     icon_atlas=icon_atlas,     icon_mapping=icon_mapping,     get_color=[255, 100, 100], )  m3.add_icon_layer(     data=hotels,     name=\"icon-hotels\",     get_position=\"coordinates\",     get_icon=\"icon\",     get_size=\"size\",     icon_atlas=icon_atlas,     icon_mapping=icon_mapping,     get_color=[100, 150, 255], )  m3.add_icon_layer(     data=attractions,     name=\"icon-attractions\",     get_position=\"coordinates\",     get_icon=\"icon\",     get_size=\"size\",     icon_atlas=icon_atlas,     icon_mapping=icon_mapping,     get_color=[100, 255, 150], )  m3.add_layer_control() m3 In\u00a0[\u00a0]: Copied! <pre>m4 = DeckGLMap(center=[-122.42, 37.79], zoom=13)\nm4.add_basemap(\"CartoDB.DarkMatter\")\n\nm4.add_deckgl_layer(\n    layer_type=\"IconLayer\",\n    data=pois,\n    name=\"icon-generic\",\n    getPosition=\"coordinates\",\n    getIcon=\"icon\",\n    getSize=\"size\",\n    iconAtlas=icon_atlas,\n    iconMapping=icon_mapping,\n    getColor=[138, 43, 226],\n    sizeMinPixels=20,\n    sizeMaxPixels=80,\n    pickable=True,\n)\nm4\n</pre> m4 = DeckGLMap(center=[-122.42, 37.79], zoom=13) m4.add_basemap(\"CartoDB.DarkMatter\")  m4.add_deckgl_layer(     layer_type=\"IconLayer\",     data=pois,     name=\"icon-generic\",     getPosition=\"coordinates\",     getIcon=\"icon\",     getSize=\"size\",     iconAtlas=icon_atlas,     iconMapping=icon_mapping,     getColor=[138, 43, 226],     sizeMinPixels=20,     sizeMaxPixels=80,     pickable=True, ) m4 In\u00a0[\u00a0]: Copied! <pre>m3.to_html(\"icon_layer_example.html\")\n</pre> m3.to_html(\"icon_layer_example.html\")"},{"location":"notebooks/icon_layer/#icon-layer-example","title":"Icon Layer Example\u00b6","text":"<p>This notebook demonstrates the DeckGL IconLayer for rendering custom marker icons on maps.</p>"},{"location":"notebooks/icon_layer/#basic-icon-layer","title":"Basic Icon Layer\u00b6","text":""},{"location":"notebooks/icon_layer/#icon-layer-with-different-categories","title":"Icon Layer with Different Categories\u00b6","text":""},{"location":"notebooks/icon_layer/#multiple-icon-layers-with-layer-control","title":"Multiple Icon Layers with Layer Control\u00b6","text":""},{"location":"notebooks/icon_layer/#using-the-generic-add_deckgl_layer-method","title":"Using the Generic add_deckgl_layer Method\u00b6","text":""},{"location":"notebooks/icon_layer/#export-to-html","title":"Export to HTML\u00b6","text":""},{"location":"notebooks/keplergl/","title":"Keplergl","text":"In\u00a0[\u00a0]: Copied! <pre>from anymap_ts import KeplerGLMap\nimport pandas as pd\n\n# Create a KeplerGL map\nm = KeplerGLMap(center=[-122.4, 37.8], zoom=10)\nm\n</pre> from anymap_ts import KeplerGLMap import pandas as pd  # Create a KeplerGL map m = KeplerGLMap(center=[-122.4, 37.8], zoom=10) m In\u00a0[\u00a0]: Copied! <pre># Create sample data\nimport random\n\ndf = pd.DataFrame(\n    {\n        \"latitude\": [37.8 + random.uniform(-0.2, 0.2) for _ in range(100)],\n        \"longitude\": [-122.4 + random.uniform(-0.2, 0.2) for _ in range(100)],\n        \"value\": [random.randint(1, 100) for _ in range(100)],\n        \"category\": [random.choice([\"A\", \"B\", \"C\"]) for _ in range(100)],\n    }\n)\n\n# Add data to map\nm.add_data(df, name=\"sample_points\")\n</pre> # Create sample data import random  df = pd.DataFrame(     {         \"latitude\": [37.8 + random.uniform(-0.2, 0.2) for _ in range(100)],         \"longitude\": [-122.4 + random.uniform(-0.2, 0.2) for _ in range(100)],         \"value\": [random.randint(1, 100) for _ in range(100)],         \"category\": [random.choice([\"A\", \"B\", \"C\"]) for _ in range(100)],     } )  # Add data to map m.add_data(df, name=\"sample_points\") In\u00a0[\u00a0]: Copied! <pre># Add GeoJSON data\ngeojson = {\n    \"type\": \"FeatureCollection\",\n    \"features\": [\n        {\n            \"type\": \"Feature\",\n            \"geometry\": {\n                \"type\": \"Polygon\",\n                \"coordinates\": [\n                    [\n                        [-122.5, 37.7],\n                        [-122.3, 37.7],\n                        [-122.3, 37.9],\n                        [-122.5, 37.9],\n                        [-122.5, 37.7],\n                    ]\n                ],\n            },\n            \"properties\": {\"name\": \"Area\"},\n        }\n    ],\n}\n\nm.add_data(geojson, name=\"polygon\")\n</pre> # Add GeoJSON data geojson = {     \"type\": \"FeatureCollection\",     \"features\": [         {             \"type\": \"Feature\",             \"geometry\": {                 \"type\": \"Polygon\",                 \"coordinates\": [                     [                         [-122.5, 37.7],                         [-122.3, 37.7],                         [-122.3, 37.9],                         [-122.5, 37.9],                         [-122.5, 37.7],                     ]                 ],             },             \"properties\": {\"name\": \"Area\"},         }     ], }  m.add_data(geojson, name=\"polygon\") In\u00a0[\u00a0]: Copied! <pre># Export to HTML (limited interactivity)\nm.to_html(\"keplergl_example.html\")\n</pre> # Export to HTML (limited interactivity) m.to_html(\"keplergl_example.html\")"},{"location":"notebooks/keplergl/#keplergl-example","title":"KeplerGL Example\u00b6","text":"<p>This notebook demonstrates the KeplerGL integration in anymap-ts.</p> <p>KeplerGL is a powerful data exploration tool built on deck.gl.</p> <p>Note: For best results, use the anywidget interface in Jupyter. HTML export has limited interactivity.</p>"},{"location":"notebooks/leaflet/","title":"Leaflet","text":"In\u00a0[\u00a0]: Copied! <pre>from anymap_ts import LeafletMap\n\n# Create a Leaflet map\nm = LeafletMap(center=[-122.4, 37.8], zoom=10)\nm.add_basemap(\"OpenStreetMap\")\nm\n</pre> from anymap_ts import LeafletMap  # Create a Leaflet map m = LeafletMap(center=[-122.4, 37.8], zoom=10) m.add_basemap(\"OpenStreetMap\") m In\u00a0[\u00a0]: Copied! <pre># Add markers\nm.add_marker(-122.4194, 37.7749, popup=\"San Francisco\")\nm.add_marker(-122.2712, 37.8044, popup=\"Oakland\")\n</pre> # Add markers m.add_marker(-122.4194, 37.7749, popup=\"San Francisco\") m.add_marker(-122.2712, 37.8044, popup=\"Oakland\") In\u00a0[\u00a0]: Copied! <pre># Add GeoJSON\ngeojson = {\n    \"type\": \"FeatureCollection\",\n    \"features\": [\n        {\n            \"type\": \"Feature\",\n            \"geometry\": {\n                \"type\": \"Polygon\",\n                \"coordinates\": [\n                    [\n                        [-122.5, 37.7],\n                        [-122.3, 37.7],\n                        [-122.3, 37.9],\n                        [-122.5, 37.9],\n                        [-122.5, 37.7],\n                    ]\n                ],\n            },\n            \"properties\": {\"name\": \"Area\"},\n        }\n    ],\n}\n\nm.add_geojson(geojson, name=\"polygon\")\n</pre> # Add GeoJSON geojson = {     \"type\": \"FeatureCollection\",     \"features\": [         {             \"type\": \"Feature\",             \"geometry\": {                 \"type\": \"Polygon\",                 \"coordinates\": [                     [                         [-122.5, 37.7],                         [-122.3, 37.7],                         [-122.3, 37.9],                         [-122.5, 37.9],                         [-122.5, 37.7],                     ]                 ],             },             \"properties\": {\"name\": \"Area\"},         }     ], }  m.add_geojson(geojson, name=\"polygon\") In\u00a0[\u00a0]: Copied! <pre># Add controls\nm.add_control(\"scale\", position=\"bottom-left\")\n</pre> # Add controls m.add_control(\"scale\", position=\"bottom-left\") In\u00a0[\u00a0]: Copied! <pre># Export to HTML\nm.to_html(\"leaflet_example.html\")\n</pre> # Export to HTML m.to_html(\"leaflet_example.html\")"},{"location":"notebooks/leaflet/#leaflet-example","title":"Leaflet Example\u00b6","text":"<p>This notebook demonstrates the Leaflet integration in anymap-ts.</p> <p>Leaflet is a lightweight, open-source JavaScript library for mobile-friendly interactive maps.</p>"},{"location":"notebooks/lidar_layer/","title":"Lidar layer","text":"In\u00a0[\u00a0]: Copied! <pre>from anymap_ts import MapLibreMap\n\n# Create map centered on Autzen Stadium, Eugene, Oregon\nm = MapLibreMap(center=[-123.07, 44.05], zoom=15, pitch=60, bearing=-20, height=\"800px\")\nm.add_basemap(\"CartoDB.DarkMatter\")\n\n# Add the LiDAR control panel\n# Users can load files via the UI, change color schemes, filter classifications, etc.\nm.add_lidar_control(\n    position=\"top-left\",\n    collapsed=False,\n    color_scheme=\"classification\",\n    pickable=True,\n    point_size=2,\n    panel_max_height=600,\n)\nm\n</pre> from anymap_ts import MapLibreMap  # Create map centered on Autzen Stadium, Eugene, Oregon m = MapLibreMap(center=[-123.07, 44.05], zoom=15, pitch=60, bearing=-20, height=\"800px\") m.add_basemap(\"CartoDB.DarkMatter\")  # Add the LiDAR control panel # Users can load files via the UI, change color schemes, filter classifications, etc. m.add_lidar_control(     position=\"top-left\",     collapsed=False,     color_scheme=\"classification\",     pickable=True,     point_size=2,     panel_max_height=600, ) m In\u00a0[\u00a0]: Copied! <pre>from anymap_ts import MapLibreMap\n\n# Autzen Stadium COPC dataset\nAUTZEN_URL = \"https://s3.amazonaws.com/hobu-lidar/autzen-classified.copc.laz\"\n\nm2 = MapLibreMap(\n    center=[-123.07, 44.05],\n    zoom=15,\n    pitch=60,\n)\nm2.add_basemap(\"CartoDB.DarkMatter\")\n\n# Load LiDAR from URL\nm2.add_lidar_layer(\n    source=AUTZEN_URL,\n    name=\"autzen\",\n    color_scheme=\"elevation\",\n    point_size=2,\n    opacity=1.0,\n    pickable=True,\n    auto_zoom=True,\n    streaming_mode=True,\n)\nm2\n</pre> from anymap_ts import MapLibreMap  # Autzen Stadium COPC dataset AUTZEN_URL = \"https://s3.amazonaws.com/hobu-lidar/autzen-classified.copc.laz\"  m2 = MapLibreMap(     center=[-123.07, 44.05],     zoom=15,     pitch=60, ) m2.add_basemap(\"CartoDB.DarkMatter\")  # Load LiDAR from URL m2.add_lidar_layer(     source=AUTZEN_URL,     name=\"autzen\",     color_scheme=\"elevation\",     point_size=2,     opacity=1.0,     pickable=True,     auto_zoom=True,     streaming_mode=True, ) m2 In\u00a0[\u00a0]: Copied! <pre>from anymap_ts import MapLibreMap\n\nm3 = MapLibreMap(\n    center=[-123.07, 44.05],\n    zoom=15,\n    pitch=60,\n)\nm3.add_basemap(\"CartoDB.DarkMatter\")\n\n# Classification color scheme shows different land cover types\nm3.add_lidar_layer(\n    source=\"https://s3.amazonaws.com/hobu-lidar/autzen-classified.copc.laz\",\n    name=\"autzen-classification\",\n    color_scheme=\"classification\",  # Ground, vegetation, buildings, etc.\n    point_size=2,\n    pickable=True,\n)\n\n# Add layer control to manage LiDAR visibility\n# Note: add_layer_control should be called AFTER add_lidar_layer\nm3.add_layer_control(position=\"top-right\", collapsed=False)\nm3\n</pre> from anymap_ts import MapLibreMap  m3 = MapLibreMap(     center=[-123.07, 44.05],     zoom=15,     pitch=60, ) m3.add_basemap(\"CartoDB.DarkMatter\")  # Classification color scheme shows different land cover types m3.add_lidar_layer(     source=\"https://s3.amazonaws.com/hobu-lidar/autzen-classified.copc.laz\",     name=\"autzen-classification\",     color_scheme=\"classification\",  # Ground, vegetation, buildings, etc.     point_size=2,     pickable=True, )  # Add layer control to manage LiDAR visibility # Note: add_layer_control should be called AFTER add_lidar_layer m3.add_layer_control(position=\"top-right\", collapsed=False) m3 In\u00a0[\u00a0]: Copied! <pre>from anymap_ts import MapLibreMap\n\nm4 = MapLibreMap(\n    center=[-123.07, 44.05],\n    zoom=15,\n    pitch=60,\n)\nm4.add_basemap(\"CartoDB.DarkMatter\")\n\n# Intensity color scheme highlights reflectivity\nm4.add_lidar_layer(\n    source=\"https://s3.amazonaws.com/hobu-lidar/autzen-classified.copc.laz\",\n    name=\"autzen-intensity\",\n    color_scheme=\"intensity\",\n    point_size=2,\n    pickable=True,\n)\nm4\n</pre> from anymap_ts import MapLibreMap  m4 = MapLibreMap(     center=[-123.07, 44.05],     zoom=15,     pitch=60, ) m4.add_basemap(\"CartoDB.DarkMatter\")  # Intensity color scheme highlights reflectivity m4.add_lidar_layer(     source=\"https://s3.amazonaws.com/hobu-lidar/autzen-classified.copc.laz\",     name=\"autzen-intensity\",     color_scheme=\"intensity\",     point_size=2,     pickable=True, ) m4 In\u00a0[\u00a0]: Copied! <pre># Change the color scheme of an existing LiDAR layer\nm2.set_lidar_color_scheme(\"classification\")\n</pre> # Change the color scheme of an existing LiDAR layer m2.set_lidar_color_scheme(\"classification\") In\u00a0[\u00a0]: Copied! <pre># Change to intensity\nm2.set_lidar_color_scheme(\"intensity\")\n</pre> # Change to intensity m2.set_lidar_color_scheme(\"intensity\") In\u00a0[\u00a0]: Copied! <pre># Change back to elevation\nm2.set_lidar_color_scheme(\"elevation\")\n</pre> # Change back to elevation m2.set_lidar_color_scheme(\"elevation\") In\u00a0[\u00a0]: Copied! <pre># Increase point size\nm2.set_lidar_point_size(4)\n</pre> # Increase point size m2.set_lidar_point_size(4) In\u00a0[\u00a0]: Copied! <pre># Decrease opacity\nm2.set_lidar_opacity(0.7)\n</pre> # Decrease opacity m2.set_lidar_opacity(0.7) In\u00a0[\u00a0]: Copied! <pre># Reset to defaults\nm2.set_lidar_point_size(2)\nm2.set_lidar_opacity(1.0)\n</pre> # Reset to defaults m2.set_lidar_point_size(2) m2.set_lidar_opacity(1.0) In\u00a0[\u00a0]: Copied! <pre># Remove a specific LiDAR layer\nm2.remove_lidar_layer(\"autzen\")\n</pre> # Remove a specific LiDAR layer m2.remove_lidar_layer(\"autzen\") In\u00a0[\u00a0]: Copied! <pre>m3.to_html(\"lidar_layer_example.html\")\n</pre> m3.to_html(\"lidar_layer_example.html\")"},{"location":"notebooks/lidar_layer/#lidar-layer-example","title":"LiDAR Layer Example\u00b6","text":"<p>This notebook demonstrates LiDAR point cloud visualization using the <code>maplibre-gl-lidar</code> package.</p> <p>Key features:</p> <ul> <li>Load LAS, LAZ, and COPC (Cloud-Optimized Point Cloud) files</li> <li>Color schemes: elevation, intensity, classification, RGB</li> <li>Interactive control panel with classification filtering</li> <li>Streaming support for large COPC files</li> <li>Point picking with attribute tooltips</li> </ul>"},{"location":"notebooks/lidar_layer/#basic-lidar-with-maplibre-interactive-control-panel","title":"Basic LiDAR with MapLibre (Interactive Control Panel)\u00b6","text":""},{"location":"notebooks/lidar_layer/#programmatic-lidar-loading-from-url","title":"Programmatic LiDAR Loading from URL\u00b6","text":"<p>Load LiDAR data directly from a URL without the control panel UI.</p>"},{"location":"notebooks/lidar_layer/#color-scheme-classification-with-layer-control","title":"Color Scheme: Classification with Layer Control\u00b6","text":"<p>Visualize LiDAR data colored by classification codes (ground, vegetation, buildings, etc.). The layer control allows toggling visibility and adjusting opacity of the LiDAR layer.</p>"},{"location":"notebooks/lidar_layer/#color-scheme-intensity","title":"Color Scheme: Intensity\u00b6","text":"<p>Visualize LiDAR data colored by return intensity values.</p>"},{"location":"notebooks/lidar_layer/#change-color-scheme-dynamically","title":"Change Color Scheme Dynamically\u00b6","text":""},{"location":"notebooks/lidar_layer/#adjust-point-size-and-opacity","title":"Adjust Point Size and Opacity\u00b6","text":""},{"location":"notebooks/lidar_layer/#remove-lidar-layer","title":"Remove LiDAR Layer\u00b6","text":""},{"location":"notebooks/lidar_layer/#export-to-html","title":"Export to HTML\u00b6","text":""},{"location":"notebooks/mapbox/","title":"Mapbox","text":"In\u00a0[\u00a0]: Copied! <pre>import os\nfrom anymap_ts import MapboxMap\n\n# Create a Mapbox map (uses MAPBOX_TOKEN env var)\nm = MapboxMap(center=[-122.4, 37.8], zoom=10)\nm.add_basemap(\"OpenStreetMap\")\nm\n</pre> import os from anymap_ts import MapboxMap  # Create a Mapbox map (uses MAPBOX_TOKEN env var) m = MapboxMap(center=[-122.4, 37.8], zoom=10) m.add_basemap(\"OpenStreetMap\") m In\u00a0[\u00a0]: Copied! <pre># Add GeoJSON data\ngeojson = {\n    \"type\": \"FeatureCollection\",\n    \"features\": [\n        {\n            \"type\": \"Feature\",\n            \"geometry\": {\"type\": \"Point\", \"coordinates\": [-122.4194, 37.7749]},\n            \"properties\": {\"name\": \"San Francisco\"},\n        },\n        {\n            \"type\": \"Feature\",\n            \"geometry\": {\"type\": \"Point\", \"coordinates\": [-122.2712, 37.8044]},\n            \"properties\": {\"name\": \"Oakland\"},\n        },\n    ],\n}\n\nm.add_geojson(geojson, name=\"cities\")\n</pre> # Add GeoJSON data geojson = {     \"type\": \"FeatureCollection\",     \"features\": [         {             \"type\": \"Feature\",             \"geometry\": {\"type\": \"Point\", \"coordinates\": [-122.4194, 37.7749]},             \"properties\": {\"name\": \"San Francisco\"},         },         {             \"type\": \"Feature\",             \"geometry\": {\"type\": \"Point\", \"coordinates\": [-122.2712, 37.8044]},             \"properties\": {\"name\": \"Oakland\"},         },     ], }  m.add_geojson(geojson, name=\"cities\") In\u00a0[\u00a0]: Copied! <pre># Fly to a location\nm.fly_to(-122.4194, 37.7749, zoom=12)\n</pre> # Fly to a location m.fly_to(-122.4194, 37.7749, zoom=12) In\u00a0[\u00a0]: Copied! <pre># Export to HTML\nm.to_html(\"mapbox_example.html\")\n</pre> # Export to HTML m.to_html(\"mapbox_example.html\")"},{"location":"notebooks/mapbox/#mapbox-gl-js-example","title":"Mapbox GL JS Example\u00b6","text":"<p>This notebook demonstrates the Mapbox GL JS integration in anymap-ts.</p> <p>Note: You need a Mapbox access token to use Mapbox. Set the <code>MAPBOX_TOKEN</code> environment variable or pass <code>access_token</code> to the constructor.</p>"},{"location":"notebooks/maplibre/","title":"Maplibre","text":"In\u00a0[\u00a0]: Copied! <pre>from anymap_ts import Map\n\nm = Map(center=[-122.4, 37.8], zoom=10)\nm.add_basemap(\"OpenStreetMap\")\nm.add_draw_control(position=\"top-left\")\nm.add_layer_control()\nm\n</pre> from anymap_ts import Map  m = Map(center=[-122.4, 37.8], zoom=10) m.add_basemap(\"OpenStreetMap\") m.add_draw_control(position=\"top-left\") m.add_layer_control() m In\u00a0[\u00a0]: Copied! <pre>m.get_draw_data()\n</pre> m.get_draw_data() In\u00a0[\u00a0]: Copied! <pre>m.to_html(\"map.html\")\n</pre> m.to_html(\"map.html\")"},{"location":"notebooks/mvt_layer/","title":"Mvt layer","text":"In\u00a0[\u00a0]: Copied! <pre>from anymap_ts import DeckGLMap\n</pre> from anymap_ts import DeckGLMap In\u00a0[\u00a0]: Copied! <pre>m = DeckGLMap(center=[-122.4, 37.8], zoom=11)\nm.add_basemap(\"CartoDB.DarkMatter\")\n\n# Add CARTO vector tiles\nm.add_mvt_layer(\n    data=\"https://tiles.basemaps.cartocdn.com/vectortiles/carto.streets/v1/{z}/{x}/{y}.mvt\",\n    min_zoom=0,\n    max_zoom=14,\n    get_line_color=[255, 255, 255, 200],\n    get_fill_color=[100, 130, 180, 100],\n    get_line_width=1,\n    line_width_min_pixels=1,\n    pickable=True,\n)\nm\n</pre> m = DeckGLMap(center=[-122.4, 37.8], zoom=11) m.add_basemap(\"CartoDB.DarkMatter\")  # Add CARTO vector tiles m.add_mvt_layer(     data=\"https://tiles.basemaps.cartocdn.com/vectortiles/carto.streets/v1/{z}/{x}/{y}.mvt\",     min_zoom=0,     max_zoom=14,     get_line_color=[255, 255, 255, 200],     get_fill_color=[100, 130, 180, 100],     get_line_width=1,     line_width_min_pixels=1,     pickable=True, ) m In\u00a0[\u00a0]: Copied! <pre>m.to_html(\"mvt_layer_example.html\")\n</pre> m.to_html(\"mvt_layer_example.html\")"},{"location":"notebooks/mvt_layer/#mvt-layer-example","title":"MVT Layer Example\u00b6","text":"<p>Mapbox Vector Tiles rendering using deck.gl MVTLayer.</p>"},{"location":"notebooks/mvt_layer/#create-a-map-with-mvt-layer","title":"Create a map with MVT layer\u00b6","text":""},{"location":"notebooks/mvt_layer/#export-to-html","title":"Export to HTML\u00b6","text":""},{"location":"notebooks/openlayers/","title":"Openlayers","text":"In\u00a0[\u00a0]: Copied! <pre>from anymap_ts import OpenLayersMap\n\n# Create an OpenLayers map\nm = OpenLayersMap(center=[-122.4, 37.8], zoom=10)\nm.add_basemap(\"OpenStreetMap\")\nm\n</pre> from anymap_ts import OpenLayersMap  # Create an OpenLayers map m = OpenLayersMap(center=[-122.4, 37.8], zoom=10) m.add_basemap(\"OpenStreetMap\") m In\u00a0[\u00a0]: Copied! <pre># Add GeoJSON\ngeojson = {\n    \"type\": \"FeatureCollection\",\n    \"features\": [\n        {\n            \"type\": \"Feature\",\n            \"geometry\": {\"type\": \"Point\", \"coordinates\": [-122.4194, 37.7749]},\n            \"properties\": {\"name\": \"San Francisco\"},\n        }\n    ],\n}\n\nm.add_geojson(\n    geojson,\n    name=\"cities\",\n    style={\"fillColor\": \"rgba(255, 0, 0, 0.8)\", \"strokeColor\": \"#ffffff\", \"radius\": 8},\n)\n</pre> # Add GeoJSON geojson = {     \"type\": \"FeatureCollection\",     \"features\": [         {             \"type\": \"Feature\",             \"geometry\": {\"type\": \"Point\", \"coordinates\": [-122.4194, 37.7749]},             \"properties\": {\"name\": \"San Francisco\"},         }     ], }  m.add_geojson(     geojson,     name=\"cities\",     style={\"fillColor\": \"rgba(255, 0, 0, 0.8)\", \"strokeColor\": \"#ffffff\", \"radius\": 8}, ) In\u00a0[\u00a0]: Copied! <pre># Add WMS layer (example - replace with actual WMS service)\n# m.add_wms_layer(\n#     url=\"https://example.com/wms\",\n#     layers=\"layer_name\",\n#     name=\"WMS Layer\"\n# )\n</pre> # Add WMS layer (example - replace with actual WMS service) # m.add_wms_layer( #     url=\"https://example.com/wms\", #     layers=\"layer_name\", #     name=\"WMS Layer\" # ) In\u00a0[\u00a0]: Copied! <pre># Add markers\nm.add_marker(-122.4194, 37.7749, color=\"#ff0000\")\nm.add_marker(-122.2712, 37.8044, color=\"#00ff00\")\n</pre> # Add markers m.add_marker(-122.4194, 37.7749, color=\"#ff0000\") m.add_marker(-122.2712, 37.8044, color=\"#00ff00\") In\u00a0[\u00a0]: Copied! <pre># Fly to location\nm.fly_to(-122.4194, 37.7749, zoom=14)\n</pre> # Fly to location m.fly_to(-122.4194, 37.7749, zoom=14) In\u00a0[\u00a0]: Copied! <pre># Export to HTML\nm.to_html(\"openlayers_example.html\")\n</pre> # Export to HTML m.to_html(\"openlayers_example.html\")"},{"location":"notebooks/openlayers/#openlayers-example","title":"OpenLayers Example\u00b6","text":"<p>This notebook demonstrates the OpenLayers integration in anymap-ts.</p> <p>OpenLayers is a high-performance library with excellent WMS/WMTS support and projection handling.</p>"},{"location":"notebooks/pointcloud_layer/","title":"Pointcloud layer","text":"In\u00a0[\u00a0]: Copied! <pre>import random\nfrom anymap_ts import MapLibreMap\n\n\n# Generate sample 3D point cloud data\ndef generate_points(center_lng, center_lat, num_points=1000, spread=0.01):\n    points = []\n    for _ in range(num_points):\n        lng = center_lng + random.uniform(-spread, spread)\n        lat = center_lat + random.uniform(-spread, spread)\n        # Elevation based on distance from center (creates a dome shape)\n        dist = ((lng - center_lng) ** 2 + (lat - center_lat) ** 2) ** 0.5\n        elevation = max(0, 500 - dist * 50000) + random.uniform(0, 50)\n        # Color by elevation (blue to red)\n        color_ratio = min(elevation / 500, 1)\n        color = [\n            int(255 * color_ratio),\n            int(100 * (1 - color_ratio)),\n            int(255 * (1 - color_ratio)),\n            255,\n        ]\n        points.append({\"position\": [lng, lat, elevation], \"color\": color})\n    return points\n\n\n# Generate points around San Francisco\npoint_cloud = generate_points(-122.4194, 37.7749)\n\nm = MapLibreMap(center=[-122.4194, 37.7749], zoom=14, pitch=60)\nm.add_basemap(\"CartoDB.DarkMatter\")\nm.add_point_cloud_layer(\n    data=point_cloud,\n    name=\"pointcloud-demo\",\n    get_position=\"position\",\n    get_color=\"color\",\n    point_size=3,\n    opacity=0.9,\n)\nm\n</pre> import random from anymap_ts import MapLibreMap   # Generate sample 3D point cloud data def generate_points(center_lng, center_lat, num_points=1000, spread=0.01):     points = []     for _ in range(num_points):         lng = center_lng + random.uniform(-spread, spread)         lat = center_lat + random.uniform(-spread, spread)         # Elevation based on distance from center (creates a dome shape)         dist = ((lng - center_lng) ** 2 + (lat - center_lat) ** 2) ** 0.5         elevation = max(0, 500 - dist * 50000) + random.uniform(0, 50)         # Color by elevation (blue to red)         color_ratio = min(elevation / 500, 1)         color = [             int(255 * color_ratio),             int(100 * (1 - color_ratio)),             int(255 * (1 - color_ratio)),             255,         ]         points.append({\"position\": [lng, lat, elevation], \"color\": color})     return points   # Generate points around San Francisco point_cloud = generate_points(-122.4194, 37.7749)  m = MapLibreMap(center=[-122.4194, 37.7749], zoom=14, pitch=60) m.add_basemap(\"CartoDB.DarkMatter\") m.add_point_cloud_layer(     data=point_cloud,     name=\"pointcloud-demo\",     get_position=\"position\",     get_color=\"color\",     point_size=3,     opacity=0.9, ) m In\u00a0[\u00a0]: Copied! <pre>from anymap_ts import DeckGLMap\n\n# Generate larger point cloud\nlarge_cloud = generate_points(-122.4194, 37.7749, num_points=5000, spread=0.02)\n\nm2 = DeckGLMap(center=[-122.4194, 37.7749], zoom=13, pitch=50, bearing=30)\nm2.add_basemap(\"CartoDB.DarkMatter\")\nm2.add_point_cloud_layer(\n    data=large_cloud,\n    name=\"large-cloud\",\n    get_position=\"position\",\n    get_color=\"color\",\n    point_size=2,\n    size_units=\"pixels\",\n    opacity=0.8,\n)\nm2\n</pre> from anymap_ts import DeckGLMap  # Generate larger point cloud large_cloud = generate_points(-122.4194, 37.7749, num_points=5000, spread=0.02)  m2 = DeckGLMap(center=[-122.4194, 37.7749], zoom=13, pitch=50, bearing=30) m2.add_basemap(\"CartoDB.DarkMatter\") m2.add_point_cloud_layer(     data=large_cloud,     name=\"large-cloud\",     get_position=\"position\",     get_color=\"color\",     point_size=2,     size_units=\"pixels\",     opacity=0.8, ) m2 In\u00a0[\u00a0]: Copied! <pre># Simple point cloud with uniform color\nsimple_points = [\n    {\"position\": [lng, lat, alt]}\n    for lng in [-122.42, -122.41, -122.40, -122.39]\n    for lat in [37.77, 37.78, 37.79, 37.80]\n    for alt in [0, 100, 200, 300]\n]\n\nm3 = MapLibreMap(center=[-122.405, 37.785], zoom=13, pitch=60)\nm3.add_basemap(\"CartoDB.Positron\")\nm3.add_point_cloud_layer(\n    data=simple_points,\n    name=\"grid-points\",\n    get_position=\"position\",\n    get_color=[0, 200, 255, 200],  # Uniform cyan color\n    point_size=8,\n)\nm3\n</pre> # Simple point cloud with uniform color simple_points = [     {\"position\": [lng, lat, alt]}     for lng in [-122.42, -122.41, -122.40, -122.39]     for lat in [37.77, 37.78, 37.79, 37.80]     for alt in [0, 100, 200, 300] ]  m3 = MapLibreMap(center=[-122.405, 37.785], zoom=13, pitch=60) m3.add_basemap(\"CartoDB.Positron\") m3.add_point_cloud_layer(     data=simple_points,     name=\"grid-points\",     get_position=\"position\",     get_color=[0, 200, 255, 200],  # Uniform cyan color     point_size=8, ) m3 In\u00a0[\u00a0]: Copied! <pre># Generate two point clouds\ncloud1 = generate_points(-122.43, 37.78, num_points=500, spread=0.005)\ncloud2 = generate_points(-122.40, 37.77, num_points=500, spread=0.005)\n\nm4 = MapLibreMap(center=[-122.415, 37.775], zoom=13, pitch=45)\nm4.add_basemap(\"CartoDB.DarkMatter\")\n\n# Add first point cloud (blue theme)\nfor p in cloud1:\n    p[\"color\"] = [100, 150, 255, 200]\n\nm4.add_point_cloud_layer(\n    data=cloud1,\n    name=\"pointcloud-north\",\n    get_position=\"position\",\n    get_color=\"color\",\n    point_size=4,\n)\n\n# Add second point cloud (orange theme)\nfor p in cloud2:\n    p[\"color\"] = [255, 150, 100, 200]\n\nm4.add_point_cloud_layer(\n    data=cloud2,\n    name=\"pointcloud-south\",\n    get_position=\"position\",\n    get_color=\"color\",\n    point_size=4,\n)\n\n# Add layer control\nm4.add_layer_control()\nm4\n</pre> # Generate two point clouds cloud1 = generate_points(-122.43, 37.78, num_points=500, spread=0.005) cloud2 = generate_points(-122.40, 37.77, num_points=500, spread=0.005)  m4 = MapLibreMap(center=[-122.415, 37.775], zoom=13, pitch=45) m4.add_basemap(\"CartoDB.DarkMatter\")  # Add first point cloud (blue theme) for p in cloud1:     p[\"color\"] = [100, 150, 255, 200]  m4.add_point_cloud_layer(     data=cloud1,     name=\"pointcloud-north\",     get_position=\"position\",     get_color=\"color\",     point_size=4, )  # Add second point cloud (orange theme) for p in cloud2:     p[\"color\"] = [255, 150, 100, 200]  m4.add_point_cloud_layer(     data=cloud2,     name=\"pointcloud-south\",     get_position=\"position\",     get_color=\"color\",     point_size=4, )  # Add layer control m4.add_layer_control() m4 In\u00a0[\u00a0]: Copied! <pre># Combine arc and point cloud layers\nm5 = MapLibreMap(center=[-122.4, 37.78], zoom=11, pitch=50)\nm5.add_basemap(\"CartoDB.DarkMatter\")\n\n# Add point clouds at locations\nlocations = [\n    (-122.45, 37.80),  # Golden Gate\n    (-122.40, 37.78),  # Downtown\n    (-122.35, 37.75),  # East Bay\n]\n\nfor i, (lng, lat) in enumerate(locations):\n    cloud = generate_points(lng, lat, num_points=200, spread=0.003)\n    for p in cloud:\n        p[\"color\"] = [100 + 50 * i, 200 - 50 * i, 150, 200]\n    m5.add_point_cloud_layer(\n        data=cloud,\n        name=f\"pointcloud-loc{i}\",\n        get_position=\"position\",\n        get_color=\"color\",\n        point_size=3,\n    )\n\n# Add arcs connecting the locations\narcs = [\n    {\"source\": list(locations[0]), \"target\": list(locations[1])},\n    {\"source\": list(locations[1]), \"target\": list(locations[2])},\n    {\"source\": list(locations[0]), \"target\": list(locations[2])},\n]\n\nm5.add_arc_layer(\n    data=arcs,\n    name=\"arc-connections\",\n    get_source_color=[0, 255, 200, 255],\n    get_target_color=[255, 200, 0, 255],\n    get_width=2,\n)\n\nm5.add_layer_control()\nm5\n</pre> # Combine arc and point cloud layers m5 = MapLibreMap(center=[-122.4, 37.78], zoom=11, pitch=50) m5.add_basemap(\"CartoDB.DarkMatter\")  # Add point clouds at locations locations = [     (-122.45, 37.80),  # Golden Gate     (-122.40, 37.78),  # Downtown     (-122.35, 37.75),  # East Bay ]  for i, (lng, lat) in enumerate(locations):     cloud = generate_points(lng, lat, num_points=200, spread=0.003)     for p in cloud:         p[\"color\"] = [100 + 50 * i, 200 - 50 * i, 150, 200]     m5.add_point_cloud_layer(         data=cloud,         name=f\"pointcloud-loc{i}\",         get_position=\"position\",         get_color=\"color\",         point_size=3,     )  # Add arcs connecting the locations arcs = [     {\"source\": list(locations[0]), \"target\": list(locations[1])},     {\"source\": list(locations[1]), \"target\": list(locations[2])},     {\"source\": list(locations[0]), \"target\": list(locations[2])}, ]  m5.add_arc_layer(     data=arcs,     name=\"arc-connections\",     get_source_color=[0, 255, 200, 255],     get_target_color=[255, 200, 0, 255],     get_width=2, )  m5.add_layer_control() m5 In\u00a0[\u00a0]: Copied! <pre># Remove a specific point cloud layer\nm4.remove_point_cloud_layer(\"pointcloud-north\")\n</pre> # Remove a specific point cloud layer m4.remove_point_cloud_layer(\"pointcloud-north\") In\u00a0[\u00a0]: Copied! <pre>m.to_html(\"pointcloud_layer_example.html\")\n</pre> m.to_html(\"pointcloud_layer_example.html\")"},{"location":"notebooks/pointcloud_layer/#point-cloud-layer-example","title":"Point Cloud Layer Example\u00b6","text":"<p>This notebook demonstrates the DeckGL PointCloudLayer for visualizing 3D point data.</p> <p>Point cloud layers are ideal for:</p> <ul> <li>LiDAR data visualization</li> <li>3D scanning results</li> <li>Elevation data</li> <li>Any 3D point dataset</li> </ul>"},{"location":"notebooks/pointcloud_layer/#basic-point-cloud-with-maplibre","title":"Basic Point Cloud with MapLibre\u00b6","text":""},{"location":"notebooks/pointcloud_layer/#point-cloud-with-deckglmap","title":"Point Cloud with DeckGLMap\u00b6","text":""},{"location":"notebooks/pointcloud_layer/#point-cloud-with-uniform-color","title":"Point Cloud with Uniform Color\u00b6","text":""},{"location":"notebooks/pointcloud_layer/#point-cloud-with-layer-control","title":"Point Cloud with Layer Control\u00b6","text":""},{"location":"notebooks/pointcloud_layer/#combined-arc-and-point-cloud-layers","title":"Combined Arc and Point Cloud Layers\u00b6","text":""},{"location":"notebooks/pointcloud_layer/#remove-point-cloud-layer","title":"Remove Point Cloud Layer\u00b6","text":""},{"location":"notebooks/pointcloud_layer/#export-to-html","title":"Export to HTML\u00b6","text":""},{"location":"notebooks/polygon_layer/","title":"Polygon layer","text":"In\u00a0[\u00a0]: Copied! <pre>from anymap_ts import DeckGLMap\n\n# San Francisco districts\ndistricts = [\n    {\n        \"polygon\": [\n            [-122.405, 37.795],\n            [-122.395, 37.795],\n            [-122.395, 37.785],\n            [-122.405, 37.785],\n            [-122.405, 37.795],\n        ],\n        \"name\": \"Financial District\",\n        \"elevation\": 500,\n    },\n    {\n        \"polygon\": [\n            [-122.415, 37.785],\n            [-122.395, 37.785],\n            [-122.395, 37.770],\n            [-122.415, 37.770],\n            [-122.415, 37.785],\n        ],\n        \"name\": \"SoMa\",\n        \"elevation\": 400,\n    },\n    {\n        \"polygon\": [\n            [-122.425, 37.770],\n            [-122.405, 37.770],\n            [-122.405, 37.750],\n            [-122.425, 37.750],\n            [-122.425, 37.770],\n        ],\n        \"name\": \"Mission District\",\n        \"elevation\": 350,\n    },\n    {\n        \"polygon\": [\n            [-122.410, 37.798],\n            [-122.403, 37.798],\n            [-122.403, 37.792],\n            [-122.410, 37.792],\n            [-122.410, 37.798],\n        ],\n        \"name\": \"Chinatown\",\n        \"elevation\": 300,\n    },\n]\n\nm = DeckGLMap(center=[-122.41, 37.78], zoom=13)\nm.add_basemap(\"CartoDB.DarkMatter\")\nm.add_polygon_layer(\n    data=districts,\n    name=\"polygon-basic\",\n    get_polygon=\"polygon\",\n    get_fill_color=[100, 150, 255, 150],\n    get_line_color=[255, 255, 255, 200],\n    line_width_min_pixels=2,\n)\nm\n</pre> from anymap_ts import DeckGLMap  # San Francisco districts districts = [     {         \"polygon\": [             [-122.405, 37.795],             [-122.395, 37.795],             [-122.395, 37.785],             [-122.405, 37.785],             [-122.405, 37.795],         ],         \"name\": \"Financial District\",         \"elevation\": 500,     },     {         \"polygon\": [             [-122.415, 37.785],             [-122.395, 37.785],             [-122.395, 37.770],             [-122.415, 37.770],             [-122.415, 37.785],         ],         \"name\": \"SoMa\",         \"elevation\": 400,     },     {         \"polygon\": [             [-122.425, 37.770],             [-122.405, 37.770],             [-122.405, 37.750],             [-122.425, 37.750],             [-122.425, 37.770],         ],         \"name\": \"Mission District\",         \"elevation\": 350,     },     {         \"polygon\": [             [-122.410, 37.798],             [-122.403, 37.798],             [-122.403, 37.792],             [-122.410, 37.792],             [-122.410, 37.798],         ],         \"name\": \"Chinatown\",         \"elevation\": 300,     }, ]  m = DeckGLMap(center=[-122.41, 37.78], zoom=13) m.add_basemap(\"CartoDB.DarkMatter\") m.add_polygon_layer(     data=districts,     name=\"polygon-basic\",     get_polygon=\"polygon\",     get_fill_color=[100, 150, 255, 150],     get_line_color=[255, 255, 255, 200],     line_width_min_pixels=2, ) m In\u00a0[\u00a0]: Copied! <pre>m2 = DeckGLMap(center=[-122.41, 37.78], zoom=13, pitch=45, bearing=-17)\nm2.add_basemap(\"CartoDB.DarkMatter\")\nm2.add_polygon_layer(\n    data=districts,\n    name=\"polygon-3d\",\n    get_polygon=\"polygon\",\n    get_fill_color=[255, 100, 100, 180],\n    get_line_color=[255, 255, 255, 255],\n    extruded=True,\n    get_elevation=\"elevation\",\n    line_width_min_pixels=2,\n)\nm2\n</pre> m2 = DeckGLMap(center=[-122.41, 37.78], zoom=13, pitch=45, bearing=-17) m2.add_basemap(\"CartoDB.DarkMatter\") m2.add_polygon_layer(     data=districts,     name=\"polygon-3d\",     get_polygon=\"polygon\",     get_fill_color=[255, 100, 100, 180],     get_line_color=[255, 255, 255, 255],     extruded=True,     get_elevation=\"elevation\",     line_width_min_pixels=2, ) m2 In\u00a0[\u00a0]: Copied! <pre># Additional districts\nother_districts = [\n    {\n        \"polygon\": [\n            [-122.445, 37.805],\n            [-122.425, 37.805],\n            [-122.425, 37.798],\n            [-122.445, 37.798],\n            [-122.445, 37.805],\n        ],\n        \"name\": \"Marina\",\n        \"elevation\": 200,\n    },\n    {\n        \"polygon\": [\n            [-122.440, 37.765],\n            [-122.425, 37.765],\n            [-122.425, 37.755],\n            [-122.440, 37.755],\n            [-122.440, 37.765],\n        ],\n        \"name\": \"Castro\",\n        \"elevation\": 300,\n    },\n]\n\nm3 = DeckGLMap(center=[-122.42, 37.78], zoom=12, pitch=45, bearing=-17)\nm3.add_basemap(\"CartoDB.DarkMatter\")\n\nm3.add_polygon_layer(\n    data=districts,\n    name=\"polygon-downtown\",\n    get_polygon=\"polygon\",\n    get_fill_color=[255, 100, 100, 180],\n    extruded=True,\n    get_elevation=\"elevation\",\n)\n\nm3.add_polygon_layer(\n    data=other_districts,\n    name=\"polygon-neighborhoods\",\n    get_polygon=\"polygon\",\n    get_fill_color=[100, 200, 255, 180],\n    extruded=True,\n    get_elevation=\"elevation\",\n)\n\nm3.add_layer_control()\nm3\n</pre> # Additional districts other_districts = [     {         \"polygon\": [             [-122.445, 37.805],             [-122.425, 37.805],             [-122.425, 37.798],             [-122.445, 37.798],             [-122.445, 37.805],         ],         \"name\": \"Marina\",         \"elevation\": 200,     },     {         \"polygon\": [             [-122.440, 37.765],             [-122.425, 37.765],             [-122.425, 37.755],             [-122.440, 37.755],             [-122.440, 37.765],         ],         \"name\": \"Castro\",         \"elevation\": 300,     }, ]  m3 = DeckGLMap(center=[-122.42, 37.78], zoom=12, pitch=45, bearing=-17) m3.add_basemap(\"CartoDB.DarkMatter\")  m3.add_polygon_layer(     data=districts,     name=\"polygon-downtown\",     get_polygon=\"polygon\",     get_fill_color=[255, 100, 100, 180],     extruded=True,     get_elevation=\"elevation\", )  m3.add_polygon_layer(     data=other_districts,     name=\"polygon-neighborhoods\",     get_polygon=\"polygon\",     get_fill_color=[100, 200, 255, 180],     extruded=True,     get_elevation=\"elevation\", )  m3.add_layer_control() m3 In\u00a0[\u00a0]: Copied! <pre>m4 = DeckGLMap(center=[-122.41, 37.78], zoom=13, pitch=45)\nm4.add_basemap(\"CartoDB.DarkMatter\")\n\nm4.add_deckgl_layer(\n    layer_type=\"PolygonLayer\",\n    data=districts,\n    name=\"polygon-generic\",\n    getPolygon=\"polygon\",\n    getFillColor=[100, 255, 150, 180],\n    getLineColor=[255, 255, 255, 255],\n    extruded=True,\n    getElevation=\"elevation\",\n    lineWidthMinPixels=2,\n    pickable=True,\n)\nm4\n</pre> m4 = DeckGLMap(center=[-122.41, 37.78], zoom=13, pitch=45) m4.add_basemap(\"CartoDB.DarkMatter\")  m4.add_deckgl_layer(     layer_type=\"PolygonLayer\",     data=districts,     name=\"polygon-generic\",     getPolygon=\"polygon\",     getFillColor=[100, 255, 150, 180],     getLineColor=[255, 255, 255, 255],     extruded=True,     getElevation=\"elevation\",     lineWidthMinPixels=2,     pickable=True, ) m4 In\u00a0[\u00a0]: Copied! <pre>m2.to_html(\"polygon_layer_example.html\")\n</pre> m2.to_html(\"polygon_layer_example.html\")"},{"location":"notebooks/polygon_layer/#polygon-layer-example","title":"Polygon Layer Example\u00b6","text":"<p>This notebook demonstrates the DeckGL PolygonLayer for rendering filled and stroked polygons with 3D extrusion support.</p>"},{"location":"notebooks/polygon_layer/#basic-polygon-layer-flat","title":"Basic Polygon Layer (Flat)\u00b6","text":""},{"location":"notebooks/polygon_layer/#extruded-3d-polygons","title":"Extruded 3D Polygons\u00b6","text":""},{"location":"notebooks/polygon_layer/#multiple-polygon-layers-with-layer-control","title":"Multiple Polygon Layers with Layer Control\u00b6","text":""},{"location":"notebooks/polygon_layer/#using-the-generic-add_deckgl_layer-method","title":"Using the Generic add_deckgl_layer Method\u00b6","text":""},{"location":"notebooks/polygon_layer/#export-to-html","title":"Export to HTML\u00b6","text":""},{"location":"notebooks/potree/","title":"Potree","text":"In\u00a0[\u00a0]: Copied! <pre>from anymap_ts import PotreeViewer\n\n# Create a Potree viewer\nviewer = PotreeViewer(\n    point_budget=1000000, point_size=1.0, background=\"#1a1a2e\", edl_enabled=True\n)\nviewer\n</pre> from anymap_ts import PotreeViewer  # Create a Potree viewer viewer = PotreeViewer(     point_budget=1000000, point_size=1.0, background=\"#1a1a2e\", edl_enabled=True ) viewer In\u00a0[\u00a0]: Copied! <pre># Load a point cloud (replace with your Potree-formatted dataset URL)\n# viewer.load_point_cloud(\n#     url=\"path/to/pointcloud/cloud.js\",\n#     name=\"lidar_data\",\n#     point_size_type=\"adaptive\",\n#     shape=\"circle\"\n# )\n</pre> # Load a point cloud (replace with your Potree-formatted dataset URL) # viewer.load_point_cloud( #     url=\"path/to/pointcloud/cloud.js\", #     name=\"lidar_data\", #     point_size_type=\"adaptive\", #     shape=\"circle\" # ) In\u00a0[\u00a0]: Copied! <pre># Adjust visualization settings\nviewer.set_point_budget(2000000)  # Increase for more detail\nviewer.set_point_size(1.5)\n</pre> # Adjust visualization settings viewer.set_point_budget(2000000)  # Increase for more detail viewer.set_point_size(1.5) In\u00a0[\u00a0]: Copied! <pre># Adjust Eye Dome Lighting\nviewer.set_edl(enabled=True, radius=1.8, strength=0.5)\n</pre> # Adjust Eye Dome Lighting viewer.set_edl(enabled=True, radius=1.8, strength=0.5) In\u00a0[\u00a0]: Copied! <pre># Set camera position\nviewer.set_camera_position(0, 0, 100)\nviewer.set_camera_target(0, 0, 0)\n</pre> # Set camera position viewer.set_camera_position(0, 0, 100) viewer.set_camera_target(0, 0, 0) In\u00a0[\u00a0]: Copied! <pre># Add measurement tool\n# viewer.add_measurement_tool(\"distance\")\n</pre> # Add measurement tool # viewer.add_measurement_tool(\"distance\") In\u00a0[\u00a0]: Copied! <pre># Add annotation\nviewer.add_annotation(\n    position=(10, 20, 30),\n    title=\"Point of Interest\",\n    description=\"This is an important location\",\n)\n</pre> # Add annotation viewer.add_annotation(     position=(10, 20, 30),     title=\"Point of Interest\",     description=\"This is an important location\", ) In\u00a0[\u00a0]: Copied! <pre># Export to HTML\nviewer.to_html(\"potree_example.html\")\n</pre> # Export to HTML viewer.to_html(\"potree_example.html\")"},{"location":"notebooks/potree/#potree-example","title":"Potree Example\u00b6","text":"<p>This notebook demonstrates the Potree integration in anymap-ts.</p> <p>Potree is a WebGL-based point cloud viewer for large-scale LiDAR datasets.</p> <p>Note: You need a Potree-formatted point cloud dataset (converted from LAS/LAZ) to visualize.</p>"},{"location":"notebooks/quadkey_layer/","title":"Quadkey layer","text":"In\u00a0[\u00a0]: Copied! <pre>from anymap_ts import DeckGLMap\n</pre> from anymap_ts import DeckGLMap In\u00a0[\u00a0]: Copied! <pre># Sample quadkey data (around San Francisco area)\nquadkey_data = [\n    {\"quadkey\": \"0230102\", \"value\": 150},\n    {\"quadkey\": \"0230103\", \"value\": 200},\n    {\"quadkey\": \"0230110\", \"value\": 180},\n    {\"quadkey\": \"0230111\", \"value\": 250},\n    {\"quadkey\": \"0230120\", \"value\": 300},\n    {\"quadkey\": \"0230121\", \"value\": 220},\n    {\"quadkey\": \"0230122\", \"value\": 190},\n    {\"quadkey\": \"0230123\", \"value\": 280},\n]\n</pre> # Sample quadkey data (around San Francisco area) quadkey_data = [     {\"quadkey\": \"0230102\", \"value\": 150},     {\"quadkey\": \"0230103\", \"value\": 200},     {\"quadkey\": \"0230110\", \"value\": 180},     {\"quadkey\": \"0230111\", \"value\": 250},     {\"quadkey\": \"0230120\", \"value\": 300},     {\"quadkey\": \"0230121\", \"value\": 220},     {\"quadkey\": \"0230122\", \"value\": 190},     {\"quadkey\": \"0230123\", \"value\": 280}, ] In\u00a0[\u00a0]: Copied! <pre>m = DeckGLMap(center=[-122.4, 37.75], zoom=6, pitch=45)\nm.add_basemap(\"CartoDB.DarkMatter\")\n\nm.add_quadkey_layer(\n    data=quadkey_data,\n    get_quadkey=\"quadkey\",\n    get_fill_color=[255, 140, 0, 180],\n    get_elevation=\"value\",\n    extruded=True,\n    elevation_scale=50,\n    pickable=True,\n)\nm\n</pre> m = DeckGLMap(center=[-122.4, 37.75], zoom=6, pitch=45) m.add_basemap(\"CartoDB.DarkMatter\")  m.add_quadkey_layer(     data=quadkey_data,     get_quadkey=\"quadkey\",     get_fill_color=[255, 140, 0, 180],     get_elevation=\"value\",     extruded=True,     elevation_scale=50,     pickable=True, ) m In\u00a0[\u00a0]: Copied! <pre>m.to_html(\"quadkey_layer_example.html\")\n</pre> m.to_html(\"quadkey_layer_example.html\")"},{"location":"notebooks/quadkey_layer/#quadkey-layer-example","title":"Quadkey Layer Example\u00b6","text":"<p>Bing Maps quadkey tile indexing visualization using deck.gl QuadkeyLayer.</p>"},{"location":"notebooks/quadkey_layer/#define-quadkey-data","title":"Define quadkey data\u00b6","text":""},{"location":"notebooks/quadkey_layer/#create-map-with-quadkey-layer","title":"Create map with quadkey layer\u00b6","text":""},{"location":"notebooks/quadkey_layer/#export-to-html","title":"Export to HTML\u00b6","text":""},{"location":"notebooks/s2_layer/","title":"S2 layer","text":"In\u00a0[\u00a0]: Copied! <pre>from anymap_ts import DeckGLMap\n</pre> from anymap_ts import DeckGLMap In\u00a0[\u00a0]: Copied! <pre># Sample S2 cell tokens (around San Francisco area)\ns2_data = [\n    {\"token\": \"80858c\", \"value\": 100},\n    {\"token\": \"80858d\", \"value\": 200},\n    {\"token\": \"80858e\", \"value\": 150},\n    {\"token\": \"80858f\", \"value\": 300},\n    {\"token\": \"808590\", \"value\": 250},\n    {\"token\": \"808591\", \"value\": 180},\n    {\"token\": \"808594\", \"value\": 220},\n    {\"token\": \"808595\", \"value\": 270},\n]\n</pre> # Sample S2 cell tokens (around San Francisco area) s2_data = [     {\"token\": \"80858c\", \"value\": 100},     {\"token\": \"80858d\", \"value\": 200},     {\"token\": \"80858e\", \"value\": 150},     {\"token\": \"80858f\", \"value\": 300},     {\"token\": \"808590\", \"value\": 250},     {\"token\": \"808591\", \"value\": 180},     {\"token\": \"808594\", \"value\": 220},     {\"token\": \"808595\", \"value\": 270}, ] In\u00a0[\u00a0]: Copied! <pre>m = DeckGLMap(center=[-122.4, 37.75], zoom=8, pitch=45)\nm.add_basemap(\"CartoDB.DarkMatter\")\n\nm.add_s2_layer(\n    data=s2_data,\n    get_s2_token=\"token\",\n    get_fill_color=[51, 136, 255, 180],\n    get_elevation=\"value\",\n    extruded=True,\n    elevation_scale=100,\n    pickable=True,\n)\nm\n</pre> m = DeckGLMap(center=[-122.4, 37.75], zoom=8, pitch=45) m.add_basemap(\"CartoDB.DarkMatter\")  m.add_s2_layer(     data=s2_data,     get_s2_token=\"token\",     get_fill_color=[51, 136, 255, 180],     get_elevation=\"value\",     extruded=True,     elevation_scale=100,     pickable=True, ) m In\u00a0[\u00a0]: Copied! <pre>m.to_html(\"s2_layer_example.html\")\n</pre> m.to_html(\"s2_layer_example.html\")"},{"location":"notebooks/s2_layer/#s2-layer-example","title":"S2 Layer Example\u00b6","text":"<p>Google S2 geometry cells visualization using deck.gl S2Layer.</p>"},{"location":"notebooks/s2_layer/#define-s2-cell-data","title":"Define S2 cell data\u00b6","text":""},{"location":"notebooks/s2_layer/#create-map-with-s2-layer","title":"Create map with S2 layer\u00b6","text":""},{"location":"notebooks/s2_layer/#export-to-html","title":"Export to HTML\u00b6","text":""},{"location":"notebooks/scatterplot_layer/","title":"Scatterplot layer","text":"In\u00a0[\u00a0]: Copied! <pre>import random\nfrom anymap_ts import DeckGLMap\n\n# Generate random points around San Francisco\npoints = [\n    {\n        \"coordinates\": [\n            -122.4 + random.uniform(-0.2, 0.2),\n            37.8 + random.uniform(-0.2, 0.2),\n        ],\n        \"value\": random.randint(10, 100),\n    }\n    for _ in range(500)\n]\n\nm = DeckGLMap(center=[-122.4, 37.8], zoom=10)\nm.add_basemap(\"CartoDB.DarkMatter\")\nm.add_scatterplot_layer(\n    data=points,\n    name=\"scatterplot-basic\",\n    get_position=\"coordinates\",\n    get_radius=100,\n    get_fill_color=[255, 140, 0, 200],\n    radius_min_pixels=2,\n    radius_max_pixels=20,\n)\nm\n</pre> import random from anymap_ts import DeckGLMap  # Generate random points around San Francisco points = [     {         \"coordinates\": [             -122.4 + random.uniform(-0.2, 0.2),             37.8 + random.uniform(-0.2, 0.2),         ],         \"value\": random.randint(10, 100),     }     for _ in range(500) ]  m = DeckGLMap(center=[-122.4, 37.8], zoom=10) m.add_basemap(\"CartoDB.DarkMatter\") m.add_scatterplot_layer(     data=points,     name=\"scatterplot-basic\",     get_position=\"coordinates\",     get_radius=100,     get_fill_color=[255, 140, 0, 200],     radius_min_pixels=2,     radius_max_pixels=20, ) m In\u00a0[\u00a0]: Copied! <pre>m2 = DeckGLMap(center=[-122.4, 37.8], zoom=10)\nm2.add_basemap(\"CartoDB.DarkMatter\")\nm2.add_scatterplot_layer(\n    data=points,\n    name=\"scatterplot-sized\",\n    get_position=\"coordinates\",\n    get_radius=\"value\",\n    get_fill_color=[0, 200, 100, 180],\n    radius_scale=10,\n    radius_min_pixels=3,\n    radius_max_pixels=50,\n    stroked=True,\n    get_line_color=[255, 255, 255, 200],\n    line_width_min_pixels=1,\n)\nm2\n</pre> m2 = DeckGLMap(center=[-122.4, 37.8], zoom=10) m2.add_basemap(\"CartoDB.DarkMatter\") m2.add_scatterplot_layer(     data=points,     name=\"scatterplot-sized\",     get_position=\"coordinates\",     get_radius=\"value\",     get_fill_color=[0, 200, 100, 180],     radius_scale=10,     radius_min_pixels=3,     radius_max_pixels=50,     stroked=True,     get_line_color=[255, 255, 255, 200],     line_width_min_pixels=1, ) m2 In\u00a0[\u00a0]: Copied! <pre>high_value_points = [p for p in points if p[\"value\"] &gt;= 50]\nlow_value_points = [p for p in points if p[\"value\"] &lt; 50]\n\nm3 = DeckGLMap(center=[-122.4, 37.8], zoom=10)\nm3.add_basemap(\"CartoDB.DarkMatter\")\n\nm3.add_scatterplot_layer(\n    data=high_value_points,\n    name=\"scatterplot-high-value\",\n    get_position=\"coordinates\",\n    get_radius=\"value\",\n    get_fill_color=[255, 50, 50, 200],\n    radius_scale=15,\n    radius_min_pixels=5,\n)\n\nm3.add_scatterplot_layer(\n    data=low_value_points,\n    name=\"scatterplot-low-value\",\n    get_position=\"coordinates\",\n    get_radius=\"value\",\n    get_fill_color=[50, 100, 255, 200],\n    radius_scale=15,\n    radius_min_pixels=3,\n)\n\nm3.add_layer_control()\nm3\n</pre> high_value_points = [p for p in points if p[\"value\"] &gt;= 50] low_value_points = [p for p in points if p[\"value\"] &lt; 50]  m3 = DeckGLMap(center=[-122.4, 37.8], zoom=10) m3.add_basemap(\"CartoDB.DarkMatter\")  m3.add_scatterplot_layer(     data=high_value_points,     name=\"scatterplot-high-value\",     get_position=\"coordinates\",     get_radius=\"value\",     get_fill_color=[255, 50, 50, 200],     radius_scale=15,     radius_min_pixels=5, )  m3.add_scatterplot_layer(     data=low_value_points,     name=\"scatterplot-low-value\",     get_position=\"coordinates\",     get_radius=\"value\",     get_fill_color=[50, 100, 255, 200],     radius_scale=15,     radius_min_pixels=3, )  m3.add_layer_control() m3 In\u00a0[\u00a0]: Copied! <pre>m4 = DeckGLMap(center=[-122.4, 37.8], zoom=10)\nm4.add_basemap(\"CartoDB.DarkMatter\")\n\nm4.add_deckgl_layer(\n    layer_type=\"ScatterplotLayer\",\n    data=points,\n    name=\"scatterplot-generic\",\n    getPosition=\"coordinates\",\n    getRadius=100,\n    getFillColor=[138, 43, 226, 200],\n    radiusMinPixels=3,\n    radiusMaxPixels=30,\n    opacity=0.8,\n)\nm4\n</pre> m4 = DeckGLMap(center=[-122.4, 37.8], zoom=10) m4.add_basemap(\"CartoDB.DarkMatter\")  m4.add_deckgl_layer(     layer_type=\"ScatterplotLayer\",     data=points,     name=\"scatterplot-generic\",     getPosition=\"coordinates\",     getRadius=100,     getFillColor=[138, 43, 226, 200],     radiusMinPixels=3,     radiusMaxPixels=30,     opacity=0.8, ) m4 In\u00a0[\u00a0]: Copied! <pre>m.to_html(\"scatterplot_layer_example.html\")\n</pre> m.to_html(\"scatterplot_layer_example.html\")"},{"location":"notebooks/scatterplot_layer/#scatterplot-layer-example","title":"Scatterplot Layer Example\u00b6","text":"<p>This notebook demonstrates the DeckGL ScatterplotLayer for visualizing point data.</p>"},{"location":"notebooks/scatterplot_layer/#basic-scatterplot-layer","title":"Basic Scatterplot Layer\u00b6","text":""},{"location":"notebooks/scatterplot_layer/#scatterplot-with-size-based-on-value","title":"Scatterplot with Size Based on Value\u00b6","text":""},{"location":"notebooks/scatterplot_layer/#multiple-scatterplot-layers-with-layer-control","title":"Multiple Scatterplot Layers with Layer Control\u00b6","text":""},{"location":"notebooks/scatterplot_layer/#using-the-generic-add_deckgl_layer-method","title":"Using the Generic add_deckgl_layer Method\u00b6","text":""},{"location":"notebooks/scatterplot_layer/#export-to-html","title":"Export to HTML\u00b6","text":""},{"location":"notebooks/scenegraph_layer/","title":"Scenegraph layer","text":"In\u00a0[\u00a0]: Copied! <pre>from anymap_ts import DeckGLMap\n</pre> from anymap_ts import DeckGLMap In\u00a0[\u00a0]: Copied! <pre># Sample positions for glTF models\nmodel_positions = [\n    {\"coordinates\": [-122.4, 37.8, 0], \"orientation\": [0, 0, 90]},\n    {\"coordinates\": [-122.38, 37.79, 0], \"orientation\": [0, 0, 180]},\n    {\"coordinates\": [-122.42, 37.78, 0], \"orientation\": [0, 0, 270]},\n    {\"coordinates\": [-122.39, 37.81, 0], \"orientation\": [0, 0, 0]},\n    {\"coordinates\": [-122.41, 37.77, 0], \"orientation\": [0, 0, 45]},\n]\n</pre> # Sample positions for glTF models model_positions = [     {\"coordinates\": [-122.4, 37.8, 0], \"orientation\": [0, 0, 90]},     {\"coordinates\": [-122.38, 37.79, 0], \"orientation\": [0, 0, 180]},     {\"coordinates\": [-122.42, 37.78, 0], \"orientation\": [0, 0, 270]},     {\"coordinates\": [-122.39, 37.81, 0], \"orientation\": [0, 0, 0]},     {\"coordinates\": [-122.41, 37.77, 0], \"orientation\": [0, 0, 45]}, ] In\u00a0[\u00a0]: Copied! <pre>m = DeckGLMap(center=[-122.4, 37.79], zoom=13, pitch=60, bearing=-17)\nm.add_basemap(\"CartoDB.DarkMatter\")\n\nm.add_scenegraph_layer(\n    data=model_positions,\n    # Khronos glTF sample model\n    scenegraph=\"https://raw.githubusercontent.com/KhronosGroup/glTF-Sample-Models/master/2.0/Duck/glTF-Binary/Duck.glb\",\n    get_position=\"coordinates\",\n    get_orientation=\"orientation\",\n    size_scale=500,\n    pickable=True,\n)\nm\n</pre> m = DeckGLMap(center=[-122.4, 37.79], zoom=13, pitch=60, bearing=-17) m.add_basemap(\"CartoDB.DarkMatter\")  m.add_scenegraph_layer(     data=model_positions,     # Khronos glTF sample model     scenegraph=\"https://raw.githubusercontent.com/KhronosGroup/glTF-Sample-Models/master/2.0/Duck/glTF-Binary/Duck.glb\",     get_position=\"coordinates\",     get_orientation=\"orientation\",     size_scale=500,     pickable=True, ) m In\u00a0[\u00a0]: Copied! <pre>m.to_html(\"scenegraph_layer_example.html\")\n</pre> m.to_html(\"scenegraph_layer_example.html\")"},{"location":"notebooks/scenegraph_layer/#scenegraph-layer-example","title":"Scenegraph Layer Example\u00b6","text":"<p>glTF 3D model rendering using deck.gl ScenegraphLayer.</p>"},{"location":"notebooks/scenegraph_layer/#define-model-positions","title":"Define model positions\u00b6","text":""},{"location":"notebooks/scenegraph_layer/#create-map-with-scenegraph-layer","title":"Create map with scenegraph layer\u00b6","text":""},{"location":"notebooks/scenegraph_layer/#export-to-html","title":"Export to HTML\u00b6","text":""},{"location":"notebooks/simplemesh_layer/","title":"Simplemesh layer","text":"In\u00a0[\u00a0]: Copied! <pre>from anymap_ts import DeckGLMap\n</pre> from anymap_ts import DeckGLMap In\u00a0[\u00a0]: Copied! <pre># Sample mesh data positions (locations for mesh instances)\nmesh_data = [\n    {\"position\": [-122.4, 37.8], \"color\": [255, 140, 0, 255]},\n    {\"position\": [-122.38, 37.79], \"color\": [0, 200, 255, 255]},\n    {\"position\": [-122.42, 37.78], \"color\": [255, 100, 100, 255]},\n    {\"position\": [-122.39, 37.81], \"color\": [100, 255, 100, 255]},\n    {\"position\": [-122.41, 37.77], \"color\": [200, 100, 255, 255]},\n]\n</pre> # Sample mesh data positions (locations for mesh instances) mesh_data = [     {\"position\": [-122.4, 37.8], \"color\": [255, 140, 0, 255]},     {\"position\": [-122.38, 37.79], \"color\": [0, 200, 255, 255]},     {\"position\": [-122.42, 37.78], \"color\": [255, 100, 100, 255]},     {\"position\": [-122.39, 37.81], \"color\": [100, 255, 100, 255]},     {\"position\": [-122.41, 37.77], \"color\": [200, 100, 255, 255]}, ] In\u00a0[\u00a0]: Copied! <pre># GLB model URL - using Khronos glTF sample models\nMODEL_URL = \"https://raw.githubusercontent.com/KhronosGroup/glTF-Sample-Models/master/2.0/Duck/glTF-Binary/Duck.glb\"\n\nm = DeckGLMap(center=[-122.4, 37.79], zoom=13, pitch=60, bearing=-17)\nm.add_basemap(\"CartoDB.DarkMatter\")\n\n# Use ScenegraphLayer for GLB/glTF models\nm.add_scenegraph_layer(\n    data=mesh_data,\n    scenegraph=MODEL_URL,\n    get_position=\"position\",\n    get_color=\"color\",\n    size_scale=500,\n    pickable=True,\n)\nm\n</pre> # GLB model URL - using Khronos glTF sample models MODEL_URL = \"https://raw.githubusercontent.com/KhronosGroup/glTF-Sample-Models/master/2.0/Duck/glTF-Binary/Duck.glb\"  m = DeckGLMap(center=[-122.4, 37.79], zoom=13, pitch=60, bearing=-17) m.add_basemap(\"CartoDB.DarkMatter\")  # Use ScenegraphLayer for GLB/glTF models m.add_scenegraph_layer(     data=mesh_data,     scenegraph=MODEL_URL,     get_position=\"position\",     get_color=\"color\",     size_scale=500,     pickable=True, ) m In\u00a0[\u00a0]: Copied! <pre>m.to_html(\"mesh_layer_example.html\")\n</pre> m.to_html(\"mesh_layer_example.html\")"},{"location":"notebooks/simplemesh_layer/#mesh-layers-example","title":"Mesh Layers Example\u00b6","text":"<p>deck.gl provides two main options for 3D mesh rendering:</p> <ol> <li>SimpleMeshLayer - For simple geometry primitives (spheres, cubes, etc.) created programmatically</li> <li>ScenegraphLayer - For loading and rendering glTF/GLB 3D models (recommended for external model files)</li> </ol> <p>This notebook demonstrates ScenegraphLayer which is the recommended approach for rendering 3D models from GLB/glTF files.</p>"},{"location":"notebooks/simplemesh_layer/#define-mesh-data-positions","title":"Define mesh data positions\u00b6","text":""},{"location":"notebooks/simplemesh_layer/#create-map-with-scenegraphlayer","title":"Create map with ScenegraphLayer\u00b6","text":"<p>Using a GLB model from deck.gl examples. ScenegraphLayer is the recommended way to render glTF/GLB models.</p>"},{"location":"notebooks/simplemesh_layer/#export-to-html","title":"Export to HTML\u00b6","text":"<p>If the widget doesn't render in the notebook, export to HTML and open in a browser.</p>"},{"location":"notebooks/solidpolygon_layer/","title":"Solidpolygon layer","text":"In\u00a0[\u00a0]: Copied! <pre>from anymap_ts import DeckGLMap\n</pre> from anymap_ts import DeckGLMap In\u00a0[\u00a0]: Copied! <pre>polygons = [\n    {\n        \"polygon\": [\n            [-122.402, 37.795],\n            [-122.400, 37.795],\n            [-122.400, 37.793],\n            [-122.402, 37.793],\n        ],\n        \"elevation\": 200,\n        \"color\": [255, 140, 0, 200],\n    },\n    {\n        \"polygon\": [\n            [-122.398, 37.796],\n            [-122.395, 37.796],\n            [-122.395, 37.793],\n            [-122.398, 37.793],\n        ],\n        \"elevation\": 350,\n        \"color\": [0, 200, 255, 200],\n    },\n    {\n        \"polygon\": [\n            [-122.405, 37.790],\n            [-122.401, 37.790],\n            [-122.401, 37.787],\n            [-122.405, 37.787],\n        ],\n        \"elevation\": 150,\n        \"color\": [255, 100, 100, 200],\n    },\n]\n</pre> polygons = [     {         \"polygon\": [             [-122.402, 37.795],             [-122.400, 37.795],             [-122.400, 37.793],             [-122.402, 37.793],         ],         \"elevation\": 200,         \"color\": [255, 140, 0, 200],     },     {         \"polygon\": [             [-122.398, 37.796],             [-122.395, 37.796],             [-122.395, 37.793],             [-122.398, 37.793],         ],         \"elevation\": 350,         \"color\": [0, 200, 255, 200],     },     {         \"polygon\": [             [-122.405, 37.790],             [-122.401, 37.790],             [-122.401, 37.787],             [-122.405, 37.787],         ],         \"elevation\": 150,         \"color\": [255, 100, 100, 200],     }, ] In\u00a0[\u00a0]: Copied! <pre>m = DeckGLMap(center=[-122.4, 37.79], zoom=14, pitch=45, bearing=-17)\nm.add_basemap(\"CartoDB.DarkMatter\")\n\nm.add_solid_polygon_layer(\n    data=polygons,\n    get_polygon=\"polygon\",\n    get_elevation=\"elevation\",\n    get_fill_color=\"color\",\n    extruded=True,\n    elevation_scale=10,\n    pickable=True,\n)\nm\n</pre> m = DeckGLMap(center=[-122.4, 37.79], zoom=14, pitch=45, bearing=-17) m.add_basemap(\"CartoDB.DarkMatter\")  m.add_solid_polygon_layer(     data=polygons,     get_polygon=\"polygon\",     get_elevation=\"elevation\",     get_fill_color=\"color\",     extruded=True,     elevation_scale=10,     pickable=True, ) m In\u00a0[\u00a0]: Copied! <pre>m.to_html(\"solidpolygon_layer_example.html\")\n</pre> m.to_html(\"solidpolygon_layer_example.html\")"},{"location":"notebooks/solidpolygon_layer/#solid-polygon-layer-example","title":"Solid Polygon Layer Example\u00b6","text":"<p>Filled polygon visualization using deck.gl SolidPolygonLayer.</p>"},{"location":"notebooks/solidpolygon_layer/#define-polygon-data-building-footprints","title":"Define polygon data (building footprints)\u00b6","text":""},{"location":"notebooks/solidpolygon_layer/#create-map-with-solid-polygon-layer","title":"Create map with solid polygon layer\u00b6","text":""},{"location":"notebooks/solidpolygon_layer/#export-to-html","title":"Export to HTML\u00b6","text":""},{"location":"notebooks/terrain_layer/","title":"Terrain layer","text":"In\u00a0[\u00a0]: Copied! <pre>from anymap_ts import DeckGLMap\n</pre> from anymap_ts import DeckGLMap In\u00a0[\u00a0]: Copied! <pre># Terrain-RGB elevation data URL template\nTERRAIN_URL = \"https://s3.amazonaws.com/elevation-tiles-prod/terrarium/{z}/{x}/{y}.png\"\n\n# Satellite imagery for texture\nTEXTURE_URL = \"https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}\"\n\nm = DeckGLMap(center=[-119.5, 37.7], zoom=10, pitch=60, bearing=30)  # Yosemite area\nm.add_basemap(\"CartoDB.DarkMatter\")\n\nm.add_terrain_layer(\n    elevation_data=TERRAIN_URL,\n    texture=TEXTURE_URL,\n    elevation_decoder={\n        \"rScaler\": 256,\n        \"gScaler\": 1,\n        \"bScaler\": 1 / 256,\n        \"offset\": -32768,\n    },\n    mesh_max_error=4,\n    opacity=1.0,\n)\nm\n</pre> # Terrain-RGB elevation data URL template TERRAIN_URL = \"https://s3.amazonaws.com/elevation-tiles-prod/terrarium/{z}/{x}/{y}.png\"  # Satellite imagery for texture TEXTURE_URL = \"https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}\"  m = DeckGLMap(center=[-119.5, 37.7], zoom=10, pitch=60, bearing=30)  # Yosemite area m.add_basemap(\"CartoDB.DarkMatter\")  m.add_terrain_layer(     elevation_data=TERRAIN_URL,     texture=TEXTURE_URL,     elevation_decoder={         \"rScaler\": 256,         \"gScaler\": 1,         \"bScaler\": 1 / 256,         \"offset\": -32768,     },     mesh_max_error=4,     opacity=1.0, ) m In\u00a0[\u00a0]: Copied! <pre>m.to_html(\"terrain_layer_example.html\")\n</pre> m.to_html(\"terrain_layer_example.html\")"},{"location":"notebooks/terrain_layer/#terrain-layer-example","title":"Terrain Layer Example\u00b6","text":"<p>3D terrain visualization using deck.gl TerrainLayer with elevation tiles.</p>"},{"location":"notebooks/terrain_layer/#create-a-3d-terrain-map","title":"Create a 3D terrain map\u00b6","text":""},{"location":"notebooks/terrain_layer/#export-to-html","title":"Export to HTML\u00b6","text":""},{"location":"notebooks/text_layer/","title":"Text layer","text":"In\u00a0[\u00a0]: Copied! <pre>from anymap_ts import DeckGLMap\n\n# Bay Area city labels\ncities = [\n    {\"coordinates\": [-122.4194, 37.7749], \"text\": \"San Francisco\", \"size\": 24},\n    {\"coordinates\": [-122.2711, 37.8044], \"text\": \"Oakland\", \"size\": 20},\n    {\"coordinates\": [-122.2727, 37.8716], \"text\": \"Berkeley\", \"size\": 18},\n    {\"coordinates\": [-122.0322, 37.3688], \"text\": \"San Jose\", \"size\": 20},\n    {\"coordinates\": [-122.1430, 37.4419], \"text\": \"Palo Alto\", \"size\": 16},\n    {\"coordinates\": [-122.0096, 37.5485], \"text\": \"Fremont\", \"size\": 16},\n]\n\nm = DeckGLMap(center=[-122.3, 37.6], zoom=9)\nm.add_basemap(\"CartoDB.DarkMatter\")\nm.add_text_layer(\n    data=cities,\n    name=\"text-basic\",\n    get_position=\"coordinates\",\n    get_text=\"text\",\n    get_size=\"size\",\n    get_color=[255, 255, 255, 255],\n)\nm\n</pre> from anymap_ts import DeckGLMap  # Bay Area city labels cities = [     {\"coordinates\": [-122.4194, 37.7749], \"text\": \"San Francisco\", \"size\": 24},     {\"coordinates\": [-122.2711, 37.8044], \"text\": \"Oakland\", \"size\": 20},     {\"coordinates\": [-122.2727, 37.8716], \"text\": \"Berkeley\", \"size\": 18},     {\"coordinates\": [-122.0322, 37.3688], \"text\": \"San Jose\", \"size\": 20},     {\"coordinates\": [-122.1430, 37.4419], \"text\": \"Palo Alto\", \"size\": 16},     {\"coordinates\": [-122.0096, 37.5485], \"text\": \"Fremont\", \"size\": 16}, ]  m = DeckGLMap(center=[-122.3, 37.6], zoom=9) m.add_basemap(\"CartoDB.DarkMatter\") m.add_text_layer(     data=cities,     name=\"text-basic\",     get_position=\"coordinates\",     get_text=\"text\",     get_size=\"size\",     get_color=[255, 255, 255, 255], ) m In\u00a0[\u00a0]: Copied! <pre># Landmarks with colors\nlandmarks = [\n    {\n        \"coordinates\": [-122.4862, 37.8199],\n        \"text\": \"Golden Gate Bridge\",\n        \"size\": 16,\n        \"color\": [255, 200, 100],\n    },\n    {\n        \"coordinates\": [-122.4534, 37.8083],\n        \"text\": \"Alcatraz\",\n        \"size\": 14,\n        \"color\": [255, 150, 150],\n    },\n    {\n        \"coordinates\": [-122.3894, 37.6213],\n        \"text\": \"SFO Airport\",\n        \"size\": 14,\n        \"color\": [100, 200, 255],\n    },\n    {\n        \"coordinates\": [-122.4783, 37.8199],\n        \"text\": \"Sausalito\",\n        \"size\": 14,\n        \"color\": [200, 255, 200],\n    },\n    {\n        \"coordinates\": [-122.3894, 37.7866],\n        \"text\": \"Ferry Building\",\n        \"size\": 14,\n        \"color\": [255, 180, 100],\n    },\n]\n\nm2 = DeckGLMap(center=[-122.42, 37.79], zoom=11)\nm2.add_basemap(\"CartoDB.DarkMatter\")\nm2.add_text_layer(\n    data=landmarks,\n    name=\"text-styled\",\n    get_position=\"coordinates\",\n    get_text=\"text\",\n    get_size=\"size\",\n    get_color=\"color\",\n    font_family=\"Arial\",\n    font_weight=\"bold\",\n    outline_width=2,\n    outline_color=[0, 0, 0, 200],\n    size_min_pixels=10,\n    size_max_pixels=32,\n)\nm2\n</pre> # Landmarks with colors landmarks = [     {         \"coordinates\": [-122.4862, 37.8199],         \"text\": \"Golden Gate Bridge\",         \"size\": 16,         \"color\": [255, 200, 100],     },     {         \"coordinates\": [-122.4534, 37.8083],         \"text\": \"Alcatraz\",         \"size\": 14,         \"color\": [255, 150, 150],     },     {         \"coordinates\": [-122.3894, 37.6213],         \"text\": \"SFO Airport\",         \"size\": 14,         \"color\": [100, 200, 255],     },     {         \"coordinates\": [-122.4783, 37.8199],         \"text\": \"Sausalito\",         \"size\": 14,         \"color\": [200, 255, 200],     },     {         \"coordinates\": [-122.3894, 37.7866],         \"text\": \"Ferry Building\",         \"size\": 14,         \"color\": [255, 180, 100],     }, ]  m2 = DeckGLMap(center=[-122.42, 37.79], zoom=11) m2.add_basemap(\"CartoDB.DarkMatter\") m2.add_text_layer(     data=landmarks,     name=\"text-styled\",     get_position=\"coordinates\",     get_text=\"text\",     get_size=\"size\",     get_color=\"color\",     font_family=\"Arial\",     font_weight=\"bold\",     outline_width=2,     outline_color=[0, 0, 0, 200],     size_min_pixels=10,     size_max_pixels=32, ) m2 In\u00a0[\u00a0]: Copied! <pre>m3 = DeckGLMap(center=[-122.35, 37.7], zoom=10)\nm3.add_basemap(\"CartoDB.DarkMatter\")\n\nm3.add_text_layer(\n    data=cities,\n    name=\"text-cities\",\n    get_position=\"coordinates\",\n    get_text=\"text\",\n    get_size=\"size\",\n    get_color=[255, 255, 255, 255],\n)\n\nm3.add_text_layer(\n    data=landmarks,\n    name=\"text-landmarks\",\n    get_position=\"coordinates\",\n    get_text=\"text\",\n    get_size=\"size\",\n    get_color=\"color\",\n    outline_width=2,\n    outline_color=[0, 0, 0, 200],\n)\n\nm3.add_layer_control()\nm3\n</pre> m3 = DeckGLMap(center=[-122.35, 37.7], zoom=10) m3.add_basemap(\"CartoDB.DarkMatter\")  m3.add_text_layer(     data=cities,     name=\"text-cities\",     get_position=\"coordinates\",     get_text=\"text\",     get_size=\"size\",     get_color=[255, 255, 255, 255], )  m3.add_text_layer(     data=landmarks,     name=\"text-landmarks\",     get_position=\"coordinates\",     get_text=\"text\",     get_size=\"size\",     get_color=\"color\",     outline_width=2,     outline_color=[0, 0, 0, 200], )  m3.add_layer_control() m3 In\u00a0[\u00a0]: Copied! <pre>m4 = DeckGLMap(center=[-122.3, 37.6], zoom=9)\nm4.add_basemap(\"CartoDB.DarkMatter\")\n\nm4.add_deckgl_layer(\n    layer_type=\"TextLayer\",\n    data=cities,\n    name=\"text-generic\",\n    getPosition=\"coordinates\",\n    getText=\"text\",\n    getSize=\"size\",\n    getColor=[255, 200, 100, 255],\n    fontFamily=\"Arial\",\n    fontWeight=\"bold\",\n    outlineWidth=2,\n    outlineColor=[0, 0, 0, 200],\n    billboard=True,\n)\nm4\n</pre> m4 = DeckGLMap(center=[-122.3, 37.6], zoom=9) m4.add_basemap(\"CartoDB.DarkMatter\")  m4.add_deckgl_layer(     layer_type=\"TextLayer\",     data=cities,     name=\"text-generic\",     getPosition=\"coordinates\",     getText=\"text\",     getSize=\"size\",     getColor=[255, 200, 100, 255],     fontFamily=\"Arial\",     fontWeight=\"bold\",     outlineWidth=2,     outlineColor=[0, 0, 0, 200],     billboard=True, ) m4 In\u00a0[\u00a0]: Copied! <pre>m.to_html(\"text_layer_example.html\")\n</pre> m.to_html(\"text_layer_example.html\")"},{"location":"notebooks/text_layer/#text-layer-example","title":"Text Layer Example\u00b6","text":"<p>This notebook demonstrates the DeckGL TextLayer for rendering dynamic text labels on maps.</p>"},{"location":"notebooks/text_layer/#basic-text-layer","title":"Basic Text Layer\u00b6","text":""},{"location":"notebooks/text_layer/#text-layer-with-outline-and-styling","title":"Text Layer with Outline and Styling\u00b6","text":""},{"location":"notebooks/text_layer/#multiple-text-layers-with-layer-control","title":"Multiple Text Layers with Layer Control\u00b6","text":""},{"location":"notebooks/text_layer/#using-the-generic-add_deckgl_layer-method","title":"Using the Generic add_deckgl_layer Method\u00b6","text":""},{"location":"notebooks/text_layer/#export-to-html","title":"Export to HTML\u00b6","text":""},{"location":"notebooks/tile3d_layer/","title":"Tile3d layer","text":"In\u00a0[\u00a0]: Copied! <pre>from anymap_ts import DeckGLMap\n</pre> from anymap_ts import DeckGLMap In\u00a0[\u00a0]: Copied! <pre># Public 3D Tiles dataset from loaders.gl test data\nTILESET_URL = \"https://raw.githubusercontent.com/visgl/loaders.gl/master/modules/3d-tiles/test/data/CesiumJS/Batched/BatchedColors/tileset.json\"\n\nm = DeckGLMap(center=[0, 0], zoom=16, pitch=60, bearing=-17)\nm.add_basemap(\"CartoDB.DarkMatter\")\n\n# Add a 3D Tiles dataset\nm.add_tile3d_layer(\n    data=TILESET_URL,\n    opacity=1.0,\n    point_size=2,\n)\nm\n</pre> # Public 3D Tiles dataset from loaders.gl test data TILESET_URL = \"https://raw.githubusercontent.com/visgl/loaders.gl/master/modules/3d-tiles/test/data/CesiumJS/Batched/BatchedColors/tileset.json\"  m = DeckGLMap(center=[0, 0], zoom=16, pitch=60, bearing=-17) m.add_basemap(\"CartoDB.DarkMatter\")  # Add a 3D Tiles dataset m.add_tile3d_layer(     data=TILESET_URL,     opacity=1.0,     point_size=2, ) m In\u00a0[\u00a0]: Copied! <pre>m.to_html(\"tile3d_layer_example.html\")\n</pre> m.to_html(\"tile3d_layer_example.html\")"},{"location":"notebooks/tile3d_layer/#3d-tiles-layer-example","title":"3D Tiles Layer Example\u00b6","text":"<p>OGC 3D Tiles visualization using deck.gl Tile3DLayer.</p>"},{"location":"notebooks/tile3d_layer/#create-a-map-with-3d-tiles","title":"Create a map with 3D Tiles\u00b6","text":""},{"location":"notebooks/tile3d_layer/#export-to-html","title":"Export to HTML\u00b6","text":""},{"location":"notebooks/tile_layer/","title":"Tile layer","text":"In\u00a0[\u00a0]: Copied! <pre>from anymap_ts import DeckGLMap\n</pre> from anymap_ts import DeckGLMap In\u00a0[\u00a0]: Copied! <pre>m = DeckGLMap(center=[-122.4, 37.8], zoom=10)\nm.add_basemap(\"CartoDB.DarkMatter\")\n\n# Add OpenStreetMap tiles as a tile layer\nm.add_tile_layer(\n    data=\"https://tile.openstreetmap.org/{z}/{x}/{y}.png\",\n    min_zoom=0,\n    max_zoom=19,\n    tile_size=256,\n    opacity=0.7,\n)\nm\n</pre> m = DeckGLMap(center=[-122.4, 37.8], zoom=10) m.add_basemap(\"CartoDB.DarkMatter\")  # Add OpenStreetMap tiles as a tile layer m.add_tile_layer(     data=\"https://tile.openstreetmap.org/{z}/{x}/{y}.png\",     min_zoom=0,     max_zoom=19,     tile_size=256,     opacity=0.7, ) m In\u00a0[\u00a0]: Copied! <pre>m.to_html(\"tile_layer_example.html\")\n</pre> m.to_html(\"tile_layer_example.html\")"},{"location":"notebooks/tile_layer/#tile-layer-example","title":"Tile Layer Example\u00b6","text":"<p>Custom tile layer rendering using deck.gl TileLayer.</p>"},{"location":"notebooks/tile_layer/#create-a-map-with-a-tile-layer","title":"Create a map with a tile layer\u00b6","text":""},{"location":"notebooks/tile_layer/#export-to-html","title":"Export to HTML\u00b6","text":""},{"location":"notebooks/trips_layer/","title":"Trips layer","text":"In\u00a0[\u00a0]: Copied! <pre>from anymap_ts import DeckGLMap\n\n# Sample trip data with waypoints and timestamps\ntrips = [\n    {\n        \"waypoints\": [\n            [-122.45, 37.78],\n            [-122.42, 37.79],\n            [-122.40, 37.78],\n            [-122.38, 37.80],\n            [-122.35, 37.79],\n        ],\n        \"timestamps\": [0, 30, 60, 90, 120],\n        \"name\": \"Trip 1\",\n    },\n    {\n        \"waypoints\": [\n            [-122.50, 37.75],\n            [-122.47, 37.77],\n            [-122.44, 37.76],\n            [-122.41, 37.78],\n            [-122.38, 37.77],\n        ],\n        \"timestamps\": [10, 40, 70, 100, 130],\n        \"name\": \"Trip 2\",\n    },\n    {\n        \"waypoints\": [\n            [-122.43, 37.82],\n            [-122.41, 37.80],\n            [-122.39, 37.78],\n            [-122.37, 37.76],\n            [-122.35, 37.74],\n        ],\n        \"timestamps\": [20, 50, 80, 110, 140],\n        \"name\": \"Trip 3\",\n    },\n]\n\nm = DeckGLMap(center=[-122.42, 37.78], zoom=12)\nm.add_basemap(\"CartoDB.DarkMatter\")\nm.add_trips_layer(\n    data=trips,\n    name=\"trips-basic\",\n    get_path=\"waypoints\",\n    get_timestamps=\"timestamps\",\n    get_color=[253, 128, 93],\n    width_min_pixels=3,\n    trail_length=180,\n    current_time=60,  # Show trails up to time=60\n)\nm\n</pre> from anymap_ts import DeckGLMap  # Sample trip data with waypoints and timestamps trips = [     {         \"waypoints\": [             [-122.45, 37.78],             [-122.42, 37.79],             [-122.40, 37.78],             [-122.38, 37.80],             [-122.35, 37.79],         ],         \"timestamps\": [0, 30, 60, 90, 120],         \"name\": \"Trip 1\",     },     {         \"waypoints\": [             [-122.50, 37.75],             [-122.47, 37.77],             [-122.44, 37.76],             [-122.41, 37.78],             [-122.38, 37.77],         ],         \"timestamps\": [10, 40, 70, 100, 130],         \"name\": \"Trip 2\",     },     {         \"waypoints\": [             [-122.43, 37.82],             [-122.41, 37.80],             [-122.39, 37.78],             [-122.37, 37.76],             [-122.35, 37.74],         ],         \"timestamps\": [20, 50, 80, 110, 140],         \"name\": \"Trip 3\",     }, ]  m = DeckGLMap(center=[-122.42, 37.78], zoom=12) m.add_basemap(\"CartoDB.DarkMatter\") m.add_trips_layer(     data=trips,     name=\"trips-basic\",     get_path=\"waypoints\",     get_timestamps=\"timestamps\",     get_color=[253, 128, 93],     width_min_pixels=3,     trail_length=180,     current_time=60,  # Show trails up to time=60 ) m In\u00a0[\u00a0]: Copied! <pre># Trips with individual colors\ncolored_trips = [\n    {\n        \"waypoints\": trips[0][\"waypoints\"],\n        \"timestamps\": trips[0][\"timestamps\"],\n        \"color\": [255, 100, 100],  # Red\n    },\n    {\n        \"waypoints\": trips[1][\"waypoints\"],\n        \"timestamps\": trips[1][\"timestamps\"],\n        \"color\": [100, 255, 100],  # Green\n    },\n    {\n        \"waypoints\": trips[2][\"waypoints\"],\n        \"timestamps\": trips[2][\"timestamps\"],\n        \"color\": [100, 100, 255],  # Blue\n    },\n]\n\nm2 = DeckGLMap(center=[-122.42, 37.78], zoom=12)\nm2.add_basemap(\"CartoDB.DarkMatter\")\nm2.add_trips_layer(\n    data=colored_trips,\n    name=\"trips-colored\",\n    get_path=\"waypoints\",\n    get_timestamps=\"timestamps\",\n    get_color=\"color\",  # Use color property from data\n    width_min_pixels=4,\n    trail_length=200,\n    current_time=80,\n)\nm2\n</pre> # Trips with individual colors colored_trips = [     {         \"waypoints\": trips[0][\"waypoints\"],         \"timestamps\": trips[0][\"timestamps\"],         \"color\": [255, 100, 100],  # Red     },     {         \"waypoints\": trips[1][\"waypoints\"],         \"timestamps\": trips[1][\"timestamps\"],         \"color\": [100, 255, 100],  # Green     },     {         \"waypoints\": trips[2][\"waypoints\"],         \"timestamps\": trips[2][\"timestamps\"],         \"color\": [100, 100, 255],  # Blue     }, ]  m2 = DeckGLMap(center=[-122.42, 37.78], zoom=12) m2.add_basemap(\"CartoDB.DarkMatter\") m2.add_trips_layer(     data=colored_trips,     name=\"trips-colored\",     get_path=\"waypoints\",     get_timestamps=\"timestamps\",     get_color=\"color\",  # Use color property from data     width_min_pixels=4,     trail_length=200,     current_time=80, ) m2 In\u00a0[\u00a0]: Copied! <pre>m3 = DeckGLMap(center=[-122.42, 37.78], zoom=12)\nm3.add_basemap(\"CartoDB.DarkMatter\")\n\n# Add trips layer using the generic method\nm3.add_deckgl_layer(\n    layer_type=\"TripsLayer\",\n    data=trips,\n    name=\"trips-generic\",\n    getPath=\"waypoints\",\n    getTimestamps=\"timestamps\",\n    getColor=[255, 200, 0],  # Orange\n    widthMinPixels=3,\n    trailLength=150,\n    currentTime=100,\n)\nm3\n</pre> m3 = DeckGLMap(center=[-122.42, 37.78], zoom=12) m3.add_basemap(\"CartoDB.DarkMatter\")  # Add trips layer using the generic method m3.add_deckgl_layer(     layer_type=\"TripsLayer\",     data=trips,     name=\"trips-generic\",     getPath=\"waypoints\",     getTimestamps=\"timestamps\",     getColor=[255, 200, 0],  # Orange     widthMinPixels=3,     trailLength=150,     currentTime=100, ) m3 In\u00a0[\u00a0]: Copied! <pre>m4 = DeckGLMap(center=[-122.42, 37.78], zoom=12)\nm4.add_basemap(\"CartoDB.DarkMatter\")\n\nm4.add_trips_layer(\n    data=trips,\n    name=\"trips-animated\",\n    trail_length=180,\n    current_time=90,\n)\n\nm4.add_layer_control()\nm4\n</pre> m4 = DeckGLMap(center=[-122.42, 37.78], zoom=12) m4.add_basemap(\"CartoDB.DarkMatter\")  m4.add_trips_layer(     data=trips,     name=\"trips-animated\",     trail_length=180,     current_time=90, )  m4.add_layer_control() m4 In\u00a0[\u00a0]: Copied! <pre>m.to_html(\"trips_layer_example.html\")\n</pre> m.to_html(\"trips_layer_example.html\")"},{"location":"notebooks/trips_layer/#trips-layer-example","title":"Trips Layer Example\u00b6","text":"<p>This notebook demonstrates the DeckGL TripsLayer for animated path visualization.</p> <p>Trips layers are ideal for:</p> <ul> <li>Visualizing vehicle routes over time</li> <li>Animation of movement patterns</li> <li>GPS trajectory visualization</li> <li>Time-based path analysis</li> </ul>"},{"location":"notebooks/trips_layer/#basic-trips-layer","title":"Basic Trips Layer\u00b6","text":""},{"location":"notebooks/trips_layer/#trips-layer-with-different-colors","title":"Trips Layer with Different Colors\u00b6","text":""},{"location":"notebooks/trips_layer/#using-the-generic-add_deckgl_layer-method","title":"Using the Generic add_deckgl_layer Method\u00b6","text":""},{"location":"notebooks/trips_layer/#trips-layer-with-layer-control","title":"Trips Layer with Layer Control\u00b6","text":""},{"location":"notebooks/trips_layer/#export-to-html","title":"Export to HTML\u00b6","text":""},{"location":"notebooks/ui_controls/","title":"Ui controls","text":"In\u00a0[\u00a0]: Copied! <pre>from anymap_ts import MapLibreMap\n</pre> from anymap_ts import MapLibreMap In\u00a0[\u00a0]: Copied! <pre>m = MapLibreMap(center=[11.25, 43.77], zoom=12)\nm.add_pmtiles_control(\n    position=\"top-right\",\n    collapsed=False,\n    default_url=\"https://pmtiles.io/protomaps(vector)ODbL_firenze.pmtiles\",\n    load_default_url=True,\n)\nm\n</pre> m = MapLibreMap(center=[11.25, 43.77], zoom=12) m.add_pmtiles_control(     position=\"top-right\",     collapsed=False,     default_url=\"https://pmtiles.io/protomaps(vector)ODbL_firenze.pmtiles\",     load_default_url=True, ) m In\u00a0[\u00a0]: Copied! <pre>m = MapLibreMap(center=[-120, 37], zoom=6)\nm.add_cog_control(position=\"top-right\", collapsed=False, default_colormap=\"viridis\")\nm\n</pre> m = MapLibreMap(center=[-120, 37], zoom=6) m.add_cog_control(position=\"top-right\", collapsed=False, default_colormap=\"viridis\") m In\u00a0[\u00a0]: Copied! <pre>m = MapLibreMap(center=[0, 20], zoom=2)\nm.add_zarr_control(position=\"top-right\", collapsed=False)\nm\n</pre> m = MapLibreMap(center=[0, 20], zoom=2) m.add_zarr_control(position=\"top-right\", collapsed=False) m In\u00a0[\u00a0]: Copied! <pre>m = MapLibreMap(center=[0, 20], zoom=2)\nm.add_vector_control(\n    position=\"top-right\",\n    collapsed=False,\n    default_url=\"https://raw.githubusercontent.com/datasets/geo-countries/master/data/countries.geojson\",\n    default_fill_color=\"#3388ff\",\n    default_stroke_color=\"#2266cc\",\n)\nm\n</pre> m = MapLibreMap(center=[0, 20], zoom=2) m.add_vector_control(     position=\"top-right\",     collapsed=False,     default_url=\"https://raw.githubusercontent.com/datasets/geo-countries/master/data/countries.geojson\",     default_fill_color=\"#3388ff\",     default_stroke_color=\"#2266cc\", ) m In\u00a0[\u00a0]: Copied! <pre>m = MapLibreMap(center=[0, 20], zoom=2)\nm.add_pmtiles_control(position=\"top-right\", collapsed=True)\nm.add_cog_control(position=\"top-right\", collapsed=True)\nm.add_zarr_control(position=\"top-right\", collapsed=True)\nm.add_vector_control(position=\"top-right\", collapsed=True)\nm\n</pre> m = MapLibreMap(center=[0, 20], zoom=2) m.add_pmtiles_control(position=\"top-right\", collapsed=True) m.add_cog_control(position=\"top-right\", collapsed=True) m.add_zarr_control(position=\"top-right\", collapsed=True) m.add_vector_control(position=\"top-right\", collapsed=True) m"},{"location":"notebooks/ui_controls/#ui-controls-for-maplibre","title":"UI Controls for MapLibre\u00b6","text":"<p>This notebook demonstrates the UI controls for loading various data formats:</p> <ul> <li>PMTiles</li> <li>COG (Cloud Optimized GeoTIFF)</li> <li>Zarr</li> <li>Vector (GeoJSON, GeoParquet, FlatGeobuf)</li> </ul>"},{"location":"notebooks/ui_controls/#pmtiles-control","title":"PMTiles Control\u00b6","text":"<p>Load PMTiles vector or raster tiles via an interactive UI panel.</p>"},{"location":"notebooks/ui_controls/#cog-control","title":"COG Control\u00b6","text":"<p>Load Cloud Optimized GeoTIFF files via an interactive UI panel with colormap selection.</p>"},{"location":"notebooks/ui_controls/#zarr-control","title":"Zarr Control\u00b6","text":"<p>Load Zarr pyramid datasets via an interactive UI panel.</p>"},{"location":"notebooks/ui_controls/#vector-control","title":"Vector Control\u00b6","text":"<p>Load vector datasets (GeoJSON, GeoParquet, FlatGeobuf) via URL.</p>"},{"location":"notebooks/ui_controls/#all-controls-together","title":"All Controls Together\u00b6","text":"<p>You can add multiple controls to the same map.</p>"},{"location":"notebooks/wms_layer/","title":"Wms layer","text":"In\u00a0[\u00a0]: Copied! <pre>from anymap_ts import DeckGLMap\n</pre> from anymap_ts import DeckGLMap In\u00a0[\u00a0]: Copied! <pre>m = DeckGLMap(center=[-95, 40], zoom=4)\nm.add_basemap(\"CartoDB.DarkMatter\")\n\n# Add NOAA Weather Radar WMS\nm.add_wms_layer(\n    data=\"https://mesonet.agron.iastate.edu/cgi-bin/wms/nexrad/n0r.cgi\",\n    service_type=\"wms\",\n    layers=[\"nexrad-n0r\"],\n    opacity=0.8,\n)\nm\n</pre> m = DeckGLMap(center=[-95, 40], zoom=4) m.add_basemap(\"CartoDB.DarkMatter\")  # Add NOAA Weather Radar WMS m.add_wms_layer(     data=\"https://mesonet.agron.iastate.edu/cgi-bin/wms/nexrad/n0r.cgi\",     service_type=\"wms\",     layers=[\"nexrad-n0r\"],     opacity=0.8, ) m In\u00a0[\u00a0]: Copied! <pre>m.to_html(\"wms_layer_example.html\")\n</pre> m.to_html(\"wms_layer_example.html\")"},{"location":"notebooks/wms_layer/#wms-layer-example","title":"WMS Layer Example\u00b6","text":"<p>Web Map Service integration using deck.gl WMSLayer.</p>"},{"location":"notebooks/wms_layer/#create-a-map-with-wms-layer","title":"Create a map with WMS layer\u00b6","text":""},{"location":"notebooks/wms_layer/#export-to-html","title":"Export to HTML\u00b6","text":""},{"location":"notebooks/zarr_layer/","title":"Zarr layer","text":"In\u00a0[\u00a0]: Copied! <pre>from anymap_ts import Map\n\n# CarbonPlan 4D climate pyramid (v2, temp/precip by month)\nZARR_URL = (\n    \"https://carbonplan-maps.s3.us-west-2.amazonaws.com/v2/demo/4d/tavg-prec-month\"\n)\n\n# Create a MapLibre map\nm = Map(center=[-100, 40], zoom=3, style=\"dark-matter\")\n\n# Add the Zarr layer with precipitation data for January\n# Note: This dataset uses 'x' and 'y' instead of 'lon' and 'lat'\nm.add_zarr_layer(\n    url=ZARR_URL,\n    variable=\"climate\",\n    name=\"climate-prec\",\n    clim=(0, 300),  # Precipitation range\n    colormap=[\n        \"#f7fbff\",\n        \"#deebf7\",\n        \"#c6dbef\",\n        \"#9ecae1\",\n        \"#6baed6\",\n        \"#4292c6\",\n        \"#2171b5\",\n        \"#08519c\",\n        \"#08306b\",\n    ],  # Blues\n    opacity=0.8,\n    selector={\"band\": \"prec\", \"month\": 1},  # January precipitation\n    spatial_dimensions={\"lat\": \"y\", \"lon\": \"x\"},  # Custom dimension names\n    zarr_version=2,\n)\n\nm\n</pre> from anymap_ts import Map  # CarbonPlan 4D climate pyramid (v2, temp/precip by month) ZARR_URL = (     \"https://carbonplan-maps.s3.us-west-2.amazonaws.com/v2/demo/4d/tavg-prec-month\" )  # Create a MapLibre map m = Map(center=[-100, 40], zoom=3, style=\"dark-matter\")  # Add the Zarr layer with precipitation data for January # Note: This dataset uses 'x' and 'y' instead of 'lon' and 'lat' m.add_zarr_layer(     url=ZARR_URL,     variable=\"climate\",     name=\"climate-prec\",     clim=(0, 300),  # Precipitation range     colormap=[         \"#f7fbff\",         \"#deebf7\",         \"#c6dbef\",         \"#9ecae1\",         \"#6baed6\",         \"#4292c6\",         \"#2171b5\",         \"#08519c\",         \"#08306b\",     ],  # Blues     opacity=0.8,     selector={\"band\": \"prec\", \"month\": 1},  # January precipitation     spatial_dimensions={\"lat\": \"y\", \"lon\": \"x\"},  # Custom dimension names     zarr_version=2, )  m In\u00a0[\u00a0]: Copied! <pre># Update to show July precipitation\nm.update_zarr_layer(\n    layer_id=\"climate-prec\",\n    selector={\"band\": \"prec\", \"month\": 7},  # July\n)\n</pre> # Update to show July precipitation m.update_zarr_layer(     layer_id=\"climate-prec\",     selector={\"band\": \"prec\", \"month\": 7},  # July ) In\u00a0[\u00a0]: Copied! <pre># Switch to temperature data with a warm colormap\nm.update_zarr_layer(\n    layer_id=\"climate-prec\",\n    selector={\"band\": \"tavg\", \"month\": 7},  # July temperature\n    clim=(-20, 30),  # Temperature range in Celsius\n    colormap=[\n        \"#313695\",\n        \"#4575b4\",\n        \"#74add1\",\n        \"#abd9e9\",\n        \"#e0f3f8\",\n        \"#ffffbf\",\n        \"#fee090\",\n        \"#fdae61\",\n        \"#f46d43\",\n        \"#d73027\",\n        \"#a50026\",\n    ],\n)\n</pre> # Switch to temperature data with a warm colormap m.update_zarr_layer(     layer_id=\"climate-prec\",     selector={\"band\": \"tavg\", \"month\": 7},  # July temperature     clim=(-20, 30),  # Temperature range in Celsius     colormap=[         \"#313695\",         \"#4575b4\",         \"#74add1\",         \"#abd9e9\",         \"#e0f3f8\",         \"#ffffbf\",         \"#fee090\",         \"#fdae61\",         \"#f46d43\",         \"#d73027\",         \"#a50026\",     ], ) In\u00a0[\u00a0]: Copied! <pre>from anymap_ts import Map\n\n# Ocean temperature (v3 pyramid, EPSG:3857)\nOCEAN_URL = \"https://atlantis-vis-o.s3-ext.jc.rl.ac.uk/noc-npd-era5-demo/npd-eorca1-era5v1/gn/T1y/tos_con\"\n\nm2 = Map(center=[0, 30], zoom=2, style=\"dark-matter\")\n\nm2.add_zarr_layer(\n    url=OCEAN_URL,\n    variable=\"tos_con\",\n    name=\"ocean-temp\",\n    clim=(0, 50),\n    colormap=[\n        \"#000004\",\n        \"#1b0c41\",\n        \"#4a0c6b\",\n        \"#781c6d\",\n        \"#a52c60\",\n        \"#cf4446\",\n        \"#ed6925\",\n        \"#fb9b06\",\n        \"#f7d13d\",\n        \"#fcffa4\",\n    ],  # Inferno\n    opacity=0.9,\n    selector={\"time\": 0},\n)\n\nm2\n</pre> from anymap_ts import Map  # Ocean temperature (v3 pyramid, EPSG:3857) OCEAN_URL = \"https://atlantis-vis-o.s3-ext.jc.rl.ac.uk/noc-npd-era5-demo/npd-eorca1-era5v1/gn/T1y/tos_con\"  m2 = Map(center=[0, 30], zoom=2, style=\"dark-matter\")  m2.add_zarr_layer(     url=OCEAN_URL,     variable=\"tos_con\",     name=\"ocean-temp\",     clim=(0, 50),     colormap=[         \"#000004\",         \"#1b0c41\",         \"#4a0c6b\",         \"#781c6d\",         \"#a52c60\",         \"#cf4446\",         \"#ed6925\",         \"#fb9b06\",         \"#f7d13d\",         \"#fcffa4\",     ],  # Inferno     opacity=0.9,     selector={\"time\": 0}, )  m2 In\u00a0[\u00a0]: Copied! <pre>from anymap_ts import Map\n\n# Burn Probability over CONUS (30m resolution, Zarr v3)\nBURN_URL = \"https://carbonplan-share.s3.us-west-2.amazonaws.com/zarr-layer-examples/13-lvl-30m-4326-scott-BP.zarr\"\n\nm3 = Map(center=[-98, 39], zoom=4, style=\"dark-matter\")\n\n# Note: This dataset uses \"latitude\"/\"longitude\" dimension names (not \"lat\"/\"lon\")\n# The library will read bounds from the coordinate arrays automatically\nm3.add_zarr_layer(\n    url=BURN_URL,\n    variable=\"BP\",\n    name=\"burn-prob\",\n    clim=(0, 0.13),\n    colormap=[\n        \"#000004\",\n        \"#1b0c41\",\n        \"#4a0c6b\",\n        \"#781c6d\",\n        \"#a52c60\",\n        \"#cf4446\",\n        \"#ed6925\",\n        \"#fb9b06\",\n        \"#f7d13d\",\n        \"#fcffa4\",\n    ],  # Inferno/Fire\n    opacity=0.9,\n    spatial_dimensions={\n        \"lat\": \"latitude\",\n        \"lon\": \"longitude\",\n    },  # Custom dimension names\n    zarr_version=3,\n)\n\nm3\n</pre> from anymap_ts import Map  # Burn Probability over CONUS (30m resolution, Zarr v3) BURN_URL = \"https://carbonplan-share.s3.us-west-2.amazonaws.com/zarr-layer-examples/13-lvl-30m-4326-scott-BP.zarr\"  m3 = Map(center=[-98, 39], zoom=4, style=\"dark-matter\")  # Note: This dataset uses \"latitude\"/\"longitude\" dimension names (not \"lat\"/\"lon\") # The library will read bounds from the coordinate arrays automatically m3.add_zarr_layer(     url=BURN_URL,     variable=\"BP\",     name=\"burn-prob\",     clim=(0, 0.13),     colormap=[         \"#000004\",         \"#1b0c41\",         \"#4a0c6b\",         \"#781c6d\",         \"#a52c60\",         \"#cf4446\",         \"#ed6925\",         \"#fb9b06\",         \"#f7d13d\",         \"#fcffa4\",     ],  # Inferno/Fire     opacity=0.9,     spatial_dimensions={         \"lat\": \"latitude\",         \"lon\": \"longitude\",     },  # Custom dimension names     zarr_version=3, )  m3 In\u00a0[\u00a0]: Copied! <pre># Remove a zarr layer\nm.remove_zarr_layer(\"climate-prec\")\n</pre> # Remove a zarr layer m.remove_zarr_layer(\"climate-prec\")"},{"location":"notebooks/zarr_layer/#zarr-layer-example","title":"Zarr Layer Example\u00b6","text":"<p>This notebook demonstrates how to visualize Zarr datasets using the @carbonplan/zarr-layer package.</p> <p>The Zarr layer provides GPU-accelerated rendering with support for:</p> <ul> <li>Zarr v2 and v3 formats via zarrita.js</li> <li>EPSG:4326 and EPSG:3857 projections</li> <li>Globe and mercator projections</li> <li>Multi-dimensional data with selectors</li> <li>Dynamic updates (colormap, clim, selector)</li> </ul>"},{"location":"notebooks/zarr_layer/#basic-example-4d-climate-pyramid","title":"Basic Example: 4D Climate Pyramid\u00b6","text":"<p>Add a Zarr layer using the CarbonPlan 4D climate pyramid dataset with temperature and precipitation by month.</p>"},{"location":"notebooks/zarr_layer/#update-layer-properties","title":"Update Layer Properties\u00b6","text":"<p>You can dynamically update layer properties like selector, colormap, and clim without recreating the layer.</p>"},{"location":"notebooks/zarr_layer/#ocean-temperature-zarr-v3","title":"Ocean Temperature (Zarr v3)\u00b6","text":"<p>This example uses a Zarr v3 pyramid dataset with ocean temperature data.</p>"},{"location":"notebooks/zarr_layer/#burn-probability-over-conus","title":"Burn Probability over CONUS\u00b6","text":"<p>This example uses a high-resolution (30m) Zarr v3 dataset showing wildfire burn probability.</p>"},{"location":"notebooks/zarr_layer/#configuration-options","title":"Configuration Options\u00b6","text":"<p>The <code>add_zarr_layer</code> method supports several configuration options:</p> Parameter Type Default Description <code>url</code> str required URL to the Zarr store <code>variable</code> str required Variable name in the Zarr dataset <code>name</code> str auto Layer identifier <code>colormap</code> List[str] ['#000000', '#ffffff'] Hex color strings for visualization <code>clim</code> Tuple[float, float] (0, 100) Color scale limits (min, max) <code>opacity</code> float 1.0 Layer opacity (0-1) <code>selector</code> Dict {} Dimension selector (e.g., {\"month\": 4, \"band\": \"tavg\"}) <code>minzoom</code> int 0 Minimum zoom level for rendering <code>maxzoom</code> int 22 Maximum zoom level for rendering <code>fill_value</code> float auto No-data value <code>spatial_dimensions</code> Dict auto Custom spatial dimension names (e.g., {\"lat\": \"y\", \"lon\": \"x\"}) <code>zarr_version</code> int auto Zarr format version (2 or 3) <code>bounds</code> List[float] auto Explicit bounds [west, south, east, north] for datasets without coordinate arrays"},{"location":"notebooks/zarr_layer/#sample-datasets","title":"Sample Datasets\u00b6","text":"<p>CarbonPlan provides several sample datasets at zarr-layer.demo.carbonplan.org:</p> Dataset URL Variable Description 4D Climate carbonplan-maps.s3.../v2/demo/4d/tavg-prec-month climate Temp/precip by month Ocean Temperature atlantis-vis-o.s3-ext.../tos_con tos_con v3 pyramid, EPSG:3857 Burn Probability carbonplan-share.s3.../13-lvl-30m-4326-scott-BP.zarr BP 30m resolution CONUS"},{"location":"typescript/","title":"TypeScript Examples","text":"<p>anymap-ts is built with TypeScript, providing type-safe interactive maps through the anywidget framework. This section demonstrates how to use the TypeScript renderers directly.</p>"},{"location":"typescript/#architecture-overview","title":"Architecture Overview","text":"<p>anymap-ts uses the anywidget pattern for Python-JavaScript communication:</p> <pre><code>Python (anymap_ts)  &lt;--&gt;  anywidget model  &lt;--&gt;  TypeScript Renderer\n</code></pre> <p>Each map type has a corresponding TypeScript renderer that:</p> <ol> <li>Receives a <code>model</code> object for state synchronization with Python</li> <li>Receives an <code>el</code> DOM element for rendering</li> <li>Handles method calls from Python via <code>_js_calls</code></li> <li>Sends events back to Python via <code>_js_events</code></li> </ol>"},{"location":"typescript/#available-renderers","title":"Available Renderers","text":"Renderer Library Source File <code>MapLibreRenderer</code> MapLibre GL JS <code>src/maplibre/MapLibreRenderer.ts</code> <code>LeafletRenderer</code> Leaflet <code>src/leaflet/LeafletRenderer.ts</code> <code>MapboxRenderer</code> Mapbox GL JS <code>src/mapbox/MapboxRenderer.ts</code> <code>CesiumWidget</code> Cesium <code>src/cesium/index.ts</code> <code>DeckGLRenderer</code> DeckGL + MapLibre <code>src/deckgl/DeckGLRenderer.ts</code> <code>OpenLayersRenderer</code> OpenLayers <code>src/openlayers/OpenLayersRenderer.ts</code> <code>PotreeWidget</code> Potree <code>src/potree/index.ts</code> <code>KeplerGLWidget</code> KeplerGL <code>src/keplergl/index.ts</code>"},{"location":"typescript/#examples-by-category","title":"Examples by Category","text":""},{"location":"typescript/#basic-mapping","title":"Basic Mapping","text":"<ul> <li>MapLibre GL JS - Vector maps with drawing and layer control</li> <li>Leaflet - Lightweight, mobile-friendly maps</li> <li>Mapbox GL JS - Commercial vector maps (requires token)</li> <li>OpenLayers - Feature-rich with WMS/WMTS support</li> </ul>"},{"location":"typescript/#3d-visualization","title":"3D Visualization","text":"<ul> <li>Cesium - 3D globe with terrain and 3D Tiles</li> </ul>"},{"location":"typescript/#gpu-accelerated-layers","title":"GPU-Accelerated Layers","text":"<ul> <li>DeckGL - ScatterplotLayer, HexagonLayer, HeatmapLayer, ArcLayer</li> </ul>"},{"location":"typescript/#scientific-data","title":"Scientific Data","text":"<ul> <li>COG Layer - Cloud Optimized GeoTIFF visualization</li> <li>Zarr Layer - Multi-dimensional dataset visualization</li> </ul>"},{"location":"typescript/#specialized-viewers","title":"Specialized Viewers","text":"<ul> <li>Potree - Point cloud visualization for LiDAR</li> <li>KeplerGL - Interactive data exploration</li> </ul>"},{"location":"typescript/#core-types","title":"Core Types","text":"<p>The anywidget communication types are defined in <code>src/types/anywidget.ts</code>:</p> <pre><code>// Method call from Python to JavaScript\ninterface JsCall {\n  id: number;\n  method: string;\n  args: unknown[];\n  kwargs: Record&lt;string, unknown&gt;;\n}\n\n// Event from JavaScript to Python\ninterface JsEvent {\n  type: string;\n  data: unknown;\n  timestamp: number;\n}\n\n// Render context provided by anywidget\ninterface RenderContext {\n  model: MapWidgetModel;\n  el: HTMLElement;\n}\n</code></pre>"},{"location":"typescript/#typescript-source-files","title":"TypeScript Source Files","text":"<p>Standalone TypeScript example files are available in <code>src/examples/</code>:</p> File Description <code>maplibre.ts</code> MapLibre with draw and layer control <code>leaflet.ts</code> Leaflet with markers and GeoJSON <code>mapbox.ts</code> Mapbox GL JS example <code>cesium.ts</code> Cesium 3D globe <code>deckgl.ts</code> DeckGL visualization layers <code>openlayers.ts</code> OpenLayers mapping <code>potree.ts</code> Potree point cloud viewer <code>keplergl.ts</code> KeplerGL data exploration <code>cog_layer.ts</code> COG layer visualization <code>zarr_layer.ts</code> Zarr layer visualization"},{"location":"typescript/examples/arc_layer/","title":"Arc Layer","text":"<p>The DeckGL ArcLayer renders raised arcs joining pairs of source and target points, ideal for visualizing origin-destination data like flight routes, migration patterns, and transportation networks.</p>"},{"location":"typescript/examples/arc_layer/#python-example","title":"Python Example","text":"<pre><code>from anymap_ts import MapLibreMap\n\n# Sample flight data from San Francisco\nflights = [\n    {\"source\": [-122.4194, 37.7749], \"target\": [-73.9857, 40.7484], \"name\": \"SF to NYC\"},\n    {\"source\": [-122.4194, 37.7749], \"target\": [-87.6298, 41.8781], \"name\": \"SF to Chicago\"},\n    {\"source\": [-122.4194, 37.7749], \"target\": [-118.2437, 34.0522], \"name\": \"SF to LA\"},\n]\n\nm = MapLibreMap(center=[-98.5795, 39.8283], zoom=3, pitch=30)\nm.add_basemap(\"CartoDB.DarkMatter\")\nm.add_arc_layer(\n    data=flights,\n    name=\"flights\",\n    get_source_color=[0, 128, 255, 255],\n    get_target_color=[255, 128, 0, 255],\n    get_width=2,\n    great_circle=True,\n)\nm\n</code></pre>"},{"location":"typescript/examples/arc_layer/#typescript-implementation","title":"TypeScript Implementation","text":"<p>The <code>handleAddArcLayer</code> method in <code>MapLibreRenderer</code> creates deck.gl ArcLayer instances:</p> <pre><code>import { ArcLayer } from '@deck.gl/layers';\n\nprivate handleAddArcLayer(args: unknown[], kwargs: Record&lt;string, unknown&gt;): void {\n  this.initializeDeckOverlay();\n  const id = kwargs.id as string || `arc-${Date.now()}`;\n  const data = kwargs.data as unknown[];\n\n  const layer = new ArcLayer({\n    id,\n    data,\n    pickable: kwargs.pickable !== false,\n    opacity: kwargs.opacity as number ?? 0.8,\n    getWidth: kwargs.getWidth ?? 1,\n    getHeight: kwargs.getHeight ?? 1,\n    greatCircle: kwargs.greatCircle as boolean ?? false,\n    getSourcePosition: (d: any) =&gt; d[kwargs.getSourcePosition as string] || d.source,\n    getTargetPosition: (d: any) =&gt; d[kwargs.getTargetPosition as string] || d.target,\n    getSourceColor: kwargs.getSourceColor ?? [51, 136, 255, 255],\n    getTargetColor: kwargs.getTargetColor ?? [255, 136, 51, 255],\n  });\n\n  this.deckLayers.set(id, layer);\n  this.updateDeckOverlay();\n  this.deckLayerAdapter?.notifyLayerAdded(id);\n}\n</code></pre>"},{"location":"typescript/examples/arc_layer/#layer-control-integration","title":"Layer Control Integration","text":"<p>Arc layers integrate with the layer control via <code>DeckLayerAdapter</code>:</p> <pre><code>// Layer IDs starting with 'arc-' are managed by DeckLayerAdapter\ngetLayerIds(): string[] {\n  return Array.from(this.deckLayers.keys()).filter(id =&gt;\n    id.startsWith('arc-') || id.startsWith('pointcloud-')\n  );\n}\n\n// Toggle visibility by cloning the immutable deck.gl layer\nsetVisibility(layerId: string, visible: boolean): void {\n  const layer = this.deckLayers.get(layerId);\n  if (layer &amp;&amp; typeof layer.clone === 'function') {\n    const updated = layer.clone({ visible });\n    this.deckLayers.set(layerId, updated);\n    this.updateOverlay();\n  }\n}\n</code></pre>"},{"location":"typescript/examples/arc_layer/#api-reference","title":"API Reference","text":""},{"location":"typescript/examples/arc_layer/#parameters","title":"Parameters","text":"Parameter Type Default Description <code>data</code> <code>Array</code> required Array of arc data objects <code>name</code> <code>string</code> auto-generated Layer identifier <code>get_source_position</code> <code>string</code> <code>\"source\"</code> Accessor for source [lng, lat] <code>get_target_position</code> <code>string</code> <code>\"target\"</code> Accessor for target [lng, lat] <code>get_source_color</code> <code>Array&lt;int&gt;</code> <code>[51, 136, 255, 255]</code> RGBA color at source <code>get_target_color</code> <code>Array&lt;int&gt;</code> <code>[255, 136, 51, 255]</code> RGBA color at target <code>get_width</code> <code>number</code> <code>1</code> Arc width in pixels <code>get_height</code> <code>number</code> <code>1</code> Arc height multiplier <code>great_circle</code> <code>bool</code> <code>false</code> Use great circle path <code>pickable</code> <code>bool</code> <code>true</code> Enable hover/click <code>opacity</code> <code>float</code> <code>0.8</code> Layer opacity"},{"location":"typescript/examples/arc_layer/#data-format","title":"Data Format","text":"<p>Each arc object should have source and target coordinates:</p> <pre><code>{\n  source: [longitude, latitude],  // or [longitude, latitude, altitude]\n  target: [longitude, latitude],\n  // ... additional properties\n}\n</code></pre>"},{"location":"typescript/examples/arc_layer/#source-files","title":"Source Files","text":"<ul> <li>MapLibre Handler: <code>src/maplibre/MapLibreRenderer.ts</code></li> <li>Mapbox Handler: <code>src/mapbox/MapboxRenderer.ts</code></li> <li>DeckGL Handler: <code>src/deckgl/DeckGLRenderer.ts</code></li> <li>Layer Adapter: <code>src/maplibre/adapters/DeckLayerAdapter.ts</code></li> </ul> <p>See also: Python notebook example</p>"},{"location":"typescript/examples/cesium/","title":"Cesium","text":"<p>Cesium is a powerful 3D globe visualization library with terrain and 3D Tiles support.</p>"},{"location":"typescript/examples/cesium/#python-example","title":"Python Example","text":"<pre><code>from anymap_ts import CesiumMap\n\nm = CesiumMap(center=[-122.4, 37.8], zoom=10)\nm.add_basemap(\"OpenStreetMap\")\nm.add_geojson(geojson, name=\"features\", stroke=\"#ff0000\", fill=\"rgba(255,0,0,0.3)\")\nm.fly_to(-122.4194, 37.7749, height=50000, heading=45, pitch=-45)\nm\n</code></pre> <p>Note: Some features like Cesium World Terrain require a Cesium Ion access token. Set the <code>CESIUM_TOKEN</code> environment variable.</p>"},{"location":"typescript/examples/cesium/#typescript-implementation","title":"TypeScript Implementation","text":"<p>Cesium is loaded dynamically from CDN since it's too large to bundle:</p> <pre><code>const CESIUM_VERSION = '1.120';\nconst CESIUM_BASE_URL = `https://cesium.com/downloads/cesiumjs/releases/${CESIUM_VERSION}/Build/Cesium`;\n\n// Load Cesium JS dynamically\nfunction loadCesiumJS(): Promise&lt;void&gt; {\n  return new Promise((resolve, reject) =&gt; {\n    if (window.Cesium) {\n      resolve();\n      return;\n    }\n\n    window.CESIUM_BASE_URL = CESIUM_BASE_URL;\n\n    const script = document.createElement('script');\n    script.src = `${CESIUM_BASE_URL}/Cesium.js`;\n    script.async = true;\n    script.onload = () =&gt; resolve();\n    script.onerror = () =&gt; reject(new Error('Failed to load Cesium'));\n    document.head.appendChild(script);\n  });\n}\n</code></pre>"},{"location":"typescript/examples/cesium/#cesiumwidget-class","title":"CesiumWidget Class","text":"<pre><code>class CesiumWidget {\n  private viewer: Cesium.Viewer | null = null;\n  private dataSources: Map&lt;string, Cesium.DataSource&gt; = new Map();\n\n  async initialize(): Promise&lt;void&gt; {\n    const Cesium = window.Cesium;\n    const accessToken = this.model.get('access_token');\n\n    if (accessToken) {\n      Cesium.Ion.defaultAccessToken = accessToken;\n    }\n\n    // Create viewer\n    this.viewer = new Cesium.Viewer(this.container, {\n      baseLayerPicker: false,\n      geocoder: false,\n      homeButton: false,\n      animation: false,\n      timeline: false,\n    });\n\n    // Set initial camera position\n    const center = this.model.get('center');\n    const height = this.zoomToHeight(this.model.get('zoom'));\n\n    this.viewer.camera.setView({\n      destination: Cesium.Cartesian3.fromDegrees(center[0], center[1], height),\n    });\n  }\n}\n</code></pre>"},{"location":"typescript/examples/cesium/#key-methods","title":"Key Methods","text":""},{"location":"typescript/examples/cesium/#camera-control","title":"Camera Control","text":"<pre><code>// Convert zoom level to camera height\nfunction zoomToHeight(zoom: number): number {\n  return 40000000 / Math.pow(2, zoom);\n}\n\nhandle_flyTo(args: unknown[], kwargs: Record&lt;string, unknown&gt;): void {\n  const Cesium = window.Cesium;\n  const lng = args[0] as number;\n  const lat = args[1] as number;\n  const height = kwargs.height as number || this.zoomToHeight(kwargs.zoom as number || 10);\n  const heading = kwargs.heading as number || 0;\n  const pitch = kwargs.pitch as number || -90;\n  const duration = kwargs.duration as number ?? 2;\n\n  this.viewer.camera.flyTo({\n    destination: Cesium.Cartesian3.fromDegrees(lng, lat, height),\n    orientation: {\n      heading: Cesium.Math.toRadians(heading),\n      pitch: Cesium.Math.toRadians(pitch),\n      roll: 0,\n    },\n    duration,\n  });\n}\n\nhandle_resetView(args: unknown[], kwargs: Record&lt;string, unknown&gt;): void {\n  this.viewer.camera.flyHome(kwargs.duration as number ?? 2);\n}\n</code></pre>"},{"location":"typescript/examples/cesium/#adding-geojson","title":"Adding GeoJSON","text":"<pre><code>async handle_addGeoJSON(args: unknown[], kwargs: Record&lt;string, unknown&gt;): Promise&lt;void&gt; {\n  const Cesium = window.Cesium;\n  const data = kwargs.data as object;\n  const name = kwargs.name as string;\n  const stroke = kwargs.stroke as string || '#3388ff';\n  const fill = kwargs.fill as string || 'rgba(51, 136, 255, 0.5)';\n\n  const dataSource = await Cesium.GeoJsonDataSource.load(data, {\n    stroke: Cesium.Color.fromCssColorString(stroke),\n    fill: Cesium.Color.fromCssColorString(fill),\n    clampToGround: true,\n  });\n\n  await this.viewer.dataSources.add(dataSource);\n  this.dataSources.set(name, dataSource);\n\n  if (kwargs.flyTo !== false) {\n    this.viewer.zoomTo(dataSource);\n  }\n}\n</code></pre>"},{"location":"typescript/examples/cesium/#terrain","title":"Terrain","text":"<pre><code>handle_setTerrain(args: unknown[], kwargs: Record&lt;string, unknown&gt;): void {\n  const Cesium = window.Cesium;\n\n  this.viewer.scene.setTerrain(\n    Cesium.Terrain.fromWorldTerrain({\n      requestVertexNormals: true,\n      requestWaterMask: true,\n    })\n  );\n}\n</code></pre>"},{"location":"typescript/examples/cesium/#basemap","title":"Basemap","text":"<pre><code>handle_addBasemap(args: unknown[], kwargs: Record&lt;string, unknown&gt;): void {\n  const Cesium = window.Cesium;\n  const url = args[0] as string;\n  const name = kwargs.name as string || 'basemap';\n\n  const imageryProvider = new Cesium.UrlTemplateImageryProvider({ url });\n  const layer = this.viewer.imageryLayers.addImageryProvider(imageryProvider);\n  this.imageryLayers.set(name, layer);\n}\n</code></pre>"},{"location":"typescript/examples/cesium/#3d-features","title":"3D Features","text":""},{"location":"typescript/examples/cesium/#camera-orientation","title":"Camera Orientation","text":"<p>Cesium supports full 3D camera control with heading, pitch, and roll:</p> <pre><code>// Heading: rotation around the vertical axis (0-360 degrees)\n// Pitch: rotation around the lateral axis (-90 to 90 degrees)\n// Roll: rotation around the longitudinal axis\n\nthis.viewer.camera.flyTo({\n  destination: Cesium.Cartesian3.fromDegrees(lng, lat, height),\n  orientation: {\n    heading: Cesium.Math.toRadians(45),  // 45 degrees from north\n    pitch: Cesium.Math.toRadians(-45),   // 45 degrees down\n    roll: 0,\n  },\n});\n</code></pre>"},{"location":"typescript/examples/cesium/#3d-tilesets","title":"3D Tilesets","text":"<pre><code>handle_add3DTileset(args: unknown[], kwargs: Record&lt;string, unknown&gt;): void {\n  const Cesium = window.Cesium;\n  const url = kwargs.url as string;\n  const name = kwargs.name as string;\n\n  const tileset = this.viewer.scene.primitives.add(\n    new Cesium.Cesium3DTileset({ url })\n  );\n\n  this.tilesets.set(name, tileset);\n}\n</code></pre>"},{"location":"typescript/examples/cesium/#source-files","title":"Source Files","text":"<ul> <li>Widget: <code>src/cesium/index.ts</code></li> <li>Types: <code>src/types/cesium.ts</code></li> </ul> <p>See also: Python notebook example</p>"},{"location":"typescript/examples/cog_layer/","title":"COG Layer","text":"<p>Cloud Optimized GeoTIFFs (COGs) enable efficient raster visualization with automatic reprojection.</p>"},{"location":"typescript/examples/cog_layer/#python-example","title":"Python Example","text":"<pre><code>from anymap_ts import Map\n\nCOG_URL = \"https://s3.us-east-1.amazonaws.com/ds-deck.gl-raster-public/cog/Annual_NLCD_LndCov_2024_CU_C1V1.tif\"\n\nm = Map(center=[-98.5, 39.8], zoom=4, style=\"dark-matter\")\nm.add_cog_layer(COG_URL, name=\"nlcd-landcover\", opacity=1.0)\nm\n</code></pre>"},{"location":"typescript/examples/cog_layer/#typescript-implementation","title":"TypeScript Implementation","text":"<p>COG layers use the <code>@developmentseed/deck.gl-geotiff</code> package with deck.gl overlay:</p> <pre><code>import { MapboxOverlay } from '@deck.gl/mapbox';\nimport { COGLayer, proj } from '@developmentseed/deck.gl-geotiff';\nimport { toProj4 } from 'geotiff-geokeys-to-proj4';\n\n// Parse GeoKeys for reprojection\nasync function geoKeysParser(geoKeys: Record&lt;string, unknown&gt;): Promise&lt;proj.ProjectionInfo&gt; {\n  const projDefinition = toProj4(geoKeys);\n  return {\n    def: projDefinition.proj4,\n    parsed: proj.parseCrs(projDefinition.proj4),\n    coordinatesUnits: projDefinition.coordinatesUnits,\n  };\n}\n</code></pre>"},{"location":"typescript/examples/cog_layer/#adding-cog-layer","title":"Adding COG Layer","text":"<pre><code>private handleAddCOGLayer(args: unknown[], kwargs: Record&lt;string, unknown&gt;): void {\n  // Initialize deck.gl overlay if needed\n  this.initializeDeckOverlay();\n\n  const id = kwargs.id as string || `cog-${Date.now()}`;\n  const geotiff = kwargs.geotiff as string;\n  const fitBounds = kwargs.fitBounds !== false;\n\n  const layer = new COGLayer({\n    id,\n    geotiff,\n    opacity: kwargs.opacity as number ?? 1,\n    visible: kwargs.visible !== false,\n    debug: kwargs.debug as boolean ?? false,\n    debugOpacity: kwargs.debugOpacity as number ?? 0.25,\n    maxError: kwargs.maxError as number ?? 0.125,\n    beforeId: kwargs.beforeId as string,\n    geoKeysParser,\n    onGeoTIFFLoad: (tiff, options) =&gt; {\n      if (fitBounds &amp;&amp; this.map) {\n        const { west, south, east, north } = options.geographicBounds;\n        this.map.fitBounds([[west, south], [east, north]], { padding: 40, duration: 1000 });\n      }\n    },\n  });\n\n  this.deckLayers.set(id, layer);\n  this.updateDeckOverlay();\n}\n</code></pre>"},{"location":"typescript/examples/cog_layer/#removing-cog-layer","title":"Removing COG Layer","text":"<pre><code>private handleRemoveCOGLayer(args: unknown[], kwargs: Record&lt;string, unknown&gt;): void {\n  const [id] = args as [string];\n  this.deckLayers.delete(id);\n  this.updateDeckOverlay();\n}\n</code></pre>"},{"location":"typescript/examples/cog_layer/#configuration-options","title":"Configuration Options","text":"Parameter Type Default Description <code>geotiff</code> string required URL to the Cloud Optimized GeoTIFF file <code>id</code> string auto Layer identifier <code>opacity</code> number 1.0 Layer opacity (0-1) <code>visible</code> boolean true Whether layer is visible <code>debug</code> boolean false Show reprojection mesh for debugging <code>debugOpacity</code> number 0.25 Opacity of debug mesh <code>maxError</code> number 0.125 Maximum reprojection error in pixels <code>fitBounds</code> boolean true Fit map to COG bounds after loading <code>beforeId</code> string undefined ID of layer to insert before"},{"location":"typescript/examples/cog_layer/#layer-control-integration","title":"Layer Control Integration","text":"<p>The COG layer adapter allows integration with the layer control:</p> <pre><code>class COGLayerAdapter implements CustomLayerAdapter {\n  private map: MapLibreMap;\n  private deckOverlay: MapboxOverlay;\n  private deckLayers: Map&lt;string, unknown&gt;;\n\n  getLayerIds(): string[] {\n    return Array.from(this.deckLayers.keys()).filter((id) =&gt; id.startsWith('cog-'));\n  }\n\n  setVisibility(layerId: string, visible: boolean): void {\n    const layer = this.deckLayers.get(layerId);\n    if (layer) {\n      const updatedLayer = (layer as COGLayer).clone({ visible });\n      this.deckLayers.set(layerId, updatedLayer);\n      this.updateOverlay();\n    }\n  }\n\n  setOpacity(layerId: string, opacity: number): void {\n    const layer = this.deckLayers.get(layerId);\n    if (layer) {\n      const updatedLayer = (layer as COGLayer).clone({ opacity });\n      this.deckLayers.set(layerId, updatedLayer);\n      this.updateOverlay();\n    }\n  }\n}\n</code></pre>"},{"location":"typescript/examples/cog_layer/#debug-mode","title":"Debug Mode","text":"<p>Enable debug mode to visualize the reprojection mesh:</p> <pre><code>m.add_cog_layer(\n    COG_URL,\n    name=\"nlcd-debug\",\n    debug=True,\n    debug_opacity=0.25,\n)\n</code></pre> <p>This shows the triangular mesh used for GPU reprojection, useful for debugging projection issues.</p>"},{"location":"typescript/examples/cog_layer/#source-files","title":"Source Files","text":"<ul> <li>MapLibre Implementation: <code>src/maplibre/MapLibreRenderer.ts</code></li> <li>DeckGL Implementation: <code>src/deckgl/DeckGLRenderer.ts</code></li> <li>Layer Adapter: <code>src/maplibre/adapters/COGLayerAdapter.ts</code></li> <li>Layer with Opacity: <code>src/maplibre/layers/COGLayerWithOpacity.ts</code></li> </ul> <p>See also: Python notebook example</p>"},{"location":"typescript/examples/deckgl/","title":"DeckGL","text":"<p>DeckGL provides GPU-accelerated visualization layers on top of MapLibre GL JS.</p>"},{"location":"typescript/examples/deckgl/#python-example","title":"Python Example","text":"<pre><code>from anymap_ts import DeckGLMap\nimport random\n\n# Create map with dark basemap\nm = DeckGLMap(center=[-122.4, 37.8], zoom=10)\nm.add_basemap(\"CartoDB.DarkMatter\")\n\n# Generate sample data\npoints = [\n    {\"coordinates\": [-122.4 + random.uniform(-0.2, 0.2), 37.8 + random.uniform(-0.2, 0.2)], \"value\": random.randint(1, 100)}\n    for _ in range(1000)\n]\n\n# Add scatterplot layer\nm.add_scatterplot_layer(data=points, name=\"scatterplot\", get_radius=100, get_fill_color=[255, 140, 0, 200])\n\n# Add hexagon aggregation layer\nm.add_hexagon_layer(data=points, name=\"hexagons\", radius=500, elevation_scale=10, extruded=True)\nm\n</code></pre>"},{"location":"typescript/examples/deckgl/#typescript-implementation","title":"TypeScript Implementation","text":"<p>The <code>DeckGLRenderer</code> extends <code>MapLibreRenderer</code> and adds deck.gl overlay support:</p> <pre><code>import { MapboxOverlay } from '@deck.gl/mapbox';\nimport { ScatterplotLayer, ArcLayer } from '@deck.gl/layers';\nimport { HexagonLayer, HeatmapLayer } from '@deck.gl/aggregation-layers';\nimport { MapLibreRenderer } from '../maplibre/MapLibreRenderer';\n\nexport class DeckGLRenderer extends MapLibreRenderer {\n  private deckOverlay: MapboxOverlay | null = null;\n  private deckLayers: Map&lt;string, unknown&gt; = new Map();\n\n  async initialize(): Promise&lt;void&gt; {\n    await super.initialize();\n\n    // Create deck.gl overlay\n    this.deckOverlay = new MapboxOverlay({ layers: [] });\n    this.map.addControl(this.deckOverlay);\n  }\n\n  private updateDeckOverlay(): void {\n    const layers = Array.from(this.deckLayers.values());\n    this.deckOverlay.setProps({ layers });\n  }\n}\n</code></pre>"},{"location":"typescript/examples/deckgl/#layer-types","title":"Layer Types","text":""},{"location":"typescript/examples/deckgl/#scatterplotlayer","title":"ScatterplotLayer","text":"<pre><code>private handleAddScatterplotLayer(args: unknown[], kwargs: Record&lt;string, unknown&gt;): void {\n  const id = kwargs.id as string || `scatterplot-${Date.now()}`;\n  const data = kwargs.data as unknown[];\n\n  const layer = new ScatterplotLayer({\n    id,\n    data,\n    pickable: true,\n    opacity: kwargs.opacity as number ?? 0.8,\n    stroked: true,\n    filled: true,\n    radiusScale: kwargs.radiusScale as number ?? 1,\n    radiusMinPixels: kwargs.radiusMinPixels as number ?? 1,\n    getPosition: (d: any) =&gt; d.coordinates || d.position,\n    getRadius: kwargs.getRadius ?? 5,\n    getFillColor: kwargs.getFillColor ?? [51, 136, 255, 200],\n    getLineColor: kwargs.getLineColor ?? [255, 255, 255, 255],\n  });\n\n  this.deckLayers.set(id, layer);\n  this.updateDeckOverlay();\n}\n</code></pre>"},{"location":"typescript/examples/deckgl/#hexagonlayer-aggregation","title":"HexagonLayer (Aggregation)","text":"<pre><code>private handleAddHexagonLayer(args: unknown[], kwargs: Record&lt;string, unknown&gt;): void {\n  const id = kwargs.id as string || `hexagon-${Date.now()}`;\n  const data = kwargs.data as unknown[];\n\n  const layer = new HexagonLayer({\n    id,\n    data,\n    pickable: true,\n    extruded: kwargs.extruded as boolean ?? true,\n    radius: kwargs.radius as number ?? 1000,\n    elevationScale: kwargs.elevationScale as number ?? 4,\n    getPosition: (d: any) =&gt; d.coordinates || d.position,\n    colorRange: [\n      [1, 152, 189],\n      [73, 227, 206],\n      [216, 254, 181],\n      [254, 237, 177],\n      [254, 173, 84],\n      [209, 55, 78],\n    ],\n  });\n\n  this.deckLayers.set(id, layer);\n  this.updateDeckOverlay();\n}\n</code></pre>"},{"location":"typescript/examples/deckgl/#heatmaplayer","title":"HeatmapLayer","text":"<pre><code>private handleAddHeatmapLayer(args: unknown[], kwargs: Record&lt;string, unknown&gt;): void {\n  const id = kwargs.id as string || `heatmap-${Date.now()}`;\n  const data = kwargs.data as unknown[];\n\n  const layer = new HeatmapLayer({\n    id,\n    data,\n    opacity: kwargs.opacity as number ?? 1,\n    radiusPixels: kwargs.radiusPixels as number ?? 30,\n    intensity: kwargs.intensity as number ?? 1,\n    threshold: kwargs.threshold as number ?? 0.05,\n    getPosition: (d: any) =&gt; d.coordinates || d.position,\n    getWeight: kwargs.getWeight ?? 1,\n    colorRange: [\n      [255, 255, 178, 25],\n      [254, 217, 118, 85],\n      [254, 178, 76, 127],\n      [253, 141, 60, 170],\n      [240, 59, 32, 212],\n      [189, 0, 38, 255],\n    ],\n  });\n\n  this.deckLayers.set(id, layer);\n  this.updateDeckOverlay();\n}\n</code></pre>"},{"location":"typescript/examples/deckgl/#arclayer-connections","title":"ArcLayer (Connections)","text":"<pre><code>private handleAddArcLayer(args: unknown[], kwargs: Record&lt;string, unknown&gt;): void {\n  const id = kwargs.id as string || `arc-${Date.now()}`;\n  const data = kwargs.data as unknown[];\n\n  const layer = new ArcLayer({\n    id,\n    data,\n    pickable: true,\n    getWidth: kwargs.getWidth ?? 1,\n    getSourcePosition: (d: any) =&gt; d.source || d.from,\n    getTargetPosition: (d: any) =&gt; d.target || d.to,\n    getSourceColor: kwargs.getSourceColor ?? [51, 136, 255, 255],\n    getTargetColor: kwargs.getTargetColor ?? [255, 136, 51, 255],\n  });\n\n  this.deckLayers.set(id, layer);\n  this.updateDeckOverlay();\n}\n</code></pre>"},{"location":"typescript/examples/deckgl/#available-layers","title":"Available Layers","text":"Layer Description <code>ScatterplotLayer</code> Render points as circles <code>ArcLayer</code> Render arcs between source and target positions <code>PathLayer</code> Render paths/polylines <code>PolygonLayer</code> Render filled and/or stroked polygons <code>HexagonLayer</code> Aggregate points into hexagonal bins <code>HeatmapLayer</code> Render heatmap based on point density <code>GridLayer</code> Aggregate points into rectangular bins <code>IconLayer</code> Render icons at positions <code>TextLayer</code> Render text labels <code>GeoJsonLayer</code> Render GeoJSON data"},{"location":"typescript/examples/deckgl/#source-files","title":"Source Files","text":"<ul> <li>Renderer: <code>src/deckgl/DeckGLRenderer.ts</code></li> <li>Types: <code>src/types/deckgl.ts</code></li> </ul> <p>See also: Python notebook example</p>"},{"location":"typescript/examples/keplergl/","title":"KeplerGL","text":"<p>KeplerGL is a powerful data exploration tool built on deck.gl.</p>"},{"location":"typescript/examples/keplergl/#python-example","title":"Python Example","text":"<pre><code>from anymap_ts import KeplerGLMap\nimport pandas as pd\nimport random\n\nm = KeplerGLMap(center=[-122.4, 37.8], zoom=10)\n\n# Create sample data\ndf = pd.DataFrame({\n    \"latitude\": [37.8 + random.uniform(-0.2, 0.2) for _ in range(100)],\n    \"longitude\": [-122.4 + random.uniform(-0.2, 0.2) for _ in range(100)],\n    \"value\": [random.randint(1, 100) for _ in range(100)],\n    \"category\": [random.choice([\"A\", \"B\", \"C\"]) for _ in range(100)],\n})\n\nm.add_data(df, name=\"sample_points\")\nm\n</code></pre> <p>Note: For best results, use the anywidget interface in Jupyter. HTML export has limited interactivity.</p>"},{"location":"typescript/examples/keplergl/#typescript-implementation","title":"TypeScript Implementation","text":"<p>KeplerGL is loaded dynamically and requires React:</p> <pre><code>class KeplerGLWidget {\n  private keplerGl: any = null;\n  private store: any = null;\n\n  async initialize(): Promise&lt;void&gt; {\n    await loadKeplerGL();\n\n    const { KeplerGl, keplerGlReducer, addDataToMap } = window.KeplerGl;\n\n    // Create Redux store\n    this.store = createStore(\n      combineReducers({ keplerGl: keplerGlReducer }),\n      applyMiddleware(taskMiddleware)\n    );\n\n    // Render KeplerGL component\n    const root = createRoot(this.container);\n    root.render(\n      &lt;Provider store={this.store}&gt;\n        &lt;KeplerGl\n          id=\"map\"\n          mapboxApiAccessToken={this.model.get('access_token')}\n          width={this.container.clientWidth}\n          height={this.container.clientHeight}\n        /&gt;\n      &lt;/Provider&gt;\n    );\n  }\n}\n</code></pre>"},{"location":"typescript/examples/keplergl/#key-methods","title":"Key Methods","text":""},{"location":"typescript/examples/keplergl/#adding-data","title":"Adding Data","text":"<pre><code>handle_addData(args: unknown[], kwargs: Record&lt;string, unknown&gt;): void {\n  const { addDataToMap } = window.KeplerGl;\n\n  const data = kwargs.data;\n  const name = kwargs.name as string;\n\n  // Determine data format\n  let processedData;\n  if (this.isDataFrame(data)) {\n    processedData = this.convertDataFrameToRows(data);\n  } else if (this.isGeoJSON(data)) {\n    processedData = data;\n  }\n\n  // Dispatch to KeplerGL store\n  this.store.dispatch(\n    addDataToMap({\n      datasets: {\n        info: { label: name, id: name },\n        data: processedData,\n      },\n    })\n  );\n}\n\nprivate convertDataFrameToRows(df: any): { fields: any[]; rows: any[] } {\n  const columns = Object.keys(df);\n  const fields = columns.map((name) =&gt; ({\n    name,\n    type: this.inferType(df[name][0]),\n  }));\n\n  const rows = [];\n  const length = df[columns[0]].length;\n  for (let i = 0; i &lt; length; i++) {\n    rows.push(columns.map((col) =&gt; df[col][i]));\n  }\n\n  return { fields, rows };\n}\n</code></pre>"},{"location":"typescript/examples/keplergl/#configuration","title":"Configuration","text":"<pre><code>handle_setConfig(args: unknown[], kwargs: Record&lt;string, unknown&gt;): void {\n  const { receiveMapConfig } = window.KeplerGl;\n  const config = kwargs.config as object;\n\n  this.store.dispatch(receiveMapConfig(config));\n}\n\nhandle_setFilter(args: unknown[], kwargs: Record&lt;string, unknown&gt;): void {\n  const { setFilter } = window.KeplerGl;\n\n  this.store.dispatch(setFilter({\n    idx: kwargs.idx as number,\n    prop: kwargs.prop as string,\n    value: kwargs.value,\n  }));\n}\n</code></pre>"},{"location":"typescript/examples/keplergl/#layer-management","title":"Layer Management","text":"<pre><code>handle_addLayer(args: unknown[], kwargs: Record&lt;string, unknown&gt;): void {\n  const { addLayer } = window.KeplerGl;\n\n  this.store.dispatch(addLayer({\n    type: kwargs.type as string,\n    dataId: kwargs.dataId as string,\n    config: kwargs.config as object,\n  }));\n}\n\nhandle_updateLayerConfig(args: unknown[], kwargs: Record&lt;string, unknown&gt;): void {\n  const { layerConfigChange } = window.KeplerGl;\n\n  this.store.dispatch(layerConfigChange({\n    oldLayer: this.getLayerById(kwargs.layerId as string),\n    newConfig: kwargs.config as object,\n  }));\n}\n</code></pre>"},{"location":"typescript/examples/keplergl/#data-formats","title":"Data Formats","text":"<p>KeplerGL supports multiple data formats:</p>"},{"location":"typescript/examples/keplergl/#dataframe-like-objects","title":"DataFrame-like Objects","text":"<pre><code>const data = {\n  latitude: [37.7749, 37.8044, 37.3382],\n  longitude: [-122.4194, -122.2712, -122.0308],\n  value: [100, 80, 60],\n  category: ['A', 'B', 'A'],\n};\n</code></pre>"},{"location":"typescript/examples/keplergl/#geojson","title":"GeoJSON","text":"<pre><code>const geojson = {\n  type: 'FeatureCollection',\n  features: [\n    {\n      type: 'Feature',\n      geometry: {\n        type: 'Polygon',\n        coordinates: [[[-122.5, 37.7], [-122.3, 37.7], [-122.3, 37.9], [-122.5, 37.9], [-122.5, 37.7]]],\n      },\n      properties: { name: 'Area' },\n    },\n  ],\n};\n</code></pre>"},{"location":"typescript/examples/keplergl/#built-in-layer-types","title":"Built-in Layer Types","text":"<ul> <li>Point - Render points as circles or icons</li> <li>Arc - Render arcs between points</li> <li>Line - Render line segments</li> <li>Polygon - Render filled polygons</li> <li>Hexagon - Hexagonal aggregation</li> <li>Heatmap - Density heatmap</li> <li>Grid - Grid-based aggregation</li> <li>Cluster - Point clustering</li> <li>H3 - H3 hexagonal tiles</li> <li>Trip - Animated path visualization</li> </ul>"},{"location":"typescript/examples/keplergl/#source-files","title":"Source Files","text":"<ul> <li>Widget: <code>src/keplergl/index.ts</code></li> <li>Types: <code>src/types/keplergl.ts</code></li> </ul> <p>See also: Python notebook example</p>"},{"location":"typescript/examples/leaflet/","title":"Leaflet","text":"<p>Leaflet is a lightweight, mobile-friendly mapping library with excellent browser support.</p>"},{"location":"typescript/examples/leaflet/#python-example","title":"Python Example","text":"<pre><code>from anymap_ts import LeafletMap\n\nm = LeafletMap(center=[-122.4, 37.8], zoom=10)\nm.add_basemap(\"OpenStreetMap\")\nm.add_marker(-122.4194, 37.7749, popup=\"San Francisco\")\nm.add_marker(-122.2712, 37.8044, popup=\"Oakland\")\nm\n</code></pre>"},{"location":"typescript/examples/leaflet/#typescript-implementation","title":"TypeScript Implementation","text":"<p>The <code>LeafletRenderer</code> class handles coordinate conversion (Leaflet uses <code>[lat, lng]</code> order):</p> <pre><code>import * as L from 'leaflet';\nimport { BaseMapRenderer } from '../core/BaseMapRenderer';\nimport type { MapWidgetModel } from '../types/anywidget';\n\nexport class LeafletRenderer extends BaseMapRenderer&lt;L.Map&gt; {\n  private layersMap: Map&lt;string, L.Layer&gt; = new Map();\n  private markersMap: Map&lt;string, L.Marker&gt; = new Map();\n\n  protected createMap(): L.Map {\n    // Leaflet uses [lat, lng] but we receive [lng, lat] from Python\n    const center = this.model.get('center') as [number, number];\n    const zoom = this.model.get('zoom');\n\n    return L.map(this.mapContainer!, {\n      center: [center[1], center[0]], // Convert [lng, lat] to [lat, lng]\n      zoom,\n      zoomControl: false,\n    });\n  }\n\n  async initialize(): Promise&lt;void&gt; {\n    this.createMapContainer();\n    this.map = this.createMap();\n    this.setupModelListeners();\n    this.setupMapEvents();\n    this.isMapReady = true;\n    this.processPendingCalls();\n  }\n}\n</code></pre>"},{"location":"typescript/examples/leaflet/#key-methods","title":"Key Methods","text":""},{"location":"typescript/examples/leaflet/#adding-markers","title":"Adding Markers","text":"<pre><code>private handleAddMarker(args: unknown[], kwargs: Record&lt;string, unknown&gt;): void {\n  const [lng, lat] = args as [number, number];\n  const id = kwargs.id as string || `marker-${Date.now()}`;\n  const popup = kwargs.popup as string;\n\n  // Note: Leaflet uses [lat, lng] order\n  const marker = L.marker([lat, lng]);\n\n  if (popup) {\n    marker.bindPopup(popup);\n  }\n\n  marker.addTo(this.map);\n  this.markersMap.set(id, marker);\n}\n</code></pre>"},{"location":"typescript/examples/leaflet/#adding-geojson","title":"Adding GeoJSON","text":"<pre><code>private handleAddGeoJSON(args: unknown[], kwargs: Record&lt;string, unknown&gt;): void {\n  const geojson = kwargs.data as FeatureCollection;\n  const name = kwargs.name as string;\n  const style = kwargs.style as Record&lt;string, unknown&gt;;\n\n  const geoJsonLayer = L.geoJSON(geojson, {\n    style: (feature) =&gt; style || this.getDefaultStyle(feature.geometry.type),\n    pointToLayer: (feature, latlng) =&gt; {\n      return L.circleMarker(latlng, style || this.getDefaultStyle('Point'));\n    },\n  });\n\n  geoJsonLayer.addTo(this.map);\n  this.layersMap.set(name, geoJsonLayer);\n\n  // Optionally fit bounds\n  if (kwargs.fitBounds !== false) {\n    this.map.fitBounds(geoJsonLayer.getBounds());\n  }\n}\n</code></pre>"},{"location":"typescript/examples/leaflet/#navigation","title":"Navigation","text":"<pre><code>private handleFlyTo(args: unknown[], kwargs: Record&lt;string, unknown&gt;): void {\n  const [lng, lat] = args as [number, number];\n  const zoom = kwargs.zoom as number;\n  const duration = (kwargs.duration as number) || 2000;\n\n  // Leaflet's flyTo uses [lat, lng] and duration in seconds\n  this.map.flyTo([lat, lng], zoom || this.map.getZoom(), {\n    duration: duration / 1000,\n  });\n}\n\nprivate handleFitBounds(args: unknown[], kwargs: Record&lt;string, unknown&gt;): void {\n  const [bounds] = args as [[number, number, number, number]];\n\n  // Convert [west, south, east, north] to Leaflet bounds\n  const leafletBounds = L.latLngBounds(\n    [bounds[1], bounds[0]], // Southwest: [lat, lng]\n    [bounds[3], bounds[2]]  // Northeast: [lat, lng]\n  );\n\n  this.map.fitBounds(leafletBounds);\n}\n</code></pre>"},{"location":"typescript/examples/leaflet/#controls","title":"Controls","text":"<pre><code>private handleAddControl(args: unknown[], kwargs: Record&lt;string, unknown&gt;): void {\n  const [controlType] = args as [string];\n  const position = this.convertPosition(kwargs.position as string);\n\n  let control: L.Control;\n  switch (controlType) {\n    case 'zoom':\n      control = L.control.zoom({ position });\n      break;\n    case 'scale':\n      control = L.control.scale({ position, imperial: false });\n      break;\n    case 'layers':\n      control = L.control.layers({}, {}, { position });\n      break;\n  }\n\n  control.addTo(this.map);\n  this.controlsMap.set(controlType, control);\n}\n\n// Convert position from MapLibre format to Leaflet format\nprivate convertPosition(position: string): L.ControlPosition {\n  const map: Record&lt;string, L.ControlPosition&gt; = {\n    'top-left': 'topleft',\n    'top-right': 'topright',\n    'bottom-left': 'bottomleft',\n    'bottom-right': 'bottomright',\n  };\n  return map[position] || 'topright';\n}\n</code></pre>"},{"location":"typescript/examples/leaflet/#default-styles","title":"Default Styles","text":"<pre><code>private getDefaultStyle(geometryType: string): Record&lt;string, unknown&gt; {\n  const defaults = {\n    Point: {\n      radius: 8,\n      fillColor: '#3388ff',\n      color: '#ffffff',\n      weight: 2,\n      fillOpacity: 0.8,\n    },\n    LineString: {\n      color: '#3388ff',\n      weight: 3,\n      opacity: 0.8,\n    },\n    Polygon: {\n      fillColor: '#3388ff',\n      color: '#0000ff',\n      weight: 2,\n      fillOpacity: 0.5,\n    },\n  };\n  return defaults[geometryType] || defaults.Point;\n}\n</code></pre>"},{"location":"typescript/examples/leaflet/#source-files","title":"Source Files","text":"<ul> <li>Renderer: <code>src/leaflet/LeafletRenderer.ts</code></li> <li>Types: <code>src/types/leaflet.ts</code></li> </ul> <p>See also: Python notebook example</p>"},{"location":"typescript/examples/mapbox/","title":"Mapbox GL JS","text":"<p>Mapbox GL JS is a commercial vector tile mapping library. Requires an access token.</p>"},{"location":"typescript/examples/mapbox/#python-example","title":"Python Example","text":"<pre><code>import os\nfrom anymap_ts import MapboxMap\n\nm = MapboxMap(center=[-122.4, 37.8], zoom=10)\nm.add_basemap(\"OpenStreetMap\")\nm.add_geojson(geojson, name=\"cities\")\nm.fly_to(-122.4194, 37.7749, zoom=12)\nm\n</code></pre> <p>Note: Set the <code>MAPBOX_TOKEN</code> environment variable or pass <code>access_token</code> to the constructor.</p>"},{"location":"typescript/examples/mapbox/#typescript-implementation","title":"TypeScript Implementation","text":"<p>The <code>MapboxRenderer</code> extends <code>MapLibreRenderer</code> since Mapbox GL JS has a similar API:</p> <pre><code>import mapboxgl from 'mapbox-gl';\nimport { BaseMapRenderer } from '../core/BaseMapRenderer';\nimport type { MapWidgetModel } from '../types/anywidget';\n\nexport class MapboxRenderer extends BaseMapRenderer&lt;mapboxgl.Map&gt; {\n  constructor(model: MapWidgetModel, el: HTMLElement) {\n    super(model, el);\n\n    // Set access token\n    const token = model.get('access_token') as string;\n    if (token) {\n      mapboxgl.accessToken = token;\n    }\n\n    this.registerMethods();\n  }\n\n  protected createMap(): mapboxgl.Map {\n    const center = this.model.get('center') as [number, number];\n    const zoom = this.model.get('zoom');\n    const style = this.model.get('style') as string || 'mapbox://styles/mapbox/streets-v12';\n\n    return new mapboxgl.Map({\n      container: this.mapContainer!,\n      style,\n      center,\n      zoom,\n    });\n  }\n\n  async initialize(): Promise&lt;void&gt; {\n    this.createMapContainer();\n    this.map = this.createMap();\n    this.setupModelListeners();\n    this.setupMapEvents();\n\n    await new Promise&lt;void&gt;((resolve) =&gt; {\n      this.map!.on('load', () =&gt; {\n        this.isMapReady = true;\n        this.processPendingCalls();\n        resolve();\n      });\n    });\n  }\n}\n</code></pre>"},{"location":"typescript/examples/mapbox/#key-methods","title":"Key Methods","text":""},{"location":"typescript/examples/mapbox/#adding-geojson","title":"Adding GeoJSON","text":"<pre><code>private handleAddGeoJSON(args: unknown[], kwargs: Record&lt;string, unknown&gt;): void {\n  const geojson = kwargs.data as FeatureCollection;\n  const name = kwargs.name as string;\n  const sourceId = `${name}-source`;\n\n  // Add source\n  this.map.addSource(sourceId, {\n    type: 'geojson',\n    data: geojson,\n  });\n\n  // Determine layer type\n  const layerType = this.inferLayerType(geojson);\n\n  // Add layer\n  this.map.addLayer({\n    id: name,\n    type: layerType,\n    source: sourceId,\n    paint: this.getDefaultPaint(layerType),\n  });\n}\n</code></pre>"},{"location":"typescript/examples/mapbox/#navigation","title":"Navigation","text":"<pre><code>private handleFlyTo(args: unknown[], kwargs: Record&lt;string, unknown&gt;): void {\n  const [lng, lat] = args as [number, number];\n\n  this.map.flyTo({\n    center: [lng, lat],\n    zoom: kwargs.zoom as number,\n    bearing: kwargs.bearing as number,\n    pitch: kwargs.pitch as number,\n    duration: kwargs.duration as number || 2000,\n  });\n}\n</code></pre>"},{"location":"typescript/examples/mapbox/#mapbox-specific-features","title":"Mapbox-Specific Features","text":""},{"location":"typescript/examples/mapbox/#3d-terrain","title":"3D Terrain","text":"<pre><code>private handleSetTerrain(args: unknown[], kwargs: Record&lt;string, unknown&gt;): void {\n  // Add terrain source\n  this.map.addSource('mapbox-dem', {\n    type: 'raster-dem',\n    url: 'mapbox://mapbox.mapbox-terrain-dem-v1',\n    tileSize: 512,\n    maxzoom: 14,\n  });\n\n  // Enable terrain\n  this.map.setTerrain({\n    source: 'mapbox-dem',\n    exaggeration: kwargs.exaggeration as number || 1.5,\n  });\n\n  // Add sky layer\n  this.map.addLayer({\n    id: 'sky',\n    type: 'sky',\n    paint: {\n      'sky-type': 'atmosphere',\n    },\n  });\n}\n</code></pre>"},{"location":"typescript/examples/mapbox/#3d-buildings","title":"3D Buildings","text":"<pre><code>private handleAdd3DBuildings(args: unknown[], kwargs: Record&lt;string, unknown&gt;): void {\n  this.map.addLayer({\n    id: '3d-buildings',\n    source: 'composite',\n    'source-layer': 'building',\n    filter: ['==', 'extrude', 'true'],\n    type: 'fill-extrusion',\n    minzoom: 15,\n    paint: {\n      'fill-extrusion-color': '#aaa',\n      'fill-extrusion-height': ['get', 'height'],\n      'fill-extrusion-base': ['get', 'min_height'],\n      'fill-extrusion-opacity': 0.6,\n    },\n  });\n}\n</code></pre>"},{"location":"typescript/examples/mapbox/#source-files","title":"Source Files","text":"<ul> <li>Renderer: <code>src/mapbox/MapboxRenderer.ts</code></li> <li>Types: <code>src/types/mapbox.ts</code></li> </ul> <p>See also: Python notebook example</p>"},{"location":"typescript/examples/maplibre/","title":"MapLibre GL JS","text":"<p>MapLibre GL JS is the default renderer in anymap-ts, providing vector tile maps with drawing and layer control capabilities.</p>"},{"location":"typescript/examples/maplibre/#python-example","title":"Python Example","text":"<pre><code>from anymap_ts import Map\n\nm = Map(center=[-122.4, 37.8], zoom=10)\nm.add_basemap(\"OpenStreetMap\")\nm.add_draw_control(position=\"top-left\")\nm.add_layer_control()\nm\n</code></pre>"},{"location":"typescript/examples/maplibre/#typescript-implementation","title":"TypeScript Implementation","text":"<p>The <code>MapLibreRenderer</code> class extends <code>BaseMapRenderer</code> and provides comprehensive map functionality:</p> <pre><code>import maplibregl, { Map as MapLibreMap } from 'maplibre-gl';\nimport { BaseMapRenderer } from '../core/BaseMapRenderer';\nimport type { MapWidgetModel, RenderContext } from '../types/anywidget';\n\nexport class MapLibreRenderer extends BaseMapRenderer&lt;MapLibreMap&gt; {\n  constructor(model: MapWidgetModel, el: HTMLElement) {\n    super(model, el);\n    this.registerMethods();\n  }\n\n  async initialize(): Promise&lt;void&gt; {\n    this.createMapContainer();\n    this.map = this.createMap();\n    this.setupModelListeners();\n    this.setupMapEvents();\n\n    await new Promise&lt;void&gt;((resolve) =&gt; {\n      this.map!.on('load', () =&gt; {\n        this.isMapReady = true;\n        this.processPendingCalls();\n        resolve();\n      });\n    });\n  }\n\n  protected createMap(): MapLibreMap {\n    const center = this.model.get('center');\n    const zoom = this.model.get('zoom');\n\n    return new MapLibreMap({\n      container: this.mapContainer!,\n      style: this.model.get('style'),\n      center: center as [number, number],\n      zoom,\n    });\n  }\n}\n</code></pre>"},{"location":"typescript/examples/maplibre/#key-methods","title":"Key Methods","text":""},{"location":"typescript/examples/maplibre/#navigation","title":"Navigation","text":"<pre><code>// Set center position\nprivate handleSetCenter(args: unknown[]): void {\n  const [lng, lat] = args as [number, number];\n  this.map.setCenter([lng, lat]);\n}\n\n// Fly to location with animation\nprivate handleFlyTo(args: unknown[], kwargs: Record&lt;string, unknown&gt;): void {\n  const [lng, lat] = args as [number, number];\n  this.map.flyTo({\n    center: [lng, lat],\n    zoom: kwargs.zoom as number,\n    duration: kwargs.duration as number || 2000,\n  });\n}\n\n// Fit bounds\nprivate handleFitBounds(args: unknown[]): void {\n  const [bounds] = args as [[number, number, number, number]];\n  this.map.fitBounds([\n    [bounds[0], bounds[1]],\n    [bounds[2], bounds[3]],\n  ]);\n}\n</code></pre>"},{"location":"typescript/examples/maplibre/#adding-geojson","title":"Adding GeoJSON","text":"<pre><code>private handleAddGeoJSON(args: unknown[], kwargs: Record&lt;string, unknown&gt;): void {\n  const geojson = kwargs.data as FeatureCollection;\n  const name = kwargs.name as string;\n  const sourceId = `${name}-source`;\n\n  // Add source\n  this.map.addSource(sourceId, {\n    type: 'geojson',\n    data: geojson,\n  });\n\n  // Determine layer type from geometry\n  const layerType = this.inferLayerType(geojson.features[0].geometry.type);\n\n  // Add layer with default styling\n  this.map.addLayer({\n    id: name,\n    type: layerType,\n    source: sourceId,\n    paint: this.getDefaultPaint(layerType),\n  });\n}\n</code></pre>"},{"location":"typescript/examples/maplibre/#controls","title":"Controls","text":"<pre><code>// Add navigation, scale, or draw controls\nprivate handleAddControl(args: unknown[], kwargs: Record&lt;string, unknown&gt;): void {\n  const [controlType] = args as [string];\n  const position = kwargs.position as string || 'top-right';\n\n  let control: maplibregl.IControl;\n  switch (controlType) {\n    case 'navigation':\n      control = new maplibregl.NavigationControl();\n      break;\n    case 'scale':\n      control = new maplibregl.ScaleControl();\n      break;\n    case 'fullscreen':\n      control = new maplibregl.FullscreenControl();\n      break;\n  }\n\n  this.map.addControl(control, position);\n}\n</code></pre>"},{"location":"typescript/examples/maplibre/#draw-control","title":"Draw Control","text":"<pre><code>private handleAddDrawControl(args: unknown[], kwargs: Record&lt;string, unknown&gt;): void {\n  const position = kwargs.position as string || 'top-right';\n\n  this.geoEditorPlugin = new GeoEditorPlugin(this.map);\n  this.geoEditorPlugin.initialize({\n    position,\n    drawModes: kwargs.drawModes as string[],\n  }, (data: FeatureCollection) =&gt; {\n    // Sync drawn features to Python\n    this.model.set('_draw_data', data);\n    this.model.save_changes();\n  });\n}\n\n// Get drawn features\nprivate handleGetDrawData(): void {\n  const data = this.geoEditorPlugin.getFeatures();\n  this.model.set('_draw_data', data);\n  this.model.save_changes();\n}\n</code></pre>"},{"location":"typescript/examples/maplibre/#event-handling","title":"Event Handling","text":"<pre><code>private setupMapEvents(): void {\n  // Click event\n  this.map.on('click', (e) =&gt; {\n    this.sendEvent('click', {\n      lngLat: [e.lngLat.lng, e.lngLat.lat],\n      point: [e.point.x, e.point.y],\n    });\n  });\n\n  // Move end event\n  this.map.on('moveend', () =&gt; {\n    const center = this.map.getCenter();\n    this.model.set('current_center', [center.lng, center.lat]);\n    this.model.set('current_zoom', this.map.getZoom());\n    this.model.save_changes();\n  });\n}\n</code></pre>"},{"location":"typescript/examples/maplibre/#source-files","title":"Source Files","text":"<ul> <li>Renderer: <code>src/maplibre/MapLibreRenderer.ts</code></li> <li>Plugins: <code>src/maplibre/plugins/GeoEditorPlugin.ts</code>, <code>LayerControlPlugin.ts</code></li> <li>Types: <code>src/types/maplibre.ts</code></li> </ul> <p>See also: Python notebook example</p>"},{"location":"typescript/examples/openlayers/","title":"OpenLayers","text":"<p>OpenLayers is a high-performance library with excellent WMS/WMTS support and projection handling.</p>"},{"location":"typescript/examples/openlayers/#python-example","title":"Python Example","text":"<pre><code>from anymap_ts import OpenLayersMap\n\nm = OpenLayersMap(center=[-122.4, 37.8], zoom=10)\nm.add_basemap(\"OpenStreetMap\")\nm.add_geojson(geojson, name=\"cities\", style={\"fillColor\": \"rgba(255, 0, 0, 0.8)\", \"strokeColor\": \"#ffffff\", \"radius\": 8})\nm.add_marker(-122.4194, 37.7749, color=\"#ff0000\")\nm.fly_to(-122.4194, 37.7749, zoom=14)\nm\n</code></pre>"},{"location":"typescript/examples/openlayers/#typescript-implementation","title":"TypeScript Implementation","text":"<p>The <code>OpenLayersRenderer</code> wraps the OpenLayers API:</p> <pre><code>import Map from 'ol/Map';\nimport View from 'ol/View';\nimport TileLayer from 'ol/layer/Tile';\nimport VectorLayer from 'ol/layer/Vector';\nimport VectorSource from 'ol/source/Vector';\nimport OSM from 'ol/source/OSM';\nimport XYZ from 'ol/source/XYZ';\nimport GeoJSON from 'ol/format/GeoJSON';\nimport { fromLonLat, toLonLat } from 'ol/proj';\n\nexport class OpenLayersRenderer extends BaseMapRenderer&lt;Map&gt; {\n  private layersMap: Map&lt;string, Layer&gt; = new Map();\n\n  protected createMap(): Map {\n    const center = this.model.get('center') as [number, number];\n    const zoom = this.model.get('zoom');\n\n    return new Map({\n      target: this.mapContainer!,\n      view: new View({\n        center: fromLonLat(center), // Convert to EPSG:3857\n        zoom,\n      }),\n    });\n  }\n}\n</code></pre>"},{"location":"typescript/examples/openlayers/#key-methods","title":"Key Methods","text":""},{"location":"typescript/examples/openlayers/#adding-geojson","title":"Adding GeoJSON","text":"<pre><code>private handleAddGeoJSON(args: unknown[], kwargs: Record&lt;string, unknown&gt;): void {\n  const geojson = kwargs.data as FeatureCollection;\n  const name = kwargs.name as string;\n  const style = kwargs.style as Record&lt;string, unknown&gt;;\n\n  // Parse GeoJSON\n  const features = new GeoJSON().readFeatures(geojson, {\n    featureProjection: 'EPSG:3857', // Reproject to map projection\n  });\n\n  // Create vector source and layer\n  const source = new VectorSource({ features });\n  const layer = new VectorLayer({\n    source,\n    style: this.createStyle(style),\n  });\n\n  this.map.addLayer(layer);\n  this.layersMap.set(name, layer);\n\n  // Fit to extent\n  if (kwargs.fitBounds !== false) {\n    this.map.getView().fit(source.getExtent(), { padding: [50, 50, 50, 50] });\n  }\n}\n</code></pre>"},{"location":"typescript/examples/openlayers/#styling","title":"Styling","text":"<pre><code>private createStyle(options?: Record&lt;string, unknown&gt;): Style {\n  return new Style({\n    fill: new Fill({\n      color: options?.fillColor || 'rgba(51, 136, 255, 0.5)',\n    }),\n    stroke: new Stroke({\n      color: options?.strokeColor || '#3388ff',\n      width: options?.strokeWidth || 2,\n    }),\n    image: new Circle({\n      radius: options?.radius || 8,\n      fill: new Fill({ color: options?.fillColor || '#3388ff' }),\n      stroke: new Stroke({ color: options?.strokeColor || '#ffffff', width: 2 }),\n    }),\n  });\n}\n</code></pre>"},{"location":"typescript/examples/openlayers/#navigation","title":"Navigation","text":"<pre><code>private handleFlyTo(args: unknown[], kwargs: Record&lt;string, unknown&gt;): void {\n  const [lng, lat] = args as [number, number];\n  const zoom = kwargs.zoom as number;\n  const duration = kwargs.duration as number || 2000;\n\n  this.map.getView().animate({\n    center: fromLonLat([lng, lat]),\n    zoom: zoom || this.map.getView().getZoom(),\n    duration,\n  });\n}\n</code></pre>"},{"location":"typescript/examples/openlayers/#markers","title":"Markers","text":"<pre><code>private handleAddMarker(args: unknown[], kwargs: Record&lt;string, unknown&gt;): void {\n  const [lng, lat] = args as [number, number];\n  const id = kwargs.id as string || `marker-${Date.now()}`;\n  const color = kwargs.color as string || '#3388ff';\n\n  const feature = new Feature({\n    geometry: new Point(fromLonLat([lng, lat])),\n  });\n\n  feature.setStyle(new Style({\n    image: new Circle({\n      radius: 8,\n      fill: new Fill({ color }),\n      stroke: new Stroke({ color: '#ffffff', width: 2 }),\n    }),\n  }));\n\n  const source = new VectorSource({ features: [feature] });\n  const layer = new VectorLayer({ source });\n\n  this.map.addLayer(layer);\n  this.markersMap.set(id, layer);\n}\n</code></pre>"},{"location":"typescript/examples/openlayers/#wms-layers","title":"WMS Layers","text":"<pre><code>private handleAddWMSLayer(args: unknown[], kwargs: Record&lt;string, unknown&gt;): void {\n  const url = kwargs.url as string;\n  const layers = kwargs.layers as string;\n  const name = kwargs.name as string;\n\n  const layer = new TileLayer({\n    source: new TileWMS({\n      url,\n      params: {\n        LAYERS: layers,\n        TILED: true,\n      },\n    }),\n  });\n\n  this.map.addLayer(layer);\n  this.layersMap.set(name, layer);\n}\n</code></pre>"},{"location":"typescript/examples/openlayers/#coordinate-system","title":"Coordinate System","text":"<p>OpenLayers uses EPSG:3857 (Web Mercator) internally. Convert coordinates:</p> <pre><code>import { fromLonLat, toLonLat } from 'ol/proj';\n\n// To OpenLayers (EPSG:4326 -&gt; EPSG:3857)\nconst olCoord = fromLonLat([-122.4, 37.8]);\n\n// From OpenLayers (EPSG:3857 -&gt; EPSG:4326)\nconst lngLat = toLonLat(olCoord);\n</code></pre>"},{"location":"typescript/examples/openlayers/#source-files","title":"Source Files","text":"<ul> <li>Renderer: <code>src/openlayers/OpenLayersRenderer.ts</code></li> <li>Types: <code>src/types/openlayers.ts</code></li> </ul> <p>See also: Python notebook example</p>"},{"location":"typescript/examples/pointcloud_layer/","title":"Point Cloud Layer","text":"<p>The DeckGL PointCloudLayer renders 3D point cloud data, ideal for visualizing LiDAR scans, 3D models, and elevation data.</p>"},{"location":"typescript/examples/pointcloud_layer/#python-example","title":"Python Example","text":"<pre><code>import random\nfrom anymap_ts import MapLibreMap\n\n# Generate sample 3D point cloud\npoints = [\n    {\n        \"position\": [-122.4 + random.uniform(-0.01, 0.01),\n                     37.8 + random.uniform(-0.01, 0.01),\n                     random.uniform(0, 500)],\n        \"color\": [255, int(random.uniform(0, 255)), 0, 255]\n    }\n    for _ in range(1000)\n]\n\nm = MapLibreMap(center=[-122.4, 37.8], zoom=14, pitch=60)\nm.add_basemap(\"CartoDB.DarkMatter\")\nm.add_point_cloud_layer(\n    data=points,\n    name=\"lidar-scan\",\n    get_position=\"position\",\n    get_color=\"color\",\n    point_size=3,\n    opacity=0.9,\n)\nm\n</code></pre>"},{"location":"typescript/examples/pointcloud_layer/#typescript-implementation","title":"TypeScript Implementation","text":"<p>The <code>handleAddPointCloudLayer</code> method creates deck.gl PointCloudLayer instances:</p> <pre><code>import { PointCloudLayer } from '@deck.gl/layers';\n\nprivate handleAddPointCloudLayer(args: unknown[], kwargs: Record&lt;string, unknown&gt;): void {\n  this.initializeDeckOverlay();\n  const id = kwargs.id as string || `pointcloud-${Date.now()}`;\n  const data = kwargs.data as unknown[];\n\n  const layer = new PointCloudLayer({\n    id,\n    data,\n    pickable: kwargs.pickable !== false,\n    opacity: kwargs.opacity as number ?? 1,\n    pointSize: kwargs.pointSize as number ?? 2,\n    sizeUnits: kwargs.sizeUnits as string ?? 'pixels',\n    getPosition: (d: any) =&gt; d[kwargs.getPosition as string] || d.position,\n    getNormal: kwargs.getNormal ?? [0, 0, 1],\n    getColor: (d: any) =&gt; {\n      const accessor = kwargs.getColor;\n      if (Array.isArray(accessor)) return accessor;\n      if (typeof accessor === 'string') return d[accessor] || [255, 255, 255, 255];\n      return [255, 255, 255, 255];\n    },\n    coordinateSystem: kwargs.coordinateSystem,\n    coordinateOrigin: kwargs.coordinateOrigin,\n  });\n\n  this.deckLayers.set(id, layer);\n  this.updateDeckOverlay();\n  this.deckLayerAdapter?.notifyLayerAdded(id);\n}\n</code></pre>"},{"location":"typescript/examples/pointcloud_layer/#layer-control-integration","title":"Layer Control Integration","text":"<p>Point cloud layers integrate with the layer control via <code>DeckLayerAdapter</code>:</p> <pre><code>// Layer IDs starting with 'pointcloud-' are managed by DeckLayerAdapter\ngetLayerIds(): string[] {\n  return Array.from(this.deckLayers.keys()).filter(id =&gt;\n    id.startsWith('arc-') || id.startsWith('pointcloud-')\n  );\n}\n\n// Adjust opacity by cloning the immutable deck.gl layer\nsetOpacity(layerId: string, opacity: number): void {\n  const layer = this.deckLayers.get(layerId);\n  if (layer &amp;&amp; typeof layer.clone === 'function') {\n    const updated = layer.clone({ opacity });\n    this.deckLayers.set(layerId, updated);\n    this.updateOverlay();\n  }\n}\n</code></pre>"},{"location":"typescript/examples/pointcloud_layer/#api-reference","title":"API Reference","text":""},{"location":"typescript/examples/pointcloud_layer/#parameters","title":"Parameters","text":"Parameter Type Default Description <code>data</code> <code>Array</code> required Array of point data objects <code>name</code> <code>string</code> auto-generated Layer identifier <code>get_position</code> <code>string</code> <code>\"position\"</code> Accessor for [x, y, z] position <code>get_color</code> <code>Array&lt;int&gt;</code> or <code>string</code> <code>[255, 255, 255, 255]</code> RGBA color or accessor <code>get_normal</code> <code>string</code> <code>[0, 0, 1]</code> Normal vector for lighting <code>point_size</code> <code>number</code> <code>2</code> Point size in size_units <code>size_units</code> <code>string</code> <code>\"pixels\"</code> <code>\"pixels\"</code> or <code>\"meters\"</code> <code>coordinate_system</code> <code>string</code> auto Coordinate system type <code>coordinate_origin</code> <code>Array</code> none Origin for offset coordinates <code>pickable</code> <code>bool</code> <code>true</code> Enable hover/click <code>opacity</code> <code>float</code> <code>1.0</code> Layer opacity"},{"location":"typescript/examples/pointcloud_layer/#data-format","title":"Data Format","text":"<p>Each point object should have position coordinates:</p> <pre><code>{\n  position: [x, y, z],  // [longitude, latitude, altitude] or [x, y, z]\n  color: [r, g, b, a],  // Optional RGBA color\n  normal: [nx, ny, nz]  // Optional normal vector\n}\n</code></pre>"},{"location":"typescript/examples/pointcloud_layer/#coordinate-systems","title":"Coordinate Systems","text":"<p>The <code>coordinate_system</code> parameter supports:</p> <ul> <li><code>CARTESIAN</code> - Local cartesian coordinates</li> <li><code>METER_OFFSETS</code> - Meter offsets from origin</li> <li><code>LNGLAT</code> - WGS84 longitude/latitude (default)</li> <li><code>LNGLAT_OFFSETS</code> - Lng/lat offsets from origin</li> </ul>"},{"location":"typescript/examples/pointcloud_layer/#source-files","title":"Source Files","text":"<ul> <li>MapLibre Handler: <code>src/maplibre/MapLibreRenderer.ts</code></li> <li>Mapbox Handler: <code>src/mapbox/MapboxRenderer.ts</code></li> <li>DeckGL Handler: <code>src/deckgl/DeckGLRenderer.ts</code></li> <li>Layer Adapter: <code>src/maplibre/adapters/DeckLayerAdapter.ts</code></li> </ul> <p>See also: Python notebook example</p>"},{"location":"typescript/examples/potree/","title":"Potree","text":"<p>Potree is a WebGL-based point cloud viewer for large-scale LiDAR datasets.</p>"},{"location":"typescript/examples/potree/#python-example","title":"Python Example","text":"<pre><code>from anymap_ts import PotreeViewer\n\nviewer = PotreeViewer(\n    point_budget=1000000,\n    point_size=1.0,\n    background=\"#1a1a2e\",\n    edl_enabled=True\n)\n\n# Adjust settings\nviewer.set_point_budget(2000000)\nviewer.set_point_size(1.5)\nviewer.set_edl(enabled=True, radius=1.8, strength=0.5)\n\n# Set camera\nviewer.set_camera_position(0, 0, 100)\nviewer.set_camera_target(0, 0, 0)\n\n# Add annotation\nviewer.add_annotation(position=(10, 20, 30), title=\"Point of Interest\", description=\"Important location\")\n\nviewer\n</code></pre>"},{"location":"typescript/examples/potree/#typescript-implementation","title":"TypeScript Implementation","text":"<p>Potree is loaded dynamically from CDN:</p> <pre><code>const POTREE_VERSION = '1.8.2';\nconst POTREE_BASE_URL = `https://unpkg.com/potree-core@${POTREE_VERSION}/build`;\n\nclass PotreeWidget {\n  private viewer: any = null;\n  private pointClouds: Map&lt;string, any&gt; = new Map();\n  private annotations: Map&lt;string, any&gt; = new Map();\n\n  async initialize(): Promise&lt;void&gt; {\n    await loadPotree();\n\n    const Potree = window.Potree;\n\n    // Create viewer\n    this.viewer = new Potree.Viewer(this.container);\n\n    // Configure settings\n    this.viewer.setPointBudget(this.model.get('point_budget') || 1000000);\n    this.viewer.setBackground(this.model.get('background') || '#1a1a2e');\n    this.viewer.setEDLEnabled(this.model.get('edl_enabled') !== false);\n\n    // Set initial camera position\n    const position = this.model.get('camera_position') || [0, 0, 100];\n    const target = this.model.get('camera_target') || [0, 0, 0];\n    this.viewer.scene.view.position.set(...position);\n    this.viewer.scene.view.lookAt(new Potree.Vector3(...target));\n  }\n}\n</code></pre>"},{"location":"typescript/examples/potree/#key-methods","title":"Key Methods","text":""},{"location":"typescript/examples/potree/#loading-point-clouds","title":"Loading Point Clouds","text":"<pre><code>async handle_loadPointCloud(args: unknown[], kwargs: Record&lt;string, unknown&gt;): Promise&lt;void&gt; {\n  const Potree = window.Potree;\n  const url = kwargs.url as string;\n  const name = kwargs.name as string;\n\n  const pointCloud = await Potree.loadPointCloud(url, name);\n\n  // Configure appearance\n  pointCloud.material.size = kwargs.pointSize as number || 1.0;\n  pointCloud.material.pointSizeType = kwargs.pointSizeType || Potree.PointSizeType.ADAPTIVE;\n  pointCloud.material.shape = kwargs.shape || Potree.PointShape.CIRCLE;\n\n  this.viewer.scene.addPointCloud(pointCloud);\n  this.pointClouds.set(name, pointCloud);\n\n  // Fit to point cloud bounds\n  this.viewer.fitToScreen();\n}\n</code></pre>"},{"location":"typescript/examples/potree/#visualization-settings","title":"Visualization Settings","text":"<pre><code>handle_setPointBudget(args: unknown[], kwargs: Record&lt;string, unknown&gt;): void {\n  const budget = args[0] as number;\n  this.viewer.setPointBudget(budget);\n}\n\nhandle_setPointSize(args: unknown[], kwargs: Record&lt;string, unknown&gt;): void {\n  const size = args[0] as number;\n  this.pointClouds.forEach((pc) =&gt; {\n    pc.material.size = size;\n  });\n}\n\nhandle_setEDL(args: unknown[], kwargs: Record&lt;string, unknown&gt;): void {\n  const enabled = kwargs.enabled as boolean ?? true;\n  const radius = kwargs.radius as number ?? 1.4;\n  const strength = kwargs.strength as number ?? 0.4;\n\n  this.viewer.setEDLEnabled(enabled);\n  this.viewer.setEDLRadius(radius);\n  this.viewer.setEDLStrength(strength);\n}\n\nhandle_setBackground(args: unknown[], kwargs: Record&lt;string, unknown&gt;): void {\n  const color = args[0] as string;\n  this.viewer.setBackground(color);\n}\n</code></pre>"},{"location":"typescript/examples/potree/#camera-control","title":"Camera Control","text":"<pre><code>handle_setCameraPosition(args: unknown[], kwargs: Record&lt;string, unknown&gt;): void {\n  const [x, y, z] = args as [number, number, number];\n  this.viewer.scene.view.position.set(x, y, z);\n}\n\nhandle_setCameraTarget(args: unknown[], kwargs: Record&lt;string, unknown&gt;): void {\n  const [x, y, z] = args as [number, number, number];\n  const Potree = window.Potree;\n  this.viewer.scene.view.lookAt(new Potree.Vector3(x, y, z));\n}\n</code></pre>"},{"location":"typescript/examples/potree/#annotations","title":"Annotations","text":"<pre><code>handle_addAnnotation(args: unknown[], kwargs: Record&lt;string, unknown&gt;): void {\n  const Potree = window.Potree;\n  const position = kwargs.position as [number, number, number];\n  const title = kwargs.title as string;\n  const description = kwargs.description as string;\n\n  const annotation = new Potree.Annotation({\n    position: new Potree.Vector3(...position),\n    title,\n    description,\n  });\n\n  this.viewer.scene.annotations.add(annotation);\n  this.annotations.set(title, annotation);\n}\n</code></pre>"},{"location":"typescript/examples/potree/#measurement-tools","title":"Measurement Tools","text":"<pre><code>handle_addMeasurementTool(args: unknown[], kwargs: Record&lt;string, unknown&gt;): void {\n  const Potree = window.Potree;\n  const type = args[0] as string;\n\n  let tool;\n  switch (type) {\n    case 'distance':\n      tool = new Potree.MeasuringTool(this.viewer);\n      break;\n    case 'area':\n      tool = new Potree.AreaTool(this.viewer);\n      break;\n    case 'volume':\n      tool = new Potree.VolumeTool(this.viewer);\n      break;\n    case 'height':\n      tool = new Potree.HeightTool(this.viewer);\n      break;\n  }\n\n  if (tool) {\n    tool.startInsertion();\n  }\n}\n</code></pre>"},{"location":"typescript/examples/potree/#eye-dome-lighting-edl","title":"Eye Dome Lighting (EDL)","text":"<p>EDL enhances depth perception in point clouds:</p> <pre><code>// Enable EDL with custom settings\nthis.viewer.setEDLEnabled(true);\nthis.viewer.setEDLRadius(1.8);    // Light radius\nthis.viewer.setEDLStrength(0.5);  // Effect strength\n</code></pre>"},{"location":"typescript/examples/potree/#source-files","title":"Source Files","text":"<ul> <li>Widget: <code>src/potree/index.ts</code></li> <li>Types: <code>src/types/potree.ts</code></li> </ul> <p>See also: Python notebook example</p>"},{"location":"typescript/examples/zarr_layer/","title":"Zarr Layer","text":"<p>Zarr layers enable visualization of multi-dimensional scientific datasets with GPU acceleration.</p>"},{"location":"typescript/examples/zarr_layer/#python-example","title":"Python Example","text":"<pre><code>from anymap_ts import Map\n\nZARR_URL = \"https://carbonplan-maps.s3.us-west-2.amazonaws.com/v2/demo/4d/tavg-prec-month\"\n\nm = Map(center=[-100, 40], zoom=3, style=\"dark-matter\")\n\nm.add_zarr_layer(\n    url=ZARR_URL,\n    variable=\"climate\",\n    name=\"climate-prec\",\n    clim=(0, 300),\n    colormap=[\"#f7fbff\", \"#deebf7\", \"#c6dbef\", \"#9ecae1\", \"#6baed6\", \"#4292c6\", \"#2171b5\", \"#08519c\", \"#08306b\"],\n    opacity=0.8,\n    selector={\"band\": \"prec\", \"month\": 1},\n    spatial_dimensions={\"lat\": \"y\", \"lon\": \"x\"},\n    zarr_version=2,\n)\nm\n</code></pre>"},{"location":"typescript/examples/zarr_layer/#typescript-implementation","title":"TypeScript Implementation","text":"<p>Zarr layers use the <code>@carbonplan/zarr-layer</code> package:</p> <pre><code>import { ZarrLayer } from '@carbonplan/zarr-layer';\n\nprivate handleAddZarrLayer(args: unknown[], kwargs: Record&lt;string, unknown&gt;): void {\n  const id = kwargs.id as string || `zarr-${Date.now()}`;\n  const source = kwargs.source as string;\n  const variable = kwargs.variable as string;\n\n  const layer = new ZarrLayer({\n    id,\n    source,\n    variable,\n    clim: kwargs.clim as [number, number] || [0, 100],\n    colormap: kwargs.colormap as string[] || ['#000000', '#ffffff'],\n    selector: kwargs.selector as Record&lt;string, unknown&gt; || {},\n    opacity: kwargs.opacity as number ?? 1,\n    minzoom: kwargs.minzoom as number,\n    maxzoom: kwargs.maxzoom as number,\n    fillValue: kwargs.fillValue as number,\n    spatialDimensions: kwargs.spatialDimensions as { lat?: string; lon?: string },\n    zarrVersion: kwargs.zarrVersion as 2 | 3,\n    bounds: kwargs.bounds as [number, number, number, number],\n  });\n\n  this.map.addLayer(layer as unknown as maplibregl.CustomLayerInterface);\n  this.zarrLayers.set(id, layer);\n}\n</code></pre>"},{"location":"typescript/examples/zarr_layer/#updating-zarr-layer","title":"Updating Zarr Layer","text":"<pre><code>private handleUpdateZarrLayer(args: unknown[], kwargs: Record&lt;string, unknown&gt;): void {\n  const id = kwargs.id as string;\n  const layer = this.zarrLayers.get(id);\n  if (!layer) return;\n\n  // Update properties dynamically\n  if (kwargs.selector) layer.setSelector(kwargs.selector as Record&lt;string, number&gt;);\n  if (kwargs.clim) layer.setClim(kwargs.clim as [number, number]);\n  if (kwargs.colormap) layer.setColormap(kwargs.colormap as string[]);\n  if (kwargs.opacity !== undefined) layer.setOpacity(kwargs.opacity as number);\n}\n</code></pre>"},{"location":"typescript/examples/zarr_layer/#removing-zarr-layer","title":"Removing Zarr Layer","text":"<pre><code>private handleRemoveZarrLayer(args: unknown[], kwargs: Record&lt;string, unknown&gt;): void {\n  const [id] = args as [string];\n\n  if (this.map &amp;&amp; this.map.getLayer(id)) {\n    this.map.removeLayer(id);\n  }\n  this.zarrLayers.delete(id);\n}\n</code></pre>"},{"location":"typescript/examples/zarr_layer/#configuration-options","title":"Configuration Options","text":"Parameter Type Default Description <code>source</code> string required URL to the Zarr store <code>variable</code> string required Variable name in the Zarr dataset <code>id</code> string auto Layer identifier <code>colormap</code> string[] <code>['#000000', '#ffffff']</code> Hex color strings for visualization <code>clim</code> [number, number] <code>[0, 100]</code> Color scale limits (min, max) <code>opacity</code> number 1.0 Layer opacity (0-1) <code>selector</code> object <code>{}</code> Dimension selector (e.g., <code>{month: 4, band: \"tavg\"}</code>) <code>minzoom</code> number 0 Minimum zoom level for rendering <code>maxzoom</code> number 22 Maximum zoom level for rendering <code>fillValue</code> number auto No-data value <code>spatialDimensions</code> object auto Custom spatial dimension names <code>zarrVersion</code> number auto Zarr format version (2 or 3) <code>bounds</code> [number, number, number, number] auto Explicit bounds [west, south, east, north]"},{"location":"typescript/examples/zarr_layer/#dynamic-updates","title":"Dynamic Updates","text":"<p>Zarr layers support dynamic updates without recreating the layer:</p> <pre><code># Update selector (e.g., change month)\nm.update_zarr_layer(\n    layer_id=\"climate-prec\",\n    selector={\"band\": \"prec\", \"month\": 7},\n)\n\n# Update colormap and clim\nm.update_zarr_layer(\n    layer_id=\"climate-prec\",\n    selector={\"band\": \"tavg\", \"month\": 7},\n    clim=(-20, 30),\n    colormap=[\"#313695\", \"#4575b4\", \"#74add1\", \"#abd9e9\", \"#e0f3f8\", \"#ffffbf\", \"#fee090\", \"#fdae61\", \"#f46d43\", \"#d73027\", \"#a50026\"],\n)\n</code></pre>"},{"location":"typescript/examples/zarr_layer/#colormaps","title":"Colormaps","text":"<p>Common colormaps as hex arrays:</p> <pre><code>const colormaps = {\n  // Blues (precipitation)\n  blues: ['#f7fbff', '#deebf7', '#c6dbef', '#9ecae1', '#6baed6', '#4292c6', '#2171b5', '#08519c', '#08306b'],\n\n  // RdYlBu (temperature)\n  rdylbu: ['#313695', '#4575b4', '#74add1', '#abd9e9', '#e0f3f8', '#ffffbf', '#fee090', '#fdae61', '#f46d43', '#d73027', '#a50026'],\n\n  // Inferno (general)\n  inferno: ['#000004', '#1b0c41', '#4a0c6b', '#781c6d', '#a52c60', '#cf4446', '#ed6925', '#fb9b06', '#f7d13d', '#fcffa4'],\n};\n</code></pre>"},{"location":"typescript/examples/zarr_layer/#sample-datasets","title":"Sample Datasets","text":"Dataset URL Variable Description 4D Climate <code>carbonplan-maps.s3.../v2/demo/4d/tavg-prec-month</code> climate Temp/precip by month Ocean Temp <code>atlantis-vis-o.s3-ext.../tos_con</code> tos_con v3 pyramid, EPSG:3857 Burn Prob <code>carbonplan-share.s3.../13-lvl-30m-4326-scott-BP.zarr</code> BP 30m resolution CONUS"},{"location":"typescript/examples/zarr_layer/#source-files","title":"Source Files","text":"<ul> <li>MapLibre Implementation: <code>src/maplibre/MapLibreRenderer.ts</code></li> <li>Layer Adapter: <code>src/maplibre/adapters/ZarrLayerAdapter.ts</code></li> </ul> <p>See also: Python notebook example</p>"}]}