import{N as g,C as d}from"./mapbox-overlay-CtMyNbGZ.js";function w(n){let c=1/0,A=1/0,T=1/0,r=-1/0,f=-1/0,i=-1/0;const s=n.POSITION?n.POSITION.value:[],I=s&&s.length;for(let l=0;l<I;l+=3){const M=s[l],a=s[l+1],y=s[l+2];c=M<c?M:c,A=a<A?a:A,T=y<T?y:T,r=M>r?M:r,f=a>f?a:f,i=y>i?y:i}return[[c,A,T],[r,f,i]]}const p=Math.PI/180,E=new Float32Array(16),S=new Float32Array(12);function z(n,c,A){const T=c[0]*p,r=c[1]*p,f=c[2]*p,i=Math.sin(f),s=Math.sin(T),I=Math.sin(r),l=Math.cos(f),M=Math.cos(T),a=Math.cos(r),y=A[0],h=A[1],e=A[2];n[0]=y*a*M,n[1]=y*I*M,n[2]=y*-s,n[3]=h*(-I*l+a*s*i),n[4]=h*(a*l+I*s*i),n[5]=h*M*i,n[6]=e*(I*i+a*s*l),n[7]=e*(-a*i+I*s*l),n[8]=e*M*l}function C(n){return n[0]=n[0],n[1]=n[1],n[2]=n[2],n[3]=n[4],n[4]=n[5],n[5]=n[6],n[6]=n[8],n[7]=n[9],n[8]=n[10],n[9]=n[12],n[10]=n[13],n[11]=n[14],n.subarray(0,12)}const D={size:12,accessor:["getOrientation","getScale","getTranslation","getTransformMatrix"],shaderAttributes:{instanceModelMatrixCol0:{size:3,elementOffset:0},instanceModelMatrixCol1:{size:3,elementOffset:3},instanceModelMatrixCol2:{size:3,elementOffset:6},instanceTranslation:{size:3,elementOffset:9}},update(n,{startRow:c,endRow:A}){const{data:T,getOrientation:r,getScale:f,getTranslation:i,getTransformMatrix:s}=this.props,I=Array.isArray(s),l=I&&s.length===16,M=Array.isArray(f),a=Array.isArray(r),y=Array.isArray(i),h=l||!I&&!!s(T[0]);h?n.constant=l:n.constant=a&&M&&y;const e=n.value;if(n.constant){let o;h?(E.set(s),o=C(E)):(o=S,z(o,r,f),o.set(i,9)),n.value=new Float32Array(o)}else{let o=c*n.size;const{iterable:u,objectInfo:x}=g(T,c,A);for(const O of u){x.index++;let t;if(h)E.set(l?s:s(O,x)),t=C(E);else{t=S;const F=a?r:r(O,x),R=M?f:f(O,x);z(t,F,R),t.set(y?i:i(O,x),9)}e[o++]=t[0],e[o++]=t[1],e[o++]=t[2],e[o++]=t[3],e[o++]=t[4],e[o++]=t[5],e[o++]=t[6],e[o++]=t[7],e[o++]=t[8],e[o++]=t[9],e[o++]=t[10],e[o++]=t[11]}}}};function _(n,c){return c===d.CARTESIAN||c===d.METER_OFFSETS||c===d.DEFAULT&&!n.isGeospatial}export{D as M,w as g,_ as s};
