import{a3 as et,a4 as r,a5 as st,a6 as z,a0 as W}from"./mapbox-overlay-CjL5nCza.js";import{M as w,Q as F}from"./quaternion-CNi4xXkd.js";const nt="Queued Requests",at="Active Requests",rt="Cancelled Requests",ot="Queued Requests Ever",ct="Active Requests Ever",it={id:"request-scheduler",throttleRequests:!0,maxRequests:6,debounceTime:0};class bt{props;stats;activeRequestCount=0;requestQueue=[];requestMap=new Map;updateTimer=null;constructor(t={}){this.props={...it,...t},this.stats=new et({id:this.props.id}),this.stats.get(nt),this.stats.get(at),this.stats.get(rt),this.stats.get(ot),this.stats.get(ct)}scheduleRequest(t,e=()=>0){if(!this.props.throttleRequests)return Promise.resolve({done:()=>{}});if(this.requestMap.has(t))return this.requestMap.get(t);const n={handle:t,priority:0,getPriority:e},a=new Promise(s=>(n.resolve=s,n));return this.requestQueue.push(n),this.requestMap.set(t,a),this._issueNewRequests(),a}_issueRequest(t){const{handle:e,resolve:n}=t;let a=!1;const s=()=>{a||(a=!0,this.requestMap.delete(e),this.activeRequestCount--,this._issueNewRequests())};return this.activeRequestCount++,n?n({done:s}):Promise.resolve({done:s})}_issueNewRequests(){this.updateTimer!==null&&clearTimeout(this.updateTimer),this.updateTimer=setTimeout(()=>this._issueNewRequestsAsync(),this.props.debounceTime)}_issueNewRequestsAsync(){this.updateTimer!==null&&clearTimeout(this.updateTimer),this.updateTimer=null;const t=Math.max(this.props.maxRequests-this.activeRequestCount,0);if(t!==0){this._updateAllRequests();for(let e=0;e<t;++e){const n=this.requestQueue.shift();n&&this._issueRequest(n)}}}_updateAllRequests(){const t=this.requestQueue;for(let e=0;e<t.length;++e){const n=t[e];this._updateRequest(n)||(t.splice(e,1),this.requestMap.delete(n.handle),e--)}t.sort((e,n)=>e.priority-n.priority)}_updateRequest(t){return t.priority=t.getPriority(t.handle),t.priority<0?(t.resolve(null),!1):!0}}const Ut=.1,Pt=1e-12,ut=1e-15,lt=1e-20,p={OUTSIDE:-1,INTERSECTING:0,INSIDE:1},K=new r,ht=new r;class J{constructor(t=[0,0,0],e=[0,0,0],n){n=n||K.copy(t).add(e).scale(.5),this.center=new r(n),this.halfDiagonal=new r(e).subtract(this.center),this.minimum=new r(t),this.maximum=new r(e)}clone(){return new J(this.minimum,this.maximum,this.center)}equals(t){return this===t||!!t&&this.minimum.equals(t.minimum)&&this.maximum.equals(t.maximum)}transform(t){return this.center.transformAsPoint(t),this.halfDiagonal.transform(t),this.minimum.transform(t),this.maximum.transform(t),this}intersectPlane(t){const{halfDiagonal:e}=this,n=ht.from(t.normal),a=e.x*Math.abs(n.x)+e.y*Math.abs(n.y)+e.z*Math.abs(n.z),s=this.center.dot(n)+t.distance;return s-a>0?p.INSIDE:s+a<0?p.OUTSIDE:p.INTERSECTING}distanceTo(t){return Math.sqrt(this.distanceSquaredTo(t))}distanceSquaredTo(t){const e=K.from(t).subtract(this.center),{halfDiagonal:n}=this;let a=0,s;return s=Math.abs(e.x)-n.x,s>0&&(a+=s*s),s=Math.abs(e.y)-n.y,s>0&&(a+=s*s),s=Math.abs(e.z)-n.z,s>0&&(a+=s*s),a}}const g=new r,Y=new r;class G{constructor(t=[0,0,0],e=0){this.radius=-0,this.center=new r,this.fromCenterRadius(t,e)}fromCenterRadius(t,e){return this.center.from(t),this.radius=e,this}fromCornerPoints(t,e){return e=g.from(e),this.center=new r().from(t).add(e).scale(.5),this.radius=this.center.distance(e),this}equals(t){return this===t||!!t&&this.center.equals(t.center)&&this.radius===t.radius}clone(){return new G(this.center,this.radius)}union(t){const e=this.center,n=this.radius,a=t.center,s=t.radius,o=g.copy(a).subtract(e),i=o.magnitude();if(n>=i+s)return this.clone();if(s>=i+n)return t.clone();const l=(n+i+s)*.5;return Y.copy(o).scale((-n+l)/i).add(e),this.center.copy(Y),this.radius=l,this}expand(t){const n=g.from(t).subtract(this.center).magnitude();return n>this.radius&&(this.radius=n),this}transform(t){this.center.transform(t);const e=st(g,t);return this.radius=Math.max(e[0],Math.max(e[1],e[2]))*this.radius,this}distanceSquaredTo(t){const e=this.distanceTo(t);return e*e}distanceTo(t){const n=g.from(t).subtract(this.center);return Math.max(0,n.len()-this.radius)}intersectPlane(t){const e=this.center,n=this.radius,s=t.normal.dot(e)+t.distance;return s<-n?p.OUTSIDE:s<n?p.INTERSECTING:p.INSIDE}}const mt=new r,dt=new r,P=new r,D=new r,L=new r,ft=new r,pt=new r,M={COLUMN0ROW0:0,COLUMN0ROW1:1,COLUMN0ROW2:2,COLUMN1ROW0:3,COLUMN1ROW1:4,COLUMN1ROW2:5,COLUMN2ROW0:6,COLUMN2ROW1:7,COLUMN2ROW2:8};class X{constructor(t=[0,0,0],e=[0,0,0,0,0,0,0,0,0]){this.center=new r().from(t),this.halfAxes=new w(e)}get halfSize(){const t=this.halfAxes.getColumn(0),e=this.halfAxes.getColumn(1),n=this.halfAxes.getColumn(2);return[new r(t).len(),new r(e).len(),new r(n).len()]}get quaternion(){const t=this.halfAxes.getColumn(0),e=this.halfAxes.getColumn(1),n=this.halfAxes.getColumn(2),a=new r(t).normalize(),s=new r(e).normalize(),o=new r(n).normalize();return new F().fromMatrix3(new w([...a,...s,...o]))}fromCenterHalfSizeQuaternion(t,e,n){const a=new F(n),s=new w().fromQuaternion(a);return s[0]=s[0]*e[0],s[1]=s[1]*e[0],s[2]=s[2]*e[0],s[3]=s[3]*e[1],s[4]=s[4]*e[1],s[5]=s[5]*e[1],s[6]=s[6]*e[2],s[7]=s[7]*e[2],s[8]=s[8]*e[2],this.center=new r().from(t),this.halfAxes=s,this}clone(){return new X(this.center,this.halfAxes)}equals(t){return this===t||!!t&&this.center.equals(t.center)&&this.halfAxes.equals(t.halfAxes)}getBoundingSphere(t=new G){const e=this.halfAxes,n=e.getColumn(0,P),a=e.getColumn(1,D),s=e.getColumn(2,L),o=mt.copy(n).add(a).add(s);return t.center.copy(this.center),t.radius=o.magnitude(),t}intersectPlane(t){const e=this.center,n=t.normal,a=this.halfAxes,s=n.x,o=n.y,i=n.z,l=Math.abs(s*a[M.COLUMN0ROW0]+o*a[M.COLUMN0ROW1]+i*a[M.COLUMN0ROW2])+Math.abs(s*a[M.COLUMN1ROW0]+o*a[M.COLUMN1ROW1]+i*a[M.COLUMN1ROW2])+Math.abs(s*a[M.COLUMN2ROW0]+o*a[M.COLUMN2ROW1]+i*a[M.COLUMN2ROW2]),h=n.dot(e)+t.distance;return h<=-l?p.OUTSIDE:h>=l?p.INSIDE:p.INTERSECTING}distanceTo(t){return Math.sqrt(this.distanceSquaredTo(t))}distanceSquaredTo(t){const e=dt.from(t).subtract(this.center),n=this.halfAxes,a=n.getColumn(0,P),s=n.getColumn(1,D),o=n.getColumn(2,L),i=a.magnitude(),l=s.magnitude(),h=o.magnitude();a.normalize(),s.normalize(),o.normalize();let d=0,c;return c=Math.abs(e.dot(a))-i,c>0&&(d+=c*c),c=Math.abs(e.dot(s))-l,c>0&&(d+=c*c),c=Math.abs(e.dot(o))-h,c>0&&(d+=c*c),d}computePlaneDistances(t,e,n=[-0,-0]){let a=Number.POSITIVE_INFINITY,s=Number.NEGATIVE_INFINITY;const o=this.center,i=this.halfAxes,l=i.getColumn(0,P),h=i.getColumn(1,D),d=i.getColumn(2,L),c=ft.copy(l).add(h).add(d).add(o),m=pt.copy(c).subtract(t);let u=e.dot(m);return a=Math.min(u,a),s=Math.max(u,s),c.copy(o).add(l).add(h).subtract(d),m.copy(c).subtract(t),u=e.dot(m),a=Math.min(u,a),s=Math.max(u,s),c.copy(o).add(l).subtract(h).add(d),m.copy(c).subtract(t),u=e.dot(m),a=Math.min(u,a),s=Math.max(u,s),c.copy(o).add(l).subtract(h).subtract(d),m.copy(c).subtract(t),u=e.dot(m),a=Math.min(u,a),s=Math.max(u,s),o.copy(c).subtract(l).add(h).add(d),m.copy(c).subtract(t),u=e.dot(m),a=Math.min(u,a),s=Math.max(u,s),o.copy(c).subtract(l).add(h).subtract(d),m.copy(c).subtract(t),u=e.dot(m),a=Math.min(u,a),s=Math.max(u,s),o.copy(c).subtract(l).subtract(h).add(d),m.copy(c).subtract(t),u=e.dot(m),a=Math.min(u,a),s=Math.max(u,s),o.copy(c).subtract(l).subtract(h).subtract(d),m.copy(c).subtract(t),u=e.dot(m),a=Math.min(u,a),s=Math.max(u,s),n[0]=a,n[1]=s,n}transform(t){this.center.transformAsPoint(t);const e=this.halfAxes.getColumn(0,P);e.transformAsPoint(t);const n=this.halfAxes.getColumn(1,D);n.transformAsPoint(t);const a=this.halfAxes.getColumn(2,L);return a.transformAsPoint(t),this.halfAxes=new w([...e,...n,...a]),this}getTransform(){throw new Error("not implemented")}}const j=new r,H=new r;class V{constructor(t=[0,0,1],e=0){this.normal=new r,this.distance=-0,this.fromNormalDistance(t,e)}fromNormalDistance(t,e){return z(Number.isFinite(e)),this.normal.from(t).normalize(),this.distance=e,this}fromPointNormal(t,e){t=j.from(t),this.normal.from(e).normalize();const n=-this.normal.dot(t);return this.distance=n,this}fromCoefficients(t,e,n,a){return this.normal.set(t,e,n),z(W(this.normal.len(),1)),this.distance=a,this}clone(){return new V(this.normal,this.distance)}equals(t){return W(this.distance,t.distance)&&W(this.normal,t.normal)}getPointDistance(t){return this.normal.dot(t)+this.distance}transform(t){const e=H.copy(this.normal).transformAsVector(t).normalize(),n=this.normal.scale(-this.distance).transform(t);return this.fromPointNormal(n,e)}projectPointOntoPlane(t,e=[0,0,0]){const n=j.from(t),a=this.getPointDistance(n),s=H.copy(this.normal).scale(a);return n.subtract(s).to(e)}}const $=[new r([1,0,0]),new r([0,1,0]),new r([0,0,1])],k=new r,wt=new r;class A{constructor(t=[]){this.planes=t}fromBoundingSphere(t){this.planes.length=2*$.length;const e=t.center,n=t.radius;let a=0;for(const s of $){let o=this.planes[a],i=this.planes[a+1];o||(o=this.planes[a]=new V),i||(i=this.planes[a+1]=new V);const l=k.copy(s).scale(-n).add(e);o.fromPointNormal(l,s);const h=k.copy(s).scale(n).add(e),d=wt.copy(s).negate();i.fromPointNormal(h,d),a+=2}return this}computeVisibility(t){let e=p.INSIDE;for(const n of this.planes)switch(t.intersectPlane(n)){case p.OUTSIDE:return p.OUTSIDE;case p.INTERSECTING:e=p.INTERSECTING;break}return e}computeVisibilityWithPlaneMask(t,e){if(z(Number.isFinite(e),"parentPlaneMask is required."),e===A.MASK_OUTSIDE||e===A.MASK_INSIDE)return e;let n=A.MASK_INSIDE;const a=this.planes;for(let s=0;s<this.planes.length;++s){const o=s<31?1<<s:0;if(s<31&&(e&o)===0)continue;const i=a[s],l=t.intersectPlane(i);if(l===p.OUTSIDE)return A.MASK_OUTSIDE;l===p.INTERSECTING&&(n|=o)}return n}}A.MASK_OUTSIDE=4294967295;A.MASK_INSIDE=0;A.MASK_INDETERMINATE=2147483647;new r;new r;new r;new r;new r;new r;new r;new r;new r;new r;new r;new r;new r;new r;new r;new r;new r;const E=new w,xt=new w,Et=new w,_=new w,Z=new w;function Mt(f,t={}){const e=lt,n=10;let a=0,s=0;const o=xt,i=Et;o.identity(),i.copy(f);const l=e*Nt(i);for(;s<n&&At(i)>l;)Tt(i,_),Z.copy(_).transpose(),i.multiplyRight(_),i.multiplyLeft(Z),o.multiplyRight(_),++a>2&&(++s,a=0);return t.unitary=o.toTarget(t.unitary),t.diagonal=i.toTarget(t.diagonal),t}function Nt(f){let t=0;for(let e=0;e<9;++e){const n=f[e];t+=n*n}return Math.sqrt(t)}const Q=[1,0,0],B=[2,2,1];function At(f){let t=0;for(let e=0;e<3;++e){const n=f[E.getElementIndex(B[e],Q[e])];t+=2*n*n}return Math.sqrt(t)}function Tt(f,t){const e=ut;let n=0,a=1;for(let h=0;h<3;++h){const d=Math.abs(f[E.getElementIndex(B[h],Q[h])]);d>n&&(a=h,n=d)}const s=Q[a],o=B[a];let i=1,l=0;if(Math.abs(f[E.getElementIndex(o,s)])>e){const h=f[E.getElementIndex(o,o)],d=f[E.getElementIndex(s,s)],c=f[E.getElementIndex(o,s)],m=(h-d)/2/c;let u;m<0?u=-1/(-m+Math.sqrt(1+m*m)):u=1/(m+Math.sqrt(1+m*m)),i=1/Math.sqrt(1+u*u),l=u*i}return w.IDENTITY.to(t),t[E.getElementIndex(s,s)]=t[E.getElementIndex(o,o)]=i,t[E.getElementIndex(o,s)]=l,t[E.getElementIndex(s,o)]=-l,t}const N=new r,yt=new r,It=new r,Rt=new r,gt=new r,qt=new w,Ct={diagonal:new w,unitary:new w};function Dt(f,t=new X){if(!f||f.length===0)return t.halfAxes=new w([0,0,0,0,0,0,0,0,0]),t.center=new r,t;const e=f.length,n=new r(0,0,0);for(const R of f)n.add(R);const a=1/e;n.multiplyByScalar(a);let s=0,o=0,i=0,l=0,h=0,d=0;for(const R of f){const x=N.copy(R).subtract(n);s+=x.x*x.x,o+=x.x*x.y,i+=x.x*x.z,l+=x.y*x.y,h+=x.y*x.z,d+=x.z*x.z}s*=a,o*=a,i*=a,l*=a,h*=a,d*=a;const c=qt;c[0]=s,c[1]=o,c[2]=i,c[3]=o,c[4]=l,c[5]=h,c[6]=i,c[7]=h,c[8]=d;const{unitary:m}=Mt(c,Ct),u=t.halfAxes.copy(m);let T=u.getColumn(0,It),y=u.getColumn(1,Rt),I=u.getColumn(2,gt),q=-Number.MAX_VALUE,C=-Number.MAX_VALUE,S=-Number.MAX_VALUE,O=Number.MAX_VALUE,b=Number.MAX_VALUE,U=Number.MAX_VALUE;for(const R of f)N.copy(R),q=Math.max(N.dot(T),q),C=Math.max(N.dot(y),C),S=Math.max(N.dot(I),S),O=Math.min(N.dot(T),O),b=Math.min(N.dot(y),b),U=Math.min(N.dot(I),U);T=T.multiplyByScalar(.5*(O+q)),y=y.multiplyByScalar(.5*(b+C)),I=I.multiplyByScalar(.5*(U+S)),t.center.copy(T).add(y).add(I);const v=yt.set(q-O,C-b,S-U).multiplyByScalar(.5),tt=new w([v[0],0,0,0,v[1],0,0,0,v[2]]);return t.halfAxes.multiplyRight(tt),t}export{J as A,G as B,A as C,Pt as E,X as O,V as P,bt as R,Ut as a,ut as b,Dt as m};
