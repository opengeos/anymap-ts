var st=Object.defineProperty;var nt=(m,t,e)=>t in m?st(m,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):m[t]=e;var T=(m,t,e)=>nt(m,typeof t!="symbol"?t+"":t,e);import{S as rt,r as a,J as at,s as Q,f as z}from"./mapbox-overlay-CtMyNbGZ.js";import{M as w,Q as K}from"./quaternion-BcOn_HKL.js";const ot="Queued Requests",ct="Active Requests",it="Cancelled Requests",ut="Queued Requests Ever",lt="Active Requests Ever",ht={id:"request-scheduler",throttleRequests:!0,maxRequests:6,debounceTime:0};class Lt{constructor(t={}){T(this,"props");T(this,"stats");T(this,"activeRequestCount",0);T(this,"requestQueue",[]);T(this,"requestMap",new Map);T(this,"updateTimer",null);this.props={...ht,...t},this.stats=new rt({id:this.props.id}),this.stats.get(ot),this.stats.get(ct),this.stats.get(it),this.stats.get(ut),this.stats.get(lt)}scheduleRequest(t,e=()=>0){if(!this.props.throttleRequests)return Promise.resolve({done:()=>{}});if(this.requestMap.has(t))return this.requestMap.get(t);const n={handle:t,priority:0,getPriority:e},r=new Promise(s=>(n.resolve=s,n));return this.requestQueue.push(n),this.requestMap.set(t,r),this._issueNewRequests(),r}_issueRequest(t){const{handle:e,resolve:n}=t;let r=!1;const s=()=>{r||(r=!0,this.requestMap.delete(e),this.activeRequestCount--,this._issueNewRequests())};return this.activeRequestCount++,n?n({done:s}):Promise.resolve({done:s})}_issueNewRequests(){this.updateTimer!==null&&clearTimeout(this.updateTimer),this.updateTimer=setTimeout(()=>this._issueNewRequestsAsync(),this.props.debounceTime)}_issueNewRequestsAsync(){this.updateTimer!==null&&clearTimeout(this.updateTimer),this.updateTimer=null;const t=Math.max(this.props.maxRequests-this.activeRequestCount,0);if(t!==0){this._updateAllRequests();for(let e=0;e<t;++e){const n=this.requestQueue.shift();n&&this._issueRequest(n)}}}_updateAllRequests(){const t=this.requestQueue;for(let e=0;e<t.length;++e){const n=t[e];this._updateRequest(n)||(t.splice(e,1),this.requestMap.delete(n.handle),e--)}t.sort((e,n)=>e.priority-n.priority)}_updateRequest(t){return t.priority=t.getPriority(t.handle),t.priority<0?(t.resolve(null),!1):!0}}const _t=.1,Vt=1e-12,mt=1e-15,dt=1e-20,p={OUTSIDE:-1,INTERSECTING:0,INSIDE:1},Y=new a,ft=new a;class tt{constructor(t=[0,0,0],e=[0,0,0],n){n=n||Y.copy(t).add(e).scale(.5),this.center=new a(n),this.halfDiagonal=new a(e).subtract(this.center),this.minimum=new a(t),this.maximum=new a(e)}clone(){return new tt(this.minimum,this.maximum,this.center)}equals(t){return this===t||!!t&&this.minimum.equals(t.minimum)&&this.maximum.equals(t.maximum)}transform(t){return this.center.transformAsPoint(t),this.halfDiagonal.transform(t),this.minimum.transform(t),this.maximum.transform(t),this}intersectPlane(t){const{halfDiagonal:e}=this,n=ft.from(t.normal),r=e.x*Math.abs(n.x)+e.y*Math.abs(n.y)+e.z*Math.abs(n.z),s=this.center.dot(n)+t.distance;return s-r>0?p.INSIDE:s+r<0?p.OUTSIDE:p.INTERSECTING}distanceTo(t){return Math.sqrt(this.distanceSquaredTo(t))}distanceSquaredTo(t){const e=Y.from(t).subtract(this.center),{halfDiagonal:n}=this;let r=0,s;return s=Math.abs(e.x)-n.x,s>0&&(r+=s*s),s=Math.abs(e.y)-n.y,s>0&&(r+=s*s),s=Math.abs(e.z)-n.z,s>0&&(r+=s*s),r}}const q=new a,j=new a;class X{constructor(t=[0,0,0],e=0){this.radius=-0,this.center=new a,this.fromCenterRadius(t,e)}fromCenterRadius(t,e){return this.center.from(t),this.radius=e,this}fromCornerPoints(t,e){return e=q.from(e),this.center=new a().from(t).add(e).scale(.5),this.radius=this.center.distance(e),this}equals(t){return this===t||!!t&&this.center.equals(t.center)&&this.radius===t.radius}clone(){return new X(this.center,this.radius)}union(t){const e=this.center,n=this.radius,r=t.center,s=t.radius,o=q.copy(r).subtract(e),i=o.magnitude();if(n>=i+s)return this.clone();if(s>=i+n)return t.clone();const l=(n+i+s)*.5;return j.copy(o).scale((-n+l)/i).add(e),this.center.copy(j),this.radius=l,this}expand(t){const n=q.from(t).subtract(this.center).magnitude();return n>this.radius&&(this.radius=n),this}transform(t){this.center.transform(t);const e=at(q,t);return this.radius=Math.max(e[0],Math.max(e[1],e[2]))*this.radius,this}distanceSquaredTo(t){const e=this.distanceTo(t);return e*e}distanceTo(t){const n=q.from(t).subtract(this.center);return Math.max(0,n.len()-this.radius)}intersectPlane(t){const e=this.center,n=this.radius,s=t.normal.dot(e)+t.distance;return s<-n?p.OUTSIDE:s<n?p.INTERSECTING:p.INSIDE}}const pt=new a,wt=new a,D=new a,L=new a,_=new a,xt=new a,Et=new a,M={COLUMN0ROW0:0,COLUMN0ROW1:1,COLUMN0ROW2:2,COLUMN1ROW0:3,COLUMN1ROW1:4,COLUMN1ROW2:5,COLUMN2ROW0:6,COLUMN2ROW1:7,COLUMN2ROW2:8};class F{constructor(t=[0,0,0],e=[0,0,0,0,0,0,0,0,0]){this.center=new a().from(t),this.halfAxes=new w(e)}get halfSize(){const t=this.halfAxes.getColumn(0),e=this.halfAxes.getColumn(1),n=this.halfAxes.getColumn(2);return[new a(t).len(),new a(e).len(),new a(n).len()]}get quaternion(){const t=this.halfAxes.getColumn(0),e=this.halfAxes.getColumn(1),n=this.halfAxes.getColumn(2),r=new a(t).normalize(),s=new a(e).normalize(),o=new a(n).normalize();return new K().fromMatrix3(new w([...r,...s,...o]))}fromCenterHalfSizeQuaternion(t,e,n){const r=new K(n),s=new w().fromQuaternion(r);return s[0]=s[0]*e[0],s[1]=s[1]*e[0],s[2]=s[2]*e[0],s[3]=s[3]*e[1],s[4]=s[4]*e[1],s[5]=s[5]*e[1],s[6]=s[6]*e[2],s[7]=s[7]*e[2],s[8]=s[8]*e[2],this.center=new a().from(t),this.halfAxes=s,this}clone(){return new F(this.center,this.halfAxes)}equals(t){return this===t||!!t&&this.center.equals(t.center)&&this.halfAxes.equals(t.halfAxes)}getBoundingSphere(t=new X){const e=this.halfAxes,n=e.getColumn(0,D),r=e.getColumn(1,L),s=e.getColumn(2,_),o=pt.copy(n).add(r).add(s);return t.center.copy(this.center),t.radius=o.magnitude(),t}intersectPlane(t){const e=this.center,n=t.normal,r=this.halfAxes,s=n.x,o=n.y,i=n.z,l=Math.abs(s*r[M.COLUMN0ROW0]+o*r[M.COLUMN0ROW1]+i*r[M.COLUMN0ROW2])+Math.abs(s*r[M.COLUMN1ROW0]+o*r[M.COLUMN1ROW1]+i*r[M.COLUMN1ROW2])+Math.abs(s*r[M.COLUMN2ROW0]+o*r[M.COLUMN2ROW1]+i*r[M.COLUMN2ROW2]),h=n.dot(e)+t.distance;return h<=-l?p.OUTSIDE:h>=l?p.INSIDE:p.INTERSECTING}distanceTo(t){return Math.sqrt(this.distanceSquaredTo(t))}distanceSquaredTo(t){const e=wt.from(t).subtract(this.center),n=this.halfAxes,r=n.getColumn(0,D),s=n.getColumn(1,L),o=n.getColumn(2,_),i=r.magnitude(),l=s.magnitude(),h=o.magnitude();r.normalize(),s.normalize(),o.normalize();let f=0,c;return c=Math.abs(e.dot(r))-i,c>0&&(f+=c*c),c=Math.abs(e.dot(s))-l,c>0&&(f+=c*c),c=Math.abs(e.dot(o))-h,c>0&&(f+=c*c),f}computePlaneDistances(t,e,n=[-0,-0]){let r=Number.POSITIVE_INFINITY,s=Number.NEGATIVE_INFINITY;const o=this.center,i=this.halfAxes,l=i.getColumn(0,D),h=i.getColumn(1,L),f=i.getColumn(2,_),c=xt.copy(l).add(h).add(f).add(o),d=Et.copy(c).subtract(t);let u=e.dot(d);return r=Math.min(u,r),s=Math.max(u,s),c.copy(o).add(l).add(h).subtract(f),d.copy(c).subtract(t),u=e.dot(d),r=Math.min(u,r),s=Math.max(u,s),c.copy(o).add(l).subtract(h).add(f),d.copy(c).subtract(t),u=e.dot(d),r=Math.min(u,r),s=Math.max(u,s),c.copy(o).add(l).subtract(h).subtract(f),d.copy(c).subtract(t),u=e.dot(d),r=Math.min(u,r),s=Math.max(u,s),o.copy(c).subtract(l).add(h).add(f),d.copy(c).subtract(t),u=e.dot(d),r=Math.min(u,r),s=Math.max(u,s),o.copy(c).subtract(l).add(h).subtract(f),d.copy(c).subtract(t),u=e.dot(d),r=Math.min(u,r),s=Math.max(u,s),o.copy(c).subtract(l).subtract(h).add(f),d.copy(c).subtract(t),u=e.dot(d),r=Math.min(u,r),s=Math.max(u,s),o.copy(c).subtract(l).subtract(h).subtract(f),d.copy(c).subtract(t),u=e.dot(d),r=Math.min(u,r),s=Math.max(u,s),n[0]=r,n[1]=s,n}transform(t){this.center.transformAsPoint(t);const e=this.halfAxes.getColumn(0,D);e.transformAsPoint(t);const n=this.halfAxes.getColumn(1,L);n.transformAsPoint(t);const r=this.halfAxes.getColumn(2,_);return r.transformAsPoint(t),this.halfAxes=new w([...e,...n,...r]),this}getTransform(){throw new Error("not implemented")}}const H=new a,$=new a;class v{constructor(t=[0,0,1],e=0){this.normal=new a,this.distance=-0,this.fromNormalDistance(t,e)}fromNormalDistance(t,e){return Q(Number.isFinite(e)),this.normal.from(t).normalize(),this.distance=e,this}fromPointNormal(t,e){t=H.from(t),this.normal.from(e).normalize();const n=-this.normal.dot(t);return this.distance=n,this}fromCoefficients(t,e,n,r){return this.normal.set(t,e,n),Q(z(this.normal.len(),1)),this.distance=r,this}clone(){return new v(this.normal,this.distance)}equals(t){return z(this.distance,t.distance)&&z(this.normal,t.normal)}getPointDistance(t){return this.normal.dot(t)+this.distance}transform(t){const e=$.copy(this.normal).transformAsVector(t).normalize(),n=this.normal.scale(-this.distance).transform(t);return this.fromPointNormal(n,e)}projectPointOntoPlane(t,e=[0,0,0]){const n=H.from(t),r=this.getPointDistance(n),s=$.copy(this.normal).scale(r);return n.subtract(s).to(e)}}const k=[new a([1,0,0]),new a([0,1,0]),new a([0,0,1])],Z=new a,Mt=new a;class A{constructor(t=[]){this.planes=t}fromBoundingSphere(t){this.planes.length=2*k.length;const e=t.center,n=t.radius;let r=0;for(const s of k){let o=this.planes[r],i=this.planes[r+1];o||(o=this.planes[r]=new v),i||(i=this.planes[r+1]=new v);const l=Z.copy(s).scale(-n).add(e);o.fromPointNormal(l,s);const h=Z.copy(s).scale(n).add(e),f=Mt.copy(s).negate();i.fromPointNormal(h,f),r+=2}return this}computeVisibility(t){let e=p.INSIDE;for(const n of this.planes)switch(t.intersectPlane(n)){case p.OUTSIDE:return p.OUTSIDE;case p.INTERSECTING:e=p.INTERSECTING;break}return e}computeVisibilityWithPlaneMask(t,e){if(Q(Number.isFinite(e),"parentPlaneMask is required."),e===A.MASK_OUTSIDE||e===A.MASK_INSIDE)return e;let n=A.MASK_INSIDE;const r=this.planes;for(let s=0;s<this.planes.length;++s){const o=s<31?1<<s:0;if(s<31&&!(e&o))continue;const i=r[s],l=t.intersectPlane(i);if(l===p.OUTSIDE)return A.MASK_OUTSIDE;l===p.INTERSECTING&&(n|=o)}return n}}A.MASK_OUTSIDE=4294967295;A.MASK_INSIDE=0;A.MASK_INDETERMINATE=2147483647;new a;new a;new a;new a;new a;new a;new a;new a;new a;new a;new a;new a;new a;new a;new a;new a;new a;const E=new w,Nt=new w,At=new w,V=new w,J=new w;function Tt(m,t={}){const e=dt,n=10;let r=0,s=0;const o=Nt,i=At;o.identity(),i.copy(m);const l=e*yt(i);for(;s<n&&It(i)>l;)Rt(i,V),J.copy(V).transpose(),i.multiplyRight(V),i.multiplyLeft(J),o.multiplyRight(V),++r>2&&(++s,r=0);return t.unitary=o.toTarget(t.unitary),t.diagonal=i.toTarget(t.diagonal),t}function yt(m){let t=0;for(let e=0;e<9;++e){const n=m[e];t+=n*n}return Math.sqrt(t)}const B=[1,0,0],G=[2,2,1];function It(m){let t=0;for(let e=0;e<3;++e){const n=m[E.getElementIndex(G[e],B[e])];t+=2*n*n}return Math.sqrt(t)}function Rt(m,t){const e=mt;let n=0,r=1;for(let h=0;h<3;++h){const f=Math.abs(m[E.getElementIndex(G[h],B[h])]);f>n&&(r=h,n=f)}const s=B[r],o=G[r];let i=1,l=0;if(Math.abs(m[E.getElementIndex(o,s)])>e){const h=m[E.getElementIndex(o,o)],f=m[E.getElementIndex(s,s)],c=m[E.getElementIndex(o,s)],d=(h-f)/2/c;let u;d<0?u=-1/(-d+Math.sqrt(1+d*d)):u=1/(d+Math.sqrt(1+d*d)),i=1/Math.sqrt(1+u*u),l=u*i}return w.IDENTITY.to(t),t[E.getElementIndex(s,s)]=t[E.getElementIndex(o,o)]=i,t[E.getElementIndex(o,s)]=l,t[E.getElementIndex(s,o)]=-l,t}const N=new a,gt=new a,qt=new a,Ct=new a,St=new a,Ot=new w,bt={diagonal:new w,unitary:new w};function vt(m,t=new F){if(!m||m.length===0)return t.halfAxes=new w([0,0,0,0,0,0,0,0,0]),t.center=new a,t;const e=m.length,n=new a(0,0,0);for(const g of m)n.add(g);const r=1/e;n.multiplyByScalar(r);let s=0,o=0,i=0,l=0,h=0,f=0;for(const g of m){const x=N.copy(g).subtract(n);s+=x.x*x.x,o+=x.x*x.y,i+=x.x*x.z,l+=x.y*x.y,h+=x.y*x.z,f+=x.z*x.z}s*=r,o*=r,i*=r,l*=r,h*=r,f*=r;const c=Ot;c[0]=s,c[1]=o,c[2]=i,c[3]=o,c[4]=l,c[5]=h,c[6]=i,c[7]=h,c[8]=f;const{unitary:d}=Tt(c,bt),u=t.halfAxes.copy(d);let y=u.getColumn(0,qt),I=u.getColumn(1,Ct),R=u.getColumn(2,St),C=-Number.MAX_VALUE,S=-Number.MAX_VALUE,O=-Number.MAX_VALUE,b=Number.MAX_VALUE,U=Number.MAX_VALUE,P=Number.MAX_VALUE;for(const g of m)N.copy(g),C=Math.max(N.dot(y),C),S=Math.max(N.dot(I),S),O=Math.max(N.dot(R),O),b=Math.min(N.dot(y),b),U=Math.min(N.dot(I),U),P=Math.min(N.dot(R),P);y=y.multiplyByScalar(.5*(b+C)),I=I.multiplyByScalar(.5*(U+S)),R=R.multiplyByScalar(.5*(P+O)),t.center.copy(y).add(I).add(R);const W=gt.set(C-b,S-U,O-P).multiplyByScalar(.5),et=new w([W[0],0,0,0,W[1],0,0,0,W[2]]);return t.halfAxes.multiplyRight(et),t}export{tt as A,X as B,A as C,Vt as E,F as O,v as P,Lt as R,_t as a,mt as b,vt as m};
