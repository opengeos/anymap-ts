import{_ as j}from"./preload-helper-PPVm8Dsz.js";let $=null;function J(){return $||($=new x),$}class x{_duckdb=null;_db=null;_worker=null;_initialized=!1;_initializing=!1;_bundleUrl;constructor(t){this._bundleUrl=t}isReady(){return this._initialized&&this._db!==null}async initialize(t){if(!this._initialized){if(this._initializing){for(;this._initializing;)await new Promise(r=>setTimeout(r,50));return}this._initializing=!0;try{t?.({stage:"initializing",percent:0,message:"Loading DuckDB WASM..."});let r;try{const e=await j(()=>import("@duckdb/duckdb-wasm"),[],import.meta.url);r=e.default||e}catch(e){throw new Error(`DuckDB WASM is not installed or failed to load. Install it with: npm install @duckdb/duckdb-wasm. Error: ${e instanceof Error?e.message:"Unknown error"}`)}this._duckdb=r,t?.({stage:"initializing",percent:30,message:"Selecting DuckDB bundle..."});let i;if(this._duckdb.getJsDelivrBundles){const e=this._duckdb.getJsDelivrBundles();i=await this._duckdb.selectBundle(e)}else{const e=this._getJsDelivrBundles();i=await this._duckdb.selectBundle(e)}t?.({stage:"initializing",percent:50,message:"Instantiating DuckDB..."});const h=new this._duckdb.ConsoleLogger(4);let l,a=null;try{a=URL.createObjectURL(new Blob([`importScripts("${i.mainWorker}");`],{type:"text/javascript"})),l=new Worker(a)}catch(e){throw a&&URL.revokeObjectURL(a),new Error(`Failed to create DuckDB worker: ${e instanceof Error?e.message:"Unknown error"}`)}this._worker=l;const m=new this._duckdb.AsyncDuckDB(h,l);try{await m.instantiate(i.mainModule,i.pthreadWorker)}catch(e){throw new Error(`Failed to instantiate DuckDB: ${e instanceof Error?e.message:"Unknown error"}`)}a&&URL.revokeObjectURL(a),this._db=m,t?.({stage:"initializing",percent:70,message:"Loading spatial extension..."});const o=await this._db.connect();try{await o.query("INSTALL spatial"),await o.query("LOAD spatial")}catch(e){console.warn("Failed to load spatial extension, some features may not work:",e)}finally{await o.close()}this._initialized=!0,t?.({stage:"initializing",percent:100,message:"DuckDB ready"})}catch(r){throw t?.({stage:"error",message:`Failed to initialize DuckDB: ${r instanceof Error?r.message:"Unknown error"}`}),r}finally{this._initializing=!1}}}_getJsDelivrBundles(){const t=this._bundleUrl||"https://cdn.jsdelivr.net/npm/@duckdb/duckdb-wasm@latest/dist";return{mvp:{mainModule:`${t}/duckdb-mvp.wasm`,mainWorker:`${t}/duckdb-browser-mvp.worker.js`},eh:{mainModule:`${t}/duckdb-eh.wasm`,mainWorker:`${t}/duckdb-browser-eh.worker.js`}}}async convert(t,r,i){const h=performance.now(),l=this._detectFormat(r);if(this.isReady()||await this.initialize(i),!this._db)throw new Error("DuckDB not initialized");i?.({stage:"loading",percent:0,message:`Loading ${r}...`});const a=new Uint8Array(t);await this._db.registerFileBuffer(r,a);const m=await this._db.connect();try{i?.({stage:"converting",percent:30,message:"Reading spatial data..."});let o;l==="geoparquet"||l==="parquet"?o=`read_parquet('${r}')`:o=`ST_Read('${r}')`;const e=(await m.query(`
        DESCRIBE SELECT * FROM ${o}
      `)).toArray();let c=null,w="",p=null,u=null,s=null;const d=[],B=["lat","latitude","y","lat_y","point_y"],S=["lon","lng","long","longitude","x","lon_x","long_x","point_x"],_=["wkt","wkt_geom","wkt_geometry","geometry_wkt"];for(const g of e){const n=g.column_name,E=g.column_type?.toUpperCase()||"",f=n.toLowerCase(),U=E.includes("GEOMETRY"),T=f==="geom"||f==="geometry"||f==="wkb_geometry"||f==="the_geom"||f==="shape",R=E.includes("BLOB")&&T;U||T||R?c||(c=n,w=E):B.includes(f)&&!p?(p=n,d.push(n)):S.includes(f)&&!u?(u=n,d.push(n)):_.includes(f)&&!s?s=n:d.push(n)}let y=!1,L=!1;if(!c)if(s)L=!0;else if(p&&u){y=!0;const g=d.indexOf(p);g>-1&&d.splice(g,1);const n=d.indexOf(u);n>-1&&d.splice(n,1)}else throw new Error("No geometry column found in the file. For CSV/Excel files, include a geometry column, WKT column, or lat/lon columns.");i?.({stage:"converting",percent:50,message:"Converting to GeoJSON..."});const N=d.length>0?`json_object(${d.map(g=>`'${g}', "${g}"`).join(", ")})`:"'{}'::JSON";let k,b;y&&p&&u?(k=`ST_AsGeoJSON(ST_Point("${u}", "${p}"))`,b=`"${p}" IS NOT NULL AND "${u}" IS NOT NULL`):L&&s?(k=`ST_AsGeoJSON(ST_GeomFromText("${s}"))`,b=`"${s}" IS NOT NULL AND "${s}" != ''`):w.includes("BLOB")?(k=`ST_AsGeoJSON(ST_GeomFromWKB("${c}"))`,b=`"${c}" IS NOT NULL`):(k=`ST_AsGeoJSON("${c}")`,b=`"${c}" IS NOT NULL`);const F=(await m.query(`
        SELECT json_object(
          'type', 'Feature',
          'geometry', ${k}::JSON,
          'properties', ${N}
        ) as feature
        FROM ${o}
        WHERE ${b}
      `)).toArray();i?.({stage:"converting",percent:80,message:"Building feature collection..."});const D=[],O=new Set;for(const g of F)if(g.feature)try{const n=typeof g.feature=="string"?JSON.parse(g.feature):g.feature;D.push(n),n.geometry?.type&&O.add(n.geometry.type)}catch(n){console.warn("Failed to parse feature:",n)}const v={type:"FeatureCollection",features:D},z=performance.now(),C={originalFormat:l,featureCount:D.length,geometryTypes:Array.from(O),fileSize:t.byteLength,conversionTimeMs:Math.round(z-h)};return i?.({stage:"complete",percent:100,message:`Converted ${D.length} features`}),{geojson:v,warnings:[],metadata:C}}catch(o){throw i?.({stage:"error",message:`Failed to convert: ${o instanceof Error?o.message:"Unknown error"}`}),o}finally{await m.close();try{await this._db.dropFile(r)}catch{}}}_detectFormat(t){switch(t.toLowerCase().split(".").pop()){case"gpkg":return"geopackage";case"parquet":case"geoparquet":return"geoparquet";case"shp":return"shapefile";case"geojson":case"json":return"geojson";case"kml":return"kml";case"kmz":return"kmz";case"gpx":return"gpx";case"fgb":return"flatgeobuf";case"gml":return"gml";case"topojson":return"topojson";case"csv":return"csv";case"xlsx":case"xls":return"xlsx";case"dxf":return"dxf";default:return"unknown"}}async registerRemoteParquet(t,r){if(this.isReady()||await this.initialize(),!this._db||!this._duckdb)throw new Error("DuckDB not initialized");await this._db.registerFileURL(r,t,this._duckdb.DuckDBDataProtocol.HTTP,!1)}async getParquetSchema(t){if(!this._db)throw new Error("DuckDB not initialized");const r=await this._db.connect();try{const i=(await r.query(`DESCRIBE SELECT * FROM read_parquet('${t}')`)).toArray(),h=i.map(e=>({name:e.column_name,type:e.column_type}));let l=null,a=null;const m=[],o=["geom","geometry","wkb_geometry","the_geom","shape"];for(const e of i){const c=e.column_name,w=e.column_type?.toUpperCase()||"",p=c.toLowerCase(),u=w.includes("GEOMETRY"),s=o.includes(p),d=w.includes("BLOB")&&s;(u||s||d)&&!l?(l=c,a=w):m.push(c)}return{geometryColumn:l,geometryColumnType:a,propertyColumns:m,allColumns:h}}finally{await r.close()}}async queryByBounds(t,r,i,h,l){if(!this._db)throw new Error("DuckDB not initialized");const a=await this._db.connect(),[m,o,e,c]=r;try{const w=h.length>0?`json_object(${h.map(_=>`'${_}', "${_}"`).join(", ")})`:"'{}'::JSON",p=(l?.toUpperCase()||"").includes("BLOB");let u,s;p?(u=`ST_AsGeoJSON(ST_GeomFromWKB("${i}"))`,s=`ST_GeomFromWKB("${i}")`):(u=`ST_AsGeoJSON("${i}")`,s=`"${i}"`);const d=`
        SELECT json_object(
          'type', 'Feature',
          'geometry', ${u}::JSON,
          'properties', ${w}
        ) as feature
        FROM read_parquet('${t}')
        WHERE "${i}" IS NOT NULL
          AND ST_Intersects(
            ${s},
            ST_MakeEnvelope(${m}, ${o}, ${e}, ${c})
          )
      `,B=(await a.query(d)).toArray(),S=[];for(const _ of B)if(_.feature)try{const y=typeof _.feature=="string"?JSON.parse(_.feature):_.feature;S.push(y)}catch(y){console.warn("Failed to parse feature:",y)}return{type:"FeatureCollection",features:S}}finally{await a.close()}}async unregisterFile(t){if(this._db)try{await this._db.dropFile(t)}catch{}}dispose(){this._db&&(this._db.terminate().catch(console.error),this._db=null),this._worker&&(this._worker.terminate(),this._worker=null),this._initialized=!1,this._duckdb=null,$===this&&($=null)}}export{x as DuckDBConverter,J as getDuckDBConverter};
