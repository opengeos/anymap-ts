import{ar as C,a as T,as as D,N as F,at as Y}from"./mapbox-overlay-C46bI65L.js";class J{constructor(t){this.indexStarts=[0],this.vertexStarts=[0],this.vertexCount=0,this.instanceCount=0;const{attributes:e={}}=t;this.typedArrayManager=C,this.attributes={},this._attributeDefs=e,this.opts=t,this.updateGeometry(t)}updateGeometry(t){Object.assign(this.opts,t);const{data:e,buffers:n={},getGeometry:o,geometryBuffer:i,positionFormat:r,dataChanged:l,normalize:y=!0}=this.opts;if(this.data=e,this.getGeometry=o,this.positionSize=i&&i.size||(r==="XY"?2:3),this.buffers=n,this.normalize=y,i&&(T(e.startIndices),this.getGeometry=this.getGeometryFromBuffer(i),y||(n.vertexPositions=i)),this.geometryBuffer=n.vertexPositions,Array.isArray(l))for(const c of l)this._rebuildGeometry(c);else this._rebuildGeometry()}updatePartialGeometry({startRow:t,endRow:e}){this._rebuildGeometry({startRow:t,endRow:e})}getGeometryFromBuffer(t){const e=t.value||t;return ArrayBuffer.isView(e)?D(e,{size:this.positionSize,offset:t.offset,stride:t.stride,startIndices:this.data.startIndices}):null}_allocate(t,e){const{attributes:n,buffers:o,_attributeDefs:i,typedArrayManager:r}=this;for(const l in i)if(l in o)r.release(n[l]),n[l]=null;else{const y=i[l];y.copy=e,n[l]=r.allocate(n[l],t,y)}}_forEachGeometry(t,e,n){const{data:o,getGeometry:i}=this,{iterable:r,objectInfo:l}=F(o,e,n);for(const y of r){l.index++;const c=i?i(y,l):null;t(c,l.index)}}_rebuildGeometry(t){if(!this.data)return;let{indexStarts:e,vertexStarts:n,instanceCount:o}=this;const{data:i,geometryBuffer:r}=this,{startRow:l=0,endRow:y=1/0}=t||{},c={};if(t||(e=[0],n=[0]),this.normalize||!r)this._forEachGeometry((f,h)=>{const u=f&&this.normalizeGeometry(f);c[h]=u,n[h+1]=n[h]+(u?this.getGeometrySize(u):0)},l,y),o=n[n.length-1];else if(n=i.startIndices,o=n[i.length]||0,ArrayBuffer.isView(r))o=o||r.length/this.positionSize;else if(r instanceof Y){const f=this.positionSize*4;o=o||r.byteLength/f}else if(r.buffer){const f=r.stride||this.positionSize*4;o=o||r.buffer.byteLength/f}else if(r.value){const f=r.value,h=r.stride/f.BYTES_PER_ELEMENT||this.positionSize;o=o||f.length/h}this._allocate(o,!!t),this.indexStarts=e,this.vertexStarts=n,this.instanceCount=o;const p={};this._forEachGeometry((f,h)=>{const u=c[h]||f;p.vertexStart=n[h],p.indexStart=e[h];const g=h<n.length-1?n[h+1]:o;p.geometrySize=g-n[h],p.geometryIndex=h,this.updateGeometryAttributes(u,p)},l,y),this.vertexCount=e[e.length-1]}}function S(s,t){const e=t.length,n=s.length;if(n>0){let o=!0;for(let i=0;i<e;i++)if(s[n-e+i]!==t[i]){o=!1;break}if(o)return!1}for(let o=0;o<e;o++)s[n+o]=t[o];return!0}function B(s,t){const e=t.length;for(let n=0;n<e;n++)s[n]=t[n]}function P(s,t,e,n,o=[]){const i=n+t*e;for(let r=0;r<e;r++)o[r]=s[i+r];return o}function M(s,t,e,n,o=[]){let i,r;if(e&8)i=(n[3]-s[1])/(t[1]-s[1]),r=3;else if(e&4)i=(n[1]-s[1])/(t[1]-s[1]),r=1;else if(e&2)i=(n[2]-s[0])/(t[0]-s[0]),r=2;else if(e&1)i=(n[0]-s[0])/(t[0]-s[0]),r=0;else return null;for(let l=0;l<s.length;l++)o[l]=(r&1)===l?n[r]:i*(t[l]-s[l])+s[l];return o}function z(s,t){let e=0;return s[0]<t[0]?e|=1:s[0]>t[2]&&(e|=2),s[1]<t[1]?e|=4:s[1]>t[3]&&(e|=8),e}function k(s,t){const{size:e=2,broken:n=!1,gridResolution:o=10,gridOffset:i=[0,0],startIndex:r=0,endIndex:l=s.length}=t||{},y=(l-r)/e;let c=[];const p=[c],f=P(s,0,e,r);let h,u;const g=w(f,o,i,[]),a=[];S(c,f);for(let m=1;m<y;m++){for(h=P(s,m,e,r,h),u=z(h,g);u;){M(f,h,u,g,a);const d=z(a,g);d&&(M(f,a,d,g,a),u=d),S(c,a),B(f,a),V(g,o,u),n&&c.length>e&&(c=[],p.push(c),S(c,f)),u=z(h,g)}S(c,h),B(f,h)}return n?p:p[0]}const E=0,H=1;function N(s,t=null,e){if(!s.length)return[];const{size:n=2,gridResolution:o=10,gridOffset:i=[0,0],edgeTypes:r=!1}=e||{},l=[],y=[{pos:s,types:r?new Array(s.length/n).fill(H):null,holes:t||[]}],c=[[],[]];let p=[];for(;y.length;){const{pos:f,types:h,holes:u}=y.shift();X(f,n,u[0]||f.length,c),p=w(c[0],o,i,p);const g=z(c[1],p);if(g){let a=L(f,h,n,0,u[0]||f.length,p,g);const m={pos:a[0].pos,types:a[0].types,holes:[]},d={pos:a[1].pos,types:a[1].types,holes:[]};y.push(m,d);for(let G=0;G<u.length;G++)a=L(f,h,n,u[G],u[G+1]||f.length,p,g),a[0]&&(m.holes.push(m.pos.length),m.pos=v(m.pos,a[0].pos),r&&(m.types=v(m.types,a[0].types))),a[1]&&(d.holes.push(d.pos.length),d.pos=v(d.pos,a[1].pos),r&&(d.types=v(d.types,a[1].types)))}else{const a={positions:f};r&&(a.edgeTypes=h),u.length&&(a.holeIndices=u),l.push(a)}}return l}function L(s,t,e,n,o,i,r){const l=(o-n)/e,y=[],c=[],p=[],f=[],h=[];let u,g,a;const m=P(s,l-1,e,n);let d=Math.sign(r&8?m[1]-i[3]:m[0]-i[2]),G=t&&t[l-1],_=0,x=0;for(let I=0;I<l;I++)u=P(s,I,e,n,u),g=Math.sign(r&8?u[1]-i[3]:u[0]-i[2]),a=t&&t[n/e+I],g&&d&&d!==g&&(M(m,u,r,i,h),S(y,h)&&p.push(G),S(c,h)&&f.push(G)),g<=0?(S(y,u)&&p.push(a),_-=g):p.length&&(p[p.length-1]=E),g>=0?(S(c,u)&&f.push(a),x+=g):f.length&&(f[f.length-1]=E),B(m,u),d=g,G=a;return[_?{pos:y,types:t&&p}:null,x?{pos:c,types:t&&f}:null]}function w(s,t,e,n){const o=Math.floor((s[0]-e[0])/t)*t+e[0],i=Math.floor((s[1]-e[1])/t)*t+e[1];return n[0]=o,n[1]=i,n[2]=o+t,n[3]=i+t,n}function V(s,t,e){e&8?(s[1]+=t,s[3]+=t):e&4?(s[1]-=t,s[3]-=t):e&2?(s[0]+=t,s[2]+=t):e&1&&(s[0]-=t,s[2]-=t)}function X(s,t,e,n){let o=1/0,i=-1/0,r=1/0,l=-1/0;for(let y=0;y<e;y+=t){const c=s[y],p=s[y+1];o=c<o?c:o,i=c>i?c:i,r=p<r?p:r,l=p>l?p:l}return n[0][0]=o,n[0][1]=r,n[1][0]=i,n[1][1]=l,n}function v(s,t){for(let e=0;e<t.length;e++)s.push(t[e]);return s}const j=85.051129;function K(s,t){const{size:e=2,startIndex:n=0,endIndex:o=s.length,normalize:i=!0}=t||{},r=s.slice(n,o);A(r,e,0,o-n);const l=k(r,{size:e,broken:!0,gridResolution:360,gridOffset:[-180,-180]});if(i)for(const y of l)b(y,e);return l}function Q(s,t=null,e){const{size:n=2,normalize:o=!0,edgeTypes:i=!1}=e||{};t=t||[];const r=[],l=[];let y=0,c=0;for(let f=0;f<=t.length;f++){const h=t[f]||s.length,u=c,g=O(s,n,y,h);for(let a=g;a<h;a++)r[c++]=s[a];for(let a=y;a<g;a++)r[c++]=s[a];A(r,n,u,c),U(r,n,u,c,e==null?void 0:e.maxLatitude),y=h,l[f]=c}l.pop();const p=N(r,l,{size:n,gridResolution:360,gridOffset:[-180,-180],edgeTypes:i});if(o)for(const f of p)b(f.positions,n);return p}function O(s,t,e,n){let o=-1,i=-1;for(let r=e+1;r<n;r+=t){const l=Math.abs(s[r]);l>o&&(o=l,i=r-1)}return i}function U(s,t,e,n,o=j){const i=s[e],r=s[n-t];if(Math.abs(i-r)>180){const l=P(s,0,t,e);l[0]+=Math.round((r-i)/360)*360,S(s,l),l[1]=Math.sign(l[1])*o,S(s,l),l[0]=i,S(s,l)}}function A(s,t,e,n){let o=s[0],i;for(let r=e;r<n;r+=t){i=s[r];const l=i-o;(l>180||l<-180)&&(i-=Math.round(l/360)*360),s[r]=o=i}}function b(s,t){let e;const n=s.length/t;for(let i=0;i<n&&(e=s[i*t],(e+180)%360===0);i++);const o=-Math.round(e/360)*360;if(o!==0)for(let i=0;i<n;i++)s[i*t]+=o}export{J as T,K as a,N as b,k as c,Q as d};
