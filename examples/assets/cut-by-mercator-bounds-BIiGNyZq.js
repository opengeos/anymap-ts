import{R as C,S as T,W as D,c as F,X as Y}from"./mapbox-overlay-B3MFwkdI.js";class W{constructor(t){this.indexStarts=[0],this.vertexStarts=[0],this.vertexCount=0,this.instanceCount=0;const{attributes:e={}}=t;this.typedArrayManager=C,this.attributes={},this._attributeDefs=e,this.opts=t,this.updateGeometry(t)}updateGeometry(t){Object.assign(this.opts,t);const{data:e,buffers:n={},getGeometry:i,geometryBuffer:o,positionFormat:r,dataChanged:l,normalize:y=!0}=this.opts;if(this.data=e,this.getGeometry=i,this.positionSize=o&&o.size||(r==="XY"?2:3),this.buffers=n,this.normalize=y,o&&(T(e.startIndices),this.getGeometry=this.getGeometryFromBuffer(o),y||(n.vertexPositions=o)),this.geometryBuffer=n.vertexPositions,Array.isArray(l))for(const c of l)this._rebuildGeometry(c);else this._rebuildGeometry()}updatePartialGeometry({startRow:t,endRow:e}){this._rebuildGeometry({startRow:t,endRow:e})}getGeometryFromBuffer(t){const e=t.value||t;return ArrayBuffer.isView(e)?D(e,{size:this.positionSize,offset:t.offset,stride:t.stride,startIndices:this.data.startIndices}):null}_allocate(t,e){const{attributes:n,buffers:i,_attributeDefs:o,typedArrayManager:r}=this;for(const l in o)if(l in i)r.release(n[l]),n[l]=null;else{const y=o[l];y.copy=e,n[l]=r.allocate(n[l],t,y)}}_forEachGeometry(t,e,n){const{data:i,getGeometry:o}=this,{iterable:r,objectInfo:l}=F(i,e,n);for(const y of r){l.index++;const c=o?o(y,l):null;t(c,l.index)}}_rebuildGeometry(t){if(!this.data)return;let{indexStarts:e,vertexStarts:n,instanceCount:i}=this;const{data:o,geometryBuffer:r}=this,{startRow:l=0,endRow:y=1/0}=t||{},c={};if(t||(e=[0],n=[0]),this.normalize||!r)this._forEachGeometry((f,h)=>{const u=f&&this.normalizeGeometry(f);c[h]=u,n[h+1]=n[h]+(u?this.getGeometrySize(u):0)},l,y),i=n[n.length-1];else if(n=o.startIndices,i=n[o.length]||0,ArrayBuffer.isView(r))i=i||r.length/this.positionSize;else if(r instanceof Y){const f=this.positionSize*4;i=i||r.byteLength/f}else if(r.buffer){const f=r.stride||this.positionSize*4;i=i||r.buffer.byteLength/f}else if(r.value){const f=r.value,h=r.stride/f.BYTES_PER_ELEMENT||this.positionSize;i=i||f.length/h}this._allocate(i,!!t),this.indexStarts=e,this.vertexStarts=n,this.instanceCount=i;const p={};this._forEachGeometry((f,h)=>{const u=c[h]||f;p.vertexStart=n[h],p.indexStart=e[h];const g=h<n.length-1?n[h+1]:i;p.geometrySize=g-n[h],p.geometryIndex=h,this.updateGeometryAttributes(u,p)},l,y),this.vertexCount=e[e.length-1]}}function S(s,t){const e=t.length,n=s.length;if(n>0){let i=!0;for(let o=0;o<e;o++)if(s[n-e+o]!==t[o]){i=!1;break}if(i)return!1}for(let i=0;i<e;i++)s[n+i]=t[i];return!0}function B(s,t){const e=t.length;for(let n=0;n<e;n++)s[n]=t[n]}function P(s,t,e,n,i=[]){const o=n+t*e;for(let r=0;r<e;r++)i[r]=s[o+r];return i}function M(s,t,e,n,i=[]){let o,r;if(e&8)o=(n[3]-s[1])/(t[1]-s[1]),r=3;else if(e&4)o=(n[1]-s[1])/(t[1]-s[1]),r=1;else if(e&2)o=(n[2]-s[0])/(t[0]-s[0]),r=2;else if(e&1)o=(n[0]-s[0])/(t[0]-s[0]),r=0;else return null;for(let l=0;l<s.length;l++)i[l]=(r&1)===l?n[r]:o*(t[l]-s[l])+s[l];return i}function z(s,t){let e=0;return s[0]<t[0]?e|=1:s[0]>t[2]&&(e|=2),s[1]<t[1]?e|=4:s[1]>t[3]&&(e|=8),e}function X(s,t){const{size:e=2,broken:n=!1,gridResolution:i=10,gridOffset:o=[0,0],startIndex:r=0,endIndex:l=s.length}=t||{},y=(l-r)/e;let c=[];const p=[c],f=P(s,0,e,r);let h,u;const g=w(f,i,o,[]),a=[];S(c,f);for(let m=1;m<y;m++){for(h=P(s,m,e,r,h),u=z(h,g);u;){M(f,h,u,g,a);const d=z(a,g);d&&(M(f,a,d,g,a),u=d),S(c,a),B(f,a),V(g,i,u),n&&c.length>e&&(c=[],p.push(c),S(c,f)),u=z(h,g)}S(c,h),B(f,h)}return n?p:p[0]}const E=0,k=1;function H(s,t=null,e){if(!s.length)return[];const{size:n=2,gridResolution:i=10,gridOffset:o=[0,0],edgeTypes:r=!1}=e||{},l=[],y=[{pos:s,types:r?new Array(s.length/n).fill(k):null,holes:t||[]}],c=[[],[]];let p=[];for(;y.length;){const{pos:f,types:h,holes:u}=y.shift();j(f,n,u[0]||f.length,c),p=w(c[0],i,o,p);const g=z(c[1],p);if(g){let a=L(f,h,n,0,u[0]||f.length,p,g);const m={pos:a[0].pos,types:a[0].types,holes:[]},d={pos:a[1].pos,types:a[1].types,holes:[]};y.push(m,d);for(let G=0;G<u.length;G++)a=L(f,h,n,u[G],u[G+1]||f.length,p,g),a[0]&&(m.holes.push(m.pos.length),m.pos=v(m.pos,a[0].pos),r&&(m.types=v(m.types,a[0].types))),a[1]&&(d.holes.push(d.pos.length),d.pos=v(d.pos,a[1].pos),r&&(d.types=v(d.types,a[1].types)))}else{const a={positions:f};r&&(a.edgeTypes=h),u.length&&(a.holeIndices=u),l.push(a)}}return l}function L(s,t,e,n,i,o,r){const l=(i-n)/e,y=[],c=[],p=[],f=[],h=[];let u,g,a;const m=P(s,l-1,e,n);let d=Math.sign(r&8?m[1]-o[3]:m[0]-o[2]),G=t&&t[l-1],_=0,x=0;for(let I=0;I<l;I++)u=P(s,I,e,n,u),g=Math.sign(r&8?u[1]-o[3]:u[0]-o[2]),a=t&&t[n/e+I],g&&d&&d!==g&&(M(m,u,r,o,h),S(y,h)&&p.push(G),S(c,h)&&f.push(G)),g<=0?(S(y,u)&&p.push(a),_-=g):p.length&&(p[p.length-1]=E),g>=0?(S(c,u)&&f.push(a),x+=g):f.length&&(f[f.length-1]=E),B(m,u),d=g,G=a;return[_?{pos:y,types:t&&p}:null,x?{pos:c,types:t&&f}:null]}function w(s,t,e,n){const i=Math.floor((s[0]-e[0])/t)*t+e[0],o=Math.floor((s[1]-e[1])/t)*t+e[1];return n[0]=i,n[1]=o,n[2]=i+t,n[3]=o+t,n}function V(s,t,e){e&8?(s[1]+=t,s[3]+=t):e&4?(s[1]-=t,s[3]-=t):e&2?(s[0]+=t,s[2]+=t):e&1&&(s[0]-=t,s[2]-=t)}function j(s,t,e,n){let i=1/0,o=-1/0,r=1/0,l=-1/0;for(let y=0;y<e;y+=t){const c=s[y],p=s[y+1];i=c<i?c:i,o=c>o?c:o,r=p<r?p:r,l=p>l?p:l}return n[0][0]=i,n[0][1]=r,n[1][0]=o,n[1][1]=l,n}function v(s,t){for(let e=0;e<t.length;e++)s.push(t[e]);return s}const N=85.051129;function J(s,t){const{size:e=2,startIndex:n=0,endIndex:i=s.length,normalize:o=!0}=t||{},r=s.slice(n,i);A(r,e,0,i-n);const l=X(r,{size:e,broken:!0,gridResolution:360,gridOffset:[-180,-180]});if(o)for(const y of l)b(y,e);return l}function K(s,t=null,e){const{size:n=2,normalize:i=!0,edgeTypes:o=!1}=e||{};t=t||[];const r=[],l=[];let y=0,c=0;for(let f=0;f<=t.length;f++){const h=t[f]||s.length,u=c,g=O(s,n,y,h);for(let a=g;a<h;a++)r[c++]=s[a];for(let a=y;a<g;a++)r[c++]=s[a];A(r,n,u,c),U(r,n,u,c,e?.maxLatitude),y=h,l[f]=c}l.pop();const p=H(r,l,{size:n,gridResolution:360,gridOffset:[-180,-180],edgeTypes:o});if(i)for(const f of p)b(f.positions,n);return p}function O(s,t,e,n){let i=-1,o=-1;for(let r=e+1;r<n;r+=t){const l=Math.abs(s[r]);l>i&&(i=l,o=r-1)}return o}function U(s,t,e,n,i=N){const o=s[e],r=s[n-t];if(Math.abs(o-r)>180){const l=P(s,0,t,e);l[0]+=Math.round((r-o)/360)*360,S(s,l),l[1]=Math.sign(l[1])*i,S(s,l),l[0]=o,S(s,l)}}function A(s,t,e,n){let i=s[0],o;for(let r=e;r<n;r+=t){o=s[r];const l=o-i;(l>180||l<-180)&&(o-=Math.round(l/360)*360),s[r]=i=o}}function b(s,t){let e;const n=s.length/t;for(let o=0;o<n&&(e=s[o*t],(e+180)%360===0);o++);const i=-Math.round(e/360)*360;if(i!==0)for(let o=0;o<n;o++)s[o*t]+=i}export{W as T,J as a,H as b,X as c,K as d};
